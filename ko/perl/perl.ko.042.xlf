<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">원격 파일의 이름입니다. 로컬 파일 이름의 경우 $ ff-&amp;gt; output_file의 결과가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">애프터 표시됩니다 테스트의 이름 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;not ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">시험 명. 일반적으로 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">OP의 targ가있는 변수의 이름 (있는 경우), 그렇지 않으면 문자 t 뒤에 OP의 targ가 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">이 대상의 이름은 tardist에 의해 생성 된 tarball의 이름입니다. 이 목표는 distdir을 tarball로 바꾸는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">이 대상의 이름은 zipdist에 의해 생성 된 zip 파일의 이름입니다. 이 대상은 distdir을 zip 파일로 변환하는 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">이름 또는 URL 또는 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다. 예를 들어 &quot;L &amp;lt;Perl Functions | perlfunc&amp;gt;&quot;에서 이름 (페이지라고도 함)은 &quot;perlfunc&quot;입니다. &quot;L &amp;lt;/ CAVEATS&amp;gt;&quot;에서 이름은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">반환 된 이름은 가능한 경우 코드 포인트의 &quot;최고&quot;(아래에 정의 된) 공식 이름 또는 별명입니다. 그렇지 않으면 정의 된 경우 사용자 정의 별명; 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 즉, 개인용 사용 코드 포인트와 같이 공식 유니 코드 이름 (또는 별명)이없는 코드 포인트에 대해서만 별명이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">이름 사양에는 옵션 이름이 포함되며 선택적으로 세로 막대 문자로 구분 된 대체 이름 목록이옵니다.</target>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">패드 이름 구조체에 저장된 이름입니다. 대상 슬롯에 대해 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">이라는 이름 &lt;code&gt;gv_stash*v&lt;/code&gt; 원하는 심볼 테이블에 원하는 패키지의 이름입니다. 기본 패키지는 &lt;code&gt;main&lt;/code&gt; 입니다. 중첩 된 패키지가 여러 개인 경우, 이름을 Perl 언어 자체에서와 같이 &lt;code&gt;::&lt;/code&gt; 로 구분 하여 &lt;code&gt;gv_stash*v&lt;/code&gt; 로 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">C의 &lt;code&gt;argv[0]&lt;/code&gt; 또는 (지원되는 경우) 에서 현재 Perl 사본을 실행하는 데 사용되는 이름</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">이름</target>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">이름은 이전 스타일입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">패드 항목과 관련된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">이름은 효율성을 위해 추가 &lt;b&gt;LENGTH&lt;/b&gt; 콜백 이있는 &lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt; 메소드 이름과 유사하게 선택되었습니다 . 그러나 명명 된 캡처 변수는 현재 내부적으로 연결되어 있지 않지만 마술을 통해 구현됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">내보낼 수없는 기호 이름은 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 배열에 나열되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">보고서에 포함 할 하나 이상의 패치 파일 또는 기타 텍스트 첨부 파일의 이름입니다. 여러 파일은 쉼표로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">상수의 이름은 길이별로 그룹화됩니다. 이 번호 이상의 이름을 가진 각 그룹에 대한 하위 서브 루틴을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">필드의 이름은 &lt;code&gt;overview_fmt&lt;/code&gt; 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">신호의 이름은 시스템에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 로 표시되거나 CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal을&lt;/a&gt; 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma에 의한 인코딩 이름 지정은 유연한 이름을 허용합니다. &lt;code&gt;koi8-r&lt;/code&gt; 및 &lt;code&gt;KOI8R&lt;/code&gt; 은 모두 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">마지막 파이프 닫기, 백틱 ( &lt;code&gt;``&lt;/code&gt; ) 명령, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 호출 성공 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 연산자 에서 리턴 된 기본 상태 입니다. POSIX 유사 시스템에서이 값은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈에서 제공하는 WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG 및 WIFCONTINUED 함수를 사용하여 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">당연한 질문 : &quot;펄은 왜 그 차이를 보상 할 수 없습니까?&quot; 답을 보증합니다. 좋은 이유 중 하나는 C 컴파일러가 (ANSI가 아닌) 확장을 제공하여 개별 구조 필드 수준에서도 구조가 정렬되는 방식에 대한 모든 종류의 멋진 제어를 허용 할 수 있기 때문입니다. 그리고 이것이 충분 하지 않으면 다음 항목의 정렬에서만 채우기 바이트의 양을 도출 할 수없는 &lt;code&gt;union&lt;/code&gt; 이라는 교활한 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">이를 수행하는 자연적인 방법은 키가 국가 이름 인 해시를 갖는 것입니다. 각 국가 이름 키와 관련된 것은 해당 국가의 도시 목록입니다. 입력 줄을 읽을 때마다 국가와 도시로 나누고 해당 국가에 이미 알려진 도시 목록을 찾은 다음 새 도시를 목록에 추가하십시오. 입력을 읽었 으면 평소처럼 해시를 반복하여 인쇄하기 전에 각 도시 목록을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">부정은 부정 클래스를 정의하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">이 매크로의 부정, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; 는 뿐만 아니라도 사용할 수 있습니다 &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; 및 &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; 널 (NULL) 포인터 검사를 생략하다.</target>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">이 매크로의 부정 인 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; 는 NULL 포인터 검사를 필요 로하지 &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; 및 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; 뿐만 아니라 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">새 클래스에는 구조체 객체를 생성하기위한 &lt;code&gt;new&lt;/code&gt; 생성자 메서드가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">데이터베이스를 작성할 때 새 비교 기능을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">USE_PERLIO 구현에 대한 새로운 인터페이스. &quot;: crlf&quot;및 &quot;: raw&quot;레이어는 다른 구현에 허용되는 레이어 일 뿐이며 자동 무시됩니다. (perl5.8부터 &quot;: raw&quot;는 더 이상 사용되지 않습니다.) 휴대용 케이스의 경우 아래 PerlIO_binmode ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">새로운 키는</target>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">새로운 perlIO 레이어가 사용됩니다. NI-S가 가장 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">적격 패키지없이 내장 함수가 호출 될 때마다 새 루틴이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">새 시맨틱은 이제 &lt;code&gt;make_path&lt;/code&gt; 및 &lt;code&gt;remove_tree&lt;/code&gt; 에서만 사용할 수 있습니다 . 구 시맨틱은 &lt;code&gt;mkpath&lt;/code&gt; 와 &lt;code&gt;rmtree&lt;/code&gt; 를 통해서만 사용할 수 있습니다 . 놀라움을 피하기 위해 최소한 2.08로 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">진정한 새로운 기능 또는 까다로운 리팩토링의 새로운 결과는 이제 준비되어 올바르게 내보내집니다. 그렇다면 무엇이 잘못 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">인수없이 &lt;code&gt;XSLoader::load()&lt;/code&gt; 를 호출하는 새로운 간단한 방법 은 Perl 5.8.4 및 5.8.5에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">새로운 스레드 생성은 20 행입니다. 생성 한 대기열과 찾은 소수에 대한 참조를 전달합니다. 21 행부터 24 행까지, 우리는 새로운 쓰레드가 생성되었는지 확인하고, 그렇지 않으면 큐에 남아있는 숫자의 체크를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">new () 함수는 시스템에 설치된 모든 .packlist를 검색하고 내용을 저장합니다. .packlist는 아래 설명 된 기능으로 쿼리 할 수 ​​있습니다. 기본적으로 검색되는 위치는 &lt;code&gt;%Config::Config&lt;/code&gt; 에있는 설정 및 PERL5LIB 환경 변수의 값 에 따라 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">최신 스타일은 다음과 같이 밑줄로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">새로 작성된 서브 루틴은 전달 된 SV에 대한 참조의 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">다음 8 비트는 프로그램의 종료 상태를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">다음 예제는 필요한 경우 반환 값에 명시 적 undef를 배치하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">다음 예제는 &lt;code&gt;LimitOutput&lt;/code&gt; 옵션 을 사용하는 방법을 보여줍니다 . 이 경우 두 개의 중첩 루프가 사용됩니다. 외부 루프는 입력 소스에서 데이터를 읽습니다-STDIN 및 내부 루프 는 &lt;code&gt;$input&lt;/code&gt; 이 소진되거나 오류가 발생하거나 스트림의 끝에 도달 할 때까지 &lt;code&gt;inflate&lt;/code&gt; 반복적으로 호출합니다 . 원 포인트 가치가 기억하는이 사용하는 것입니다 &lt;code&gt;LimitOutput&lt;/code&gt; 의 당신은 또한 얻을 옵션을 &lt;code&gt;ConsumeInput&lt;/code&gt; 의 이 훨씬 간단 아래의 코드를 만들어 - 잘으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">다음 예는 늦게 평가 된 각 입력 매개 변수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">다음 예제는 다음 C ++ 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">다음 옵션은 터미널이 지원하는 문자 세트 (일명 문자 세트)를 처리합니다. 일반적으로 CPAN은 영어를 사용하는 영역이므로 문자 집합은 중요하지 않지만 일부 CPAN의 이름은 ASCII 범위를 벗어납니다. 터미널이 UTF-8을 지원하는 경우 다음 질문에 '아니요'라고 말해야합니다. ISO-8859-1 (LATIN1이라고도 함)이 필요한 경우 예라고 말해야합니다. 두 가지 모두를 지원하지 않으면 일부 저자의 이름을 읽을 수 없으므로 답이 중요하지 않습니다. no로 대답하면 이름이 UTF-8로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es에 대한 다음 포인터 는 분기가 실패 할 경우 실행이 어디로 가야하는지에 대한 점입니다. 실행할 때 엔진이에 지점에서 통과하려고하면, &lt;code&gt;regnext&lt;/code&gt; 지점 아니다 후 엔진이 지점의 전체 세트가 실패했음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">다음 단계는 얻은 텍스트의 보간이며, 이제 구분 기호와 무관합니다. 여러 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">다음 단계는 이메일을 통해 패치를 Perl 코어 티켓 시스템에 제출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">다음 작업은 문제를 정규식으로 쉽게 변환되는 작은 문제로 나누는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">다음에 패치를 만들려면 깨끗한 상태에서 최신 펄에서 시작해야합니다. 펄 체크 아웃에 유지하려는 로컬 변경 사항이나 추가 된 파일이 없는지 확인한 후 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">단순히 테스트 블록을 주석 처리하는 것과 달리, 할 일 테스트에 대한 좋은 부분은 프로그래밍 방식의 할 일 목록을 갖는 것과 같습니다. 수행해야 할 작업량을 알고 버그가 무엇인지 알고 있으며 수정 된 시점을 즉시 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++와 함께 제공되는 nmake는 작성하기에 충분합니다. Visual C에서는 Visual C가 성공적으로 실행되기 전에 콘솔에 특정 항목을 설정해야합니다. 콘솔 박스가 C 컴파일러를 실행할 수있게하려면 미리 &lt;code&gt;vcvars32.bat&lt;/code&gt; 파일을 실행하여 x86-32 및 x86-64 및 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; 또는 &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; 에 대해 컴파일 해야 합니다. Microsoft C 컴파일러 제품의 일반 설치에서 이러한 배치 파일은 이미 &lt;code&gt;PATH&lt;/code&gt; 에 있습니다.환경 변수이므로 콘솔에 절대 경로없이 입력 할 수 있습니다. 배치 파일의 절대 경로를 찾아야하는 경우 일반적으로 C : \ Program Files \ Microsoft Visual Studio \ VC98 \ Bin과 같습니다. 일부 최신 Micrsoft C 제품 (~ 2004 이후 출시)에서는 설치 프로그램이 시작 메뉴에 바로 가기를 추가하여 대상 아키텍처 (x86-32 또는 x86-64 또는 IA64)에 대해 콘솔이 이미 설정된 새 콘솔 창을 시작합니다. . 최신 컴파일러에서는 원하는 경우 이전 배치 파일을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Platform SDK와 함께 제공되는 nmake는 Perl을 빌드하기에 충분합니다. 시작 메뉴에서 플랫폼 SDK를 설치 한 후 사용 가능한 &quot;빌드 환경&quot;쉘 중 하나에 빌드하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">노드 유형 중 하나를 &lt;code&gt;section&lt;/code&gt; 또는 &lt;code&gt;item&lt;/code&gt; . 비공식 유형으로, 예를 들어 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt; 에서 파생 된 &lt;code&gt;hyperlink&lt;/code&gt; 도 있습니다</target>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">비파괴 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;$_&lt;/code&gt; (또는 대체가 &lt;code&gt;=~&lt;/code&gt; 로 바인딩 된 변수) 를 수정하는 대신 대체 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">0이 아닌 숫자</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs가 생성하는 일반적인 Makefile.PL은 mylib 디렉토리에 대해 알지 못합니다. 하위 디렉토리가 있고 그 안에 라이브러리를 생성 할 것임을 알려야합니다. 다음과 같이 MYEXTLIB 인수를 WriteMakefile 호출에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">정상적인 행동 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">이 클래스의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Perl 프로그램을 실행하는 일반적인 방법은 프로그램을 직접 실행 가능하게하거나 소스 파일 이름을 명령 행에 인수로 전달하는 것입니다. (대화식 Perl 환경도 가능 합니다. 자세한 방법 은 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 를 참조하십시오 .) 시작할 때 Perl은 다음 위치 중 하나에서 프로그램을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">이 표기법은 여전히 ​​약간 성가신 것처럼 보이므로 약어가 하나 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">빈 &lt;b&gt;파생 클래스&lt;/b&gt; 는 &lt;b&gt;기본 클래스&lt;/b&gt; 와 정확히 동일하게 동작해야 한다는 개념입니다 .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 에게 일반적인 무언가를하도록 지시 할 수 있으며 객체는 유형에 따라 다른 방식으로 명령을 해석합니다. [&amp;lt;그리스어 &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, 여러 형태.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">잘 작동하는 완전한 간단한 도구 세트를 사용하면 원하는 거의 모든 것을 만들 수 있습니다. 세발 자전거를 조립하는 경우에는 문제가 없지만, 디 프랜차이징 (defranishizing) comboflux regurgalator를 만드는 경우에는 특수 공구를 제작할 수있는 자체 기계 공장이 필요합니다. 펄은 일종의 기계 공장입니다.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">널 파일 핸들 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 은 특별합니다. &lt;b&gt;sed&lt;/b&gt; 및 &lt;b&gt;awk&lt;/b&gt; 의 동작 과 파일 이름 목록을 가져 오는 다른 모든 유닉스 필터 프로그램 을 에뮬레이션하는 데 사용할 수 있습니다 . 에서 입력 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 중 하나를 표준 입력에서 또는 명령 행에 나열된 각 파일에서 비롯됩니다. 작동 방식은 다음과 같습니다. &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 처음 평가되고 &lt;code&gt;@ARGV&lt;/code&gt; 배열이 검사되며 비어 있으면 &lt;code&gt;$ARGV[0]&lt;/code&gt; 이 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 설정되어 열릴 때 표준 입력을 제공합니다. &lt;code&gt;@ARGV&lt;/code&gt; 의 배열은 파일명의리스트로서 처리된다. 루프</target>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">널리스트는 ()로 표시됩니다. 목록에서 보간해도 효과가 없습니다. 따라서 ((), (), ())는 ()와 같습니다. 마찬가지로 요소가없는 배열을 보간하는 것은 해당 시점에 배열이 보간되지 않은 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">널 (null) 루프 시간은 캐시 될 수 있으며 키는 라운드 수입니다. 다음과 같은 호출을 사용하여 캐싱을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">부울 컨텍스트에서 숫자 0, 문자열 &lt;code&gt;'0'&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; , 빈 목록 &lt;code&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 모두 false입니다. 다른 모든 값은 true입니다. 에 의한 진정한 가치의 부정 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;not&lt;/code&gt; 은 특별한 거짓 값을 반환합니다. 문자열로 평가 될 때 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 처리 되지만 숫자로 처리됩니다. 0으로 처리됩니다. true 또는 false를 리턴하는 대부분의 Perl 연산자는이 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl 이후의 숫자 (즉, Perl 5 이후의 5)는 언어 버전뿐만 아니라 perl 인터프리터의 주요 릴리스입니다. 각 주요 버전에는 이전 버전에서 지원할 수없는 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">테스트 실행의 &quot;세대&quot;수입니다. 1 세대는 1 (일)이고 다음 세대는 2, 3 등입니다.</target>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">이 포맷터가 처리 할 동시 작업 수</target>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">av_fill ()이 반환 된 후 배열의 요소 수는 &lt;code&gt;fill + 1&lt;/code&gt; 입니다. 배열이 이전에 더 짧은 경우 추가 된 추가 요소가 NULL로 설정됩니다. 배열이 더 길면 초과 요소가 해제됩니다. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 은 &lt;code&gt;av_clear(av)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">해시의 항목 수는 다음을 수행하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">현재 선택된 출력 채널의 페이지에 남은 줄 수입니다.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">이 줄 이전에 읽은 줄 수에 1을 더한 값. 1 Perl은 열린 각 소스 또는 입력 파일에 대해 별도의 줄 번호를 유지합니다. 현재 소스 파일의 행 번호는 &lt;code&gt;__LINE__&lt;/code&gt; 로 표시됩니다 . 현재 입력 라인 번호 ( &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 를 통해 가장 최근에 읽은 파일의 경우 )는 &lt;code&gt;$.&lt;/code&gt; 로 표시됩니다 . ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) 변수 사용 가능한 경우 많은 오류 메시지가 두 값을 모두보고합니다.</target>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">프로그램이 종료되기 전에 실행 된 시간 (초) 또는 시간 종료가 발생하지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">일반 텍스트를 들여 쓰기 할 공백 수와 &lt;code&gt;=over&lt;/code&gt; 블록에 대한 기본 들여 쓰기 기본값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">스크립트의 테스트 수 이것은 모든 ok () 및 skip () 호출을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">TODO 지시문이있는 테스트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">구조가 참조 된 횟수입니다. 이것이 0으로 떨어지면 정규 표현식은 pregfree 호출에 의해 자동으로 해제됩니다. 각 엔진의 &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; 루틴 에서 1로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">테스트가 실패한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">테스트가 통과 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">각 브랜치 내의 번호는 평상시와 같으며,이 구문 다음에 오는 그룹은 하나의 브랜치 만 포함 된 것처럼 번호가 매겨지며, 가장 많은 캡처 그룹이있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">숫자는 객체로 저장되며, 특히 수학 연산 사이에 내부가 언제든지 변경 될 수 있습니다. 개체는 Math :: BigInt 또는 Math :: BigFloat와 같은 다른 클래스에 속할 수도 있습니다. 일반 스칼라로도 함께 혼합하는 것은 특별하지는 않지만 정상이며 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">숫자는 객체로 저장되며, 특히 수학 연산 사이에 내부가 언제든지 변경 될 수 있습니다. 개체는 Math :: BigInt 또는 Math :: BigInt :: Lite와 같은 다른 클래스에 속할 수도 있습니다. 일반 스칼라로도 함께 혼합하는 것은 특별하지는 않지만 정상이며 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정 될 각 작성된 디렉토리 (기본값은 0777)에 적용 할 숫자 권한 모드 입니다. 디렉토리가 이미 존재하여 작성 될 필요가없는 경우 권한이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COP 힌트 플래그의 숫자 값이거나 COP가 아닌 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OP 플래그의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OP 개인 플래그의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">OP 대상의 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OP 유형의 숫자 ​​값 (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">객체는 &lt;code&gt;IO::Handle&lt;/code&gt; 의 하위 클래스로 다시 축복되며 파이프의 읽기 끝에서 핸들이됩니다. 경우 &lt;code&gt;ARGS&lt;/code&gt; 가 다음 주어진 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 라고하며 &lt;code&gt;ARGS&lt;/code&gt; 은 간부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">객체는 &lt;code&gt;IO::Handle&lt;/code&gt; 의 하위 클래스로 다시 축복되며 파이프의 쓰기 끝에서 핸들이됩니다. 경우 &lt;code&gt;ARGS&lt;/code&gt; 가 다음 주어진 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 라고하며 &lt;code&gt;ARGS&lt;/code&gt; 은 간부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">메소드가 호출되는 객체 또는 클래스는 별도 &lt;code&gt;this&lt;/code&gt; 값 이 아니라 메소드의 인수 중 하나로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Digest::MD5&lt;/code&gt; 대한 객체 지향 인터페이스에 대해 설명합니다. 후 &lt;code&gt;Digest::MD5&lt;/code&gt; 객체가 생성되어, 당신은 데이터를 추가하고 마지막으로 적절한 형식으로 다이제스트를 요청합니다. 단일 개체를 사용하여 여러 다이제스트를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">객체 레지스트리는 스레드 복제 후 필드 해시를 복구하는 데에도 사용됩니다. 여기서 전체 오브젝트 레지스트리가 처리됩니다. 거기에서 찾은 모든 참조에 대해, 사용 된 필드 해시가 방문되고 항목이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">객체 레지스트리는 필드 해시 키로 사용 된 참조를 추적합니다. 키는 필드 해시와 같이 참조 주소에서 생성됩니다 (레지스트리가 필드 해시가 아님). 각 값은 원래 참조의 약한 사본 이며 자체적으로 마법 인 &lt;code&gt;SV&lt;/code&gt; 에 저장됩니다 ( &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ). 마법 구조에는 참조와 함께 사용 된 필드 해시 목록 (실제로 또 다른 해시)이 있습니다. weakref가 오래되면 마법이 활성화되고이 목록을 사용하여 사용 된 모든 필드 해시에서 참조를 삭제합니다. 그런 다음 항목이 객체 레지스트리 자체에서 제거됩니다. 암시 적으로, 그것은 마술 구조와 그것이 사용하고있는 스토리지를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; 의해 리턴 된 오브젝트는 런타임에 변경 될 수 있으므로 전역에 저장하지 않고 각 함수 내에서 &lt;code&gt;builder()&lt;/code&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">oct () 함수는 일반적으로 &lt;code&gt;644&lt;/code&gt; 와 같은 문자열을 파일 모드로 변환해야 할 때 사용됩니다 . Perl은 문자열을 필요에 따라 자동으로 숫자로 변환하지만이 자동 변환은 밑이 10 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Application DVD / CD에 제공되는 HP의 공식 (스레드) 빌드는 &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL(PA-RISC&lt;/a&gt; 용) 에 있습니다 . 및 IPF (이타 늄 프로세서 제품군). HP ANSI-C 컴파일러로 빌드됩니다. ActiveState가 수행 한 5.8.8까지.</target>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">perl 개발을위한 공식 포럼은 위에서 언급 한 perl5-porters 메일 링리스트와 rt.perl.org의 버그 추적기입니다. 토론에 참여한 모든 참가자는 표준 행동 기준을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">이 글을 쓰는 시점에서 VMS의 공식 명칭은 OpenVMS입니다.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">버클리 DB의 공식 웹 사이트는</target>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 를 &lt;code&gt;FALSE&lt;/code&gt; 값 으로 설정하면 즉각적인 크로 킹의 이전 동작을 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 값을 가질 수있는 이전 표시 형식 스타일 은 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 매개 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn ()의 이전 형식입니다. flags 매개 변수가 없으므로 UTF8 문자열에서는 작동하지 않습니다. 경우] &lt;code&gt;multi&lt;/code&gt; 파라미터가 설정되어 상기 플래그가 GV_ADDMULTI gv_init_pvn에 전달한다 ().</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">모듈 테스트를위한 오래된 집은 여기에 새로운 것을 넣지 말아야합니다. 여전히 움직일 필요가있는 몇 가지 비트와 조각이 여기에 있습니다. 아마도 당신은 그들을 움직일 수 있습니까? 감사!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">이전 패키지 구분 기호는 작은 따옴표 였지만 이제는 이중 콜론이 선호되는 구분 기호입니다. 부분적으로는 사람이 더 읽기 쉽고 일부는 &lt;b&gt;emacs&lt;/b&gt; 매크로 에서 더 읽기 &lt;b&gt;쉽습니다&lt;/b&gt; . 또한 C ++ 프로그래머는 작은 따옴표를 구분 기호로 사용하는 것과 달리 Ada 프로그래머가 무슨 일이 일어나고 있는지 알고있는 것처럼 느끼게하는 것과는 달리 진행 상황을 알고있는 것처럼 느끼게합니다. 구식 구문은 이전 버전과의 호환성을 위해 계속 지원되므로 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 와 같은 문자열을 사용하려고하면 &lt;code&gt;$owner::s&lt;/code&gt; 액세스하게됩니다 . 즉, package &lt;code&gt;owner&lt;/code&gt; 의 $ s 변수 는 아마도 의도하지 않은 것입니다. &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 와 같이 중괄호를 사용하여 명확하게하십시오..</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">오래된 (그리고 쓸모가없는) 라이브러리 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">이전 라이브러리 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits ()의 한 인수 형식은 $ bitstring &quot;1&quot;및 &quot;0&quot;문자를 인수로 사용합니다. &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 의 줄임말입니다 .</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">하나의 매개 변수 호출 규칙도 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일을&lt;/b&gt; 완전히 제어 할 수있는 한 명의 사용자 (수퍼 유저 제외) . 파일 에는 실제 소유자가 허용하는 경우 공동 소유권을 행사할 수있는 사용자 &lt;b&gt;그룹&lt;/b&gt; 이 있을 수도 있습니다 . &lt;b&gt;권한 비트를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">유일한 필수 방법입니다. 레이어가 스택으로 밀릴 때 호출됩니다. &lt;code&gt;mode&lt;/code&gt; 이 포스트 오픈 발생하면 인수는 NULL이 될 수 있습니다. &lt;code&gt;arg&lt;/code&gt; 아닌 것 &lt;code&gt;NULL&lt;/code&gt; 인수 문자열이 전달 된 경우. 대부분의 경우 레이어 자체에서 수행하는 작업 외에도 &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; 를 호출 하여 &lt;code&gt;mode&lt;/code&gt; 를 적절한 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 플래그 로 변환 해야합니다 . 레이어가 인수를 기대하지 않으면 전달 된 레이어를 저장할 필요도없고 &lt;code&gt;Getarg()&lt;/code&gt; 제공 할 필요도 없습니다 (아마도 &lt;code&gt;Perl_warn&lt;/code&gt; 이 인수가 예상치 않았을 수도 있음 ).</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">유일한 차이점은 &lt;code&gt;string_vianame&lt;/code&gt; 이 런타임이고 &lt;code&gt;\N{}&lt;/code&gt; 이 컴파일 시간 이라는 사실 때문입니다 . &lt;code&gt;\N{}&lt;/code&gt; 내부에서 보간 할 수 없으므로 &lt;code&gt;\N{$variable}&lt;/code&gt; 이 작동하지 않습니다. 입력 이름을 알 수 없으면 &lt;code&gt;string_vianame&lt;/code&gt; 은 구문 오류가 아닌 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">이번에 지정된 유일한 플래그는 G_SCALAR입니다. 즉, &lt;code&gt;@_&lt;/code&gt; 배열이 만들어지고 값이</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">유일한 보간은 &lt;code&gt;\\&lt;/code&gt; 쌍에서 &lt;code&gt;\&lt;/code&gt; 를 제거하는 것입니다 . 따라서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 문자 그대로 하이픈으로 취급되며 사용 가능한 문자 범위가 없습니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;\1&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">남아있는 유일한 문제는 부트 스트랩 방법입니다.</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">유일한 간단한 설명은 부작용에 대해 평가 된 표현식입니다. 모든 간단한 명령문은 블록의 마지막 명령문이 아닌 경우 세미콜론으로 끝나야합니다.이 경우 세미콜론은 선택 사항입니다. 그러나 블록이 둘 이상의 라인을 차지하면 세미콜론을 넣으십시오. 결국 다른 라인을 추가 할 수 있습니다. 이 같은 사업자이다하는 것으로 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 있음</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">이 pragma의 합법적 인 사용은 파일이 하나의 인코딩으로 만 작성 될 가능성이 높기 때문에 파일 범위와 함께 파일 당 하나당 거의 확실하게 파일 당 하나입니다. v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;이전의&lt;/a&gt; Perls에는 추가 제한 사항이 적용됩니다 ( Perl v5.22 이전 참조 ).</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl이 지원할 수있는 유일한 멀티 바이트 (또는 넓은 문자) 로케일은 UTF-8입니다. 구현의 어려움, 고품질 UTF-8 로케일이 이제 전세계의 모든 영역 ( &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; )에 대해 게시되어 있으며 , 모든 것이 실패하기 때문입니다. &lt;a href=&quot;encode&quot;&gt;인코딩을&lt;/a&gt; 사용할 수 있습니다로케일로 /에서 번역 할 수있는 모듈. 따라서 Big5 또는 Shift JIS와 같은 이러한 로캘 중 하나를 사용하는 경우 이러한 작업 중 하나를 수행해야합니다. UTF-8 로케일의 경우, UTF-8 로케일이 완전히 지원되지 않는 Perls (이전 v5.20)에서는 로컬 라이브러리와 Perl이 모두 차지하는 문자를 저장하므로 C 라이브러리 구현에 따라 합리적으로 잘 작동 할 수 있습니다. 같은 방식으로 여러 바이트. 그러나 대부분은 아니지만 일부 C 라이브러리 구현은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 에서 라틴 -1 범위 (128-255)의 상반부에있는 문자를 제대로 처리하지 못할 수 있습니다 . 로케일에서 문자가 특정 유형인지 확인하기 위해 Perl은 &lt;code&gt;isalnum()&lt;/code&gt; 과 같은 함수를 사용합니다 . C 라이브러리는 이러한 기능을 가진 UTF-8 로켈에서 작동하지 않을 수 있습니다.대신 다음과 같은 최신 라이브러리 기능에서만 작동합니다. &lt;code&gt;iswalnum()&lt;/code&gt; Perl이 사용하지 않는 iswalnum () 이러한 멀티 바이트 로케일은 단일 바이트 로케일처럼 취급되며 아래 설명 된 제한 사항이 있습니다. Perl v5.22부터 Perl이 완전히 지원하지 않는 멀티 바이트 로케일을 감지하면 경고 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl이 현재 지원하는 유일한 문자가 아닌 속성은 Named Sequences입니다. 여기서 일련의 코드 포인트에는 이름이 지정되고 일반적으로 단일 엔터티로 취급됩니다. Perl은 &lt;code&gt;\N{...}&lt;/code&gt; 큰 따옴표 구조, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames의 charnames ::&lt;/a&gt; string_vianame (name) , 그리고 &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;Unicode :: UCD의 namedseq ()를 통해이를 지원&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">1 바이트가 아닌 로케일 Perl이 지원하는 유일한 것은 (v5.20부터) UTF-8입니다. 즉, UTF-8이 유니 코드를 의미하기 때문에 255보다 큰 코드 포인트는 어떤 로캘이 적용되는지에 관계없이 유니 코드로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; 사용의 유일한 객관적인 이점 은 디렉토리 핸들을 보유 할 glob를 작성하여 네임 스페이스 오염을 피한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">다른 제약 조건은 실행할 테스트 수를 미리 선언해야한다는 것입니다. 테스트 중에 문제가 발생하여 테스트 프로그램이 중단되거나 테스트 등을 건너 뜁니다. 당신은 이렇게 이렇게 :</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">경고가 발생했을 때 경고가 발생하지 않는 유일한 위치는 최적화로 인해 전체 패턴 일치가 시도되지 않는 경우입니다. 예를 들어, Perl은 문자열이 특정 정규식 패턴과 일치하기 위해서는 문자열에 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 하위 문자열이 포함되어 있음을 알아낼 수 있습니다 . 일치를 시도하기 전에 Perl은 해당 하위 문자열을 찾을 수 있으며, 찾지 못하면 즉시 시도하지 않고 즉시 실패합니다. 따라서 문자열에 유니 코드 위의 코드 포인트가 포함되어 있어도 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">이 단계의 유일한 목적은 필요한 디렉토리를 작성하고 해당 디렉토리의 이름을 알려주는 것입니다. 출력에서 확장의 디렉토리가</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">유일하게 필요한 부분은 모듈의 이름 인 첫 번째 필드입니다 (예 : Foo :: Bar, 즉</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 중요한 값 은 GV_SUPER 및 SVf_UTF8입니다.</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">정적 메소드와 가상 메소드 모두에서 메소드 이름이 스택을 통해 전달되지 않는다는 점에 주목해야합니다. 첫 번째 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">기억해야 할 것은 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perl에서 선언해야 할 것은 보고서 형식과 서브 루틴뿐 아니라 때로는 서브 루틴도 아닙니다. 스칼라 변수가 정의되지 않은 값 (보유 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 그것 이외 인 정의 값이 할당 될 때까지) &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 숫자로 사용될 때 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 처리됩니다 . 문자열로 사용될 때 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 취급됩니다 . 할당되지 않은 참조로 사용될 경우 오류로 취급됩니다. 경고를 활성화하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 문자열 또는 숫자로 취급 할 때마다 초기화되지 않은 값 이 표시됩니다. 보통은 다음과 같은 부울 컨텍스트</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">당신이 절대적으로 유일한 시간</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">이를 변경하는 유일한 방법은 &lt;code&gt;'|'&lt;/code&gt; 에 대한 고유 한 서브 루틴을 제공하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">사전 경고 설정을 대체하는 유일한 방법은 &lt;b&gt;-W&lt;/b&gt; 또는 &lt;b&gt;-X&lt;/b&gt; 명령 행 플래그를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op 트리는 두 가지 방식으로 연결됩니다. 두 개의 &quot;라우트&quot;가 있다고 가정 할 수 있습니다. 두 개의 순서는 트리를 통과 할 수 있습니다. 먼저, 파싱 순서는 파서가 코드를 이해 한 방법을 반영하고, 둘째로 실행 순서는 펄에게 연산 수행 순서를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">코드 블록을 나타내는 op 트리가 반환됩니다. 이것은 항상 실제 작업이며 null 포인터는 아닙니다. 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 op를 포함 하여 &lt;code&gt;lineseq&lt;/code&gt; 목록 이됩니다 . 모든 종류의 런타임 범위를 구성하는 작전은 그것이 블록이기 때문에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">식을 나타내는 op 트리가 반환됩니다. 선택적 표현식이 없으면 널 포인터가 리턴되고 그렇지 않으면 포인터가 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">명령문을 나타내는 op 트리가 리턴됩니다. 명령문이 널 (null) 인 경우, 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이있는) 인 경우 널 포인터 일 수 있습니다. null이 아닌 경우는, 문장을 직접 구현해 &lt;a href=&quot;#newSTATEOP&quot;&gt;opSTATEOP&lt;/a&gt; 에 건네주는 조작이 됩니다. 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 op를 포함하지 않습니다 (문에 완전히 포함 된 범위에 포함 된 것을 제외).</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">명령문을 나타내는 op 트리가 리턴됩니다. 명령문이 널 (null) 인 경우, 예를 들어 실제로 서브 루틴 정의 (컴파일 시간 부작용이있는) 인 경우 널 포인터 일 수 있습니다. null가 아닌 경우는 결과가 될 것입니다 &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP에&lt;/a&gt; 일반적으로 포함 호출, &lt;code&gt;nextstate&lt;/code&gt; 또는 이에 상응하는 연산.</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">명령문 순서를 나타내는 op 트리가 리턴됩니다. 명령문이 모두 없거나 예를 들어 명령문이 없거나 서브 루틴 정의 만있는 경우 (컴파일 타임 부작용이있는 경우) 이는 널 포인터 일 수 있습니다. null이 &lt;code&gt;lineseq&lt;/code&gt; 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 또는 이와 동등한 ops를 포함 하는 lineseq 목록이됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op 플래그 (예 : &lt;b&gt;'sK / 2'&lt;/b&gt; )는 ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP 플래그 약어&lt;/a&gt; )에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Larry Wall이 Perl을 위해 만든 오픈 소스 라이센스로 Perl의 유용성, 가용성 및 수정 성을 극대화합니다. 현재 버전은 2입니다 ( &lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2 () 함수는 주어진 $ cmd를 실행하고 읽기를 위해 $ chld_out을 연결하고 쓰기를 위해 $ chld_in을 연결합니다. 시도 할 때 작동해야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">일부 유형의 regop 피연산자는 리터럴 문자열입니다. 다른 사람들에게는 하위 프로그램으로 이어지는 레고 프입니다. 특히, &lt;code&gt;BRANCH&lt;/code&gt; 노드 의 피연산자 는 분기의 첫 번째 regop입니다.</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">운영 체제, 장치 드라이버, C 라이브러리 및 Perl 런타임 시스템은 모두 외부 표현에 관계없이 프로그래머가 단일 문자 ( &lt;code&gt;\n&lt;/code&gt; )를 줄 종결 자로 처리하도록 구성합니다 . 많은 운영 체제에서 기본 텍스트 파일 표현은 내부 표현과 일치하지만 일부 플랫폼에서는 &lt;code&gt;\n&lt;/code&gt; 의 외부 표현 이 둘 이상의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 배열 의 조작은 논리 이름의 변환에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval 옵션의 작동은 약간의 논의를 보증합니다. 다음은 Berkeley DB 1.85 recno 매뉴얼 페이지의 bval 정의입니다.</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">이 방법의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 및 &lt;code&gt;cc&lt;/code&gt; 항목 에도 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">이 방법의 작동은 &lt;code&gt;Config.pm&lt;/code&gt; 의 &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 항목 에도 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">로캘의 영향을받는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">운영자는 &lt;code&gt;not&lt;/code&gt; 에 대한 유효한 키가 아닌 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . 그러나 연산자가 &lt;code&gt;!&lt;/code&gt; 오버로드 된 경우 동일한 구현이 사용 &lt;code&gt;not&lt;/code&gt; (두 연산자가 우선 순위가 다르기 때문에).</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">두 번째 인수와 세 번째 인수가 모두 합법적 인 lvalue 인 경우 연산자를 지정할 수 있습니다 (할당 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;'add [t1]'&lt;/b&gt; 에서와 같이 opname 뒤에 괄호 나 괄호로 묶인 op 관련 정보가있을 수 있습니다 (예 : &lt;b&gt;'[t1]'&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir()&quot;&gt;catdir ()&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spec#catdir&quot;&gt;catdir ()&lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset 및 opset_to_ops 함수를 사용하여 연산자 목록에서 opset으로 변환하고</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">사용 된 optag 이름은 아직 정의되어 있지 않아야합니다 (define_optag는 이미 정의 된 경우 축소됨). Optag 이름은 perl 프로세스에 대해 전역 적이며 일단 정의 된 optag 정의는 변경하거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">최적화 프로그램 별 정보는 정확히 일치하지 않는 문자열에 (느린) 정규식 엔진을 입력하지 않도록하는 데 사용됩니다. 는 IF &lt;code&gt;isall&lt;/code&gt; 의 플래그가 설정되어 최적화 프로그램이 경기를보기 위해 적절한 장소를 발견 할 때, 정규식 엔진에 대한 호출도 피할 수있다.</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">이 옵션은 인수를 사용하지 않으며 &quot;no&quot;또는 &quot;no-&quot;를 접두어로 붙여서 무시할 수 있습니다. 예 : &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 수 없다 &lt;code&gt;--foo&lt;/code&gt; (1의 값이 할당 될 것이다)로서뿐만 아니라 &lt;code&gt;--nofoo&lt;/code&gt; 및 &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (0의 값이 할당 될 것이다). 옵션에 별명이있는 경우 별명에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">이 옵션은 인수를 사용하지 않으며 명령 행에 나타날 때마다 1 씩 증가합니다. 예를 들어 &lt;code&gt;--more --more --more&lt;/code&gt; 와 함께 사용되는 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 는 값을 3 번 증가시켜 값이 3이됩니다 (제공된 값이 0이거나 처음에 정의되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">GetOptions () 함수에 지정된 옵션 이름을 옵션이라고합니다.</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">아래에 정의 된 옵션 이름은 대소 문자를 구분하지 않으며 선택적으로 접두어에 '-'를 붙일 수 있습니다. 따라서 다음은 모두 유효합니다</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">옵션에는 주어진 유형의 인수가 필요합니다. 지원되는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">선택적인 &lt;code&gt;rules&lt;/code&gt; 속성은 테스트를 병렬로 실행하고 순차적으로 실행해야하는 방향을 제공합니다. 규칙 데이터 구조가 제공되지 않으면 모든 테스트를 병렬로 실행할 수있는 기본 데이터 구조가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">선택적 인수는 &lt;code&gt;~&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 로 시작하지 않으면 리터럴 문자열로 간주됩니다 . 이 경우 정규 표현식으로 해석됩니다 (아마도 부정 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">위에 나열된 옵션은 기본 머리글의 일부를 사용자 정의하지만 &lt;code&gt;html_header&lt;/code&gt; 또는 &lt;code&gt;html_footer&lt;/code&gt; 를 설정 하면 내장 머리글 또는 바닥 글이 완전히 무시됩니다. 리터럴 HTML 헤더 및 바닥 글 대신 템플릿 태그를 사용하거나 더 큰 웹 사이트에서 변환 된 POD 페이지를 통합하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">이 인수에 대한 옵션은 재귀 적으로 검색되는 디렉토리 또는 파일 목록입니다. (일반적으로 파일을 지정하지 않고 단지 dirs 일뿐입니다.) 또는 $ name2path와 같이 빈 목록을 지정할 수도 있습니다. 와 &lt;code&gt;inc&lt;/code&gt; 는 기본적으로 한,에 대한 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optree는 스레드간에 공유됩니다. 이는 optree가이를 생성 한 특정 스레드 (및 인터프리터 인스턴스)보다 오래 지속될 가능성이 있으므로 true Perl 스칼라를 optree에 저장할 수 없음을 의미합니다. 대신 정수 (부호 및 부호없는), 문자열 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 참조 값 및 부동 소수점 값만 문자열화할 수있는 간단한 형식이 사용됩니다 . 여러 값 또는 복잡한 구조를 저장해야하는 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 같이 직렬화해야합니다 . &lt;code&gt;%^H&lt;/code&gt; 에서 해시 키 삭제 가 기록되며, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용 하여 값이있는 키의 존재와 구별 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">프로그램이 종료되기 전에 전역 소멸 중에 오브젝트가 소멸되는 순서는 예측할 수 없습니다. 즉, 개체에 포함 된 모든 개체가 이미 손상되었을 수 있습니다. 메소드를 호출하기 전에 포함 된 오브젝트가 정의되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">주어진 테스트 스위트 결과에 대해이 테스트가 실행 된 순서.</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;문자가&lt;/b&gt; 정렬 되는 순서 입니다. 예를 들어이 용어집에서 &quot;collating sequence&quot;를 배치 할 위치를 결정하기 위해 &lt;b&gt;문자열&lt;/b&gt; 비교 루틴에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">인수의 순서는 open2 ()의 순서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">인수의 순서는 open3 ()의 순서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">순서는 EXPR의 결과 인 정규식 또는 캡처 그룹에 포함 된 패턴과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">원래 &lt;code&gt;MD5&lt;/code&gt; 인터페이스는 Neil Winton ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ) 이 작성했습니다. ) .</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">딜런 원본</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">원래 Pod :: Text에는 termcap 시퀀스를 통해 서식을 지정하는 코드가 포함되어 있지만 기본적으로 설정되어 있지 않으며 전혀 작동하지 않는 문제가있었습니다. 이 재 작성은 그렇게하려고 시도하지 않지만 하위 클래스는 그렇게합니다. &lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap을&lt;/a&gt; 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">원래 UTF-8 사양은 최대 6 바이트를 허용하여 최대 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 의 숫자 인코딩을 허용합니다. 합니다. Perl은이를 계속 허용하며 64 비트 워드에 맞는 코드 포인트를 인코딩하기 위해 최대 13 바이트까지 확장했습니다. 그러나 Perl은이 중 하나를 이식 불가능한 것으로 출력하면 경고합니다. 엄격한 UTF-8 입력 프로토콜에서는 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">대중 대중 주의적 인터넷의 원래 문화와 Perl의 저자 Larry Wall의 깊은 신념은 Perl의 자유롭고 개방 된 배포 정책을 일으켰습니다. Perl은 사용자가 지원합니다. 핵심, 표준 Perl 라이브러리, 옵션 모듈 및 읽고있는 문서는 모두 자원 봉사자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt; 의 원래 형식으로 , 이전 버전과의 호환성을 위해 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 플래그를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN 메타 파일의 원래 형식은 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; 이며 해당 파일이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">소스 필터의 원래 목적은 일반적인 불법 복제를 방지하기 위해 프로그램 소스를 암호화 할 수 있도록하는 것입니다. 곧 배울 수 있듯이 이것이 그들이 할 수있는 전부는 아닙니다. 그러나 먼저 기본 사항.</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB의 원래 스택 마크입니다. &lt;code&gt;dORIGMARK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">원래 스타일은 다음과 같이 블록 이름에 공백과 하이픈을 사용합니다 ( &lt;code&gt;No_Block&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">원래 제목은</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terse의 원래 버전은 Malcolm Beattie (&amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;)가 작성했습니다. 이 래퍼는 Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISC의 원래 버전 인 HP는 더 이상이 칩이있는 시스템을 판매하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 기사의 원래 버전은 원래 Perl Journal # 10에 실 렸으며 1998 년 저작권 Perl Journal에 저작권이 있습니다. Jon Orwant와 The Perl Journal이 제공 한 것으로 보입니다. 이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">Andy Dougherty가 쓴 원본</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">다른 &lt;code&gt;OA_*&lt;/code&gt; 상수는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">다른 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 방법이 의미 만에 한 번 호출 할 수 &lt;code&gt;$parser&lt;/code&gt; 객체; 그러나 마지막 호출 (및 마지막 호출 만)이 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값으로 끝나는 한 &lt;code&gt;$parser&lt;/code&gt; 객체 당 &lt;code&gt;parse_lines&lt;/code&gt; 를 원하는만큼 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; 를 알고 있다면 다른 인수는 익숙해 보일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; 또 다른 큰 문제 는 코드의 예기치 않은 위치에서 실수로 경고 설정을 변경할 수있는 방법입니다. 예를 들어, 아래 코드가 실행되면 ( &lt;b&gt;-w&lt;/b&gt; 플래그 없이 ) 두 번째 &lt;code&gt;doit&lt;/code&gt; 호출 은 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 경고를 트립 하지만 첫 번째 코드는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">다른 경우에는 좀 더 복잡한 절차가 필요합니다. 아래에서는 Perl의 현재 버전이 &lt;code&gt;5.8.2&lt;/code&gt; 라고 가정 하여 실행 파일의 이름이 적절하게 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">&quot;Full-range Unicode&quot;열에있는 다른 상대방은 전체 유니 코드 문자 집합의 해당 문자와 ​​일치합니다. 예를 들어, &lt;code&gt;\p{Alpha}&lt;/code&gt; 는 ASCII 알파벳 문자뿐만 아니라 전체 유니 코드 문자 집합의 모든 문자가 알파벳으로 간주됩니다. &quot;백 슬래시 시퀀스&quot;라고 표시된 열의 항목은 (짧은) 항목입니다.</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">다른 해킹은 dlopen () 호출 후 FP 플래그를 복원하는 것입니다. 이는 런타임시 DLL _DLLInitTerm ()에 의해 수행 된 유사한 손상을 방지하는 데 도움이됩니다. 현재 이러한 핵을 끄는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">다른 하나는 임시 위치에 모듈을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">다른 수정은</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">다른 변수의 이름을 유지하기 위해 변수를 사용하는 것이 나쁜 생각 인 또 다른 이유는 문제는 종종 Perl 데이터 구조, 특히 해시에 대한 이해가 부족하기 때문입니다. 기호 참조를 사용 하면 사용자 정의 해시 대신 패키지의 기호 테이블 해시 (예 : &lt;code&gt;%main::&lt;/code&gt; :)를 사용하면됩니다. 해결책은 자신의 해시 또는 실제 참조를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">다른 구조는 &lt;code&gt;regexp&lt;/code&gt; 구조체의 &lt;code&gt;pprivate&lt;/code&gt; 에 의해 &lt;code&gt;intflags&lt;/code&gt; 되며 정규 표현식을 컴파일 한 regex 엔진의 속성으로 간주되는 동일한 구조체의 intflags 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">아래에 설명 된 다른 동기화 프리미티브도 비슷한 문제를 겪을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 필드 구분 기호입니다. 정의 된 경우이 값은 각 인쇄 인수 사이에 인쇄됩니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">인쇄 할 출력 파일입니다. 특수 이름 &quot;-&quot;또는 &quot;&amp;gt; &amp;amp; 1&quot;또는 &quot;&amp;gt; &amp;amp; STDOUT&quot;이 사용되면 표준 출력이 사용됩니다. &quot;&amp;gt; &amp;amp; 2&quot;또는 &quot;&amp;gt; &amp;amp; STDERR&quot;을 사용하면 표준 오류가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">출력 파일은 Perl의 아키텍처 종속 라이브러리 디렉토리를 기반으로하는 계층 구조에 배치됩니다. &lt;b&gt;-d&lt;/b&gt; 스위치를 사용하여 다른 계층을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">출력 형식은 &lt;a href=&quot;#Configurable-Options&quot;&gt;구성&lt;/a&gt; 가능한 옵션에 설명 된 여러 옵션이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;쓰기&lt;/a&gt; 의 출력 형식은 이전 형식 선언 ( &lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt; )에 의해 결정 되므로 출력이 로케일의 영향을 받는지 여부는 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 여부가 아니라 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 내에 있는지 여부에 따라 결정됩니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">객체를 축복하지 않는 T_PTRREF 맵과 같은 것을 사용하는 XSUB의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">그 결과는</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">출력이 오염되지 않았습니다. 오염이 무엇인지 모른다면 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">출력 라인은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 호출 에서 템플릿으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;uname -a&lt;/code&gt; 의 출력 , 그렇지 않은 경우 호스트 이름 그런 다음 모든 것이 소문자이며 슬래시와 작은 따옴표가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인쇄 연산자의 출력 레코드 구분 기호입니다. 정의 된 경우이 값은 마지막 인쇄 인수 이후에 인쇄됩니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">출력은 모든 그룹을 보여줍니다. 가장 바깥 쪽 일치 항목이 먼저 표시되고 중첩 된 일치 항목이 나중에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">결과는 Perl이 두 가지 주요 그룹을 찾았 음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">&lt;code&gt;OUTER&lt;/code&gt; 블록에서 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 값이 &lt;code&gt;$outer&lt;/code&gt; 와 일치 하는 결과가 출력에 표시 됩니다. &lt;code&gt;INNER&lt;/code&gt; 블록 내에서 &lt;code&gt;$1&lt;/code&gt; 과 &lt;code&gt;$2&lt;/code&gt; 의 값은 $ &lt;code&gt;$inner&lt;/code&gt; 와의 일치에서 블록의 끝까지 (예 : 동적 범위)까지입니다. &lt;code&gt;INNER&lt;/code&gt; 블록이 완료된 후 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 값 은 다른 일치 항목을 만들지 않았더라도 &lt;code&gt;$outer&lt;/code&gt; 와 일치하는 값으로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">출력은 테스트중인 constant () 서브 루틴을 &lt;code&gt;DEBUG&lt;/code&gt; 상수 값 0으로 바꿉니다 . 테스트 할 라인은 완전히 최적화되었으며 그보다 훨씬 더 효율적일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">출력 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">에 대한 출력 문자열 &lt;b&gt;Tputs&lt;/b&gt; 은 성능을 위해 1 카운트로 캐시됩니다. &lt;b&gt;Tgoto&lt;/b&gt; 와 &lt;b&gt;Tpad&lt;/b&gt; 는 캐시하지 않습니다. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; 는 원시 termcap 데이터이고 &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; 는 캐시 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">부호가있는 출력 값은 1,2, ..., OBJ2-1 범위의 양수 값이거나 OBJ2를 뺀 동일한 값이어야합니다. 예를 들어 입력 인수가 숫자 7과 5를 나타내는 객체 인 경우이 메서드는 (3 * 7) % 5 = 1 % 5이므로 숫자 3과 &quot;+&quot;부호를 나타내는 객체 또는 객체를 반환해야합니다. (-2 * 7) % 5 = 1 % 5이므로 숫자 2와 &quot;-&quot;부호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">스크립트가 실행될 때 얻을 수있는 출력 :</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 이 호출 된 시점 과 종료 된 시점 사이의 전체 또는 벽시계 시간 . 경과 시간에는 사용자 및 시스템 시간과 시스템의 다른 사용자 및 프로세스를 기다리는 데 소요 된 시간이 포함됩니다. 필연적으로 이것은 주어진 측정치 중 가장 근사한 수치입니다.</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">정의의 pTHX_ 기호는 스레딩에서 Perl이 정규 표현식을 실행하는 인터프리터에 대한 포인터를 다시 유지하는 추가 인수를 제공하기 위해 사용하는 매크로입니다. 따라서 스레딩에서 모든 루틴은 추가 인수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">팩 코드 &lt;code&gt;A*&lt;/code&gt; 남아있는 모든 바이트를 모으고 &lt;code&gt;$prio&lt;/code&gt; 는 정의되지 않은 상태로 유지됩니다! 실망이 사기를 약화시키기 전에 : Perl은이 트릭을 만들기 위해 트럼프 카드를 얻었습니다. 이것을보세요:</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">팩 코드 &lt;code&gt;w&lt;/code&gt; 는 단순한 정수 이상의 휴대용 이진 데이터 인코딩 체계를 지원하기 위해 추가되었습니다. (자세한 내용은 &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt; , Scarab 프로젝트 에서 확인할 수 있습니다 .) BER (Binary Encoded Representation) 압축 부호없는 정수는 가능한 한 적은 수의 숫자로 기본 128 자리 (가장 중요한 자리)를 저장합니다. 비트 8 (상위 비트)은 마지막 바이트를 제외한 각 바이트에 설정됩니다. BER 인코딩에는 크기 제한이 없지만 Perl은 극단적으로 진행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">빅 엔디안 (가장 낮은 주소의 상위 바이트)에 대한 팩 코드는 &lt;code&gt;n&lt;/code&gt; 입니다. 16 비트의 경우 이고 32 비트 정수의 경우 &lt;code&gt;N&lt;/code&gt; 입니다. 데이터가 호환 아키텍처에서 나온다는 것을 알고 있으면이 코드를 사용하지만 놀랍게도 네트워크를 통해 이진 데이터를 전혀 모르는 시스템과 교환 할 경우이 팩 코드를 사용해야합니다. 간단한 이유는이 주문이</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">위의 팩 코드 &lt;code&gt;/&lt;/code&gt; 모든 숫자 이진 팩 코드 및 같은 심지어 텍스트 코드 :의 숫자를 표현하기 위해 맞는 것이있을 수 있습니다 아무것도 &lt;code&gt;A4&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">팩 형식 &lt;code&gt;A&lt;/code&gt; 는 &quot;모든 문자&quot;를 의미합니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 하고 포장 할 물건이 부족한 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 공백으로 나머지 부분을 채울 것입니다.</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">패키지에는 세션 관리자와 캐시 관리자가 포함되어 있습니다. 세션 관리자는 현재 세션에서 페치, 빌드 및 설치된 것을 추적합니다. 캐시 관리자는 make 프로세스가 차지하는 디스크 공간을 추적하고 간단한 FIFO 메커니즘을 사용하여 초과 공간을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">패키지 이름 인수는 일반적으로 서브 루틴이 선언 된 클래스의 이름이지만 핸들러가 상속되므로 파생 클래스의 이름 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">패키지 이름은 &lt;code&gt;DBM_Filter::&lt;/code&gt; 두부를 .</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">분포를 나타내는 패키지입니다. 예를 들어 &lt;code&gt;Test::More&lt;/code&gt; 또는 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 입니다. &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt; , Perl 라이브러리 내의 설치 위치 및 기본적으로 XS 파일을 찾는 위치 와 같은 배포에 대한 정보를 도출하는 데 사용됩니다 (참조&lt;a href=&quot;#XS&quot;&gt; XS를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr // magic 객체가 축복받은 패키지 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ) 엔진은 객체에 메소드를 구현하는지 여부에 관계없이 식별을 위해 패키지 이름으로이를 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">이 메소드가 리턴하는 패키지는 또한 &lt;code&gt;@ISA&lt;/code&gt; 에 내부 &lt;code&gt;Regexp&lt;/code&gt; 패키지를 가져야합니다. . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; 는 사용중인 엔진에 관계없이 항상 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;@EXPORT&lt;/code&gt; 패키지 변수 는 호출자가 단순히 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 한다고 말할 때 어떤 심볼을 내보낼 지 결정 합니다. &lt;code&gt;@EXPORT_OK&lt;/code&gt; 는 내보낼 심볼을 지정합니다. 여러 개의 심볼을 내보내려면 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 사용하십시오. 를 사용하고 표준 내보내기 세트를 정의 하십시오. 자세한 내용 은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">다양한 DBM 관련 구현과 관련된 패키지 (</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST의 패드 이름에는 변수 이름을 보유한 PV가 있습니다. COP_SEQ_RANGE_LOW 및 _HIGH 필드는 이름이 유효한 cop_seq 숫자의 범위 (낮은 +1 .. 포함)를 형성합니다. 컴파일 중에이 필드는 다양한 단계를 표시하기 위해 특수 값 PERL_PADSEQ_INTRO를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">채워진 $ string이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Xiaoyun Wang과 Hongbo Yu의 논문 &quot;MD5 및 기타 해시 함수를 깨는 방법&quot;.</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap에&lt;/a&gt; 제공하는 단락에는 줄 바꿈 문자가 포함되어서는 안됩니다. &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; 은 행을 정당화하지 않습니다 (오른쪽 플러시).</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수 는 압축 된 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수 는 압축되지 않은 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">매개 변수 &lt;code&gt;$text&lt;/code&gt; 는 내부 시퀀스에 대해 구문 분석 할 문자열 또는 텍스트 블록입니다. &lt;code&gt;$line_num&lt;/code&gt; 매개 변수 는 &lt;code&gt;$text&lt;/code&gt; 의 시작 부분에 해당하는 줄 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">&lt;code&gt;extra_libs&lt;/code&gt; 매개 변수 는 설치된 모듈을 검색하기위한 &lt;b&gt;추가&lt;/b&gt; 경로를 지정하는 데 사용될 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">매개 변수 &lt;code&gt;type&lt;/code&gt; 은 사용할 3 가지 인터페이스 메소드 (DB_HASH, DB_BTREE 또는 DB_RECNO)를 지정하는 열거입니다. 이 중 실제로 선택된 매개 변수에 따라</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">원하는 경우 my ()에 대한 매개 변수 목록을 지정하여 변수를 초기화 할 수 있습니다. (특정 변수에 대해 이니셜 라이저가 제공되지 않으면 정의되지 않은 값으로 작성됩니다.) 일반적으로 이는 입력 매개 변수의 이름을 서브 루틴으로 지정하는 데 사용됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">값이 어디에도 저장되지 않더라도 해당 인수가 제공되지 않으면 매개 변수의 기본값이 여전히 평가됩니다. 평가에 중요한 부작용이있는 경우입니다. 그러나 빈 공간에서 평가되므로 부작용이없고 사소하지 않은 경우 &quot;void&quot;경고 범주가 활성화되면 경고가 생성됩니다. 이름이없는 선택적 매개 변수의 기본값이 중요하지 않은 경우 매개 변수 이름이 다음과 같이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수 는 압축 된 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수 는 압축되지 않은 데이터의 소스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">허용되는 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 매개 변수 는 perl 검색 경로의 시작 부분에 추가됩니다. 속담</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">&lt;code&gt;XSLoader::load()&lt;/code&gt; 인수 에 대한 괄호는 우리가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 로 대체 했기 때문에 필요 하므로 컴파일러는 &lt;code&gt;XSLoader::load()&lt;/code&gt; 함수 가 존재 한다는 것을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">구문 분석은 대부분의 루틴이 단락되어 크기 필드 &lt;code&gt;RExC_size&lt;/code&gt; 를 변경하고 다른 작업을 수행하지 않는다는 점을 제외하고는 구성 단계와 거의 동일하게 진행 됩니다.</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">파서는 어휘 분석기로 도움을 받는다. 어휘 분석기는 어휘 분석기를 이용하여 입력을 토큰으로 청산하고 변수 명, 연산자, 베어 워드, 서브 루틴, 코어 함수 등 각 토큰의 유형을 결정한다. 렉서의 주요 진입 점은 &lt;code&gt;yylex&lt;/code&gt; 이며 해당 루틴 및 관련 루틴은</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">그런 다음 파서는 다음 코드를 봅니다.</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">올바른 기계를 찾은 후 회사 운영자에게 연락 할 때 제공하는 전화 내선 번호와 같은 올바른 프로세스로 패킷을 전달하는 TCP 또는 UDP 소켓 주소 부분. 또한 원래 의도 한 것과 다른 플랫폼에서 실행되도록 코드를 변환 한 결과 또는이 변환을 나타내는 동사입니다.</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">사용하려는 Perl의 특정 사본이 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 호출 에 사용되는 지정된 신호를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">사용하려는 Perl의 특정 사본은 &lt;code&gt;useithreads&lt;/code&gt; 구성 옵션을 사용하여 빌드되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">사용해야하는 특정 매크로 는 먼저 호출 한 &lt;code&gt;sv_set*v&lt;/code&gt; 루틴 에 따라 다릅니다 . 모든 &lt;code&gt;sv_set*v&lt;/code&gt; 루틴은 설정중인 특정 유형의 데이터에 대한 비트 만 설정하고 나머지는 모두 해제하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">전달 된 속성은 &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()가&lt;/a&gt; 반환 한 동의어 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">이 패키지의 패치 수준입니다. patchlevel의 가치는</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perl의 경로는 &lt;code&gt;@INC&lt;/code&gt; 를 통과 합니다. 기본적으로, 이것은 정의 된 메소드를 찾은 후 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 위한 한 번의 이중 심도 검색 입니다. 그러나 Perl에서는 &lt;code&gt;mro&lt;/code&gt; 로이 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">URI에서 경로는 적어도 하나의 '/'입니다.</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">사용 가능한 Term :: ReadLine 백엔드를 사용하여 히스토리가 디버거 시작시 읽히고 종료시 저장되는 파일의 경로입니다 (세션 전체에 지속성을 위해). Bash의 &lt;code&gt;.bash_history&lt;/code&gt; 파일 과 개념이 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">파일 경로는 아카이브에서 사용하기 위해 자동으로 Unix로 변환되며, MacOS의 경우 파일 수정 시간이 MacOS 시대에서 Unix 시대로 변환됩니다. 따라서 &lt;b&gt;Archive :: Tar를 사용&lt;/b&gt; 하여 MacOS에서 생성 된 tar 아카이브 는</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">구문 검사를위한 POD 파일의 경로 이름 (기본값은 표준 입력)입니다.</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">사용법 메시지 형식으로 출력 될 포드 문서를 포함하는 파일의 경로 이름입니다 (기본값은 표준 입력).</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">포드 설명서의 섹션을 선택할 파일의 경로 이름입니다 (기본값은 표준 입력).</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">패턴은 문자의 하위 집합과 일치하는 클래스로 시작합니다. 이것이 일치 할 때마다 &lt;code&gt;$count{'a'}++;&lt;/code&gt; 문자 카운터를 증가시키면서 실행됩니다. 그런 다음 &lt;code&gt;(*FAIL)&lt;/code&gt; 이 말한 것을 수행하고 정규식 엔진은 책에 따라 진행합니다. 줄의 끝에 도달하지 않으면 다른 모음을 찾기 전에 위치가 진행됩니다. 따라서 일치 또는 일치하지 않으면 차이가 없으며 정규식 엔진은 전체 문자열이 검사 될 때까지 진행됩니다. (다음과 같은 것을 사용하는 대체 솔루션은 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">패턴 일치가 성공하고 &lt;code&gt;$1&lt;/code&gt; &quot;nothing&quot;과 일치하지만 $ 1 이 정의됩니다. 실제로 아무것도 일치하지 않습니다. 오히려 0 자 길이의 항목과 일치합니다. 이것은 모두 매우 정직하고 정직합니다. 함수가 정의되지 않은 값을 반환하면 정직한 대답을 할 수 없다는 것이 인정됩니다. 따라서 수행하려는 작업의 무결성에 의문을 제기 할 때만 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다 . 다른 경우에는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 에 대한 간단한 비교가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">패턴 일치가 성공하고 &lt;code&gt;$1&lt;/code&gt; &quot;nothing&quot;과 일치하지만 이 정의됩니다. 실제로 아무것도 일치하지 않습니다. 오히려 0 자 길이의 항목과 일치합니다. 이것은 모두 매우 정직하고 정직합니다. 함수가 정의되지 않은 값을 반환하면 정직한 대답을 할 수 없다는 것이 인정됩니다. 따라서 수행하려는 작업의 무결성에 의문을 제기 할 때만 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다 . 다른 경우에는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 에 대한 간단한 비교가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">패턴 일치 메타 문자 &quot;(&quot;, &quot;)&quot;및 &quot;|&quot; 앞에 백 슬래시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">패턴 매칭 연산 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; &lt;code&gt;=~&lt;/code&gt; 연산자없이 사용될 때 tr /// (일명 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">패턴 수정 자 :</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">매크로 호출 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">패턴은 정말</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perl 패턴 일치에 사용 된 패턴은 버전 8 정규식 루틴에서 제공되는 패턴에서 발전했습니다. (이 루틴은 Henry Spencer의 무료 재배포 가능한 V8 루틴의 재 구현에서 파생됩니다.)&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt; 버전 8 정규식&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">들여다 보는 구멍 최적화 장치를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 랩핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법은 &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;컴파일 패스 3&lt;/a&gt; 에서 볼 수 있습니다 : perlguts의 구멍 최적화 . 새 코드가 최상위 수준이 아닌 서브 루틴 구조 전체에서 op에서 작동하려면 &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; 후크 를 감싸는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">들여다 보는 구멍 최적화 장치를 완전히 교체해서는 안됩니다. 오히려 기존 옵티 마이저를 랩핑하여 코드를 추가하십시오. 이를 수행하는 기본 방법은 &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;컴파일 패스 3 : perlguts의 틈 구멍 최적화에서&lt;/a&gt; 볼 수 있습니다 . 새로운 코드가 구조 전체가 아닌 서브 루틴의 최상위 레벨에서만 작동하기를 원한다면 &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; 훅 을 감싸는 것이 더 편리 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">PerlIOl을 레이어 구조의 첫 번째 멤버로 만들어 인스턴스 별 데이터를 기본 PerlIOl 구조체 이외의 메모리에 보관합니다.</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">특정 핸들에 대한 인스턴스 별 데이터.</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">레코드 당 오버 헤드는 파일 당 액세스 할 수있는 최대 레코드 수를 제한합니다. 참고</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">기간 '.' &quot;\ n&quot;을 제외한 모든 문자와 일치</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">기간 '.' &quot;\ n&quot;을 제외한 모든 문자와 일치합니다 (수정자가 &lt;code&gt;//s&lt;/code&gt; 가 아닌 한) 아래 설명 된대로 를 적용 ).</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">그런 다음 PerlIO.pm의 펄 코드는 다음을 수행하여 레이어를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">펄 코어 는 매크로 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 에서 &lt;code&gt;setjmp()&lt;/code&gt; 등을 래핑 합니다. perl 예외의 기본 규칙은 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이없는 경우 )가 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; 수행하는 반면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내의 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">Perl 실행 파일은 링크하여 얻습니다</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">펄 메시지는 &quot;Perl&quot;과 함께 나옵니다. 은 &lt;code&gt;BEGIN&lt;/code&gt; 컴파일 오류 및 경고의 모두가 얻을 수 있도록 컴파일시에 블록 작품을 &quot;펄 :&quot;접두사를 너무.</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">펄 소스는 자식 저장소에 있습니다. 다음 명령을 사용하여 저장소를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie 함수는 변수를 다양한 GET, SET 등 메소드를 구현하는 오브젝트와 연관시킵니다. XSUB에서 perl tie 기능과 동등한 기능을 수행하려면이 동작을 모방해야합니다. 아래 코드는 필요한 단계를 수행합니다. 먼저 새 해시를 만든 다음 두 번째 해시를 만들어 클래스에 축복하여 tie 메서드를 구현합니다. 마지막으로 두 해시를 함께 묶고 새로운 묶인 해시에 대한 참조를 반환합니다. 아래 코드는 MyTie 클래스에서 TIEHASH 메소드를 호출하지 않습니다 .이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;C 프로그램 내에서 Perl 루틴 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">상수를 리턴 할 생성 된 XS 서브 루틴의 perl 표시 이름. 기본값은 &lt;code&gt;constant&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org 목록은 모든 EBCDIC Perls의 일반적인 사용 문제뿐만 아니라 이식 문제에 대한 토론을위한 것입니다. &quot;subscribe perl-mvs&quot;메시지 본문을 majordomo@perl.org로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5 변경 메일 링리스트는 perl 저장소의 유지 보수 및 개발 브랜치에 제출되는 각 패치의 사본을 수신합니다. 가입 및 보관 정보는 &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">Perl5 포터 (p5p) 메일 링리스트는 Perl 표준 배포가 유지되고 개발되는 곳입니다. Perl을 유지 관리하는 사람들은 &quot;Perl 5 Porters&quot;, &quot;p5p&quot;또는 &quot;porter&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug 프로그램은 귀하의 이메일 주소와 제출 한 패치에 대해 몇 가지 질문을합니다. 응답하면 이메일을 통해 패치를 제출합니다.</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime 용 perldoc에는 파일에 대해 touch (1)과 동일한 효과를 갖는 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaq은 Perl 및 Perl 프로그래밍에 관해 가장 자주 묻는 질문에 대한 답변을 제공하는 여러 문서로 구성되어 있습니다. 주제별로이 문서에 요약 된 9 개의 주요 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq은 진화하는 문서입니다. &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; 에서 최신 버전을 읽으십시오 . 표준 Perl 배포판에도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">축 어적 단락에 대한 perlpod 스펙은 &quot;정확히 재현되어야합니다 ...&quot;입니다. 즉, 축약어 블록을 들여 쓰는 데 사용 된 공백이 출력에 보존됩니다. 이것은 공백이 모든 줄 앞에 남아있는 HTML과 같은 출력에 성 가실 수 있습니다. 구문이 의미론으로 바뀌는 불행한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perl과 함께 제공된 perlstyle 매뉴얼에는 많은 유용한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">&lt;b&gt;운영 체제&lt;/b&gt; 가 거의 모든 작업을 수행 할 수 있는 사람 입니다. 일반적으로 시스템 관리자 또는 시스템 관리자 인 사람. 유닉스 시스템에서 &lt;b&gt;루트&lt;/b&gt; 사용자. Windows 시스템에서는 일반적으로 관리자입니다.</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">파이프 라인 모델은 작업을 일련의 단계로 나누고 한 단계의 결과를 다음 단계를 처리하는 스레드로 전달합니다. 각 스레드는 각 데이터 조각에 대해 하나의 작업을 수행하고 결과를 다음 스레드에 줄로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pm 유틸리티가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">계획 (예 : '1..5')은 TAP 출력의 시작 또는 끝에 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">함수의 핵심은 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 함수 를 &quot;시드&quot; 하여 프로그램을 실행할 때마다 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 가 다른 순서를 생성 할 수 있도록하는 것 입니다. 매개 변수와 함께 호출되면 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 는 시드에이를 사용합니다. 그렇지 않으면 (반) 임의로 씨앗을 선택합니다. 두 경우 모두 Perl 5.14로 시작하여 시드를 반환합니다. 코드가 작동한다는 신호</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">함수의 핵심은 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 함수 를 &quot;시드&quot; 하여 프로그램을 실행할 때마다 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 가 다른 순서를 생성 할 수 있도록하는 것 입니다. 매개 변수와 함께 호출되면 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 는 시드에이를 사용합니다. 그렇지 않으면 (반) 임의로 씨앗을 선택합니다. 두 경우 모두 Perl 5.14로 시작하여 시드를 반환합니다. 코드가 작동한다는 신호</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">포인터는 포인터 유형의 이름에서 파생되지만 이름의 모든 '*'가 'Ptr'로 바뀐 클래스에 축복이 있습니다.</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; 의 PV에 대한 포인터 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">주목해야 할 점은</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">극좌표 표기법 (삼각형 표현이라고도 함)은 복소수의 곱셈과 나눗셈을 수행하는 데 훨씬 더 편리한 반면, 데카르트 표기법은 덧셈과 뺄셈에 더 적합합니다. 실수는</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">극지 스타일은 다음과 같은 주장을 강조하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32 용 포트가 참조로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">MacPerl의 마지막 공식 프로덕션 릴리스는 Perl 5.6에 해당하지만 Perl 5.12부터 Perl의 포트는 공식적으로 Perl 5.12에서 제거되었습니다. Perl 5.10에는 Mac OS 포트가 포함되어 있지만 Perl 모듈 설치 인프라의 핵심 부분 인 ExtUtils :: MakeMaker는 2004 년 4 월 Mac OS에 대한 지원을 공식적으로 중단했습니다.</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">포터들은 Perl을 개선하는 데 도움을 준 시간에 감사합니다. 감사합니다!</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XS 코드에서 제공하는 확장 부분은 두 가지 방법 중 하나로 Perl의 나머지 부분에 연결될 수 있습니다. 에서 &lt;b&gt;정적&lt;/b&gt; 구성, 확장을위한 오브젝트 코드에 직접 연결되어 있습니다</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE 파일의 위치는 변경되지 않습니다. 파일에 쓰기 전에 &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">소유 형태 (Perl 5.10의 새로운 기능)는 역 추적을 방지합니다. 소유 정량화가있는 패턴과 일치하는 항목은 전체 일치가 실패하더라도 역 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">가능한 범주는 : &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 및 pseudo category &lt;code&gt;:characters&lt;/code&gt; 입니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODE 매개 변수의 가능한 값과 플래그 비트는 시스템에 따라 다릅니다. 그것들은 표준 모듈 &lt;code&gt;Fcntl&lt;/code&gt; 을 통해 사용 가능합니다 . 운영 체제 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">추정되는 링크 텍스트 즉, 실제 링크 텍스트가없는 경우이 텍스트가 대신 사용됩니다. (예 : &quot;L &amp;lt;Getopt :: Std&amp;gt;&quot;의 경우 유추 링크 텍스트는 &quot;Getopt :: Std&quot;입니다.)</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;내가해야 할 일이 있으면 다르게 할 것&amp;rdquo;이라고 말하고 실제로 돌아가서 다르게하는 일을합니다. 수학적으로 말하면, 그것은 가능성의 나무에 대한 실패한 재귀에서 돌아옵니다. Perl은 패턴을 &lt;b&gt;정규식&lt;/b&gt; 과 일치 시키려고 시도 할 때 역 추적 하며 이전 시도는 팬 아웃되지 않습니다. Camel 챕터 5,&amp;ldquo;패턴 일치&amp;rdquo;의&amp;ldquo;작은 엔진은 불가능한&amp;rdquo;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">암호화를 위해 하나 이상의 문자를 알파벳으로 바꾸는 관행은 수천 년 전으로 거슬러 올라가며 Gaius Julius Caesar의 &lt;b&gt;Gallic Wars&lt;/b&gt; 텍스트 에 자세히 설명되어 있습니다. 단일 알파벳 이동은 때때로 회전이라고하며 이동량은 문자열 'rot'또는 &quot;rot $ n&quot;다음에 숫자 $ n으로 제공됩니다. Rot0 및 rot26은 영어 알파벳 26 자의 영어 알파벳으로 된 아이디 맵을 지정합니다. Rot13은 다른 후속 호출이 ID 맵이라는 흥미로운 속성을 가지고 있습니다 (따라서 rot13은 26 개의 알파벳 회전 그룹에서 사소한 역수입니다). 따라서 다음은 ASCII 및 EBCDIC 플랫폼에서 작동하는 rot13 인코더 및 디코더입니다.</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">프라 그마 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 수 &lt;code&gt;$?&lt;/code&gt; 위에서 설명한 POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. 이 pragma는 &lt;code&gt;$?&lt;/code&gt; 를 설정할 때 0이 아닌 값을 SS $ _ABORT로 변환하지 못하게합니다 . END 블록에서 (그러나 0은 여전히 ​​SS $ _NORMAL로 변환됩니다).</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">pragma는 블록 단위 어휘가 아니라 스크립트 단위입니다. 마지막 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 만 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 중요 &lt;a href=&quot;functions/no&quot;&gt;하지 않아&lt;/a&gt;&lt;b&gt; 전체 스크립트에&lt;/b&gt; 영향을 미쳤 &lt;b&gt;습니다&lt;/b&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma가 지원되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 으며 주어진 스크립트에서 원하는만큼 인코딩 이 나타날 수 있습니다 (마지막 스크립트 만 효과적 임).</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; 및&lt;a href=&quot;../bigrat&quot;&gt; bigrat&lt;/a&gt; 도 자동 업그레이드 / 다운 그레이드 문제를 적어도 부분적으로 해결하기 때문에 관심이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">각 출력 파일에 추가 된 프리앰블은 다소 장황하며 대부분 ASCII가 아닌 문자가있는 경우에만 필요합니다. 문자가 사용될 때 즉석에서 모든 정의가 필요한 경우에만 출력되는 것이 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">클래스의 프리앰블 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">선호의 &lt;b&gt;정규 표현&lt;/b&gt; 엔진은 가장 왼쪽 발생 일치 &lt;b&gt;패턴을&lt;/b&gt; 다음 일치가 발생하는 위치는 가장 긴 매치에 대한 선호도 (a 사용 추정 주어진 &lt;b&gt;욕심&lt;/b&gt; 정량 참조). 자세한 내용은 Camel 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">이를 위해 선호되는 방법은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; 를 &lt;a href=&quot;../functions/use&quot;&gt;사용할&lt;/a&gt; 때 계획을 선언하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">&lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 지정된 접두어 는 값 이름이 정의되지 않은 경우 숫자 접미사와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">범주 목록에 &quot;FATAL&quot;이라는 단어가 있으면 해당 범주의 경고가 해당 어휘 범위에서 치명적인 오류로 에스컬레이션됩니다.</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">이전 과제는 정확히</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">이전 예제는 특별히 유용하지 않았습니다. 보다 일반적인 목적으로 컨텍스트 데이터를 사용하고 임의의</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">이전 단락은 &lt;code&gt;hv_store&lt;/code&gt; 및 &lt;code&gt;hv_store_ent&lt;/code&gt; 함수를 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">이전 섹션 ( &lt;code&gt;=head&lt;/code&gt; 명령으로 소개 )에는 텍스트가 없습니다. 이것은 대개 무언가 빠진 것을 나타냅니다. 참고 : A &lt;code&gt;=head1&lt;/code&gt; 바로 뒤에 &lt;code&gt;=head2&lt;/code&gt; 는이 경고를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">이전 단계가 생성되었습니다</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">'dlopen : stub interception failed'메시지의 주요 원인은 LD_LIBRARY_PATH 환경 변수에 / usr / lib에 대한 심볼릭 링크 디렉토리 (예 : / lib)가 포함되어 있기 때문입니다. 위의 &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 주요 목적은 zip 파일 및 버퍼에 대한 스트리밍 쓰기 액세스를 제공하는 것입니다. 범용 파일 아카이버가 아닙니다. 이것이 원하는 경우 &lt;code&gt;Archive::Zip&lt;/code&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzip의 기본 사이트는</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">의 기본 사이트</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2 프로그램의 기본 사이트는</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y / x의 아크 탄젠트의 주요 값</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">발견 된 객체의 수는 항목 표시 방법에 영향을줍니다. 검색에서 하나의 항목을 찾으면 결과는 다소 장황한 메소드 인 &lt;code&gt;as_string&lt;/code&gt; 으로 표시 되지만 둘 이상의 항목을 찾으면 각 오브젝트는 간단한 메소드 인 &lt;code&gt;as_glimpse&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">print () 문은 &lt;code&gt;$,&lt;/code&gt; 및 &lt;code&gt;$\&lt;/code&gt; 를 설정하지 않으면 필드 및 레코드 구분 기호를 추가하지 않습니다 . 영어 모듈을 사용하는 경우 $ OFS 및 $ ORS를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">개인 데이터 캐시는 &lt;code&gt;hv_store()&lt;/code&gt; 가 전달한 값에 대한 참조의 소유권 을 얻는 것과 거의 같은 방식으로 private_sv에 대한 참조의 소유권을 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 과 같은 개인용 객체 해시 키는 변경되지 않지만 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 과 같은 추가 키를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">개인 변수는 현재 로케일 상태를 저장하는 데 사용되므로 &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC에&lt;/a&gt; 대한 필수 일치 호출이 이를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">대략 동등한 C 프로그램에서 문제를 추가로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 의 명령 행 인수와 같이 Perl이 생각하는 문자열에서 숫자를 가져올 때 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">예를 들어 UTF-8로 플래그가 지정되지 않은 문자열이 있고 UTF-8이 될 수있는 바이트 시퀀스가 ​​포함 된 경우 (특히 UTF-8이 아닌 문자열과 UTF-8 문자열을 결합 할 때)에 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">익명 서브 루틴이 할당되고 있기 때문에 문제가 존재 &lt;code&gt;*Foo::foo&lt;/code&gt; 글로브라는 것으로 호출 스택에 표시됩니다 &lt;code&gt;__ANON__&lt;/code&gt; 하지 &lt;code&gt;foo&lt;/code&gt; 는 예상대로. 이후 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 사용하는 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 메소드의 이름을 찾기 위해,이 경우에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">여기서 문제는 Uid_t가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; - wide 일뿐만 아니라 부호도 없을 수 있다는 것입니다.이 경우 큰 uid는 음수 값으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">여기서 문제는 그룹 둘이라는 점이다 &lt;code&gt;a&lt;/code&gt; 그 그룹의 이름 &lt;code&gt;b&lt;/code&gt; 속하는 그룹의 별칭 &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">문제는 Perl에 컴파일 타임과 런타임 경고가 모두 있다는 것입니다. 컴파일 타임 경고를 비활성화하려면 다음과 같이 코드를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">문제는 &lt;code&gt;rp&lt;/code&gt; 와 &lt;code&gt;dp&lt;/code&gt; 가 메모리에서 같은 위치를 가리키는 포인터라는 것입니다! C에서는 새로운 메모리를 malloc ()으로 기억해야합니다. Perl에서는 대신 배열 생성자 &lt;code&gt;[]&lt;/code&gt; 또는 해시 생성자 &lt;code&gt;{}&lt;/code&gt; 를 사용하려고합니다 . 앞의 깨진 코드 조각을 수행하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">문제는 grep이 컨텍스트에 관계없이 리턴 목록을 작성한다는 것입니다. 이것은 Perl이리스트를 작성하는 데 어려움을 겪고 있다는 것을 의미합니다. 목록이 크면 시간과 공간을 모두 낭비하게됩니다. 의도가 목록을 반복하려는 경우 for 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">문제는 이러한 예제 중 어느 것도 신뢰할 수 없다는 것입니다. 명령 인터프리터에 따라 다릅니다. 유닉스에서는 처음 두 가지가 종종 작동합니다. DOS에서는 전혀 작동하지 않을 수 있습니다. 4DOS가 명령 쉘인 경우 다음과 같이 운이 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">문제는 이것 중 어느 것도 신뢰할 수 없다는 것입니다. 명령에 따라 다르며 전혀 작동하지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">문제는 로깅 구성 파일에 설정된 디버그 수준이 0 인 경우에도이 코드가 항상 구문 분석되고 실행된다는 것입니다. debug () 서브 루틴이 입력되고 내부 &lt;code&gt;$debug&lt;/code&gt; 변수가 0으로 확인되면, 전송 된 메시지가 삭제되고 프로그램이 계속됩니다. 그러나 주어진 예에서, &lt;code&gt;\%INC&lt;/code&gt; 해시는 이미 덤프되고 메시지 문자열이 구성되며, 모든 작업은 다음과 같이 명령문 레벨에서 디버그 변수에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">문제는이 코드가</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">문제는 큰 따옴표가 문자열이되고 싶지 않은 경우에도 문자열과 숫자로의 참조를 강제로 묶는 것입니다. 이런 식으로 생각하십시오 : 큰 따옴표 확장은 새로운 문자열을 생성하는 데 사용됩니다. 이미 줄이 있다면 왜 더 필요한가?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">문제는 procfs를 통해 볼 수있는 다양한 구조가 off_t를 사용하고 큰 파일 지원으로 컴파일하는 경우 이러한 변경 사항을 32 비트에서 64 비트로 변경한다는 것입니다. 따라서 procfs에서 얻은 내용이 perl의 구조와 일치하지 않아 가비지가 발생합니다. 자세한 내용은 proc (4)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">문제는 내포 된 불확정 양자화 기입니다. 사이 길이 n의 스트링을 분할하는 방법에는 여러 가지가있다 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; : 하나 반복 &lt;code&gt;b+&lt;/code&gt; 의 길이는 N, 첫 번째와 두 반복 &lt;code&gt;b+&lt;/code&gt; 길이 K와 길이 NK, 그 비트 길이 n까지 추가 m 반복 갖는 제 2 실제로 문자열을 길이의 함수로 분할하는 방법에는 기하 급수적 인 방법이 있습니다. 정규 표현식이 운이 좋으면 프로세스 초기에 일치하지만 일치하는 항목이 없으면 Perl이 시도합니다.</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">문제는 일반적으로 해당 시스템의 명령 인터프리터가 단일 라이너가 작성된 Unix 쉘과는 다른 인용 방식에 대한 아이디어를 가지고 있다는 것입니다. 일부 시스템에서는 작은 따옴표를 큰 따옴표로 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">이것의 문제는 버퍼링이 실제로 하루를 망칠 것입니다. 당신 비록 &lt;code&gt;Writer&lt;/code&gt; 다른 쪽 끝에 프로세스가 적시에 데이터를 얻을 수 있도록 핸들이 자동 플러시, 당신은 일반적으로 유사하게 빠른 방식으로 당신에게 데이터를 제공하는 해당 프로세스를 강제로 아무것도 할 수 없습니다. 이 특별한 경우에 우리는 실제로 그렇게 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">가비지 수집 및 스레드 안전성 문제는 &lt;code&gt;register()&lt;/code&gt; 함수로 해결됩니다 . 임의의 수의 해시와 함께 객체를 등록합니다. 레지스트리는 객체가 죽으면이 객체의 참조 주소 아래의 해시 항목이 삭제됨을 의미합니다. 이것은 이러한 해시에 가비지 콜렉션을 보장합니다. 또한 스레드 복제시 등록 된 해시의 객체 항목이 키가 복제 된 객체의 참조 주소 인 업데이트 된 항목으로 대체됨을 의미합니다. 따라서 객체 데이터 연결은 스레드로부터 안전 해집니다.</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">이 스크립트를 실행하는 Perl의 프로세스 번호. 당신은</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">문자열을 4 개의 유니 코드 &lt;b&gt;케이스 맵&lt;/b&gt; 중 하나로 변환하는 프로세스 . Perl에서는 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 함수로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">어떤 방법을 사용해야하는지 결정하는 과정을 &lt;b&gt;방법 분석&lt;/b&gt; 이라고 합니다. Perl이하는 일은 객체의 클래스를 먼저 보는 것입니다 ( 이 경우 &lt;code&gt;File::MP3&lt;/code&gt; ). 해당 클래스가 메소드를 정의하면 해당 클래스의 메소드 버전이 호출됩니다. 그렇지 않으면 Perl은 각 상위 클래스를 차례로 봅니다. 를 들어 &lt;code&gt;File::MP3&lt;/code&gt; , 유일한 부모입니다 &lt;code&gt;File&lt;/code&gt; . 경우 &lt;code&gt;File::MP3&lt;/code&gt; 방법을 정의하지 않지만, &lt;code&gt;File&lt;/code&gt; 수행 한 후 펄의 메소드를 호출 &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">한 고양이의 코를 다른 고양이의 꼬리에 붙이는 과정. 또한 두 &lt;b&gt;문자열&lt;/b&gt; 에서 비슷한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">추상 객체 의 &lt;b&gt;문자열&lt;/b&gt; 표현 을 생성하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">하나의 대안을 시도하고, 대안이 일치하는지 확인하고, 다음 대안으로 넘어 가면서 이전 대안이 시도 된 곳에서 문자열로 돌아가는 프로세스가 호출되는 프로세스가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">소스 코드를 기계가 사용할 수있는 형태로 바꾸는 과정. &lt;b&gt;컴파일 단계를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">정규식을 통해 오염 된 값을 &quot;세탁&quot;하여 프로그램을 실행할 수 있습니다. 두 번째 예제 (로케일 정보를 여전히 무시 함)가 실행되면 명령 행에 이름이 지정된 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">프로그램이 충돌하고 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; &lt;code&gt;closelog&lt;/code&gt; 를 호출 하면 로그가 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">h2xs 프로그램은 확장을 작성하기위한 시작점입니다. 이후 예제에서 h2x를 사용하여 헤더 파일을 읽고 C 루틴에 연결하기위한 템플릿을 생성하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">이 프로그램은 2 ~ 7 행으로 입력을 읽고 데이터 구조를 작성하며 8 ~ 13 행은 데이터를 분석하고 보고서를 인쇄합니다. 키는 국가 이름이고 값은 도시 이름 배열에 대한 참조 인 해시 &lt;code&gt;%table&lt;/code&gt; 을 갖습니다 . 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">프로그램은 &lt;code&gt;regnode&lt;/code&gt; 구조 의 배열로 표시되며 , 하나 이상의 프로그램이 단일 regop을 나타냅니다. Struct &lt;code&gt;regnode&lt;/code&gt; 는 필요한 가장 작은 구조체이며 다른 모든 더 큰 구조체와 공유되는 필드 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">프로그램은 이것이 이루어 지도록주의를 기울여야합니다</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">이 프로그램은 실행하는 데 17 초 이상 걸렸습니다. 다른 값의 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 출력에 유의하십시오. 항상 같은 것을 사용하고 각각의 의미를 혼동하지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">프로그램이 중단됩니다</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">프로그래밍 인터페이스는 사용하기 쉽습니다 . CPAN의 &lt;a href=&quot;../digest&quot;&gt;다이제스트&lt;/a&gt; 모듈 에서와 동일 합니다. 따라서 응용 프로그램에서 현재 &lt;a href=&quot;md5&quot;&gt;Digest :: MD5를&lt;/a&gt; 사용 하고 있고 더 강력한 SHA 보안을 원한다면 간단히 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">이 영역의 프로그램과 설명서는 유용하지만 보증없이 제공 될 것입니다. 상업성이나 특정 목적에의 적합성에 대한 묵시적 보증없이.</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan 쉘의 프롬프트는 세션을 쉽게 추적하기 위해 현재 명령 번호를 포함하거나 일반 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC에서 대문자 앞의 소문자 속성은 심지어 0037 및 1047과 같은 라틴어 1 EBCDIC 페이지로 전달됩니다. 예를 들어 &quot;&amp;Euml;&quot;( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203)은 &quot;&amp;euml;&quot;( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235 ) 앞에옵니다. )를 ASCII 플랫폼에서 사용하지만 후자 (83)는 EBCDIC 플랫폼에서 전자 (115) 앞에옵니다. (Astute 독자들은 &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 의 대문자 버전 은 단순히 &quot;SS&quot;이며 &quot;&amp;yuml;&quot;(작은 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;micro;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; )의 대문자 버전은 0..255 범위이지만 유니 코드를 사용하는 유니 코드 사용 Perl).</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">프로토콜 (예 : &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">이 프로토콜은 또한 여러 표준 &lt;b&gt;번역을&lt;/b&gt; 정의합니다&lt;b&gt;&lt;/b&gt;파일이 전송 중에 겪을 수 있습니다. ASCII, EBCDIC, 이진 및 바이트입니다. ASCII는 기본 유형이며 파일 발신자가 줄 끝을 표준 표현으로 변환 한 다음 수신자가 다시 로컬 표현으로 변환 함을 나타냅니다. EBCDIC은 전송중인 파일이 EBCDIC 형식임을 나타냅니다. 이진 (이미지라고도 함) 형식은 데이터를 연속 비트 스트림으로 보냅니다. 바이트 형식은 데이터를 바이트로 전송하며, 그 값은 두 시스템 간의 바이트 크기 차이와 상관없이 동일하게 유지됩니다 (이론상 실제로는 실제로 수행중인 작업을 알고있는 경우에만 사용해야합니다). 이 클래스는 EBCDIC 또는 바이트 형식을 지원하지 않으며, 시도하면 대신 이진을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">'my'하위에 대한 프로토 타입 CV</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">프로토 타입 속성 및 기타 속성은 서명 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">속성의 프로토 타입은 서브의 프로토 타입 바로 다음에 서브에 할당됩니다. 즉, 둘 다 동시에 선언되면 기존에 정의 된 프로토 타입이 무시됩니다. 즉, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 은 &lt;code&gt;sub foo(@){}&lt;/code&gt; 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기위한 문자열과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기위한 배열 참조 요소 중 하나와 같아야합니다. 배열 참조는 위의 모든 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">제공된 인수는 유효성 검사를 통과하기 위해 정규식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">제공된 서브 루틴은 검증이 통과되고 인수가 승인 되려면 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">유사 해시 기능은 이전 버전의 Perl에서 도입되어 5.10.0에서 제거 된 실험 기능입니다. 의사 해시는 해시와 같은 명명 된 키를 사용하여 액세스 할 수있는 배열 참조입니다. 코드를 사용하는 일부 코드가 실행될 수 있습니다. 자세한 정보는 pragma &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">퍼블릭 API는 일관성을 유지해야합니다. 즉 서브 클래스가 오버로드를 추가하는 경우 서브 클래스는 동일한 이름을 사용해야합니다 (이 경우 badd ()). 그 이유는 Math :: BigInt가 객체 메소드를 직접 호출하도록 최적화 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">&lt;code&gt;SPAGAIN&lt;/code&gt; 매크로의 목적은 스택 포인터의 로컬 복사본을 새로 고치는 것입니다. 이는 Perl 스택에 할당 된 메모리가 재 할당 될 수 있기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">테스트의 목적은 두 가지입니다. 하나는 개발자가 다른 플랫폼에서의 테스트 부족으로 인해 코드에서 발생하는 문제를 해결하도록 돕는 것입니다. 주어진 모듈에서 특정 모듈이 작동하는지에 대한 정보를 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">이 문서의 목적은 C에서 직접 Perl 서브 루틴을 호출하는 방법, 즉 작성 방법을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">이 모듈의 목적은 광범위한 테스트 유틸리티를 제공하는 것입니다. 더 나은 진단 기능, 테스트 건너 뛰기 기능, 향후 기능 테스트 및 복잡한 데이터 구조 비교와 함께 &quot;확인&quot;하는 다양한 방법. 간단한 &lt;code&gt;ok()&lt;/code&gt; 함수를 사용하면 거의 모든 작업을 수행 할 수 있지만 진단 결과는 양호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">모듈의 목적, 범위 및 대상 응용</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">전반적인 에너지 소비를 줄이기 위해 많은 노력을 기울이는 품질. 다른 사람들이 유용하게 사용할 수있는 노동 절약 프로그램을 작성하고 작성한 내용을 문서화하므로 이에 대해 많은 질문에 대답 할 필요가 없습니다. 따라서 프로그래머의 첫 번째 미덕입니다. 따라서이 책도 마찬가지입니다. &lt;b&gt;조바심&lt;/b&gt; 과 &lt;b&gt;후부&lt;/b&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">문자열 동등성의 문제는 유니 코드에서 다소 복잡해집니다. &quot;같음&quot;은 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">SV가</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">물론 질문은 왜 이런 식으로 하시겠습니까? 시작 카운트가 아닌 세마포어를 만드는 이유 또는 왜 두 개 이상 감소 또는 증가합니까? 대답은 자원 가용성입니다. 액세스를 관리하려는 많은 자원을 한 번에 둘 이상의 스레드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">빠르고 더러운 방법은 주석 처리 된 코드를 소스에 남겨 두지 않을 경우에만 잘 작동합니다. 포드 파서가 나오면 여러 줄 주석이 포드 번역에 표시됩니다. 더 좋은 방법은 포드 파서에서도 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">둘 이상의 Perl 행을 주석 처리하는 빠르고 더러운 방법은 해당 행을 포드 지시문으로 묶는 것입니다. 이 지시문은 줄의 시작 부분과 Perl이 새로운 문장을 기대하는 곳에 두어야합니다 (따라서 &lt;code&gt;#&lt;/code&gt; 주석 과 같은 문장의 중간 부분은 아님). &lt;code&gt;=cut&lt;/code&gt; 으로 주석을 끝내고 포드 섹션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">몫은 항상 두 피연산자의 실제 몫보다 작거나 같은 가장 큰 정수이며, 나머지 (0이 아닌 경우)는 항상 두 번째 피연산자와 같은 부호를 갖습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">임의의 문자는 File :: Temp에서 제공되며 각 모듈의 개별 빌드 디렉토리가 고유한지 확인하십시오. 따라서 동시 프로세스에서 CPAN.pm을 동시에 안전하게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">범위 연산자 (목록 컨텍스트에서)는 피연산자가 문자열 인 경우 마술 자동 증가 알고리즘을 사용합니다. 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">범위 연산자 &lt;code&gt;..&lt;/code&gt; 을 ( 를) 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">범위 연산자는 마법의 자동 증가를 사용하여 문자열에서 작동합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">범위 연산자는 &quot;..&quot;이며 쉼표가 아닙니다. 쉼표 연산자는 C에서와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">범위 연산자는 쉼표가 아닌 &lt;code&gt;...&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">이를 요구하는 이유는 유니 코드가 등장하기 전에 작동 방식에 의존하는 오래된 프로그램을 중단하지 않는 것입니다. 이러한 이전 프로그램은 ASCII 문자 세트에 대해서만 알고 있으므로 추가 문자에 대해 제대로 작동하지 않을 수 있습니다. 문자열이 UTF-8로 인코딩되면 Perl은 프로그램이 유니 코드를 처리 할 준비가되어 있다고 가정하지만 문자열이 그렇지 않으면 Perl은 ASCII 만 필요하다고 가정하므로 ASCII 문자가 아닌 문자는 그렇지 않습니다 그들이 유니 코드로 무엇인지에 대해 인식했습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 문자열이 UTF-8로 인코딩되는지 여부에 관계없이 모든 문자를 유니 코드로 처리하도록하여 Perl에 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">텍스트가 &quot;|&quot;, &quot;/&quot;등으로 분할되기 전과 E &amp;lt;...&amp;gt; 코드가 확장되기 전에 원시 원본 L &amp;lt;...&amp;gt; 컨텐츠.</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">읽기 전용 매직 변수 &lt;code&gt;${^UNICODE}&lt;/code&gt; 는이 설정의 숫자 값을 반영합니다. 이 변수는 Perl 시작 중에 설정되며 이후 읽기 전용입니다. 런타임 효과를 원하면 three-arg open () ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ), two-arg binmode () ( &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; 참조 ) 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 )를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">이 과정의 실제 모습. 당신이 컴퓨터에있는 경우 동시에 여러 그룹에서 지원하는 회원은 공간이 당신에있는 그룹의 목록을 분리 준다. 첫 번째 숫자에 의해 반환되는 것과 &lt;code&gt;getgid()&lt;/code&gt; , 그리고에 의해 이후의 것들 &lt;code&gt;getgroups()&lt;/code&gt; , 하나의 수도 첫 번째 숫자와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OP의 실제 시퀀스 번호는 일반 번호이며 실제 프로그램의 시작에 상대적으로 조정되지 않습니다. ( &lt;b&gt;B :: Concise&lt;/b&gt; 는 모두 프로그램이 컴파일되기 전에 컴파일되기 때문에 일반적으로 상당히 큰 숫자 입니다).</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">실시간 타이밍은 time (2)를 사용하여 수행되므로 세분성은 1 초에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">이 과정의 실제 UID. &lt;code&gt;POSIX::setuid()&lt;/code&gt; 사용하여 실제 uid와 유효 uid를 동시에 변경할 수 있습니다 . &lt;code&gt;$&amp;lt;&lt;/code&gt; 로 변경 하면 시스템 호출이 필요하므로 &lt;code&gt;$!&lt;/code&gt; 를 확인하십시오 . 변경 후 가능한 오류를 감지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">실제 작업은 표준 유형 맵에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; 가 존재 하는 이유 는 다른 언어 태그가 동일한 언어를 나타낼 수 있기 때문입니다. 일반적으로 &lt;code&gt;same_language_tag&lt;/code&gt; 로 처리 할 수 있지만 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">내가 &quot;이 경우에&quot;라고 말한 이유는</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">print ()에서 리턴 값을 확인하지 않는 이유는 파이프 버퍼링 때문입니다. 물리적 쓰기가 지연됩니다. 닫힐 때까지 폭발하지 않으며 SIGPIPE와 함께 폭발합니다. 그것을 잡기 위해 이것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">그 이유는 CPAN이 시작할 때 모든 모듈의 종속성을 알지 못하기 때문입니다. 설치할 추가 항목을 결정하기 위해 META.yml 파일 또는 생성 된 Makefile에있는 데이터 만 사용합니다. 감지되지 않은 누락 된 조각은 프로세스를 중단시킵니다. 그러나 번들은 일부 종속 항목보다 나중에 일부 전제 조건을 설치하므로 두 번째 시도로 모든 것을 해결할 수 있습니다. CPAN.pm은 종속성 트리를 미리 알지 못하므로 설치할 항목 큐를 토폴로지 적으로 올바른 순서로 정렬 할 수 없습니다. 그것은 완벽하게 잘 해결 &lt;b&gt;하면&lt;/b&gt; 모든 모듈이 MakeMaker 또는에 PREREQ_PM 속성을 제대로 전제 조건을 선언이 &lt;code&gt;requires&lt;/code&gt; Module :: Build의 스탠자. 실패한 번들을 자주 설치해야하는 경우 번들 정의 파일을 수동으로 정렬하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">이 사용 불가능성에 대한 이유는 Perl의 기본 가정은 구문 분석 및 어휘 분석에 관심이있는 문자가 텍스트가 UTF-8인지 여부에 관계없이 동일하기 때문입니다. 예를 들어, Perl은 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 문자를 포함하는 문자열 (또는 프로그램 텍스트)이 UTF-8로 인코딩되었는지 여부에 관계없이 문자 &quot;[&quot; 가 동일한 표현을 가질 것으로 예상합니다 . 이를 보장하기 위해 Perl은 UTF-EBCDIC을 특정 코드 페이지에 맞게 조정하여 UTF-8 불변 일 것으로 예상되는 모든 문자가 실제로 UTF-8 불변 일 수 있도록합니다. 이는 Perl의 UTF-EBCDIC 버전을 실행하는 컴퓨터에서 생성 된 텍스트가 다른 버전을 실행하는 컴퓨터에서 이해할 수 있도록 번역되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">그 이유는 Encode :: Guess가 시행 착오로 인코딩을 추측하기 때문입니다. 먼저 $ data를 줄로 나누고 각 용의자에 대한 줄을 해독하려고 시도합니다. 하나의 인코딩을 제외한 모든 인코딩이 용의자 목록에서 제거 될 때까지 계속 진행됩니다. ISO-8859 시리즈는 대부분의 경우 너무 성공합니다 (\ x00- \ xff의 거의 모든 코드 포인트를 채우므로).</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">변수 보간과 코드 표현식이 함께 보안 상 위험하기 때문입니다. 검색 엔진을 작성하는 많은 프로그래머가 종종 사용자 입력을 받아 정규 표현식에 직접 연결하기 때문에이 조합은 위험합니다.</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">벤더 인코딩은 일반적으로 국가 표준의 상위 집합이므로 대부분의 경우 너무 모호해지기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">원하는 것을하지 않는 이유는 명명 된 배열을 스칼라에 할당하는 것이 스칼라 컨텍스트에서 배열을 취하기 때문입니다. 즉 @tmp의 요소 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">호스트 $ failed_ack_host가 유효한 ACK를받지 못한 이유입니다. ack ($ fail_ack_host)가 false 값을 반환하는 이유를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">이 함수의 이름에 &quot;_strictly&quot;가있는 이유는 RFC에 따라 Accept-Language 목록을 처리 할 때 RFC를 매우 엄격하게 해석하면 implicate_supers_strictly를 사용하지만 일반적으로 사용하기 때문입니다. -내가 아는 한, 감각 사용) 당신은 implicate_supers를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">이것이 필요한 이유는 시간 제어가 반환 된 펄 스택 영역이 다른 것에 의해 덮어 쓰여졌 기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">이것이 기본 동작이 아닌 이유는 압축을 풀어야 만 RFC 1951 컨텐츠를 감지 할 수 있기 때문입니다. 이 프로세스는 오류가 발생하기 쉽고 오 탐지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">이것이 기본 동작이 아닌 이유는 lzma_alone 컨텐츠는 압축 해제를 시도해야만 감지 할 수 있기 때문입니다. 이 프로세스는 오류가 발생하기 쉽고 오 탐지 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">이 잘못된 이유는, 당신은 포인터 사용 오는 시간이다 &lt;code&gt;rememberSub&lt;/code&gt; 에서 &lt;code&gt;CallSavedSub1&lt;/code&gt; 를 , 그것은 또는 정지에 기록 된 펄 서브 루틴을 참조하지 않을 수 있습니다 &lt;code&gt;SaveSub1&lt;/code&gt; . 다음과 같은 경우에 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">가장 중요한 생략 된 테스트의 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">인식되는 밝은 배경색 속성 (8 ~ 15 색)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">인식되는 일반 배경색 속성 (색상 0 ~ 7)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">인식되는 일반 전경색 속성 (색상 0 ~ 7)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new ()에 대해 인식되는 옵션은 다음과 같습니다. 모든 옵션은 단일 인수를 취합니다.</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">Tru64에서 권장되는 컴파일러는 네이티브 C 컴파일러입니다. 네이티브 컴파일러는 훨씬 빠른 코드 (속도 차이가 눈에 띄게 : 수십 퍼센트)와 더 정확한 코드를 생성합니다. GNU C 컴파일러 사용을 고려하는 경우 모든 이전 gcc 이후로 최소한 2.95.3 릴리스를 사용해야합니다 릴리스는 Perl을 컴파일 할 때 깨진 코드를 생성하는 것으로 알려져 있습니다. 이러한 손상의 한 가지 징후는 lib / sdbm 테스트 덤핑 코어입니다. 또 다른 하나는 op / regexp 및 op / pat 또는 ext / Storable 테스트 덤프 코어 (GCC 릴리스 및 최적화 플래그에 따른 정확한 실패 패턴)입니다.</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Perl 모듈 문서에서 권장되는 섹션 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">OS / 400 PASE에 Perl을 빌드하는 권장 방법은 AIX에서 Perl 5 소스 코드 (릴리스 5.8.1 이상)를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red () 및 green () 함수는 비슷합니다. 이를 만들기 위해 빌드하려는 함수 이름의 typeglob에 클로저를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 의 참조 횟수 는</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">지정된 각 &lt;code&gt;SV*&lt;/code&gt; 매개 변수 의 참조 카운트 가 감소합니다.</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">패드 이름 목록의 참조 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">패드 이름의 참조 카운트.</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">패드리스트의 참조 카운트. 현재 이것은 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 에서 &lt;code&gt;$bar&lt;/code&gt; 로의 참조 가 약해졌습니다. 때 &lt;code&gt;$bar&lt;/code&gt; 변수가 범위를 벗어나, 그것은 가비지 수집 될 것입니다. 다음에 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 키 의 값을 보면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">참조는 실제로 버려지고 마침내 우리가 다루고있는 것을 볼 수 있습니다. 우리의 인용은 완벽하게 유효하지만 우리의 목적에 맞지 않습니다. '와 jerry'는 문구가 아닌 두 개의 분리 된 단어로 취급되어 고르게 짝을 이루는 해시 구조를 정렬에서 제외시킵니다.</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">규칙 2에서 얻은 참조는 규칙 1에서 가져온 것과 동일한 종류의 참조입니다.</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">정규 표현식에는 단일 문자 그룹화가 있으며 4 문자 조합, 3 문자 조합 등을 고려하고 &lt;code&gt;\g1&lt;/code&gt; 을 사용 하여 반복을 찾습니다. 하지만 &lt;code&gt;$1&lt;/code&gt; 과 &lt;code&gt;\g1&lt;/code&gt; 같은 일을 대표하는주의가 일치 변수를 사용하도록주의해야한다 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 만</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">정규 표현식은 열린 괄호, 하나 이상의 대체 사본 및 가까운 괄호와 일치합니다. 대체는 양방향이며, 첫 번째 대안 &lt;code&gt;[^()]+&lt;/code&gt; 는 괄호없이 하위 문자열과 일치하고 두 번째 대안 &lt;code&gt;\([^()]*\)&lt;/code&gt; 는 괄호로 구분 된 하위 문자열과 일치합니다. 이 정규 표현식의 문제점은 병리학 적이라는 것입니다. &lt;code&gt;(a+|b)+&lt;/code&gt; 형식의 불확실한 정량자가 중첩되어 있습니다. 1 부에서 이와 같은 중첩 수량 화기가 일치하는 항목이없는 경우 실행하는 데 시간이 오래 걸리는 방법에 대해 논의했습니다. 기하 급수적 인 폭파를 방지하기 위해 어느 시점에서 쓸모없는 역 추적을 방지해야합니다. 내부 정량자를 독립 하위 표현식으로 묶어 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">정규 표현식 구조에는 정규 표현식을 올바르게 사용하기 위해 perl이 알아야 할 모든 데이터가 포함됩니다. 여기에는 perl이 정규식 엔진을 실제로 사용해야하는지 여부를 결정하는 데 사용할 수있는 최적화에 대한 데이터와 어떤 방식으로 고정 된 패턴과 같은 다양한 컨텍스트에서 패턴을 올바르게 실행하는 데 필요한 다양한 기타 제어 정보 또는 사용 된 플래그가 포함됩니다. 컴파일 중 또는 프로그램에 perl이 알고 있어야하는 특수 구문이 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">&lt;code&gt;//x&lt;/code&gt; 수정자가 없는 정규식 은</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">레고는</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">각 운영자에 대한 회귀 테스트는</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">정규식 엔진은 휘두르는 데 중요한 도구가 될 수 있습니다. 긴 문자열과 복잡한 패턴에서는 일치하는 항목을 찾기 위해 많은 작업을 수행해야하며 일치하는 항목이 없다고 결정해야 할 수도 있습니다. 다음 패턴과 같은 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">실행할 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">균형 잡힌 텍스트와 일치하는 정규 표현식은 두 가지 새로운 (Perl 5.10까지) 정규 표현식 기능을 사용합니다. 이것들은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에서 다루고 있으며이 예제는 그 문서에서 수정 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">관련 &lt;code&gt;base&lt;/code&gt; pragma는 기본 클래스의 &lt;code&gt;fields&lt;/code&gt; pragma 필드를 사용하여 선언 된 모든 필드를 결합합니다 . 이를 통해 필드 상속이 올바르게 작동합니다. 상속 된 필드는 재정의 될 수 있지만 경고가 활성화되면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 의 관련 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">입력 문자열의 나머지 (예 : 추출 된 문자열 뒤의 문자) 실패하면 전체 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">나머지 인수는 tar 파일에 포함될 파일을 나열합니다. 이 파일들은 모두 존재해야합니다. 존재하지 않거나 읽을 수없는 파일은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">나머지리스트-감소 함수는이 일반적인 아이디어의 모든 특수화입니다.</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">나머지 로케일 범주는 현재 Perl 자체에서 사용되지 않습니다. 그러나 Perl과 상호 작용하는 것은 표준 Perl 배포 외부의 확장, 운영 체제 및 유틸리티에 의한 확장을 포함하여 이러한 기능을 사용할 수 있습니다. 특히 문자열 값은 &lt;code&gt;$!&lt;/code&gt; 외부 유틸리티가 제공 한 오류 메시지는 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 에 의해 변경 될 수 있습니다 . 휴대용 오류 코드를 원하면 &lt;code&gt;%!&lt;/code&gt; 사용하십시오 ! . &lt;a href=&quot;errno&quot;&gt;Errno를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">&lt;code&gt;autosplit&lt;/code&gt; 에 대한 나머지 세 가지 인수는 다른 옵션을 autosplitter에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">나머지 변형 (예 : 16 진수-&amp;gt; oct, bin-&amp;gt; 16 진수 등)은 기울어 진 독자에게 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 의 반복 횟수 는 출력 라인 당 인코딩 할 최대 바이트 수로 해석되며 0, 1 및 2는 45로 대체됩니다. 반복 횟수는 65를 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perl이 표시 할 수있는 문자 레퍼토리는 Unicode Consortium에서 정의한 문자의 수퍼 세트입니다. 대부분의 플랫폼에 의해 반환되는 문자의 순서 값 &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; 은 IS</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">생성 된 보고서는 다음 형식으로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">그런 다음 각 변수, 서브 루틴 또는 형식 의 &lt;b&gt;패키지&lt;/b&gt; 별로 어휘 변수를 의미하는 특수한 &quot;(lexicals)&quot; &lt;b&gt;패키지&lt;/b&gt; 로 보고서를 그룹화 합니다. 각 &lt;b&gt;객체&lt;/b&gt; 이름 (포함하는 &lt;b&gt;Package로&lt;/b&gt; 암시 적으로 규정 됨 )에는 가능한 경우 처음에 유형 문자가 포함됩니다. 어휘 변수는 추적하기 쉬우 며 가능한 경우 역 참조 정보도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">보고서</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">요청은 작은 것으로 판단되었으므로이를 포괄 할 수있는 가능성은 perl이 컴파일 된 방법에 따라 다릅니다. 기본적으로 트래핑 할 수 없습니다. 그러나이를 위해 컴파일 된 경우, Perl은 &lt;code&gt;$^M&lt;/code&gt; 의 내용을 이 메시지와 함께 die () 후 비상 풀로 사용할 수 있습니다 . 이 경우 오류를 잡을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">요청이 항상 운영 체제로 항상 내려갈 필요는 없습니다. 바로 PerlIO 버퍼링이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">require 함수는 실제로 &quot;</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require 함수는 &quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">동안 필요한 인수 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 해시 패키지 및 대한 참조이다 &lt;code&gt;FETCH&lt;/code&gt; 보내고 기능. 선택적 인수는 임의의 스칼라 $ data, &lt;code&gt;EXISTS&lt;/code&gt; 함수에 대한 참조 및 해시 및 존재 캐시의 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">require 및 build_requires 종속성 선언</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">나머지는 MM_Unix의 중복 코드입니다. 링커 코드를 자체 메서드로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">나머지는이 패키지의 내부 사용을위한 것입니다. 특히 TIEHASH를 덮어 쓰면 SUPER :: TIEHASH를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">나머지 .pm 파일에는 확장에 대한 설명서를 제공하기위한 샘플 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">나머지 기능 설명은 들여 쓰기되거나 왼쪽으로 조정될 수 있습니다. 다음 예제는 본문이 왼쪽으로 조정 된 함수를 보여줍니다. 이 문서의 대부분의 예는 가독성을 높이기 위해 본문을 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분은 업데이트가 필요할 수 있지만 그 내용을 잘 모릅니다. &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt; 에게 의견을 보내주십시오 .</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">재가동 이전에 사용 구현 &lt;code&gt;longjmp&lt;/code&gt; 에 &lt;code&gt;regatom()&lt;/code&gt; (A)에 위로 &lt;code&gt;setjmp&lt;/code&gt; 는 에 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 하지만, 후자는 많은 자동 변수를 포함하는 많은 기능이기 때문에 이것은 문제가 될 것으로 판명되는 인터랙트 심하게의 출사 제어 흐름 &lt;code&gt;setjmp&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">비교 연산에 대한 제한 사항은 예를 들어 &lt;code&gt;cmp&lt;/code&gt; 가 축복 된 참조를 리턴해야하더라도 자동 생성 된 &lt;code&gt;lt&lt;/code&gt; 함수는 &lt;code&gt;cmp&lt;/code&gt; 결과의 숫자 값을 기반으로 표준 논리 값 만 생성한다는 것입니다 . 특히이 경우 작동하는 숫자 변환이 필요합니다 (다른 변환으로 표현 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">결과 &lt;code&gt;$^R&lt;/code&gt; 은 자동으로 현지화되므로 역 추적이있는 경우 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Regexp&lt;/code&gt; 는 인수가 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 결과 인 정규식 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Regexp&lt;/code&gt; 는 인수가 &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 결과 인 정규식 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">결과는 두 개의 인수로 반환됩니다. 모듈 식 곱셈 역수가 존재하지 않으면 두 인수가 모두 정의되지 않습니다. 그렇지 않으면 인수는 숫자 (객체)와 그 부호 ( &quot;+&quot;또는 &quot;-&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">결과적으로 파일의 17 행 내용이 &quot;Cherry pie&quot;로 대체됩니다. 개행 문자는 17 행을 18 행과 분리합니다. 이는이 코드가 아무 것도 수행하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">결과는 다음과 같이 유니 코드 문자 또는 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 16 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 0x00에서 0xFF 범위의 16 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 중괄호 사이의 8 진수로 지정된 문자입니다. 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">결과는 000에서 777 사이의 3 자리 8 진수로 지정된 문자입니다 (그러나 077 이상을 사용하지 않는 것이 가장 좋습니다. 다음 단락 참조). 어떤 문자에 대한 자세한 내용은 아래 &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">결과는 &lt;code&gt;xhdr&lt;/code&gt; 과 동일하지만 헤더의 텍스트가 &lt;code&gt;PATTERN&lt;/code&gt; 과 일치하는 헤더로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">결과는 일치하는 하위 패턴으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">마지막으로 성공한 &lt;code&gt;(?{ code })&lt;/code&gt; 정규식 어설 션 평가 결과 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ). 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_direction의 결과는 라디안으로 표시되며 0은 직선 북쪽, pi 또는 -pi 직선 남쪽, pi / 2 직선 서쪽 및 -pi / 2 직선 동쪽을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5 ( &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)의 결과는 md5 ( &quot;abc&quot;)의 결과와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">정수 범위를 오버플로 한 결과는 C에서도 정의되지 않기 때문에 정의되지 않습니다. 즉, 32 비트 정수를 사용하면 &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; 는 정의되지 않습니다. 음의 비트 수만큼의 이동도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">이 시나리오의 결과는 기껏해야 기대하는 것을 포함하지 않는 데이터베이스입니다. 최악의 경우 데이터베이스가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">반환 된 결과는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식이 유효한 경우 보간 된 재료를 포함하는 결과 문자열이 오염됩니다 .</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">결과는 각각 3 개의 요소로 구성된 배열이 될 것이며, 각각은 읽기, 쓰기 및 예외가있는 핸들을 보유 할 배열에 대한 참조입니다. 오류가 발생하면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">결과는 레이어 수의 3 배가됩니다 : 첫 번째 요소는 이름, 두 번째 요소는 인수 (지정되지 않은 인수는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 것입니다 ), 세 번째 요소는 플래그, 네 번째 요소는 다시 이름입니다. 앞으로.</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">결과 $ subdir_cmd에는 선행 탭이나 후행 줄 바꿈이 없습니다. 이렇게하면 make 문자열에 쉽게 포함 할 수 있습니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">결과 바이트 시퀀스는 체크섬을 확인하는 데 가장 편리합니다. 이 문자열 바이트 의 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 값을 추가하는 for 루프로 프로그램 속도를 늦추지 마십시오 . &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 코드 &lt;code&gt;%&lt;/code&gt; 는 모든 바이트의 8 비트 합계를 계산하는 데 사용하는 것으로 0과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">결과 경로는 기본적으로 상대적입니다. 즉 결과 경로에는 선행 콜론이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">결과 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로)를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;a href=&quot;#catpath()&quot;&gt;catpath ()&lt;/a&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로 ) 를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">결과는 &lt;code&gt;catpath()&lt;/code&gt; 로 전달되어 원래 경로와 동일한 경로 (일반적으로 동일한 경로 ) 를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">결과는 ASCII 규칙을 따릅니다. 문자 &lt;code&gt;A-Z&lt;/code&gt; 만 각각 &lt;code&gt;a-z&lt;/code&gt; 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">새 기호 테이블 항목을 직접 작성하거나 아직 유형 글로브가 아닌 항목을 수정 한 결과는 정의되지 않으며 perl 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 으로부터의 리턴 은 실제로 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라 패키지를 사용하여 문자열 화 된 버전 오브젝트 가 될 것입니다. 이는 동일하지만 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라 의 내용이 아닐 수도 있습니다 . 당신의 실제 내용하려면 &lt;code&gt;$VERSION&lt;/code&gt; 사용 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">생성 된 Perl 함수의 리턴 목록은 함수의 C 리턴 값 (XSUB가 &lt;code&gt;void&lt;/code&gt; 리턴 유형이거나 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; 가 사용 되지 않은 경우 )과 모든 &lt;code&gt;OUTLIST&lt;/code&gt; 및 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 매개 변수 (모양 순서대로)로 구성됩니다. XSUB에서 복귀하면 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl 매개 변수가 C 함수에 의해 쓰여진 값을 갖도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">인수가 조건을 만족하면 true를 리턴합니다. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; 는 정수가 아니며 홀수도 짝수도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">반환 값 (정의 된 경우)은 &lt;code&gt;PerlIO::Layer&lt;/code&gt; 클래스의 Perl 객체이며 C 코드에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">리턴 값 &lt;code&gt;LVALUE&lt;/code&gt; 는 변수가 아닌 lvalue에 대한 참조를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 호출의 참조를 가져 와서 이것을 얻습니다 . 참조가 &lt;a href=&quot;perldata#Version-Strings&quot;&gt;버전 문자열을&lt;/a&gt; 가리키는 경우 &lt;code&gt;VSTRING&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">리턴 값 &lt;code&gt;LVALUE&lt;/code&gt; 는 변수가 아닌 lvalue에 대한 참조를 나타냅니다. &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 호출의 참조를 가져 와서 이것을 얻습니다 . 참조가 &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;버전 문자열을&lt;/a&gt; 가리키는 경우 &lt;code&gt;VSTRING&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">리턴 값은 다음 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 원래 기준 구조체의 동일한 복사본을 돌아갈 ED. (신뢰할 수없는 출처의 평가 코드가 보안에 미치는 영향을 고려하십시오!)</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 의 반환 값 은 구현 정의되어 있습니다. 자세한 내용은 atan2 (3) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 의 반환 값 은 구현 정의되어 있습니다. 자세한 내용은 atan2 (3) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">반환 값은 &lt;code&gt;true&lt;/code&gt; 이 유효한 프로토 타입 인 경우, 그리고 &lt;code&gt;false&lt;/code&gt; 이에 관계없이 여부되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 했다 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">리턴 값은 POSIX와 유사하며 (8 비트 씩 이동), 원시 32 비트 조건 코드의 심각도 비트에서 파생 된 구성 값만 허용합니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하여&lt;/a&gt; 재정의하지 않는 한 ). 기본 조건 코드가 POSIX 값이 인코딩 된 코드 인 경우 예상 종료 값을 추출하기 위해 POSIX 값이 디코딩됩니다. 자세한 내용은 &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$?를&lt;/a&gt; 참조하십시오 . perlvms에서 . (VMS)</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">반환 값은 항상 스칼라 (문자열 또는 숫자)입니다. 값에 대한 동의어가있는 특성의 경우이 함수가 리턴하는 동의어 는 스칼라 컨텍스트에서 호출 될 때 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()에&lt;/a&gt; 의해 리턴되는 가장 길고 가장 설명적인 형식 입니다. 물론 결과에서 &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 를 호출 하여 다른 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">반환 값은 $ ctx 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 호출에 의해 리턴 된 프로그램의 종료 상태입니다 . 실제 종료 값을 얻으려면 8만큼 오른쪽으로 이동하십시오 (아래 참조). &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; 도 참조하십시오 . 이것은</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 호출에 의해 리턴 된 프로그램의 종료 상태입니다 . 실제 종료 값을 얻으려면 8만큼 오른쪽으로 이동하십시오 (아래 참조). &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; 도 참조하십시오 . 이것은</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 0 이상의 arrayref, integer 또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 포함하는 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">리턴 값은 상기 도시 된 바와 같이 제 1 내지 제 4 가중치의 배열 참조 일 수있다. 리턴 값은 아래와 같이 1 차 가중치로서 정수일 수있다. 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환되고, 기본 파생 조합 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) 의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) 의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">이 예에서 &lt;code&gt;INLINED&lt;/code&gt; 의 반환 값은 나중에 $ x 수정에 관계없이 항상 54321입니다. 서브 내에 임의의 코드를 넣을 수도 있습니다. 서브 코드는 즉시 실행되며 반환 값은 같은 방식으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; 의 반환 값 은 두 가지 해시입니다.</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Pod :: Perldoc :: GetOptsOO :: getopts의 반환 값은 오류가 없으면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDIN과 같은 표준 스트림에 대한 tell ()의 리턴 값은 운영 체제에 따라 다릅니다. -1 또는 다른 것을 리턴 할 수 있습니다. 파이프, fifo 및 소켓의 tell ()은 일반적으로 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">작업이 실패했거나 값이 실제로 해시 내에 저장 될 필요가없는 경우 반환 값은 NULL이됩니다 (연결된 해시의 경우). 그렇지 않으면 원래 &lt;code&gt;SV*&lt;/code&gt; 를 얻기 위해 역 참조 될 수 있습니다 . 호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 NULL을 리턴하면 감소시킵니다. 효과적으로 성공적인 hv_store는 &lt;code&gt;val&lt;/code&gt; 에 대한 하나의 참조 소유권을 갖습니다.. 이것은 일반적으로 원하는 것입니다. 새로 생성 된 SV의 참조 카운트는 1입니다. 따라서 모든 코드에서 SV를 생성 한 다음 해시에 저장하면 hv_store는 새 SV에 대한 유일한 참조를 소유하며 코드는 더 이상 수행 할 작업이 없습니다. 치우다. hv_store는 hv_store_ent에 대한 호출로 구현되지 않으며 키에 대한 임시 SV를 작성하지 않으므로 키 데이터가 아직 SV 형식이 아닌 경우 hv_store를 기본적으로 hv_store_ent보다 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">반환 값은리스트가됩니다. 첫 번째 값은 오류 조건이며 호스트 이름과 서비스 이름이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">반환 값은리스트가됩니다. 첫 번째 값은 오류 표시이며, 주소 구조 목록 (오류가 발생하지 않은 경우)이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">반환 값은 키가 메시지 번호이고 각 값에 해당 메시지의 개요 필드가 포함 된 배열에 대한 참조가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">반환 값은 키가 메시지 번호이고 각 값에 해당 메시지의 요청 된 헤더 텍스트가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">반환 값은 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 보다 &quot;요리&quot; 됩니다. 예를 들어, &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 속성 값은 입력 코드 포인트의 전체 대문자 매핑을 포함하는 실제 문자열입니다. 전체 매핑이 간단한 것과 다를 때 &lt;code&gt;upper&lt;/code&gt; 해시 요소 에서이 값을 얻으려면 &lt;code&gt;charinfo&lt;/code&gt; 를 사용 하여 추가 문제를 해결 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">리턴 된 오브젝트는 기본 OP 및 SV가 계속 존재하는 한 유효합니다. 기본 구조가 해제 된 후 오브젝트를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 해시의 원래 키 사본이므로 수정하면 원래 해시에 영향을 미치지 않습니다. &lt;a href=&quot;#values&quot;&gt;값을&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 해시의 원래 키 사본이므로 수정하면 원래 해시에 영향을 미치지 않습니다. &lt;a href=&quot;values&quot;&gt;값을&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 및 &lt;code&gt;Greek&lt;/code&gt; 과 같은 Perl 확장 등록 정보에 대해 리턴 된 값 은 다소 오해의 소지가 있습니다. 값은 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;입니다. 모든 유니 코드 속성은이 분식이므로 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; 과 같이 Perl 정규 rexpression에서 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;N&lt;/code&gt; &quot;을 실제로 사용할 수 있습니다 . 그러나 Perl 확장은 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; 와 같이이 방법으로 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl 인터프리터의 개정, 버전 및 하위 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 은 버전 객체 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl 인터프리터의 개정, 버전 및 하위 버전은 5.XXXYYY 형식의 10 진수로 표시됩니다. 여기서 XXX는 버전 / 1e3이고 YYY는 하위 버전 / 1e6입니다. 예를 들어 Perl v5.10.1은 &quot;5.010001&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">이 모듈의 재 작성된 버전 (vs. v0.01)은 &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;numify()&lt;/code&gt; 와 같은 특정 작업에서 느립니다 . 그 이유는 이제 더 많은 작업을 수행하고 더 많은 사례를 처리하기 때문입니다. 이러한 연산에 소요되는 시간은 일반적으로 다른 수학 연산에서 얻으므로 평균 코드가 훨씬 빨라집니다. 그렇지 않은 경우 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">속성이 일반적으로 예상되는 것과 다른 것을 의미하는 경우 오른쪽 열에도주의가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">라인 5에서 시작하는 오른쪽은 방금 본 것과 유사합니다. &lt;code&gt;add&lt;/code&gt; op ( &lt;code&gt;pp_add&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">연산자가 &quot;false&quot;상태 인 동안 오른쪽 피연산자가 평가되지 않고 연산자가 &quot;true&quot;상태 인 동안 왼쪽 피연산자가 평가되지 않습니다. 우선 순위는 ||보다 약간 낮습니다. &amp;amp;&amp;amp;. 리턴 된 값은 false의 경우 빈 문자열이거나 true의 경우 시퀀스 번호 (1부터 시작)입니다. 시퀀스 번호는 발생한 각 범위에 대해 재설정됩니다. 범위의 최종 시퀀스 번호에는 문자열 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; 이 추가되어 숫자 값에 영향을 미치지 않지만 엔드 포인트를 제외하려는 경우 검색 할 항목을 제공합니다. 시퀀스 번호가 1보다 커질 때까지 대기하여 시작점을 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">내부 텍스트에서 인수 텍스트를 시작하는 가장 오른쪽 분리 문자 ( &quot;&amp;gt;&quot;여야 함).</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree () 함수는 전달 된 인수에 대한 다른 해석으로 remove_tree ()의 레거시 인터페이스를 제공합니다. 함수의 동작 및 반환 값은 그렇지 않으면 remove_tree ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13 예제는 간단한 예제였습니다. 몇 가지 추가 기능을 보여주는 또 다른 데모가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">대략적인 perl은 &lt;code&gt;$myarray[$idx]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">&lt;code&gt;regtail()&lt;/code&gt; 루틴 은 &quot;꼬리 포인터&quot;를 올바르게 설정하기 위해 &lt;code&gt;reg()&lt;/code&gt; 와 &lt;code&gt;regbranch()&lt;/code&gt; 에 의해 호출 됩니다. 실행하고 분기가 끝날 때 그룹화 parens 다음에있는 노드로 이동해야합니다. 그러나 파싱 할 때 우리는 도착할 때까지 끝이 어디인지 알지 못하므로 돌아올 때 오프셋을 적절히 업데이트해야합니다. &lt;code&gt;regtail&lt;/code&gt; 은 이것을 쉽게하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 로 표시된 루틴은 치명적인 예외가 발생하려고 할 때 호출됩니다. 오류 메시지가 첫 번째 인수로 전달됩니다. 경우 &lt;code&gt;__DIE__&lt;/code&gt; 의 후크 루틴 복귀가 후크 부재에있는 것처럼 후크 루틴 자체를 통해 배출되지 않는 한, 예외 처리가 계속 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; 루프 종료 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러는 명시 적으로 당신이 죽을 수 있도록하는 것이, 통화 중에 사용할 수 없습니다 &lt;code&gt;__DIE__&lt;/code&gt; 의 핸들러입니다. &lt;code&gt;__WARN__&lt;/code&gt; 의 경우와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">가장 자주 사용되는 루틴은 &lt;code&gt;call_sv&lt;/code&gt; 입니다. &lt;code&gt;SV*&lt;/code&gt; 인수 중 펄 서브 루틴의 이름을 포함하는 호출 또는 서브 루틴을 참조한다. 두 번째 인수는 서브 루틴이 호출되는 컨텍스트, 서브 루틴의 인수 전달 여부, 오류 트랩 방법 및 리턴 값 처리 방법을 제어하는 ​​플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">그렇지 않으면 루틴은 &lt;b&gt;false를&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">루틴은 I / O 문제점 또는 기타 내부 오류에 대해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 하고 그렇지 않으면 true 값을 리턴합니다 . 심각한 오류는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 예외 로 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">루틴 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;reftype&lt;/code&gt; 은 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">루틴은 &lt;code&gt;make_path&lt;/code&gt; 및 &lt;code&gt;remove_tree&lt;/code&gt; 되어 &lt;b&gt;있지&lt;/b&gt; 기본적으로 수출했다. 사용할 것을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">루틴은 KEY의 문자열 비교 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Digest :: SHA가 유니 코드 문자열을 처리하는 규칙은 설명하기 쉽지만 이해하기 어려울 수 있습니다. 문자열은 일련의 바이트 값으로 해석되며 각 바이트 값은 서수 값 (즉, 코드 포인트)과 같습니다. 해당 유니 코드 문자 이렇게하면 유니 코드 문자열 'abc'는 일반 문자열 'abc'와 정확히 동일한 다이제스트 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">규칙에는 최상위 키가 하나만 있어야합니다. &quot;parallel&quot;의 경우 'par'또는 &quot;sequence&quot;의 경우 &quot;seq&quot;.</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">이식 가능한 코드의 기본 규칙은 다음과 같습니다. 이식 가능한 Perl에서 모두 수행하거나 모듈을 사용하십시오 (플랫폼 별 코드로 내부적으로 구현할 수 있지만 공통 인터페이스를 제공함).</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">규칙 데이터 구조는 다음 섹션에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">백 슬래시 뒤의 문자가 ASCII 문장 부호 (단어가 아닌) 문자 (즉, 문자, 숫자 또는 밑줄이 아닌 문자) 인 경우 백 슬래시는 그 뒤에 나오는 캐릭터의 특별한 의미.</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">다른 지침이없는 경우 먼저해야 할 일을 결정하는 행동 규칙. 예를 들어, 괄호가없는 경우 항상 더하기 전에 곱셈을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">런타임 구성 요소의 이름은</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">명령 행과 동일한 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 동일 하지만 누락 된 연산자를 자동 생성 할 수없는 경우 오류 메시지를 발행하는 대신 Perl은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문 이없는 경우 해당 연산자에 대해 수행 한 작업으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">동일한 체크섬을 OO 스타일로 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">위의 예와 다른 효과가 동일합니다. coderef는 별명 이름을 인수로 사용하고 성공하면 정식 이름을 반환하거나 그렇지 않으면 undef를 반환합니다. 제공된 경우 두 번째 인수는 무시됩니다. 정규식 버전보다 훨씬 신중하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">서브 루틴을 포함하거나 현재 실행중인 평가 된 문자열도 마찬가지입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">명령의 출력 끝에 동일한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 의 구현에 대해서도 마찬가지입니다 . : 피연산자를 수정해야합니다. 의 적절한 구현 &lt;code&gt;--&lt;/code&gt; 처럼 보일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">AIX 5.1 또는 다른 OS 레벨에서도 마찬가지입니다. 참고로, bos.adt.syscalls 및 bos.adt.libm을 설치하지 않으면 Perl을 빌드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">연속되지 않은 코드를 허용하는 동일한 패키지 이름을 두 번 이상 사용할 수 있습니다. 패키지 이름보다 강력한 순서 원칙이있는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">비 ISO8859-1 비 UTF-8 로케일에서 &lt;b&gt;-C&lt;/b&gt; 명령 행 을 사용 하여 표준 파일 핸들, 기본 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 레이어 및 &lt;code&gt;@ARGV&lt;/code&gt; 의 자동 UTF-8 인증을 사용하는 경우에도 동일한 문제점이 발생합니다. 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 환경 변수 ( &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 참조 ) 사물은 일반적으로 유니 코드 해석을 의미하는 UTF-8로 읽히지 만 로케일이 있으면 해당 로케일로 해석됩니다. 예를 들어, 유니 코드 입력의 0xD7 코드 포인트는 곱셈 부호를 의미해야하며 그리스어 로케일에서 Perl에 의해 해석되지 않습니다. 이것은 문제가되지 않습니다&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf () 객체를 전달하면 동일한 문제가 발생합니다. 이러한 루틴을 오버로드 할 수 없으므로 BigInt에서이를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">동일한 템플릿이 일반적으로 unpack ()에서도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">동일한 테스트가 두 번 실행되지만 &lt;code&gt;./perl harness&lt;/code&gt; 로 실행할 때 더 많은 정보가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">샘플 프로그램 :</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">스칼라 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값은 &lt;code&gt;PL_sv_undef&lt;/code&gt; 라는 SV 인스턴스에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">서브 루틴 및 할당의 오른쪽에 대한 스칼라 /리스트 컨텍스트는 서브 루틴 호출이 스칼라로 대체 된 것처럼 결정됩니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">위의 체계를 통해 특히 4 자리 연도를 사용하는 경우 광범위한 날짜를 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">uri의 구성표 (예 : 'file', 'http'등)</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 사용되는 범위에서 &lt;code&gt;void&lt;/code&gt; 경고 범주가 치명적 오류로 에스컬레이션 되었으므로 경고가 발생하면 프로그램이 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">스크립트는 먼저 &lt;code&gt;Name&lt;/code&gt; 클래스 의 기능을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">스크립트는 &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt; 에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">검색 엔진은 처음에 &lt;code&gt;\D*&lt;/code&gt; 와 &quot;ABC&quot;를 일치 시킵니다. 그런 다음 &lt;code&gt;(?!123)&lt;/code&gt; 을 &quot;123&quot;과 일치 시키려고 하는데 실패합니다. 그러나 정규 표현식에 수량 자 ( &lt;code&gt;\D*&lt;/code&gt; )가 사용되었으므로 검색 엔진은 완전한 정규 표현식과 일치시키기 위해 일치하는 방식으로 역 추적하고 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">두 번째 장점은 포함 된 수정 자 ( 전체 정규 표현식을 수정하는 &lt;code&gt;//p&lt;/code&gt; 제외 )는 포함 된 수정자가 포함 된 그룹 내부의 정규 표현식에만 영향을 미친다는 것입니다. 따라서 그룹화를 사용하여 수정 자의 효과를 지역화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">두 번째 및 세 번째 인수 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 은 지정된 유형의 데이터 구조 중 몇 개를 할당해야하는지 지정합니다. 인수 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;sizeof&lt;/code&gt; 로 전달됩니다 . &lt;code&gt;pointer&lt;/code&gt; 인수가 &lt;code&gt;type&lt;/code&gt; 인수 와 다른 경우 &lt;code&gt;Newxc&lt;/code&gt; 의 마지막 인수 인 &lt;code&gt;cast&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">두 번째 인수 ($ eol)는 사용할 행 끝 순서입니다. 선택 사항이며 기본값은 &quot;\ n&quot;입니다. &quot;\ n&quot;이 나타날 때마다이 문자열로 바뀌고 추가 &quot;소프트 줄 바꿈&quot;에도 사용되어 줄이 76자를 넘지 않도록합니다. 외부 소비에 적합한 데이터를 생성하려면 &quot;\ 015 \ 012&quot;로 전달하십시오. 문자열 &quot;\ r \ n&quot;은 많은 플랫폼에서 동일한 결과를 생성하지만 전부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 번째 인수는 옵션이있는 해시 참조 일 수 있으며 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 전달 된 인수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">두 번째 인수는 정규식입니다. 정규 표현식 처럼 보이는 문자열로 정규 표현식 참조 (예 : &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ) 또는 (이전의 perls와의 호환성을 높이기 위해) 제공 될 수 있습니다 (대체 구분 기호는 현재 지원되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">두 번째 인수는 정규식 객체이거나 정규식처럼 보이는 문자열 인 경우 정규식으로 간주됩니다. 정규식 객체는 최신 버전의 perl에서 qr // 연산자로 구성됩니다. 첫 번째와 마지막 문자가 &quot;/&quot;이거나 첫 번째 문자가 &quot;m&quot;이고 두 번째와 마지막 문자가 모두 영숫자가 아닌 비 공백 문자 인 경우 문자열은 정규식처럼 보입니다. 이 정규 표현식</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">두 번째 인수는 다른 피연산자이거나 단항 연산자의 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">두 번째 인수는 압축을 나타내는 데 사용됩니다. &lt;code&gt;gzip&lt;/code&gt; 또는 &lt;code&gt;bzip2&lt;/code&gt; 를 사용하여 압축 할 수 있습니다 . 숫자를 전달하면 &lt;code&gt;gzip&lt;/code&gt; 압축 수준 (1과 9 사이)으로 가정되지만 상수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">두 번째 인수는 선택 사항으로 간주 될 수 있지만 이전 버전과의 호환성을 위해 남아 있습니다. Archive :: Tar는 이제 파일 매직을보고 파일을 여는 데 사용할 클래스를 결정하고 투명하게 올바른 일을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 포함 된 배열을 가리 킵니다 . AV가 생성되면 원하는 경우 SV를 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">hex ()에 대한 두 번째 호출은 이식 불가능한 상수에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">$ term-&amp;gt; readline 호출 전에 콜백을 등록한 경우 두 번째 콜백은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">등록 된 두 번째 콜백은 등록을위한 콜백입니다. 입력 파일 핸들 (종종 STDIN이지만 반드시 그런 것은 아님)이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">두 번째 열은 반환 유형이고 세 번째 열은 이름입니다. 그 후의 열이 인수입니다. 첫 번째 열은 플래그 집합입니다.</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">시놉시스의 두 번째 예는 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">두 번째 예는 이름이 &lt;code&gt;foo&lt;/code&gt; 인 항목과 이름이 &lt;code&gt;bar&lt;/code&gt; 로 끝나 거나 5 자보다 짧은 항목을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">입력 버퍼에 남아있는 데이터가있을 경우 두 번째 종료점 테스트는 &lt;code&gt;$input&lt;/code&gt; - 기억 &lt;code&gt;ConsumeInput&lt;/code&gt; 의 경우 옵션이 자동으로 활성화됩니다 &lt;code&gt;LimitOutput&lt;/code&gt; 가 사용됩니다. 입력 버퍼가 소진되면 외부 루프가 다시 실행되고 이제 빈 &lt;code&gt;$input&lt;/code&gt; 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">두 번째 형식은 필터가 클로저를 사용하여 상태 정보를 보유 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">두 번째 형식은 서브 클래스가 부모의 생성자를 재사용 할 수있는 능력을 상실하기 때문에 권장하지 않지만 기존 코드에서 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">두 번째 양식은 다음 예와 같이 쉘 글 로빙으로 출력을 제한하거나 확장합니다.</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">두 번째 형식은 &quot;0&quot;및 &quot;1&quot;문자의 ASCII 문자열을 인수로 사용합니다. 그것은 동등하다</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">편의상 두 번째 형식 은 개체를 즉시 덤프하기 전에 인수 에서 &lt;code&gt;new&lt;/code&gt; 메서드를 호출하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">두 번째는 체인의 각 깊이에 몇 개의 키가 있는지에 대한 데이터를 제공하고 가져 오기 * hit *가 얼마나 많은 작업을 수행하는지에 대한 아이디어를 제공합니다. 해시에서 항목의 업데이트 또는 삭제 성능은이 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">두 번째는</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">두 번째는 물음표 &lt;code&gt;?&lt;/code&gt; 모든 단일 문자와 일치합니다. 세 번째는 특정 문자 집합을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">두 번째는 요컨대 더 읽기 쉽습니다. 특히, 당신이 그 구에 공급하는 매개 변수의 수 (2)는 그것이 그 매개 변수의 수라는 것이 명백합니다</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">두 번째 방법은 AV를 생성하고 처음에 SV로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">두 번째 방법은 생성 된 코드를</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">두 번째 새 디스플레이 매개 변수는 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; 이며, 기본값은 true 또는 false로 설정할 수 있습니다. 이것이 의미하는 바는 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">두 번째 옵션은 올바른 디렉토리에 &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; 및 &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; 를 제공&lt;b&gt;하고&lt;/b&gt; &quot;make test&quot;를 실행하기 전에 LD_LIBRARY_PATH를</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">두 번째 매개 변수 &lt;code&gt;$mode&lt;/code&gt; 는 파일을 읽거나 쓸 수 있도록 열지 여부를 지정하고, 쓸 때 압축 수준과 압축 전략을 선택적으로 지정하는 데 사용됩니다. &lt;code&gt;$mode&lt;/code&gt; 매개 변수 의 형식은 'C'함수 &lt;code&gt;fopen&lt;/code&gt; 의 mode 매개 변수와 유사 하므로 &quot;rb&quot;는 읽기를 위해 열고, &quot;wb&quot;는 쓰기를 위해, 추가하려면 &quot;ab&quot;를 사용하여 추가합니다 ( 파일).</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 시작 부분에서만 일치하도록 제한 하기 때문에 두 번째 정규 표현식이 일치하지 않지만 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; 는 중간부터 시작합니다. &lt;code&gt;$&lt;/code&gt; 제한 &lt;code&gt;keeper&lt;/code&gt; 가 문자열의 끝에서만 일치하기 때문에 세 번째 정규 표현식이 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">두 번째 반품 및 &lt;code&gt;$!&lt;/code&gt; 유효한 입력을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">두 번째 문장이 잘못되었습니다. 실제로 dbopen의 openinfo 매개 변수가 NULL 인 경우 bval의 기본값은 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 입니다. NULL이 아닌 openinfo 매개 변수가 전혀 사용되지 않으면 bval에있는 값이 사용됩니다. 즉, openinfo 매개 변수의 옵션을 사용할 때 항상 bval을 지정해야합니다. 이 설명서 오류는 다음 Berkeley DB 릴리스에서 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">두 번째 상황은 예를 들어 범위를 벗어난 어휘 서브 루틴에 액세스하는 평가로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">두 번째 상황은 예를 들어 범위를 벗어난 변수에 액세스하는 평가로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">번들링의 두 번째 스타일은이 제한을 해제합니다. 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">출력 문자열에서 대체 될 두 번째 값 (일반적으로 커서 주소 지정 기능의 행)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">두 번째로 더 효율적인 방법은 Foo.xs에 다음 템플릿을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">섹션 (이전 perlpod의 AKA &quot;항목&quot;) 또는 정의 되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 예를 들어 &quot;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&quot;에서 &quot;DESCRIPTION&quot;은 섹션입니다. (이것은 &quot;man 5 crontab&quot;의 &quot;5&quot;와 같은 맨 페이지 섹션과 동일하지 않습니다. 포드 의미의 &quot;섹션 Foo&quot;는 제목이 도입 한 텍스트 또는 텍스트가 &quot;Foo&quot;인 항목의 일부를 의미합니다. &quot;.)</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">파일 핸들과 파일 이름이 함께 리턴되도록 임시 파일 작성의 보안 측면이 강조됩니다. 이렇게하면 파일 존재 여부와 열기를 확인하는 다른 프로세스에서 임시 파일을 만들 때 경쟁 조건이 발생하지 않도록 보장 할 수 있습니다. 예를 들어, 고정 비트가 세계 쓰기 가능 디렉토리에 설정되어 있는지 확인하기 위해 추가 보안 레벨이 제공됩니다. 자세한 내용은 &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">Perl에서 겉으로 동등한 구성 인 &lt;code&gt;$$aref[$i]&lt;/code&gt; 먼저 $ aref의 deref를 수행하여 배열에 대한 참조로 $ aref를 취한 다음 역 참조하고 마지막으로</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">멀티 스레드 프로그램에 대한 간격 타이머의 의미는 시스템마다 다르며 일부 시스템은 추가 간격 타이머를 지원할 수 있습니다. 예를 들어 어떤 스레드가 신호를 가져 오는지는 지정되지 않습니다. &lt;code&gt;setitimer()&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;!~&lt;/code&gt; 연산자 를 사용하여 일치를 반전시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">시퀀스 &lt;code&gt;\b&lt;/code&gt; 는 대괄호로 묶은 문자 클래스 내에서 특별합니다. 문자 클래스 외부에있는 &lt;code&gt;\b&lt;/code&gt; 는 괄호 문자 클래스 내부에서 양쪽에 두 개의 단어 문자 또는 두 개의 비 단어 문자가없는 지점을 나타내는 어설 션 입니다. &lt;code&gt;\b&lt;/code&gt; 는 백 스페이스 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">OP의 다음 OP의 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">OP의 시퀀스 번호 또는 하이픈이없는 경우 하이픈입니다.</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OP의 시퀀스 번호. 이것은 B :: Concise에 의해 생성 된 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\x&lt;/code&gt; 시퀀스 도 특별하며 동일한 의미를 갖습니다. 대괄호로 묶은 문자 클래스 외부에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">직렬화 중에 객체에서 호출 된 직렬화 후크. 다른 메소드와 마찬가지로 상속되거나 클래스 자체에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">$ addts에 제공된 소켓 유형에 대해 getaddrinfo ()에 제공된 서비스 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">코드의 일부는 &lt;b&gt;구현&lt;/b&gt; 과 달리 영원히 제공하겠다고 약속하는 서비스로 , 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">세트는 문자 목록 또는 범위의 시작과 끝이 빼기 (또는 대시) 문자로 구분되는 문자 범위 또는 목록과 범위의 조합으로 지정됩니다. 또한 세트의 시작 또는 끝인 경우 대시를 문자로 세트에 포함시킬 수 있습니다. 이 세트는 대괄호로 묶습니다. 닫는 대괄호 &lt;code&gt;]&lt;/code&gt; 는 세트의 첫 번째 문자 인 경우 세트에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">공백으로 간주되는 문자 세트는 유니 코드가 &quot;패턴 공백&quot;이라고하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale 함수</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">서브 루틴 속성 설정은 컴파일시 발생합니다. 변수 속성 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 컴파일시에 적용됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수는 런타임에 속성이 적용됩니다. 이것은 당신이해야한다는 것을 의미합니다</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">7 가지 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">시트</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">쉘은 다음과 같이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">쉘의 &lt;code&gt;test&lt;/code&gt; 는 문자열 비교에 &quot;=&quot;, &quot;! =&quot;, &quot;&amp;lt;&quot;등을 사용하고 숫자 비교에 &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot;등을 사용합니다. 이것은 사용하는 펄의 역이다 &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 문자열 비교를 위해, 그리고 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 등 수치 비교를 위해.</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">짧은 대답은 기본적으로 Perl은 문자의 코드 포인트만을 기준으로 동등성 ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; )을 비교한다는 것입니다 . 위의 경우 대답은 아니요입니다 (0x00C1! = 0x0041). 그러나 때로는 대문자로 된 A가 모두 같거나 어떤 경우에도 A로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">짧은 대답은 기본적으로 Perl은 문자의 코드 포인트만을 기준으로 문자열 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; )을 비교한다는 것입니다. 위의 경우 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 이기 때문에 대답은 &quot;after&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">일반 카테고리의 짧은 이름</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">짧은 이야기</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">짧은 이야기는 아마도 집계 (배열 및 해시)가 아닌 스칼라 또는 함수에서만 정의되어야한다는 것입니다. 자세한 내용 은 Perl 5.004 릴리스 이상에 &lt;a href=&quot;functions/defined&quot;&gt;정의&lt;/a&gt; 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">&lt;code&gt;/^[+-]$/&lt;/code&gt; 부호 는 별도로 저장됩니다. 문자열 'NaN'은 입력 인수가 숫자가 아닐 때의 결과와 0으로 나눈 결과를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'이며 별도로 저장됩니다. sign () 메소드로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'입니다.</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">부호는 '+', '-', 'NaN', '+ inf'또는 '-inf'입니다. sign () 메소드로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">서명은 서브 루틴 본문의 일부입니다. 일반적으로 서브 루틴의 본문은 단순한 코드 블록입니다. 서명을 사용할 때 서명은 서브 루틴 이름 바로 뒤에 오는 괄호로 묶은 목록입니다. 서명은 블록 범위에있는 어휘 변수를 선언합니다. 서브 루틴이 호출되면 서명이 먼저 제어됩니다. 전달 된 인수 목록에서 서명 변수를 채 웁니다. 인수 목록이 서명의 요구 사항을 충족하지 않으면 예외가 발생합니다. 서명 처리가 완료되면 제어가 블록으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">이들 각각의 의미는 나머지 자습서에서 설명하지만 지금은 메타 문자를 백 슬래시 앞에 두어 일치시킬 수 있다는 것을 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">비슷한 이름의 &lt;code&gt;\p{Punct}&lt;/code&gt; 속성 은 ASCII 범위의 다소 다른 세트, 즉 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; ,. / :; @ [\\\] _ {}] 과 일치합니다 . 즉, 9 개의 문자 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . 이것은 POSIX가 문장 부호로 간주하는 것을 문장 부호와 기호의 두 범주로 나누기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">간단한 규칙은 다음과 같습니다. 비 메소드를 자동로드 할 때 상속이 작동하지 않습니다. 이전 코드에 대한 간단한 수정 사항은 다음과 같습니다. &lt;code&gt;BaseClass&lt;/code&gt; 라는 기본 클래스에서 메소드가 아닌 메소드에 대한 &lt;code&gt;AUTOLOAD&lt;/code&gt; 상속에 의존하는 데 사용한 모든 모듈 에서 시작 중에 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">간단한 stdio 구현은 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">가장 단순한 XSUB는 리턴 값 설명, XSUB 루틴 이름 및 인수 이름, 인수 유형 또는 형식에 대한 설명의 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">가장 간단한 경우는 정수입니다. 선택적인 부호가 앞에있는 일련의 숫자로 구성됩니다. &lt;code&gt;\d+&lt;/code&gt; 나타낼 수있는 숫자 와 부호는 &lt;code&gt;[+-]&lt;/code&gt; 와 일치 할 수 있습니다 . 따라서 정수 정규 표현식은</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 사용합니다 . 왼쪽 또는 오른쪽을 공백으로 채우고 왼쪽을 0으로 채울 수 있으며 결과가 잘리지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 기능은 패드 공백으로 오른쪽에 문자열과 그것의 최대 길이로 결과를 자릅니다 수 &lt;code&gt;$pad_len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">가장 간단한 정규식은 단순히 단어 또는 더 일반적으로 문자열입니다. 단어로 구성된 정규식은 해당 단어가 포함 된 모든 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">가장 간단한 정규 표현식은 단순히 단어 또는 더 일반적으로 문자열입니다. 단어로 구성된 정규 표현식은 해당 단어가 포함 된 모든 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">가장 간단한 번들링 스타일은 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Perl에서 빌드하는 가장 간단한 2 단계 데이터 구조는 배열의 배열이며, 때로는 목록 목록이라고도합니다. 합리적으로 이해하기 쉽고 여기에 적용되는 거의 모든 것이 나중에 더 멋진 데이터 구조로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">가장 간단한 유형의 op 구조는 &lt;code&gt;OP&lt;/code&gt; 입니다 . 여기에는 자식이 없습니다. 단항 연산자 ( &lt;code&gt;UNOP&lt;/code&gt; )에는 자식이 하나 있으며 &lt;code&gt;op_first&lt;/code&gt; 필드 가이를 지적 합니다. 이진 연산자 ( &lt;code&gt;BINOP&lt;/code&gt; )에는 &lt;code&gt;op_first&lt;/code&gt; 필드뿐만 아니라 &lt;code&gt;op_last&lt;/code&gt; 필드도 있습니다. 가장 복잡한 유형의 op는 &lt;code&gt;LISTOP&lt;/code&gt; 이며 많은 수의 자식이 있습니다. 이 경우 첫 번째 자식은 &lt;code&gt;op_first&lt;/code&gt; 로 가리 킵니다. 로, 마지막 자식은 &lt;code&gt;op_last&lt;/code&gt; 로 가리 킵니다 . 그 사이의 자식은 첫 번째 자식에서 마지막 자식까지 &lt;code&gt;OpSIBLING&lt;/code&gt; 포인터를 반복적으로 따라 가면서 찾을 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">이를 수행하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">이 라이브러리를 사용하는 가장 간단한 방법은 md5_hex () 함수 (또는 그 사촌 중 하나)를 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">스레드를 만드는 가장 간단하고 간단한 방법은 &lt;code&gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">단일 매개 변수 &lt;code&gt;cb1&lt;/code&gt; 은 함수에 대한 포인터이므로 정의해야합니다. &lt;code&gt;cb1&lt;/code&gt; 코드에서 cb1 을</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">의 상황 &lt;b&gt;&lt;/b&gt;주변 환경 (코드를 호출하는 코드)에서 단일 값이 아닌 값 목록을 반환&lt;b&gt; 식이&lt;/b&gt; 예상되는 . 원하는 기능</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">주변 ( &lt;b&gt;표현식&lt;/b&gt; 코드)에서 &lt;b&gt;표현식&lt;/b&gt; 이 &lt;b&gt;값 &lt;/b&gt;&lt;b&gt;목록&lt;/b&gt; 이 아닌 단일 &lt;b&gt;값&lt;/b&gt; 을 반환 할 것으로 예상되는 상황입니다 . &lt;b&gt;context&lt;/b&gt; 및 &lt;b&gt;list context&lt;/b&gt; 도 참조하십시오 . 스칼라 컨텍스트는 때때로 반환 값에 추가 제약을 부과 &lt;b&gt;합니다 (문자열 컨텍스트&lt;/b&gt; 및 &lt;b&gt;숫자 컨텍스트 참조)&lt;/b&gt; . 때로는 조건부 내부 의 &lt;b&gt;부울 컨텍스트&lt;/b&gt; 에 대해 이야기 하지만 numeric 또는 &lt;b&gt;string&lt;/b&gt; 스칼라 값 이 이미 true 또는 false 이므로 스칼라 값이 추가로 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">주변 (코드를 호출하는 코드)에서 표현식이 &lt;b&gt;문자열&lt;/b&gt; 을 리턴 할 것으로 예상되는 상황입니다 . 도 참조 &lt;b&gt;컨텍스트&lt;/b&gt; 및&lt;b&gt; numeric context&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">주변 (코드를 호출하는 코드)에서 표현식이 숫자를 반환 할 것으로 예상되는 상황입니다. &lt;b&gt;context&lt;/b&gt; 및 &lt;b&gt;string context&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">비표준 장소에 추가 모듈을 설치하는 데 사용할 수있는 MakeMaker와 같은 도구의 경우 상황이 훨씬 명확하지 않습니다. 예를 들어, 사용자가 개인 디렉토리에 모듈을 설치하려는 경우 (아마도 &lt;code&gt;PREFIX&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">이것이 필요한 상황은 아마도 매우 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">정규식에서 일치하는 유니 코드 속성 인 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 이러한 코드 포인트에 대해 구문 은 명확하지 않으며 경험을 통해 이러한 방식을 처리하는 방식이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">파일의 크기가 결정되고 일반 파일을 위해 서버로 자동 전송되므로 소켓, 명명 된 파이프 또는 일반 파일과 관련되지 않은 다른 스트림에서 데이터를 전송하는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">인스턴스 별 데이터 구조의 크기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">다루고있는 작품의 크기, 정신적으로 말하면.</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">사이즈 지정자 &lt;code&gt;V&lt;/code&gt; 는 Perl 코드에는 영향을 미치지 않지만 XS 코드와의 호환성을 위해 지원됩니다. &quot;Perl 정수 또는 부동 소수점 숫자에 표준 크기 사용&quot;을 의미합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">생략 된 접두사 (예 : 추출 된 문자열 앞의 문자) 실패하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">느리지 만 뛰어난 수정은 환경 변수의 잘못된 구성을 직접 수정할 수있는 경우입니다. 전체 시스템 로케일의 잘못된 구성은 대개 친숙한 시스템 관리자의 도움이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">변경 사항이 작고 지역화 될수록 좋습니다. 마찬가지로 일련의 작은 패치가 하나의 큰 패치보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">문자열의 가장 작은 개별 요소. 컴퓨터는 문자를 정수로 저장하지만 Perl을 사용하면 문자를 텍스트로 조작 할 수 있습니다. 특정 문자를 나타내는 데 사용되는 정수를 해당 문자의 &lt;b&gt;codepoint&lt;/b&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">일치하는 것을 찾으면 스마트 일치가 중지되므로 모든 표현을 시도 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">스마트 매치는 암시되지 않은 해시 또는 배열 참조를 암시 적으로 역 참조하므로 이러한 경우 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; 항목이 적용됩니다. 축복받은 참고 문헌의 경우, &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; 항목이 적용됩니다. 해시와 관련된 스마트 매치는 해시 키만 고려하고 값을 해시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">스마트 매치 연산자는 대부분 &lt;code&gt;when&lt;/code&gt; 절의 암시 적 연산자로 사용됩니다 . &lt;a href=&quot;perlsyn&quot;&gt;perlsyn의&lt;/a&gt; &quot;스위치 설명&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">네트워크가 구성되어 있지 않으면 소켓 테스트에 실패 할 수 있습니다. &quot;/ hurd / pfinet&quot;를 &quot;/ servers / socket / 2&quot;에 대한 번역기로 지정하여 올바른 인수를 제공해야합니다. 자세한 내용은 &quot;/ hurd / pfinet --help&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">소켓 유형 (예 : &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">이 모듈의 유일한 목적은 명령 줄에서 색상을 강조 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">해결책은 하위 디렉토리 에서 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 을 제거 할 디렉토리 트리 외부에 배치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">우리가 단어에 넣는 캐릭터의 종류. 유니 코드에서 이것은 모든 표의 문자 및 분음 부호, 로마 숫자와 같은 문자 번호 및 다양한 결합 표시를 포함한 모든 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">정렬 순서는 ASCII 플랫폼과 EBCDIC 플랫폼에서 얻은 결과간에 차이가 발생합니다. 다음은 이러한 차이점을 처리하는 방법에 대한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">소스 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">소스 버퍼 &lt;code&gt;$source&lt;/code&gt; 는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">확장의 소스 코드는 일반적으로 자체 디렉토리에 있습니다. 일반적으로 3 개 이상의 파일이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">소스 코드에는 선택할 수있는 여러 해시 알고리즘이 포함되어 있습니다. 우리는 기본 펄 해시가 공격하기에 강력하다고 생각하지만 해시 함수 Siphash를 대체 옵션으로 포함 시켰습니다. Perl 5.18.0의 출시 시점에서 Siphash는 암호화 수준으로 여겨집니다. 기본 해시보다 훨씬 느리므로 기본값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">소스 코드 위치는 개발자 도구가 설치된 경우 &lt;b&gt;에만&lt;/b&gt; 지원 &lt;b&gt;됩니다&lt;/b&gt; . (BFD는 필요 &lt;b&gt;하지&lt;/b&gt; 않습니다.)</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test :: More의 소스 코드 저장소는 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">소스 필터 배포에는이 작업을 단순화하는 &lt;code&gt;Filter::exec&lt;/code&gt; 및 &lt;code&gt;Filter::sh&lt;/code&gt; 두 모듈이 포함되어 있습니다. 둘 다 외부 실행 파일을 실행할 수 있습니다. 둘 다 코 프로세스를 사용하여 외부 실행 파일의 데이터 흐름을 제어합니다. (coprocesses에 대한 자세한 내용은 스티븐스, WR, &quot;유닉스 환경에서 고급 프로그래밍&quot;을 참조하십시오. 애디슨 - 웨슬리, ISBN 0-210-56317-7, 페이지 441-445입니다.) 그들 사이의 차이는 즉 &lt;code&gt;Filter::exec&lt;/code&gt; 급부상을 직접 외부 명령, 동안 &lt;code&gt;Filter::sh&lt;/code&gt; 급부상 쉘은 외부 명령을 실행합니다. (Unix는 Bourne 쉘을 사용하고 NT는 cmd 쉘을 사용합니다.) 쉘을 생성하면 쉘 메타 문자 및 리디렉션 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">소스를 설정해야 구문 분석 할 수 있습니다. 가장 낮은 수준의 방법은 &lt;code&gt;set_source&lt;/code&gt; 를 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">이 모듈에서 사용되는 ISO 3166-1 2 자리 코드의 소스.</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">공식 ISO 3166-1 3 자리 코드 및 3 자리 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; 의 특별한 인수 는 전체 도움말 페이지를 생성하는데, 이는 상당히 길다.</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">특별 부기 Perl은 프로그램을 통한 외부 데이터의 흐름을 추적하고 시스템 명령에서 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자로 작동하므로 연속 된 문자 세트를 범위로 작성할 수 있습니다. 범위가 있으면 다루기 힘든 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 가 날카로운 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; 됩니다. 몇 가지 예는</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">특수 문자 &lt;code&gt;'-'&lt;/code&gt; 는 문자 클래스 내에서 범위 연산자로 작동하므로 다루기 어려운 &lt;code&gt;[0123456789]&lt;/code&gt; 및 &lt;code&gt;[abc...xyz]&lt;/code&gt; 가 스 벨트 &lt;code&gt;[0-9]&lt;/code&gt; 및 &lt;code&gt;[a-z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">문자 클래스의 첫 번째 위치에서 특수 문자 &lt;code&gt;^&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">문자 클래스의 첫 번째 위치에서 특수 문자 &lt;code&gt;^&lt;/code&gt; 는 괄호 안에있는 문자 이외의 문자와 일치 하는 &lt;b&gt;부정 문자 클래스를&lt;/b&gt; 나타냅니다 . 두 &lt;code&gt;[...]&lt;/code&gt; 및 &lt;code&gt;[^...]&lt;/code&gt; 문자와 일치해야하며, 일치에 실패합니다. 그때</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 의 명령 줄 파일 이름을 반복하는 특수 파일 핸들입니다 . 일반적으로 각도 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 널 파일 핸들로 작성됩니다 . 현재 &lt;code&gt;ARGV&lt;/code&gt; 는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 내에서만 마법 효과를 나타냅니다 . 다른 곳에서는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 의해 열린 마지막 파일에 해당하는 일반 파일 핸들 입니다. 특히, 파일 핸들을 기대하는 함수에 매개 변수로 &lt;code&gt;\*ARGV&lt;/code&gt; 를 전달 하면 함수가 &lt;code&gt;@ARGV&lt;/code&gt; 에있는 모든 파일의 내용을 자동으로 읽지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-i&lt;/b&gt; 로 내부 편집 처리를 수행 할 때 현재 열려있는 출력 파일을 가리키는 특수 파일 핸들입니다 . 많은 삽입 작업을 수행해야하고 &lt;code&gt;$_&lt;/code&gt; 수정을 계속하고 싶지 않을 때 유용합니다 . &lt;b&gt;-i&lt;/b&gt; 스위치에 대해서는 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">특수 리터럴 __FILE__, __LINE__ 및 __PACKAGE__은 프로그램의 해당 시점에서 현재 파일 이름, 줄 번호 및 패키지 이름을 나타냅니다. __SUB__는 현재 서브 루틴에 대한 참조를 제공합니다. 개별 토큰으로 만 사용할 수 있습니다. 문자열로 보간되지 않습니다. 빈 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 지시문 으로 인해 현재 패키지가없는 경우 __PACKAGE__는 정의되지 않은 값입니다. 그러나 빈 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 는 버전 5.10부터 더 이상 지원되지 않습니다. 서브 루틴 외부에서 __SUB__는 정의되지 않은 값입니다. __SUB__는 5.16 이상에서만 사용 가능하고 만 함께 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">운영 체제에이 프로그램을 실행할 수 있음을 알리는 특수 표시입니다. 실제로 Unix에는 세 개의 실행 비트가 있으며 사용되는 비트는 파일을 단일, 집합 또는 소유하는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;mro&lt;/code&gt; 모듈이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 를 통해로드 될 때까지 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;maybe::next::method&lt;/code&gt; 특수 메소드를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">특수 인용 동작은 우선 순위를 무시하므로 다음에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">특수 문자열 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 는 부적절한 숫자 변환에 대한 &lt;b&gt;-w&lt;/b&gt; 불만 에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">특수 기호 &lt;code&gt;__PACKAGE__&lt;/code&gt; 는 현재 패키지를 포함하지만 변수 이름을 구성하는 데 (쉽게) 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl의 open () 함수의 특수 2 인수 형식은 파일 이름에서 후행 공백을 무시하고 특정 선행 문자 (또는 후행 &quot;|&quot;)에서 모드를 유추합니다. 이전 버전의 Perl에서는이 버전이 open ()의 유일한 버전이므로 이전 코드 및 서적에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">특수 값 00은 Perl이 단락 모드에서 파일을 처리하게합니다. 값이 0400 이상이면 Perl이 파일 전체를 훔치 게되지만 일반적으로 값 0777은이 목적으로 일반적으로 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">특수 변수 &lt;code&gt;$#array&lt;/code&gt; 는 배열 의 마지막 요소의 인덱스를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">형식의 특수 변수는 파일 핸들 변수의 하위 집합입니다. Perl 형식에 대한 자세한 정보는 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">특수한 상세 레벨 99에서는 -sections 매개 변수도 지정해야합니다. 그런 다음이 섹션을 추출하여 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">여기서 구체적인 작업은 응답 코드, 쿼리, 브라우저, 참조 URL 및 마지막 날짜별로이 파일의 286,525 줄을 정렬하는 것입니다. 한 가지 해결책은 다음 코드를 사용하는 것입니다.이 코드는 명령 행에 제공된 파일을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">타르에서 파생되는 사양; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">지정된</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">지정된 필터링 서브 루틴은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 이 발생할 때마다 호출되며 다음 호출이 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 까지 해당 호출 다음의 모든 소스 코드를 전달합니다 . (또는 설정 한 터미네이터) 또는 소스 파일의 끝 (둘 중 먼저 발생) 기본적으로 어떤 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 통화는 별도의 회선에 단독으로 나타나거나 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">스플릿 기능</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">분할 연산자</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">대괄호는 목록 값을 스칼라 값으로 명시 적으로 바꾸지 만 괄호는 그렇지 않습니다. 따라서 괄호로 묶은 목록을 스칼라 컨텍스트에서 평가하면 쉼표는 C의 쉼표 연산자처럼 처리되어 왼쪽 인수를 버립니다. 이는 원하는 것이 아닙니다. &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 참조 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">대괄호는 다음과 같이 새 배열을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">이러한 확장의 안정성은 크게 다릅니다. 일부는 수년간 핵심 언어의 일부였습니다. 다른 실험 중이며 경고없이 변경되거나 완전히 제거 될 수 있습니다. 개별 기능에 대한 설명서를 확인하여 현재 상태를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">스택 인수는 &lt;code&gt;ST(n)&lt;/code&gt; 매크로를 통해 액세스 할 수 있으며 &lt;code&gt;n&lt;/code&gt; 번째 스택 인수 를 반환합니다 . 인수 0은 Perl 서브 루틴 호출에서 전달 된 첫 번째 인수입니다. 이 인수는 &lt;code&gt;SV*&lt;/code&gt; 이며 &lt;code&gt;SV*&lt;/code&gt; 가 사용 되는 모든 곳에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">현재 존재하는 스레드의 스택 크기를 변경할 수 없으므로 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;bigrat&lt;/code&gt; 와 함께 표준 &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; 모듈 pragma 가변 정밀도 산술 및 오버로드 된 연산자를 제공하지만 현재 속도는 느립니다. 일부 공간과 상당한 속도의 비용으로 제한된 정밀도 표현과 관련된 일반적인 함정을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">표준 &lt;code&gt;IO::Select&lt;/code&gt; 모듈은 대부분의 비트 마스크 작업을 수행하기 때문에 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 하기 쉬운 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">표준 &lt;code&gt;IO::Select&lt;/code&gt; 모듈은 대부분의 비트 마스크 작업을 수행하기 때문에 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 하기 쉬운 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">표준 Perl 5 MRO는 (D, B, A, C)입니다. 그 결과 인 &lt;b&gt;A가&lt;/b&gt; 전에 나타나는 &lt;b&gt;C는&lt;/b&gt; , 비록 &lt;b&gt;C는&lt;/b&gt; 의 서브 클래스 . 그러나 C3 MRO 알고리즘은이 문제가없는 (D, B, C, A) 순서를 생성합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">표준 Pod :: Parser 메소드 parse_from_filehandle ()은 최대 두 개의 인수를 사용합니다. 첫 번째는 POD를 읽는 파일 핸들이고 두 번째는 형식화 된 출력을 쓸 파일 핸들입니다. 지정하지 않은 경우 첫 번째는 STDIN이고, 두 번째는 STDOUT입니다. parse_from_file () 메소드는 두 개의 인수가 대신 입력 및 출력 디스크 파일이라는 점을 제외하면 거의 동일합니다. 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">표준 Pod :: Simple 메소드 parse_file ()은 읽을 POD 파일을 명명하는 하나의 인수를 사용합니다. 기본적으로 출력은 &lt;code&gt;STDOUT&lt;/code&gt; 으로 전송됩니다. 되지만 output_fh () 메소드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">표준 Pod :: Simple 메소드 parse_from_file ()은 최대 두 개의 인수를 사용합니다. 첫 번째는 POD를 읽을 입력 파일이고 두 번째는 형식화 된 출력을 쓸 파일입니다.</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">표준 Tie :: RefHash 모듈은 이에 대한 편리한 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">아래에 나열된 표준 유니 코드 속성은 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/에&lt;/a&gt; 문서화되어 있습니다 . Perl_Decimal_Digit는 &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap ()에 Unicode :: UCD&lt;/a&gt; 로 문서화되어 있습니다. 다른 Perl 확장자는 &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode의 기타 특성에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perl의 표준 릴리스 (Perl 개발 팀이 유지 보수하는 버전)는 소스 코드 형식으로 만 배포됩니다. 최신 릴리스는 &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt; 에서 찾을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">매뉴얼 페이지의 표준 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">표준 타입 맵에는 perl 5.7 이전의 PerlIO *가 포함되어 있지 않지만 세 가지 스트림 변형이 있습니다. 고유 한 유형 맵을 제공하지 않으면 PerlIO *를 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">표준 유형 맵은 PerlIO *의 세 가지 변형 인 &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) 및 &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT)을 제공합니다. 베어 &lt;code&gt;PerlIO *&lt;/code&gt; 는 T_INOUT으로 간주됩니다. 코드에서 중요한 경우 (아래의 이유를 참조하십시오) 특정 이름 중 하나를 #define 또는 typedef하고 XS 파일에서 인수 또는 결과 유형으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">dl_findfile ()이 라이브러리 등을 검색 할 디렉토리의 표준 / 기본 목록입니다. $ dl_library_path [0], [1], ... 등의 디렉토리가 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">유형화 된 어휘와 연관된 숨김입니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; 대한 % Foo :: 해시를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">이 &quot;우리의&quot;변수가 선언 된 숨김</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat () 모드 비트는 아마도 시스템에있는 대부분의 파일과 디렉토리에 적합 할 것입니다. access ()가 제공하는 추가 기능을 사용하려는 사람은 거의 없기 때문입니다. 그러나 stat () 정보가 실제 권한을 반영하지 않기 때문에 프로그램이 ACL을 사용하는 시스템에서 실행되는 경우 놀라게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; 명령문 은 현재 위치를 변경하지 않지만 핸들의 파일 끝 조건을 지우므로 다음 &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; 는 Perl이 다시 무언가를 읽으려고합니다.</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">상태 2는 지정된 파일 중 하나 이상에 포함되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 에서 반환 된 상태 코드 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 아닌 경우 주 처리 루프의 종료 만 트리거합니다 . 경우 &lt;code&gt;LimitOutput&lt;/code&gt; 을 사용한되지 &lt;code&gt;Z_OK&lt;/code&gt; 의 압축 데이터 스트림의 끝에 도달하거나 비 압축에서 에러가되었다는 상태 수단.</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed 플래그의 상태는 컴파일 오류의 VMS 오류 메시지 출력에도 영향을줍니다. 다시, 여전히 Perl 오류 메시지와 $ STATUS 코드가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">마지막 파이프 닫기, 백틱 ( &lt;code&gt;``&lt;/code&gt; ) 명령, &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 호출 성공 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 연산자 에서 리턴 한 상태 입니다. 이것은 전통적인 Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 시스템 호출에 의해 반환 된 16 비트 상태 단어 일뿐입니다 (또는 이와 같이 보이도록 구성되어 있습니다). 따라서 서브 프로세스의 종료 값은 실제로 ( &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ) 및 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; 은 프로세스가 어느 신호에서 죽었는지, 그리고 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; 은 코어 덤프가 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">사용자의 &lt;code&gt;filter&lt;/code&gt; 메소드 또는 익명 서브와 &lt;code&gt;filter_read&lt;/code&gt; 및 &lt;code&gt;read_exact&lt;/code&gt; 함수에 의해 리턴되는 상태 값 은 동일한 값 세트를 취합니다.</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio (3C) 맨 페이지에서는 LP32 응용 프로그램의 경우 fopen ()을 사용하여 255 개의 파일 만 열 수 있으며 스트림에는 0-255의 파일 설명 자만 사용할 수 있습니다. perl은 결과 파일 설명자와 함께 open ()을 호출 한 다음 fdopen (3C)을 호출하므로 sysopen ()을 사용하더라도 perl은 255 개의 동시 열린 파일로 제한됩니다. 이것이 극복 할 수없는 문제인 경우, perl을 LP64 응용 프로그램으로 컴파일 할 수 있습니다 . 자세한 내용 &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;은 LP64 perl 빌드&lt;/a&gt; 를 참조하십시오. Solaris에서 열린 파일 디스크립터의 기본 자원 제한은 255이므로 ulimit 또는 rctl (Solaris 9 이상)을 적절하게 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">상점 기능을합니다 &lt;code&gt;croak&lt;/code&gt; 그들이 당신을 설정하지 않는 한 이러한 참조로 실행하면 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 일부 &lt;code&gt;TRUE&lt;/code&gt; 값. 이 경우 치명적인 메시지가 경고로 변환되고 의미없는 문자열이 대신 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend 및 patend 포인터는 각 문자열의 마지막 문자 다음에 오는 바이트를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">문자열 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 입니다. &lt;code&gt;NDBM_File&lt;/code&gt; Perl에게 NDBM_File 패키지를 사용하여 해시의 기능을 수행하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">문자열 &lt;code&gt;$vec&lt;/code&gt; 는 필요한만큼만 비트를 차지합니다. 예를 들어 &lt;code&gt;@ints&lt;/code&gt; 에 16 개의 항목이있는 경우 &lt;code&gt;$vec&lt;/code&gt; 에는 스칼라 변수 오버 헤드를 계산하지 않고 2 바이트 만 저장하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">문자열 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; 에는 6 개의 그래 핀 이 있지만 최대 8 개의 코드 포인트가 있습니다. 이것은 코드 포인트가 아닌 grapheme으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 항목 뒤에 오는 문자열 ( 현재 BLOCK으로 묶인 BLOCK 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 내에 숨겨진 일치 항목은 제외 ) 예:</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995 년 12 월 12 일 화요일의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">해당 키와 연관된 &lt;b&gt;값&lt;/b&gt; 을 찾는 데 사용되는 &lt;b&gt;해시&lt;/b&gt; 의 문자열 색인 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">문자열은 TEMPLATE에 의해 설명 된 덩어리로 나뉩니다. 각 청크는 개별적으로 값으로 변환됩니다. 일반적으로 문자열은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 의 결과 이거나 문자열의 문자는 일종의 C 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">문자열은 TEMPLATE에 의해 설명 된 덩어리로 나뉩니다. 각 청크는 개별적으로 값으로 변환됩니다. 일반적으로 문자열은 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 의 결과 이거나 문자열의 문자는 일종의 C 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 문자열 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 현재 BLOCK으로 묶인 BLOCK 또는 eval () 내에 숨겨진 일치 항목은 제외 )</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">부동 소수점 숫자의 문자열 출력은 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">문자열 출력에는 항상 선행 및 후행 0이 제거되고 더하기 부호가 삭제됩니다. &lt;code&gt;bstr()&lt;/code&gt; 은 항상 소수점 형식을 제공하지만 &lt;code&gt;bsstr()&lt;/code&gt; 은 과학적 표기법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">마지막으로 성공한 패턴 일치와 일치하는 항목 앞에 오는 문자열은 BLOCK 내에 숨겨져있는 일치 항목이나 현재 BLOCK으로 둘러싸인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 계산하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">로케일을 신뢰할 수 없을 수 있으므로 로케일 정보를 사용하는 조작의 문자열 결과가 오염됩니다. &lt;a href=&quot;#SECURITY&quot;&gt;보안을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">반환 된 문자열이 항상 NFD / NFKD 인 것은 아닙니다. 재정렬이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">옵션을 시작하는 문자열입니다. 상수 문자열이 충분하지 않으면 &lt;code&gt;prefix_pattern&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">삽입 할 문자열은</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">삽입 할 문자열은 다음에서 시작하는 8 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">삽입 할 문자열은</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 문자열 값 ! 이는 CRTL의 strerror () 함수에 의해 반환되므로 VMS 관련 오류에 대한 VMS 메시지를 포함합니다. &lt;code&gt;$!&lt;/code&gt; 의 숫자 값 errno가 EVMSERR 인 경우를 제외하고 는 &lt;code&gt;errno&lt;/code&gt; 의 값입니다 .이 경우 &lt;code&gt;$!&lt;/code&gt; vaxc $ errno의 값을 포함합니다. &lt;code&gt;$!&lt;/code&gt; 설정 중 ! 항상 errno를 지정된 값으로 설정합니다. 이 값이 EVMSERR이면 vaxc $ errno를 4 (NONAME-F-NOMSG)로 설정하여 문자열 값 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; 이전의 VMS 오류 메시지를 반영하지 않습니다 . 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">인수로 제공된 $ data의 문자열 값은 다이제스트를 계산하는 메시지에 추가됩니다. 반환 값은 $ ctx 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">struct () 함수</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied () 데이터의 구조는 요소를 가진 배열 참조입니다</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">펄 배포판에 포함 된 스텁 패키지는 몇 가지 추가 방법을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; 옵션 의 제출자 주소는 RFC 2554에서 요구하는 형식, RFC2821 인용 양식 및 xtext 인코딩 또는 &amp;lt;&amp;gt; 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; 에 대한 서브 루틴 은 Perl 할당 연산자를 오버로드하지 않습니다. 여기에 설명 된대로 뮤 테이터가 작동하도록하는 데만 사용됩니다. ( &lt;a href=&quot;#Assignments&quot;&gt;지정&lt;/a&gt; 참조 위 )</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; 에 대한 서브 루틴 은 오브젝트가 &lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 의 RHS에 나타날 때를 포함하여 정규 표현식으로 보간되거나 정규 표현식으로 사용되는 모든 곳에서 사용됩니다 . 연산자 .</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">연산자의 할당 변형에 대한 서브 루틴은 조작 결과를 리턴하기 위해서만 필요합니다. 피연산자의 값을 변경할 수 있지만 (Perl이 먼저 복사 생성자를 호출하기 때문에 안전합니다) 그러나 Perl은 반환 된 값을 왼쪽 피연산자에 할당하므로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">서브 루틴 인터페이스는 상수 인터페이스에 비해 32 개의 서브 루틴 만 네임 스페이스로 내보내는 점에서 상수 인터페이스에 비해 이점이 있습니다. 반대로, 상수 인터페이스는 철자가 틀린 색상 이름이나 런타임에 호출 될 때 색상의 잘못된 철자 이름이나 색상 () 및 컬러 () 호출에 대한 속성은 잡히지 않는 반면, 철자가 틀린 상수 이름은 잡히기 때문에 컴파일 시간 오류 검사의 이점이 있습니다. 컴파일 타임에. 따라서 자주 사용하지 않거나 속성을 잘못 입력하여 바보 같은 버그를 일으킬 수있는 약 24 개의 서브 루틴으로 네임 스페이스를 오염시킵니다. 선택, TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">서브 루틴은 최대 5 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">서브 루틴은 최대 4 개의 선택적 인수 ( &lt;code&gt;extract_tagged&lt;/code&gt; 와 동일한 세트)를 사용합니다. 처리 할 문자열을 제외하고 )를 사용합니다. 서브 루틴에 대한 참조를 리턴하고 서브 루틴에 단일 인수 (텍스트를 추출 할)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">서브 루틴은 최대 4 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">서브 루틴은 최대 두 개의 선택적 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; 및 &lt;code&gt;'bool'&lt;/code&gt; 의 서브 루틴은 임의의 Perl 값을 리턴 할 수 있습니다. 이 값에 해당하는 조작에도 과부하가 걸리면이 값으로 조작이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">서브 루틴은 하나 이상의 줄 바꾸기로 구분 된 특수 형식 문자열을 리턴해야합니다. 각 줄은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">다차원 배열 에뮬레이션을위한 첨자 분리 자. 해시 요소를</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">대체 연산자 &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">대체 연산자 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">추출 될 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 스트링은 스트링 변수 의 현재 위치 (또는 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 위치가 정의 되지 않은 경우 인덱스 0)에 나타나야합니다 . 다시 말해 &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">잘못된 형식의 프로그램을 유효한 &lt;b&gt;구문 트리&lt;/b&gt; 로 바꾸려는 미묘하지만 때로는 잔인한 기술입니다 .</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">이 패키지의 서브 버전 레벨. 파괴의 가치는</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">수퍼 유저 ( &lt;code&gt;UID&lt;/code&gt; == 0) 또한 파일 시스템의 최상위 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">유니 코드 지원은 Perl 버전 v5.6부터 새로 도입되었으며 버전 v5.8 이상에서 더 완벽하게 구현됩니다. &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">지원되는 플랫폼은 Linux 및 OS X입니다 (일부 * BSD는 적어도 부분적으로 작동하지만 아직 테스트되지는 않았습니다).</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">놀랍게도 &lt;code&gt;--a&lt;/code&gt; 는 옵션이 &lt;code&gt;a&lt;/code&gt; (자동 완성으로 인해)가 아니라 &lt;code&gt;all&lt;/code&gt; 를 설정 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">환경이나 환경. 주변 코드에서 제공하는 컨텍스트에 따라 특정 &lt;b&gt;표현식&lt;/b&gt; 이 반환 할 데이터 종류가 결정 됩니다. 세 가지 주요 컨텍스트는 &lt;b&gt;list context&lt;/b&gt; , &lt;b&gt;스칼라&lt;/b&gt; 및 &lt;b&gt;void 컨텍스트&lt;/b&gt; 입니다. 스칼라 컨텍스트는 때때로 &lt;b&gt;부울 컨텍스트&lt;/b&gt; , &lt;b&gt;숫자 컨텍스트&lt;/b&gt; , &lt;b&gt;문자열 컨텍스트&lt;/b&gt; 및 &lt;b&gt;void 컨텍스트&lt;/b&gt; 로 세분됩니다 . 또한 &quot;무관심&quot;이라는 맥락이 있습니다 (카멜 2 장, &quot;원하는 경우 비트와 조각&quot;에서 다루어집니다).</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic 함수는 미리 정의 된 &quot;Magic Virtual Table&quot;이 &lt;code&gt;mg_virtual&lt;/code&gt; 필드에 할당되어야 하는지를 결정하는 &lt;code&gt;how&lt;/code&gt; 을 사용 합니다 . 아래의 &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;매직 가상 테이블&lt;/a&gt; 섹션을 참조하십시오. &lt;code&gt;how&lt;/code&gt; 인수도에 저장되어 &lt;code&gt;mg_type&lt;/code&gt; 의 필드. 의 값 &lt;code&gt;how&lt;/code&gt; 매크로의 집합에서 선택해야한다는 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 에서 발견</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switch 문은 &lt;code&gt;given/when&lt;/code&gt; 호출 되며 perl 5.10 이상에서만 사용할 수 있습니다. &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn의 스위치 명령문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">꺾쇠 괄호 사이의 기호는 예를 들어 op의 유형을 나타냅니다. &amp;lt;2&amp;gt;는 BINOP, &amp;lt;@&amp;gt; LISTOP, &amp;lt;#&amp;gt;은 스레드 perls에 사용되는 PADOP입니다. ( &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP 클래스 약어&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">패키지의 심볼 테이블은 두 개의 콜론이 추가 된 해당 이름의 해시에 저장됩니다. 따라서 기본 기호 테이블의 이름은 &lt;code&gt;%main::&lt;/code&gt; 또는 &lt;code&gt;%::&lt;/code&gt; 입니다. 마찬가지로 앞에서 언급 한 중첩 패키지의 심볼 테이블 이름은 &lt;code&gt;%OUTER::INNER::&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">심볼 테이블은 라인 노이즈처럼 보이는 이름으로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 및 ZIP_CM_LZMA 기호는 압축 방법을 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">간접 객체 호출 구문을 사용할 때 메소드 호출과 인수 사이의 구문 위치. (슬롯은 슬롯과 다음 인수 사이에 쉼표가없는 것으로 구별됩니다.) &lt;code&gt;STDERR&lt;/code&gt; 은 간접 오브젝트 슬롯에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">구문과 동작은 &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 과 유사 하지만 테스트는 실패하지만 할일로 표시됩니다. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 그것들을 통과 한 것으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 의 구문은 그것이 가능한 유일한 방법에 관한 것이지만 여전히 혼란 스럽습니다. 위의 예제로 시작하면 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">입력 FileGlob의 구문 은 다음을 제외하고 &lt;code&gt;File::Glob&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">텍스트 문자열을 이진 문자열로 인코딩하는 구문은 디코딩만큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">문법 :</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">설계중인 시스템이 크거나 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">시스템 복사 루틴도 같이 VMS 및 OS / 2에서 직접 호출 할 수 있습니다 &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (또는 VMS에서 같은 &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , SYSCOPY의 실제 작업을 수행하는 루틴입니다).</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">시스템 설계는 이미 객체 지향적입니다.</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">시스템은 첫 번째 줄을 무시하고 프로그램을</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">시스템 시간은 커널 자체가이 프로세스 사용자 대신 루틴 또는 시스템 호출을 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">널 (null) 루프의 시스템 시간은 실제 코드와 함께 루프의 시스템 시간보다 약간 더 길 수 있으므로 차이는 &amp;lt;0이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">시스템의 시간과 달력 날짜의 개념은 크게 다른 방식으로 제어됩니다. 시간대가 &lt;code&gt;$ENV{TZ}&lt;/code&gt; 저장되어 있다고 가정하지 말고 해당 시간대를 사용 하더라도 해당 변수를 통해 시간대를 제어 할 수 있다고 가정하지 마십시오. 3 글자 시간대 약어에 대해서는 아무 것도 가정하지 마십시오 (예 : MST는 산악 표준시, 모스크바 표준시로 알려져 있음). 시간대를 사용해야하는 경우 UTC에서 정확한 분 오프셋 (분) 또는 POSIX 시간대 형식과 같은 모호하지 않은 형식으로 시간대를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">아래 표에는 두 개의 열이 있습니다. 왼쪽 열에는 &lt;code&gt;\p{}&lt;/code&gt; 구문이 포함되어 있으며 위에서 언급 한 플래그가 앞에 올 수 있습니다. 오른쪽 열에는 설명 또는 동의어와 같은 정보가 포함됩니다. 표에는 각 속성이있는 단일 및 복합 형식이 모두 나와 있습니다. 왼쪽 열이 속성의 짧은 이름 인 경우 오른쪽 열은 길고 설명적인 이름을 제공합니다. 왼쪽 열이 가장 긴 이름 인 경우 오른쪽 열은 해당되는 경우 단일 형식과 복합 형식으로 동등한 짧은 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">테이블 파일은</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">모든 작업에 대한 메소드 테이블은 패키지의 기호 테이블 해시에 대해 마술로 캐시됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없음&lt;/a&gt; , 새로운 함수 정의 및 @ISA 변경 처리 중에 캐시가 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">Perlop의 &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator의 스마트&lt;/a&gt; 일치 표는 Perl 6과 Perl 5의 데이터 모델 간의 차이로 인해 Perl 6 사양에서 제안한 것과 동일하지 않지만 Perl 5가 초기 채택으로 급격히 돌진 한 이후로 Perl 6 사양이 변경 되었기 때문에 .</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">탄젠트</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">타르볼은 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">목표는 OS / 2를 Perl을 사용 / 빌드 / 개발할 수있는 최고의 지원 플랫폼 중 하나로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">OP의 대상이거나 널 (null) 된 OP에 대해서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">템플릿은 사용되는 키마다 다른 규칙 집합을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">템플릿은 파일 이름에 X가 추가 된 파일 이름 (예 : F) 일 수 있습니다. 후행 X는 고유 한 영숫자 조합으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">&quot;네이티브 (native)&quot;라는 용어는 네이티브 부동 소수점 숫자가 포함될 때처럼 네이티브 정수에 대해 말할 때 그다지 의미가 없습니다. 정수에서 &quot;네이티브&quot;라는 용어의 유일한 의미는 최대 및 최소 지원되는 실제 적분 수량에 대한 제한이 2의 거듭 제곱에 가깝다는 것입니다. 그러나 &quot;네이티브&quot;플로트에는 가장 근본적인 제한이 있습니다. 이진 분수로 변환 할 때 상대적으로 &quot;짧은&quot;표현을 갖습니다. 예를 들어 0.9의 이진 분수는 무한하므로 0.9는 원시 부동 소수점으로 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">&quot;철도 정규형&quot;이라는 용어는 약간 난해하며 &quot;구문 다이어그램 / 차트&quot;또는 &quot;철도 다이어그램 / 차트&quot;가 더 일반적인 용어입니다. 그럼에도 불구하고 그것은 정규식 프로그램의 유용한 정신적 이미지를 제공합니다 : 각 노드는 단일 엔트리와 대부분의 경우 단일 출구 포인트를 가진 트랙 단위로 생각할 수 있습니다 (포크가 있지만 트랙이 많은 트랙이 있습니다) 전체가 단일 항목과 단일 종료점을 가진 레이아웃을 형성합니다. 매칭 과정은 트랙을 따라 이동하는 차량으로 생각할 수 있으며, 시스템을 통한 특정 경로는 각 가능한 커넥터 지점에서 읽은 문자에 의해 결정됩니다. 자동차는 어느 시점에서나 트랙에서 떨어질 수 있지만 트랙과 일치하는 한 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">'mathemagic'이라는 용어는 수학 연산자의 오버로드 된 구현을 설명합니다. Mathemagical 작업이 문제를 제기합니다. 코드를 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">&quot;유니 코드 버그&quot;라는 용어는 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; 블록 의 코드 포인트 , 즉 128과 255 사이 의 불일치에 적용되었습니다 . 로케일을 지정하지 않으면 다른 문자 나 코드 포인트와 달리이 문자는 적용되는 규칙에 따라 매우 다른 의미론. (코드 포인트가 255보다 큰 문자는 유니 코드 규칙을 강제하지만 ASCII 문자 규칙은 ASCII 및 유니 코드 규칙에서 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">이 터미널에 대한 터미널 출력 비트 전송률 (보통 전송 속도라고도 함)-설정하지 않으면 경고가 생성되고 기본값은 9600입니다.</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">termcap 항목이 사용될 터미널 유형-제공되지 않으면 $ ENV {TERM}으로 기본 설정 됩니다. 설정되지 않으면 &lt;b&gt;Tgetent&lt;/b&gt; 가 &lt;b&gt;삐걱 거립니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">종료 문자열은 식별자 (단어)이거나 인용 된 텍스트 일 ​​수 있습니다. 따옴표없는 식별자는 큰 따옴표처럼 작동합니다. 식별자가 명시 적으로 인용되지 않는 한 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 식별자 사이에 공백이 없을 수 있습니다 . (공백을 넣으면 유효하지 않은 첫 번째 빈 줄과 일치하는 null 식별자로 처리됩니다.) 종료 문자열은 그 자체로 (따옴표없이 공백 문자없이) 끝나는 줄에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">런타임의 종결 자 &lt;code&gt;(?{...})&lt;/code&gt; 는 일시적으로 제어를 perl 파서로 전환하여 발견됩니다. 이것은 논리적으로 균형을 잡는 종료 &lt;code&gt;}&lt;/code&gt; 가 있는 지점에서 중지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">시험</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">테스트 하네스는 원하는만큼 많이 남습니다. 패치는 환영합니다.</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">테스트 이름 확장명. 기본값은 &lt;code&gt;.t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">테스트 스위트는 훨씬 좋지만 항상 개선이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">테스트는 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">테스트 시스템은 테스트하려는 각 테스트에 대해 3 단계 프로세스를 수행하여 사용하도록 설계되었습니다. 이 프로세스는 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 를 미리 사용 하여 테스트중인 testsuite가 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 사용하여 stdout 및 stderr에 출력 할 것을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">테스트</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">테스트 &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-z&lt;/code&gt; 는 알려진대로 작동합니다. &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 의 리턴 값 은 실제로 파일에 액세스 할 수 있는지 여부를 알려줍니다. 이것은 UIC 기반 파일 보호를 반영하지 않을 수 있습니다. 실제적이고 효과적인 UIC는 VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; 와 같습니다. 마찬가지로 &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;-u&lt;/code&gt; 를 포함한 다른 여러 테스트는 VMS에서 특별히 의미가 없으며 이러한 테스트에서 반환 된 값은 CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 루틴이 수행하는 모든 작업을 반영합니다.st_mode 필드의 동등한 비트에. 마지막으로 &lt;code&gt;-d&lt;/code&gt; 는 디렉토리를전달한 경우와 같이명시 적 디렉토리 (예 : &lt;code&gt;DUA1:&lt;/code&gt; 없이 장치 사양을 전달한 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">&quot;개체 속성&quot;이라는 텍스트는 제목으로 구성됩니다. 이 표제 명령의 텍스트는 다음과 같이 형식화 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">마지막으로 성공한 검색 패턴의 마지막 대괄호와 일치하는 텍스트입니다. 이는 대체 패턴 세트 중 어느 것이 일치하는지 모르는 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">마지막으로 성공한 검색 패턴 중 가장 최근에 닫힌 그룹 (즉 가장 오른쪽에 닫는 괄호가있는 그룹)과 일치하는 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">프로그램 사용 메시지를 인쇄하기 직전에 인쇄 할 메시지의 텍스트.</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile의 텍스트는 디스크에 쓰기 전에이 방법을 통해 실행됩니다. 시스템이 Makefile에 이식성을 수정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">텍스트 / 이진 문제는 Cygwin 설명서에서 자세히 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">위의 세타, phi, 방향 및 거리는 모두 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">당신이 작업하고있는 것. &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; 및 &lt;code&gt;given&lt;/code&gt; 과 같은 구조 는 기본값 인 &lt;code&gt;$_&lt;/code&gt; 에 할당하여 주제를 설정합니다 (</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">세 번째 인수 ($ binmode)는 TRUE 값으로 전달되면 이진 모드를 선택합니다. 이진 모드에서 &quot;\ n&quot;은 인쇄 할 수없는 다른 문자와 같은 방식으로 인코딩됩니다. 이를 통해 디코더는 사용하는 줄 끝 시퀀스에 관계없이 정확히 동일한 문자열로 끝납니다. 일반적으로 이진 데이터에는 base64 인코딩을 사용하는 것이 좋습니다. &lt;a href=&quot;base64&quot;&gt;MIME :: Base64를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">세 번째 인수는 옵션이있는 해시 참조 일 수 있습니다. 모든 옵션은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">세 번째 인수는 선택적 접두사입니다. 모든 파일은 접두사로 지정한 디렉토리에 저장됩니다. 따라서 아카이브에 파일 'a'와 'b'가 있고 접두어로 'foo'를 지정하면 아카이브에 'foo / a'와 'foo / b'로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">두 피연산자가 스왑 된 경우 세 번째 인수는 TRUE로 설정됩니다. Perl은 첫 번째 인수 ( &lt;code&gt;$self&lt;/code&gt; )가 일반 오브젝트 호출 규칙에 따라 오버로드 된 조작을 구현하는 오브젝트 인지 확인하기 위해이를 수행 할 수 있습니다 . 예를 들어, &lt;code&gt;$x&lt;/code&gt; 및 &lt;code&gt;$y&lt;/code&gt; 가 &lt;code&gt;Number&lt;/code&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl 정규식에 사용할 수있는 세 번째 문자 클래스는 대괄호 문자 클래스입니다. 가장 간단한 형식으로, 일치 할 수있는 문자를 대괄호로 묶은 다음과 같이 나열합니다 : &lt;code&gt;[aeiou]&lt;/code&gt; . 이것은 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; 또는 &lt;code&gt;u&lt;/code&gt; 중 하나와 일치 합니다. 다른 문자 클래스와 마찬가지로 정확히 하나의 문자가 일치합니다. * 문자 클래스에서 언급 된 문자로 구성된 더 긴 문자열을 일치 시키려면 문자 클래스를 &lt;a href=&quot;perlre#Quantifiers&quot;&gt;수량&lt;/a&gt; 자로 사용하십시오 . 예를 들어, &lt;code&gt;[aeiou]+&lt;/code&gt; 는 하나 이상의 소문자 영어 모음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">세 번째 옵션은 Perl을 빌드 할 때 -Ui_db를 Configure로 지정한 다음 DB_File 대신 CPAN에서 BerkeleyDB 모듈을 사용하여 DB_File을 완전히 비활성화하여 문제를 해결하는 것입니다. BerkeleyDB는 Berkeley DB 버전 2. * 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">세 번째 매개 변수는 정수 플래그이며, &lt;code&gt;rmscopy&lt;/code&gt; 에게 타임 스탬프 처리 방법을 알려줍니다 . &amp;lt;0이면 입력 파일의 타임 스탬프가 출력 파일로 전파되지 않습니다. &amp;gt; 0이면 비트 마스크로 해석됩니다. 비트 0 (LSB)이 설정되면 개정 날짜 이외의 타임 스탬프가 전파됩니다. 비트 1이 설정되면 개정 날짜가 전파됩니다. &lt;code&gt;rmscopy&lt;/code&gt; 에 대한 세 번째 매개 변수 가 0이면 DCL COPY 명령과 매우 유사하게 작동합니다. 출력 파일의 이름 또는 유형이 명시 적으로 지정된 경우 시간 소인이 전파되지 않지만 입력 파일 스펙에서 내재적으로 가져온 경우 개정 날짜 이외의 모든 타임 스탬프가 전파됩니다. 이 매개 변수가 제공되지 않으면 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 의 세 번째 매개 변수는 주어진 메소드가없는 경우 AUTOLOAD 조회가 수행되는지 여부를 판별합니다. 0이 아닌 경우 예, AUTOLOAD를 찾으십시오. 0은 아니오, 자동로드를 찾지 않음을 의미합니다. &lt;code&gt;gv_fetchmethod&lt;/code&gt; 호출 은 0이 아닌 &lt;code&gt;autoload&lt;/code&gt; 매개 변수로 &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">세 번째로 더 효율적인 방법은 Perl 내장 내에서 수행되는 방법을 유인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">스레드 Perl 빌드는 AIX 5.1에서도 작동하지만 IBM Perl 빌드 (Perl v5.6.0)는 AIX 5.1에서 스레드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">세 개의 점으로 구분 된 비트 단위 할당 연산자 ( &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; )는 Perl 5.22의 새로운 기능이며 실험적인 기능입니다. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">키 해시의 세 가지 기능</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">서브 루틴의 세 가지 호출은 모두 동기화되어 작동합니다. 그러나 세마포어는 한 번에 하나의 스레드 만 전역 변수에 액세스하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">3 개의 사전 정의 된 변수 $ DB_HASH, $ DB_BTREE 및 $ DB_RECNO는 일반적으로 대부분의 응용 프로그램에 적합합니다. 이러한 객체의 추가 인스턴스를 생성해야하는 경우 각 파일 유형에 대해 생성자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">프로그래머의 세 가지 주요 미덕은 게으름, 조바심 및 Hubris입니다. 이유는 Camel Book을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision, api_version 및 api_subversion의 세 변수는 현재 perl과 호환되는 가장 오래된 perl 바이너리의 버전을 지정합니다. 정식 버전 문자열과 같은</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">세 가지 경고 기능인 &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; 및 &lt;code&gt;warnings::enabled&lt;/code&gt; 는 선택적으로 범주 이름 대신 객체 참조를 취할 수 있습니다. 이 경우 함수는 객체의 클래스 이름을 경고 범주로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl # 121481]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl # 116487]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl # 119313]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl # 119315]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl # 119317]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl # 119437]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl # 119451]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl # 119453]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl # 119455]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl # 120085]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl # 122947]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl # 123630]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl # 123707]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">이 기능에 대한 티켓은 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl # 120162]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie () 함수는 변수를 클래스 (패키지)에 바인딩하여 해당 변수의 액세스 메소드에 대한 구현을 제공합니다. 이 마법이 수행되면 연결된 변수에 액세스하면 적절한 클래스에서 메서드 호출이 자동으로 트리거됩니다. 클래스의 복잡성은 마술 메서드 호출 뒤에 숨겨져 있습니다. 메소드 이름은 ALL CAPS에 있으며, 이는 Perl이 BEGIN () 및 END () 함수와 같이 명시 적으로가 아니라 내재적으로 호출되었음을 나타 내기 위해 사용하는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">신기원 이후 (1970 년 초) 프로그램이 실행 된 시간 (초) &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-A&lt;/b&gt; 및 &lt;b&gt;-C&lt;/b&gt; 파일 테스트 에서 리턴 된 값 은이 값을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">시간이 절반으로 단축되었으며 이는 표준에 따라 상당한 속도 향상입니다. 당연히, 출력이 첫 번째 프로그램 실행과 일치하는지 확인하는 것이 중요합니다. 이것은 Unix 시스템 &lt;code&gt;cksum&lt;/code&gt; 유틸리티가 들어오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">소요 시간은 시스템 속도 및 인코딩 크기에 따라 다릅니다. euc-tw와 같은 큰 작업을 수행하지 않으면 시간이 오래 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">널 루프의 시간 (라운드 수는 동일하지만 빈 루프 본문이있는 루프)은 실제 루프의 시간에서 뺍니다.</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">리턴 된 시간에는 또한 wait ()가 실행 된 종료 된 하위 프로세스의 프로세스 시간도 포함됩니다. 이 값은 코어 Perl의 times ()에 의해 리턴 된 두 번째 값과 다소 같지만 반드시 동일하지는 않습니다. 이전 버전과의 호환성 제한으로 인해 반환 된 값은 약 2147 초 또는 약 36 분에 줄 바꿈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">펄이 실제로 말한 내용이 무엇인지 이해하려고 시도했던 초기의 시간과 반대로, 펄이 실제로 코드에서 말한 것을 수행하는 시간은 &lt;b&gt;컴파일 시간&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">펄이 코드의 의미를 알고 있다고 생각하는 것과 반대로 펄이 코드를 이해하려고 시도하는 시간은 단지 코드가 무엇을하는지 생각하는 것, 즉 &lt;b&gt;런타임&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">&quot;폴 (poll)&quot;에 영향을주기 위해 [PKG]의 시간 초과를 0으로 지정할 수 있지만, 단일 폴링을 수행하기 위해 새로운 IO :: Select 객체가 씬 뒤에 생성되므로 그렇게하지 않아야합니다. 이것은 엄청나게 비효율적입니다. 핸들에서 제한 시간이 0이거나 비 차단 IO 인 경우 오히려 true select ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">타임 아웃은 현재 시간에 상대적인 초 수 (예를 들어, 호출 된 시점으로부터 5 초)이거나, 또는</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">타이밍은 time (3) 및 times (3)을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">이 섹션의 제목은 C 구조를 포장 할 때 조만간 발생할 수있는 두 번째 문제를 나타냅니다. 호출하려는 함수에 &lt;code&gt;void *&lt;/code&gt; 값이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl 정규식에 대한 최상위 문서는 &lt;a href=&quot;perlre&quot;&gt;perlre에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">트리의 최상위 노드는 &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">신기원에서 초 단위로 테스트 실행에 소요 된 총 경과 시간 ..</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">총 비교 수는 각 버킷에있는 항목 수의 제곱의 합과 같습니다. &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; 버킷에 대한 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; 키 의 임의 해시의 예상 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">테스트 실행에 소요 된 총 시간 (초)입니다. 경우 &lt;code&gt;Time::HiRes&lt;/code&gt; 가능하며, 그것은 치밀하게있을 것이다.</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">트레이드 오프는 반환 값의 수를 미리 계산해야한다는 것입니다 (스택을 과도하게 확장해도 일반적으로 메모리 소비 외에 다른 것은 없습니다).</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">전통적인 &quot;0&quot;, &quot;1&quot;및 &quot;2&quot;모드는 일부 시스템에서 다른 숫자 값으로 구현됩니다. &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR)에서 내 보낸 플래그 는 어디에서나 작동해야합니다. (Mac OS, OS / 390)</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">전통적인 이름 뒤에는 중괄호로 묶인 이름이 붙습니다. 이는 해당 이름으로 지정된 문자 (또는 문자 시퀀스)를 의미합니다. 따라서 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; 는 &lt;code&gt;*&lt;/code&gt; 를 쓰는 또 다른 방법으로 , 큰 따옴표로 묶인 문자열과 정규식 패턴 모두에 유효합니다. 패턴에서는 의미 이스케이프가없는 &lt;code&gt;*&lt;/code&gt; 는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">전이 컴파일 환경은 다음 컴파일러 및 링커 플래그를 사용하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">트랩 및 언 트랩 방법은 거부의 동의어이며 정중하게 허용합니다.</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">둘 이상의 물리적 &lt;b&gt;회선&lt;/b&gt; 을 단일 논리적 회선으로 처리합니다. &lt;b&gt;개행&lt;/b&gt; 앞에 백 슬래시를 넣어 &lt;b&gt;Makefile&lt;/b&gt; 행을 계속합니다 . RFC 822에 정의 된대로 메일 헤더는 공백이나 탭을 넣어 계속됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">트리는 컴파일러에 의해 생성됩니다</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">이 작업의 요령은 디렉토리를 찾는 것입니다. 스크립트가 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 과 같은 다른 작업을 수행하기 전에 Perl과 함께 제공되는 &lt;code&gt;Cwd&lt;/code&gt; 모듈을 사용하여 현재 작업 디렉토리를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">비결은 &lt;code&gt;BOM&lt;/code&gt; 을 읽으면 바이트 순서를 알 수 있다는 것입니다. 빅 엔디안 플랫폼에서 작성된 경우 바이트 &lt;code&gt;0xFE 0xFF&lt;/code&gt; 를 읽지 만 리틀 엔디안 플랫폼에서 작성된 경우 바이트 순서를 알 수 있습니다 바이트 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 를 읽습니다 . (원래 플랫폼이 ASCII 플랫폼 UTF-8로 작성중인 경우 바이트 &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; 를 읽습니다 .)</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">트릭은 AIX에서 쉘 스크립트를 실행할 때 특수 매개 변수를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">이 문제의 속임수는 우발적 인 자생을 피하는 것입니다. 세 개의 키를 자세히 확인하려면 순진하게 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">기억해야 할 까다로운 점은 원하는 경우 첫 번째 매개 변수가 true라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">삼각 상수 &lt;b&gt;pi&lt;/b&gt; 와 편리한 배수가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">항목 2에 대한 신뢰는 전 이적입니다. A가 B를 신뢰하고 B가 C를 신뢰하면 A는 C를 신뢰합니다. 따라서 &lt;code&gt;@ISA&lt;/code&gt; 를 &lt;code&gt;@CARP_NOT&lt;/code&gt; 로 대체하지 않으면 이 신뢰 관계는 &quot; inherits from&quot;과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">문제의 진실은 오늘날 펄의 정규 표현은 이러한 종류의 구조보다 훨씬 복잡하지만, 이런 식으로 시각화하면 베어링을 가져올 때 도움이 될 수 있으며 현재 구현과 매우 일치합니다.</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">tty 드라이버는 UNIX와 같은 환경 &lt;code&gt;stty&lt;/code&gt; 에서 운영 체제 특정 명령을 사용하여 원시 모드로 전환되고 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">Llama에서 시작된 튜토리얼은 Alpaca에서 계속되며 참조, 데이터 구조, 객체 지향 프로그래밍 및 모듈의 중간 기능을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">두 개의 추가 라인은 코드에서 다양한 일반적인 문제를 포착하기 위해 perl에 요청합니다. 그들은 다른 것을 확인하므로 둘 다 필요합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용으로&lt;/a&gt; 인해 발생할 수있는 잠재적 인 문제 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안 코드가 발견되면 즉시 중지됩니다 . 명령 줄 스위치 &lt;b&gt;-w&lt;/b&gt; 와 같은 경고 만 표시 하고 코드를 실행하십시오. 이에 대한 자세한 내용은 해당 매뉴얼 페이지를 &lt;a href=&quot;strict&quot;&gt;엄격&lt;/a&gt; 하고 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 하여 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits ()의 두 인수 형식은 $ data에서 첫 $ nbits 비트를 추가합니다. 마지막 잠재적 부분 바이트의 경우 상위 &lt;code&gt;$nbits % 8&lt;/code&gt; 비트 만 사용됩니다. $ nbits가 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; 보다 큰 경우이 방법은 &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 와 &lt;code&gt;@EXPORT&lt;/code&gt; 의 두 배열 은 매우 중요합니다. &lt;code&gt;@ISA&lt;/code&gt; 의 배열은 현재 패키지에 존재하지 않는 방법 (또는 서브 루틴들)을 검색하여 다른 패키지의리스트를 포함한다. 이것은 일반적으로 객체 지향 확장 (나중에 이야기 할 것)에만 중요하므로 일반적으로 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">두 개의 제어 문자 ^ D 및 ^ Z와 토큰 __END__ 및 __DATA__을 사용하여 실제 파일 끝 전에 스크립트의 논리적 끝을 나타낼 수 있습니다. 다음 텍스트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">두 개의 진입 점은 &lt;code&gt;re_intuit_start()&lt;/code&gt; 및 &lt;code&gt;pregexec()&lt;/code&gt; 입니다. 이 루틴들은 함수간에 겹치는 부분이 다소 &lt;code&gt;pregexec()&lt;/code&gt; 관계를 가지고 있으며, pregexec () 는 &lt;code&gt;re_intuit_start()&lt;/code&gt; 를 스스로 호출 할 수도 있습니다. 그럼에도 불구하고 perl 소스 코드의 다른 부분은 둘 중 하나 또는 둘 다를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">두 파일 이름은 &lt;code&gt;$dirfile&lt;/code&gt; 및 &lt;code&gt;$pagfilename&lt;/code&gt; 전체적으로 별도로 제공 할 수도 있습니다 . 이것은 &quot;.dir&quot;및 &quot;.pag&quot;확장자가없는 두 파일에 적합합니다 (예 &lt;a href=&quot;file/temp&quot;&gt;: File :: Temp의&lt;/a&gt; 두 파일) .</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">두 가지 첫 번째 형태는 단순한 구문 설탕으로 처음 사용할 때 올바른 모듈을 자동으로로드합니다. 두 번째 형식을 사용하면 합법적 인 펄 식별자가 아닌 문자 (예 : &quot;SHA-1&quot;)가 포함 된 알고리즘 이름을 사용할 수 있습니다. 주어진 알고리즘에 대한 구현을 찾을 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">이를위한 두 가지 주요 용도는 내부 범위 내에서 패키지 하위를 사용하도록 다시 전환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">배열 배열과 같은 것을 구성 할 때 가장 흔히 발생하는 두 가지 실수는 실수로 요소 수를 계산하거나 동일한 메모리 위치를 반복적으로 참조하는 것입니다. 중첩 배열 대신 카운트를 얻는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">플러그인에 대한 &lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에서 지원하는 두 가지 주요 사용 사례 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">가장 빠른 두 가지 수정 사항은 로케일 불일치에 대해 Perl을 침묵 시키거나 기본 로케일 &quot;C&quot;로 Perl을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">두 개의 막대 차트 세트는 통계와 해시 성능을 시각적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">두 문장 :</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">상수의 유형 (</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">세 번째 매개 변수의 유형은 유형 맵에 관한 한 임의적입니다. 선언 된 변수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">유형 간 일치 (더 그들 앞에 공백, 다중이없는 쉼표를 제외한 백색 도료됩니다 &lt;code&gt;*&lt;/code&gt; 그들 사이에 공백이 없습니다).</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">타입 맵은 스칼라 참조가 perl에서 XS로 전달되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">조건부 컴파일 및 매크로 정의를 위해 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 행을 처리 하고 현재 정의를 기반으로 프로그램 텍스트의 다양한 조작을 수행하는 일반적인 C 컴파일러의 첫 번째 패스 입니다. 또한 ~으로 알려진</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">일반적인 접근 방식은 Perl 디버거를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">프로그램의 일반적인 입 / 출력 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">데이터 조각 간의 일반적인 상호 작용은 운영자가 가장 잘 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">일반적인 사용 사례는 로컬 디스크의 원격 리포지토리에서 개인 모듈 또는 프로젝트의 작업 복사본에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">일반적인 사용법은 &lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker에&lt;/a&gt; 의해 생성 된 Makefile 내에서 입니다. 따라서 정상적인 상황에서는이 모듈을 직접 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 호출 을 사용하는 일반적인 방법 은 모든 클래스가 상속하는 다른 기본 메소드로 래핑하는 것입니다. 예를 들어, 객체가 상속하는 모든 소멸자를 실제로 호출하는지 확인하려면 (가장 왼쪽에서 가장 깊이있는 것만 반대) :</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">uncolor () 함수 및 ANSI_COLORS_DISABLED 지원은 Perl 5.8.0에 포함 된 Term :: ANSIColor 1.04에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">의 기본 동작 &lt;code&gt;%+&lt;/code&gt; 에 의해 제공된다 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;타이 :: 해시 :: NamedCapture 용&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">기본 파서 객체 테스트 프로그램에 대한 전체 정보가 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">언 덤프 프로그램은 이미 컴파일 된 양식을 디스크에 저장하여 Perl 프로그램의 속도를 높이려는 고대의 시도였습니다. 이 기능은 더 이상 몇 가지 아키텍처에서만 작동했으며 더 이상 좋은 솔루션이 아니기 때문에 실행 가능한 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">이 함수의 이름과 Perl의 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 조작자 와의 불행한 유사성은 우연의 일치입니다. 이 기능은 왼쪽에서 작동합니다. &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 오른쪽에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">Unt Gotcha</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">untie () 잡았다</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">대문자 변형 ( &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; 및 &lt;code&gt;\V&lt;/code&gt; )은 각각 단어 문자, 숫자, 공백, 가로 공백 또는 세로 공백이 아닌 문자와 일치하는 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">생성자에게 전달한 URI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist 매개 변수는 CD-ROM을 지원합니다</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">통조림 필터의 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 의 사용은 다음 예에 나와 있습니다. 공백으로 구분 된 단어로 구성된 문자열이 있다고 가정합니다. 사전에 단어가 몇 개인 지 알면 그룹화를 사용하여 단어를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">의 사용 &lt;code&gt;:void&lt;/code&gt; 이 발생되지 않는 예외를 초래할 수 있으므로, 권장하지 않습니다 만약 당신이</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Fatal과 함께 &lt;code&gt;:void&lt;/code&gt; 를 사용 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">위 의 &lt;code&gt;=&amp;gt;&lt;/code&gt; 사용 은 필요한 &lt;code&gt;MODULE&lt;/code&gt; 인용을 제공합니다 . 뚱뚱한 쉼표를 사용하지 않으면 (예 : 인수가없는 경우) 모듈을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">사용 &lt;code&gt;\Q&lt;/code&gt; (가) &amp;lt;.&amp;gt; 정규식에서 일정한 문자로 취급하기 때문에 발생한다는 &lt;code&gt;P.&lt;/code&gt; 가 일치 &lt;code&gt;P&lt;/code&gt; 점을 하였다.</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Perl 주제와 함께 낙타를 사용하는 것은 O'Reilly and Associates, Inc.의 상표입니다. 허가를 받아 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">상수 이름에 모든 대문자를 사용하는 것은 단지 관례이지만 상수를 돋보이게하고 다른 베어 워드, 키워드 및 서브 루틴 이름과의 충돌을 피하기 위해 권장됩니다. 상수 이름은 문자 나 밑줄로 시작해야합니다. 이중 밑줄로 시작하는 이름은 예약되어 있습니다. 컴파일시 경고가 활성화 된 경우 이름을 잘못 선택하면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">하이픈 ( &lt;code&gt;-name&lt;/code&gt; )으로 시작 하거나 완전히 대문자 ( &lt;code&gt;NAME&lt;/code&gt; )로 시작하는 해시 키 사용은 일반 소문자 문자열이 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자로 올바르게 처리되지 않은 이전 버전의 Perl의 유물입니다 . 일부 모듈은 역사적 이유로 또는 개인 스타일 문제로 대문자 또는 하이픈이있는 인수 키를 유지하지만 대부분의 새 모듈은 간단한 소문자 키를 사용해야합니다. 무엇을 선택하든 일관성을 유지하십시오!</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">perl에서 인터프리터 기반 스레드를 사용하는 것은 공식적으로 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;권장되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;정규 표현식&lt;/b&gt; 에서 &lt;b&gt;하위 패턴&lt;/b&gt; 주위에 괄호 를 사용하여 일치하는 &lt;b&gt;하위 문자열&lt;/b&gt; 을 &lt;b&gt;역 참조&lt;/b&gt; 로 저장합니다 . 캡처 된 문자열은 &lt;b&gt;목록 컨텍스트&lt;/b&gt; 에서 &lt;b&gt;목록&lt;/b&gt; 으로 반환됩니다 . Camel 5 장, &quot;패턴 일치&quot;를 참조하십시오.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">괄호를 사용하여 입력 파일 이름의 일부를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">다음 기능은 실제로 기능을 테스트하지 않으며 문제를 파악하는 데 도움이되는 진단을 생성하지 않으므로 사용하지 않는 것이 좋습니다. 두 개의 임의 데이터 구조의 유용한 차이점을 표시하는 방법을 알 수 없기 때문에 &lt;code&gt;is_deeply()&lt;/code&gt; 존재하기 전에 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenm 옵션</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">파일을 소유 한 사용자 ID</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
