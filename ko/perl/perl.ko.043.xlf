<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">파일을 소유 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">사용자 시간은이 프로그램을 실행하는이 시스템에서 사용자를 대신하여 전체 프로세스가 소비 한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">정책에 따라 메모 캐시가 만료되기를 원하는 사용자는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">일반적인 산술 (+,-, + =,-=)도 객체에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">일반적인 통화 서명은</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">일반적인 관용구는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">스레드를 종료하는 일반적인 방법 은 진입 점 함수에서 적절한 반환 값으로 &lt;a href=&quot;functions/return&quot;&gt;EXPR&lt;/a&gt; 을 반환 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">일반적인 쉘 재 지정 기호 &lt;code&gt; | &lt;/code&gt; 와 &lt;code&gt;&amp;gt;&lt;/code&gt; CPAN 쉘에 의해 인식 &lt;b&gt;공백으로 둘러싸인 경우에만&lt;/b&gt; . 따라서 호출기로 파이핑하거나 파일로 출력을 리디렉션하면 추가 공백을 입력해야한다는 규정과 함께 일반 셸과 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">관련된 파일을 읽거나 쓸 수없는 경우 일반적인 경고입니다.</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">관련된 파일을 읽거나 쓸 수없는 경우 일반적인 경고입니다.</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">일반적으로 사용 가능한 상수는</target>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">util.c : 1716은 소스 코드 파일과 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v- 문자열은 최대 v2147483647 (0x7FFF_FFFF)까지만 이식 할 수 있습니다. 즉, EBCDIC 또는보다 정확하게 UTF-EBCDIC의 거리입니다.</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">v5.16 릴리스는 문자 이름의 느슨한 일치를 위해 &lt;code&gt;:loose&lt;/code&gt; import를 지원합니다 . 속성 이름의 느슨한 일치와 같이 작동합니다. 즉, 대소 문자, 공백 및 밑줄을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrind 도구를 사용하여 메모리 누수와 불법 힙 메모리 액세스를 모두 찾을 수 있습니다. 버전 3.3.0부터 Valgrind는 x86, x86-64의 Linux 및 x86 및 x86-64의 PowerPC 및 Darwin (OS X) 만 지원합니다. 특수 &quot;test.valgrind&quot;대상을 사용하여 valgrind에서 테스트를 실행할 수 있습니다. 발견 된 오류 및 메모리 누수가 이름이 지정된 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">&lt;code&gt;'fallback'&lt;/code&gt; 키에 할당 된 값 은 Perl에게 누락 된 연산자를 구현하는 다른 방법을 찾는 데 얼마나 어려운지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; 와 관련된 값 은 그 자체가 &lt;code&gt;%ENV&lt;/code&gt; 해시 의 해당 값과 일치하는 해시 참조입니다. &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;perlconfig&lt;/code&gt; 와 연관된 값 은 &lt;code&gt;Config.pm&lt;/code&gt; 모듈 에있는 &lt;code&gt;%Config::Config&lt;/code&gt; 해시 의 해당 값과 일치하는 해시 참조 입니다. &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Unix의 &lt;code&gt;$offset&lt;/code&gt; 값은 &lt;code&gt;0&lt;/code&gt; 이지만 Mac OS Classic에서는 큰 숫자입니다. 그런 다음 &lt;code&gt;$offset&lt;/code&gt; 을 Unix 시간 값에 추가하여 모든 시스템에서 적절한 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">해시의 각 항목 값은 &lt;code&gt;*name&lt;/code&gt; typeglob 표기법 을 사용할 때 참조하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">값은 &lt;code&gt;$Config{'osname'}&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 문서화 된 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 및 &lt;b&gt;-V&lt;/b&gt; 명령 행 스위치 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">$ side의 가치는</target>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">&lt;code&gt;$Config{sitelib}&lt;/code&gt; 의 값 도 C 코드로 결정되며 로드되지 않은 &lt;code&gt;Config.pm&lt;/code&gt; 에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">OpenVMS 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값 은 &quot;VMS&quot;입니다. 실행중인 아키텍처를 판별하려면 &lt;code&gt;$Config{'archname'}&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">VOS 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값 은 &quot;vos&quot;입니다. 모든 &lt;code&gt;%Config&lt;/code&gt; 를로드하지 않고 실행중인 아키텍처를 확인하려면 다음 과 같이 &lt;code&gt;@INC&lt;/code&gt; 배열 의 내용을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">하위 반환시 &lt;code&gt;$_&lt;/code&gt; 값은 파일 이름 헤더 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 값은 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 올바른 형식의 UTF-8 문자를 가리 키지 않을 때 의 동작을 결정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 기형이 발견 0이고, 0이 리턴되며, &lt;code&gt;*retlen&lt;/code&gt; 그 (있도록 설정 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; 가 )의 다음 가능한 위치 인 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 비 잘못된 문자를 시작할 수 있습니다. 또한 UTF-8 경고가 사 전적으로 비활성화되지 않은 경우 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">문자 값 ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; )은 해당 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">속성 자체의 값은 다른 객체 일 수 있습니다. 예를 들어, 마지막 모드 시간을 숫자로 반환하는 대신 &lt;code&gt;File&lt;/code&gt; 클래스 는 해당 값을 나타내는 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">단일 코드 포인트에 대해 위에서 언급 한 모든 유니 코드 (Perl 확장자를 포함하지 않음) 문자 특성의 값은 &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;Unicode :: UCD의 charprop ()를&lt;/a&gt; 통해 사용할 수 있습니다 . &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;Unicode :: UCD의 charprops_all ()은&lt;/a&gt; 주어진 코드 포인트에 대한 모든 유니 코드 속성의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">개정의 가치는</target>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">getaddrinfo () 에 대한 &lt;code&gt;flags&lt;/code&gt; 힌트 값 또는 getnameinfo ()에 대한 $ flags 매개 변수에 인식 할 수없는 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">읽은 ADLER32 필드의 값은 실제로 파일에 포함 된 압축되지 않은 데이터의 adler32 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">읽은 CRC32 필드의 값은 gzip 파일에 실제로 포함 된 압축되지 않은 데이터의 crc32 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">읽은 ISIZE 필드의 값은 실제로 파일에서 읽은 압축되지 않은 데이터의 길이와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">OP의 SV 값 (있는 경우)은 사람이 읽을 수있는 짧은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">함수의 값은 함수의 반환 값으로 다시 전달되지 않고 함수에 전달 된 변수의 값을 변경하여 전달됩니다. round의 리턴 값이 &quot;void&quot;유형 인 것을 보았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">조건이 참이 아닌 경우 &lt;code&gt;given&lt;/code&gt; 블록 의 마지막으로 평가 된 표현식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">성공한 &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 절이있는 경우 마지막으로 평가 된 표현식의 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 값은 사용자를 인증하기 위해 &lt;code&gt;getpw*&lt;/code&gt; 함수에 의해 리턴 된 UAF의 암호화 된 비밀번호와 비교 될 수 있습니다 . 이 작업을 수행하려면 UAF의 암호화 된 비밀번호가 대문자 사용자 이름 및 비밀번호 문자열을 사용하여 생성되었다는 것을 기억하십시오. 적절한 가치를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 하기 위해 인수를 대문자 로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 값 은 호출 후 영향을받을 수 있으며 파일 핸들이 플러시 될 수 있습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">에 의해 반환되는 값 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 하여 POSIX / 유닉스 세계에서 들어오는 코드 삶을 더 쉽게하기 위해서, 01-JAN-1970 0시 0분 0초 (단지 CRTL의 배와 같은 () 루틴)에서 초 오프셋.</target>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">DELETE가 리턴 한 값은 delete () 호출의 리턴 값이됩니다. delete ()의 정상적인 동작을 에뮬레이션하려면이 키에 대해 반환 된 모든 FETCH를 반환해야합니다. 이 예에서는 대신 파일이 성공적으로 삭제되었는지 여부를 호출자에게 알려주는 값을 반환하도록 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">에 의해 반환되는 값</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">에서 반환 된 값</target>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">리턴 된 값은 새 스타일입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">인수가 스칼라이거나 인수가 해시, 배열 또는 서브 루틴 인 경우 참조 인 경우 리턴되는 값은 스칼라 자체입니다.</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">빈 문자열이 반환되거나 정의되지 않은 값이 반환되면 지정된 &lt;code&gt;$text&lt;/code&gt; 가 무시됩니다 (처리되지 않음).</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">반환 된 값은 대신 사용할 새 텍스트와 일치해야합니다. 빈 문자열 또는 정의되지 않은 값이 리턴되면이 행에 대한 추가 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">경우 생성 반환되는 값에 해당 할 것이다 &lt;code&gt;$paragraph&lt;/code&gt; 과 같은 섹션의 나머지 텍스트 &lt;code&gt;$paragraph&lt;/code&gt; 처리 선택 (포함)한다; 그렇지 않으면 거짓 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 현재 처리 된 디렉토리를 떠나기 직전에 호출됩니다. 인수없이 void 컨텍스트에서 호출됩니다. 현재 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 입니다. 이 후크는 디스크 사용량 계산과 같은 디렉토리를 요약하는 데 유용합니다. 언제</target>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;의 원하는 기능에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 서브 루틴은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">값은 코드 참조 여야합니다. 이 코드 참조는 현재 디렉토리를 사전 처리하는 데 사용됩니다. 현재 처리 된 디렉토리의 이름은 &lt;code&gt;$File::Find::dir&lt;/code&gt; 입니다. 전처리 함수는 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 이후에 , &lt;code&gt;wanted()&lt;/code&gt; 함수 를 호출하는 루프 전에 호출 됩니다. 문자열 목록 (실제로는 파일 / 디렉토리 이름)과 함께 호출되며 문자열 목록을 반환해야합니다. 이 코드는 파일 / 디렉토리 이름을 알파벳순, 숫자 순으로 정렬하거나 이름 만 기준으로 디렉토리 항목을 필터링하는 데 사용할 수 있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">값은 완전한 TAP 출력이어야합니다.</target>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 옵션 과 함께 제공된 값 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 ISO 8859-1 문자와 줄 바꿈 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 옵션 과 함께 제공된 값 은 ISO 8859-1 문자 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">값은 그림 필드와 동일한 순서로 다음 형식 행에 지정됩니다. 값을 제공하는 표현식은 쉼표로 구분해야합니다. 행이 처리되기 전에 목록 컨텍스트에서 모두 평가되므로 단일 목록 표현식이 여러 목록 요소를 생성 할 수 있습니다. 중괄호로 묶으면 표현식이 둘 이상의 행으로 분산 될 수 있습니다. 그렇다면 여는 중괄호는 첫 번째 줄의 첫 번째 토큰이어야합니다. 표현식이 소수 부분이있는 숫자로 평가되고 해당 그림이 소수 부분이 출력에 표시되도록 지정하는 경우 (즉, &quot;.&quot;가 포함 &lt;b&gt;되지 않은&lt;/b&gt; 여러 &quot;#&quot;문자 &lt;b&gt;를&lt;/b&gt; 제외한 모든 그림 ), 사용 된 문자 소수점의 현재 LC_NUMERIC 로케일에 의해 결정되는 경우에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 효과가 있습니다. 예를 들어 런타임 환경에서 독일어 로캘을 지정하면 기본 &quot;.&quot;대신 &quot;,&quot;가 사용됩니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">이러한 플랫폼 중 일부 에서 &lt;code&gt;$^O&lt;/code&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">XSUB의 리턴 스택으로 푸시 된 값은 실제로 필사자 SV입니다. 호출 프로그램이 일단 값을 복사하면 리턴 된 값을 보유한 SV를 할당 해제 할 수 있도록 필멸자가됩니다. 이들이 필멸의 상태가 아닌 경우 XSUB 루틴이 리턴 된 후에도 계속 존재하지만 액세스 할 수 없습니다. 이것은 메모리 누수입니다.</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.sh에 저장된 값은 작은 따옴표 또는 큰 따옴표 일 수 있습니다. 큰 따옴표로 묶인 문자열은 문자열에 이스케이프 시퀀스를 포함해야하는 경우에 편리합니다. 런타임 변수 보간을 피하기 위해 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 문자는 각각 &lt;code&gt;\$&lt;/code&gt; 및 &lt;code&gt;\@&lt;/code&gt; 로 대체됩니다 . 물론 이것은 결코 쉬운 일이 아니므로 결과를 기꺼이 다루지 않는 한 &lt;code&gt;\$&lt;/code&gt; 또는 &lt;code&gt;\@&lt;/code&gt; 를 큰 따옴표로 묶은 문자열에 포함시키지 마십시오 . (슬래시는 이스케이프되고 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 는 변수 보간을 트리거합니다)</target>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">위의 해시에 저장된 값은 대부분 C에 해당하는 값입니다. C 상대방과 마찬가지로 모두 기본값으로 설정되므로 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 및 &lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 에는 여러 개의 포함 된 널이 포함될 수 있습니다. gzip 헤더에 작성된 문자열은 첫 번째 포함 된 NULL 이하의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 및 &lt;code&gt;-Comment&lt;/code&gt; 옵션 과 함께 제공된 값 은 여러 개의 포함 된 널을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">비교할 값은 항상 참조로 전달되며 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">변수 $ 심판은 서브 루틴 언급했을 수 &lt;code&gt;fred&lt;/code&gt; 를 호출 할 때마다 &lt;code&gt;SaveSub1&lt;/code&gt; 가 되었다하지만 시간 &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 지금 호출되는 수를 보유하고 &lt;code&gt;47&lt;/code&gt; . &lt;code&gt;SaveSub1&lt;/code&gt; 의 원래 SV에 대한 포인터 만 저장했기 때문에 $ ref에 대한 모든 변경 사항은 포인터 &lt;code&gt;rememberSub&lt;/code&gt; 에 의해 추적됩니다 . 이것은 &lt;code&gt;CallSavedSub1&lt;/code&gt; 이 호출 될 때마다 SV * &lt;code&gt;rememberSub&lt;/code&gt; 가 참조하는 코드를 실행하려고 시도 함을 의미합니다 . 이 경우 이제 정수 &lt;code&gt;47&lt;/code&gt; 을 참조하므로 Perl이 크게 불평 할 것으로 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수에는 C 컴파일러만으로 정의 된 기호가 포함됩니다. cpp 또는 cc가 cpp를 호출 할 때 정의한 기호는이 목록에 없습니다. cppsymbols 및 cppccsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수는 cpp를 호출 할 때 C 컴파일러가 정의한 기호를 포함합니다. cc 만 또는 cpp만으로 정의 된 기호는이 목록에 없습니다. ccsymbols 및 cppsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">변수는 C 전처리기만으로 정의 된 기호를 포함합니다. cc 또는 cc가 cpp를 호출 할 때 정의한 기호는이 목록에 없습니다. ccsymbols 및 cppccsymbols를 참조하십시오. 이 목록은 공백으로 구분 된 symbol = value 토큰 목록입니다.</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">변수 &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; 및 &lt;code&gt;$?&lt;/code&gt; Perl 프로그램을 실행하는 동안 나타날 수있는 다양한 유형의 오류 조건에 대한 정보가 들어 있습니다. 변수는 오류를보고 한 서브 시스템과 Perl 프로세스 사이의 &quot;거리&quot;순서로 표시됩니다. Perl 인터프리터, C 라이브러리, 운영 체제 또는 외부 프로그램에서 각각 감지 한 오류에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">변수의 길이는 수천 자이며 변경되지 않는다는 것을 알고 있으며 Perl이 테스트를 건너 뛰도록하여 약간의 속도를 줄이십시오. ( &lt;code&gt;/o&lt;/code&gt; 를 언급 하면 패턴의 변수를 변경하지 않겠다는 약속을 구성 하므로 유지 관리에 대한 페널티 가 있습니다. 변경하면 Perl도 알 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">패턴 일치로 기억 된 텍스트를 유지하는 변수 (예 : &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%&amp;ndash; &lt;/code&gt; 낙타 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">예외 마스크를 처리하기위한 기본값 좋은과 OS2 :: _ control87 ()의 변형 : 어떤 경우 &lt;code&gt;mask&lt;/code&gt; 의 예외 마스크 부분을 사용하여 &lt;code&gt;new&lt;/code&gt; 만. &lt;code&gt;new&lt;/code&gt; 가 아닌 경우 모든 부동 소수점 예외를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">다양한 &lt;code&gt;extract_...&lt;/code&gt; 서브 루틴을 사용하여 지정된 접두어 문자열을 건너 뛴 후 구분 된 서브 스트링을 추출 할 수 있습니다. 기본적으로이 접두사는 선택적 공백 ( &lt;code&gt;/\s*/&lt;/code&gt; )이지만 원하는대로 변경할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">다양한 MSWin32 Perl은 &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; 에서 반환 된 목록의 다섯 번째 요소 값을 통해 실행중인 OS를 구별 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">다양한 명명 된 단항 연산자는 선택적인 괄호와 함께 하나의 인수를 가진 함수로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">지정할 수있는 다양한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">다양한 유형의 데이터 집계는 상속 및 다형성의 사용을 용이하게하는 자연스러운 계층을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">이 영역에서보고 된 대부분의 문제는 Perl 문자열이 아닌 C 문자열이 NULL로 종료된다는 사실로 귀결됩니다. 이 문제를 해결하는 일반적인 방법 은 &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM 필터&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">코드의 대부분은 Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; 의 VMS 지원 . Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; 에 의한 OS / 2 지원 . 폴 쉰더에 의해 맥 지원 &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , 토마스 웨 그너 &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel () 및 rel2abs ()는 Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; 에 의해 수정 됨. Barrie Slaymaker의 splitpath (), splitdir (), catpath () 및 catdir ().</target>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;구현&lt;/b&gt; 과 &lt;b&gt;인터페이스&lt;/b&gt; 를 분리하는 추상화의 베일 (강제 여부에 관계없이)은 &lt;b&gt;객체&lt;/b&gt; 의 상태 에 대한 모든 액세스가 &lt;b&gt;메소드&lt;/b&gt; 만으로 이루어 지도록 요구합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">XS 모듈의 버전 식별자입니다. 이것은 일반적으로 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 의해 자동으로 처리됩니다 . &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">설치된 모듈의 버전 번호 -이 될 것 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 모듈이없는 (또는 해석 할) 버전 번호가 없었다, 또는 변수 경우 경우 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; true로 설정했다. (자세한 내용은 아래 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오)</target>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">이 문서의 마지막 업데이트 시점의 PA-RISC 버전은 2.0이며 마지막 버전입니다. HP PA-RISC 시스템은 일반적으로 &quot;HP 9000&quot;모델 설명으로 참조됩니다. 이 시리즈의 마지막 CPU는 PA-8900입니다. PA-RISC 아키텍처 머신에 대한 지원은 공식적으로 다음 표와 같이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">VMS에서 실행되는 ext () 버전은 여러 측면에서 Unix-OS / 2 버전과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">Win32에서 실행되는 ext () 버전은 여러 측면에서 Unix-OS / 2 버전과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">당신이 사용하는, Vstrings를 구현하지 않습니다 사용하고 있는지 펄의 버전 &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; 는 펄의 최신 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">사용중인 perl의 버전이 약한 참조를 구현하지 않으므로 &lt;a href=&quot;#isweak&quot;&gt;iswaak&lt;/a&gt; 를 사용 하거나 &lt;a href=&quot;#weaken&quot;&gt;약화&lt;/a&gt; 하려면 새로운 perl 릴리스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">호박 홀더가 업그레이드를 보류 할 수 있지만 Perl과 함께 배포 된 모듈 버전은 가능하면 작성자가 배포 한 최신 버전의 모듈 (공개 Perl 릴리스의 경우 베타 버전이 아닌 최신 버전)이어야합니다. 최신 버전의 테스트가 충분할 때까지 Perl과 함께 배포 된 모듈 버전이 최신 버전으로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Perl 코어의 모듈 버전은 여전히 ​​원래 작성자의 작업으로 간주되어야합니다. 모든 패치, 버그 보고서 등은 그들에게 피드백되어야합니다. 개발 방향은 가능할 때마다 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">이 모듈이 필요한 버전-이것은 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Solaris와 함께 제공된 as 및 ld 버전은 perl을 빌드하는 데 적합합니다. 일반적으로 perl을 컴파일하기 위해 GNU 버전을 설치할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">문서의 끝 :</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">가장 먼저해야 할 일은 CPAN에서 Term :: ReadKey 확장을 얻는 것입니다. 앞에서 언급했듯이 이제는 이식 불가능한 (읽기 : 개방형 시스템, 폐쇄 형, 독점 형, POSIX, 유닉스 등이 아닌) 시스템에 대한 지원이 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">볼륨 부분은 항상 후행 &quot;:&quot;과 함께 반환됩니다. 디렉토리 부분은 항상 선행 (상대 경로를 나타냄)과 후행 &quot;:&quot;(디렉토리를 나타냄)과 함께 리턴됩니다. 파일 부분은 항상 반환됩니다</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">원하는 기능</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">원하는 함수는 인수를 취하지 않고 변수 모음을 통해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">이전에 컴파일 된 함수 호출은 여전히 ​​함수의 이전 값을 사용하므로 경고는 &lt;b&gt;-w&lt;/b&gt; 스위치의 영향을받지 않을 정도로 심각하다고 간주 됩니다. 서브 루틴을 재정의 할 수 있어야하는 경우 &lt;code&gt;()&lt;/code&gt; 프로토 타입 을 삭제 ( 시맨틱을 호출하는 의미를 변경하므로주의해야 함)하거나 다른 방법으로 인라인 메커니즘을 방해하여 인라인되지 않도록해야합니다. 위에서 언급 한 것처럼 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 추가하여 :</target>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">내가 사용되는 방식은 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">펄이 파싱 과정에서 이러한 op 트리를 빌드하는 방식은 다음과 같이 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Test :: More가이를 처리하는 방식은 명명 된 블록을 사용하는 것입니다. 기본적으로 건너 뛰거나 수행 할 수있는 테스트 블록입니다. 내가 보여 주면 최고야 ...</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">프로그램이 오류에 응답하는 방식. Perl의 예외 처리 메커니즘은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">호출 할 실제 메소드를 해결하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">작동 방식은 &lt;code&gt;@{...}&lt;/code&gt; 이 큰 따옴표로 묶인 문자열에 표시되면 블록으로 평가된다는 것입니다. 블록은 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; 에 대한 호출 결과를 포함하는 익명 배열에 대한 참조를 작성합니다 . 따라서 전체 블록은 배열에 대한 참조를 반환합니다. 그런 다음 &lt;code&gt;@{...}&lt;/code&gt; 의해 역 참조되고 큰 따옴표로 묶인 문자열에 고정됩니다. 이 chicanery는 임의의 표현에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">이 트릭이 작동하는 방식은 코드 포인트 &lt;code&gt;U+FFFE&lt;/code&gt; 를 가진 문자가 입력 스트림에 있지 않아야하므로 바이트 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 의 시퀀스는 &quot; 작은 엔디안 형식으로 표현 된 &lt;code&gt;BOM&lt;/code&gt; &quot;이며 &lt;code&gt;U+FFFE&lt;/code&gt; 일 수 없습니다. , 빅 엔디안 형식으로 표시됩니다. &quot;</target>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">이 문제를 해결하는 방법은 &lt;code&gt;seq&lt;/code&gt; 라는 Berkeley DB API 메소드를 사용하는 것 입니다. 이 방법을 사용하면 키 / 값 쌍에 순차적으로 액세스 할 수 있습니다. &lt;code&gt;seq&lt;/code&gt; 메소드와 일반적으로 API에 대한 자세한 내용은 &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API 인터페이스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">이 클래스를 사용하는 방법은이 클래스의 새 객체를 만들고 옵션을 설정 한 다음 검색 옵션 중 하나를 호출하는 것입니다 ( &lt;code&gt;survey&lt;/code&gt; 또는 &lt;code&gt;find&lt;/code&gt; ). 아래 섹션에서는 모든 것을 수행하는 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">HTTP 서비스를 처리하는 웹 서버는 표준 포트 (번호 80)에있는 것으로 가정합니다. 연결하려는 서버가 1080 또는 8080과 같은 다른 포트에있는 경우 이름 지정된 매개 변수 쌍으로 지정해야합니다. , &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 입니다. 자동 &lt;code&gt;autoflush&lt;/code&gt; 메소드는 소켓에서 사용됩니다. 그렇지 않으면 시스템이 우리가 보낸 출력을 버퍼링하기 때문입니다. 선사 시대의 Mac을 사용하는 경우 네트워크를 통해 데이터를 보내는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 코드를 &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">잘 알려진 유니 코드 바이트 순서 표시는 다음과 같습니다. 파일이 두 개의 리터럴 바이트 값 0xFE 0xFF로 시작하면 이것이 빅 엔디안 UTF-16의 BOM입니다. 파일이 2 개의 리터럴 바이트 값 0xFF 0xFE로 시작하면 리틀 엔디안 UTF-16의 BOM입니다. ASCII 플랫폼에서 파일이 3 개의 리터럴 바이트 값 0xEF 0xBB 0xBF로 시작하면 UTF-8의 BOM입니다. EBCDIC 플랫폼에 이식 가능한 메커니즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">14 행에서 26 행까지의 while 루프는 입력 큐에서 스칼라를 잡고이 스레드가 담당하는 소수를 검사합니다. 15 번 줄은 소수로 확인할 숫자를 나눌 때 나머지가 있는지 확인합니다. 하나가있는 경우 소수는 소수로 나눌 수 없어야하므로 하나를 만들면 다음 스레드로 전달하거나 (17 행) 그렇지 않으면 새 스레드를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">전체 유니 코드 표준 &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">&quot;응용 프로그램을 시작하는 표준 C API&quot;의 전체 아이디어는 프로그램 인수의 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 형식 이 완전히 호환 가능 하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">두 자리 연도를 해석하기위한 전체 계획은 버그로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">공백에서 왼쪽 여백의 너비입니다. 기본값은 0입니다. 이것은 일반 텍스트가 들여 쓰기되는 양이 아니라 제목을 포함한 모든 텍스트의 여백입니다. 후자의 경우 &lt;b&gt;-i&lt;/b&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">공백에서 왼쪽 여백의 너비입니다. 기본값은 0입니다. 이것은 일반 텍스트가 들여 쓰기되는 양이 아니라 제목을 포함한 모든 텍스트의 여백입니다. 후자에 대해서는</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">서브 루틴에 대한 참조에 적용 할 때 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되는 단어 . &lt;b&gt;CV&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">서류 작업이 끝날 때까지 작업이 끝나지 않으며 모듈에 대한 문서를 작성하는 데 약간의 시간이 필요합니다. &lt;code&gt;module-starter&lt;/code&gt; 또는 &lt;code&gt;h2xs&lt;/code&gt; 는 작성을위한 스텁을 제공합니다. 형식에 대해 잘 &lt;a href=&quot;perlpod&quot;&gt;모르면 perlpod&lt;/a&gt; 에서 소개 를 찾으십시오 . 코드가 모듈에서 어떻게 사용되는지, 설명을 제공 한 다음 개별 서브 루틴 또는 메소드의 구문과 기능에 대한 참고 사항을 제공합니다. 개발자 메모에는 Perl 메모를 사용하고 최종 사용자 메모에는 POD를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">인터프리터의 작업에는 코드를 내부 표현 또는 바이트 코드로 컴파일 한 다음 실행하는 두 가지 주요 단계가 있습니다. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlguts의 컴파일 된 코드&lt;/a&gt; 는 컴파일 단계가 어떻게 발생하는지 정확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">세계 언어는 다양한 스크립트로 작성되었습니다. 이 문장 (번역으로 읽지 않는 한)은 라틴어로 작성되고 러시아어는 키릴 문자로 작성되며 그리스어는 그리스어로 작성됩니다. 히라가나 또는 가타카나에서 주로 일본어. 더 많은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">최악의 패치는 시스템 별 기능을 사용합니다. Perl 언어에 이식 불가능한 추가가 허용 될 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">쓰기 파일 핸들에 자동 플러시가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">BS2000 POSIX와 함께 제공되는 yacc는 우리에게 효과가 없었습니다. 그래서 우리는 들소를 사용해야했습니다. 순수한 bison 파서 (parent)를 사용하기 위해 perl을 약간 변경해야했습니다. 버전 1.25를 사용했지만 EBCDIC으로 인해 몇 가지 변경 사항을 추가해야했습니다. yacc에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">z / OS Unix 도구 및 장난감 목록이 도움이 될 수 있으며 Perl을 빌드하는 데 도움이되는 많은 소프트웨어 포트에 대한 링크를 포함합니다. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">그런 다음 &lt;code&gt;$reg&lt;/code&gt; 를 정규 표현식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">그런 다음 다시 괄호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">그런 다음 백만 개 이상의 문자를 수용 할 수있는 유니 코드가 제공됩니다 (Perl은 더 많은 것을 허용합니다). 즉, 문자를 나타 내기 위해 문자에 단일 바이트 이상이 필요할 수 있으므로 두 용어가 더 이상 동일하지 않습니다. 중요한 것은 문자가 전체 엔티티이며 일반적으로 해당 문자를 구성하는 바이트가 아닙니다. 이것이이 섹션 제목의 &quot;문자 의미론&quot;이라는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">그런 다음 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">그런 다음 setargv.obj를 % PlatformSDKDir % \ lib에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">그런 다음 폴더의 어느 곳에서나 발견 된 모든 .bundle 파일을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">그런 다음 자격없이 함수에서 변수를 선언하고 사용하십시오. 모듈 생성의 역학 및 스타일 문제에 대한 자세한 내용 은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 및 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">그런 다음 파일을 이동하십시오 (아마도</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">그런 다음 서브 클래스에서 &lt;code&gt;start_for&lt;/code&gt; 메소드를 대체하여 &quot;$ flags- &amp;gt; { 'target'}&quot;이 'foo'인지 확인하고 foo 블록에 있음을 표시하는 플래그를 설정하십시오 ( &quot;$ self-&amp;gt; { 'in_foo'} = 1 &quot;). 그런 다음 &lt;code&gt;handle_text&lt;/code&gt; 메소드를 대체하여 플래그를 확인하고 $ text를 사용자 정의 서브 루틴에 전달하여 'foo'요소에 대한 HTML 출력을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">그런 다음 다음 스크립트 (또는 이와 유사한 스크립트)를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">그런 다음 해당 텍스트와 &lt;code&gt;=cut&lt;/code&gt; 으로 시작하는 줄을 포함하여 남아있는 모든 텍스트 는 무시됩니다. 중재 텍스트의 형식은 &lt;a href=&quot;perlpod&quot;&gt;perlpod에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">그런 다음 왼쪽에 간접적 인 할당은 이미 있던 기존 참조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">그런 다음 핸들러는 수신하는 데이터를 해석하려고 시도하지 않고 단순히 문자열로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">그런 다음 일치가 실행되고 나머지 줄은 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">그런 다음 일반적인 파일 핸들처럼 사용하십시오. Perl이 파일 핸들을 기대하는 곳이면 간접 파일 핸들을 대신 사용할 수 있습니다. 간접 파일 핸들은 파일 핸들을 포함하는 스칼라 변수 일뿐입니다. &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 다이아몬드 연산자 와 같은 함수 는 명명 된 filehandle 또는 하나를 포함하는 스칼라 변수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">그런 다음 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">그런 다음 $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">그런 다음 0x2000-0x204D 범위 (www.unicode.org의 문자표 참조)에서 남은 주목할만한 유니 코드 문자를 진행할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">그럼 당신은 사용할 수 &lt;code&gt;FH&lt;/code&gt; 을 에, 파일 핸들로 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 와 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 등등합니다. 전역 변수이므로 새 코드에서는이 형식을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">그럼 당신은 사용할 수 &lt;code&gt;FH&lt;/code&gt; 을 에, 파일 핸들로 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 와 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 등등합니다. 전역 변수이므로 새 코드에서는이 형식을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">그런 다음 Perl 스택을 조작하는 방법을 알아야합니다. 이것은 &lt;a href=&quot;perlcall&quot;&gt;perlcall에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">그런 다음 &quot;이름&quot;을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 옵션 을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">그런 다음 인수 앞에 자동 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 제공했습니다 . 하나의 것을 유지하는 데 사용 되었던 오래된 &lt;code&gt;@foo&lt;/code&gt; 는 전달되지 않습니다. 대신 &lt;code&gt;func()&lt;/code&gt; 이제 &lt;code&gt;1&lt;/code&gt; 로 전달됩니다 . 즉, &lt;code&gt;@foo&lt;/code&gt; 의 요소 수입니다 . 그리고 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 그것이 당신에 낙서 시작 있도록 스칼라 문맥에서 호출되는 &lt;code&gt;@_&lt;/code&gt; 매개 변수의 목록입니다. 아야!</target>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">그런 다음 호출 된 컨텍스트의 클래스 및 메소드 이름을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">BS2000 POSIX 시스템에서 부동 소수점 구현에 버그가있는 것 같습니다. 숫자와 소수의 곱에서 int ()를 호출하는 것이 해당 숫자의 몫에서 int ()를 호출하는 것과 같지 않습니다. 크기 숫자. 예를 들어, 다음 Perl 코드에서 :</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">S / 390 시스템에서 부동 소수점 구현에 버그가있는 것 같습니다. 예를 들어 숫자와 소수의 곱에서 int ()를 호출하는 것은 해당 숫자의 몫에서 int ()를 호출하는 것과 같지 않습니다. 큰 숫자입니다. 예를 들어, 다음 Perl 코드에서 :</target>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">채워질 수있는 항목에는 3 가지가 있습니다. 특수 패턴, #var 및 리터럴 텍스트가 그대로 복사됩니다. (예, 일련의 s /// g 단계입니다.)</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">있습니다 &lt;code&gt;lint&lt;/code&gt; 및 &amp;lt;부목&amp;gt; 목표는 메이크에,하지만 당신은 플래그 (위 참조) 속이다 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">날짜 필드에 리턴되는 값을 제어하는 ​​DECC 기능 논리 이름 및 ODS-5 볼륨 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">위의 규칙에는 몇 가지 예외가 있습니다. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 는 항상 유니 코드 코드 포인트로 해석되므로 EBCDIC 플랫폼에서도 &lt;code&gt;\N{U+0050}&lt;/code&gt; 은 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 입니다. 그리고 &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; 이 유효한 경우 숫자는 해당 인코딩에있는 것으로 간주되며 해당 기본 문자가있는 경우 숫자를 플랫폼의 기본 인코딩으로 변환합니다. 그렇지 않으면 유니 코드로.</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">XS 모듈에서 매우 기본적인 예외 처리를 수행하는 몇 가지 매크로가 있습니다. 포함하기 전에 &lt;code&gt;NO_XSLOCKS&lt;/code&gt; 를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">실제로 유형 지정자가 아닌 몇 가지 다른 기호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; (스크립트에 대한 명령 행 인수) 및 &lt;code&gt;@_&lt;/code&gt; (서브 루틴에 전달 된 인수 )와 같은 특수 배열도 있습니다. 이것들은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">이 분석에 대해 유의해야 할 사항이 몇 가지 있습니다. 첫째, 두 번째 그룹 'de'의 세 번째 대안도 일치를 허용하지만 주어진 문자 위치에서 가장 왼쪽에있는 승리를 얻었습니다. 둘째, 문자열 'a'의 첫 번째 문자 위치에서 일치시킬 수있었습니다. 첫 번째 위치에 일치하는 항목이 없으면 Perl은 두 번째 문자 위치 'b'로 이동하여 다시 일치를 시도합니다. 가능한 모든 문자 위치에서 가능한 모든 경로가 소진 된 경우에만 Perl은 &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; 포기하고 선언 합니다. 거짓이다.</target>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">전체 해시를 처리 할 수있는 몇 가지 방법이 있습니다. 키 목록을 얻은 다음 각 키를 살펴 보거나 한 번에 하나의 키-값 쌍을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">객체 지향 Perl을 정의하는 몇 가지 기본 원칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">그러나 몇 가지 예외 가 있습니다 . &lt;code&gt;x&lt;/code&gt; 는 왼쪽 피연산자의 유형에 따라 문자열 반복 또는 목록 반복 일 수 있으며 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 문자열 또는 숫자 비트 연산 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">일치 연산자에 대해 알아야 할 사항이 몇 가지 더 있습니다. 전역 수정 자 &lt;code&gt;//g&lt;/code&gt; 를 사용하면 일치 연산자가 문자열 내에서 가능한 한 많이 일치 할 수 있습니다. 스칼라 문맥에서 문자열에 대한 연속 일치는 일치에서 문자열로 &lt;code&gt;//g&lt;/code&gt; 점프하여 문자열의 위치를 ​​추적합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">BTREE 데이터베이스에서 순서를 변경하려면 몇 가지 유의해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">자신 만의 &lt;code&gt;ResultFactory&lt;/code&gt; 를 생성 할 때 명심해야 할 것이 몇 가지 있습니다 .</target>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">그러나 몇 가지 알아야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPAN에는 많은 모듈이 있으며, 기고하려는 것과 유사한 모듈을 놓치기 쉽습니다. &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org를&lt;/a&gt; 통해 쟁기질을 하고 바퀴를 재발견하는 사람이 아닌지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">문장 부호 나 라인 노이즈처럼 보이는 이름을 가진 여러 &quot;마법의&quot;스칼라가 있습니다. 이 특수 변수는 모든 종류의 목적으로 사용되며 &lt;a href=&quot;perlvar&quot;&gt;perlvar에&lt;/a&gt; 문서화되어 있습니다. 당신이 지금 알아야 할 유일한 것은 &quot;기본 변수&quot;인 &lt;code&gt;$_&lt;/code&gt; 입니다. Perl의 여러 함수에 대한 기본 인수로 사용되며 특정 루핑 구문에 의해 암시 적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 아래 여러 문자와 일치하는 여러 유니 코드 문자가 있습니다. 예를 들어, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; 는 시퀀스 &lt;code&gt;fi&lt;/code&gt; 와 일치해야합니다 . Perl은 여러 문자가 패턴에 있고 그룹화로 분할되거나 하나 이상의 수량화 될 때 현재이를 수행 할 수 없습니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">아직 다루지 않은 많은 이스케이프 시퀀스와 문자 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">정규 표현식 구조의 끝에서 찾을 수있는 많은 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">유니 코드 규칙에서 대소 문자를 구분하지 않는 일치와 관련하여 여러 가지 문제가 있습니다. 위 &lt;a href=&quot;#Modifiers&quot;&gt;수정 자&lt;/a&gt; 아래의 &lt;code&gt;i&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">NDBM 파일에 저장할 수있는 데이터 크기에는 여러 가지 제한이 있습니다. 가장 중요한 것은 키 길이와 관련 값의 길이에 1008 바이트를 초과 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">SDBM 파일에 저장할 수있는 데이터 크기에는 여러 가지 제한이 있습니다. 가장 중요한 것은 키 길이와 관련 값의 길이에 1008 바이트를 초과 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">Perl에서 GUI를 작성할 수있는 많은 모듈이 있습니다. 대부분의 GUI 툴킷에는 perl 인터페이스가 있습니다. 불완전한 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">여기에 소개 된 여러 가지 새로운 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; 옵션 에는 몇 가지 다른 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tie::File&lt;/code&gt; 선호하는 데는 여러 가지 이유가 있습니다 . &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; 에서 목록을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">전체 유니 코드 단어 문자 목록에는 여러 가지 보안 문제가 있습니다. &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">이런 종류의 문제를 처리하는 방법에는 여러 가지가 있습니다. 가장 좋은 방법은 모든 스레드가 항상 동일한 순서로 잠금을 획득하도록하는 것입니다. 예를 들어, 변수 잠금 경우 &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$z&lt;/code&gt; 항상 잠금 &lt;code&gt;$x&lt;/code&gt; 전에 &lt;code&gt;$y&lt;/code&gt; , 및 &lt;code&gt;$y&lt;/code&gt; 하기 전에 &lt;code&gt;$z&lt;/code&gt; . 교착 상태의 위험을 최소화하기 위해 잠깐 동안 잠금을 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">다양한 &quot;보안&quot;수준으로 Perl 프로그램에 소스를 숨기는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">다양한 효율성을 가진 여러 가지 방법이 있습니다. 문자열 내에서 특정 단일 문자 (X)를 원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 함수를 다음과 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">Perl 프로그램 개발, 특히 Perl을 C로 확장하는 데 도움이되는 유틸리티 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22와 함께 제공되는 CPAN 모듈에는 많은 테스트 실패가 있습니다. 이들은 주로 Perl 5 포터가 유지 보수하지 않는 모듈에만 있습니다. 이 중 일부는 테스트에서만 실패한 것입니다. EBCDIC 플랫폼에서 다른 결과를 얻는 것이 적절하다는 것을 인식하지 못합니다. 그리고 일부 실패는 실제 버그입니다. Perl에서 컴파일하고 &lt;code&gt;make test&lt;/code&gt; 를 수행하면 &lt;code&gt;/cpan&lt;/code&gt; 디렉토리 의 모든 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">다양한 목적을 제공하는 인트라 문자 세트 맵핑으로 데이터를 변환하는 다양한 방법이 있습니다. 정렬은 이전 섹션에서 논의되었으며 다른 인기있는 몇 가지 매핑 기술은 다음에 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">실제로는 정의되지 않은 문자열과 정의되지 않은 문자열의 두 가지 null 문자열 (때로는 &quot;빈&quot;문자열이라고 함)이 있습니다. 정의 된 버전은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 와 같이 길이가 0 인 문자열입니다 . 정의되지 않은 버전은 오류가 있거나 파일이 끝났을 때 또는 초기화되지 않은 변수 또는 배열 또는 해시의 요소를 참조 할 때와 같이 무언가에 대한 실제 값이 없음을 나타내는 값입니다. 초기 버전의 Perl에서는 정의 된 값을 예상하는 장소에서 처음 사용할 때 정의되지 않은 스칼라가 정의 될 수 있지만, &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 설명 된 드문 경우의 자생 생존을 제외하고는 더 이상 발생하지 않습니다.. defined () 연산자를 사용하여 스칼라 값이 정의되어 있는지 (배열 또는 해시에 의미가 없는지) 확인하고 undef () 연산자를 사용하여 정의되지 않은 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">특정 추가 기능을 사용하기 위해 &lt;code&gt;GV_ADD&lt;/code&gt; 인수로 값을 비트 단위로 OR 할 수있는 추가 매크로가 있습니다. 그 비트는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">도 있습니다 &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; 과 &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; &lt;code&gt;perldoc Win32&lt;/code&gt; 를 시도 하고 libwin32 0.19 (핵심 Perl 배포의 일부는 아님) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 시도하십시오 . 이식성이 뛰어난 &lt;code&gt;POSIX::uname()&lt;/code&gt; 도 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">사용할 끝없는 가능성도 있습니다</target>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;comp.lang.perl.*&lt;/code&gt; 아래에 Perl 관련 뉴스 그룹이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">라이센스를 구입해야하지만 일부 상용 제품도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">작업에 일반적으로 사용되는 몇 가지 모듈이 있습니다. &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; (5.8과 함께 배포)은 변수가 숫자처럼 보이는지 여부를 결정 하기 위해 perl의 내부 함수 &lt;code&gt;looks_like_number&lt;/code&gt; 에 액세스 할 수 있도록합니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt; 는 위와 다른 정규식을 모두 사용하여 데이터 형식의 유효성을 검사하는 함수를 내 보냅니다. 셋째, 다양한 유형의 숫자와 일치하는 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;정규식&lt;/a&gt; 이있는 Regexp :: Common 이 있습니다. 이 세 가지 모듈은 CPAN에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">다른 op 유형도 있습니다. &lt;code&gt;PMOP&lt;/code&gt; 에는 정규식이 있고 자식이 없으며 &lt;code&gt;LOOP&lt;/code&gt; 에는 자식이 있거나 없을 수 있습니다. 는 IF &lt;code&gt;op_children&lt;/code&gt; 필드가 0이 아닌이며, 그것은처럼 동작 &lt;code&gt;LISTOP&lt;/code&gt; . 문제를 복잡하게하기 위해, 최적화 후 &lt;code&gt;UNOP&lt;/code&gt; 가 실제로 &lt;code&gt;null&lt;/code&gt; 연산 인 경우 ( &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;컴파일 패스 2 : 컨텍스트 전파 참조&lt;/a&gt; ) 이전 유형에 따라 여전히 하위 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 과 누산기 변수 &lt;code&gt;$^A&lt;/code&gt; 를 사용할 수있는 몇 가지 트릭도 있지만 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 이 페이징 등을 처리하지 않으므로 형식 값이 많이 손실됩니다 . 사용하면 형식을 다시 구현하게됩니다.</target>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">부울 TRUE 및 FALSE 값을 각각 포함 하는 두 개의 값 &lt;code&gt;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;PL_sv_no&lt;/code&gt; 도 있습니다. &lt;code&gt;PL_sv_undef&lt;/code&gt; 와 마찬가지로 &lt;code&gt;SV*&lt;/code&gt; 가 필요할 때마다 해당 주소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">이름에 &quot;_hex&quot;또는 &quot;_base64&quot;가 추가 된 기능 버전도 있으며 이는 표시된 형식으로 요약을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">해시 참조에 {data} 및 {encoding}의 인스턴스 변수가 두 개 이상 저장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">스크립트가 몇 개의 테스트를 실행할지 미리 알 수없는 경우가 있습니다. 이 경우 마지막에 테스트를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">CPAN이 이미 제공 한 특정 애플리케이션 공간이 있습니다. 하나는 템플릿 시스템이고, 다른 하나는 날짜 및 시간 모듈이며, 더 많은 것이 있습니다. 이런 것들을 자신의 버전으로 작성하는 것은 통과 의례이지만, Perl 세계가 실제로 그것을 출판해야하는지 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">대응하는 문자 명령있다 , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 은 상기 네 개의 카테고리들 각각에 대해 다른 &lt;code&gt;i&lt;/code&gt; (가) 네 언급 중 어떤. 4 개의 엔티티 각각은 객체를 표시하는 방법이 약간 다른 클래스로 구현됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">현재 세 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; 네임 스페이스에는 다양한 사서함 유형을 지원하기위한 클래스가 다릅니다 . 이러한 모듈은 일반적으로 다소 제한적이며 쓰기보다는 &lt;b&gt;읽기만&lt;/b&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">등에 대한 -이 역 참조 작업에 대한 위의 규칙에 대한 예외 (역 참조를 참조 1 단계가 실패 할 경우, 항상 정상으로 돌아 가을, 내장 구현)입니다 &lt;code&gt;~~&lt;/code&gt; 규칙의 그것의 자신의 세트가있다 (- 참조 &lt;code&gt;Matching&lt;/code&gt; 아래를 위의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;과부하 작업&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">단순 스칼라 맵에는 예외가 있습니다. 일부 속성에는 맵 목록에 스칼라 목록 인 일부 요소가 있습니다. 그리고 그대로 해석되지 않는 일부 특수 문자열이 리턴됩니다. 반환 된 네 개의 요소 목록 중 요소 [2] (위 예에서 &lt;code&gt;$format&lt;/code&gt; 배치 )는 다음과 같이지도에 이러한 특수 요소가 있는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">패턴과 일치를 검사 할 소스간에 엄격한 일대일 일치 이외의 다섯 가지 패턴 일치 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">네 가지 주장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">DBM 필터와 관련된 네 가지 방법이 있습니다. 모두 동일하게 작동하며 각각 단일 DBM 필터를 설치 (또는 설치 제거)하는 데 사용됩니다. 각각은 단일 매개 변수, 즉 하위에 대한 참조를 필요로합니다. 그들 사이의 유일한 차이점은 필터가 설치된 장소입니다.</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">C 프로그램 내에서 Perl 서브 루틴을 호출하는 데 사용할 수있는 네 가지 루틴이 있습니다. 이 네 가지는 :</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">참조를하는 데는 두 가지 방법이 있으며, 일단 참조를 사용하는 데는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">CPAN에는 문자 그대로 수십 개의 다른 OO 관련 모듈이 있으며 여기에서 다루는 것 외에도 다른 사람들의 코드로 작업 할 경우 하나 이상의 모듈에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">더 많은 명령과 옵션이 있지만 위의 작업과 옵션이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">다양한 주제에 대한 Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;메일 링리스트&lt;/a&gt; 가 많이 있으며 , 특히 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;초보자리스트&lt;/a&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">Perl 및 Perl 관련 서적이 많이 있습니다. 이들 중 일부는 좋고 일부는 괜찮지 만 많은 사람들은 돈을 쓸 가치가 없습니다. &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; 에이 책들의 목록이 있으며 일부는 광범위한 리뷰를 가지고 있습니다. 우리는 여기에 일부 책을 나열하고, 책을 나열하는 것이 우리의 승인을 의미하지만, 책을 포함하지 않는 것이 의미가 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">사용 가능한 여러 가지 ftp 방화벽 제품이 있습니다. 그러나 불행히도 방화벽을 통과하는 방법에 대한 표준은 없습니다. 아래 목록은 Net :: FTP가 사용할 명령 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;Perl에 관한&lt;/a&gt; 좋은 책 들이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">여기에 설명 된 가장 기본적인 것보다 더 많은 속성이 있습니다. 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">FileHandle이 IO :: File, IO :: Seekable 및 IO :: Handle의 하위 항목이므로 사용 가능한 다른 기능이 많이 있습니다. 더 많은 기능에 대한 설명서는 해당 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">여러 가지 이유가 있지만 가장 큰 이유는 크로스 플랫폼 호환성입니다.</target>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">값이 기대하거나 수용하려는 값이되도록 여러 가지 방법이 있습니다. perlfaq에서 다루는 특정 예 외에도 &quot;Assert&quot;및 &quot;Validate&quot;가있는 모듈을 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 과 같은 다른 모듈과 함께 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">여러 줄 데이터를 문자열로 가져 오는 방법에는 여러 가지가 있습니다. 입력을 읽는 동안 자동으로 발생 하게하려면 한 번에 두 줄 이상을 읽을 수 있도록 $ /를 설정하십시오 (단락의 경우 ''또는 전체 파일의 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정).</target>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">많은 유니 코드 문자 속성이 있습니다. 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops를&lt;/a&gt; 참조하십시오 . 그들 중 대부분은 짧은 이름의 동의어를 가지고 있으며 거기에 나열되어 있습니다. 일부 동의어는 단일 문자입니다. 이를 위해 버팀대를 떨어 뜨릴 수 있습니다. 예를 들어, &lt;code&gt;\pM&lt;/code&gt; 은 &lt;code&gt;\p{Mark}&lt;/code&gt; 와 동일하며 악센트 표시와 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">많은 코드 포인트가 있지만 컴퓨터는 바이트로 작동하며 바이트에는 256 값만 사용할 수 있습니다. 유니 코드에는 그보다 더 많은 문자가 있으므로이를 액세스 할 수있는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">Solaris 정보에 대한 많은 소스가 있습니다. 펄을위한 중요한 것들 :</target>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">모듈 작성 과정을 도와주는 모듈이 있습니다 : &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">참조 루프가 없습니다.</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">알 수없는 결과에 대한 고유 한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 아래에는 불일치하는 유니 코드 규칙이 있으며,이 규칙은 다양하지만 일치하지는 않습니다. 예를 들어, 하위 문자열 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 는 단일 문자 LATIN SMALL LETTER SHARP S와 일치 할 수 있습니다. 단일 합자 문자와 일치 할 수있는 다른 ASCII 문자 시퀀스 (예 : LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; )가 있습니다. Perl v5.16부터 ASCII 일치 만 신경 쓰면 &lt;code&gt;/aa&lt;/code&gt; 수정자를 정규식에 추가하면 이러한 모든 명백하지 않은 일치가 제외 되어이 메시지가 제거됩니다. 당신은 또한 말할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; 적용 &lt;code&gt;/aa&lt;/code&gt; 그 범위 내에서 컴파일 된 모든 정규 표현식. &lt;a href=&quot;re&quot;&gt;다시&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">코드에는 두 개의 중첩 루프가 있습니다. 이전과 같이 STDIN에서 압축 된 데이터를 읽는 외부 루프; 압축을 수행하기위한 내부 루프.</target>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">현재 Perl 자체 (또는이 모듈에서 직접 보는 방식에 따라 직접 처리)에 의해 처리되는 속성은 거의 없습니다. 그러나 패키지 특정 속성은 확장 메커니즘에 의해 허용됩니다. 아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">찾고있는 정보를 포함 할 수있는 다른 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">특히 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 와 관련하여 다른 사소한 차이 가 있지만 일반적으로 해당 관계는 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다른 런타임 옵션도 있습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">long이 64 비트 인 플랫폼과 int가 64 비트 인 플랫폼이 있으며, 쇼트가 64 비트 인 플랫폼까지 충격을 주려고합니다. 이것은 C 표준에 따라 모두 합법적입니다. 즉, &quot;long long&quot;은 64 비트를 지정하는 이식 가능한 방법이 아니며 &quot;long long&quot;은 &quot;long&quot;보다 더 넓은 것으로 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">비 ASCII 플랫폼 (EBCDIC)에는 더 많은 버그가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">더 나쁜 시스템이 많이 있습니다!</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">이 패키지 기반 해상도가 문제가되는 경우는 거의 없습니다. 한 패키지에서 다른 패키지로 서브 루틴을 복사 하면 원래 패키지를 기준으로 &lt;code&gt;SUPER&lt;/code&gt; 해결이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">펄 개발에는 실제로 유지 보수 버전과 실험 버전의 두 가지 트랙이 있습니다. 유지 관리 버전은 안정적이며 마이너 릴리스 (예 : perl5.18.x, 여기서 18은 마이너 릴리스)로 짝수입니다. 실험 버전에는 안정적인 버전으로 만들지 않고 부 버전으로 홀수 (예 : perl5.19.x, 여기서 19는 부 버전) 인 기능이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">알아야 할 몇 가지 I / O 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">변환 루틴이 입력 파일 이름이 Unix 형식인지 VMS 형식인지 확인할 수없는 몇 가지 모호한 경우가 있습니다. 이제 VMS 및 Unix 파일 스펙에 다른 유형의 구문 구분 기호로 오인 될 수있는 문자가있을 수 있기 때문입니다. 따라서 일부 경로 이름은 단순히 두 가지 유형의 경로 이름을 모두 사용할 수있는 모드에서 사용할 수 없습니다. Perl은 모호한 파일 이름이 Unix 형식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">국가를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">통화를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">언어를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">스크립트를 식별하는 데 사용할 수있는 여러 가지 코드 세트가 있습니다. 코드 세트는 이름 또는이 모듈에서 자동으로 내보내는 상수를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">대소 문자를 구분하여 문자 또는 문자열을 변환하는 이스케이프 시퀀스가 ​​여러 개 있으며 패턴 내에서도 사용할 수 있습니다. &lt;code&gt;\l&lt;/code&gt; 및 &lt;code&gt;\u&lt;/code&gt; 는 다음 문자를 각각 소문자 또는 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">테스트에서 문자 및 코드 포인트를 이식 가능하게 지정하는 데 사용할 수있는 몇 가지 기능이 있습니다. 항상 사전로드 된 함수 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 및 그 역 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; 는 코드 포인트를 가져와 적절하게 변환합니다. 파일</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">워크샵을 찾을 수있는 훌륭한 자료가 몇 가지 있습니다 : 위에서 언급 한 &lt;a href=&quot;#Websites&quot;&gt;웹 사이트&lt;/a&gt; , 아래에 언급 된 &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;캘린더&lt;/a&gt; , YAPC 유럽 웹 사이트 &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt; 는 아마도 유럽 펄 행사를위한 최고의 자료입니다.</target>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Posix 클래스에 대해 &lt;code&gt;\p{}&lt;/code&gt; 표기법을 사용하는 동등한 몇 가지가 &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;있으며 perlrecharclass의 POSIX 문자 클래스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 중 몇 가지는 표준 Posix 클래스가 전체 유니 코드 범위로 확장되어 있습니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl이 구현하는 몇 가지 유형의 문자 클래스 테스트가 있습니다. 여기에 설명 된 유일한 것은 8 비트 문자에서 작동하는 C 라이브러리 함수에 직접 대응하는 기능이지만 와이드 문자 및 UTF-8로 인코딩 된 문자열에서는 작동하는 기능이 있습니다. 모두 &lt;a href=&quot;perlapi#Character-classification&quot;&gt;perlapi의 문자 분류&lt;/a&gt; 및 perlapi의 &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;문자 대소 문자 변경에&lt;/a&gt; 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">디버거를 호출하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">DCL에서 Perl 스크립트를 래핑하는 몇 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt; 템플릿에 버그가 있습니다</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">Perl이 표현식과 명령문의 차이점을 즉시 알 수없는 경우가 있습니다. 예를 들어, 블록의 구문과 익명의 해시 참조 생성자는 괄호 안에 Perl에 힌트를 줄 무언가가 없다면 동일하게 보입니다. Perl이 &lt;code&gt;{ ... }&lt;/code&gt; 가 블록 이라고 추측하지 않으면 생략 부호는 구문 오류 입니다. 이 경우, 문이 아닌 표현식을 기대하기 때문에 &lt;code&gt;...&lt;/code&gt; 이 줄임표 라고 생각하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; 와 같은 런타임 문을 사용 하고 변수를 패키지에 할당하는 것과 같은 몇 가지주의 사항 이 있습니다. 이는 인식하지 못하는 프로그래머에게는 미묘합니다. 예를 들어 상호 재귀 모듈에서 발생할 수 있으며, 이는 관련 구성이 실행되는 시간에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">xV 파괴에 도움이되는 몇 가지 편리한 기능이 있습니다. 이러한 기능은 &quot;사망률&quot;이라는 개념을 소개합니다. 필멸의 xV는 참조 시간이 감소한 것으로 표시되었지만 &quot;짧은 시간&quot;까지 실제로 감소하지는 않았습니다. 일반적으로 &quot;짧은 시간&quot;이라는 용어는 XSUB 함수 호출과 같은 단일 Perl 문을 의미합니다. 필사자 xV의 참조 횟수가 감소 할 때의 실제 결정 요인은 SAVETMPS 및 FREETMPS의 두 매크로에 따라 다릅니다. 이 매크로에 대한 자세한 내용 은 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 및 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">중복 키를 사용하여 BTREE 데이터베이스를 조작하려는 경우 연결된 해시 인터페이스를 사용하는 데 약간의 어려움이 있습니다. 이 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">이 방법에는 몇 가지 단점이 있습니다. 하나는 파일 조작 C 함수를 호출하는 확장명을 다시 컴파일해야한다는 것입니다 (일반적인 &quot;perl Makefile.PL; make; 테스트; make 설치&quot;절차를 따르십시오).</target>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">이 기술에는 몇 가지 명백한 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">동작 방식을 변경 하기 위해 &lt;code&gt;memoize&lt;/code&gt; 할 수있는 옵션 옵션이 있습니다 . 옵션을 제공하려면 다음과 같이 &lt;code&gt;memoize&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">oneliners에 대한 몇 가지 지름길이 있습니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun의 &lt;/a&gt;&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">잘못된 하이퍼 링크와 관련하여 몇 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">유니 코드 (일부 인코딩 또는 기타)가 인수로 주어 지거나 결과로 또는 Perl로 수신 될 수있는 곳이 여전히 많지만 Perl이 유니 코드로 입력 및 출력하는 광범위한 방법에도 불구하고 그렇지는 않습니다. &lt;code&gt;@ARGV&lt;/code&gt; 배열 과 같은 다른 &quot;입력 지점&quot; (UTF-8로 해석 될 수 있음) 은 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">경고가 생성되거나 생성되지 않는시기를 제어하는 ​​데 사용할 수있는 세 가지 명령 줄 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">외부 명령을 실행하는 세 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">스레드 프로그램을 구성 할 수있는 세 가지 기본 방법이 있습니다. 어떤 모델을 선택해야하는지 프로그램에 따라 다릅니다. 사소하지 않은 많은 스레드 프로그램의 경우 프로그램의 다른 부분에 대해 다른 모델을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">정규식 엔진에는 &quot;다음&quot;이라는 세 가지 고유 한 개념이 있으며 명확하게 유지하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">이 오버 헤드를 피하기 위해 널리 사용되는 세 가지 방법이 있습니다. 한 가지 해결책은 mod_perl 또는 mod_fastcgi 플러그인 모듈 중 하나를 사용하여 Apache HTTP 서버 ( &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; 에서 사용 가능)를 실행하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">Perl 정규식에는 3 가지 유형의 문자 클래스가 있습니다 : 점, 백 슬래시 시퀀스 및 대괄호로 묶인 형식. 그러나 종종 &quot;캐릭터 클래스&quot;라는 용어는 대괄호 형태를 의미하기 위해 사용됩니다. 확실히, 대부분의 Perl 문서는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">이를 수행하는 세 가지 방법이 있습니다. 첫째, 확장과의 소스 호환성을 유지하기 위해 쉽고 효율적이지 않은 방법도 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">핵심에서 테스트를 작성하는 세 가지 방법이 있습니다 : &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">자신의 소스 필터를 작성하는 세 가지 방법이 있습니다. C로 작성하거나 외부 프로그램을 필터로 사용하거나 Perl에서 필터를 작성할 수 있습니다. 처음 두 부분은 자세하게 다루지 않으므로 먼저 두 가지 방법을 알아 보겠습니다. Perl에서 필터를 작성하는 것이 가장 편리하므로 가장 많은 공간을 사용하도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">스레드가 CPU를 다른 스레드에 명시 적으로 포기하도록하는 것이 유용한 경우가 있습니다. 프로세서를 많이 사용하고 사용자 인터페이스 스레드가 자주 호출되도록 할 수 있습니다. 어쨌든 스레드가 프로세서를 포기하기를 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">두 가지 기본 작동 모드가 있습니다 (플러스를 끄면 끄는 것).</target>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">두 콜백 있습니다 &lt;code&gt;named_buff&lt;/code&gt; 가 CLEAR, 삭제, 저장을 FETCH 모든 경우에 호출이 존재하고 SCALAR &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; 콜백 변경에있을 것입니다 &lt;code&gt;%+&lt;/code&gt; 와 &lt;code&gt;%-&lt;/code&gt; 과 &lt;code&gt;named_buff_iter&lt;/code&gt; FIRSTKEY 및 NEXTKEY과 같은 경우이다.</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">다중 바이트 및 단일 바이트 로케일의 두 가지 경우가 있습니다. 첫 멀티 바이트 :</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">실행 파일을 프로파일 링하는 데 일반적으로 사용되는 두 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">OS / 2의 dyna-linking 모델에는 두 가지 특징이 있습니다. 첫째, 외부 함수에 대한 모든 참조는 컴파일 타임에 해결됩니다. 둘째, 메모리에로드 된 DLL의 런타임 수정은 없습니다. 첫 번째 기능은 다른 모델에 비해 엄청난 이점입니다. 응용 프로그램에서 사용하는 여러 DLL이 동일한 이름의 항목을 내보낼 때 충돌을 피합니다. 이러한 경우, 다이너-링크의 &quot;다른&quot;모델은 예측 가능한 재난과 함께 임의의 기준을 사용하여이 두 진입 점 중에서 선택합니다. 그러나 두 번째 기능은</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">내부 비 압축 루프에는 2 개의 출구 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">두 가지 형태의 8 진 탈출이 있습니다. 각각 8 진수 표기법으로 지정된 코드 포인트로 문자를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">기억해야 할 두 가지 중요한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">해시에는 &quot;읽기&quot;와 &quot;쓰기&quot;라는 두 가지 키가 있습니다. 여기에는 팩리스트 파일이 포함됩니다. 복사가 완료되면 install ()은 대상 파일 목록을 $ from_to {write}에 기록합니다. $ from_to {read}가 제공되면이 파일의 내용이 작성된 파일로 병합됩니다. 읽은 파일과 쓴 파일은 동일 할 수 있지만 AFS에서는 사람들이 파일이 나중에 나타나는 디렉토리와 다른 디렉토리에 설치하고있을 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">두 가지 새로운 디스플레이 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">두 개의 피연산자가 있지만 결합 방법을 제공하는 연산자는 없습니다.</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perl에는 두 개의 패키지 구분 기호가 있습니다 : 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :) 과 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ). 일반 식별자는 이중 콜론으로 시작하거나 끝날 수 있으며 이중 콜론으로 구분 된 여러 부분을 포함 할 수 있습니다. 작은 따옴표는 비슷한 규칙을 갖지만 식별자 끝에서 합법적이지 않다는 점을 제외하면 &lt;code&gt;$'foo&lt;/code&gt; 와 &lt;code&gt;$foo'bar&lt;/code&gt; 는 합법적이지만 &lt;code&gt;$foo'bar'&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">OS / 2 API의 오류 조건을보고하는 두 가지 주요 규칙 ( &lt;code&gt;Dos*&lt;/code&gt; 및 &lt;code&gt;Win*&lt;/code&gt; 을 호출하는 것이 유용 하지만 함수 서명의이 부분이 항상 API 이름으로 결정되는 것은 아님)이 있습니다. 대부분의 &lt;code&gt;Dos*&lt;/code&gt; API는 호출 결과로 오류 코드를보고합니다 (따라서 0은 성공을 의미하고 여러 유형의 오류가 있음). 대부분의 &lt;code&gt;Win*&lt;/code&gt; API는 결과가 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 인 성공 / 실패를보고 합니다 . 실패 이유를 찾으려면 WinGetLastError () API를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">테스트 스위트를 실행하는 데는 두 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 정규식을 저장하는 데 사용되는 두 가지 구조가 있습니다. 하나는 &lt;code&gt;regexp&lt;/code&gt; 에 기재된 구조 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi이&lt;/a&gt; 엔진은 됨으로써 채워. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 문자열 화와 같은 것을 구현하기 위해 perl이 사용하고 일부 필드를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">코드 포맷에 대한 두 가지 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">내가 생각할 수있는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">Perl 5.10에서 영구 개인 변수를 작성하는 방법에는 두 가지가 있습니다. 먼저 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 기능을 간단히 사용할 수 있습니다 . 또는 5.10 이전 릴리스와의 호환성을 유지하려면 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">AV를 작성하고로드하는 방법에는 두 가지가 있습니다. 첫 번째 방법은 빈 AV를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">정규식에 대한 디버깅 출력을 활성화하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; pragma를 암시 적 으로로드하는 두 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">Perl에서 Cocoa를 사용하는 방법은 두 가지가 있습니다. Mac OS X에 포함 된 Apple PerlObjCBridge 모듈은 독립형 스크립트에서 Foundation (예 : 비 GUI) 클래스 및 객체에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">의심 할 여지없이 코드에 어딘가에 숨어있는 심각한 버그가 있습니다 :-) 버그 보고서 및 기타 피드백은 가장 환영합니다.</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">이 코드의 어딘가에 숨어있는 버그는 의심 할 여지없이, 그 일부만 실제보다 Perl에 대해 많은 것을 이해하고 있다는 인상을주기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">이 주제에는 유용한 변형이 있습니다. &lt;code&gt;!~&lt;/code&gt; 연산자를 사용하여 일치를 반전시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">가능한 각 값에 대해 일반적으로 여러 동의어가 있습니다. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 를 사용 하여 액세스 하십시오 .</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">일반적으로 3 개 또는 4 개의 간격 타이머 (신호)를 사용할 수 있습니다. &lt;code&gt;$which&lt;/code&gt; 은 &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; 또는 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; 일 수 있습니다 . 사용 가능한 플랫폼은 다음과 같습니다. 실제 UNIX 플랫폼에는 일반적으로 처음 세 개가 있지만 Solaris에만 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (멀티 스레드 프로그램을 프로파일 링하는 데 사용됨)가있는 것 같습니다 . 불행히도 Win32에는 간격 타이머가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">이 라인을 따라 최적화를 촉진하는 데 사용할 수있는 패턴의 다양한 측면이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">SunOS 4.1.4 및 gcc 3.2.2에서 gcc 버그와 매우 유사하게 나타나는 여러 가지 다른 오류가 있습니다. 많은 실패는 Encode 테스트에서 발생합니다. 예를 들어 테스트에서 &quot;0&quot;이 예상되면 &quot;&amp;amp; # 48;&quot;이 표시됩니다. 약간 곁눈질 후 정말 이상하게 보일 것입니다. 다른 예는 이전에</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">표에 나열된 이름 이외에도 사용할 수있는 다양한 동의어가 있습니다. 예를 들어, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; 는 &lt;code&gt;\p{Alpha}&lt;/code&gt; 로 쓸 수 있습니다 . 모두 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 특성 에 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">Perl을 표준 &quot;test&quot;대상과 약간 다르게 테스트하는 데 사용할 수있는 다양한 특수 make 대상이 있습니다. 그들 모두가 100 %의 성공률을 기대하지는 않습니다. 그들 중 다수는 여러 개의 별명을 가지고 있으며, 그들 중 일부는 특정 운영 체제에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">아래에 나열된 다양한 구문이 있습니다. 주어진 구문에서 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;section&lt;/code&gt; 은 '/'및 '|'문자를 포함 할 수 없습니다. '&amp;lt;'또는 '&amp;gt;'는 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">주의해야 할 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">개인 및 공개 플래그가 다른 여러 가지 방법이 있습니다. 예를 들어 perl 5.16 및 이전 버전에서는 연결된 SV가 IV 슬롯에서 유효한 기본 값을 가질 수 있지만 (SvIOKp는 true 임) 데이터는 직접이 아닌 FETCH 루틴을 통해 액세스해야하므로 SvIOK는 false입니다. (perl 5.18 이후에는 묶인 스칼라가 묶이지 않은 스칼라와 같은 방식으로 플래그를 사용합니다.) 또 하나는 숫자 변환이 발생하고 정밀도가 손실 된 경우입니다. 개인 플래그 만 '손실'값으로 설정됩니다. 따라서 NV가 손실로 IV로 변환되면 SvIOKp, SvNOKp 및 SvNOK가 설정되지만 SvIOK는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">메일 링리스트의 웹 아카이브는 다음에 있습니다.</target>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">일부 로캘 이름에 &quot;UTF-8&quot;문자열이 포함되어 있어도 현재 실제 UTF-8 로캘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 을 인용 문자로 사용하는 경우를 제외하고 연산자와 인용 문자 사이에 공백이있을 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; 는 문자열 &lt;code&gt;foo&lt;/code&gt; 로 구문 분석되는 반면 &lt;code&gt;q #foo#&lt;/code&gt; 는 연산자 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 와 주석이 뒤 따릅니다. 그 주장은 다음 줄에서 가져옵니다. 이것은 당신이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot;줄 의 시작 부분에 공백이 없어도 되지만 가독성을 향상시키는 데 유용합니다. 해당 줄의 끝에 세미콜론을 두는 것도 선택 사항입니다. 임의의 양과 종류의 공백은 &quot; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &quot;와 &quot; &lt;code&gt;input&lt;/code&gt; &quot; 사이에 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">ILE 환경에 대한 Perl 포트가 있습니다. 그러나이 포트는 Perl 5.00502 (1998 년 8 월)의 이전 릴리스를 기반으로합니다. (2002 년 7 월 현재 Perl의 최신 릴리스는 5.8.0이며, 심지어 5.6.1도 2001 년 4 월 이후 출시되었습니다.) ILE에서 Perl을 실행해야하는 경우이 이전 포트가 필요할 수 있습니다. &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http : // www.cpan.org/ports/#os400 5.00502&lt;/a&gt; 이후의 Perl 릴리스는 ILE로 포팅되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">BS2000에 대한 hints.posix-bc라는 이름의 &quot;힌트&quot;파일이 있습니다 (posix-bc는`uname`에 의해 주어진 OS 이름이기 때문에). 대부분의 것들에 대한 올바른 값을 지정합니다. 가장 큰 문제는 (물론) EBCDIC 문자 세트입니다. 우리는 독일어 EBCDIC 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">어떤 종류의 물건을 가로채는 지 궁금해하는 경우 $ diagnostics :: DEBUG 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">CPAN 모듈 인 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; 이 있으며 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (또는 큰 따옴표로 묶인 문자열 인라인 버전 )에 사용할 고유 한 맵핑을 정의 할 수 있습니다. &lt;code&gt;\U&lt;/code&gt; 와 같은 ). (Perl 5.16 이전에는이 ​​기능이 Perl 코어에서 부분적으로 제공되었지만 여러 가지 극복 할 수없는 단점이 있었으므로 대신 CPAN 모듈이 작성되었습니다.)</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">CPAN에는 Clone 모듈이 있으며 기본적으로 딥 클로닝을 구현합니다. 즉, 메모리를 정지시키고 결과를 해동하지 않습니다. 언젠가 Storable의 dclone ()을 대체하는 것이 목표입니다. 그러나 현재 심층 복제가 수행되는 방식을 재정의하기 위해 Storable 후크를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">TrollTech의 Qt 툴킷에 대한 Perl 인터페이스가 있지만 유지되지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">perl5.6.0에는 UV가&amp;gt; = 1 &amp;lt;&amp;lt; 31 인 버그가 있습니다. dualvar.t의 테스트 8과 9가 실패로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Perl 커뮤니티를위한 중앙 디렉토리가 있습니다 : &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; Perl Foundation ( &lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt; )은 다양한 다른 커뮤니티 사이트를위한 서비스를 추적하고 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; 에는 XS 코드로 구현 된 클래스 메소드가 있습니다. 에 의해 호출되는 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 레이어를 확인하기 :</target>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">&quot;파일 확장자 연결&quot;이라는 기능이 있습니다. 이것은 Windows에서 표준으로 제공되는 &quot;assoc&quot;및 &quot;ftype&quot;두 명령을 통해 조작 할 수 있습니다. &quot;ftype /?&quot;를 입력하십시오. 펄 스크립트를 위해 이것을 설정하는 방법에 대한 완전한 예제를 위해 (무엇을 말합니까? 당신은 Windows가 펄-레디가 아니라고 생각 했습니까? :).</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">line 지시어에는 상당히 분명한 문제가 있습니다. 디버거와 프로파일 러는 주어진 파일의 특정 행 번호에 표시되는 마지막 소스 행만 표시합니다. 나중에 디버깅하려는 코드에서 줄 번호 충돌이 발생하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">Changes 파일에는 전체 버전 기록이 있으며 &lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList를&lt;/a&gt; 사용하여 코어로 포함 된 Test :: More 버전을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">프로그래머가 정보를 조회 할 수있는 기능적 프로그래밍 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">클로저가 아닌 익명 서브 (즉, 서브 이외의 어휘를 참조하지 않는 서브 스크립 션)와 관련하여 더 복잡한 문제가 있습니다. 이 경우 익명 프로토 타입이 복제되지 않고 공유됩니다. 이는 여전히 활동적인 자녀가있는 동안 부모가 해방 될 수있는 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">로케일 정의 모음은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">캐시 된 데이터 레코드 당 약 310 바이트, 오프셋 테이블 항목 당 약 21 바이트 인 각 레코드 오프셋 및 캐시 항목마다 메모리 오버 헤드가 큽니다.</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">&lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; 에서 사용 가능한 &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) 라는 lint 변형이 있으며 Unix 계열 플랫폼에서 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">텍스트가없는 플래그 된 줄 바로 위에 list &lt;code&gt;=item&lt;/code&gt; 이 있습니다. 빈 항목을 삭제하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">부분적인 해결 방법이 있습니다 (최신 OS / 2 커널로 완료 할 수 있음). 이전 Perl 버전의 DLL과 동일한 이름으로 전달자 DLL을 작성하여 진입 점을 새로운 Perl의 DLL로 전달합니다. 이 DLL을 새로운 Perl 실행 파일 의 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 에서 액세스 할 수있게 하십시오. 새 실행 파일이 이전 Perl의 확장 DLL에 액세스하면 이름으로 이전 Perl의 DLL을 요청하고 대신 전달자를 가져 오므로 현재 실행중인 (새) Perl DLL과 효과적으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">서명 및 프로토 타입 (참조 사이의 잠재적 인 구문 모호성이있다 &lt;a href=&quot;#Prototypes&quot;&gt;프로토 타입을&lt;/a&gt; 여는 괄호로 시작하고 둘 모두는 단지 서브 루틴 선언의 이름 뒤에 같은 장소의 일부에 표시 할 수 있기 때문에). 역사적 이유로 서명을 사용하지 않으면 이러한 컨텍스트에서 여는 괄호는 매우 관대 한 프로토 타입 구문 분석을 트리거합니다. 이러한 상황에서는 대부분의 서명이 프로토 타입으로 해석되지만 유효한 프로토 타입은 아닙니다. (유효한 프로토 타입에는 알파벳 문자가 포함될 수 없습니다.) 다소 혼란스러운 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">각 클래스가 동일한 이름의 역할이 있음을 의미하므로 역할과 클래스 사이에는 관계가 있습니다. 상속 클래스와 역할 사이에는 관계가 있습니다. 상위 클래스에서 상속하는 서브 클래스가 부모가 수행하는 모든 역할을 암시 적으로 수행한다는 점입니다. 따라서 당신은 사용할 수 &lt;code&gt;DOES&lt;/code&gt; 대신 &lt;code&gt;isa&lt;/code&gt; 는 모든 장소에 true를 돌려줍니다으로 안전하게 &lt;code&gt;isa&lt;/code&gt; 재정의 한 모든 것을 제공 (true를 돌려줍니다 &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; 네임 스페이스 아래 CPAN 에는 풍부한 &lt;code&gt;Moose&lt;/code&gt; 확장 에코 시스템이 있습니다. 또한 CPAN의 많은 모듈은 이미 &lt;code&gt;Moose&lt;/code&gt; 를 사용 하여 배울 수있는 많은 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">L &amp;lt;...&amp;gt;의 페이지 이름에서 섹션이 발견되었습니다 &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 예 : L &amp;lt;passwd (2)&amp;gt;) . POD 하이퍼 링크는 POD 문서 만 가리킬 수 있습니다. 빠른 시간 내에 연락 드릴 것입니다 &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 대신. 일부 포맷터는이를 적절한 코드로 확장 할 수 있습니다. (내장) 함수에 대한 링크는 () 없이 &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; 이라고 말하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 패키지에 존재하는 항목을 보유하는 &lt;code&gt;PL_defstash&lt;/code&gt; 라는 단일 숨김 이 있습니다 . 다른 패키지의 항목을 얻으려면 패키지 이름에 &quot;::&quot;문자열을 추가하십시오. &lt;code&gt;Foo&lt;/code&gt; 패키지 의 항목은 PL_defstash 의 숨김 &lt;code&gt;Foo::&lt;/code&gt; 에 있습니다. &lt;code&gt;Bar::Baz&lt;/code&gt; 패키지 의 항목 은 숨김 &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 의 숨김에 있습니다.</target>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">이 구조에는 &lt;code&gt;\K&lt;/code&gt; (Perl 5.10.0부터 사용 가능) 라는 특수한 형태가 있는데 , 이로 인해 정규식 엔진은 &lt;code&gt;\K&lt;/code&gt; 이전에 일치했던 모든 것을 &quot;유지&quot; 하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함시키지 않습니다 . 이것은 효과적으로 가변 길이 룩-비하인드를 제공합니다. 다른 둘러보기 어설 션 내 에서 &lt;code&gt;\K&lt;/code&gt; 사용할 수 있지만 동작은 현재 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">/usr/include/sys/socket.h 헤더 파일에 IBM이 USS V2R7, V2R8 및 가능하면 V2R9를 제공하는 구문 오류가 있습니다. 헤더 파일의 문제점은 SO_REUSEPORT 상수의 정의 근처에 주석 외부에 가짜 여분의 '/'문자가 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">하나의 특정 유형의 컴퓨터를 최대한 활용하는 것과 전체 범위를 활용하는 것에는 상충 관계가 있습니다. 당연히 범위를 넓히고 다양 해짐에 따라 공통 요인이 줄어들고 특정 작업을 수행하기 위해 운영 할 수있는 점점 더 작은 공통 영역이 남아 있습니다. 따라서, 문제를 공격하기 시작할 때, 트레이드 오프 곡선의 어느 부분을 운영 할 것인지 고려해야합니다. 특히, 코딩하는 작업이 이식 가능한 일반성을 갖는 것이 중요한지 아니면 지금 당장 작업을 수행 할 것인지 결정해야합니다. 가장 어려운 선택입니다. Perl은 문제에 접근하기를 원하는 많은 방법을 제공하기 때문에 나머지는 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">이 모듈에는 명령 줄에서 편리하게 쿼리 할 수있는 &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; 라는 유틸리티가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 심볼릭 링크가 해결 된 파일의 절대 경로 이름을 보유하는 &lt;code&gt;$File::Find::fullname&lt;/code&gt; 변수가 있습니다 . 링크가 매달려있는 심볼릭 링크 인 경우 fullname은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">Perl API를 통해 C에서 유사한 작업을 수행하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">컴파일 가능한 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; 수정 가능한 전역을 완전히 숨기는 방법이 있습니다 (모두 힙으로 이동 됨) . 일반적으로 사용되지는 않지만 테스트에 사용될 수 있습니다 . &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;perlguts의 Background 및 PERL_IMPLICIT_CONTEXT에서 자세히 읽어보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">펄에게 정리를 완료하도록하는 방법이 있습니다 : 환경 변수 PERL_DESTRUCT_LEVEL을 0이 아닌 값으로 설정하십시오. t / TEST 래퍼는 이것을 2로 설정하고 &quot;글로벌 누출&quot;을보고 싶지 않다면 다음과 같이해야합니다. 예를 들어, valgrind에서 실행</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">확장명을 문서화하지 않은 것에 대한 변명은 없습니다. 문서는 .pm 파일에 속합니다. 이 파일은 pod2man에 제공되고 내장 된 설명서는 맨 페이지 형식으로 변환 된 다음 blib 디렉토리에 저장됩니다. 확장이 설치되면 Perl의 맨 페이지 디렉토리에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; 도 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 됩니다. 그것은 당신에게 큰 이성을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;HV&lt;/code&gt; 에 마법을 추가하는 기능도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; 일치하는 POSIX 문자 클래스를 나타내는 데 사용되는 더 큰 형식의 char 클래스 구조도 있습니다. &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; 은 POSIX 문자 클래스가 포함되어 있음을 나타내는 추가 32 비트 비트 맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">CPAN의 Tk 모듈과 함께 배포되는 Perl로 작성된 toyedit Text 위젯 기반 편집기도 있습니다. ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; )는 일종의 개발 환경으로 작동하는 Perl / Tk 기반 디버거입니다. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; )는 Perl / Tk GUI 작성을위한 IDE입니다.</target>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">호출 된 것과 다른 모듈에서 작성된 서브 루틴 내에서 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 를 사용할 때 가장 중요한 경우 가 있습니다. 복잡해 보이지만 실제로는 그렇지 않습니다. 다음은 올바르게 작동하지 않는 예입니다.</target>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">원래 배포 파일이 보관되는 다른 디렉토리 ($ CPAN :: Config-&amp;gt; {keep_source_where})가 있습니다. 이 디렉토리는 캐쉬 관리 프로그램에서 다루지 않으며 사용자가 제어해야합니다. build_dir 및 keep_source_where 디렉토리와 동일한 디렉토리를 선택하면 동일한 fifo 메커니즘으로 소스가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">콜백이 종료 된 후 제어권을 다시 얻을 때마다 Perl이 자동으로 처리하도록하는 또 다른 방법이 있습니다. 이것은 단순히</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">간결성을 위해 명확성을 교환하는 또 다른 방법이 있습니다. INPUT 섹션에서는 서브 루틴의 매개 변수 목록에 나타나지 않는 C 변수를 선언 할 수 있습니다. 따라서 mutate ()에 대한 위의 코드는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">현재 표시되지 않은 텍스트를 적절하게 형식화하려는 추측을 끄는 방법은 없으며 때로는 POD를 사용하여 Perl 이외의 것을 문서화 할 때 원하지 않습니다. 그러나이 문제를 해결하기위한 대부분의 작업이 완료되었지만 여전히 필요한 것은 사용자 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">프로세스 크기에는 2GB 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">확장명과 함께 제공되는 &lt;code&gt;*.bs&lt;/code&gt; 파일 이 없습니다 . 대신 NeXT의 버클리 db에 대한 posix와 같은 특수한 경우에 대한 코드 가있는 &lt;code&gt;*_BS&lt;/code&gt; 파일이 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 기능 이 없습니다 . 이를 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 기능 이 없습니다 . 이를 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">BNF는 없지만 특히 용감한 경우 소스 배포판에서 perly.y의 yacc 문법을 사용할 수 있습니다. 문법은 매우 똑똑한 토큰 화 코드에 의존하므로 toke.c로도 활용할 수 있도록 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; 토큰 다음에 _always_가 호출되는 서브 루틴을 배치 할 경우 이점이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">내장 된 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 이 없습니다 . 이름을 다른 모듈로 내보내려는 모듈에 의해 정의되거나 상속되는 일반적인 방법 (서브 루틴)입니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 기능은 호출 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 사용되는 패키지 방법을. &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">내장 된 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 이 없습니다 . 이름을 다른 모듈로 내보내려는 모듈에 의해 정의되거나 상속되는 일반적인 방법 (서브 루틴)입니다. &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 기능은 호출 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 사용되는 패키지 방법을. &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">&quot;이것을 페이지의 오른쪽에 띄우지 만 넓게&quot;라고 말하는 내장 된 방법은 없습니다. 어디로 가야하는지 지정해야합니다. 진정으로 필사자는 현재 열 수에 따라 자체 형식을 즉석에서 생성 한 다음 eval () 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">Perl에서 C로 전달 된 파일 핸들이 올바른 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 모드 로 작성되었는지 확인하는 점검은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">압축 된 데이터 스트림 바로 뒤에는 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">암호 해독 기능이 없습니다. 이 기능이 암호화에 유용한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">대부분의 비 Perl 정의 속성에 대한 설명은 없습니다 ( &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perl에는 이중 보간이 없으므로 &lt;code&gt;$100&lt;/code&gt; 은 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">tarball은 많은 파일을 포함 할 수 있고 각 파일은 다른 방식으로 인코딩 될 수 있기 때문에 &lt;code&gt;Archive::Tar&lt;/code&gt; 에서이 기능을 제공하는 쉬운 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">실제로는 이것이 필요하지 않기 때문에 목록 컨텍스트에서 표현식을 보간하는 동등한 연산자가 없습니다. 그러나 실제로 그렇게하고 싶다면 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; 구성을 사용할 수 있지만 일반적으로 간단한 &lt;code&gt;(some expression)&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; 과 동등한 것은 없습니다 . 대신 &lt;code&gt;sv_gets&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">방화벽이 없습니다</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">이 모든 것에 대한 일반적인 해결책은 없습니다. 엉망입니다.</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">이 모든 것에 대한 일반적인 해결책은 없습니다. 그냥 엉망입니다.</target>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">정의 된 OR에 대해서는 우선 순위가 낮은 연산자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; 에서 상속 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">모든 플랫폼에서 사용 가능한 DBM 모듈이 하나도 없습니다. &lt;code&gt;SDBM_File&lt;/code&gt; 및 기타는 일반적으로 모든 Unix 및 DOSish 포트에서 사용할 수 있지만 &lt;code&gt;NDBM_File&lt;/code&gt; 및 &lt;code&gt;DB_File&lt;/code&gt; 만 사용할 수있는 MacPerl 에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">수량 자 &lt;code&gt;{,n}&lt;/code&gt; 이 없습니다 . 이것은 리터럴 문자열로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">Perl을 Unix 도구를 함께 붙이거나 Macintosh 응용 프로그램을 프로토 타입하거나 Windows 레지스트리를 관리하기위한 언어로 사용해서는 안됩니다. 주어진 프로그램에서 어떤 이유로 든 이식성을 목표로하는 것이 의미가 없다면, 귀찮게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">아무것도 변환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">set_layers ()도없고 get_layers ()도 스택을 미러링하는 묶인 배열 또는 그와 비슷한 멋진 것을 반환하지 않습니다. 우발적이거나 의도적이지 않습니다. PerlIO 레이어 스택은 스택보다 조금 더 복잡합니다 (예 &lt;code&gt;:raw&lt;/code&gt; 동작 참조 ). 스택을 조작하려면 open () 및 binmode ()를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">메타 문자를 처리 할 쉘이 없으며 기본 표준은 &quot;\ n&quot; &quot;\ r&quot;또는 &quot;\ 0&quot;으로 끝나는 명령 줄을 생성 된 프로그램에 전달하는 것입니다. &lt;code&gt;&amp;gt; foo&lt;/code&gt; 와 같은 리디렉션 은 생성 된 프로그램의 런타임 라이브러리에 의해 수행됩니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">컴파일 시간과 런타임 클래스 생성간에 속도가 크게 향상되지 않으며 새로운 표준 이벤트 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">이 질문에 대한 간단한 대답은 없습니다. Perl 프레임 워크는 기본 파일 서버 및 소규모 인트라넷에서 국제 비즈니스의 핵심 인 대규모 다국어 다국어 웹 사이트에 이르기까지 모든 것을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">printf ()의 제한된 인텔리전스 때문에 이에 대한 간단한 해결책은 없지만 많은 유형의 경우 'f'또는 '_f'접미사와 같이 올바른 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">WPS 개체에 액세스하는 간단한 방법은 없습니다. 내가 아는 유일한 방법은 &lt;code&gt;OS2::REXX&lt;/code&gt; 및 &lt;code&gt;SOM&lt;/code&gt; 확장을 통하는 것입니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM 참조&lt;/a&gt; ). 그러나 Object-REXX의 편리한 방법에는 액세스 할 수 없습니다. (물론 가능합니까? Object-REXX API를 아는 것은 없습니다.) &lt;code&gt;SOM&lt;/code&gt; 확장 (현재 알파 텍스트)은 결국이 단점을 제거 할 수 있습니다. 그러나, DII가 지원되지 않는다는 사실 때문에 &lt;code&gt;SOM&lt;/code&gt; 의 사용, 모듈 &lt;code&gt;SOM&lt;/code&gt; 은 사람이 그것을 원하는만큼 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">Perl에는 특별한 클래스 구문이 없지만 패키지가 서브 루틴을 제공하여 메소드로 작동하는 경우 패키지는 클래스로 작동 할 수 있습니다. 이러한 패키지는 또한 전역 @ISA 배열 (어휘가 아니라 패키지 전역이어야 함)에 다른 패키지 이름을 나열하여 다른 클래스 (패키지)에서 일부 메소드를 파생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS의 Perl에 대한 특정 메일 링리스트는 없습니다. 해당 지역의 Stratus Technologies 고객 지원 센터 (CAC)에 문의하거나 Stratus Anonymous FTP 사이트의 배포 파일에있는 연락처 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; 명령 뒤에 포매터의 스펙이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">실수에 대한 네트워크 표현과 같은 것은 없으므로 컴퓨터 경계를 통해 실수를 보내려면 16 진 부동 소수점 형식 (10 진수 변환 손실 방지)을 사용하여 텍스트 표현을 따르는 것이 좋습니다. '라인의 다른 쪽 끝에 무엇이 있는지 절대적으로 확신하십시오. 훨씬 더 모험적인 경우 이전 섹션의 바이트 순서 수정자를 부동 소수점 코드에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">현재 @ISA에 대한 지원은 없습니다. @ISA 설정과 'tie'를 구현하는 데 필요한 마법 항목 사이에는 잠재적 인 충돌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4에서는 동적으로 링크 된 라이브러리를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">ese ()는 어쨌든 tty와 같은 장치 파일에서는 제대로 작동하지 않기 때문에 syseof () 함수는 없습니다. sysread ()를 사용하고 0에 대한 반환 값을 확인하여 완료 여부를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">Berlley DB 데이터베이스를 Perl 및 C 응용 프로그램에서 공유 할 수없는 기술적 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">인코딩을 자동으로 안정적으로 감지 할 수있는 방법이 없으므로 사람들이 문자셋 표시없이 데이터를 계속 보내면이를 교육해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize :: Expire에는 특별한 것이 없습니다. 단지 예일뿐입니다. 구현 한 정책이 마음에 들지 않으면 원하는 정책을 구현하는 고유 한 만료 정책 모듈을 자유롭게 작성할 수 있습니다. 방법은 다음과 같습니다. 모듈 이름이 MyExpirePolicy라고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">이제 &lt;code&gt;100&lt;/code&gt; 대신 과학 표기법 일명 &lt;code&gt;1e+2&lt;/code&gt; 의 문자열을 얻는 &lt;code&gt;bsstr()&lt;/code&gt; 메소드가 있습니다. 오버로드 된 'eq'는 항상 비교를 위해 bstr ()을 사용하지만 Perl은 일부 숫자를 100으로 나타내고 다른 숫자를 1e + 308로 나타냅니다. 확실하지 않은 경우 두 인수를 모두 문자열로 비교하기 전에 Math :: BigInt로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">물론 더 많은 것을 알 수 있습니다. 이것은 표면을 긁었습니다. 더 많은 것을 배우는 가장 좋은 방법은 perldoc을 사용하여 언어에 대한 자세한 정보를 찾고 온라인 도움말 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 가 다음에 나올 곳임 ) 을 읽고 실험하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">종종 의견과 취향의 문제가 있으며 모든 사람에게 맞는 답은 없습니다. 일반적으로 현재 안정 릴리스 또는 바로 이전 릴리스를 사용하려고합니다. 현재는 각각 perl5.18.x 및 perl5.16.x입니다.</target>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">INSTALL_BASE에는 하나의 경고가 있습니다. 이전 버전의 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker가&lt;/a&gt; 주장한 PREFIX 및 LIB 설정과 다르게 작동하기 때문입니다 . INSTALL_BASE는 동일한 디렉토리에 여러 버전의 Perl 또는 다른 아키텍처에 대한 모듈 설치를 지원하지 않습니다. 실제로 원하는지 여부를 고려해야하며, 원하는 경우 이전 PREFIX 및 LIB 설정을 사용하십시오. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">이 모든 것에는 한 가지 예외가 있습니다. &lt;code&gt;\p{All}&lt;/code&gt; 은 유니 코드 속성처럼 보이지만 가능한 모든 코드 포인트에 대해 유니 코드의 유무에 관계없이 Perl 확장자이므로 유니 코드가 아닌 코드 포인트와 비교할 때 경고가 생성되지 않습니다. (v5.20 이전에는 &lt;code&gt;\p{Any}&lt;/code&gt; 와 동의어로 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;0x10FFFF&lt;/code&gt; 까지의 코드 포인트와 일치했습니다 .)</target>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">이 규칙에는 한 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">한 가지 예외가 있으며, $ x가 음수 인 기본 2입니다.</target>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">한 가지 예외가 있습니다. 영숫자 문자를 패턴의 구분자로 사용하는 경우 (가독성을 위해하지 말아야 할) 구분 기호를 일치 시키려면 구분자를 이스케이프해야합니다. 펄은 그때 경고하지 않습니다. &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;인용 된 구문을 구문 분석하는 perry의 Gory 세부 사항&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">약간의 차이점이 있습니다. &lt;code&gt;for&lt;/code&gt; 의 초기화 섹션에서 변수를 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언하면 해당 변수 의 어휘 범위는 정확히 &lt;code&gt;for&lt;/code&gt; 루프 (루프 본문과 제어 섹션)입니다.</target>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">사이의 작은 차이가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : 전자는 변수와 일부 기능의 반환 값을 할당에 영향을 미치지 않습니다. &lt;code&gt;bigint&lt;/code&gt; 는 이 결과도 정수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">다음 진술 사이에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">단항 연산자는 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">단일 &lt;code&gt;%^H&lt;/code&gt; 만 있지만 범위 지정 의미론을 사용하려는 임의의 많은 모듈이 있습니다. 서로 발가락을 밟지 않으려면 해시에서 다른 키를 사용해야합니다. 따라서 모듈은 모듈 이름 (기본 패키지 이름)과 &quot;/&quot;문자로 시작하는 키만 사용하는 것이 일반적입니다. 이 모듈 식별 접두사 다음에 나머지 키는 전적으로 모듈에 달려 있습니다. 모든 문자를 포함 할 수 있습니다. 예를 들어, &lt;code&gt;Foo::Bar&lt;/code&gt; 모듈 은 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 및 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 와 같은 키를 사용해야합니다 ! . 이 규칙을 따르는 모듈은 모두 서로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">Perdio와 stdio의 공존에 대한 개요 지원이 있습니다. 분명히 PerlIO가 stdio의 관점에서 구현된다면 아무런 문제가 없습니다. 그러나 다른 경우에는 stdio 호출을 사용하는 라이브러리 코드로 전달 될 수있는 FILE *을 작성하는 메커니즘이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">&quot;regexp&quot;또는 &quot;regex&quot;를 말할지에 대한 논쟁이 있습니다. 이 문서에서는 특별한 이유가없는 한 &quot;regex&quot;라는 용어를 사용합니다.이 경우 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">스레드 펄에서 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 작동 하는 방식에 문제가있을 수 있습니다 . 아마도 어휘 범위가 &lt;code&gt;@_&lt;/code&gt; 때문일 수 있습니다. 이것은 Perl의 버그이며, 해결 될 때까지 메모 화 된 함수는 약간 다른 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 보게되고 스레드되지 않은 perls보다 스레드 된 perls에서 약간 느리게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">빈 줄에 공백이 있습니다. POD는 그러한 것에 매우 민감하므로 플래그가 지정되어 있습니다. &lt;b&gt;vi&lt;/b&gt; 사용자는 이 문제를 피하기 위해 &lt;b&gt;목록&lt;/b&gt; 옵션을 켭니다 .</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">아직 API에서 지원하지 않는 부분이 많이 있습니다</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">신호가 완료되기 전에 시스템 수준 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 작업을 중단 할 가능성은 여전히 ​​이론적으로 낮습니다 . 버퍼가 비어 있어도 일부 STDIO 구현에서 여러 시스템 레벨 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 호출 할 수도 있습니다 . 이 확률이 0으로 감소 된 일부 시스템이있을 수 있으며 이는 시스템의 STDIO 대신 &lt;code&gt;:perlio&lt;/code&gt; 를 사용할 때 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">주어진 regnode의 &quot;다음 regnode&quot;가 있습니다. 때로는 값이 다른 것 중 하나와 일치한다는 점을 제외하고는 거의 유용하지 않은 값이며, 때로는 코드가 항상 그렇게하는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">주어진 regop / regnode의 &quot;다음 regop&quot;이 있습니다. 이것은 현재 regop의 크기에 의해 결정된대로 현재 regop 다음에 실제로 위치한 regop입니다. 구조를 덤프 할 때와 같이이 순서를 사용하여 트래버스하는 경우와 같이 종종 유용합니다. 때때로 코드는 &quot;다음 regnode&quot;가 &quot;다음 regop&quot;과 동일하다고 가정하거나, 즉 주어진 regop 유형의 크기가 항상 하나의 regnode 크기라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">주어진 regop의 &quot;regnext&quot;가 있습니다. 이것은 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 값만큼 앞으로 점프 하거나, 몇몇 경우 에는 &lt;code&gt;regnode_1&lt;/code&gt; 구조 의 &lt;code&gt;arg1&lt;/code&gt; 필드에 의한 더 긴 점프 를 위해 도달 하는 regop 입니다. 서브 루틴 &lt;code&gt;regnext()&lt;/code&gt; 는 이것을 투명하게 처리합니다. 이것은 노드의 논리적 후계자이며, 일부 경우 &lt;code&gt;BRANCH&lt;/code&gt; 레고 와 마찬가지로 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d7e93b59e1cec82fb52bcc021241febda0271114" translate="yes" xml:space="preserve">
          <source>There is unfortunately no way to know whether the current emulator supports more than eight colors, which makes the choice of colors difficult. The most conservative choice is to use only the regular colors, which are at least displayed on all emulators. However, they will appear dark in sixteen-color terminal emulators, including most common emulators in UNIX X environments. If you know the display is one of those emulators, you may wish to use the bright variants instead. Even better, offer the user a way to configure the colors for a given application to fit their terminal emulator.</source>
          <target state="translated">불행히도 현재 에뮬레이터가 8 개 이상의 색상을 지원하는지 여부를 알 수있는 방법이 없으므로 색상 선택이 어렵습니다. 가장 보수적 인 선택은 최소한 모든 에뮬레이터에 표시되는 일반 색상 만 사용하는 것입니다. 그러나 UNIX X 환경에서 가장 일반적인 에뮬레이터를 포함하여 16 색 터미널 에뮬레이터에서는 어둡게 나타납니다. 디스플레이가 해당 에뮬레이터 중 하나 인 경우 밝은 변형을 대신 사용할 수 있습니다. 더 나은 방법은 사용자에게 터미널 에뮬레이터에 맞게 주어진 응용 프로그램의 색상을 구성 할 수있는 방법을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="695fd95569c58aad4ef775aef68eb765f2b01d11" translate="yes" xml:space="preserve">
          <source>There is whitespace at the beginning or the end of the contents of L&amp;lt;...&amp;gt;.</source>
          <target state="translated">L &amp;lt;...&amp;gt;의 내용의 시작 또는 끝에 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a3b67169b42d8576a9c6b1e3142c83d233d818" translate="yes" xml:space="preserve">
          <source>There is/was a minor twist which makes this scheme fragile: what to do with DLLs loaded from</source>
          <target state="translated">이 구성표를 취약하게 만드는 약간의 왜곡이 있습니다 :에서로드 된 DLL로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="3224e59e3b76dce8e510a893a97e615a7718acdb" translate="yes" xml:space="preserve">
          <source>There may be a few system-dependent issues of concern to EBCDIC Perl programmers.</source>
          <target state="translated">EBCDIC Perl 프로그래머에게는 몇 가지 시스템 종속 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74512965a00a9ef27998a0f76a590e7ca4e44a5a" translate="yes" xml:space="preserve">
          <source>There may be a slight performance decrease in the filetest operations when the filetest pragma is in effect, because checking bits is very cheap.</source>
          <target state="translated">비트 검사가 매우 저렴하기 때문에 filetest pragma가 적용되는 경우 filetest 작업의 성능이 약간 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5aefd712f7c17e18d56a8092421c803470327d8" translate="yes" xml:space="preserve">
          <source>There may be several other functions that have undefined behavior so this list shouldn't be considered complete.</source>
          <target state="translated">동작이 정의되지 않은 다른 함수가 여러 개있을 수 있으므로이 목록을 완전한 것으로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8f2ee1e9e100e424daf008c17d87249cb596b7da" translate="yes" xml:space="preserve">
          <source>There might be padding bytes between the fields to align the fields - the bytes can be anything</source>
          <target state="translated">필드를 정렬하기 위해 필드 사이에 패딩 바이트가있을 수 있습니다. 바이트는 무엇이든 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8da2d0d0ae5db5c30555083a00bfa8e94e394bba" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overriden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt; , which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">이 긴 이중 구현에는 다양한 문제가있는 것 같습니다. Configure가이 끊어짐을 감지하면 긴 이중 지원이 비활성화됩니다. 이는 명시 적으로 오버라이드 (override) 할 수 있습니다 &lt;code&gt;-Duselongdouble&lt;/code&gt; (또는 &lt;code&gt;-Dusemorebits&lt;/code&gt; 모두 긴 두 배 및 64 개 비트 정수를 할 수 있습니다). Long doubles를 사용하기로 결정하면 대부분의 깨진 것들에 대해 Perl이 해결 방법을 구현했지만 특수 값 무한대 및 NaN의 처리는 나쁘게 유지됩니다. 예를 들어 무한대 + 0은 NaN을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="0335b463034771ce67a8d72b65b51f2c22f06a51" translate="yes" xml:space="preserve">
          <source>There seems to be a broken system header file in HP-UX 11.00 that breaks perl building in 32bit mode with GNU gcc-4.x causing this error. The same file for HP-UX 11.11 (even though the file is older) does not show this failure, and has the correct definition, so the best fix is to patch the header to match:</source>
          <target state="translated">HP-UX 11.00의 시스템 헤더 파일이 손상되어 GNU gcc-4.x로 32 비트 모드에서 perl 빌드를 중단하면이 오류가 발생합니다. HP-UX 11.11의 동일한 파일 (이전 파일 임에도 불구하고)은이 오류를 표시하지 않으며 올바른 정의를 가지고 있으므로 일치하는 헤더를 패치하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="06ff19d7cd54ce39cc7fc4ec7d77ca64eb5bbd76" translate="yes" xml:space="preserve">
          <source>There should be a second &lt;code&gt;&quot;:&quot;&lt;/code&gt; , like this:</source>
          <target state="translated">다음 과 같이 두 번째 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f721ea1c84751a36c3521319fb047aa7a307e4e5" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt; , as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">라오스와 태국어 스크립트의 문자와 숫자를 조합하는 방법에 대한 표시가 없으므로 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 앞에 연산자가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4b586b7cb9ac2ab75263a6f83deec69bb4720e3" translate="yes" xml:space="preserve">
          <source>There should be no test failures.</source>
          <target state="translated">테스트 실패가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="6e7e045068e59967e564a49c6f93bb7b24be5931" translate="yes" xml:space="preserve">
          <source>There we're using the %USER_VARS hash instead of symbolic references. Sometimes this comes up in reading strings from the user with variable references and wanting to expand them to the values of your perl program's variables. This is also a bad idea because it conflates the program-addressable namespace and the user-addressable one. Instead of reading a string and expanding it to the actual contents of your program's own variables:</source>
          <target state="translated">거기에서 기호 참조 대신 % USER_VARS 해시를 사용하고 있습니다. 때로는 변수 참조가있는 사용자로부터 문자열을 읽고 펄 프로그램 변수의 값으로 확장하려고 할 때가 있습니다. 이것은 프로그램 주소 지정 가능 네임 스페이스와 사용자 주소 지정 가능 네임 스페이스를 혼동시키기 때문에 나쁜 생각입니다. 문자열을 읽고 프로그램 자체 변수의 실제 내용으로 확장하는 대신 :</target>
        </trans-unit>
        <trans-unit id="42ff6f078c663dbcc013a189f161b1005798db67" translate="yes" xml:space="preserve">
          <source>There were at least two consecutive &lt;code&gt;=begin&lt;/code&gt; commands without the corresponding &lt;code&gt;=end&lt;/code&gt; . Only one &lt;code&gt;=begin&lt;/code&gt; may be active at a time.</source>
          <target state="translated">해당 &lt;code&gt;=end&lt;/code&gt; 없이 적어도 두 개의 연속 &lt;code&gt;=begin&lt;/code&gt; 명령 이있었습니다 . 한 번에 하나의 &lt;code&gt;=begin&lt;/code&gt; 만 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f453a9d5941f2f68e4cfdb1b1ca5576cad8a3040" translate="yes" xml:space="preserve">
          <source>There were race conditions 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path의 &lt;code&gt;rmtree&lt;/code&gt; 함수 의 경쟁 조건 1.x 구현이있었습니다 (OS 배포 또는 플랫폼에 따라 때때로 패치되기도 함). 2.0 버전에는 CVE-2002-0435에 언급 된 문제를 피하기위한 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c41744f80fbb19ebe5f5b692cb01709180e04c" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in a handler because the system</source>
          <target state="translated">이것을 아는 것은 두 가지가 있습니다 : 편집증 또는 실용적. 편집증 접근법은 신호 처리기에서 가능한 한 적은 작업을 수행하는 것이 었습니다. 이미 값이있는 기존 정수 변수를 설정하고 반환합니다. 시스템 호출이 느리면 다시 시작하는 데 도움이되지 않습니다. 즉 , 처리기에서 longjmp (3) 로 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 합니다. 이 시스템조차도 처리기에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 것을 피하는 진정한 편집증 환자에게는 조금 무심 합니다.</target>
        </trans-unit>
        <trans-unit id="73d8966c11e67db894b509268c4964e23520f68e" translate="yes" xml:space="preserve">
          <source>There will be less network overhead (and some efficiency in your program) if you specify either the udp or the icmp protocol. The tcp protocol will generate 2.5 times or more traffic for each ping than either udp or icmp. If many hosts are pinged frequently, you may wish to implement a small wait (e.g. 25ms or more) between each ping to avoid flooding your network with packets.</source>
          <target state="translated">udp 또는 icmp 프로토콜을 지정하면 네트워크 오버 헤드 (및 프로그램의 효율성)가 줄어 듭니다. tcp 프로토콜은 uping 또는 icmp보다 각 핑에 대해 2.5 배 이상의 트래픽을 생성합니다. 많은 호스트가 ping을 자주하는 경우 네트워크에 패킷이 넘치지 않도록 각 핑 사이에 작은 대기 (예 : 25ms 이상)를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b418e4f885e0ed1944b1a75c443618ba49e064f" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s More Than One Way To Do It, the Perl Motto. The notion that there can be more than one valid path to solving a programming problem in context. (This doesn&amp;rsquo;t mean that more ways are always better or that all possible paths are equally desirable&amp;mdash;just that there need not be One True Way.)</source>
          <target state="translated">펄 좌우명은 여러 가지 방법이 있습니다. 문맥에서 프로그래밍 문제를 해결하기위한 하나 이상의 유효한 경로가있을 수 있다는 개념. (그렇다고해서 더 많은 방법이 항상 더 낫거나 모든 가능한 경로가 똑같이 바람직하다는 것은 아닙니다. 단 하나의 진정한 방법이 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="f28bb8331230709c36ed738881be6c54310d8343" translate="yes" xml:space="preserve">
          <source>There's More Than One Way to Do It</source>
          <target state="translated">여러 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="2d73bf3d5d8029a31c5c535e944915e019e3d9d2" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 가져온 의미를 가져 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 해당 선언이 없습니다 . 즉 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;unimport Module LIST&lt;/code&gt; 를 호출합니다 . &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 VERSION, 생략되거나 비어있는 LIST를 사용하거나 임포트 메소드를 찾을 수없는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="899206f410877415c07b1eae00900c686b6ba014" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 가져온 의미를 가져 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 해당 선언이 없습니다 . 즉 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;unimport Module LIST&lt;/code&gt; 를 호출합니다 . &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 VERSION, 생략되거나 비어있는 LIST를 사용하거나 임포트 메소드를 찾을 수없는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5182f679e917b06933e3121044c80451fb98d666" translate="yes" xml:space="preserve">
          <source>There's a couple of useful ones to know about straight away. You wouldn't think we're using any libraries at all at the moment, but '&lt;b&gt;M&lt;/b&gt;' will show which modules are currently loaded, and their version number, while '&lt;b&gt;m&lt;/b&gt;' will show the methods, and '&lt;b&gt;S&lt;/b&gt;' shows all subroutines (by pattern) as shown below. '&lt;b&gt;V&lt;/b&gt;' and '&lt;b&gt;X&lt;/b&gt;' show variables in the program by package scope and can be constrained by pattern.</source>
          <target state="translated">바로 알아야 할 유용한 정보가 몇 가지 있습니다. 우리는 현재 라이브러리를 전혀 사용하지 않을 것이라고 생각하지만 ' &lt;b&gt;M&lt;/b&gt; '은 현재로드 된 모듈과 버전 번호 를 표시하고 ' &lt;b&gt;m&lt;/b&gt; '은 메소드를 표시하고 ' &lt;b&gt;S&lt;/b&gt; '는 모든 서브 루틴을 표시합니다 (아래 그림과 같이) ' &lt;b&gt;V&lt;/b&gt; '및 ' &lt;b&gt;X&lt;/b&gt; '는 프로그램의 변수를 패키지 범위별로 표시하며 패턴으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18ae2cf96b3321649a9e67b52ce3c6b5c29a8066" translate="yes" xml:space="preserve">
          <source>There's a lot more to networking than this, but this should get you started.</source>
          <target state="translated">이것보다 네트워킹에 더 많은 것이 있지만, 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dfd5539590f938c8db0768ae08c09cb62cf9574" translate="yes" xml:space="preserve">
          <source>There's a lot to know about character sets, and text encodings. It's probably best to spend a full day learning all this, but the basics can be learned in minutes.</source>
          <target state="translated">문자 집합과 텍스트 인코딩에 대해 알아야 할 것이 많습니다. 하루 종일이 모든 것을 배우는 것이 가장 좋지만 기본 사항은 몇 분 안에 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ae85d03f4b582c99ff96216db7d59e44f17f54" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 문제가 있습니다. 생성 한 파이프의 읽기 끝 파일 번호를 반환하지만 다른 쪽 끝의 파일 번호를 검색 할 방법은 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 를 사용하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66cd02292a787335ff912b7d35685e3ae9e8fbc4" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 문제가 있습니다. 생성 한 파이프의 읽기 끝 파일 번호를 반환하지만 다른 쪽 끝의 파일 번호를 검색 할 방법은 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 를 사용하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e41e3a2378d95f98d33fb21414c6067f31a384cf" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt; : There are actually</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 의 후드에는 약간의 합병증 이 있습니다. 실제로</target>
        </trans-unit>
        <trans-unit id="5de903209b03670bb7672de0c3e9635cd117f5ca" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt; ) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">포장에 미묘한 함정이 숨어 있습니다. 단문 메시지 (변수 &lt;code&gt;$sm&lt;/code&gt; ) 후에 다른 필드를 추가하는 것은 괜찮습니다. 그러나 포장을 풀 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5136f0522d5206778ac4f88d48f4c827076f1a46" translate="yes" xml:space="preserve">
          <source>There's a wiki dedicated to the Test Anything Protocol:</source>
          <target state="translated">Test Anything Protocol 전용 Wiki가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b112374a474f8a64038b7df632984baece37394" translate="yes" xml:space="preserve">
          <source>There's also</source>
          <target state="translated">또한있다</target>
        </trans-unit>
        <trans-unit id="58a726895b66eba4d8724a2292f078a4d2648322" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File :: Tail&lt;/a&gt; 모듈도 있습니다.</target>
        </trans-unit>
        <trans-unit id="035e86078ae3280a54d8fc426b353c9ce230b2ad" translate="yes" xml:space="preserve">
          <source>There's also a negated version of it:</source>
          <target state="translated">그것의 부정 버전도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="194f92c1842e4ee102fc7a284b9e315ab368c04c" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt; :</source>
          <target state="translated">다음과 같은 &lt;code&gt;unless&lt;/code&gt; 하고 부정한 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce23f5592e874ac51b717997ee3d4abcaf17d1eb" translate="yes" xml:space="preserve">
          <source>There's an &lt;code&gt;unmemoize&lt;/code&gt; function that you can import if you want to. Why would you want to? Here's an example: Suppose you have your cache tied to a DBM file, and you want to make sure that the cache is written out to disk if someone interrupts the program. If the program exits normally, this will happen anyway, but if someone types control-C or something then the program will terminate immediately without synchronizing the database. So what you can do instead is</source>
          <target state="translated">원하는 경우 가져올 수 있는 &lt;code&gt;unmemoize&lt;/code&gt; 기능이 있습니다. 왜 하시겠습니까? 예를 들면 다음과 같습니다. 캐시가 DBM 파일에 연결되어 있고 누군가 프로그램을 중단 할 경우 캐시가 디스크에 기록되도록하려고한다고 가정하십시오. 프로그램이 정상적으로 종료되면 어쨌든 이런 일이 발생하지만 누군가 control-C 또는 무언가를 입력하면 데이터베이스를 동기화하지 않고 프로그램이 즉시 종료됩니다. 대신에 할 수있는 것은</target>
        </trans-unit>
        <trans-unit id="08ec3c4ec2591dd761c5a485e08fcf45d215a5be" translate="yes" xml:space="preserve">
          <source>There's an effort going on to document the internal functions and automatically produce reference manuals from them -- &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; is one such manual which details all the functions which are available to XS writers. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; is the autogenerated manual for the functions which are not part of the API and are supposedly for internal use only.</source>
          <target state="translated">내부 기능을 문서화하고 이들로부터 참조 매뉴얼을 자동으로 작성하려는 노력이 있습니다. &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 는 XS 라이터가 사용할 수있는 모든 기능을 자세히 설명하는 매뉴얼입니다. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; 은 API의 일부가 아니며 내부 용으로 만 사용되는 기능에 대한 자동 생성 매뉴얼입니다.</target>
        </trans-unit>
        <trans-unit id="b109c22c8125d5fbc051e5882994774c0628f7aa" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;). First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt; 에 이에 대한 예가 있습니다 . 먼저, 터미널을 &quot;에코 없음&quot;모드로 설정 한 다음 비밀번호를 정상적으로 읽으십시오. 이전 스타일의 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 함수, POSIX 터미널 제어 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 또는 해당 설명서 Camel Book 참조) 또는 &lt;b&gt;stty&lt;/b&gt; 프로그램 호출을 통해 다양한 수준의 이식성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1ee734c8b4d4a5b72b07450e993a31efdfcc81d2" translate="yes" xml:space="preserve">
          <source>There's an extraordinary number of people out there who don't appear to know anything about using the perl debugger, though they use the language every day. This is for them.</source>
          <target state="translated">perl 디버거 사용에 대해서는 아무것도 모르지만 매일 언어를 사용하는 사람은 많지 않습니다. 이것은 그들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e675dcb566e351efbc0e3f85ec7104c90a083d" translate="yes" xml:space="preserve">
          <source>There's currently only one class that has a stable interface - CPAN::Shell. All commands that are available in the CPAN shell are methods of the class CPAN::Shell. The arguments on the commandline are passed as arguments to the method.</source>
          <target state="translated">현재 안정적인 인터페이스를 가진 클래스는 CPAN :: Shell입니다. CPAN 쉘에서 사용 가능한 모든 명령은 CPAN :: Shell 클래스의 메소드입니다. 명령 행의 인수는 메소드에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f60d62cdc295d6cbdfb5f2a35e55c4e958719c10" translate="yes" xml:space="preserve">
          <source>There's even less need to distinguish between EBCDIC code pages, but to do so try looking at one or more of the characters that differ between them.</source>
          <target state="translated">EBCDIC 코드 페이지를 구별 할 필요는 없지만, 서로 다른 하나 이상의 문자를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="241fd51f25450a5ab0b7ec2c19699d2410027de0" translate="yes" xml:space="preserve">
          <source>There's no builtin way to do this, but &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; has a couple of techniques to make it possible for the intrepid hacker.</source>
          <target state="translated">이 작업을 수행하는 기본 방법 은 없지만 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 에는 대담한 해커가이를 가능하게하는 몇 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ace2a9bc7f6a90948438c072e0ce5f8cdc2b9bc" translate="yes" xml:space="preserve">
          <source>There's no feedback from this, but you can see what breakpoints are set by using the list 'L' command:</source>
          <target state="translated">이것에 대한 피드백은 없지만 list 'L'명령을 사용하여 어떤 중단 점을 설정했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f521ff0638ee964aa0ea31d64e9248f45119c41c" translate="yes" xml:space="preserve">
          <source>There's no solution for this problem other than making the custom engine understand a construct like &lt;code&gt;(?:)&lt;/code&gt;.</source>
          <target state="translated">커스텀 엔진이 &lt;code&gt;(?:)&lt;/code&gt; 와 같은 구문을 이해하게하는 것 외에는이 문제에 대한 해결책이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f42438ddafc8a1bac998273822622081c6567570" translate="yes" xml:space="preserve">
          <source>There's no strong security layer in CPAN.pm. CPAN.pm helps you to install foreign, unmasked, unsigned code on your machine. We compare to a checksum that comes from the net just as the distribution file itself. But we try to make it easy to add security on demand:</source>
          <target state="translated">CPAN.pm에는 강력한 보안 계층이 없습니다. CPAN.pm을 사용하면 시스템에 마스크되지 않은 서명되지 않은 외부 코드를 설치할 수 있습니다. 우리는 배포 파일 자체와 같이 그물에서 나오는 체크섬과 비교합니다. 그러나 요청시 보안을 쉽게 추가 할 수 있도록 노력합니다.</target>
        </trans-unit>
        <trans-unit id="794fc83a38998696363c5b95bfbda5c120c0de13" translate="yes" xml:space="preserve">
          <source>There's no way to tell if a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;U8 *&lt;/code&gt; string is UTF-8 or not. But you can tell if an SV is to be treated as UTF-8 by calling &lt;code&gt;DO_UTF8&lt;/code&gt; on it, after stringifying it with &lt;code&gt;SvPV&lt;/code&gt; or a similar macro. And, you can tell if SV is actually UTF-8 (even if it is not to be treated as such) by looking at its &lt;code&gt;SvUTF8&lt;/code&gt; flag (again after stringifying it). Don't forget to set the flag if something should be UTF-8. Treat the flag as part of the PV, even though it's not -- if you pass on the PV to somewhere, pass on the flag too.</source>
          <target state="translated">&lt;code&gt;char *&lt;/code&gt; 또는 &lt;code&gt;U8 *&lt;/code&gt; 문자열이 UTF-8 인지 여부를 알 수있는 방법이 없습니다. 그러나 &lt;code&gt;SvPV&lt;/code&gt; 또는 유사한 매크로를 사용 하여 SV_UTF8 을 문자열 화 한 후 &lt;code&gt;DO_UTF8&lt;/code&gt; 을 호출하여 SV를 UTF-8로 처리할지 알 수 있습니다 . 그리고 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 다시 확인하여 SV가 실제로 UTF-8인지 (그렇게 취급되지 않더라도) 알 수 있습니다 . UTF-8이어야하는 경우 플래그를 설정하는 것을 잊지 마십시오. PV가 아닌 경우에도 플래그를 PV의 일부로 취급하십시오. PV를 다른 곳으로 전달하는 경우 플래그도 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc25cfc8a3ec732d1d2283e554b506992b75eb5" translate="yes" xml:space="preserve">
          <source>There's not a single way to run code in the background so you don't have to wait for it to finish before your program moves on to other tasks. Process management depends on your particular operating system, and many of the techniques are covered in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">백그라운드에서 코드를 실행하는 단일 방법은 없으므로 프로그램이 다른 작업으로 이동하기 전에 코드가 끝날 때까지 기다릴 필요가 없습니다. 프로세스 관리는 특정 운영 체제에 따라 다르며 많은 기술이 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="d2aa5e3dbb927bd52349be7be623e623e64f5bf0" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">이제 .xs 파일에 추가 된 몇 가지 새로운 C 코드가 있습니다. &lt;code&gt;constant&lt;/code&gt; 루틴 의 목적은 헤더 파일에서 # define 's 값을 Perl 스크립트가 액세스 할 수있게하는 것입니다 ( &lt;code&gt;TESTVAL&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; 을 호출하여 ). &lt;code&gt;constant&lt;/code&gt; 루틴 에 대한 호출을 허용하는 XS 코드도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ac8386164e4284b824a87f18c211196212c066" translate="yes" xml:space="preserve">
          <source>There's one fine point I skipped. Line 5 is unnecessary, and we can get rid of it.</source>
          <target state="translated">건너 뛴 좋은 점이 하나 있습니다. 5 호선은 불필요하며 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f039a4fa9d9f10c8752271acf6c5252496665e47" translate="yes" xml:space="preserve">
          <source>There's one more item to add to this list. Do &lt;b&gt;not&lt;/b&gt; export variable names. Just because &lt;code&gt;Exporter&lt;/code&gt; lets you do that, it does not mean you should.</source>
          <target state="translated">이 목록에 추가 할 항목이 하나 더 있습니다. 마십시오 &lt;b&gt;하지&lt;/b&gt; 변수 이름을 내보낼 수 있습니다. 그냥 있기 때문에 &lt;code&gt;Exporter&lt;/code&gt; 당신이 작업을 수행 할 수 있습니다, 당신이해야 의미하지 않는다.</target>
        </trans-unit>
        <trans-unit id="23be60d3d8e40781087cd39d472decaae39f70d3" translate="yes" xml:space="preserve">
          <source>There, &quot;=shazbot&quot; will be parsed as a Pod command &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;. However, you can express a data paragraph consisting of &quot;=shazbot\n&quot; using this code:</source>
          <target state="translated">여기서 &quot;= shazbot&quot;은 데이터 단락 &quot;= shazbot \ n&quot;이 아닌 포드 명령 &quot;shazbot&quot;으로 구문 분석됩니다. 그러나이 코드를 사용하여 &quot;= shazbot \ n&quot;으로 구성된 데이터 단락을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d934ecae0b30d1837eb15a99e36faf1a189e093b" translate="yes" xml:space="preserve">
          <source>There, the &quot;=begin html&quot;...&quot;=end html&quot; region is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end :biblio&quot; region. Note that the content of the &quot;=begin html&quot;...&quot;=end html&quot; region is data paragraph(s), because the immediately containing region's identifier (&quot;html&quot;)</source>
          <target state="translated">&quot;= begin html&quot;... &quot;= end html&quot;영역은 더 큰 &quot;= begin : biblio&quot;... &quot;= end : biblio&quot;영역 안에 중첩됩니다. &quot;= begin html&quot;... &quot;= end html&quot;영역의 내용은 데이터 단락입니다. 왜냐하면 바로 영역의 식별자 ( &quot;html&quot;)를 포함하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4c11e16e3b4c4d1c6c6291b739425f3d103ebc32" translate="yes" xml:space="preserve">
          <source>Therefor, we recommend to only use &lt;code&gt;lynx&lt;/code&gt; as a last resort. This is why it is at the back of our list of methods to try as well.</source>
          <target state="translated">따라서 마지막 수단으로 &lt;code&gt;lynx&lt;/code&gt; 만 사용하는 것이 좋습니다 . 이것이 우리가 시도하는 방법 목록의 뒷면에있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="22f5648477726ba3de08027c1e14282ca2d62678" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; . Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">따라서 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 을 피하는 것이 가장 좋습니다 . 대신 &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; 및 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d0e80030071251142bc856e7654aae9ae473e69" translate="yes" xml:space="preserve">
          <source>Therefore we can use the &lt;code&gt;O_FILES&lt;/code&gt; variable to tell MakeMaker to use these objects into the shared library.</source>
          <target state="translated">따라서 &lt;code&gt;O_FILES&lt;/code&gt; 변수를 사용하여 MakeMaker 에게 이러한 객체를 공유 라이브러리로 사용하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc549460f9ec0f5ba049505f7c5226ae9e2f8140" translate="yes" xml:space="preserve">
          <source>Therefore, if you make changes to $ENV{TZ} from inside a thread other than the main thread then those changes will not be seen by strftime if you subsequently call that with the %Z formatting code. You must change $ENV{TZ} in the main thread to have the desired effect in this case (and you must also call _tzset() in the main thread to register the environment change).</source>
          <target state="translated">따라서 주 스레드 이외의 스레드 내부에서 $ ENV {TZ}를 변경하면 이후에 % Z 형식화 코드로 호출하면 strftime에 해당 변경 사항이 표시되지 않습니다. 이 경우 원하는 효과를 주려면 주 스레드에서 $ ENV {TZ}를 변경해야하며 환경 변경을 등록하려면 주 스레드에서 _tzset ()을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9f8fba915c890e8c346b81a259121ea682217ff" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">따라서 모든 버전의 Perl에서 스크립트를 실행할 수있게하려면 자동 닫기에 의존하지 말고 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b60bd02288d8270eaef5b4fd58dd4835333cea91" translate="yes" xml:space="preserve">
          <source>Therefore, populate such variables &lt;b&gt;after&lt;/b&gt; declaring them as shared. (Scalar and scalar refs are not affected by this problem.)</source>
          <target state="translated">따라서 이러한 변수 를 공유 &lt;b&gt;된 것으로&lt;/b&gt; 선언 &lt;b&gt;한 후 채&lt;/b&gt; 웁니다 . 스칼라 및 스칼라 참조는이 문제의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd4c5f1975f02e1f013464b5926b49a349d976cd" translate="yes" xml:space="preserve">
          <source>Therefore, recursion should normally be avoided, but is nonetheless supported.</source>
          <target state="translated">따라서 재귀는 일반적으로 피해야하지만 그럼에도 불구하고 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db068f38c67a6942c06b6242bd31cfce066e66c2" translate="yes" xml:space="preserve">
          <source>Therefore, when both -f and -t are omitted, &lt;b&gt;piconv&lt;/b&gt; just acts like &lt;b&gt;cat&lt;/b&gt;.</source>
          <target state="translated">따라서 -f와 -t를 모두 생략하면 &lt;b&gt;piconv&lt;/b&gt; 는 &lt;b&gt;cat&lt;/b&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="2f61899aa2182fe38363f4a728d368f7dbd80080" translate="yes" xml:space="preserve">
          <source>Therefore, when serializing hooks are involved,</source>
          <target state="translated">따라서 직렬화 후크가 관련된 경우</target>
        </trans-unit>
        <trans-unit id="c563bb79b9bbcc9436e0f964c49bd1fc0638d285" translate="yes" xml:space="preserve">
          <source>These #vars represent opcode properties that you may want as part of your rendering. The '#' is intended as a private sigil; a #var's value is interpolated into the style-line, much like &quot;read $this&quot;.</source>
          <target state="translated">이러한 #var은 렌더링의 일부로 원하는 opcode 속성을 나타냅니다. '#'은 개인시길로 사용됩니다. #var의 값은 &quot;read $ this&quot;와 같이 스타일 라인에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="8f188e4230a9960392a0f6434bcd9cdb687b2105" translate="yes" xml:space="preserve">
          <source>These actually run the tests, analogous to the functions in Test::More.</source>
          <target state="translated">실제로 Test :: More의 기능과 유사한 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="47b609b8bdbe47393836decca9fbf56107eb37fe" translate="yes" xml:space="preserve">
          <source>These all match a single codepoint with the given property. Use &lt;code&gt;\P&lt;/code&gt; in place of &lt;code&gt;\p&lt;/code&gt; to match one codepoint lacking that property.</source>
          <target state="translated">이것들은 모두 주어진 속성과 단일 코드 포인트와 일치합니다. 해당 속성이없는 하나의 코드 포인트와 일치 시키려면 &lt;code&gt;\p&lt;/code&gt; 대신 &lt;code&gt;\P&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14b0e821748bdb374700b2c0b377f04dafebe4c2" translate="yes" xml:space="preserve">
          <source>These all might have problems handling infinity right.</source>
          <target state="translated">이것들은 모두 무한대를 올바르게 처리하는 데 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f193401280223b6d90ef40113a3483800172634b" translate="yes" xml:space="preserve">
          <source>These are Locale::Maketext's assumptions about the class hierarchy formed by all your language classes:</source>
          <target state="translated">다음은 모든 언어 클래스에 의해 형성된 클래스 계층 구조에 대한 Locale :: Maketext의 가정입니다.</target>
        </trans-unit>
        <trans-unit id="7d93f149b189abdf70833601535a585584795222" translate="yes" xml:space="preserve">
          <source>These are Perl bindings for the Gtk toolkit ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; ). The interface changed significantly between versions 1 and 2 so they have separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently it requires an X server on Mac OS, but a 'native' port is underway), and the widgets look the same on every platform: i.e., they don't match the native widgets. As with Wx, the Perl bindings follow the C API closely, and the documentation requires you to read the C documentation to understand it.</source>
          <target state="translated">Gtk 툴킷 ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; )에 대한 Perl 바인딩입니다 . 인터페이스는 버전 1과 2 사이에서 크게 변경되었으므로 별도의 Perl 모듈이 있습니다. Unix, Win32 및 Mac OS X에서 실행되며 (현재 Mac OS에서 X 서버가 필요하지만 '기본'포트가 진행 중입니다) 위젯은 모든 플랫폼에서 동일하게 보입니다. 즉, 기본 플랫폼과 일치하지 않습니다. 위젯. Wx와 마찬가지로 Perl 바인딩은 C API를 밀접하게 따르므로 설명서를 이해하려면 C 설명서를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="06cca08d46609adb849cad691c3d195ff57274e9" translate="yes" xml:space="preserve">
          <source>These are a few notes describing features peculiar to Plan 9 Perl. As such, it is not intended to be a replacement for the rest of the Perl 5 documentation (which is both copious and excellent). If you have any questions to which you can't find answers in these man pages, contact Luther Huffman at lutherh@stratcom.com and we'll try to answer them.</source>
          <target state="translated">다음은 Plan 9 Perl 특유의 기능을 설명하는 몇 가지 참고 사항입니다. 따라서이 문서는 나머지 Perl 5 문서를 대체하기위한 것이 아닙니다 (이 문서는 풍부하고 훌륭합니다). 이 매뉴얼 페이지에서 답변을 찾을 수없는 질문이있는 경우 lutherhuffman (lutherh@stratcom.com)에 문의하면 답변을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="035e487505e2bd7d2a574e14eebe3b30a69fa1a9" translate="yes" xml:space="preserve">
          <source>These are a hotchpotch of opcodes still waiting to be considered</source>
          <target state="translated">이들은 여전히 ​​고려되기를 기다리는 opcode의 핫치 포치입니다.</target>
        </trans-unit>
        <trans-unit id="ab597ea19704a4092bef6ea8610d0145fc3acd27" translate="yes" xml:space="preserve">
          <source>These are all &quot;getters&quot; which return the data set for these attributes during object construction.</source>
          <target state="translated">이들은 모두 &quot;게터 (getter)&quot;로, 객체 구성 중 이러한 속성에 대한 데이터 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c6ad141ea95625d5f83dc60a511981417685e463" translate="yes" xml:space="preserve">
          <source>These are also the typical steps involved in writing a computer program. This makes perfect sense, because regular expressions are essentially programs written in a little computer language that specifies patterns.</source>
          <target state="translated">컴퓨터 프로그램 작성과 관련된 일반적인 단계이기도합니다. 정규식은 본질적으로 패턴을 지정하는 작은 컴퓨터 언어로 작성된 프로그램이기 때문에 이것은 완벽하게 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="c614a56da53c8268e03927a0382855aa589c9ffe" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8',
...)&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 및 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 대체 구문입니다 .</target>
        </trans-unit>
        <trans-unit id="a504c2130962ba4555e63c517df7cfb6c3415a56" translate="yes" xml:space="preserve">
          <source>These are based on what command.com does on Win98. They may be wrong for other Windows shells, I don't know.</source>
          <target state="translated">이들은 command.com이 Win98에서 수행하는 작업을 기반으로합니다. 다른 Windows 셸에서는 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c07d55f7a2a925e22fec82104bd39d3cabc4301" translate="yes" xml:space="preserve">
          <source>These are called mid-endian, middle-endian, mixed-endian, or just weird.</source>
          <target state="translated">이들은 중간 엔디안, 중간 엔디안, 혼합 엔디안 또는 이상하게 불립니다.</target>
        </trans-unit>
        <trans-unit id="3a9105b34a20a7fdd4e6d997e3a1e1ad31f3f321" translate="yes" xml:space="preserve">
          <source>These are covered in the following section.</source>
          <target state="translated">이것들은 다음 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="543fcf9df34b75f159b226a9706c32a67f612f3d" translate="yes" xml:space="preserve">
          <source>These are effectively no-ops.</source>
          <target state="translated">이들은 사실상 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6dbfbbee534ca87c61eabe600b034f42390dde5" translate="yes" xml:space="preserve">
          <source>These are equivalent</source>
          <target state="translated">이것들은 동등합니다</target>
        </trans-unit>
        <trans-unit id="2c34193d065093cc77699a0d9ca713a7565b5a4e" translate="yes" xml:space="preserve">
          <source>These are fetched from one or more mirrored CPAN (Comprehensive Perl Archive Network) sites and unpacked in a dedicated directory.</source>
          <target state="translated">이들은 하나 이상의 미러링 된 CPAN (Comprehensive Perl Archive Network) 사이트에서 가져오고 전용 디렉토리에서 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="1218c4eafb2ac24b7f5a6bfc47e38d53cda6dbb8" translate="yes" xml:space="preserve">
          <source>These are fprintf()/vfprintf() equivalents.</source>
          <target state="translated">이들은 fprintf () / vfprintf ()에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c9080846b04ed2aaef61ea34f53f7101d2c5f347" translate="yes" xml:space="preserve">
          <source>These are functions for searching through directory trees doing work on each file found similar to the Unix</source>
          <target state="translated">유닉스와 비슷하게 발견 된 각 파일에 대한 작업을 수행하는 디렉토리 트리를 검색하는 기능입니다</target>
        </trans-unit>
        <trans-unit id="82d3c39fd0ecabf1c8dc2de9284d7be1c98f1d46" translate="yes" xml:space="preserve">
          <source>These are general guidelines for how to write POD documentation for Perl scripts and modules, based on general guidelines for writing good UNIX man pages. All of these guidelines are, of course, optional, but following them will make your documentation more consistent with other documentation on the system.</source>
          <target state="translated">다음은 좋은 UNIX 매뉴얼 페이지 작성을위한 일반 지침을 기반으로 Perl 스크립트 및 모듈에 대한 POD 문서를 작성하는 방법에 대한 일반적인 지침입니다. 이 모든 지침은 물론 선택 사항이지만 지침을 따르면 시스템의 다른 문서와보다 일관성있게 문서를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dad0e81d2d1dfbeb7b354f138de6b73ae95d9158" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl from source. This version of Perl requires the dynamic linking support that is found in OpenVOS Release 17.1 and thus is not supported on OpenVOS Release 17.0 or earlier releases.</source>
          <target state="translated">다음은 소스에서 Perl을 빌드하기위한 지시 사항입니다. 이 버전의 Perl에는 OpenVOS 릴리스 17.1에있는 동적 링크 지원이 필요하므로 OpenVOS 릴리스 17.0 또는 이전 릴리스에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8591b5e35cdacaa99ac7aebf4d9655f41e44d08" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under DOS (or w??), using DJGPP v2.03 or later. Under w95 long filenames are supported.</source>
          <target state="translated">다음은 DJGPP v2.03 이상을 사용하여 DOS (또는 w ??)에서 Perl을 빌드하기위한 지시 사항입니다. w95에서 긴 파일 이름이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebba6a1db0c9a0e274e92574c949eaf7a4b8fb7" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under Windows 2000 and later.</source>
          <target state="translated">다음은 Windows 2000 이상에서 Perl을 빌드하기위한 지시 사항입니다.</target>
        </trans-unit>
        <trans-unit id="56039c5fbea93b2739212ecaf27c30cc3edfb9c5" translate="yes" xml:space="preserve">
          <source>These are intended to be services performed by the clients of this API.</source>
          <target state="translated">이것들은이 API의 클라이언트가 수행하는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="6d5e58ad94dd8e12f40343c4fe00cb855a20e455" translate="yes" xml:space="preserve">
          <source>These are just the most common definitions of &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; in Perl. There may well be others. For example, on an EBCDIC implementation such as z/OS (OS/390) or OS/400 (using the ILE, the PASE is ASCII-based) the above material is similar to &quot;Unix&quot; but the code numbers change:</source>
          <target state="translated">이것은 Perl에서 가장 일반적인 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; 정의입니다 . 다른 사람들도있을 수 있습니다. 예를 들어, z / OS (OS / 390) 또는 OS / 400과 같은 EBCDIC 구현 (ILE를 사용하여 PASE는 ASCII 기반 임)에서 위 자료는 &quot;Unix&quot;와 유사하지만 코드 번호가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e2a1ebead9f267c39fe9da94bb4791dac090d0bc" translate="yes" xml:space="preserve">
          <source>These are low-level functions to extract and use capabilities from a terminal capability (termcap) database.</source>
          <target state="translated">이들은 터미널 기능 (termcap) 데이터베이스에서 기능을 추출하고 사용하기위한 저수준 기능입니다.</target>
        </trans-unit>
        <trans-unit id="6e1b104453fcd9be9aa03bca5a6390babe809d8b" translate="yes" xml:space="preserve">
          <source>These are methods that you may find it handy to use, generally from %Lexicon routines of yours (whether expressed as Bracket Notation or not).</source>
          <target state="translated">이것들은 일반적으로 당신의 % Lexicon 루틴 (브래킷 표기법으로 표현 되든 아니든)에서 사용하기 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9a95859137ef50d66689fe259453639b6dce722a" translate="yes" xml:space="preserve">
          <source>These are methods which are used in the course of writing a test but are not themselves tests.</source>
          <target state="translated">이것들은 테스트 작성 과정에서 사용되는 방법이지만 자체 테스트는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="14859e3783966bf81d1767be73584f0ff1e6b683" translate="yes" xml:space="preserve">
          <source>These are methods which help writing cross-platform code.</source>
          <target state="translated">크로스 플랫폼 코드 작성에 도움이되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="10fcdff63f0636b8e542860baaf4e1184f58638e" translate="yes" xml:space="preserve">
          <source>These are methods which produce make targets.</source>
          <target state="translated">이것들은 make target을 만드는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5242bfa15c97f14acba2cd2d00dbeca39084930f" translate="yes" xml:space="preserve">
          <source>These are most easily explained from the bottom up.</source>
          <target state="translated">이것들은 아래에서 가장 쉽게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="eff3d42df745b107b6d797477e3d4e7f8d24cab3" translate="yes" xml:space="preserve">
          <source>These are not the very basics, though. It is assumed that you already know the difference between bytes and characters, and realise (and accept!) that there are many different character sets and encodings, and that your program has to be explicit about them. Recommended reading is &quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel Spolsky, at &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;.</source>
          <target state="translated">그러나 이것들은 기본적인 것이 아닙니다. 바이트와 ​​문자의 차이점을 이미 알고 있으며 문자 세트와 인코딩이 많이 있으며 프로그램에 명시해야한다는 것을 알고 있습니다. 권장 사항은 Joel Spolsky ( &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt; )의 &quot;절대적으로 모든 소프트웨어 개발자는 절대적으로 유니 코드 및 문자 집합에 대해 알아야합니다 (변명 없음!)&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="3cbc1741b6d34271e2ec1a26ca7d6418baa0ebb4" translate="yes" xml:space="preserve">
          <source>These are only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. These are the sizes of various C datatypes of the perl that created this image. These must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">&lt;code&gt;netorder&lt;/code&gt; 가 FALSE 인 경우에만 존재 합니다. 이들은이 이미지를 생성 한 perl의 다양한 C 데이터 유형의 크기입니다. Storable이 이미지를 읽을 수 있으려면 현재 perl과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="920887e803f6cf14e09050db36f20df3c6ead9d1" translate="yes" xml:space="preserve">
          <source>These are only supported if your system has &amp;lt;</source>
          <target state="translated">시스템에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="140e31bd5bffd898fd2913825a2d2d23dcf95138" translate="yes" xml:space="preserve">
          <source>These are pairwise exclusive, i.e. compact or loose, vt or ascii.</source>
          <target state="translated">이것들은 쌍으로 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="ee44bfea63f0502e44e3769d9962bf8126742be7" translate="yes" xml:space="preserve">
          <source>These are passed in to your plugin's &lt;code&gt;load()&lt;/code&gt; class method (if it has one), along with a reference to the &lt;code&gt;App::Prove&lt;/code&gt; object that is invoking your plugin:</source>
          <target state="translated">이들은 플러그인을 호출 하는 &lt;code&gt;App::Prove&lt;/code&gt; 객체에 대한 참조와 함께 플러그인의 &lt;code&gt;load()&lt;/code&gt; 클래스 메소드 (있는 경우 )에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="87db38161fab9301a6c38e350a75487ce9dba0c7" translate="yes" xml:space="preserve">
          <source>These are readline issues and can only be fixed by studying readline configuration on your architecture and adjusting the referenced file accordingly. Please make a backup of the &lt;code&gt;/etc/inputrc&lt;/code&gt; or &lt;code&gt;~/.inputrc&lt;/code&gt; and edit them. Quite often harmless changes like uppercasing or lowercasing some arguments solves the problem.</source>
          <target state="translated">이러한 문제는 readline 문제이며 아키텍처에서 readline 구성을 연구하고 이에 따라 참조 된 파일을 조정해야만 해결할 수 있습니다. &lt;code&gt;/etc/inputrc&lt;/code&gt; 또는 &lt;code&gt;~/.inputrc&lt;/code&gt; 를 백업 하고 편집하십시오. 어떤 주장을 대문자로 바꾸거나 소문자로 바꾸는 것과 같이 무해한 변화는 종종 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b38ff2c237d2189cfc8068063c988ad558800625" translate="yes" xml:space="preserve">
          <source>These are scripts which will check the source things like ANSI C violations, POD encoding issues, etc.</source>
          <target state="translated">이것은 ANSI C 위반, POD 인코딩 문제 등과 같은 소스를 확인하는 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="08a1e3d5222d26c7ad00377b2f49dd3e19a69282" translate="yes" xml:space="preserve">
          <source>These are shortcuts for &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt;</source>
          <target state="translated">이것들은 &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt; &lt;i&gt;somestring에&lt;/i&gt; 대한 지름길입니다&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="34937e959a1c366f5128e5b9fde3a8ddb4bd5e6f" translate="yes" xml:space="preserve">
          <source>These are similar to article(), body() and head(), but rather than returning the requested data directly, they return a tied filehandle from which to read the article.</source>
          <target state="translated">이들은 article (), body () 및 head ()와 유사하지만 요청 된 데이터를 직접 반환하지 않고 기사를 읽을 수있는 묶인 파일 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="992979db9b32df20ed312f9df292c8122981c5bf" translate="yes" xml:space="preserve">
          <source>These are the files in the Perl release that contain references to Cygwin. These very brief notes attempt to explain the reason for all conditional code. Hopefully, keeping this up to date will allow the Cygwin port to be kept as clean as possible.</source>
          <target state="translated">Cygwin에 대한 참조가 포함 된 Perl 릴리스의 파일입니다. 이 매우 간단한 노트는 모든 조건부 코드의 이유를 설명하려고 시도합니다. 이 업데이트를 최신 상태로 유지하면 Cygwin 포트를 최대한 깨끗하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ac46c3e2da8e520c552d106b13b25422f4ae84" translate="yes" xml:space="preserve">
          <source>These are the functions that are available, they may either be called as functions or class methods:</source>
          <target state="translated">다음은 사용 가능한 함수이며 함수 또는 클래스 메서드로 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1f03a776fe8bedafea0b23935ca2ad13f5c2fe" translate="yes" xml:space="preserve">
          <source>These are the hash data structures that are available:</source>
          <target state="translated">사용 가능한 해시 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="321abf696e1ac3f1c7e8ae4631a3e0352eed8069" translate="yes" xml:space="preserve">
          <source>These are the same as color('attribute') and can be used if you prefer typing:</source>
          <target state="translated">이들은 color ( 'attribute')와 동일하며 입력을 선호하는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4187810dcd65ec8ff13d408cac42774a760ce9e6" translate="yes" xml:space="preserve">
          <source>These are the signals which a program might normally expect to encounter and which by default cause it to terminate. They are HUP, INT, PIPE and TERM.</source>
          <target state="translated">이들은 일반적으로 프로그램에서 발생할 것으로 예상되는 신호이며 기본적으로 프로그램을 종료시킵니다. 그들은 HUP, INT, PIPE 및 TERM입니다.</target>
        </trans-unit>
        <trans-unit id="50c4067312fedca516066cb81563c6787bf50478" translate="yes" xml:space="preserve">
          <source>These are the signals which were trapped by default by the old &lt;b&gt;sigtrap&lt;/b&gt; interface, they are ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM, and TRAP. If no signals or signals lists are passed to &lt;b&gt;sigtrap&lt;/b&gt;, this list is used.</source>
          <target state="translated">이들은 이전 &lt;b&gt;sigtrap&lt;/b&gt; 인터페이스에 의해 기본적으로 트랩 된 신호이며 ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM 및 TRAP입니다. 신호 또는 신호 목록이 &lt;b&gt;sigtrap&lt;/b&gt; 으로 전달되지 않으면 이 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cea91aaa564fccd3f4852969e3ebc12f20249663" translate="yes" xml:space="preserve">
          <source>These are the six methods that are exported as default.</source>
          <target state="translated">기본적으로 내보내는 6 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="107044185540681260f831f30270844d122d9842" translate="yes" xml:space="preserve">
          <source>These are the things that you can put in the parameters to plan:</source>
          <target state="translated">다음은 계획 할 매개 변수에 넣을 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cae5aa495786f78d7786c67162eeac298ded8720" translate="yes" xml:space="preserve">
          <source>These are to do with constructing a language handle:</source>
          <target state="translated">언어 핸들 구성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e9dcb05d530b0eaaf353a6122269805fd5136a" translate="yes" xml:space="preserve">
          <source>These are useful shortcuts to save on the typing.</source>
          <target state="translated">입력시 저장하는 유용한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="20957167192887677e71195c4861c8a5596fbdd0" translate="yes" xml:space="preserve">
          <source>These are valid only on ASCII platforms. Starting in Perl v5.22, simply changing the octal constants to equivalent &lt;code&gt;\N{U+...}&lt;/code&gt; values makes them portable:</source>
          <target state="translated">이들은 ASCII 플랫폼에서만 유효합니다. Perl v5.22부터는 8 진 상수를 동등한 &lt;code&gt;\N{U+...}&lt;/code&gt; 값으로 변경하면 이식성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c3820acf49b8050b73972a9c61ce1cf6f1d9df" translate="yes" xml:space="preserve">
          <source>These are versions of the macros which take an explicit interpreter as an argument.</source>
          <target state="translated">이들은 명시적인 인터프리터를 인수로 취하는 매크로 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b056cc5f487123530dc637016a4d1c22c28e035c" translate="yes" xml:space="preserve">
          <source>These are:</source>
          <target state="translated">이것들은:</target>
        </trans-unit>
        <trans-unit id="16d16f3cffc4ac9689654ee5a738c8ecadd74b82" translate="yes" xml:space="preserve">
          <source>These can all be disabled with</source>
          <target state="translated">이것들은 모두 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e41fb2d0ecca05f4e2a4a44f51aab35f28ed5c33" translate="yes" xml:space="preserve">
          <source>These can be combined into a single regexp with a three-way alternation:</source>
          <target state="translated">이들은 3 방향 교대로 단일 정규식으로 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b66993a553be0939fc1c087fcb0c54c5cdbbb0" translate="yes" xml:space="preserve">
          <source>These cases below violate the &quot;remainder has the sign of the second of the two arguments&quot;, since they wouldn't match up otherwise.</source>
          <target state="translated">아래의 이러한 경우는 &quot;남은 두 인자 중 두 번째 인자의 부호가 있습니다&quot;를 위반하는 것입니다. 그렇지 않으면 일치하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1fd6f63888a958514d8ebfc5074b3f479f8a49f9" translate="yes" xml:space="preserve">
          <source>These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">이러한 클래스는 명백한 방식으로 유사한 이름의 기본 C 구조에 해당합니다. 상속 계층은 기본 C &quot;상속&quot;을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="5f11a03556aad53a0a7bc63133f793375ad1dc66" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">이 코드 블록은 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 로 접두어를 붙여서 서브 루틴의 모양을 만들 수 있습니다 (이것은 좋은 스타일로 간주되지는 않습니다). 이러한 코드 블록은 실제로는 이름이 지정된 서브 루틴으로 존재하지 않습니다 (모양에도 불구하고). 이것을 제공하는 것은 프로그램에서 &lt;b&gt;하나&lt;/b&gt; 이상의 이러한 코드 블록을 가질 수 있으며, 적절한 순간에 &lt;b&gt;모두&lt;/b&gt; 실행될 것 입니다. 따라서 이름으로 이러한 코드 블록을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="97b3b7dd37ba8a222332eb2984faedc72082d594" translate="yes" xml:space="preserve">
          <source>These commands take any number of arguments and investigate what is necessary to perform the action. Argument processing is as follows:</source>
          <target state="translated">이 명령은 여러 인수를 사용하여 조치를 수행하는 데 필요한 사항을 조사합니다. 인수 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1935b5d017d485fb4c9165c42281556d84b0d309" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 단계 키워드는 &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod의 BEGIN, UNITCHECK, CHECK, INIT 및 END에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f96e99d050cd5ba24ce3555c69d5626ea1ddfe" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 단계 키워드는 &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod의 BEGIN, UNITCHECK, CHECK, INIT 및 END에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="97251eb9b01071889514a18b4c3f732daa85a7b2" translate="yes" xml:space="preserve">
          <source>These constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a9cdeb250fa9e2cb61227f4240cb75a90c2a763" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</source>
          <target state="translated">이 상수는 정규화 된 이름과 함께 사용할 수도 있습니다. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24ced089c50142be624d4fe7279d5e7e8267bf6" translate="yes" xml:space="preserve">
          <source>These conversions are governed by the following general rules:</source>
          <target state="translated">이러한 변환에는 다음과 같은 일반적인 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ebb9f4990eefbf7af18e7f37f2d673045cd0b59" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt; ) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">이러한 변환은 필요에 따라 상황에 따라 호출됩니다. 예를 들어, 오버로드 된 객체가 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 인수로 전달되는 경우 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) 의 서브 루틴 과 흐름 제어 명령문의 조건에서 테스트되는 &lt;code&gt;'bool'&lt;/code&gt; 의 서브 루틴 (예 : &lt;code&gt;while&lt;/code&gt; ) 또는 삼항 &lt;code&gt;?:&lt;/code&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="a40ed2255002784d89744404c25a8dfb75189849" translate="yes" xml:space="preserve">
          <source>These correspond (loosely) to fgetpos() and fsetpos(). Rather than stdio's Fpos_t they expect a &quot;Perl Scalar Value&quot; to be passed. What is stored there should be considered opaque. The layout of the data may vary from handle to handle. When not using stdio or if platform does not have the stdio calls then they are implemented in terms of PerlIO_tell() and PerlIO_seek().</source>
          <target state="translated">이들은 fgetpos () 및 fsetpos ()에 대응합니다. stdio의 Fpos_t 대신 &quot;Perl Scalar Value&quot;가 전달 될 것으로 예상합니다. 저장된 것은 불투명 한 것으로 간주해야합니다. 데이터의 레이아웃은 핸들마다 다를 수 있습니다. stdio를 사용하지 않거나 플랫폼에 stdio 호출이 없으면 PerlIO_tell () 및 PerlIO_seek ()로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab9bc2795a0ea30e5174b44302c5f3390695af2" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">이들은 기능적으로 fread () 및 fwrite ()에 해당하지만 인수와 반환 값이 다릅니다. PerlIO_read () 및 PerlIO_write () 시그니처는보다 낮은 수준의 read () 및 write () 함수에서 대신 모델링되었습니다. &quot;file&quot;인수가 먼저 전달되고 하나의 &quot;count&quot;만 있으며 리턴 값은 error와 &lt;code&gt;EOF&lt;/code&gt; 를 구별하십시오 .</target>
        </trans-unit>
        <trans-unit id="6faed5a4522cd8b94dc864e27b779abb63c4ce78" translate="yes" xml:space="preserve">
          <source>These correspond to fopen()/fdopen() and the arguments are the same. Return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; if there is an error. There may be an implementation limit on the number of open handles, which may be lower than the limit on the number of open files - &lt;code&gt;errno&lt;/code&gt; may not be set when &lt;code&gt;NULL&lt;/code&gt; is returned if this limit is exceeded.</source>
          <target state="translated">이들은 fopen () / fdopen ()에 해당하며 인수는 동일합니다. 반환 &lt;code&gt;NULL&lt;/code&gt; 과 세트 &lt;code&gt;errno&lt;/code&gt; 오류가있는 경우. 열린 핸들 수에 대한 구현 제한이있을 수 있습니다. 열린 핸들 수에 대한 제한보다 낮을 수 있습니다 .이 한계를 초과 하면 &lt;code&gt;NULL&lt;/code&gt; 이 리턴 될 때 &lt;code&gt;errno&lt;/code&gt; 가 설정되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85c39d61ce18e7b09b1791e93aa8066eeef62084" translate="yes" xml:space="preserve">
          <source>These correspond to fputs() and fputc(). Note that arguments have been revised to have &quot;file&quot; first.</source>
          <target state="translated">이들은 fputs () 및 fputc ()에 해당합니다. 인수는 &quot;파일&quot;을 먼저 갖도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e90caae28ef06f86a5a7c45f8c354bdfbb310ff" translate="yes" xml:space="preserve">
          <source>These defaults may change once perlio has been better tested and tuned.</source>
          <target state="translated">perlio를 더 잘 테스트하고 조정하면 이러한 기본값이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b42ed96c36dd8480d16597a1b739ba48b433615" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=perl. Defaults to $Config{installman*dir}.</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = perl 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ Config {installman * dir}입니다.</target>
        </trans-unit>
        <trans-unit id="80d2a82fca268aa8c538c7ef08b93ac2b88facef" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=site (default). Defaults to $(SITEPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = site (기본값) 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ (SITEPREFIX) / man / man $ (MAN * EXT)입니다.</target>
        </trans-unit>
        <trans-unit id="68e3f1b03dd4e2ce3d50494f40f9bb4bc33a9ff9" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=vendor. Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">이 디렉토리는 INSTALLDIRS = vendor 인 경우 'make install'시간에 매뉴얼 페이지를 가져옵니다. 기본값은 $ (VENDORPREFIX) / man / man $ (MAN * EXT)입니다.</target>
        </trans-unit>
        <trans-unit id="40c3a72856e79ae11ef7788be093b884c47b09d5" translate="yes" xml:space="preserve">
          <source>These examples are realized in the code below, which could be copied to a file</source>
          <target state="translated">이 예제는 아래 코드에서 실현되며 파일로 복사 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ea1d8aa8b62f74ea36ff39b0b63b9774953aaca0" translate="yes" xml:space="preserve">
          <source>These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="translated">줄임표를 사용하려는 시도의 예는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="ad269ea05e73affc724a0326dc3ecea88836b454" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">이러한 예제는 종종 해당 문서의 작성자 스타일과 선호도를 반영하며 실제 프로그램의 해당 코드 줄보다 짧을 수 있습니다. 특별한 법적 고지가없는 한, 해당 가정해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 문 앞에서 &quot;프로그램&quot;에 표시를하고, 이미 그 선언이 생략 된 경우에도, 선언 된 사용되는 모든 변수를 읽을 수 예를 쉽게하기 위해있다.</target>
        </trans-unit>
        <trans-unit id="da4181b23484c1b0366a0256854a440c5eed9952" translate="yes" xml:space="preserve">
          <source>These examples show how to make references to variables with names. Sometimes you want to make an array or a hash that doesn't have a name. This is analogous to the way you like to be able to use the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or the number 80 without having to store it in a named variable first.</source>
          <target state="translated">이 예제는 이름을 가진 변수를 참조하는 방법을 보여줍니다. 때로는 이름이없는 배열이나 해시를 만들고 싶을 때가 있습니다. 이것은 명명 된 변수를 먼저 저장하지 않고 문자열 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 또는 숫자 80 을 사용할 수있는 방식과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7900d790c497c44a25852d75caed60efb96bb183" translate="yes" xml:space="preserve">
          <source>These features are no longer considered experimental and their functionality has disappeared. It's your own fault if you wrote production programs using these features after we explicitly told you not to (see &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;).</source>
          <target state="translated">이러한 기능은 더 이상 실험적인 것으로 간주되지 않으며 기능이 사라졌습니다. 우리가 명시 적으로 지시하지 않은 후에 이러한 기능을 사용하여 프로덕션 프로그램을 작성했다면 그것은 당신 자신의 잘못입니다 ( &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ecdbc29b6059151fd36541ed2cea90e388fc6071" translate="yes" xml:space="preserve">
          <source>These features were so wildly successful and played so well with others that we decided to remove their experimental status and admit them as full, stable features in the world of Perl, lavishing all the benefits and luxuries thereof. They are also awarded +5 Stability and +3 Charisma.</source>
          <target state="translated">이 기능은 매우 성공적이었고 다른 사람들과 잘 어울려 실험 상태를 제거하고 Perl 세계에서 완전하고 안정적인 기능으로 인정하여 모든 이점과 사치가 사라졌습니다. 또한 +5의 안정성과 +3의 카리스마가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="436079f5f30dfc97a1a6d7f8ea9906fefeca2983" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</source>
          <target state="translated">이 필드는 패턴에 일치 할 수있는 Paren 그룹 수, 마지막으로 입력 한 마지막 Paren 및 마지막으로 입력 한 마지막 Paren을 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8e2d7aa479f62270f36bb981c83130e3ea21ce" translate="yes" xml:space="preserve">
          <source>These files contain information on who maintains which modules. Run &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; to find out more information about a dual-life module.</source>
          <target state="translated">이 파일에는 누가 어떤 모듈을 유지 보수하는지에 대한 정보가 들어 있습니다. 이중 수명 모듈에 대한 자세한 정보를 보려면 &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c3add026b4eccbc256b7dbac98ef5e6ce0ff8a8" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">이 플래그는 컴파일 중에 설정되어 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 에서 최적화를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ad448cfc75702b92a6132746a47d8bee944a550" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">이러한 흐름 제어 키워드는 &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f149ae07a8478e188c52361aad3ec711ed1026a" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">이러한 흐름 제어 키워드는 &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="309e08bc8a3175c38d05ead911b510e18b559b99" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">실험용 스위치 기능과 관련된 이러한 흐름 제어 키워드 &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;는 perlsyn의 Switch Statements에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a272370ad05edf250f2041efdee62784d465ad39" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">실험용 스위치 기능과 관련된 이러한 흐름 제어 키워드 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;는 perlsyn의 Switch Statements에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc4036739b5240858c0bf581399bd57e7b5e9c9e" translate="yes" xml:space="preserve">
          <source>These forms may be assigned to, and cause the right-hand side to be evaluated in scalar context:</source>
          <target state="translated">이 형식은 다음에 할당 될 수 있으며 오른쪽이 스칼라 컨텍스트에서 평가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="b6a87abeab3fa4b07145fb59b22ed97519f70773" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2013 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">이 무료 버전의 Visual C ++ 2008-2013 Professional에는 정식 버전과 함께 제공되는 동일한 컴파일러 및 링커가 포함되어 있으며 이전 버전과 달리 Windows SDK를 별도로 다운로드하지 않고 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdfa79cbeb17377a5124b29f2fd31a6e8d98c48" translate="yes" xml:space="preserve">
          <source>These functions allow checksums to be merged. Refer to the</source>
          <target state="translated">이러한 기능을 통해 체크섬을 병합 할 수 있습니다. 참조</target>
        </trans-unit>
        <trans-unit id="ba57dd2ab74f37811d43a497242362420e4296f0" translate="yes" xml:space="preserve">
          <source>These functions are exported only on request. They each take a single argument and return the absolute pathname for it. If no argument is given they'll use the current working directory.</source>
          <target state="translated">이러한 기능은 요청시에만 내보낼 수 있습니다. 그들은 각각 하나의 인수를 취하고 그것에 대한 절대 경로 이름을 반환합니다. 인수가 없으면 현재 작업 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11a75a016614f3f6a49b489f2532217d2dc9b130" translate="yes" xml:space="preserve">
          <source>These functions are interface of character data used internally. If you want only to get Unicode normalization forms, you don't need call them yourself.</source>
          <target state="translated">이러한 기능은 내부적으로 사용되는 문자 데이터의 인터페이스입니다. 유니 코드 정규화 양식 만 얻으려면 직접 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5805d5b7ed6958150825f5cb6f923e00d36788d" translate="yes" xml:space="preserve">
          <source>These functions are provided for backwards compatibility with common tempfile generation C library functions.</source>
          <target state="translated">이러한 함수는 일반적인 임시 파일 생성 C 라이브러리 함수와의 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c85d18231511b3dd1840594c64b0cd5dd02c4fd" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes</source>
          <target state="translated">이 함수들은 perl 클래스의 메소드 해결 순서와 관련이 있습니다</target>
        </trans-unit>
        <trans-unit id="565eacfa6d391bb1e8f9b310d413202832f4d770" translate="yes" xml:space="preserve">
          <source>These functions are used by the filter to obtain either a line or block from the next filter in the chain or the actual source file if there aren't any other filters.</source>
          <target state="translated">이러한 함수는 필터에서 다른 필터가없는 경우 체인의 다음 필터 또는 실제 소스 파일에서 라인 또는 블록을 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b40856071384296779ffb96483ca0013c6d7f3df" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 보통 &lt;code&gt;ok()&lt;/code&gt; 내부에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad9ddd863a33c4087b2128f800b2bb735b670e0b" translate="yes" xml:space="preserve">
          <source>These functions control the global state of the package.</source>
          <target state="translated">이러한 기능은 패키지의 전역 상태를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="524d44a200305a1bdc5134c684c7bc58ebf331b8" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">이 함수는 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 토큰을 메소드 이름의 접두어로 부여 합니다. 리턴 된 glob을 오랫동안 유지하려면 &quot;AUTOLOAD&quot;인지 확인해야합니다. 나중에 $ AUTOLOAD가 값을 변경하여 호출이 다른 서브 루틴을로드 할 수 있기 때문입니다. 이를 위해 부작용으로 생성 된 글로브를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b1137b52cacd1fbff911e830d8d14363d490cb" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt; . The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 와 동일한 부작용을 갖 습니다 . 에 의해 반환되는 GV 통과에 대한 경고 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 에 &lt;code&gt;call_sv&lt;/code&gt; 는 이러한 기능에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="98d4aef8dd151e8462fbb3063b8efcb68e0d87b2" translate="yes" xml:space="preserve">
          <source>These functions provide convenient and thread-safe means of manipulating hook variables.</source>
          <target state="translated">이 함수는 후크 변수를 조작하는 편리한 스레드 안전 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f738338a9dbfbee4b5a909220a80f41318a9f381" translate="yes" xml:space="preserve">
          <source>These functions simply print $Config{ccflags} and $Config{ccdlflags}</source>
          <target state="translated">이 함수는 단순히 $ Config {ccflags} 및 $ Config {ccdlflags}를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6cd020ca0f66b00dde6a2341717a3dae0fc7c828" translate="yes" xml:space="preserve">
          <source>These functions take a hash as an argument. The recognized keys of this hash are:</source>
          <target state="translated">이러한 함수는 해시를 인수로 사용합니다. 이 해시의 인식 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6359c7691ac9172680cb301b6768d6c5620c165" translate="yes" xml:space="preserve">
          <source>These functions take an input numeric code point in one encoding and return what its equivalent value is in the other.</source>
          <target state="translated">이 함수는 한 인코딩에서 입력 숫자 코드 포인트를 가져 와서 다른 값에 해당하는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ebb5ef7a942f7d31cebfd11f8de6228de926c64" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;../perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">이러한 후크는로드 된 파일에 해당하는 % INC 항목을 설정할 수도 있습니다. &lt;a href=&quot;../perlvar#%25INC&quot;&gt;perlvar의 % INC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcbca2e2db6c0375d3253e7898e5f5abc5deaab1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">이러한 후크는로드 된 파일에 해당하는 % INC 항목을 설정할 수도 있습니다. &lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar의 % INC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab8134e6c8ea614a58bbf4cba85fe875f47ac40" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">이 인터페이스는 Perl 5.9.5 이상에서만 사용 가능합니다. 이전 Perls에 대한 대부분의 순방향 호환 구현은 CPAN의 &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="800024eb93ec8e2e1c9e19ed6e58201379d4f5ea" translate="yes" xml:space="preserve">
          <source>These items are the primitives used to perform indenting, and to select text from amongst alternatives.</source>
          <target state="translated">이 항목은 들여 쓰기를 수행하고 다른 텍스트 중에서 텍스트를 선택하는 데 사용되는 기본 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3dfe7afbcdb97590e1c6c0085eefd647c7035d88" translate="yes" xml:space="preserve">
          <source>These keys will be populated before any exceptions are thrown should there be an error.</source>
          <target state="translated">이 키는 오류가있을 경우 예외가 발생하기 전에 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a901d1a803d1f1e84cb86c073bdbaefe49dcbe0f" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;perldata의 특수 리터럴에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1500951fb5f2dd9eeebd6c439509f1ad3f36d4ce" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;perldata#Special-Literals&quot;&gt;perldata의 특수 리터럴에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="017f89666b16c462ff4b71931d55ca635d0ecaed" translate="yes" xml:space="preserve">
          <source>These last two are only valid for pad name SVs. They only existed in the B::NV class before Perl 5.22. In 5.22 they were moved to the B::PADNAME class.</source>
          <target state="translated">이 마지막 두 개는 패드 이름 SV에만 유효합니다. Perl 5.22 이전의 B :: NV 클래스에만 존재했습니다. 5.22에서 그들은 B :: PADNAME 수업으로 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="ee3476aee9a9c9d8b18c6d57ac8c385c0348f0d4" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것들은 문자 이름과 비슷하지만 여러 코드 포인트를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;%vx&lt;/code&gt; 벡터 인쇄 기능에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="e76a83f91dda3c78158f07c2bcf605e73e782739" translate="yes" xml:space="preserve">
          <source>These loop ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available CPU time).</source>
          <target state="translated">이러한 루프 op는 리소스 공격을 구현하는 데 쉽게 사용할 수 있으므로 (예 : 사용 가능한 모든 CPU 시간 사용) : base_core에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a843eb74986a4e9f839472d2d8d150ea39980b05" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of integer variable &lt;code&gt;i&lt;/code&gt; at the end of enclosing</source>
          <target state="translated">이 매크로 는 엔 클로징이 끝날 때 정수 변수 &lt;code&gt;i&lt;/code&gt; 의 값을 복원하도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f7a2a9aebcff3586f69f55801776cb23fd4e90a9" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">이 매크로는 포인터 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 의 값을 복원하기 위해 사물을 배열 합니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;SV*&lt;/code&gt; 변환 된 후에도 존속하는 유형의 포인터 여야 하고, &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;char*&lt;/code&gt; 변환 한 후에도 존속 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="593dfba1d3d328349b77f1588cf82c2aaffa0443" translate="yes" xml:space="preserve">
          <source>These may not necessarily cause trouble, but indicate mediocre style.</source>
          <target state="translated">반드시 문제를 일으킬 수는 없지만 평범한 스타일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e22b64582fc85ac43b9e96c24337a10a450121a5" translate="yes" xml:space="preserve">
          <source>These memory related ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available memory).</source>
          <target state="translated">이러한 메모리 관련 ops는 : base_core에 포함되지 않습니다. 리소스 공격을 쉽게 구현하는 데 사용할 수 있기 때문입니다 (예 : 사용 가능한 모든 메모리 사용).</target>
        </trans-unit>
        <trans-unit id="77c1bb576863e90102788a1b3ffe564db0c5c144" translate="yes" xml:space="preserve">
          <source>These messages are classified as follows (listed in increasing order of desperation):</source>
          <target state="translated">이러한 메시지는 다음과 같이 분류됩니다 (절망적 인 순서로 나열 됨).</target>
        </trans-unit>
        <trans-unit id="b0bb74426f2aa2733dbc5c5a86f08523cab5f25f" translate="yes" xml:space="preserve">
          <source>These messages may safely be ignored. (Note that for a SunOS4 system, you must use -B/bin/ instead.)</source>
          <target state="translated">이러한 메시지는 무시해도됩니다. (SunOS4 시스템의 경우 -B / bin /을 대신 사용해야합니다.)</target>
        </trans-unit>
        <trans-unit id="5b9f0b892cf28755d89fe7944f868ad5bf940e68" translate="yes" xml:space="preserve">
          <source>These methods all apply to the Ptr type for the structure; additionally two methods are constructed for the structure type itself, &lt;code&gt;_to_ptr&lt;/code&gt; which returns a Ptr type pointing to the same structure, and a &lt;code&gt;new&lt;/code&gt; method to construct and return a new structure, initialised to zeroes.</source>
          <target state="translated">이러한 방법은 모두 구조의 Ptr 유형에 적용됩니다. 추가적으로 방법은 두 구조 유형 자체를 위해 구성된다 &lt;code&gt;_to_ptr&lt;/code&gt; 동일한 구조로의 PTR 식 포인팅을 리턴하고, &lt;code&gt;new&lt;/code&gt; 구조와 방법을 제로로 초기화 된 새로운 구조를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="833ac724c3c333f81488114a18e12c4a9e975d1a" translate="yes" xml:space="preserve">
          <source>These methods all test the BigInt for being one specific value and return true or false depending on the input. These are faster than doing something like:</source>
          <target state="translated">이 메소드는 모두 BigInt가 하나의 특정 값인지 테스트하고 입력에 따라 true 또는 false를 리턴합니다. 이것들은 다음과 같은 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="92da9e899f4e8b0a6a719a6370a299d62ec6b1c8" translate="yes" xml:space="preserve">
          <source>These methods are for setting up tests and declaring how many there are. You usually only want to call one of these methods.</source>
          <target state="translated">이 방법들은 테스트를 설정하고 몇 개가 있는지 선언하기위한 것입니다. 일반적으로 이러한 방법 중 하나만 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9725043aadb2020c60801a841d8cbbe42a310c40" translate="yes" xml:space="preserve">
          <source>These methods are not intended to be called by the user, but used or over-ridden by a sub-class of &lt;code&gt;Net::Cmd&lt;/code&gt;</source>
          <target state="translated">이러한 메소드는 사용자가 호출하도록 의도 된 것이 아니라 &lt;code&gt;Net::Cmd&lt;/code&gt; 의 서브 클래스에 의해 사용되거나 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c96be7d81aefe7494626f31fbf2d601d47ed4e3e" translate="yes" xml:space="preserve">
          <source>These methods are only testing the sign, and not the value.</source>
          <target state="translated">이러한 방법은 부호 만 테스트하고 값은 테스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f55156f755c79786d47317ca2de0a12228b5b4b7" translate="yes" xml:space="preserve">
          <source>These methods are useful when writing your own test methods.</source>
          <target state="translated">이 방법은 자체 테스트 방법을 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1371312bc20ca6b06acc065c53943c266c38f79b" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt; , a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 Test :: Builder가 출력을 인쇄 할 위치를 제어합니다. 열린 &lt;code&gt;$filehandle&lt;/code&gt; , 열고 쓸 &lt;code&gt;$filename&lt;/code&gt; 또는 추가 할 &lt;code&gt;$scalar&lt;/code&gt; 참조 중 하나를 사용합니다. 항상 &lt;code&gt;$filehandle&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4dabfc6c3e23d636029050966dc499c5c862fee9" translate="yes" xml:space="preserve">
          <source>These methods get the values of similarly named fields within the OP data structure. See top of &lt;code&gt;op.h&lt;/code&gt; for more info.</source>
          <target state="translated">이러한 메소드는 OP 데이터 구조 내에서 유사한 이름의 필드 값을 가져옵니다. 자세한 내용은 &lt;code&gt;op.h&lt;/code&gt; 의 상단을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac0ba268e5d0e742f5c1a8121218a2683f22449" translate="yes" xml:space="preserve">
          <source>These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array.</source>
          <target state="translated">이러한 방법은 빠른 개별 테스트를 보장하지만 원래 목록 또는 배열을 재구성해야합니다. 동일한 배열에 대해 여러 값을 테스트 해야하는 경우에만 보상합니다.</target>
        </trans-unit>
        <trans-unit id="7cb3b559e380c719f80028fb428c3eb720e12704" translate="yes" xml:space="preserve">
          <source>These methods install a transparent filter on the I/O stream that converts data from the specified encoding when it is read in from the stream. The result is always Unicode.</source>
          <target state="translated">이러한 메소드는 I / O 스트림에 투명한 필터를 설치하여 스트림에서 읽을 때 지정된 인코딩의 데이터를 변환합니다. 결과는 항상 유니 코드입니다.</target>
        </trans-unit>
        <trans-unit id="2d0828193002db36233bc401e0a0e9c0dbb462a1" translate="yes" xml:space="preserve">
          <source>These methods provide a user interface to the &lt;code&gt;Net::Cmd&lt;/code&gt; object.</source>
          <target state="translated">이 메소드는 &lt;code&gt;Net::Cmd&lt;/code&gt; 오브젝트에 대한 사용자 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ff435d938391d9561763fbcab2d9f747b7f84a93" translate="yes" xml:space="preserve">
          <source>These methods set the size (in half-points, like 52 for 26-point) that these heading levels will appear as.</source>
          <target state="translated">이러한 방법을 사용하면 이러한 표제 수준이 표시 될 크기 (26 포인트의 경우 52와 같은 반 포인트)를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="abcc7bd5fdde6b4a0c109a19d7071ed04915f8b9" translate="yes" xml:space="preserve">
          <source>These methods use commands that are not part of the RFC977 documentation. Some servers may not support all of them.</source>
          <target state="translated">이러한 방법은 RFC977 설명서에 포함되지 않은 명령을 사용합니다. 일부 서버는 모든 서버를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ccd9bd046a9504a4b8ad4115c9067507a8e143" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , and you can import the generic bitmask constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</source>
          <target state="translated">이러한 모드는 모두 비트 마스크를 통해 실제로 설정됩니다. &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 상수를 배치 하는 방법은 다음과 같습니다 . 당신은 가져올 수 있습니다 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 의 를 통해 상수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , 당신은을 통해 일반 비트 마스크 상수 가져올 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d789a994adbfeec56de6cff1edba3230c60ae5bf" translate="yes" xml:space="preserve">
          <source>These modifiers are restored at the end of the enclosing group. For example,</source>
          <target state="translated">이 수정자는 엔 클로징 그룹의 끝에서 복원됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4b50f0d55e6d3bcc6eb1ad193029b6cf71ad0ceb" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; does not change the case-sensitivity of the &quot;NAME&quot; pattern.</source>
          <target state="translated">이러한 수정자는 묶음 그룹에서 호출 된 명명 된 하위 패턴으로 이어지지 않습니다. 즉, &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; 과 같은 패턴 은 &quot;NAME&quot;패턴의 대소 문자 구분을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5fbd761faf543e63a6416a5e28a730d54795855" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode, etc.) are used, as described below in &lt;a href=&quot;#Character-set-modifiers&quot;&gt;Character set modifiers&lt;/a&gt;.</source>
          <target state="translated">5.14의 새로운 기능인 이러한 수정자는 아래의 &lt;a href=&quot;#Character-set-modifiers&quot;&gt;문자 집합 수정 자&lt;/a&gt; 에 설명 된대로 사용되는 문자 집합 규칙 (유니 코드 등)에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="bb9708d2ade8d02334095230804c31cb6c6f062f" translate="yes" xml:space="preserve">
          <source>These names are case-insensitive. By default (if specification is omitted), 'shifted' is adopted.</source>
          <target state="translated">이 이름은 대소 문자를 구분하지 않습니다. 기본적으로 (사양이 생략 된 경우) 'shifted'가 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a7bae57c0b7e47324c6368dda30c35ad91dca7" translate="yes" xml:space="preserve">
          <source>These notices must be retained in any copies of any part of this documentation and/or software.</source>
          <target state="translated">이 고지 사항은이 설명서 및 / 또는 소프트웨어의 일부 사본에 보관해야합니다.</target>
        </trans-unit>
        <trans-unit id="efbc4f1ae4d272c0d4681905f6fb23798e4783eb" translate="yes" xml:space="preserve">
          <source>These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running under Linux on a P4 2.8 GHz CPU. The last 5 entries differ by being pure perl implementations of the algorithms, which explains why they are so slow.</source>
          <target state="translated">이 수치는 2004 년 4 월 P4 2.8GHz CPU의 Linux에서 실행되는 ActivePerl-5.8.3으로 달성되었습니다. 마지막 5 개 항목은 알고리즘의 순수한 펄 구현 방식에 따라 다르며 왜 느린 지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b16394db34a86c1309e6f32038763254bbfec1e7" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="902ffcf3ea51513d56fbec3ce0266f1b87291429" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23835ab35bd3941ef690822a20797ba91ee28d2e" translate="yes" xml:space="preserve">
          <source>These operators are exempt from the &quot;looks like a function rule&quot; described above. That is, an opening parenthesis after the operator does not affect how much of the following code constitutes the argument. Put the opening parentheses before the operator to separate it from code that follows (this applies only to operators with higher precedence than unary operators, of course):</source>
          <target state="translated">이러한 연산자는 위에서 설명한 &quot;함수 규칙처럼 보임&quot;에서 제외됩니다. 즉, 연산자 뒤의 여는 괄호는 다음 코드 중 어느 것이 인수를 구성하는지에 영향을 미치지 않습니다. 여는 괄호를 연산자 앞에 두어 다음 코드와 분리하십시오 (물론 단항 연산자보다 우선 순위가 높은 연산자에만 적용됨).</target>
        </trans-unit>
        <trans-unit id="6b54b9bb627d1cf1404f3b5dab668ec8269f4aa6" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt; . If not, then only the &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; , and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">&lt;code&gt;sys$getuai&lt;/code&gt; 를 통해 명명 된 사용자의 UAF 정보를 검색하는 데 필요한 권한이있는 경우 이러한 연산자는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된 정보를 얻습니다 . 그렇지 않으면 &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 항목 만 반환됩니다. &lt;code&gt;$dir&lt;/code&gt; 그동안 항목, VMS 구문의 로그인 디렉토리를 포함 &lt;code&gt;$comment&lt;/code&gt; 항목이 유닉스 구문의 로그인 디렉토리가 포함되어 있습니다. &lt;code&gt;$gcos&lt;/code&gt; 항목은 UAF 레코드에서 소유자 필드가 포함되어 있습니다. &lt;code&gt;$quota&lt;/code&gt; 항목은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7e657656c9789c3619d255f79ac9b3a6c835215" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because of the risk of them being used to generate floating point exceptions (which would have to be caught using a $SIG{FPE} handler).</source>
          <target state="translated">이러한 연산은 부동 소수점 예외 ($ SIG {FPE} 핸들러를 사용하여 포착해야 함)를 생성하는 데 사용될 위험 때문에 : base_core에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5ea0da5f8ce978d8d492f686d44331bb4fc3946" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because they have an effect beyond the scope of the compartment.</source>
          <target state="translated">이 op는 구획의 범위를 넘어서 영향을 미치기 때문에 : base_core에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4dfb8577c0955249e95ba26e17b894dbf4b7a2" translate="yes" xml:space="preserve">
          <source>These ops are related to multi-threading.</source>
          <target state="translated">이 op는 멀티 스레딩과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2901e27ec7bca28af121ed51d6417c782431820f" translate="yes" xml:space="preserve">
          <source>These ops enable</source>
          <target state="translated">이 작전은</target>
        </trans-unit>
        <trans-unit id="e55c6aacfd2933ba2a5d8d99593dbebe1787988f" translate="yes" xml:space="preserve">
          <source>These options affect which handler will be used for subsequently installed signals.</source>
          <target state="translated">이 옵션은 이후에 설치된 신호에 사용할 핸들러에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="29c586cad3979b967f1d8c83a031669d4e85f7d5" translate="yes" xml:space="preserve">
          <source>These options control the 'vertical display' of opcodes. The display 'order' is also called 'mode' elsewhere in this document.</source>
          <target state="translated">이 옵션은 opcode의 '수직 디스플레이'를 제어합니다. 디스플레이 '순서'는이 문서의 다른 곳에서 '모드'라고도합니다.</target>
        </trans-unit>
        <trans-unit id="b5693ca212dce09ab36fc48e6272f7336e49446b" translate="yes" xml:space="preserve">
          <source>These options select the line-style (or just style) used to render each opcode, and dictates what info is actually printed into each line.</source>
          <target state="translated">이 옵션은 각 opcode를 렌더링하는 데 사용되는 선 스타일 (또는 스타일)을 선택하고 실제로 각 행에 인쇄되는 정보를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="822ae20d8832a94dbc806795384f0c1cb46d5024" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 모두 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="e00985d023d49949f9c18d4b6917b5fcc1fe8b04" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이러한 패키지는 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="ee6b901a4b16ea8fd5c1a17b0f5f523262d0ae63" translate="yes" xml:space="preserve">
          <source>These packages can both be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">이 패키지는 모두 다운로드 센터 ( &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en)&lt;/a&gt; 에서 검색하여 다운로드 할 수 있습니다 . (이러한 패키지에 대한 정확한 링크를 제공하는 것은 링크가 자주 변경되기 때문에 무의미한 작업으로 입증되었습니다.)</target>
        </trans-unit>
        <trans-unit id="b0b087e3db9d0ec8ccf2941b80cf3aaf473d4556" translate="yes" xml:space="preserve">
          <source>These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.</source>
          <target state="translated">현재 이러한 Perl 루틴 (Perl v.5.8.6 현재)은 전달 된 inf를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="5ee158f8c062eca4d28a3ec2d9f8d880c70ecea2" translate="yes" xml:space="preserve">
          <source>These possessive quantifiers represent a special case of a more general concept, the</source>
          <target state="translated">이러한 소유 수량자는보다 일반적인 개념의 특별한 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfd6c7d2c77daf624f0f4dda10d349c1b00557da" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , and all the Posix character classes</source>
          <target state="translated">이러한 속성은 &lt;code&gt;\b&lt;/code&gt; (중괄호 없음), &lt;code&gt;\B&lt;/code&gt; (중괄호 없음), &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; 및 모든 Posix 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="49d4c7299af6c451da747abf6a31ed43bc6d224c" translate="yes" xml:space="preserve">
          <source>These quantifiers will try to match as much of the string as possible, while still allowing the regex to match. So we have</source>
          <target state="translated">이러한 수량자는 가능한 한 많은 문자열을 일치 시키면서도 정규 표현식이 일치하도록 시도합니다. 그래서 우리는</target>
        </trans-unit>
        <trans-unit id="26153a279914ed6ae972bab9be5035c10687695d" translate="yes" xml:space="preserve">
          <source>These results are &quot;meta&quot; information about the total results of an individual test program.</source>
          <target state="translated">이 결과는 개별 테스트 프로그램의 총 결과에 대한 &quot;메타&quot;정보입니다.</target>
        </trans-unit>
        <trans-unit id="2bea10980ed9e4e8701806a5267309dec8b36b3d" translate="yes" xml:space="preserve">
          <source>These results refer to individual tests which are run.</source>
          <target state="translated">이 결과는 실행되는 개별 테스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f99e408a46643ae41ce4a2a5b658c331ee2d8a0f" translate="yes" xml:space="preserve">
          <source>These routines all create system-specific portability problems. As noted elsewhere, Perl is at the mercy of your C libraries for much of its system behavior. It's probably safest to assume broken SysV semantics for signals and to stick with simple TCP and UDP socket operations; e.g., don't try to pass open file descriptors over a local UDP datagram socket if you want your code to stand a chance of being portable.</source>
          <target state="translated">이러한 루틴은 모두 시스템 특정 이식성 문제를 발생시킵니다. 다른 곳에서 언급 한 바와 같이, Perl은 C 시스템의 많은 시스템 동작에 대한 자비에 있습니다. 신호에 대해 깨진 SysV 시맨틱을 가정하고 간단한 TCP 및 UDP 소켓 조작을 사용하는 것이 가장 안전합니다. 예를 들어, 코드를 이식 가능하게 만들려면 로컬 UDP 데이터 그램 소켓을 통해 열린 파일 디스크립터를 전달하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7accb91a83a147e188cfdb7ea0bdeddeb0f7f3a7" translate="yes" xml:space="preserve">
          <source>These routines allow you to parse file paths into their directory, filename and suffix.</source>
          <target state="translated">이 루틴을 사용하면 파일 경로를 해당 디렉토리, 파일 이름 및 접미사로 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c49f2650fd89670405ec1fbc536b94e9ae8bdf" translate="yes" xml:space="preserve">
          <source>These routines are all documented in the Locale::Codes::API man page.</source>
          <target state="translated">이러한 루틴은 모두 Locale :: Codes :: API 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd965d62212a6eeb3c7fb76c8f854332dc29f76" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 루틴은 매우 효율적이지만 항상 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 에 동의합니다 . 우리는 이전에 본 달의 시작 시간을 캐싱하여이를 관리합니다. 해당 월의 시작 시간을 알고 있으면 해당 월의 시간을 언제든지 계산할 수 있습니다. 시작 시간은 수학 공식을 사용하여 계산됩니다. &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 을 여러 번 호출하는 다른 알고리즘과 달리 .</target>
        </trans-unit>
        <trans-unit id="e296b7f9a5e96b639ca1839fa4442d3f45e92709" translate="yes" xml:space="preserve">
          <source>These routines are the same as their counterparts in the system C library. In list context, the return values from the various get routines are as follows:</source>
          <target state="translated">이 루틴은 시스템 C 라이브러리의 해당 루틴과 동일합니다. 리스트 컨텍스트에서 다양한 get 루틴의 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc1ea3e493711677c93d92be2ec1c6ec9a5ee909" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt; , etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">이 루틴 호출하는 데 사용 &lt;code&gt;perl_call_sv&lt;/code&gt; 펄 v5.6.0 전에, 등,하지만 그 이름은 이제 사용되지 않습니다; 호환성을 위해 동일한 이름의 매크로가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb1fb969b6c77a6565b33ce0e7b7cbfccc95cfb" translate="yes" xml:space="preserve">
          <source>These rules are complicated, but the goal is for them to do what you want (even if you don't quite understand why they are doing it). For example:</source>
          <target state="translated">이러한 규칙은 복잡하지만 목표는 왜하고 있는지 이해하지 못하는 경우에도 원하는대로 수행하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c39d28608973eadb707da3830a9f4611c69ff29" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt; .</source>
          <target state="translated">이들은 선택된 유니 코드 규칙입니다. 즉, 큰 따옴표로 묶인 문자열에서 문자열은 항상 UTF-8로 변환되어 유니 코드 해석을 강제합니다 (가능한 경우 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 를 사용하여 비 UTF8로 다시 변환 할 수 있음). 정규 표현식 패턴에서는 변환이 수행되지 않지만 문자 세트 수정자가 &lt;code&gt;/d&lt;/code&gt; 이면 &lt;code&gt;/u&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="c33be304d6b7f8ebe4e43f5c0dfa6aefb4009eb4" translate="yes" xml:space="preserve">
          <source>These sets of one-liners are equivalent:</source>
          <target state="translated">이 한 줄짜리 라이너 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52c95446c9ca7d3ffaa7ed7da6e1f21bf02cdc2e" translate="yes" xml:space="preserve">
          <source>These settings can be overridden globally too:</source>
          <target state="translated">이러한 설정은 전체적으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc91f3641f463359dfc31290abbc3a64d30454a" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt; . This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">&lt;code&gt;av_unshift&lt;/code&gt; 를 제외하고 익숙한 작업이어야합니다 . 이 루틴 은 배열 앞에 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값으로 &lt;code&gt;num&lt;/code&gt; 요소를 추가 합니다. 그런 다음 &lt;code&gt;av_store&lt;/code&gt; (아래 설명)를 사용 하여 이러한 새 요소에 값을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f249c892c517536f796cbacefae284ca0ae8032" translate="yes" xml:space="preserve">
          <source>These should give you an overall feel for how modules are laid out and written.</source>
          <target state="translated">이것들은 모듈의 레이아웃과 작성 방법에 대한 전반적인 느낌을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a888f57551ca71c1272e83f90d05d460b30fbf3" translate="yes" xml:space="preserve">
          <source>These signal to a formatter that if it is to hyphenate &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done as &quot;sig-</source>
          <target state="translated">&quot;서명&quot;또는 &quot;원고&quot;를 하이픈으로 묶으려면 &quot;sig-</target>
        </trans-unit>
        <trans-unit id="a76776d9b84dd64fcd8c2f12ffb416173943a78e" translate="yes" xml:space="preserve">
          <source>These signals usually indicate a serious problem with the Perl interpreter or with your script. They are ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS and TRAP.</source>
          <target state="translated">이러한 신호는 일반적으로 Perl 인터프리터 또는 스크립트에 심각한 문제가 있음을 나타냅니다. ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS 및 TRAP입니다.</target>
        </trans-unit>
        <trans-unit id="7ee071669b1efa68f9a3156de49d5e707921d24a" translate="yes" xml:space="preserve">
          <source>These solutions can have far-reaching effects on your system and on the way you write your CGI programs, so investigate them with care.</source>
          <target state="translated">이러한 솔루션은 시스템 및 CGI 프로그램 작성 방식에 광범위한 영향을 줄 수 있으므로주의해서 조사하십시오.</target>
        </trans-unit>
        <trans-unit id="af1c9d3db11663506b814ed4474ccb898e81f0dd" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*VERB:ARG)&lt;/code&gt;. Unless otherwise stated the ARG argument is optional; in some cases, it is forbidden.</source>
          <target state="translated">이러한 특수 패턴은 일반적으로 &lt;code&gt;(*VERB:ARG)&lt;/code&gt; 형식 입니다. 달리 명시되지 않는 한 ARG 인수는 선택 사항입니다. 어떤 경우에는 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6fd84e089df12e602215034c3af5ac8fb7e11a" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; , etc.) are dynamically scoped until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 해시 및 숫자 일치 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등) 와 같은 이러한 특수 변수 는 둘러싸는 블록의 끝까지 또는 다음 성공적인 일치 (둘 중 먼저 오는 것)까지 동적으로 범위가 지정됩니다. ( &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ba4f20c17b5b03a6a3deb3a04503955765039642" translate="yes" xml:space="preserve">
          <source>These strengths make it especially popular with web developers and system administrators. Mathematicians, geneticists, journalists, managers and many other people also use Perl.</source>
          <target state="translated">이러한 장점으로 인해 웹 개발자 및 시스템 관리자에게 특히 인기가 있습니다. 수학자, 유전 학자, 언론인, 관리자 및 다른 많은 사람들도 Perl을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a952f4bd002dc5bdafb796a94c6eaa4765c9b45b" translate="yes" xml:space="preserve">
          <source>These strings do not match /\Bam\B/</source>
          <target state="translated">이 문자열은 / \ Bam \ B /와 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2125a4453223ddc6316d0fee4d859469467def9f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\b'\b/.</source>
          <target state="translated">이 문자열은 / \ b '\ b /와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa64b62307f4ac9360d6b96b7d4a2888dc9ba0f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\bPerl\b/.</source>
          <target state="translated">이 문자열은 / \ bPerl \ b /와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ece96fea144561ec8d240482b56438a3b8cd021" translate="yes" xml:space="preserve">
          <source>These subroutines are only visible within the block in which they are declared, and only after that declaration:</source>
          <target state="translated">이 서브 루틴은 선언 된 블록 내에서만 그리고 그 선언 후에 만 ​​볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5002f9badee48e82e2e716cfadae24bcbea4d597" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Level&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Level&lt;/code&gt; 옵션에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="de652943440f246885efed6bc50624dc94d59ab4" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Method&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Method&lt;/code&gt; 옵션에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ec9419fff6178cfe016f55595d7a90364f97f63" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Strategy&lt;/code&gt; option in the constructor.</source>
          <target state="translated">이 기호 상수는 생성자 의 &lt;code&gt;Strategy&lt;/code&gt; 옵션에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="09599ebf73a41d7f3fd327344d88fceb70681aab" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;flush&lt;/code&gt; method.</source>
          <target state="translated">이러한 기호 상수는 &lt;code&gt;flush&lt;/code&gt; 메소드에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="430e03746fb928435d7aa08e0e3eea945da77d4a" translate="yes" xml:space="preserve">
          <source>These symbols appear before the op-name, and indicate the B:: namespace that represents the ops in your Perl code.</source>
          <target state="translated">이 기호는 op- 이름 앞에 표시되며 Perl 코드에서 op를 나타내는 B :: 네임 스페이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2dbd7a997bbaaa84741a5e1fbd14e323c239d540" translate="yes" xml:space="preserve">
          <source>These terms are your choice of any of (1) the Perl Artistic Licence, or (2) version 2 of the GNU General Public License as published by the Free Software Foundation, or (3) any later version of the GNU General Public License.</source>
          <target state="translated">본 조건은 (1) Perl Artistic License 또는 (2) Free Software Foundation에서 게시 한 GNU General Public License 버전 2 또는 (3) 이후 버전의 GNU General Public License 중 하나를 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c298e17caacd4174da139fecae9a62cf22ed5cc" translate="yes" xml:space="preserve">
          <source>These tests are expected to succeed. Usually, most or all of your tests are in this category. If a normal test doesn't succeed, then that means that something is</source>
          <target state="translated">이 테스트는 성공할 것으로 예상됩니다. 일반적으로 대부분 또는 모든 테스트는이 범주에 속합니다. 정상적인 테스트가 성공하지 못하면</target>
        </trans-unit>
        <trans-unit id="07325952f04a521e228140b025365f61c44af25f" translate="yes" xml:space="preserve">
          <source>These three macros are used to change a memory buffer size or to free a piece of memory no longer needed. The arguments to &lt;code&gt;Renew&lt;/code&gt; and &lt;code&gt;Renewc&lt;/code&gt; match those of &lt;code&gt;New&lt;/code&gt; and &lt;code&gt;Newc&lt;/code&gt; with the exception of not needing the &quot;magic cookie&quot; argument.</source>
          <target state="translated">이 3 개의 매크로는 메모리 버퍼 크기를 변경하거나 더 이상 필요없는 메모리를 비우는 데 사용됩니다. 인수는하는 &lt;code&gt;Renew&lt;/code&gt; 및 &lt;code&gt;Renewc&lt;/code&gt; 은 의 그와 일치하는 &lt;code&gt;New&lt;/code&gt; 및 &lt;code&gt;Newc&lt;/code&gt; 은 &quot;마법 쿠키&quot;인수를 필요로하지 않은 것 이외에는.</target>
        </trans-unit>
        <trans-unit id="3b6ba4dd1926405bd4af1077435f09d7c0a86a11" translate="yes" xml:space="preserve">
          <source>These three macros are used to move, copy, or zero out previously allocated memory. The &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments point to the source and destination starting points. Perl will move, copy, or zero out &lt;code&gt;number&lt;/code&gt; instances of the size of the &lt;code&gt;type&lt;/code&gt; data structure (using the &lt;code&gt;sizeof&lt;/code&gt; function).</source>
          <target state="translated">이 세 매크로는 이전에 할당 된 메모리를 이동, 복사 또는 제로화하는 데 사용됩니다. &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;dest&lt;/code&gt; 인수는 소스 및 대상 시작 지점을 가리 킵니다. Perl은 &lt;code&gt;sizeof&lt;/code&gt; 함수를 사용하여 &lt;code&gt;type&lt;/code&gt; 데이터 구조 크기의 &lt;code&gt;number&lt;/code&gt; 인스턴스를 이동, 복사 또는 제로 아웃 합니다.</target>
        </trans-unit>
        <trans-unit id="335c760b89ccd866bd4e5cd7ec4e5ef4c599cbd4" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">이 두 개의 내보내기 태그는 bsd_glob () 및 Perl의 내장 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자 사용을 제외한 VMS를 제외하고 기본 플래그를 전체적으로 수정합니다 . &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 가 각각 켜져 있거나 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9660fc7e9efd93a7abe465c81de57e11a5045a23" translate="yes" xml:space="preserve">
          <source>These two features are available starting with Perl 5.16.</source>
          <target state="translated">이 두 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5480402538907c3c246c95ce18885b4ae5225b" translate="yes" xml:space="preserve">
          <source>These two handles are held in the array part of the GLOB until either &lt;code&gt;reader&lt;/code&gt; or &lt;code&gt;writer&lt;/code&gt; is called.</source>
          <target state="translated">이 두 핸들은 &lt;code&gt;reader&lt;/code&gt; 또는 &lt;code&gt;writer&lt;/code&gt; 가 호출 될 때까지 GLOB의 배열 부분에 보유됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0f87921e5dc8828d5a6d9ea360bbab6bf450027" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt; s:</source>
          <target state="translated">이 두 개의 하위 수준 매크로는 정의되어 있지만 &lt;code&gt;SV*&lt;/code&gt; 가 아닌 키를 처리 할 때만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca39330e5c20e1239e2de6584e211ecc882f376" translate="yes" xml:space="preserve">
          <source>These two methods are discussed in the section &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">이 두 가지 방법은 &quot;조회 실패 제어&quot;섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b5a74bc9d562e1d07daa7fdb3ddf9da715c3433" translate="yes" xml:space="preserve">
          <source>These two methods return the pad names, using B::SPECIAL objects for null pointers and B::PADNAME objects otherwise.</source>
          <target state="translated">이 두 메소드는 널 포인터에 B :: SPECIAL 오브젝트를 사용하고 그렇지 않으면 B :: PADNAME 오브젝트를 사용하여 패드 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="74ded97cfff6de6cbb1491c5e4159e3babfbcd36" translate="yes" xml:space="preserve">
          <source>These two parameters are used to specify the ambient pragmas in the format used by the special variables $^H and ${^WARNING_BITS}.</source>
          <target state="translated">이 두 매개 변수는 특수 변수 $ ^ H 및 $ {^ WARNING_BITS}에서 사용되는 형식으로 주변 pragma를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="668c2e486db55d10e5d748ec32a4297d24e80364" translate="yes" xml:space="preserve">
          <source>These two values for</source>
          <target state="translated">이 두 값은</target>
        </trans-unit>
        <trans-unit id="fded399d428f7e457d56603aa714f9152134fea1" translate="yes" xml:space="preserve">
          <source>These utilities help manage extra Perl modules that don't come with the perl distribution.</source>
          <target state="translated">이 유틸리티는 Perl 배포와 함께 제공되지 않는 추가 Perl 모듈을 관리하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="25a3a72bd29e8059a94921c647bd6ce419cc4377" translate="yes" xml:space="preserve">
          <source>These values will not change for the duration of the tied hash</source>
          <target state="translated">이 값은 연결된 해시 동안 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32b1d023c49a0c39aa9dd2f2164ec0cee979dc1b" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process.</source>
          <target state="translated">이러한 변수는 전체 프로세스에 대해 전역 적입니다. 프로세스의 모든 인터프리터와 모든 스레드간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="53f5ad69f1f855f312a7f31903221b231e10b532" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped, unless we note otherwise.</source>
          <target state="translated">달리 언급하지 않는 한 이러한 변수는 읽기 전용이며 동적 범위입니다.</target>
        </trans-unit>
        <trans-unit id="2a1de91c215bb3911b0f9767ad8cb63c7c66902f" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped.</source>
          <target state="translated">이러한 변수는 읽기 전용이며 동적 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c7b31baa2b679d0f632af8871cff4bfcc11fe664" translate="yes" xml:space="preserve">
          <source>These variables are used not only to represent Perl-space variables, but also any constants in the code, as well as some structures completely internal to Perl. The symbol table, for instance, is an ordinary Perl hash. Your code is represented by an SV as it's read into the parser; any program files you call are opened via ordinary Perl filehandles, and so on.</source>
          <target state="translated">이러한 변수는 Perl 공간 변수뿐만 아니라 코드의 상수 및 Perl 내부의 일부 구조를 나타내는 데 사용됩니다. 예를 들어, 심볼 테이블은 일반적인 Perl 해시입니다. 코드는 파서에서 읽을 때 SV로 표시됩니다. 호출하는 모든 프로그램 파일은 일반 Perl 파일 핸들 등을 통해 열립니다.</target>
        </trans-unit>
        <trans-unit id="82a728707d8b23d45f027d3109e809864b998b05" translate="yes" xml:space="preserve">
          <source>These variables determine the default state of the object created by calling the &lt;code&gt;new&lt;/code&gt; method, but cannot be used to alter the state of the object thereafter. The equivalent method names should be used instead to query or set the internal state of the object.</source>
          <target state="translated">이러한 변수는 &lt;code&gt;new&lt;/code&gt; 메소드 를 호출하여 작성된 오브젝트의 기본 상태를 판별 하지만 이후 오브젝트의 상태를 변경하는 데 사용할 수 없습니다. 대신 객체의 내부 상태를 쿼리하거나 설정하기 위해 동등한 메소드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="21d06b0dd7e2966bcc2949ad21cc8cf11e259059" translate="yes" xml:space="preserve">
          <source>These variables provide information about the current interpreter state.</source>
          <target state="translated">이 변수는 현재 인터프리터 상태에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ee1fe032de721a344cba89480c67e716abbee89" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the fopen(3) modes of &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , and &lt;code&gt;a+&lt;/code&gt; .</source>
          <target state="translated">이러한 다양한 접두사는 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;a+&lt;/code&gt; 의 fopen (3) 모드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ab874a84fee8b167d507adabcea364962ee19104" translate="yes" xml:space="preserve">
          <source>These vars take 3 forms:</source>
          <target state="translated">이 변수는 3 가지 형태를 취합니다.</target>
        </trans-unit>
        <trans-unit id="b607e9f6b449fd1b8f047ca8c774e440f540bc1c" translate="yes" xml:space="preserve">
          <source>These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">이 테스트는 Test :: More 0.82에서 출시되었으며, Test :: More 0.92의 일부로 5.10.1에서 Perl과 함께 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbff7e2745b850ca42a72fcb2a24d874bb4460d2" translate="yes" xml:space="preserve">
          <source>These will take care of 64-bit integers and long doubles. For example:</source>
          <target state="translated">이것들은 64 비트 정수와 long double을 처리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac19dfbee94adc36e2c9732558c6cd8eefc750a8" translate="yes" xml:space="preserve">
          <source>These will tell you if you truly have an integer, double, or string pointer stored in your SV. The &quot;p&quot; stands for private.</source>
          <target state="translated">SV에 실제로 정수, 이중 또는 문자열 포인터가 저장되어 있는지 알려줍니다. &quot;p&quot;는 개인을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01c10ede2ffed1b0b1b81928ac4993a2913e0a5d" translate="yes" xml:space="preserve">
          <source>These work as in normal strings.</source>
          <target state="translated">이것들은 일반 문자열에서와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="38675552ee022f79a520bb1f28a37d1e98aa3227" translate="yes" xml:space="preserve">
          <source>They all return true if the test passed, false if the test failed.</source>
          <target state="translated">테스트가 통과되면 모두 true를, 테스트가 실패하면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c3cf570334019dd16b6da35836503ad0b730443" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt; ), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">또한 전체 해시 항목 ( &lt;code&gt;HE*&lt;/code&gt; )을 반환 및 수락 하여보다 효율적으로 사용합니다 (특정 문자열의 해시 번호가 매번 다시 계산 될 필요가 없기 때문에). 자세한 설명 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25c349a57769dbafa1bf807ae04ad1d22921bb7" translate="yes" xml:space="preserve">
          <source>They are not exported and must be addressed using the full package name.</source>
          <target state="translated">이들은 내 보내지 않으며 전체 패키지 이름을 사용하여 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="82e0433b7d59191ca9d6b5b4f7f2c32e84b80d15" translate="yes" xml:space="preserve">
          <source>They are suspected to be compiler errors (at least the shuffle.t failure is known from some IRIX 6 setups) and math library errors (the Trig.t failure), but since IRIX 5 is long since end-of-lifed, further fixes for the IRIX are unlikely. If you can get gcc for 5.3, you could try that, too, since gcc in IRIX 6 is a known workaround for at least the shuffle.t and sort.t failures.</source>
          <target state="translated">컴파일러 오류 (적어도 shuffle.t 오류는 일부 IRIX 6 설정에서 알려짐) 및 수학 라이브러리 오류 (Trig.t 실패)로 의심되지만 IRIX 5는 수명이 다한 이후 오랫동안 수정되었으므로 추가 수정 IRIX는 거의 없습니다. 5.3의 gcc를 얻을 수 있다면 IRIX 6의 gcc는 적어도 shuffle.t 및 sort.t 오류에 대한 알려진 해결 방법이므로 시도해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69688ab534f08d7044475644301b479b2c0aa07a" translate="yes" xml:space="preserve">
          <source>They are type specifiers, as detailed in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perldata&quot;&gt;perldata에&lt;/a&gt; 자세히 설명 된대로 유형 지정자입니다 .</target>
        </trans-unit>
        <trans-unit id="e0af70f00dfa3e42a5613047a29fed35339f3d84" translate="yes" xml:space="preserve">
          <source>They come in handy when you want to print or find the size of data.</source>
          <target state="translated">인쇄하거나 데이터 크기를 찾을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="af45a4b37483f2a06205c7d3d09277fb7f496321" translate="yes" xml:space="preserve">
          <source>They differ in how they behave if they have the same key as the default metadata. META_ADD will override the default value with its own. META_MERGE will merge its value with the default.</source>
          <target state="translated">기본 메타 데이터와 동일한 키가있는 경우 동작 방식이 다릅니다. META_ADD는 기본값을 기본값으로 무시합니다. META_MERGE는 해당 값을 기본값과 병합합니다.</target>
        </trans-unit>
        <trans-unit id="38d5f7d4e163392c98f5f93a608be715596d63d6" translate="yes" xml:space="preserve">
          <source>They exist principally so that you can write code like:</source>
          <target state="translated">기본적으로 존재하므로 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7317b86bbf49f550672235cb05f34f1bf614569a" translate="yes" xml:space="preserve">
          <source>They may be deprecated in future versions.</source>
          <target state="translated">이후 버전에서는 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9f866ec06430c109794c0b11daa6f4be4c1816" translate="yes" xml:space="preserve">
          <source>They may be expecting something completely different.</source>
          <target state="translated">그들은 완전히 다른 것을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330c7e5216d53f5b33c24e5c7f8fd3d4ead54c44" translate="yes" xml:space="preserve">
          <source>They seem to be caused by broken system header files, and also other open source projects are seeing them. The following HP-UX patches should make the warnings go away:</source>
          <target state="translated">시스템 헤더 파일이 손상되어 발생하는 것으로 보이며 다른 오픈 소스 프로젝트에서도 볼 수 있습니다. 다음 HP-UX 패치는 경고를 사라지게합니다.</target>
        </trans-unit>
        <trans-unit id="b797d5622b1d1393375da6062407cd69c0ce1eae" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">그것들은 프로그램의 컴파일에 영향을 미치는 경향이 있다는 점에서 컴파일러 지시문 (pragmata)과 다소 유사하므로 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 내에 사용될 때만 잘 작동합니다 . 이것들의 대부분은 어휘 범위가 있으므로 내부 블록은 다음과 같이 말함으로써 그들을 반박 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6abf5248bc6675a47a3988cb21c2af942a4be9d1" translate="yes" xml:space="preserve">
          <source>They works like the same name operators as theirs.</source>
          <target state="translated">그들은 그들과 같은 이름 연산자처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dd7133f0a4178555cc80821515a5b2265342ef9d" translate="yes" xml:space="preserve">
          <source>They're opcode specific, and occur less often than the public ones, so they're represented by short mnemonics instead of single-chars; see B::Op_private and</source>
          <target state="translated">그것들은 오피 코드에 따라 다르며, 공개 코드보다 덜 자주 발생하므로 단일 문자 대신 짧은 니모닉으로 표시됩니다. B :: Op_private 및</target>
        </trans-unit>
        <trans-unit id="c1537a4a381e27d6bdd2214d8f21c4c16bc119e0" translate="yes" xml:space="preserve">
          <source>Things that are broken or just don't work quite right.</source>
          <target state="translated">깨지거나 제대로 작동하지 않는 것들.</target>
        </trans-unit>
        <trans-unit id="731699b64ef1b2479598864f867653535a2b0bbe" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">Perl을 더 쉽게 배울 수있는 것 : 유닉스 경험, 거의 모든 종류의 프로그래밍 경험, 정규 표현식에 대한 이해 및 다른 사람들의 코드를 이해하는 능력. 당신이해야 할 일이 있다면, 이미 완료되었을 것입니다. 작업 예제는 일반적으로 무료로 제공됩니다. Perl 모듈도 잊지 마십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt; 과 함께이 FAQ의 3 부에서 논의되고 2 부에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9717c58dca00ca4e0fdd51bb342bee53c9f4f98" translate="yes" xml:space="preserve">
          <source>Things that need to be done to improve this document.</source>
          <target state="translated">이 문서를 개선하기 위해 수행해야 할 사항.</target>
        </trans-unit>
        <trans-unit id="8bbe6bf4aeb5dea432e939ae88abe2437f8000be" translate="yes" xml:space="preserve">
          <source>Things to take special care with, sometimes called WARNINGS.</source>
          <target state="translated">경고라고도하는 특별한주의 사항.</target>
        </trans-unit>
        <trans-unit id="f330d2b9426f91894c132eec7839a297e7c3f2bb" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (or &lt;b&gt;-w&lt;/b&gt;) in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">재사용 가능성에 대해 생각하십시오. 다시 같은 일을하고 싶을 때 왜 원샷에서 두뇌를 낭비 하는가? 코드를 일반화하십시오. 모듈 또는 객체 클래스 작성을 고려하십시오. 깨끗하게 코드 실행을 고려해 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (또는 &lt;b&gt;-w&lt;/b&gt; 효과). 코드를 제공하는 것을 고려하십시오. 전체 세계관을 바꾸는 것을 고려하십시오. 생각 해봐 ... 오, 괜찮아</target>
        </trans-unit>
        <trans-unit id="369cf00ca2016a53c53652dbdfad94b27946d096" translate="yes" xml:space="preserve">
          <source>Think carefully about whether OO is appropriate for your module. Gratuitous object orientation results in complex APIs which are difficult for the average module user to understand or use.</source>
          <target state="translated">OO가 모듈에 적합한 지 신중하게 생각하십시오. 과도한 객체 지향은 복잡한 API를 생성하여 일반 모듈 사용자가 이해하거나 사용하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="d05ca6e0d80ee8bcc4977d0ae97da44f7a9ad4e9" translate="yes" xml:space="preserve">
          <source>Think of these macros as working a bit like &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; in Perl to limit the scope of local variables.</source>
          <target state="translated">이 매크로 를 로컬 변수의 범위를 제한하기 위해 Perl에서 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 와 같이 작동하는 것으로 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="b798a2f7f99599171fc59b43924703f9a2be020d" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. You have been warned!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 와 스레드 를 혼합 할 생각 입니까? 누워서 느낌이 지나갈 때까지 기다리십시오. &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 의 의미는 플랫폼마다 다릅니다. 예를 들어, 일부 유닉스 시스템은 모든 현재 스레드를 자식 프로세스에 복사하는 반면 다른 시스템은 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 라는 스레드 만 복사합니다 . 경고를 받았습니다!</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="3b8ab74e7f407ff0613b1e22c57e79a02a3a70ca" translate="yes" xml:space="preserve">
          <source>This 'cheat sheet' is a handy reference, meant for beginning Perl programmers. Not everything is mentioned, but 195 features may already be overwhelming.</source>
          <target state="translated">이 '치트 시트'는 Perl 프로그래머를 시작하기위한 편리한 참고 자료입니다. 모든 것이 언급되어 있지는 않지만 195 개의 기능이 이미 압도적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449deebd32ed5eaf74d8aec8711aa290af1210b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is somewhat like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt; . However, whilst the C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;). A more C-like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (see above).</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 는 읽기와 반대되는 점에서 C에서 발견 된 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 와 다소 비슷 합니다. perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수 의 랩퍼 는 &lt;code&gt;format_write&lt;/code&gt; 라고 합니다 . 그러나 C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수는 쓴 바이트 수를 반환 하지만 이 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 함수는 성공하면 (예 : &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ) true를 반환합니다 . 보다 C와 유사한 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="809a4dea69e66cbb56a6927382a1c7747ff2b245" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POSIX::SigAction&lt;/code&gt; object is intended for use with the &lt;code&gt;POSIX::sigaction()&lt;/code&gt; function.</source>
          <target state="translated">이 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 객체는 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 함수 와 함께 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8a5e4636d7ee396c2538c58facc6d68cb4eb415b" translate="yes" xml:space="preserve">
          <source>This CPAN module lets you create application-level DTrace probes written in Perl.</source>
          <target state="translated">이 CPAN 모듈을 사용하면 Perl로 작성된 애플리케이션 레벨 DTrace 프로브를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="511e2864753cd52a1ebcc75d7881ce1d9fb8ec6b" translate="yes" xml:space="preserve">
          <source>This DBM filter allows you to choose the character encoding will be store in the DBM file. The usage is</source>
          <target state="translated">이 DBM 필터를 사용하면 DBM 파일에 저장 될 문자 인코딩을 선택할 수 있습니다. 사용법은</target>
        </trans-unit>
        <trans-unit id="8d6cf7bbaf015be1842a3503d362b5db206d9719" translate="yes" xml:space="preserve">
          <source>This DBM filter is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">이 DBM 필터는 C int를 DBM 파일의 키 및 / 또는 값으로 사용하는 C / C ++ 애플리케이션과 상호 운용 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9afd96c4f0113b4f4a0ca24ef6b7ce1c1eceace" translate="yes" xml:space="preserve">
          <source>This DBM filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">이 DBM 필터는 데이터베이스에 기록되기 전에 모든 데이터를 압축하고 읽을 때 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b3c940c7a493363dfcc2ec46854ae2f8bf461ebc" translate="yes" xml:space="preserve">
          <source>This Filter will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">이 필터는 DBM에 기록 된 모든 데이터가 UTF-8로 인코딩되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc3e8623db78291ea4659afa55c27a0af1b2fdc1" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getaddrinfo() or inet_pton() instead for IPv6 support.</source>
          <target state="translated">이 IPv4 전용 기능은 대부분 레거시 이유로 제공됩니다. 새로 작성된 코드는 IPv6 지원 대신 getaddrinfo () 또는 inet_pton ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1b8940a7dbf27c2770dc1f730a7a76eb668b365" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getnameinfo() or inet_ntop() instead for IPv6 support.</source>
          <target state="translated">이 IPv4 전용 기능은 대부분 레거시 이유로 제공됩니다. 새로 작성된 코드는 IPv6 지원 대신 getnameinfo () 또는 inet_ntop ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="722a81c183f099f4bcdf928fea77c08691faed91" translate="yes" xml:space="preserve">
          <source>This MGVTBL structure is set at compile-time in</source>
          <target state="translated">이 MGVTBL 구조는 컴파일 타임에</target>
        </trans-unit>
        <trans-unit id="d239471597c0b244a6c849bc4b21df8bfaf5b7db" translate="yes" xml:space="preserve">
          <source>This PerlIO layer opens a filehandle with a transparent encoding filter.</source>
          <target state="translated">이 PerlIO 레이어는 투명한 인코딩 필터로 파일 핸들을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a75ec57aa7be5f3e457676aa78fd87835feef6b5" translate="yes" xml:space="preserve">
          <source>This README was written by Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;, and subsequently updated by Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; and Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;. The &quot;Starting From Scratch&quot; recipe was contributed by John Montbriand &amp;lt;montbriand@apple.com&amp;gt;.</source>
          <target state="translated">이 읽어보기는 Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;에 의해 작성되었으며 이후 Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; 및 Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;에 의해 업데이트되었습니다. &quot;스크래치에서 시작&quot;레시피는 John Montbriand &amp;lt;montbriand@apple.com&amp;gt;에서 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="ebd95c4f5ef4e4618995d165e48685abb75f4895" translate="yes" xml:space="preserve">
          <source>This TODO</source>
          <target state="translated">이 TODO</target>
        </trans-unit>
        <trans-unit id="65401762a1d1713b0f2418936baae5413a27fffb" translate="yes" xml:space="preserve">
          <source>This UTF8 flag is not visible in Perl scripts, exactly for the same reason you cannot (or rather, you</source>
          <target state="translated">이 UTF8 플래그는 Perl 스크립트에서 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4052f785cdabbfe61b3039b9711ade7bde52e516" translate="yes" xml:space="preserve">
          <source>This a copy of the $md5 object. It is useful when you do not want to destroy the digests state, but need an intermediate value of the digest, e.g. when calculating digests iteratively on a continuous data stream. Example:</source>
          <target state="translated">이것은 $ md5 객체의 복사본입니다. 다이제스트 상태를 제거하고 싶지 않지만 다이제스트의 중간 값이 필요한 경우 (예 : 연속 데이터 스트림에서 다이제스트를 반복적으로 계산할 때) 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="80e3860a781a3958ead624c7605f67461e6feac0" translate="yes" xml:space="preserve">
          <source>This action at a distance can be confusing, so you should be careful with your use of weaken. You should weaken the reference in the variable that will go out of scope</source>
          <target state="translated">멀리서이 동작은 혼동 될 수 있으므로 약화 사용에주의해야합니다. 범위를 벗어날 변수의 참조를 약화시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="31854231243bab283e1b65fbafa450794c35d551" translate="yes" xml:space="preserve">
          <source>This affects the &quot;udp&quot;, &quot;tcp&quot;, and &quot;syn&quot; protocols.</source>
          <target state="translated">이는 &quot;udp&quot;, &quot;tcp&quot;및 &quot;syn&quot;프로토콜에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="873bbf87a172d66b10ad3b61904a0d639ca9b860" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt; . See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">이를 통해 Math :: BigInt는 &lt;code&gt;$SubClass::precision&lt;/code&gt; 과 같은 서브 클래스에서 패키지 글로벌을 올바르게 검색 할 수 있습니다 . t / Math / BigInt / Subclass.pm 또는 t / Math / BigFloat / SubClass.pm 완전 기능 서브 클래스 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5501a126d7bcccb962537b6328418e9a9cd85d" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; , and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">이를 통해 사용자는 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 및 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 디렉토리를 사용하여 일부 소프트웨어의 디렉토리 트리를 설정할 수 있으며 , 위의 예에서는 소프트웨어 트리의 설치 위치를 모르고 lib 디렉토리에서 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d1ac05408a326c089b0ec60746ba54464b2076" translate="yes" xml:space="preserve">
          <source>This allows for a more traditional use of sockatmark() as a procedural socket function. If your system does not support sockatmark(), the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="translated">이렇게하면 절차 적 소켓 함수로 sockatmark ()를보다 전통적인 방식으로 사용할 수 있습니다. 시스템이 sockatmark ()를 지원하지 않으면 컴파일시 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 선언이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c4bf55b527390af875f220a6a455b96b2cc2be5" translate="yes" xml:space="preserve">
          <source>This allows one to specify the</source>
          <target state="translated">이것은 하나를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dd0d07d0d3a6167b29dae996bfd8a33bb4d04031" translate="yes" xml:space="preserve">
          <source>This allows the ability to provide an extra pointer (called the &quot;host&quot; environment) for all the system calls. This makes it possible for all the system stuff to maintain their own state, broken down into seven C structures. These are thin wrappers around the usual system calls (see</source>
          <target state="translated">이를 통해 모든 시스템 호출에 대해 추가 포인터 ( &quot;호스트&quot;환경이라고 함)를 제공 할 수 있습니다. 이를 통해 모든 시스템 요소가 7 개의 C 구조로 분류 된 자체 상태를 유지할 수 있습니다. 이것들은 일반적인 시스템 호출을 둘러싼 얇은 래퍼입니다 (참조</target>
        </trans-unit>
        <trans-unit id="f2d9de12c87f7e2eb33ce435c5af882982d468fe" translate="yes" xml:space="preserve">
          <source>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</source>
          <target state="translated">이를 통해 엔진은 개인 데이터를 제거 할 수 있지만 필요한 경우 최종 구조를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="afb3f86b59b2eab9a83b014b190ee8244b9d77c6" translate="yes" xml:space="preserve">
          <source>This allows the programmer to look at the execution stack and variables to find out the cause of the exception. As the debugger is being invoked as the Perl interpreter is about to do a fatal exit, continuing the execution in debug mode is usually not practical.</source>
          <target state="translated">이를 통해 프로그래머는 예외의 원인을 찾기 위해 실행 스택과 변수를 볼 수 있습니다. Perl 인터프리터가 치명적인 종료를 수행하려고 할 때 디버거가 호출되므로 디버그 모드에서 실행을 계속하는 것은 일반적으로 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1baefaa51fc7ed599ce445dad500d37cb72bf43c" translate="yes" xml:space="preserve">
          <source>This allows you to add a prefix to the backup file, instead of (or in addition to) a suffix:</source>
          <target state="translated">이를 통해 접미사 대신 또는 접미사를 백업 파일에 접두사를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e47154414d862007ad5f643f15fef0b3978ca2c" translate="yes" xml:space="preserve">
          <source>This allows you to intermix your source code and your documentation text freely, as in</source>
          <target state="translated">따라서 소스 코드와 문서 텍스트를 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e637a731a56d0d223f91be743e436a188835e3" translate="yes" xml:space="preserve">
          <source>This allows you to pass a reference to a scalar, in which the data will be stored:</source>
          <target state="translated">이를 통해 데이터가 저장 될 스칼라에 대한 참조를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae11cd12869687833116af8fabb9e16d79564d09" translate="yes" xml:space="preserve">
          <source>This allows you to specify &lt;code&gt;constants&lt;/code&gt; in your template. ie, they keys that are not allowed to be altered by the user. It pretty much allows you to keep all your &lt;code&gt;configurable&lt;/code&gt; data in one place; the &lt;code&gt;Params::Check&lt;/code&gt; template.</source>
          <target state="translated">이를 통해 템플릿에서 &lt;code&gt;constants&lt;/code&gt; 를 지정할 수 있습니다 . 즉, 사용자가 변경할 수없는 키입니다. &lt;code&gt;configurable&lt;/code&gt; 모든 데이터를 한 곳에 보관할 수 있습니다 . &lt;code&gt;Params::Check&lt;/code&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="ec9cd2ea84115168b54e6b0797c0f572af954da0" translate="yes" xml:space="preserve">
          <source>This almost definitely doesn't do what you expect:</source>
          <target state="translated">이것은 거의 당신이 기대하는 것을하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="5ba2015dbd8b7d90bb6da319e60421ccbe89f224" translate="yes" xml:space="preserve">
          <source>This also applies to integers that look like floating point constants:</source>
          <target state="translated">부동 소수점 상수처럼 보이는 정수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="636185aa1476a4214e4b7454bccd1f721aa5d7e5" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">이것도 비슷하게 동작하지만 &lt;code&gt;$_&lt;/code&gt; 대신 어휘 변수에 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="77df2183cb5ed8fa6c016243494c2444f23d3c09" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">또한 XS AUTOLOAD 하위 시스템과 함께 특수하게 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts에서 XSUB로 자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3d548e6c0ea6757b5bd736b5e0dc177ac6e6019" translate="yes" xml:space="preserve">
          <source>This also has implications for the use of the SUPER:: qualifier (see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;).</source>
          <target state="translated">이것은 또한 SUPER :: 한정자를 사용하는 데 영향을 미칩니다 ( &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f8da07f35c437fa97e844be13f7f26224b7e80d0" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">이것은 또한 $ x의 실제 내용이 예상치 못한 것일 수 있기 때문에 특정 패키지를 확인하는 것은 나쁜 생각임을 의미합니다. bignum의 투명한 방식으로 인해 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f046ba2ed5c45f32bb7d779ddd434216adcb9e9" translate="yes" xml:space="preserve">
          <source>This also means that a first argument hash reference now becomes the second argument:</source>
          <target state="translated">이것은 또한 첫 번째 인수 해시 참조가 이제 두 번째 인수가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53e0f20ff4a10e2905e391319be8b9814ea5ca78" translate="yes" xml:space="preserve">
          <source>This also returns the file format version. If the version is &quot;2.7&quot; then major would be 2 and minor would be 7. The minor element is missing for when major is less than 2.</source>
          <target state="translated">파일 형식 버전도 반환합니다. 버전이 &quot;2.7&quot;이면 major는 2이고 minor는 7입니다. major가 2보다 작 으면 minor 요소가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="61c52be3ac150c6eed66b2a1ead6f0d851e682d3" translate="yes" xml:space="preserve">
          <source>This also works for other subclasses, like Math::String.</source>
          <target state="translated">Math :: String과 같은 다른 하위 클래스에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8468a87cfa0204ff52a567b1eaf4b66d1ee547eb" translate="yes" xml:space="preserve">
          <source>This always means your main memory, not your disk. Clouding the issue is the fact that your machine may implement &lt;b&gt;virtual&lt;/b&gt; memory; that is, it will pretend that it has more memory than it really does, and it&amp;rsquo;ll use disk space to hold inactive bits. This can make it seem like you have a little more memory than you really do, but it&amp;rsquo;s not a substitute for real memory. The best thing that can be said about virtual memory is that it lets your performance degrade gradually rather than suddenly when you run out of real memory. But your program can die when you run out of virtual memory, too&amp;mdash;if you haven&amp;rsquo;t thrashed your disk to death first.</source>
          <target state="translated">이것은 항상 디스크가 아닌 기본 메모리를 의미합니다. 문제를 흐리게하면 시스템이 &lt;b&gt;가상&lt;/b&gt; 메모리를 구현할 수 있다는 사실입니다 . 즉, 실제보다 많은 메모리가있는 것으로 가장하고 디스크 공간을 사용하여 비활성 비트를 보유합니다. 이렇게하면 실제 메모리보다 약간 더 많은 메모리가있는 것처럼 보일 수 있지만 실제 메모리를 대신 할 수는 없습니다. 가상 메모리에 대해 말할 수있는 가장 좋은 점은 실제 메모리가 부족할 때 갑자기 성능이 떨어지지 않고 점차적으로 성능이 저하된다는 것입니다. 그러나 디스크를 먼저 쓰러 뜨리지 않은 경우 가상 메모리가 부족 해지면 프로그램이 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="165f78228b9bb880f61927fda978ad6714cce456" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">이 예외는 Perl의 유니 코드 지원을 완벽하게 추가하려는 Perl의 요구와 함께, 유니 코드를 사용하지 않은 오래된 프로그램을 방해하지 않으려는 시도에서 비롯됩니다. 그러나 결과는 완벽하지 않은 것으로 판명되었습니다. (이러한 상황이 발생하면 경고를 받도록 선택할 수 있습니다. &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8c246570729105a65f6bd289985b0b62d1e1f94f" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt; , and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; .</source>
          <target state="translated">이것은 perl 5.10.0에 나타났습니다. &lt;code&gt;\K&lt;/code&gt; 왼쪽에 일치하는 것은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함 되지 않으며 패턴이 대체에 사용되는 경우 대체되지 않습니다. 이를 통해 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 또는 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 대신 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 를 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e79001ab117c0cf333336e9232ddbb9a00de3d" translate="yes" xml:space="preserve">
          <source>This applies equally to method names, parameter names, and anything else which is visible to the user (and most things that aren't!)</source>
          <target state="translated">이것은 메서드 이름, 매개 변수 이름 및 사용자에게 표시되는 모든 항목 (및 보이지 않는 것)에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70dd8476567c22ea231857d01ff4db7f81b73be8" translate="yes" xml:space="preserve">
          <source>This applies only to lexical variables, by the way. Dynamic variables continue to work as they have always worked. Closure is not something that most Perl programmers need trouble themselves about to begin with.</source>
          <target state="translated">이것은 어휘 변수에만 적용됩니다. 동적 변수는 항상 작동 한대로 계속 작동합니다. 클로저는 대부분의 Perl 프로그래머가 처음부터 어려움을 겪어야하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4e13602141364999d0474f62de688119ccaf7274" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</source>
          <target state="translated">이것은 perlio 시스템에만 적용됩니다. 5.7 이전 버전의 경우, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 에 해당 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88ab6b9c73082204ae0542a65f9bf2f5c23ef207" translate="yes" xml:space="preserve">
          <source>This approach also works for comparing hashes. Here we'll demonstrate two different answers:</source>
          <target state="translated">이 방법은 해시를 비교할 때도 효과적입니다. 다음은 두 가지 다른 답변을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="684f52e2ad132a8d50a850505a18c8cf67adca2e" translate="yes" xml:space="preserve">
          <source>This approach makes it comparatively easy to write code preprocessors without worrying about the form or contents of strings, regexes, etc.</source>
          <target state="translated">이 방법을 사용하면 문자열, 정규식 등의 형식이나 내용에 대해 걱정하지 않고 코드 전처리기를 비교적 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21941c4a2190129983b70fab8729b6e9162dfa7f" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">객체 연산자 호출과 같은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 처리 방식은 다이아몬드 연산자에는 적용되지 않습니다. 쉼표가없는 인수 만있는 함수가 아니라 실제 연산자이기 때문입니다. 위에서와 같이 구조에 typeglob를 저장했다고 가정하면 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 이라는 내장 함수를 사용하여 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 처럼 레코드를 읽을 수 있습니다. 위의 @fd에 대한 초기화가 주어지면 readline ()에 typeglob가 필요하기 때문에 작동합니다. 객체 또는 문자열에는 작동하지 않습니다. 아직 수정하지 않은 버그 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95f50481ff3516b07bb9d7865830ab6c1ff5648" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the beginnings of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$-[0]&lt;/code&gt; is the offset into the string of the beginning of the entire match. The</source>
          <target state="translated">이 배열은 현재 활성화 된 동적 범위에서 마지막으로 성공한 부분 일치의 시작 오프셋을 유지합니다. &lt;code&gt;$-[0]&lt;/code&gt; 은 전체 일치의 시작 부분에 대한 오프셋입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="e96381bdcc284e80585b7b54b1e289040c1f9efb" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">이 배열은 현재 활성화 된 동적 범위에서 마지막으로 성공한 부분 일치의 끝 오프셋을 유지합니다. &lt;code&gt;$+[0]&lt;/code&gt; 은 전체 일치의 끝 문자열에 대한 오프셋입니다. 이는 일치하는 변수에서 호출 될 때 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 함수가 리턴 하는 것과 동일한 값 입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="de9df0444460b118bc16cc7a6647d43831c503da" translate="yes" xml:space="preserve">
          <source>This array of function pointers is a convenient place to hook into the compilation process. An XS module can put its own custom check function in place of any of the standard ones, to influence the compilation of a particular type of op. However, a custom check function must never fully replace a standard check function (or even a custom check function from another module). A module modifying checking must instead &lt;b&gt;wrap&lt;/b&gt; the preexisting check function. A custom check function must be selective about when to apply its custom behaviour. In the usual case where it decides not to do anything special with an op, it must chain the preexisting op function. Check functions are thus linked in a chain, with the core's base checker at the end.</source>
          <target state="translated">이 함수 포인터 배열은 컴파일 프로세스에 연결하기 편리한 위치입니다. XS 모듈은 표준 유형 대신 고유 한 사용자 정의 검사 기능을 배치하여 특정 유형의 op를 컴파일하는 데 영향을 줄 수 있습니다. 그러나 사용자 정의 검사 기능은 표준 검사 기능 (또는 다른 모듈의 사용자 정의 검사 기능)을 완전히 대체해서는 안됩니다. 대신 모듈 수정 검사는 기존 검사 기능을 &lt;b&gt;래핑&lt;/b&gt; 해야합니다 . 사용자 정의 검사 기능은 사용자 정의 동작을 적용 할시기에 대해 선택적이어야합니다. op와 관련하여 특별한 작업을 수행하지 않기로 결정한 일반적인 경우에는 기존 op 기능을 연결해야합니다. 따라서 체크 기능은 체인의 기본베이스 체커와 끝에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="b8dc273368b99545f08bf93846a0eeb46f2d8f07" translate="yes" xml:space="preserve">
          <source>This article is about a little-known feature of Perl called</source>
          <target state="translated">이 기사는 Perl의 작은 알려진 기능에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="31e9f3bedf523d7ebb982ebf37f1569db684a386" translate="yes" xml:space="preserve">
          <source>This article originally appeared in</source>
          <target state="translated">이 기사는 원래</target>
        </trans-unit>
        <trans-unit id="290ae5b40be8703f5e688eadedc6451a7fcb95b4" translate="yes" xml:space="preserve">
          <source>This article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 원래 Perl Journal # 11에 실 렸으며 1998 년 저작권 Perl Journal에 저작권이 있습니다. Jon Orwant와 Perl Journal이 제공 한 것으로 보입니다. 이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5ced083e00b961f0ed9ea00cb4d87f96f2e0533" translate="yes" xml:space="preserve">
          <source>This assertion may be used as the condition in a</source>
          <target state="translated">이 주장은 다음 조건에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0000b51c42222ffe097e200394d62769ca419cbc" translate="yes" xml:space="preserve">
          <source>This assumes that we saw the locale &quot;en_US.ISO8859-1&quot; using the commands discussed above. We decided to try that instead of the above faulty locale &quot;En_US&quot;--and in Cshish shells (&lt;b&gt;csh&lt;/b&gt;, &lt;b&gt;tcsh&lt;/b&gt;)</source>
          <target state="translated">위에서 설명한 명령을 사용하여 로캘 &quot;en_US.ISO8859-1&quot;을 본 것으로 가정합니다. 위의 잘못된 로케일 &quot;En_US&quot;대신 Cshish 쉘 ( &lt;b&gt;csh&lt;/b&gt; , &lt;b&gt;tcsh&lt;/b&gt; ) 에서 시도하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="c0dee2f933f09058dd9bf3765b7f846ec57f52d7" translate="yes" xml:space="preserve">
          <source>This attribute is not a search parameter, but is used to report the result of &lt;code&gt;survey&lt;/code&gt; method, as discussed in the next section.</source>
          <target state="translated">이 속성은 검색 매개 변수는 아니지만 다음 섹션에서 설명하는 것처럼 &lt;code&gt;survey&lt;/code&gt; 방법 의 결과를보고하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c687ced37405f8cf67c894463cfe3d86f5b0e65" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. It is currently only used by OS/2 and Win32.</source>
          <target state="translated">이 속성은 확장으로 가져올 이름을 지정하는 데 사용됩니다. 현재 OS / 2 및 Win32에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e8362900ead72447d5c4ebf2182285972d3847" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. Takes a hash ref.</source>
          <target state="translated">이 속성은 확장으로 가져올 이름을 지정하는 데 사용됩니다. 해시 참조를받습니다.</target>
        </trans-unit>
        <trans-unit id="767e4d21fb47d7f73037ece0977c12a97d29d46d" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL EXCLUDE_EXT='Socket Safe'</source>
          <target state="translated">이 속성은 명령 행에 문자열로 지정 될 때 가장 유용합니다. perl Makefile.PL EXCLUDE_EXT = 'Socket Safe'</target>
        </trans-unit>
        <trans-unit id="79f89eca0caacc11c08af6c151f34570659a105e" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'</source>
          <target state="translated">이 속성은 명령 행에서 문자열로 지정 될 때 가장 유용 할 수 있습니다. perl Makefile.PL INCLUDE_EXT = 'POSIX Socket Devel :: Peek'</target>
        </trans-unit>
        <trans-unit id="f063de8522828eff3b84027f3f1f4329111a6d6f" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt; .)</source>
          <target state="translated">이 속성은이 검색에서 일치하는 포드 파일을 볼 때마다이 콜백 루틴을 호출해야 함을 의미합니다. 루틴은 현재 파일의 파일 스펙과 포드 이름이라는 두 개의 매개 변수로 호출됩니다. (예 : &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 는 &lt;code&gt;@_&lt;/code&gt; 에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d1d55a165f99ccc6289583795c82aceb24ceabae" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false, meaning that no callback is called.</source>
          <target state="translated">이 속성의 기본값은 false이며 콜백이 호출되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bcee703f93ae24f2cb5be27baf6a28edef44800c" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false; and normally you won't need to turn it on.</source>
          <target state="translated">이 속성의 기본값은 false입니다. 일반적으로 전원을 켤 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="56b03f0333e5f7d53de3d13aaa7c296581e96eb6" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">이 속성이 0이 아닌 양수 값으로 설정되면 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 통해 검색 결과에 수행 한 작업에 대한 메모를 표시합니다. 이 옵션은 포드 관련 모듈을 디버깅하는 데 유용 할 수 있습니다. 이 속성의 기본값은 0이며, &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 메시지가 생성 되지 않음을 의미합니다 . (자세한 내용을 1로 설정하면 일부 메시지가 켜지고 2로 설정하면 더 많은 메시지가 나타납니다. 즉, 다음 검색이 1보다 더 자세한 정보가됩니다.)</target>
        </trans-unit>
        <trans-unit id="9a5ab376fb5b92c88b226665b3b3189f69774bb5" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a true value, means that searches should implicitly add perl's</source>
          <target state="translated">이 속성이 true 값으로 설정된 경우 검색에서 암시 적으로 perl을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="b39a84ee1b444ad72be8b273ce2aa43be2362f55" translate="yes" xml:space="preserve">
          <source>This behavior can be overridden by supplying your own set of files to search. PL_FILES accepts a hash ref, the key being the file to run and the value is passed in as the first argument when the PL file is run.</source>
          <target state="translated">검색 할 파일 세트를 제공하여이 동작을 무시할 수 있습니다. PL_FILES는 해시 참조를 허용합니다. 키는 실행할 파일이며 PL 파일이 실행될 때 값이 첫 번째 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="31de598976c4af9df58fa731498e0e725fcefe91" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; modifiers. &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">이 동작은 편리합니다. 일반적으로 한 줄의 문자를 세고 일치시킬 때 줄 바꿈을 무시하려고합니다. 그러나 때때로 우리는 줄 바꿈을 추적하려고합니다. 심지어 문자열의 시작과 끝이 아니라 문자열 내에서 줄의 시작과 끝에 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 고정 되기를 원할 수도 있습니다 . Perl을 사용하면 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 수정자를 사용하여 개행을 무시하고주의를 기울일 수 있습니다. &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 은 한 줄과 여러 줄을 나타내며 문자열을 하나의 연속 문자열로 취급할지 또는 줄 집합으로 취급할지 결정합니다. 두 수정자는 정규 표현식이 해석되는 방식의 두 가지 측면에 영향을 미칩니다. 1) &lt;code&gt;'.'&lt;/code&gt; 문자 클래스가 정의되며 2) 앵커 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 일치 할 수있는 위치입니다. 가능한 네 가지 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d6ebadd3063ef053971debc9b4e78f1e936126e" translate="yes" xml:space="preserve">
          <source>This behavior is more &quot;Do what I mean&quot; than in earlier Perls for most applications. But it catches fewer issues for code that needs to be strictly Unicode compliant. Therefore there is an additional mode of operation available to accommodate such code. This mode is enabled if a regular expression pattern is compiled within the lexical scope where the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; warning class has been made fatal, say by:</source>
          <target state="translated">이 동작은 대부분의 응용 프로그램에서 이전 Perls보다 &quot;의미있는 것&quot;입니다. 그러나 엄격하게 유니 코드를 준수 해야하는 코드의 문제는 적습니다. 따라서 이러한 코드를 수용 할 수있는 추가 작동 모드가 있습니다. &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 경고 클래스가 치명적인 어휘 범위 내에서 정규식 패턴이 컴파일 된 경우이 모드가 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="092eaaecfde2fe8092e286b99e012b8ea81cec11" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 동작은 기존 VMS 동작이 아닌 POSIX 동작과 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="353b3ac3017572fed965aadb9e085377b2c9e20d" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma.</source>
          <target state="translated">이 동작은 어휘 범위 지정의 의미를 제공하며, 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="902d9db5da6a9d0d90bec88dd7435e3d3036822b" translate="yes" xml:space="preserve">
          <source>This behaviour is identical to that of the actual compiler.</source>
          <target state="translated">이 동작은 실제 컴파일러와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fd9ffc9da0934423cf7a8b2a8167c734225e00ac" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">dbm (3), ndbm (3), sdbm (3), gdbm (3) 또는 Berkeley DB 파일을 해시에 바인딩합니다. 해시는 해시의 이름입니다. (일반적인 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 과 달리 첫 번째 인수는</target>
        </trans-unit>
        <trans-unit id="2616a24dba48e4df35dec143fa3cabdfd81fd386" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">dbm (3), ndbm (3), sdbm (3), gdbm (3) 또는 Berkeley DB 파일을 해시에 바인딩합니다. 해시는 해시의 이름입니다. (일반적인 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 과 달리 첫 번째 인수는</target>
        </trans-unit>
        <trans-unit id="a6324526e82c2b2028f79347525bf2bc78810ebd" translate="yes" xml:space="preserve">
          <source>This block modifies all the &lt;code&gt;.c&lt;/code&gt; files in the current directory, leaving a backup of the original data from each file in a new &lt;code&gt;.c.orig&lt;/code&gt; file.</source>
          <target state="translated">이 블록 은 현재 디렉토리의 모든 &lt;code&gt;.c&lt;/code&gt; 파일을 수정 하여 각 파일의 원본 데이터를 새 &lt;code&gt;.c.orig&lt;/code&gt; 파일로 백업 합니다.</target>
        </trans-unit>
        <trans-unit id="ba453fd403a510bef4a413f0d9ec2dc3165244e0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt; , it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">이 상용구는 로우 오버 헤드 &lt;code&gt;XSLoader&lt;/code&gt; 가있는 경우 이를 사용합니다 . &lt;code&gt;XSLoader&lt;/code&gt; 가없는 앤티크 Perl과 함께 사용하면 &lt;code&gt;DynaLoader&lt;/code&gt; 를 사용 하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="090e5f02457ce14eed85483c0b931f07be2bd405" translate="yes" xml:space="preserve">
          <source>This bug only affects closures that are generated by the block but used afterwards. Lexical variables that are only used during the lifetime of the block's execution will take their individual values for each invocation, as normal.</source>
          <target state="translated">이 버그는 블록에 의해 생성되었지만 나중에 사용되는 클로저에만 영향을줍니다. 블록의 실행 수명 동안에 만 사용되는 어휘 변수는 정상적으로 각 호출에 대해 개별 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3fb23a96de018295d436dfc71b478c2f496e60be" translate="yes" xml:space="preserve">
          <source>This bug was fixed in Perl 5.18, but may still trip you up if you are using older versions:</source>
          <target state="translated">이 버그는 Perl 5.18에서 수정되었지만 이전 버전을 사용하는 경우 여전히 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca44502c3ed83912a6b5db8a967d8fd6b852bc6b" translate="yes" xml:space="preserve">
          <source>This bug will be rectified in future by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt; s. However, there is a significant base of existing code that may be using the old behavior. So, as an interim step, Perl currently issues an optional warning when non-methods use inherited &lt;code&gt;AUTOLOAD&lt;/code&gt; s.</source>
          <target state="translated">이 버그는 메소드의 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대해서만 메소드 검색을 사용하여 수정 될 것 입니다. 그러나 이전 동작을 사용하고있을 수있는 기존 코드의 중요한 기반이 있습니다. 따라서 임시 단계로서 Perl은 메소드가 아닌 상속 된 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 사용할 때 현재 선택적 경고를 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="3151c00be9f916508bc5bf705b67d1e4b35d8229" translate="yes" xml:space="preserve">
          <source>This call extracts the next single substring that is a valid Perl quotelike operator (and removes it from $text):</source>
          <target state="translated">이 호출은 유효한 Perl 따옴표와 같은 연산자 인 다음 단일 문자열을 추출하여 $ text에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ced21c2bd0a49aeaa42731431a2edf3632b44a97" translate="yes" xml:space="preserve">
          <source>This call will allow &lt;code&gt;--l&lt;/code&gt; and &lt;code&gt;--L&lt;/code&gt; for the length option, but requires a least &lt;code&gt;--hea&lt;/code&gt; and &lt;code&gt;--hei&lt;/code&gt; for the head and height options.</source>
          <target state="translated">이 호출은 길이 옵션에 &lt;code&gt;--l&lt;/code&gt; 및 &lt;code&gt;--L&lt;/code&gt; 을 허용 하지만 head 및 height 옵션 에는 최소 &lt;code&gt;--hea&lt;/code&gt; 및 &lt;code&gt;--hei&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc74026b11403dd05d9d70bf8ec94212f671778f" translate="yes" xml:space="preserve">
          <source>This callback is where Perl untaints its own capture variables under taint mode (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). See the &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; function in</source>
          <target state="translated">이 콜백은 Perl이 Taint 모드에서 고유 한 캡처 변수를 유지하지 않는 곳입니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34608b82ee2af981743bfaea1702ca89b064619d" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">이 콜백은 항상 호출되며 위의 콜백 중 하나가 호출 된 후 각 결과에 대해 발생합니다. 예를 들어 &lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor가로&lt;/a&gt; 드 된 경우 다음을 사용하여 테스트 출력을 채색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a84240a7c3c6fb058597f6d953d7900c399c1c57" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; .</source>
          <target state="translated">SV_GMAGIC 플래그와 함께 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 를 호출합니다 . &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86657828dc4b39c2a031e8feb96e30aa836f7063" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">그러면 지정된 비트 마스크를 사용하여 select (2) syscall을 호출합니다.이 마스크는 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 를 사용하여 다음 행을 따라 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6030aab04889f87b188edddb787660db9b1b144a" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">그러면 지정된 비트 마스크를 사용하여 select (2) syscall을 호출합니다.이 마스크는 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 를 사용하여 다음 행을 따라 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bc12c1e6a592155ae29365e5d2b2a31283e6dd9" translate="yes" xml:space="preserve">
          <source>This can also be a problem with intermediate subprocesses in more complicated code, which will call waitpid() on all open filehandles during global destruction--in no predictable order.</source>
          <target state="translated">이것은 더 복잡한 코드의 중간 하위 프로세스에서 문제가 될 수 있으며, 전역 파괴 중에 열려있는 모든 파일 핸들에서 waitpid ()를 호출하여 예측 가능한 순서로 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62869b1f9b57cb9d79e8730408b0c95ddf4b16ac" translate="yes" xml:space="preserve">
          <source>This can also be called with a null first argument to indicate that &lt;code&gt;oldstash&lt;/code&gt; has been deleted.</source>
          <target state="translated">&lt;code&gt;oldstash&lt;/code&gt; 가 삭제 되었음을 표시하기 위해 널 (null) 첫 번째 인수와 함께 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d43bae30188acac82d7e357353fabe7bc6c40a81" translate="yes" xml:space="preserve">
          <source>This can be accomplished by adding a repeat specifier to the option specification. Repeat specifiers are very similar to the &lt;code&gt;{...}&lt;/code&gt; repeat specifiers that can be used with regular expression patterns. For example, the above command line would be handled as follows:</source>
          <target state="translated">옵션 스펙에 반복 지정자를 추가하여이를 수행 할 수 있습니다. 반복 지정자는 정규식 패턴과 함께 사용할 수있는 &lt;code&gt;{...}&lt;/code&gt; 반복 지정자 와 매우 유사합니다 . 예를 들어 위의 명령 줄은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="372e8345a480f344b8fa12b55e0c07a688e7200f" translate="yes" xml:space="preserve">
          <source>This can be accomplished with a destination routine:</source>
          <target state="translated">이는 대상 루틴으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e3779b19d94c38ed3503cfda1db4bf067d5a3d" translate="yes" xml:space="preserve">
          <source>This can be conveniently combined with precalculation of keys as given above.</source>
          <target state="translated">이것은 위에 주어진 키의 사전 계산과 편리하게 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee9c9bfb944617270087476daa04080c698fb3a" translate="yes" xml:space="preserve">
          <source>This can be used to change the</source>
          <target state="translated">이것은 변경하는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d06a37a2d3a4148b6ee21e32af3a875ef2d651aa" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; .</source>
          <target state="translated">이를 통해 각 분기에 대해 별도의 캡처 그룹을 사용하지 않고 패턴 분기를 일치시킬 수 있습니다. 이는 perl이 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 처럼 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="c6b6a0827f222037bfd74f5afc449218b3d32dc4" translate="yes" xml:space="preserve">
          <source>This can be used to provide overridable configuration defaults:</source>
          <target state="translated">재정의 가능한 구성 기본값을 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7302fe67fb868f202093521caa858978f0b6a28c" translate="yes" xml:space="preserve">
          <source>This can be used to see the effect of/bugs in the various layers e.g.</source>
          <target state="translated">이것은 다양한 레이어에서 / 버그의 효과를 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="20e14da8dfc2bfdf2f71fc590d8fe2a63e1000ea" translate="yes" xml:space="preserve">
          <source>This can be used to store bytes in the string component of the SV. Here the representation of the data is irrelevant to perl and the bytes themselves are just stored in the SV. It is assumed that the C variable is a pointer (the bytes are copied from that memory location). If the pointer is pointing to something that is represented by 8 bytes then those 8 bytes are stored in the SV (and length() will report a value of 8). This entry is similar to T_OPAQUE.</source>
          <target state="translated">이것은 SV의 문자열 구성 요소에 바이트를 저장하는 데 사용될 수 있습니다. 여기서 데이터 표현은 perl과 관련이 없으며 바이트 자체는 SV에 저장됩니다. C 변수가 포인터 인 것으로 가정합니다 (바이트는 해당 메모리 위치에서 복사 됨). 포인터가 8 바이트로 표시되는 것을 가리키는 경우 해당 8 바이트는 SV에 저장되며 length ()는 8의 값을보고합니다. 이 항목은 T_OPAQUE와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="0410f2327d86bdf0fdae05f37687269ec62b9fe1" translate="yes" xml:space="preserve">
          <source>This can be used to store data from non-pointer types in the string part of an SV. It is similar to T_OPAQUEPTR except that the typemap retrieves the pointer directly rather than assuming it is being supplied. For example, if an integer is imported into Perl using T_OPAQUE rather than T_IV the underlying bytes representing the integer will be stored in the SV but the actual integer value will not be available. i.e. The data is opaque to perl.</source>
          <target state="translated">이것은 포인터가 아닌 유형의 데이터를 SV의 문자열 부분에 저장하는 데 사용할 수 있습니다. typemap이 포인터를 제공한다고 가정하지 않고 직접 포인터를 검색한다는 점을 제외하면 T_OPAQUEPTR과 유사합니다. 예를 들어, T_IV가 아닌 T_OPAQUE를 사용하여 정수를 Perl로 가져 오면 정수를 나타내는 기본 바이트는 SV에 저장되지만 실제 정수 값은 사용할 수 없습니다. 즉, 데이터는 펄에 불투명하다.</target>
        </trans-unit>
        <trans-unit id="89bc9efe11bbc18be53fe6f2369d301f92011919" translate="yes" xml:space="preserve">
          <source>This can be useful when carrying out batch operations on multiple files that have both an input filename and output filename and the output file can be derived from the input filename. Examples of operations where this can be useful include, file renaming, file copying and file compression.</source>
          <target state="translated">입력 파일 이름과 출력 파일 이름이 모두있는 여러 파일에 대해 일괄 작업을 수행 할 때 유용 할 수 있으며 출력 파일은 입력 파일 이름에서 파생 될 수 있습니다. 이것이 유용한 작업의 예로는 파일 이름 바꾸기, 파일 복사 및 파일 압축이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee5530e46592bdd5b18c5d4e4adf9c1e149be67" translate="yes" xml:space="preserve">
          <source>This can easily be demonstrated by using a module, such as the Socket module, which uses eval &quot;...&quot; as part of an AUTOLOAD function. You can 'use' the module outside the compartment and share an (autoloaded) function with the compartment. If an autoload is triggered by code in the compartment, or by any code anywhere that is called by any means from the compartment, then the eval in the Socket module's AUTOLOAD function happens in the namespace of the compartment. Any variables created or used by the eval'd code are now under the control of the code in the compartment.</source>
          <target state="translated">이는 AUTOLOAD 기능의 일부로 eval &quot;...&quot;을 사용하는 소켓 모듈과 같은 모듈을 사용하여 쉽게 설명 할 수 있습니다. 컴 파트먼트 외부에서 모듈을 '사용'하고 컴 파트먼트와 (자동로드 된) 기능을 공유 할 수 있습니다. 컴 파트먼트의 코드 또는 컴 파트먼트에서 호출 된 코드에 의해 자동로드가 트리거되는 경우 소켓 모듈의 AUTOLOAD 함수의 평가는 컴 파트먼트의 네임 스페이스에서 발생합니다. 평가 된 코드에 의해 생성되거나 사용 된 모든 변수는 이제 구획의 코드에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="33eb1b5384e732b374fa6a2eb81b539c4ef372da" translate="yes" xml:space="preserve">
          <source>This can give a serious performance boost to your threaded program, since more than one thread will be executing at the same time. As a tradeoff, though, any of those nagging synchronization issues that might not have shown with basic kernel threads will appear with a vengeance.</source>
          <target state="translated">둘 이상의 스레드가 동시에 실행되므로 스레드 된 프로그램의 성능이 크게 향상 될 수 있습니다. 그러나 기본 커널 스레드에서 표시되지 않았을 수있는 잔소리 동기화 문제는 복수로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="56f625d37a903c20859d631591a0773b6d672cf7" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt; , Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">이로 인해 일부 모호성이 생길 수 있습니다. 경우 &lt;code&gt;\N&lt;/code&gt; 좌 괄호 바로 뒤에 있지 않은 펄은 가정 &lt;code&gt;[^\n]&lt;/code&gt; 의미한다. 또한 중괄호가 &lt;code&gt;\N{3}&lt;/code&gt; 또는 &lt;code&gt;\N{5,}&lt;/code&gt; 와 같은 유효한 수량 자를 구성하는 경우 Perl은 이것이 주어진 줄 바꿈이 아닌 수량 (이 예에서는 3; 5 이상)과 일치하는 것으로 가정합니다. 각기). 다른 모든 경우, &lt;code&gt;\N{&lt;/code&gt; 및 일치하는 &lt;code&gt;}&lt;/code&gt; 가있는 경우 Perl은 문자 이름이 필요하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="959b6fc0ff47607dd43aa724268206e3f29dd78b" translate="yes" xml:space="preserve">
          <source>This can lead to unexpected results. For example, a string's semantics can suddenly change if a code point above 255 is appended to it, which changes the rules from ASCII to Unicode. As an example, consider the following program and its output:</source>
          <target state="translated">예기치 않은 결과가 발생할 수 있습니다. 예를 들어 255보다 큰 코드 포인트가 추가되면 규칙의 의미가 ASCII에서 유니 코드로 변경되면 문자열의 의미가 갑자기 변경 될 수 있습니다. 예를 들어, 다음 프로그램 및 해당 출력을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="85608589698ca117deecc9b9804cdf91bb5ea3e0" translate="yes" xml:space="preserve">
          <source>This can result from a bug in emx sprintf which was fixed in 0.9d fix 03.</source>
          <target state="translated">0.9d 수정 프로그램 03에서 수정 된 emx sprintf의 버그로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0068e1ff0325fa89c18995ccdfd4bec0d4d0e1c" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using a (non-gcc) vendor cc, this variable may contain a version for the compiler.</source>
          <target state="translated">힌트 파일 또는 구성으로 설정할 수 있습니다. gcc가 아닌 공급 업체 cc를 사용하는 경우이 변수에 컴파일러 버전이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b497dc3b646a186b11a326e1c1c02e389336f453" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt; .</source>
          <target state="translated">힌트 파일 또는 구성으로 설정할 수 있습니다. gcc를 사용하는 경우 이것은 gcc이며 그렇지 않은 경우 일반적으로 cc와 같고 인상적이지 않습니까? 그러나 일부 플랫폼은 여기서 사용되는 C 컴파일러의 특징을 저장하여이를 잘 활용합니다. 예를 들어 Sun WorkShop 제품군을 사용하는 경우 ccname은 &lt;code&gt;workshop&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="268887449daa89d9e6e6591c09f61433e4f65428" translate="yes" xml:space="preserve">
          <source>This causes Attribute::Handlers to define the &lt;code&gt;Roo&lt;/code&gt; attribute in the package that imports the Tie::Me::Kangaroo:Down::Sport module.</source>
          <target state="translated">이로 인해 Attribute :: Handlers 는 Tie :: Me :: Kangaroo : Down :: Sport 모듈을 가져 오는 패키지에 &lt;code&gt;Roo&lt;/code&gt; 속성 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="102ace81a524208492f6e027d89b5645163151f6" translate="yes" xml:space="preserve">
          <source>This causes perl to load your module but does not import any symbols.</source>
          <target state="translated">이로 인해 펄은 모듈을로드하지만 심볼은 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c30feda4a3a3684c859a87888367dce95a5f76b5" translate="yes" xml:space="preserve">
          <source>This causes the redispatcher to only visit each distinct &lt;code&gt;method&lt;/code&gt; method once. That is, to skip any classes in the hierarchy that it has already visited during redispatch. So, for example, if the previous example were rewritten:</source>
          <target state="translated">이로 인해 redispatcher는 각 고유 한 &lt;code&gt;method&lt;/code&gt; 메소드를 한 번만 방문합니다 . 즉, redispatch 중에 이미 방문한 계층 구조의 클래스를 건너 뛰는 것입니다. 예를 들어 이전 예제를 다시 쓴 경우 :</target>
        </trans-unit>
        <trans-unit id="582cc40cbf8b3547920ee86c914be4717f134b16" translate="yes" xml:space="preserve">
          <source>This change was made because it was found that various commercial tools like editors, or for things like source code control, had been written so that they would not handle program files that used these code points, effectively precluding their use almost entirely! And that was never the intent. They've always been meant to be usable within an application, or cooperating set of applications, at will.</source>
          <target state="translated">이러한 변경은 편집기 나 소스 코드 제어와 같은 다양한 상용 도구가 작성되어 이러한 코드 포인트를 사용하는 프로그램 파일을 처리하지 않아서 거의 전적으로 사용을 완전히 배제한 것으로 밝혀졌습니다! 그리고 그것은 결코 의도가 아니 었습니다. 이들은 항상 응용 프로그램 내에서 또는 협력적인 응용 프로그램 내에서 자유롭게 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c679de889cc139bb514d15d08372653b38479f14" translate="yes" xml:space="preserve">
          <source>This changes the sentence to &quot;this is a SUcCess case.&quot;</source>
          <target state="translated">문장이 &quot;이것은 SUCCess 사례&quot;로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="806d9541617fb633252bc021124ba56dfb002ae1" translate="yes" xml:space="preserve">
          <source>This changes the string that this token holds. You probably won't need to do this.</source>
          <target state="translated">이 토큰이 보유한 문자열을 변경합니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b4ce31991e674e8d238b692a9312c922759283b" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this end-token object. You probably won't need to do this.</source>
          <target state="translated">이 엔드 토큰 객체의 태그 이름이 변경됩니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="05c1f4e6ea1fd867b5212d7916e4ce924dd15d97" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this start-token object. You probably won't need to do this.</source>
          <target state="translated">시작 토큰 객체의 태그 이름이 변경됩니다. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="642eb07575d1344323a97b06a777777ad1321fc4" translate="yes" xml:space="preserve">
          <source>This chart is sorted from slowest to fastest, and shows the percent speed difference between each pair of tests.</source>
          <target state="translated">이 차트는 가장 느린 것부터 가장 빠른 것까지 정렬되며 각 테스트 쌍 간의 속도 차이 백분율을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7da28c0924cf2fc297ae57e942274584c8adbeb4" translate="yes" xml:space="preserve">
          <source>This checks that every file listed in the .packlist actually exists. If an argument which evaluates to true is given, any missing files will be removed from the internal hash. The return value is a list of the missing files, which will be empty if they all exist.</source>
          <target state="translated">이렇게하면 .packlist에 나열된 모든 파일이 실제로 존재하는지 확인합니다. true로 평가되는 인수가 제공되면 누락 된 파일이 내부 해시에서 제거됩니다. 리턴 값은 누락 된 파일의 목록이며, 존재하는 경우 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55eba663917d253b044988b2b6ee903ef6a93dc" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">이 클래스 (매우 작음-소스 읽기)는 파서 이벤트가 메소드 호출로 변환되도록 Pod :: Simple의 _handle_element_start, _handle_text 및 _handle_element_end 메소드를 대체합니다. (그렇지 않으면 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속합니다.)</target>
        </trans-unit>
        <trans-unit id="494e46870d49e2dc3a5f9a64f75952ec99423e9a" translate="yes" xml:space="preserve">
          <source>This class defines several methods for setting (and, occasionally, reading) the contents of an object. With two exceptions (discussed at the end of this section), these attributes are just for controlling the way searches are carried out.</source>
          <target state="translated">이 클래스는 객체의 내용을 설정 (때로는 읽기)하기위한 몇 가지 메소드를 정의합니다. 이 섹션의 끝에서 논의 된 두 가지 예외를 제외하고 이러한 속성은 검색 수행 방식을 제어하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d32aad8f8251ef1db7bcc4b8f3feb324d9d1213" translate="yes" xml:space="preserve">
          <source>This class is NOT a subclass of Pod::Simple::HTML (nor of bad old Pod::Html) -- although it uses Pod::Simple::HTML for doing the conversion of each document.</source>
          <target state="translated">이 클래스는 Pod :: Simple :: HTML (나머지 포드 :: Html도 아님)의 하위 클래스가 아닙니다. 비록 각 문서를 변환하기 위해 Pod :: Simple :: HTML을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b711767b4a974da1a1509d38f153220b0d62949c" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as RTF, good for viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.</source>
          <target state="translated">이 클래스는 포드를 가져와 RTF로 렌더링하는 포맷터로 MSWord, WordPad / write.exe, TextEdit 등에서 보거나 인쇄하기에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="138981ec5228a60a4f53dbf829b51f5efd9f8a75" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as XHTML validating HTML.</source>
          <target state="translated">이 클래스는 포드를 가져 와서 XHTML 유효성 검사 HTML로 렌더링하는 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="3d4c24315ad07b2a992c0858db0b7be768d0cc0b" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as wrapped plaintext.</source>
          <target state="translated">이 클래스는 포드를 가져 와서 랩핑 된 일반 텍스트로 렌더링하는 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="62abaee97c33098880e266351ef2fc532bf53875" translate="yes" xml:space="preserve">
          <source>This class is an internal interface only.</source>
          <target state="translated">이 클래스는 내부 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5e43c4bd22a6b18d8bc78626e236eaa142e2b822" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">이 클래스는 포드의 구문 유효성을 검사하기위한 것입니다. 기본적으로 &quot;Pod Errors&quot;섹션 만 형식화하는 &lt;a href=&quot;text&quot;&gt;Pod :: Simple :: Text의 간단한&lt;/a&gt; 버전으로 작동 합니다 (Pod :: Simple이 지정된 문서에 대해 하나를 생성하는 경우).</target>
        </trans-unit>
        <trans-unit id="9b791e36572b7d483165e52086de0aff10cad7ba" translate="yes" xml:space="preserve">
          <source>This class is for dumping, as text, the events gotten from parsing a Pod document. This class is of interest to people writing Pod formatters based on Pod::Simple. It is useful for seeing exactly what events you get out of some Pod that you feed in.</source>
          <target state="translated">이 클래스는 Pod 문서를 구문 분석하여 얻은 이벤트를 텍스트로 덤프하기위한 것입니다. 이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 관심이 있습니다. 피드 한 일부 포드에서 어떤 이벤트가 발생했는지 정확하게 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a18cdad26fb8d235532c57fb43aa60327d80a50a" translate="yes" xml:space="preserve">
          <source>This class is for making an HTML rendering of a Pod document.</source>
          <target state="translated">이 클래스는 포드 문서의 HTML 렌더링을 만들기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd75675624091c3742f49bbeb8bbfb0c06a37c0a" translate="yes" xml:space="preserve">
          <source>This class is for using Pod::Simple to build a Pod processor -- but one that uses an interface based on a stream of token objects, instead of based on events.</source>
          <target state="translated">이 클래스는 Pod :: Simple을 사용하여 포드 프로세서를 빌드하기위한 것입니다. 그러나 이벤트 대신 토큰 객체 스트림을 기반으로 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="44761047bfaa4c6cc438e77b4bb92131ad714c01" translate="yes" xml:space="preserve">
          <source>This class is inspired by XML::Parser's &quot;Tree&quot; parsing-style, although it doesn't use exactly the same LoL format.</source>
          <target state="translated">이 클래스는 XML :: Parser의 &quot;Tree&quot;구문 분석 스타일에서 영감을 얻었지만 정확히 동일한 LoL 형식을 사용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9698adab813e0c4fae21452c7598015f3935b3d" translate="yes" xml:space="preserve">
          <source>This class is not of interest to general users.</source>
          <target state="translated">이 클래스는 일반 사용자에게는 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f2f6048d2f61aa8645bcc5ebd42e19fc8c8aea4" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">이 클래스는 Pod :: Simple을 기반으로 Pod 포맷터를 작성하는 사람들에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63f889f338653b4ee33eb44dc0ee1133ee852ae" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing a Pod processor/formatter.</source>
          <target state="translated">이 수업은 포드 프로세서 / 포매터를 작성하는 사람들에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dca4f8907e7dbb28751ea149d9af37422c91f32" translate="yes" xml:space="preserve">
          <source>This class is that parses Pod and dumps just the text content. It is mainly meant for use by the Pod::Simple test suite, but you may find some other use for it.</source>
          <target state="translated">이 클래스는 포드를 구문 분석하고 텍스트 내용 만 덤프합니다. 주로 Pod :: Simple 테스트 스위트에서 사용하기위한 것이지만 다른 용도로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a51d38f10e103a9903a5853a79eae683ff646eb" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; , then you have a bunch of methods at your disposal.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 시스템 의 핵심입니다 . 대부분의 TAP 라인은 테스트 라인이 될 것이며 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 이면 여러 가지 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f581c5cd9d5c7598c0dcb3ca6436c9bd821c2c4" translate="yes" xml:space="preserve">
          <source>This class might turn out to be a temporary solution, but MM won't go away.</source>
          <target state="translated">이 클래스는 임시 솔루션으로 판명 될 수 있지만 MM은 사라지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24195eb4cea8857a411b60273a35c873f422dbe0" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt; . It takes no parameters:</source>
          <target state="translated">이 클래스는 &lt;code&gt;new&lt;/code&gt; 라는 하나의 생성자를 제공합니다 . 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30e23715125a3d5360cef7bf3e4022849622110" translate="yes" xml:space="preserve">
          <source>This class takes Pod and parses it, returning a parse tree made just of arrayrefs, and hashrefs, and strings.</source>
          <target state="translated">이 클래스는 Pod를 가져와 구문 분석하여 arrayrefs와 hashrefs 및 문자열로 구성된 구문 분석 트리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9dbee182dfa76d92a94c69cd0858c1622ac2f770" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">이 클라이언트는 지금까지 해왔 던 것보다 더 복잡하지만, 강력한 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 호출 을 지원하는 시스템을 사용하는 경우 솔루션이 그렇게 거칠지 않습니다. 채팅하려는 서비스에 연결되면 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 를 호출 하여 프로세스를 복제하십시오. 이 두 가지 동일한 프로세스는 매우 간단한 작업을 수행합니다. 부모는 소켓에서 표준 출력으로 모든 것을 복사하는 반면 자식은 표준 입력에서 소켓으로 모든 것을 동시에 복사합니다. 하나의 프로세스 만 사용하여 동일한 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="ceec53b2ebb7603eb9ee71d9bde01119b83707cb" translate="yes" xml:space="preserve">
          <source>This clones the repository and makes a local copy in the</source>
          <target state="translated">그러면 리포지토리가 복제되고</target>
        </trans-unit>
        <trans-unit id="5330da17cfc7cfcf64aab224d5b574c934e7ac2c" translate="yes" xml:space="preserve">
          <source>This code heavily adapted from an early version of perl5db.pl attributable to Larry Wall and the Perl Porters.</source>
          <target state="translated">이 코드는 Larry Wall 및 Perl Porters에 기인 한 perl5db.pl의 초기 버전에서 크게 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="11c4fc183eca8652881b1cb5b12c6ea249b79ebe" translate="yes" xml:space="preserve">
          <source>This code is intended for development only, and may not be portable even to all Unix variants. Also, it is an 80% solution, in that it isn't able to make all ops read only. Specifically it does not apply to op slabs belonging to &lt;code&gt;BEGIN&lt;/code&gt; blocks.</source>
          <target state="translated">이 코드는 개발만을 목적으로하며 모든 유닉스 변종에도 이식 가능하지 않을 수 있습니다. 또한 모든 연산을 읽기 전용으로 만들 수 없다는 점에서 80 % 솔루션입니다. 특히 &lt;code&gt;BEGIN&lt;/code&gt; 블록에 속하는 연산 슬래브에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="443071b2d9d382ee44392d30a6c9cc6944390654" translate="yes" xml:space="preserve">
          <source>This code is unusual in that most formatters completely discard this code and its content. Other formatters will render it with invisible codes that can be used in building an index of the current document.</source>
          <target state="translated">이 코드는 대부분의 포맷터가이 코드와 그 내용을 완전히 버린다는 점에서 특이합니다. 다른 포맷터는 현재 문서의 색인을 작성하는 데 사용할 수있는 보이지 않는 코드로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="ed77ac1105bfebc895982f70abdb5f07d0f61471" translate="yes" xml:space="preserve">
          <source>This code is unusual is that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; . Whether or not it complains, the</source>
          <target state="translated">이 코드는 내용이 없어야한다는 것이 일반적이지 않습니다. 즉, 프로세서가 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 보게되면 불만을 제기 할 수 있습니다 . 불평 여부에 관계없이</target>
        </trans-unit>
        <trans-unit id="9f748555f0c218e80f371f8622c90719bdf4c3e1" translate="yes" xml:space="preserve">
          <source>This code resides primarily in</source>
          <target state="translated">이 코드는 주로</target>
        </trans-unit>
        <trans-unit id="b4ca79218fad07abe234bb2cecfbf2b9daaa8186" translate="yes" xml:space="preserve">
          <source>This code tries to return a new SV (which contains the value 42) if it should return a real value, or undef otherwise. Instead it has returned a NULL pointer which, somewhere down the line, will cause a segmentation violation, bus error, or just weird results. Change the zero to &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in the first line and all will be well.</source>
          <target state="translated">이 코드는 실제 값을 반환해야하는 경우 새 SV (값 42 포함)를 반환하거나 그렇지 않으면 undef를 시도합니다. 대신 널 어딘가에서 NULL 위반을 반환하여 세그먼트 위반, 버스 오류 또는 이상한 결과를 초래할 수 있습니다. 첫 번째 줄에서 0을 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 로 변경하면 모두 정상 입니다.</target>
        </trans-unit>
        <trans-unit id="6b0496da28a3ec6a32260558d3028edcf275c0a4" translate="yes" xml:space="preserve">
          <source>This combination of options may also be specified thus</source>
          <target state="translated">이러한 옵션 조합은 다음과 같이 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="738a4e0887c40771b0a61f4f0df6d45e56b8d5cf" translate="yes" xml:space="preserve">
          <source>This combination performs the work of the legacy functions gethostbyname() and inet_ntoa().</source>
          <target state="translated">이 조합은 레거시 함수 gethostbyname () 및 inet_ntoa ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d728ee6330c55e20ceb083fe7c0710810e2932ca" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">이 명령은 목록의 항목이 여기에서 시작됨을 나타냅니다. 포맷팅 코드가 처리됩니다. 이 단락의 나머지 부분에서 (선택적) 텍스트의 의미는 아래에 대한 &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About = over ... = back Regions&lt;/a&gt; 섹션에 설명되어 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4a355ff290cc8d5e2710e8069a06d654602bb061" translate="yes" xml:space="preserve">
          <source>This command indicates that the text in the remainder of the paragraph is a heading. That text may contain formatting codes. Examples:</source>
          <target state="translated">이 명령은 나머지 단락의 텍스트가 제목임을 나타냅니다. 해당 텍스트에는 서식 코드가 포함될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c6da60e4854fba0e9da1ba094a38fc435654e60e" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the end of the region begun by the most recent &quot;=over&quot; command. It permits no text after the &quot;=back&quot; command.</source>
          <target state="translated">이 명령은 이것이 가장 최근의 &quot;= over&quot;명령으로 시작된 영역의 끝임을 나타냅니다. &quot;= back&quot;명령 뒤에 텍스트를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19be29c945bbd16c098b73b780bb343e863492ff" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">이 명령은 이것이 목록 / 들여 쓰기 영역의 시작임을 나타냅니다. &quot;= over&quot;뒤에 텍스트가 있으면 0이 아닌 양수로만 구성되어야합니다. 이 숫자의 의미는 아래 의 &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About = over ... = back Regions&lt;/a&gt; 섹션에 설명되어 있습니다. 서식 코드가 확장되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7ff4d3408bd7bdb5ab335d1f0aa8564e21d93c8d" translate="yes" xml:space="preserve">
          <source>This command indicates that this line is the end of this previously started Pod block. If there is any text after &quot;=cut&quot; on the line, it must be ignored. Examples:</source>
          <target state="translated">이 명령은이 줄이 이전에 시작된 포드 블록의 끝임을 나타냅니다. 줄에 &quot;= cut&quot;다음에 텍스트가 있으면 무시해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="3f41d49fdd2a10822f19964c9959582847611ffe" translate="yes" xml:space="preserve">
          <source>This command indicates that this paragraph begins a Pod block. (If we are already in the middle of a Pod block, this command has no effect at all.) If there is any text in this command paragraph after &quot;=pod&quot;, it must be ignored. Examples:</source>
          <target state="translated">이 명령은이 단락이 Pod 블록을 시작 함을 나타냅니다. (이미 Pod 블록의 중간에 있다면이 명령은 전혀 효과가 없습니다.) &quot;= pod&quot;다음에이 명령 단락에 텍스트가 있으면 무시해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8a99ea1513aed41e6edc9e12797ae7dfeaac42f6" translate="yes" xml:space="preserve">
          <source>This command is used for declaring the encoding of a document. Most users won't need this; but if your encoding isn't US-ASCII, then put a &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; command very early in the document so that pod formatters will know how to decode the document. For</source>
          <target state="translated">이 명령은 문서의 인코딩을 선언하는 데 사용됩니다. 대부분의 사용자는 이것을 필요로하지 않습니다. 그러나 인코딩이 US-ASCII가 아닌 경우 문서의 초기에 &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; 명령 을 입력하면 포드 포맷터가 문서를 디코딩하는 방법을 알 수 있습니다. 에 대한</target>
        </trans-unit>
        <trans-unit id="cc900c104077e4a6a7ca5f06e5d70661d00910f9" translate="yes" xml:space="preserve">
          <source>This command, which should occur early in the document (at least before any non-US-ASCII data!), declares that this document is encoded in the encoding</source>
          <target state="translated">문서의 초기 (최소한 US-ASCII 이외의 데이터 이전)에서 발생해야하는이 명령은이 문서가 인코딩으로 인코딩되었음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a044d113549cfc62bab49938c5d884a6268cf948" translate="yes" xml:space="preserve">
          <source>This commands provides a statistical overview over recent download activities. The data for this is collected in the YAML file &lt;code&gt;FTPstats.yml&lt;/code&gt; in your &lt;code&gt;cpan_home&lt;/code&gt; directory. If no YAML module is configured or YAML not installed, no stats are provided.</source>
          <target state="translated">이 명령은 최근 다운로드 활동에 대한 통계 개요를 제공합니다. 이에 대한 데이터는 &lt;code&gt;cpan_home&lt;/code&gt; 디렉토리 의 YAML 파일 &lt;code&gt;FTPstats.yml&lt;/code&gt; 에 수집됩니다 . YAML 모듈이 구성되어 있지 않거나 YAML이 설치되지 않은 경우 통계가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ea20acdc8121360e07a3ca6ca2abb72ed9a4374" translate="yes" xml:space="preserve">
          <source>This compiler backend prints the internal OPs of a Perl program's syntax tree in one of several space-efficient text formats suitable for debugging the inner workings of perl or other compiler backends. It can print OPs in the order they appear in the OP tree, in the order they will execute, or in a text approximation to their tree structure, and the format of the information displayed is customizable. Its function is similar to that of perl's &lt;b&gt;-Dx&lt;/b&gt; debugging flag or the &lt;b&gt;B::Terse&lt;/b&gt; module, but it is more sophisticated and flexible.</source>
          <target state="translated">이 컴파일러 백엔드는 Perl 또는 다른 컴파일러 백엔드의 내부 작업을 디버깅하는 데 적합한 몇 가지 공간 효율적인 텍스트 형식 중 하나로 Perl 프로그램 구문 트리의 내부 OP를 인쇄합니다. OP 트리에 표시되는 순서, 실행 순서 또는 트리 구조와 유사한 텍스트로 OP를 인쇄 할 수 있으며 표시되는 정보의 형식을 사용자 정의 할 수 있습니다. 이 기능은 perl의 &lt;b&gt;-Dx&lt;/b&gt; 디버깅 플래그 또는 &lt;b&gt;B :: Terse&lt;/b&gt; 모듈과 유사하지만 더 정교하고 유연합니다.</target>
        </trans-unit>
        <trans-unit id="49048e5c36c04df148e3cdcc3f896c82e8922e40" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">이 컴파일러는 일반적으로 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 또는 기타 Perl 모듈 빌드 도구로 작성된 makefile에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="811fc2387a18f3ccb2c99535bb74afa37f5a7e14" translate="yes" xml:space="preserve">
          <source>This condition is called a deadlock, and it occurs whenever two or more threads are trying to get locks on resources that the others own. Each thread will block, waiting for the other to release a lock on a resource. That never happens, though, since the thread with the resource is itself waiting for a lock to be released.</source>
          <target state="translated">이 상태를 교착 상태라고하며 둘 이상의 스레드가 다른 스레드가 소유 한 자원에 대한 잠금을 시도 할 때마다 발생합니다. 각 스레드는 차단되어 다른 스레드가 리소스에 대한 잠금을 해제 할 때까지 기다립니다. 그러나 리소스가있는 스레드 자체가 잠금이 해제되기를 기다리고 있기 때문에 결코 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faa53aa7f128fff59cd7dcb34623ce5e613b1979" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; , which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">이는 조건부로 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; 을 정의합니다 . 이는 컴파일러가 __builtin_choose_expr (x, y, z)를 지원함을 나타냅니다. 이 내장 함수는 C 의 &lt;code&gt;x?y:z&lt;/code&gt; 연산자와 유사하지만 리턴 된 표현식의 유형은 승격 규칙에 따라 변경되지 않습니다. 또한 내장 함수는 선택되지 않은 표현식을 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8177d32c94f6808dc1bba5e1e003e2e654d1454a" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; , which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">이것은 조건부로 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; 를 정의 하는데 , 이는 컴파일러가 __builtin_expect (exp, c)를 지원함을 나타냅니다. __builtin_expect를 사용하여 분기 예측 정보를 컴파일러에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e85ff206a230f535cdc1e1b660d9e31b004675c" translate="yes" xml:space="preserve">
          <source>This construct cannot be used within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier).</source>
          <target state="translated">이 구조는 범위 내에서 사용할 수없는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (또는 &lt;code&gt;/l&lt;/code&gt; 의 정규식 개질제).</target>
        </trans-unit>
        <trans-unit id="f8fed69726a17c92a263e748b2d7fa3336a3e37f" translate="yes" xml:space="preserve">
          <source>This construct is useful when you want to capture one of a number of alternative matches.</source>
          <target state="translated">이 구성은 여러 대체 일치 중 하나를 캡처하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89cfaa9b31ac24d949cb1a2ef0db748a527694e4" translate="yes" xml:space="preserve">
          <source>This construction is</source>
          <target state="translated">이 건설은</target>
        </trans-unit>
        <trans-unit id="78c7683a763192abf9645014c7b058753006e735" translate="yes" xml:space="preserve">
          <source>This constructor lets its parent class do the actual object construction.</source>
          <target state="translated">이 생성자는 부모 클래스가 실제 객체 구성을 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4bf27879428ff426e547cd9ab897b5c2de43f4ae" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">이것은 언어 핸들을 구성합니다. 일반적으로 이것을 직접 호출 &lt;b&gt;하지는 않지만 &lt;/b&gt; &lt;code&gt;get_handle&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 언어 클래스 를 찾은 다음-&amp;gt; new on을 호출하게하십시오.</target>
        </trans-unit>
        <trans-unit id="3edc7f7dd753392a74ab3c329050e0ec08dcdba9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">이것은 변환이 어떻게 진행되는지에 대한 STDOUT (또는 &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 'd)에 대한 메모까지 일괄 변환 중 자세한 표시 방법을 제어합니다 . 0이면 진행 정보가 인쇄되지 않습니다. 1 (기본값)이면 일부 진행 정보가 인쇄됩니다. 값이 클수록 더 많은 정보가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7a4f63a01fbc1cdd9d161f843ad25c0052f17f" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt; , if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">이는 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 이중 수명 코어 모듈이 더 이상 사용되지 않는지 여부를 제어합니다 . 이 true로 설정되어있는 경우 &lt;code&gt;check_install&lt;/code&gt; 에 false를 돌려줍니다 &lt;code&gt;uptodate&lt;/code&gt; 이중 생활 모듈에서로드 발견되면, &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4114328d4769af34ebf3741b18df472503df04" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt; . Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">이것은 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 이 &lt;code&gt;%INC&lt;/code&gt; 해시를 검사하여 모듈을 사용할 수 있는지 여부를 제어합니다 . 기본적으로 &lt;code&gt;@INC&lt;/code&gt; 만 스캔하여 모듈이 실제로 파일 시스템에 있는지 또는 &lt;code&gt;@INC-hook&lt;/code&gt; 통해 사용할 수 있는지 확인합니다 . 이 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 &lt;code&gt;%INC&lt;/code&gt; 모든 항목을 신뢰 하고 대신 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c4381fad7d89f422c37ccba3ee1b2f92eba8443" translate="yes" xml:space="preserve">
          <source>This controls whether IPC::Cmd will print any output from the commands to the screen or not. The default is 0.</source>
          <target state="translated">이것은 IPC :: Cmd가 명령의 출력을 화면에 인쇄할지 여부를 제어합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c156076360b54f8a8977c57dc77de47486be1ac3" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Module::Load::Conditional will not output any warnings. The default is 0;</source>
          <target state="translated">이는 Module :: Load :: Conditional이 특정 문제가 발생한 이유에 대한 경고 및 설명을 발행할지 여부를 제어합니다. 0으로 설정하면 Module :: Load :: Conditional은 경고를 출력하지 않습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b49fb12849ceb3c435af21ba21b9e8d24214fd70" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will try to parse (and eval) the version from the module you're trying to load.</source>
          <target state="translated">이것은 Module :: Load :: Conditional이로드하려는 모듈에서 버전을 구문 분석 (및 평가)할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d9aae25fb78fe9990ffb44145098a21f55aa720e" translate="yes" xml:space="preserve">
          <source>This controls whether Params::Check will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Params::Check will not output any warnings.</source>
          <target state="translated">이는 Params :: Check가 특정 문제가 발생한 이유에 대한 경고 및 설명을 발행할지 여부를 제어합니다. 0으로 설정하면 Params :: Check가 경고를 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa3d4d74657a46a0b2bcece8a25683b9b4d5103" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">이것은 명령의 모든 출력이 STDOUT / STDERR로 인쇄되어야하는지 또는 버퍼에만 트랩되어야하는지 여부를 제어합니다 (참고 : 버퍼에는 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt; 이 설치되어 있거나 시스템이 &lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; 과 작동 할 수 있어야 함 ).</target>
        </trans-unit>
        <trans-unit id="732d2e4b2658c0a2ec91db3c054e26236d0390f1" translate="yes" xml:space="preserve">
          <source>This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.</source>
          <target state="translated">로드 된 모듈의 기능을 호출자 패키지로 가져올 지 여부를 제어합니다. 기본값은 함수를 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb78f49655da0a3543996010fb5198aba12c2274" translate="yes" xml:space="preserve">
          <source>This controls whether or not each HTML page is liable to have a little table of contents at the top (which we call an &quot;index&quot; for historical reasons). This is true by default.</source>
          <target state="translated">이것은 각 HTML 페이지가 맨 위에 작은 목차를 가질 수 있는지 여부를 제어합니다 (이력상의 이유로 &quot;인덱스&quot;라고 함). 기본적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d18f8fcaf7759aa328d11a1f1e92e835b3d9557f" translate="yes" xml:space="preserve">
          <source>This controls whether warnings should be printed if a module failed to load. The default is to use the value of $Module::Load::Conditional::VERBOSE.</source>
          <target state="translated">모듈을로드하지 못한 경우 경고를 인쇄해야하는지 여부를 제어합니다. 기본값은 $ Module :: Load :: Conditional :: VERBOSE 값을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ff7f0c70685518180af334112b2fe58a44a4fdd" translate="yes" xml:space="preserve">
          <source>This copyright does not prohibit distribution of any version of Perl containing this extension under the terms of the GNU or Artistic licenses.</source>
          <target state="translated">이 저작권은 GNU 또는 Artistic 라이센스의 조건에 따라이 확장을 포함하는 Perl 버전의 배포를 금지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e07ca9a36ef5f49f5e95795b2568b38574fd37e2" translate="yes" xml:space="preserve">
          <source>This corresponds to clearerr(), i.e., clears 'error' and (usually) 'eof' flags for the &quot;stream&quot;. Does not return a value.</source>
          <target state="translated">이는 clearerr ()에 해당합니다. 즉, &quot;stream&quot;에 대한 'error'및 (보통) 'eof'플래그를 지 웁니다. 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a832f3c37512b00bc489449027088839617ff5af" translate="yes" xml:space="preserve">
          <source>This corresponds to feof(). Returns a true/false indication of whether the handle is at end of file. For terminal devices this may or may not be &quot;sticky&quot; depending on the implementation. The flag is cleared by PerlIO_seek(), or PerlIO_rewind().</source>
          <target state="translated">이것은 feof ()에 해당합니다. 핸들이 파일 끝에 있는지 여부에 대한 참 / 거짓 표시를 반환합니다. 터미널 장치의 경우 이는 구현에 따라 &quot;고정적&quot;일 수도 있고 아닐 수도 있습니다. PerlIO_seek () 또는 PerlIO_rewind ()에 의해 플래그가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="baeb66e5af4f3d77be2f1ed10348f03a4ed016a5" translate="yes" xml:space="preserve">
          <source>This corresponds to ferror(). Returns a true/false indication of whether there has been an IO error on the handle.</source>
          <target state="translated">이것은 ferror ()에 해당합니다. 핸들에 IO 오류가 있는지 여부에 대한 참 / 거짓 표시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb12a0ca3665432e7ae210e2f30b098e3c60f423" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt; , and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">이것은 fflush ()에 해당합니다. 버퍼링 된 쓰기 데이터를 기본 파일로 보냅니다. &lt;code&gt;NULL&lt;/code&gt; 로 호출하면 모든 열린 스트림 (또는 일부 USE_STDIO 구현의 코어 덤프)을 플러시 할 수 있습니다. 읽기 전용으로 열려 있거나 마지막 작업이 어떤 종류의 읽기 인 핸들을 호출하면 일부 USE_STDIO 구현에서 정의되지 않은 동작이 발생할 수 있습니다. USE_PERLIO (계층) 구현은 더 나은 동작을 시도합니다. &lt;code&gt;NULL&lt;/code&gt; 을 전달하면 열려있는 모든 스트림을 플러시 하고 버퍼에서 또는 현재 논리 위치에 대한 핸들을 검색하여 읽기 스트림에서 데이터를 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9e414890b7f22b1b4083f4007de6555d9d071db1" translate="yes" xml:space="preserve">
          <source>This corresponds to fileno(), note that on some platforms, the meaning of &quot;fileno&quot; may not match Unix. Returns -1 if the handle has no open descriptor associated with it.</source>
          <target state="translated">이는 fileno ()에 해당합니다. 일부 플랫폼에서는 &quot;fileno&quot;의 의미가 Unix와 일치하지 않을 수 있습니다. 핸들에 연관된 열린 설명자가 없으면 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5f4554adde4cea2591eaa99c7438bd7a745a0b3f" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">이것은 fseek ()에 해당합니다. 버퍼링 된 쓰기 데이터를 기본 파일로 보내거나 버퍼링 된 읽기 데이터를 버린 다음 &lt;b&gt;오프셋&lt;/b&gt; 및 &lt;b&gt;whence&lt;/b&gt; (sic)에 지정된대로 파일 디스크립터를 배치합니다 . 동일한 핸들에서 읽기와 쓰기를 전환 할 때 수행해야하는 올바른 작업입니다 (위의 PerlIO_flush () 관련 문제 참조). 오프셋은 &lt;code&gt;Off_t&lt;/code&gt; 유형 이며 이는 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="dd9bee6b04c387fd0085a9f7aa8ff48a5f034283" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">이것은 ftell ()에 해당합니다. 현재 파일 위치를 반환하거나 오류 발생시 (Off_t) -1을 반환합니다. 시스템을 호출하거나 기본 파일 디스크립터를 확인하지 않고 값 &quot;시스템&quot;을 리턴 할 수 있습니다 (따라서 공유 파일 디스크립터에서의 사용은 PerlIO_seek () 없이는 안전하지 않습니다). 리턴 값은 &lt;code&gt;Off_t&lt;/code&gt; 유형 이며 이는 stdio의 &lt;code&gt;off_t&lt;/code&gt; 와 같지 않을 수있는 perl 구성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a3583e8644f865d149cd4eb31d670f437a6e26eb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error.</source>
          <target state="translated">이것은 getc ()에 해당합니다. 이름의 c에도 불구하고 바이트 범위 0..0xFF 만 지원됩니다. 문자 읽기 또는 오류시 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e1cbd65b62177115f422eaf8fe4754328fbc6b9b" translate="yes" xml:space="preserve">
          <source>This corresponds to rewind(). It is usually defined as being</source>
          <target state="translated">이것은 rewind ()에 해당합니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="93c7ee35566034261e1234fcee65abc1e334abb8" translate="yes" xml:space="preserve">
          <source>This corresponds to setlinebuf(). Does not return a value. What constitutes a &quot;line&quot; is implementation dependent but usually means that writing &quot;\n&quot; flushes the buffer. What happens with things like &quot;this\nthat&quot; is uncertain. (Perl core uses it</source>
          <target state="translated">이것은 setlinebuf ()에 해당합니다. 값을 반환하지 않습니다. &quot;라인&quot;을 구성하는 것은 구현에 따라 다르지만 일반적으로 &quot;\ n&quot;을 쓰면 버퍼가 플러시됨을 의미합니다. &quot;this \ nthat&quot;과 같은 일이 어떻게되는지 불확실합니다. (펄 코어가 사용</target>
        </trans-unit>
        <trans-unit id="c130282a86007cfef5f589b0d598e97fc7e10899" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">이것은 tmpfile ()에 해당합니다. 즉 오류가 발생하면 익명 PerlIO 또는 NULL을 반환합니다. 시스템은 파일을 닫을 때 자동으로 파일 삭제를 시도합니다. 유닉스에서 파일은 일반적으로 파일을 만든 직후 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 되므로 파일을 닫는 방법은 중요하지 않습니다. 다른 시스템에서는 파일이 PerlIO_close ()를 통해 닫히거나 프로그램이 exit를 통해 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 된 경우에만 파일을 삭제할 수 있습니다 . 구현에 따라 다른 프로세스가 파일에 액세스 할 수있게하는 &quot;경주 조건&quot;이있을 수 있지만 일반적으로 광고보다 안전합니다. 혹시 계획.</target>
        </trans-unit>
        <trans-unit id="327b626f972edcc8578bc2302697191125c0290f" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">이것은 ungetc ()에 해당합니다. 인수는 &quot;파일&quot;을 먼저 갖도록 수정되었습니다. 다음 읽기 작업이 바이트 &lt;b&gt;c를&lt;/b&gt; 반환하도록 정렬합니다 . 이름에 암시 된 &quot;문자&quot;에도 불구하고 0..0xFF 범위의 값만 정의됩니다. 성공 하면 바이트 &lt;b&gt;c&lt;/b&gt; 를 , 에러 이면 -1 ( &lt;code&gt;EOF&lt;/code&gt; )을 반환합니다 . &quot;푸시 백 (push back)&quot;될 수있는 바이트 수는 다양 할 수 있으며, 한 문자 만 확실하며 핸들에서 읽은 마지막 문자 인 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d8f57342ffddc378f45e967d08a4b40a9028441d" translate="yes" xml:space="preserve">
          <source>This could, of course, be more legibly written with the &lt;code&gt;/x&lt;/code&gt; modifier, adding whitespace and comments. Here it is expanded, courtesy of Fred Curtis.</source>
          <target state="translated">물론 이것은 공백과 주석을 추가 하여 &lt;code&gt;/x&lt;/code&gt; 수정 자로 더 읽기 쉽게 작성 될 수 있습니다 . 여기에서 Fred Curtis가 제공 한 확장입니다.</target>
        </trans-unit>
        <trans-unit id="ac65bf824b65194ff0a99fd92e3e036111f8e8a9" translate="yes" xml:space="preserve">
          <source>This counterintuitive behavior has been fixed in perl v5.8.1.</source>
          <target state="translated">이 반 직관적 인 동작은 perl v5.8.1에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d26884badcfad89a2f88ee752f4bee54862ec7a" translate="yes" xml:space="preserve">
          <source>This creates a handler for the attribute &lt;code&gt;:Loud&lt;/code&gt; in the class LoudDecl. Thereafter, any subroutine declared with a &lt;code&gt;:Loud&lt;/code&gt; attribute in the class LoudDecl:</source>
          <target state="translated">LoudDecl 클래스에서 &lt;code&gt;:Loud&lt;/code&gt; 속성에 대한 핸들러를 작성합니다 . 그런 &lt;code&gt;:Loud&lt;/code&gt; LoudDecl 클래스에서 : Loud 속성으로 선언 된 모든 서브 루틴 :</target>
        </trans-unit>
        <trans-unit id="87fa03371108789e3d1ff265f81c30f8fb7e2b16" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt; ) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt; ). This is shorthand for the following:</source>
          <target state="translated">기존 스레드 ( &lt;code&gt;$thr1&lt;/code&gt; ) 에서 스택 크기를 상속 하는 새 스레드 ( &lt;code&gt;$thr2&lt;/code&gt; )가 작성 됩니다. 이것은 다음과 같은 약어입니다.</target>
        </trans-unit>
        <trans-unit id="0ee76e6a741e92139c43f1e221ed11b509991786" translate="yes" xml:space="preserve">
          <source>This database type allows arbitrary key/value pairs to be stored in data files. This is equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files created using DB_HASH are not compatible with any of the other packages mentioned.</source>
          <target state="translated">이 데이터베이스 유형을 사용하면 임의의 키 / 값 쌍을 데이터 파일에 저장할 수 있습니다. 이는 DBM, NDBM, ODBM, GDBM 및 SDBM과 같은 다른 해싱 패키지에서 제공하는 기능과 동일합니다. 그러나 DB_HASH를 사용하여 작성된 파일은 언급 된 다른 패키지와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3807b81d9c773a6c5335f9e71e920114a654bcff" translate="yes" xml:space="preserve">
          <source>This debugger prints a number which increments for each statement encountered and waits for you to hit a newline before continuing to the next statement.</source>
          <target state="translated">이 디버거는 발생한 각 명령문마다 증가하는 숫자를 인쇄하고 다음 명령문을 계속하기 전에 줄 바꿈을 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="67c09da3f20ea7878643178c10aa0a6e33cc924b" translate="yes" xml:space="preserve">
          <source>This declares a block of tests that might be skipped, $how_many tests there are, $why and under what $condition to skip them. An example is the easiest way to illustrate:</source>
          <target state="translated">이것은 건너 뛸 수있는 테스트 블록, $ how_many 테스트, $ why 및 어떤 $ 조건에서 건너 뛸 테스트를 선언합니다. 예를 들어 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44521e30f7e690cd5dc65c30814c4cee699cd60e" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">이러한 분해는 구성 요소가 분해 가능한 중간체 일 수있다. 한 번에 최종 분해를 얻으려면 &lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="97bd528541645ff3d464e572f5a4805e2ee9bc4c" translate="yes" xml:space="preserve">
          <source>This default can be overridden on a per-number basis by calling the &lt;code&gt;display_format&lt;/code&gt; method instead. As before, not supplying any argument returns the current display style for this number. Otherwise whatever you specify will be the new display style for</source>
          <target state="translated">&lt;code&gt;display_format&lt;/code&gt; 메소드를 대신 호출 하여이 기본값을 번호별로 대체 할 수 있습니다 . 이전과 같이 인수를 제공하지 않으면이 숫자의 현재 표시 스타일이 반환됩니다. 그렇지 않으면 당신이 지정한 것은 새로운 디스플레이 스타일이 될 것입니다</target>
        </trans-unit>
        <trans-unit id="b13fed4037708b058149d6d54239c3578805f852" translate="yes" xml:space="preserve">
          <source>This demonstrates how &lt;code&gt;SUPER&lt;/code&gt; is resolved. Even though the object is blessed into the &lt;code&gt;C&lt;/code&gt; class, the &lt;code&gt;speak()&lt;/code&gt; method in the &lt;code&gt;B&lt;/code&gt; class can still call &lt;code&gt;SUPER::speak()&lt;/code&gt; and expect it to correctly look in the parent class of &lt;code&gt;B&lt;/code&gt; (i.e the class the method call is in), not in the parent class of &lt;code&gt;C&lt;/code&gt; (i.e. the class the object belongs to).</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; 가 어떻게 해결 되는지 보여줍니다 . 개체가에 축복하더라도 &lt;code&gt;C&lt;/code&gt; 의 클래스의 &lt;code&gt;speak()&lt;/code&gt; 의 방법 &lt;code&gt;B&lt;/code&gt; 의 클래스는 여전히 호출 할 수 있습니다 &lt;code&gt;SUPER::speak()&lt;/code&gt; 하고 올바르게의 부모 클래스에서 볼 기대 &lt;code&gt;B&lt;/code&gt; (즉, 메서드 호출에있는 클래스 ), &lt;code&gt;C&lt;/code&gt; 의 상위 클래스 (예 : 객체가 속한 클래스 )가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5a18b47e8bc86d748a4aab67a43edef686b92a3f" translate="yes" xml:space="preserve">
          <source>This depends on the tied hash's implementation of EXISTS(). For example, there isn't the concept of undef with hashes that are tied to DBM* files. It also means that exists() and defined() do the same thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.</source>
          <target state="translated">이는 묶인 해시의 EXISTS () 구현에 따라 다릅니다. 예를 들어, DBM * 파일에 묶인 해시가있는 undef의 개념은 없습니다. 또한 exist () 및 defined ()는 DBM * 파일과 동일한 작업을 수행하며 결국 해시로 수행하는 작업이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9d4bc0de5af18f612ccd2a5cae826c99487fcbf8" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt; ; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">프로그램이 실행중인 운영 체제에 따라 다릅니다. 유닉스의 경우, 직렬 포트는 &lt;code&gt;/dev&lt;/code&gt; 의 파일을 통해 액세스 할 수 있습니다 . 다른 시스템에서는 장치 이름이 틀림없이 다릅니다. 모든 장치 상호 작용에 공통적 인 몇 가지 문제 영역은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5829cc9fcaba21dee6f9d7f5a98f9ac945f1487" translate="yes" xml:space="preserve">
          <source>This description is not updated often (since 5.6.1?), see</source>
          <target state="translated">이 설명은 자주 업데이트되지 않습니다 (5.6.1부터?).</target>
        </trans-unit>
        <trans-unit id="20322d80a32c4020d9ededc57d341d0284daf471" translate="yes" xml:space="preserve">
          <source>This directive is supported with ANSI-type function declarations only.</source>
          <target state="translated">이 지시문은 ANSI 유형 함수 선언에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a18a04a1fb981c46cc90618271edcb18e99ed305" translate="yes" xml:space="preserve">
          <source>This directory contains dual-life modules where the CPAN module is canonical. Do not patch these modules directly! Changes to these modules should be submitted to the maintainer of the CPAN module. Once those changes are applied and released, the new version of the module will be incorporated into the core.</source>
          <target state="translated">이 디렉토리에는 CPAN 모듈이 표준 인 이중 수명 모듈이 있습니다. 이 모듈을 직접 패치하지 마십시오! 이러한 모듈에 대한 변경 사항은 CPAN 모듈의 관리자에게 제출해야합니다. 이러한 변경 사항이 적용 및 릴리스되면 새 버전의 모듈이 코어에 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5f151207fd145f47cd0f164782d7d714aa8988" translate="yes" xml:space="preserve">
          <source>This directory contains pure-Perl modules which are only released as part of the core. This directory contains</source>
          <target state="translated">이 디렉토리에는 코어의 일부로 만 릴리스 된 pure-Perl 모듈이 있습니다. 이 디렉토리에는</target>
        </trans-unit>
        <trans-unit id="ff88cb5fa00bc50f7151a1d4596e477618c8bcec" translate="yes" xml:space="preserve">
          <source>This directory is for dual-life modules where the blead source is canonical. Note that some modules in this directory may not yet have been released separately on CPAN. Modules under</source>
          <target state="translated">이 디렉토리는 블리드 소스가 표준 인 이중 수명 모듈 용입니다. 이 디렉토리의 일부 모듈은 아직 CPAN에서 별도로 릴리스되지 않았을 수 있습니다. 아래 모듈</target>
        </trans-unit>
        <trans-unit id="62002fdbbc82dfdecab897397921252b1a422691" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt; .</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;BOOKSHELF&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="333fd828a086a8d956340a5925aba972db5faa95" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 당신은 일을해야합니다</target>
        </trans-unit>
        <trans-unit id="7a7d8abb15dd5ddcab335f051e15e631ee76c9a7" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working man to access these files.</source>
          <target state="translated">이 디렉토리는 &lt;code&gt;MANPATH&lt;/code&gt; 에 있어야합니다 . 이 파일에 액세스하려면 작업중인 사람이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="170ad9fea04adcf28e5b84faabd5cf2954a187d9" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration을&lt;/a&gt; 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="3b3a0993d47177782fe70afdd82bfb741c3d7395" translate="yes" xml:space="preserve">
          <source>This disables the poetry optimization, generating a compile-time error if you try to use a bareword identifier that's not a subroutine, unless it is a simple identifier (no colons) and that it appears in curly braces or on the left hand side of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">이는 간단한 식별자 (콜론 없음)이고 중괄호 또는 왼쪽에 표시되지 않는 한 서브 루틴이 아닌 베어 워드 식별자를 사용하려고하면시 최적화를 비활성화하고 컴파일 타임 오류를 생성합니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호.</target>
        </trans-unit>
        <trans-unit id="34ff219b627159fe6cfa93920427dc7e601e7134" translate="yes" xml:space="preserve">
          <source>This document aims to provide an overview of the vast perl community, which is far too large and diverse to provide a detailed listing. If any specific niche has been forgotten, it is not meant as an insult but an omission for the sake of brevity.</source>
          <target state="translated">이 문서는 광대 한 펄 커뮤니티에 대한 개요를 제공하는 데 목적이 있습니다.이 목록은 너무 넓고 다양하여 자세한 목록을 제공 할 수 없습니다. 특정 틈새를 잊어 버린 경우 모욕이 아니라 간결성을 위해 생략 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ba7340d966579fbb753302864000cf7b2972014" translate="yes" xml:space="preserve">
          <source>This document assumes that the executable named &quot;perl&quot; is Perl version 5. Some systems may have installed Perl version 5 as &quot;perl5&quot;.</source>
          <target state="translated">이 문서에서는 &quot;perl&quot;이라는 실행 파일이 Perl 버전 5라고 가정합니다. 일부 시스템은 Perl 버전 5를 &quot;perl5&quot;로 설치했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a2742d9b73b97368bfc5521e9515184f408ef85" translate="yes" xml:space="preserve">
          <source>This document assumes that you already understand the basics of Perl syntax, variable types, operators, and subroutine calls. If you don't understand these concepts yet, please read &lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt; first. You should also read the &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; documents.</source>
          <target state="translated">이 문서는 사용자가 Perl 구문, 변수 유형, 연산자 및 서브 루틴 호출의 기본 사항을 이미 이해하고 있다고 가정합니다. 이러한 개념을 아직 이해하지 &lt;a href=&quot;perlintro&quot;&gt;못하면&lt;/a&gt; 먼저 perlintro 를 읽으 십시오 . &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; , &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 문서 도 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f596bd16fedee538f262d0de64e96d996439fb3" translate="yes" xml:space="preserve">
          <source>This document attempts to describe how to use the Perl API, as well as to provide some info on the basic workings of the Perl core. It is far from complete and probably contains many errors. Please refer any questions or comments to the author below.</source>
          <target state="translated">이 문서는 Perl API 사용 방법을 설명하고 Perl 코어의 기본 작동에 대한 정보를 제공합니다. 완료되지 않았으며 많은 오류가있을 수 있습니다. 질문이나 의견은 아래 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="7e01fbc0bc773f9d24734cb30bab33bda7d5f6af" translate="yes" xml:space="preserve">
          <source>This document attempts to describe the Perl Community's &quot;best practice&quot; for writing Perl modules. It extends the recommendations found in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , which should be considered required reading before reading this document.</source>
          <target state="translated">이 문서는 Perl 모듈 작성을위한 Perl 커뮤니티의 &quot;모범 사례&quot;를 설명하려고합니다. 이 문서를 읽기 전에 반드시 읽어야하는 &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 권장 사항을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="bab11f45369409b96d7bf2180484dc0f685d2683" translate="yes" xml:space="preserve">
          <source>This document briefly describes Perl under Mac OS X.</source>
          <target state="translated">이 문서는 Mac OS X에서 Perl을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="083d82552ef9adb2b16dbbdc73ee6cb2d3adb7be" translate="yes" xml:space="preserve">
          <source>This document codifies the support and maintenance commitments that the Perl community should expect from Perl's developers:</source>
          <target state="translated">이 문서는 Perl 커뮤니티가 Perl 개발자에게 기대할 수있는 지원 및 유지 보수 약속을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="ee4356257bf892096131087eff39fae084e3b0fb" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt; ) 3.13_01.</source>
          <target state="translated">이 문서는 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; ( &lt;code&gt;xsubpp&lt;/code&gt; 라고도 함 ) 3.13_01에서 지원하는 기능을 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="5d19d436c676e82c5de62fa2d93b31ad146ee5c7" translate="yes" xml:space="preserve">
          <source>This document defines a standard generic interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement automatic dynamic loading of Perl modules.</source>
          <target state="translated">이 문서는 많은 플랫폼에서 사용 가능한 동적 연결 메커니즘에 대한 표준 일반 인터페이스를 정의합니다. 주요 목적은 Perl 모듈의 자동 동적 로딩을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9a30c0ae237ad22360e4681ed6256da44062757" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.05</source>
          <target state="translated">이 문서에서는 Thread :: Queue 버전 3.05에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c32625e21916315b56d3d555dca5fa14529f5283" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.12</source>
          <target state="translated">이 문서는 Thread :: Semaphore 버전 2.12에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0a25c4c9828d0f58970f77b7ac6aa566b68c27f1" translate="yes" xml:space="preserve">
          <source>This document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.</source>
          <target state="translated">이 문서는 모든 백 슬래시 및 이스케이프 시퀀스에 대해 설명합니다. 백 슬래시의 역할을 설명한 후에는 Perl 정규 표현식에서 특별한 의미를 갖는 모든 시퀀스 (알파벳순)를 나열한 다음 각각을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="76ff3a8588f27b8cdd8cc7d51db810e080d05732" translate="yes" xml:space="preserve">
          <source>This document describes all of Perl's object-oriented (OO) features from the ground up. If you're just looking to write some object-oriented code of your own, you are probably better served by using one of the object systems from CPAN described in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">이 문서는 모든 Perl의 객체 지향 (OO) 기능을 처음부터 설명합니다. 자신 만의 객체 지향 코드를 작성하려는 경우 &lt;a href=&quot;perlootut&quot;&gt;perlootut에&lt;/a&gt; 설명 된 CPAN의 객체 시스템 중 하나를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="50f134817136be6999dd57e5d22bbefe3d37d2f5" translate="yes" xml:space="preserve">
          <source>This document describes how Perl internally handles numeric values.</source>
          <target state="translated">이 문서는 Perl이 내부적으로 숫자 값을 처리하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8453dae2d904ec94b51a4ae275d589cad1fe0302" translate="yes" xml:space="preserve">
          <source>This document describes the behavior and implementation of the PerlIO abstraction described in &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; when &lt;code&gt;USE_PERLIO&lt;/code&gt; is defined.</source>
          <target state="translated">이 문서는 행동에서 설명은 PerlIO 추상화 구현 설명 &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; 때 &lt;code&gt;USE_PERLIO&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="a866d5af85544e7e4f21ddcd952a6d5892f7ea0f" translate="yes" xml:space="preserve">
          <source>This document describes the layout of the Perl source tree. If you're hacking on the Perl core, this will help you find what you're looking for.</source>
          <target state="translated">이 문서는 Perl 소스 트리의 레이아웃을 설명합니다. Perl 코어를 해킹하는 경우 원하는 것을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="327aacce5b60fcb7f0492805932fe1dec841e5bb" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.01</source>
          <target state="translated">이 문서는 스레드 버전 2.01을 설명합니다</target>
        </trans-unit>
        <trans-unit id="469ac48c0f559cb018049645e8c6431b0895b43b" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.48</source>
          <target state="translated">이 문서는 threads :: shared 버전 1.48에 대해 설명합니다</target>
        </trans-unit>
        <trans-unit id="645bafb8d9dd20a3e1fad46cb6f3fa997de6c937" translate="yes" xml:space="preserve">
          <source>This document describes various features of FreeBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 FreeBSD의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="321b1b1331ddd1b908bf07373d4048f86b3fa9c7" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's (formerly Compaq's, formerly Digital's) Unix operating system (Tru64) that will affect how Perl version 5 (hereafter just Perl) is configured, compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 구성, 컴파일 및 / 또는 실행에 영향을주는 HP (이전 Compaq (이전의 Digital)) Unix 운영 체제 (Tru64)의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d268ac5a2d19120ce76c77eb58b90ecc6824f4a2" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's Unix operating system (HP-UX) that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl 만)가 컴파일 및 / 또는 실행되는 방식에 영향을주는 HP Unix 운영 체제 (HP-UX)의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2eba298a6bc6800370faf3fd81957d6c988953ae" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's OS/400 operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 IBM OS / 400 운영 체제의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1043854dc3d305d1c7397cad00b2c0693b02060a" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's UNIX operating system AIX that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 IBM UNIX 운영 체제 AIX의 다양한 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e732732feb0181fd46f9c9188d35cc9910b00cf" translate="yes" xml:space="preserve">
          <source>This document describes various features of Irix that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 Irix의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="180f34cce99d47d99da56406605f0fb9ba8ddd90" translate="yes" xml:space="preserve">
          <source>This document describes various features of Linux that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 Linux의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd165af2963c8b766b7c027487cbd05b923f2018" translate="yes" xml:space="preserve">
          <source>This document describes various features of OpenBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 OpenBSD의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bc5bdb1f6483dddcfcf934a3487da7243a97f3cc" translate="yes" xml:space="preserve">
          <source>This document describes various features of Sun's Solaris operating system that will affect how Perl version 5 (hereafter just perl) is compiled and/or runs. Some issues relating to the older SunOS 4.x are also discussed, though they may be out of date.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 perl)가 컴파일 및 / 또는 실행되는 방식에 영향을주는 Sun Solaris 운영 체제의 다양한 기능을 설명합니다. 오래된 SunOS 4.x와 관련된 일부 문제에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="757712086ab3b4685f19333593ba82a0d48290a1" translate="yes" xml:space="preserve">
          <source>This document describes various features of the Symbian operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">이 문서는 Perl 버전 5 (이하 Perl)의 컴파일 및 / 또는 실행 방법에 영향을주는 Symbian 운영 체제의 다양한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a4d121d0bfe8a3c1aa6015bd2c8760d53592dff9" translate="yes" xml:space="preserve">
          <source>This document describes version 0.18 of Locale::Maketext::Simple, released Septermber 8, 2006.</source>
          <target state="translated">이 문서는 2006 년 9 월 8 일에 릴리스 된 Locale :: Maketext :: Simple 버전 0.18에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5e0659e04f3d9f2056b337b0739a67684597732b" translate="yes" xml:space="preserve">
          <source>This document describes version 0.97 of Attribute::Handlers.</source>
          <target state="translated">이 문서는 Attribute :: Handlers 버전 0.97에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="00291624b11a3514d125571e1eabaca275507a74" translate="yes" xml:space="preserve">
          <source>This document describes version 2.09 of File::Path, released 2013-01-17.</source>
          <target state="translated">이 문서는 2013 년 1 월 17 일에 릴리스 된 File :: Path 버전 2.09에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e958fa3bffae7851375960acacad749b89480be8" translate="yes" xml:space="preserve">
          <source>This document differs from &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; in that it is a style guide rather than a tutorial on creating CPAN modules. It provides a checklist against which modules can be compared to determine whether they conform to best practice, without necessarily describing in detail how to achieve this.</source>
          <target state="translated">이 문서는 CPAN 모듈 작성에 대한 학습서가 아니라 스타일 안내서라는 점에서 &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 와 다릅니다 . 이를 달성하는 방법을 자세히 설명하지 않고 모듈이 모범 사례를 준수하는지 여부를 판별하기 위해 비교할 수있는 체크리스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c365d03a0d07def2d5f697a7dff266e86bfcaee" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perlbug bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">이 문서는 Perl 개발 작동 방식을 설명합니다. 여기에는 Perl 5 Porters 이메일 목록, Perl 저장소, Perlbug 버그 추적기, 패치 지침 및 Perl 개발 철학에 대한 설명이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="448289ec7a46caaf1d68d5b7cd3ab508bea55402" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical to Perl's builtin functions.</source>
          <target state="translated">이 문서는 POSIX 모듈에서 사용 가능한 기능의 요약 목록을 제공합니다. 대부분의 기능에 대한 일반적인 정보는 운영 체제 맨 페이지를 참조하십시오. Perl의 내장 기능과 동일한 것으로 표시된 기능에 대해서는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 에 문의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fce74951001e7bfa538197dd8bb5ec9f0e07bc5" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;Further Resources&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">이 문서는 유니 코드에 대한 일반적인 아이디어와 Perl에서 유니 코드를 사용하는 방법을 제공합니다. 유니 코드에 대한 심층적 인 처리에 대한 참조는 &lt;a href=&quot;#Further-Resources&quot;&gt;추가 자료&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a55afa937d8de565fbacea117f04c55c4f3d03c" translate="yes" xml:space="preserve">
          <source>This document gives instructions for building Perl for RISC OS. It is complicated by the need to cross compile. There is a binary version of perl available from &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; which you may wish to use instead of trying to compile it yourself.</source>
          <target state="translated">이 문서는 RISC OS 용 Perl 작성에 대한 지시 사항을 제공합니다. 크로스 컴파일이 필요하기 때문에 복잡합니다. &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; 에서 사용 가능한 바이너리 버전의 perl이 있으며 , 직접 컴파일하려고하지 않고 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f232a362787f4ceadbadf19dad93be195a4a8a" translate="yes" xml:space="preserve">
          <source>This document gives you some suggestions about how to go about writing Perl modules, preparing them for distribution, and making them available via CPAN.</source>
          <target state="translated">이 문서는 Perl 모듈 작성, 배포 준비 및 CPAN을 통해 사용 가능하게하는 방법에 대한 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="132f8081c1f83d30c54e1dd1f8a6c29026e0459f" translate="yes" xml:space="preserve">
          <source>This document has provided several way to go about identifying hot-spots, and checking whether any modifications have improved the runtime of the code.</source>
          <target state="translated">이 문서는 핫스팟을 식별하고 수정 사항으로 인해 코드의 런타임이 향상되었는지 확인하는 여러 가지 방법을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="2f9e9ade072c3d9b2906bfd078f37006fde1b348" translate="yes" xml:space="preserve">
          <source>This document is an attempt to shine some light on the guts of the regex engine and how it works. The regex engine represents a significant chunk of the perl codebase, but is relatively poorly understood. This document is a meagre attempt at addressing this situation. It is derived from the author's experience, comments in the source code, other papers on the regex engine, feedback on the perl5-porters mail list, and no doubt other places as well.</source>
          <target state="translated">이 문서는 정규식 엔진의 내장과 작동 방식에 대해 간략히 설명하기위한 것입니다. 정규식 엔진은 perl 코드베이스의 상당한 부분을 나타내지 만 비교적 잘 이해되지 않습니다. 이 문서는 이러한 상황을 해결하기위한 빈약 한 시도입니다. 그것은 저자의 경험, 소스 코드의 주석, 정규식 엔진에 대한 다른 논문, perl5-porters 메일 목록에 대한 피드백 및 의심 할 여지없이 다른 곳에서도 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f799b102440b11497f30f8301310792802f29f" translate="yes" xml:space="preserve">
          <source>This document is authored and maintained by Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;.</source>
          <target state="translated">이 문서는 Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;이 작성하고 관리합니다.</target>
        </trans-unit>
        <trans-unit id="deb0c7f47e4494d30a1aab35b9ec321b01a2ec44" translate="yes" xml:space="preserve">
          <source>This document is available under the same terms as Perl itself. Code examples in all the perlfaq documents are in the public domain. Use them as you see fit (and at your own risk with no warranty from anyone).</source>
          <target state="translated">이 문서는 Perl과 동일한 용어로 사용 가능합니다. 모든 perlfaq 문서의 코드 예제는 공개 도메인에 있습니다. 적합하다고 생각되는대로 사용하십시오 (그리고 다른 사람의 보증없이 자신의 위험 부담).</target>
        </trans-unit>
        <trans-unit id="931cd9f92a3e4b725c73c5f241d6c52b01e63f35" translate="yes" xml:space="preserve">
          <source>This document is detailed notes on the Pod markup language. Most people will only have to read &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; to know how to write in Pod, but this document may answer some incidental questions to do with parsing and rendering Pod.</source>
          <target state="translated">이 문서는 포드 마크 업 언어에 대한 자세한 정보입니다. 대부분의 사람들은 포드를 작성하는 방법을 알기 위해 &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 만 읽으면 되지만,이 문서는 포드 구문 분석 및 렌더링과 관련하여 부수적 인 질문에 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5499e713f269332b5a031b1d5ec104878d26d5" translate="yes" xml:space="preserve">
          <source>This document is intended to give you a quick overview of the Perl programming language, along with pointers to further documentation. It is intended as a &quot;bootstrap&quot; guide for those who are new to the language, and provides just enough information for you to be able to read other peoples' Perl and understand roughly what it's doing, or write your own simple scripts.</source>
          <target state="translated">이 문서는 추가 문서에 대한 포인터와 함께 Perl 프로그래밍 언어에 대한 간략한 개요를 제공합니다. 이 언어는 언어를 처음 접하는 사람들을위한 &quot;부트 스트랩 (bootstrap)&quot;안내서로서 다른 사람들의 Perl을 읽고 그 내용을 대략 이해하거나 간단한 스크립트를 작성할 수 있도록 충분한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04d450fbf5761325924f000d871533277846798f" translate="yes" xml:space="preserve">
          <source>This document is maintained by Jan Dubois.</source>
          <target state="translated">이 문서는 Jan Dubois가 관리합니다.</target>
        </trans-unit>
        <trans-unit id="6ad1ca1a9c1e0e6df1be4b460cdb832dc533d65a" translate="yes" xml:space="preserve">
          <source>This document is meant to be a detailed but understandable treatment of the many different sorts of data structures you might want to develop. It should also serve as a cookbook of examples. That way, when you need to create one of these complex data structures, you can just pinch, pilfer, or purloin a drop-in example from here.</source>
          <target state="translated">이 문서는 개발하고자하는 다양한 종류의 데이터 구조에 대한 상세하지만 이해하기 쉬운 처리를 목적으로합니다. 또한 예제 요리 책으로도 사용되어야합니다. 이런 식으로 복잡한 데이터 구조 중 하나를 생성해야 할 경우 여기에서 드롭 인 예제를 집어 내거나 모으거나 흘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf997dd7f7e98ee160d1fffa9d041813ac9f4bb" translate="yes" xml:space="preserve">
          <source>This document is meant to help you to find out what constitutes portable Perl code. That way once you make a decision to write portably, you know where the lines are drawn, and you can stay within them.</source>
          <target state="translated">이 문서는 휴대용 Perl 코드를 구성하는 요소를 찾는 데 도움이됩니다. 그렇게하면 이식성있는 글을 쓰기로 결정하면 선이 그려지는 위치를 알 수 있으며 그 안에 머물 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9f3d95216c84aa89657f351bb6eefc71ea99a0" translate="yes" xml:space="preserve">
          <source>This document is provided in the hope that it will be useful, but without any warranty; without even the implied warranty of accuracy, authoritativeness, completeness, merchantability, or fitness for a particular purpose.</source>
          <target state="translated">이 문서는 도움이 되길 바라지 만 보증없이 제공됩니다. 정확성, 권위, 완전성, 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증 없이도.</target>
        </trans-unit>
        <trans-unit id="c3a1d5c913f755b58160ddd4ac8b4f8158d38b0a" translate="yes" xml:space="preserve">
          <source>This document is the master document which records all written policies about how the Perl 5 Porters collectively develop and maintain the Perl core.</source>
          <target state="translated">이 문서는 Perl 5 포터가 Perl 코어를 공동으로 개발하고 유지하는 방법에 대한 모든 서면 정책을 기록한 마스터 문서입니다.</target>
        </trans-unit>
        <trans-unit id="6445b4e91fdc1237d3a1bc4a31d98919bdef331e" translate="yes" xml:space="preserve">
          <source>This document lists the current and past experimental features in the perl core. Although all of these are documented with their appropriate topics, this succinct listing gives you an overview and basic facts about their status.</source>
          <target state="translated">이 문서는 펄 코어의 현재 및 과거 실험 기능을 나열합니다. 이들 모두가 적절한 주제와 함께 문서화되어 있지만이 간결한 목록은 해당 상태에 대한 개요 및 기본 사실을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e04379014fdbc8385dc766fdec2dc2ab609657d0" translate="yes" xml:space="preserve">
          <source>This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 Perl 자체와 동일한 용어로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68809e455146d4d0b2eb575625c0befbf01b3e91" translate="yes" xml:space="preserve">
          <source>This document may be incomplete in some respects.</source>
          <target state="translated">이 문서는 일부 측면에서 불완전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40e2bd179554762718d2c8f40e4558baafd8315" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">이 문서는 사용 가능한 모든 속성 만 나열하며 각 속성이 실제로 무엇을 의미하는지 설명하지는 않습니다. 각 Perl 확장에 대한 간단한 설명이 있습니다. &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;이에&lt;/a&gt; 대한 자세한 정보 는 perlunicode의 기타 특성을 참조하십시오 . 거기에서 블록, 스크립트, General_Category 및 Bidi_Class에 대한 몇 가지 세부 사항입니다 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode는&lt;/a&gt; 하지만, 유니 코드 표준을 참조, 공식 유니 코드 속성의 복잡한에 대해 알아. 좋은 출발지는 &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69e6772a5d46653631303f536faddc78ecd15c3a" translate="yes" xml:space="preserve">
          <source>This document mostly explains the</source>
          <target state="translated">이 문서는 주로</target>
        </trans-unit>
        <trans-unit id="a7ddd5955e611e8402df676dc922c52fe96687d9" translate="yes" xml:space="preserve">
          <source>This document needs a rewrite that separates the tutorial content from the reference content.</source>
          <target state="translated">이 문서는 튜토리얼 컨텐츠를 참조 컨텐츠와 분리하는 재 작성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5434f0b9e2b7cf484cc38556a1c3be222c03edd" translate="yes" xml:space="preserve">
          <source>This document provides a general overview of the capabilities and limitations of the fork() emulation. Note that the issues discussed here are not applicable to platforms where a real fork() is available and Perl has been configured to use it.</source>
          <target state="translated">이 문서는 fork () 에뮬레이션의 기능과 한계에 대한 일반적인 개요를 제공합니다. 여기서 논의 된 문제는 실제 fork ()를 사용할 수 있고 Perl이이를 사용하도록 구성된 플랫폼에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93c5711ad21bddf8f27384e848494d1a512f01be" translate="yes" xml:space="preserve">
          <source>This document provides a reference for Perl's object orientation features. If you're looking for an introduction to object-oriented programming in Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Perl의 객체 방향 기능에 대한 참조를 제공합니다. Perl에서 객체 지향 프로그래밍에 대한 소개를 찾고 있다면 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46a94276417126d2ba57635546eac62791e072d3" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">이 문서는 Perl의 객체 지향 프로그래밍에 대한 소개를 제공합니다. 객체 지향 디자인의 개념에 대한 간략한 개요로 시작합니다. 그런 다음 Perl이 제공하는 것 위에 구축 된 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN의&lt;/a&gt; 여러 가지 OO 시스템을 소개 합니다.</target>
        </trans-unit>
        <trans-unit id="6876a82e12e5ab947f419b2c224d987985e1ad19" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the Perl interpreter works at the level of C code, along with pointers to the relevant C source code files.</source>
          <target state="translated">이 문서는 Perl 인터프리터가 C 코드 레벨에서 관련 C 소스 코드 파일에 대한 포인터와 함께 작동하는 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98ef42b4ebd0391f6b1eb2c007891c9540cce7bb" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;Other information in the Unicode data base&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">이 문서는 문자 속성을 처리하는 유니 코드 데이터베이스 부분, 즉 단일 코드 포인트에 정의 된 부분에 대한 정보를 제공합니다. ( 아래 &lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;유니 코드 데이터베이스의&lt;/a&gt; 다른 정보는 유니 코드가 제공하는 다른 데이터를 간단히 언급합니다.)</target>
        </trans-unit>
        <trans-unit id="b2a79746685de57fddf566ba23eb18f1694b69ba" translate="yes" xml:space="preserve">
          <source>This document serves as both a specification for anyone wishing to implement the DynaLoader for a new platform and as a guide for anyone wishing to use the DynaLoader directly in an application.</source>
          <target state="translated">이 문서는 새로운 플랫폼을 위해 DynaLoader를 구현하려는 모든 사람을위한 사양과 애플리케이션에서 직접 DynaLoader를 사용하려는 모든 사람을위한 안내서 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="4c2fd7fb88b1605d6c1c01cd882956329e66498d" translate="yes" xml:space="preserve">
          <source>This document takes you through a simple patch example.</source>
          <target state="translated">이 문서는 간단한 패치 예제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="482b84044bf12cbb74ce5534dc67232a2bb4bcd3" translate="yes" xml:space="preserve">
          <source>This document varies from difficult to understand to completely and utterly opaque. The wandering prose riddled with jargon is hard to fathom in several places.</source>
          <target state="translated">이 문서는 이해하기 어려운 것에서부터 완전히 그리고 완전히 불투명 한 것까지 다양합니다. 전문 용어로 가득 찬 방황하는 산문은 여러 곳에서 사기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e494f5a4ef902fd5cb4de9dfa1a90e73e0fc46e2" translate="yes" xml:space="preserve">
          <source>This document walks through the creation of a small patch to Perl's C code. If you're just getting started with Perl core hacking, this will help you understand how it works.</source>
          <target state="translated">이 문서는 Perl의 C 코드에 대한 작은 패치 작성을 안내합니다. Perl 코어 해킹을 시작한 경우 이것이 어떻게 작동하는지 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e368b4b82da174b5c34f4ad74472953966358bf" translate="yes" xml:space="preserve">
          <source>This document was created in February, 2011, and the last major revision was in February, 2013.</source>
          <target state="translated">이 문서는 2011 년 2 월에 작성되었으며 마지막 주요 개정판은 2013 년 2 월에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="e89c4ac20e63934f15f4f06f3bdf35dc35e9054b" translate="yes" xml:space="preserve">
          <source>This document was originally written by David Fiander for the 5.005 release of Perl.</source>
          <target state="translated">이 문서는 원래 David Fiander가 Perl 5.005 릴리스 용으로 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="44116b950aea8406dc1d009e3e7e8df16d0f1901" translate="yes" xml:space="preserve">
          <source>This document was originally written by Nathan Torkington, and is maintained by the perl5-porters mailing list.</source>
          <target state="translated">이 문서는 원래 Nathan Torkington이 작성했으며 perl5-porters 메일 링리스트에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="cb57f1783ae5d9d11a07aa4ee9a4142c141dd869" translate="yes" xml:space="preserve">
          <source>This document was originally written by Thomas Dorner for the 5.005 release of Perl.</source>
          <target state="translated">이 문서는 원래 Thomas Dorner가 Perl 5.005 릴리스 용으로 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="8245e0ace1fc709b9c52b2d684fbab4d872b4b6b" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.005_03 release of Perl 11 March 1999.</source>
          <target state="translated">이 문서는 1999 년 3 월 11 일 Perl의 5.005_03 릴리스로 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="01c73c6cbc6ea7a7507692f73f286583700f23f4" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.6 release of perl 11 July 2000.</source>
          <target state="translated">이 문서는 2000 년 7 월 11 일 perl의 5.6 릴리스에 맞게 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e3d3763f0de441b0bf953c53b8f14562b8c6d91b" translate="yes" xml:space="preserve">
          <source>This document was revised 09-October-1996 for Perl 5.003_7.</source>
          <target state="translated">이 문서는 Perl 5.003_7에 대해 1996 년 10 월 9 일에 개정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ae9aedfb6e910ab590ab6a48004a6cd92829aac" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on BS2000 in the POSIX subsystem.</source>
          <target state="translated">이 문서는 POSIX 서브 시스템의 BS2000에서 Perl을 구성, 빌드, 테스트 및 설치하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb2db0bdd80184dad93c70d1f7773c61d926757" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on OS/390 (aka z/OS) Unix System Services.</source>
          <target state="translated">이 문서는 OS / 390 (일명 z / OS) Unix 시스템 서비스에서 Perl을 구성, 빌드, 테스트 및 설치하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b14dd21b17eb4778756f16a28286f3080a5b52fc" translate="yes" xml:space="preserve">
          <source>This document will help you configure, make, test and install Perl on Cygwin. This document also describes features of Cygwin that will affect how Perl behaves at runtime.</source>
          <target state="translated">이 문서는 Cygwin에서 Perl을 구성, 작성, 테스트 및 설치하는 데 도움이됩니다. 이 문서는 런타임에 Perl의 작동 방식에 영향을주는 Cygwin의 기능에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4b25a8a1d43deec5996faad1ce1066a1b7f65307" translate="yes" xml:space="preserve">
          <source>This document will help you learn the best way to go about hacking on the Perl core C code. It covers common problems, debugging, profiling, and more.</source>
          <target state="translated">이 문서는 Perl 코어 C 코드를 해킹하는 가장 좋은 방법을 배우는 데 도움이됩니다. 일반적인 문제, 디버깅, 프로파일 링 등을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="7b1ceac6a2e862b1ba010e29c7ba5c554256d9b3" translate="yes" xml:space="preserve">
          <source>This documentation describes version 0.08.</source>
          <target state="translated">이 문서는 버전 0.08을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bb13bb5cc25da0a84b0ee6fe56550c8fa997e8a4" translate="yes" xml:space="preserve">
          <source>This documentation is for people who want to download CPAN modules and install them on their own computer.</source>
          <target state="translated">이 문서는 CPAN 모듈을 다운로드하여 자신의 컴퓨터에 설치하려는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9807e2f281735ce8b4db75a087a60d39d5eaabb" translate="yes" xml:space="preserve">
          <source>This documentation is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1e03b9948de51dc9fc37899fb9224e953fca3a" translate="yes" xml:space="preserve">
          <source>This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 문서는 무료입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cceba8951b48c0df6a7d7a78ae98404b2be1a5f6" translate="yes" xml:space="preserve">
          <source>This documentation is maintained as part of the podlators distribution. The current version is always available from its web site at &amp;lt;&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">이 문서는 podlators 배포판의 일부로 유지됩니다. 현재 버전은 항상 웹 사이트 &amp;lt; &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; &amp;gt; 에서 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee59b544a64dcf3a8c36474bf7a745c77abd72ed" translate="yes" xml:space="preserve">
          <source>This documentation provided by Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007.</source>
          <target state="translated">이 문서는 Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d579dc02247e710bddf4fd80263160b958f95883" translate="yes" xml:space="preserve">
          <source>This does a &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; check on the argument provided. The &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the argument must be the same as the &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the default value for this check to pass.</source>
          <target state="translated">제공된 인수에 대해 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 검사를 수행합니다. &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 인수의은과 동일해야합니다 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 이 검사 통과에 대한 기본 값.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
