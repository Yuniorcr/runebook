<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2fabb550524d3e9edaaeec56458f89ae111e042a" translate="yes" xml:space="preserve">
          <source>For improved performance, include:</source>
          <target state="translated">성능을 향상 시키려면 다음을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b48d4e66bee46bcdb174582c112372d1e36d74" translate="yes" xml:space="preserve">
          <source>For including perl header files this function simply prints:</source>
          <target state="translated">펄 헤더 파일을 포함시키기 위해이 함수는 단순히 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b8b2246aaa2d68e99fd635ee467d71b09bb4bd64" translate="yes" xml:space="preserve">
          <source>For information on OO programming with Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">Perl을 사용한 OO 프로그래밍에 대한 정보는 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 및 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a44b4f224e3945a9a157e926bd85c54a2b806624" translate="yes" xml:space="preserve">
          <source>For information on compilers on older versions of AIX, see &lt;a href=&quot;#Compiling-Perl-5-on-older-AIX-versions-up-to-4.3.3&quot;&gt;Compiling Perl 5 on older AIX versions up to 4.3.3&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 AIX에서 컴파일러에 대한 정보는 &lt;a href=&quot;#Compiling-Perl-5-on-older-AIX-versions-up-to-4.3.3&quot;&gt;최대 4.3.3&lt;/a&gt; 이전 버전의 AIX에서 Perl 5 컴파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e475bfd513c3fa5a177d8f4cb9e523eea02595c6" translate="yes" xml:space="preserve">
          <source>For installation of the Unix emulation, read the appropriate docs.</source>
          <target state="translated">유닉스 에뮬레이션을 설치하려면 해당 문서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="82185638546b1e3be3173f75a2cb122a36a8e321" translate="yes" xml:space="preserve">
          <source>For instance in</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">For instance,</target>
        </trans-unit>
        <trans-unit id="d9622af028e4033dfcc0d167b46ab4c597968052" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;\p{Uppercase}&lt;/code&gt; matches any single character with the Unicode &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; property, while &lt;code&gt;\p{L}&lt;/code&gt; matches any character with a &lt;code&gt;General_Category&lt;/code&gt; of &lt;code&gt;&quot;L&quot;&lt;/code&gt; (letter) property (see &lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt; below). Brackets are not required for single letter property names, so &lt;code&gt;\p{L}&lt;/code&gt; is equivalent to &lt;code&gt;\pL&lt;/code&gt; .</source>
          <target state="translated">예를 들어, &lt;code&gt;\p{Uppercase}&lt;/code&gt; 는 유니 코드 &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; 속성을 사용하는 단일 문자와 일치 하지만 &lt;code&gt;\p{L}&lt;/code&gt; 은 &lt;code&gt;General_Category&lt;/code&gt; 가 &lt;code&gt;&quot;L&quot;&lt;/code&gt; (letter) 속성 을 갖는 문자와 일치합니다 (아래 &lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt; 참조). 단일 문자 속성 이름에는 대괄호가 필요하지 않으므로 &lt;code&gt;\p{L}&lt;/code&gt; 은 &lt;code&gt;\pL&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c14488c9703c3faf25c072547bcce9b9c6d026a" translate="yes" xml:space="preserve">
          <source>For instance, here's part of the report from the</source>
          <target state="translated">예를 들어 다음은 보고서의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="7503b0a59ae7cf568e520699d192f582d8728a5a" translate="yes" xml:space="preserve">
          <source>For instance, if B = 10000, the number 1234567890 is represented internally as [3456, 7890, 12].</source>
          <target state="translated">예를 들어, B = 10000이면 숫자 1234567890은 내부적으로 [3456, 7890, 12]로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0a5b8d1bb99d582e6babc450d597df94876d661f" translate="yes" xml:space="preserve">
          <source>For instance, if the object $obj represents the hexadecimal number 0xabcde, then &lt;code&gt;_rsft($obj, 2, 16)&lt;/code&gt; returns an object representing the number 0xabc. The &quot;remainer&quot;, 0xde, is discarded and not returned.</source>
          <target state="translated">예를 들어 $ obj 객체가 16 진수 0xabcde를 나타내는 경우 &lt;code&gt;_rsft($obj, 2, 16)&lt;/code&gt; 는 0xabc 번호를 나타내는 객체를 반환합니다. &quot;나머지&quot;, 0xde는 버려지고 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ec9b07fa26c1960352cc0e11e6a493987aa28ff" translate="yes" xml:space="preserve">
          <source>For instance, the &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; routine which computes the square root of its argument is only defined for non-negative real numbers and yields a non-negative real number (it is an application from &lt;b&gt;R+&lt;/b&gt; to &lt;b&gt;R+&lt;/b&gt;). If we allow it to return a complex number, then it can be extended to negative real numbers to become an application from &lt;b&gt;R&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt; (the set of complex numbers):</source>
          <target state="translated">예를 들어, 인수 의 &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 을 계산 하는 sqrt 루틴은 음이 아닌 실수에 대해서만 정의되고 음이 아닌 실수를 생성합니다 ( &lt;b&gt;R +&lt;/b&gt; 에서 &lt;b&gt;R +&lt;/b&gt; 까지 의 응용 프로그램 &lt;b&gt;임&lt;/b&gt; ). 복소수를 반환하도록 허용하면 음수의 실수로 확장되어 &lt;b&gt;R&lt;/b&gt; 에서 &lt;b&gt;C&lt;/b&gt; 로의 응용 프로그램이 될 수 있습니다 (복소수 집합).</target>
        </trans-unit>
        <trans-unit id="c71534a4a55ea4fd39c101e16a7e78a572754ea2" translate="yes" xml:space="preserve">
          <source>For instance, the MGVTBL structure called &lt;code&gt;vtbl_sv&lt;/code&gt; (which corresponds to an &lt;code&gt;mg_type&lt;/code&gt; of &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; ) contains:</source>
          <target state="translated">예를 들어, 호출 MGVTBL 구조 &lt;code&gt;vtbl_sv&lt;/code&gt; 는 (어떤에 대응 &lt;code&gt;mg_type&lt;/code&gt; 의 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; ) 포함</target>
        </trans-unit>
        <trans-unit id="9ed32d78c1e09dbba1a9af89bf4a97865e921d05" translate="yes" xml:space="preserve">
          <source>For instance, to make our report order case-insensitive, we use &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; to lowercase the keys before comparing them:</source>
          <target state="translated">예를 들어, 보고서 순서를 대소 문자를 구분하지 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 려면 lc 를 사용 하여 키를 비교하기 전에 소문자를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7cfc93ae0f30aa1f0666b1f4bcb636c1b64a91aa" translate="yes" xml:space="preserve">
          <source>For integer conversions, specifying a precision implies that the output of the number itself should be zero-padded to this width, where the 0 flag is ignored:</source>
          <target state="translated">정수 변환의 경우 정밀도를 지정하면 숫자 자체의 출력이이 너비에 0으로 채워 져야합니다. 여기서 0 플래그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd617b52663df6a2cd98775b9d0bdd10ec28a70" translate="yes" xml:space="preserve">
          <source>For intrepid programmers, the indispensable textbook is</source>
          <target state="translated">대담한 프로그래머에게 없어서는 안될 교과서는</target>
        </trans-unit>
        <trans-unit id="d3c8026914e8193ab94f632a808acbe08f5e1e3d" translate="yes" xml:space="preserve">
          <source>For licensing inquiries, contact the author at:</source>
          <target state="translated">라이센스 문의 사항은 다음 주소의 저자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="ce2ac808344a2fda3717bca04925f57752ba466c" translate="yes" xml:space="preserve">
          <source>For licensing the easiest way is to use the same licensing as Perl itself:</source>
          <target state="translated">라이센스를 얻는 가장 쉬운 방법은 Perl과 동일한 라이센스를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="22eb832a816ecf29dad84d085c065a38bc3edb22" translate="yes" xml:space="preserve">
          <source>For locales available in your system, consult also</source>
          <target state="translated">시스템에서 사용 가능한 로케일에 대해서는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="863f28adc13f8c8f63960f8d4f2a4b8a92bd94fd" translate="yes" xml:space="preserve">
          <source>For lookup of</source>
          <target state="translated">조회</target>
        </trans-unit>
        <trans-unit id="34229681f9d4faff26200baa4f876a94429acced" translate="yes" xml:space="preserve">
          <source>For low-level access to the formatting mechanism, you may use formline() and access &lt;code&gt;$^A&lt;/code&gt; (the $ACCUMULATOR variable) directly.</source>
          <target state="translated">서식 메커니즘에 대한 저수준 액세스의 경우 formline ()을 사용하고 &lt;code&gt;$^A&lt;/code&gt; ($ ACCUMULATOR 변수)에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dda78cd120d71d7294ab5327cc0bc80f1754e64b" translate="yes" xml:space="preserve">
          <source>For lower-level direct manipulation of &lt;code&gt;op_sibparent&lt;/code&gt; and &lt;code&gt;op_moresib&lt;/code&gt; , see &lt;code&gt;OpMORESIB_set&lt;/code&gt; , &lt;code&gt;OpLASTSIB_set&lt;/code&gt; , &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;op_sibparent&lt;/code&gt; 및 &lt;code&gt;op_moresib&lt;/code&gt; 의 하위 레벨 직접 조작에 대해서는 &lt;code&gt;OpMORESIB_set&lt;/code&gt; , &lt;code&gt;OpLASTSIB_set&lt;/code&gt; , &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a2710d99c8e59b0ca1361e7bf2da876fb54697f" translate="yes" xml:space="preserve">
          <source>For maintenance clarity, no functions are exported by default. These functions are available for backwards compatibility only and are best avoided in favor of &lt;code&gt;load_file&lt;/code&gt; .</source>
          <target state="translated">유지 관리의 명확성을 위해 기본적으로 함수가 내보내지지 않습니다. 이러한 함수는 이전 버전과의 호환성을 위해서만 사용할 수 있으며 &lt;code&gt;load_file&lt;/code&gt; 을 위해 사용하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="66d2d5bbea31d0eff0a07151ddd0f30d9798a0b6" translate="yes" xml:space="preserve">
          <source>For many Perl functions, the CORE package contains real subroutines. This feature is new in Perl 5.16. You can take references to these and make aliases. However, some can only be called as barewords; i.e., you cannot use ampersand syntax (&lt;code&gt;&amp;amp;foo&lt;/code&gt; ) or call them through references. See the &lt;code&gt;shove&lt;/code&gt; example above. These subroutines exist for all keywords except the following:</source>
          <target state="translated">많은 Perl 기능의 경우 CORE 패키지에는 실제 서브 루틴이 포함되어 있습니다. 이 기능은 Perl 5.16의 새로운 기능입니다. 이것들을 참조하고 별칭을 만들 수 있습니다. 그러나 일부는 베어 워드로만 호출 할 수 있습니다. 즉, 앰퍼샌드 구문 ( &lt;code&gt;&amp;amp;foo&lt;/code&gt; )을 사용하거나 참조를 통해 호출 할 수 없습니다 . 참고 항목 &lt;code&gt;shove&lt;/code&gt; 위의 예. 이 서브 루틴은 다음을 제외한 모든 키워드에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8ef8504526bafcd83f659e5d29383951a3389b63" translate="yes" xml:space="preserve">
          <source>For many common uses of the module, the read cache is a liability. For example, a program that inserts a single record, or that scans the file once, will have a cache hit rate of zero. This suggests a major optimization: The cache should be initially disabled. Here's a hybrid approach: Initially, the cache is disabled, but the cache code maintains statistics about how high the hit rate would be *if* it were enabled. When it sees the hit rate get high enough, it enables itself. The STAT comments in this code are the beginning of an implementation of this.</source>
          <target state="translated">모듈을 많이 사용하는 경우 읽기 캐시는 책임입니다. 예를 들어, 단일 레코드를 삽입하거나 파일을 한 번 스캔하는 프로그램의 캐시 적중률은 0입니다. 이는 주요 최적화를 제안합니다. 캐시는 처음에 비활성화해야합니다. 하이브리드 접근 방식은 다음과 같습니다. 처음에는 캐시가 비활성화되어 있지만 캐시 코드는 활성화 된 적중률이 얼마나 높은지에 대한 통계를 유지합니다. 적중률이 충분히 높아지면 스스로 작동합니다. 이 코드의 STAT 주석은이 구현의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="e0f179826fe2c92a37ede899dfe2a03f1a5c458a" translate="yes" xml:space="preserve">
          <source>For many functions, you can also query &lt;code&gt;%Config&lt;/code&gt; , exported by default from the &lt;code&gt;Config&lt;/code&gt; module. For example, to check whether the platform has the &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, check &lt;code&gt;$Config{d_lstat}&lt;/code&gt; . See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for a full description of available variables.</source>
          <target state="translated">많은 기능의 경우 기본적으로 &lt;code&gt;Config&lt;/code&gt; 모듈 에서 내 보낸 &lt;code&gt;%Config&lt;/code&gt; 쿼리 할 수도 있습니다 . 예를 들어, 플랫폼에 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 호출이 있는지 확인하려면 &lt;code&gt;$Config{d_lstat}&lt;/code&gt; 확인하십시오 . 사용 가능한 변수에 대한 자세한 설명은 &lt;a href=&quot;config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efd5a9c50ebfeb1864b8fd6e6ed8e999df584565" translate="yes" xml:space="preserve">
          <source>For many people, Perl serves as a great replacement for shell scripting. For others, it serves as a convenient, high-level replacement for most of what they'd program in low-level languages like C or C++. It's ultimately up to you (and possibly your management) which tasks you'll use Perl for and which you won't.</source>
          <target state="translated">많은 사람들에게 Perl은 쉘 스크립팅의 훌륭한 대체물입니다. 다른 사람들에게는 C 또는 C ++와 같은 저수준 언어로 프로그래밍 한 대부분을 편리하고 높은 수준으로 대체하는 역할을합니다. Perl을 사용할 작업과 사용하지 않을 작업은 궁극적으로 사용자 (및 아마도 관리)에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b046ce891b8b5f7d7f37e47256b7841d3461b86" translate="yes" xml:space="preserve">
          <source>For many typemap examples, refer to the core typemap file that can be found in the perl source tree at</source>
          <target state="translated">많은 타입 맵 예제는 펄 소스 트리에서 찾을 수있는 코어 타입 맵 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0610ac0b02cfa9a7d3209596fa010908429083d" translate="yes" xml:space="preserve">
          <source>For maximum security, endeavour always to avoid ever looking at, touching, or even imputing the existence of the filename. You do not know that that filename is connected to the same file as the handle you have, and attempts to check this can only trigger more race conditions. It's far more secure to use the filehandle alone and dispense with the filename altogether.</source>
          <target state="translated">최대한의 보안을 위해 파일 이름의 존재를 보거나 만지거나 전가하지 않도록 항상 노력하십시오. 해당 파일 이름이 소유하고있는 핸들과 동일한 파일에 연결되어 있는지 알 수 없으며이를 확인하려고하면 더 많은 경쟁 조건 만 트리거 할 수 있습니다. 파일 핸들 만 사용하고 파일 이름을 사용하지 않는 것이 훨씬 안전합니다.</target>
        </trans-unit>
        <trans-unit id="220ffe1d077d6e4643b22c57e942ba4049701e75" translate="yes" xml:space="preserve">
          <source>For measuring time in better granularity than one second, use the &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module from Perl 5.8 onwards (or from CPAN before then), or, if you have gettimeofday(2), you may be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface of Perl. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 시간을 측정하려면 Perl 5.8 이후 (또는 그 이전의 CPAN)부터 &lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; 모듈을 사용 하거나 gettimeofday (2)가있는 경우 Perl 의 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스 를 사용할 수 있습니다. . 자세한 내용은 &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b053fd32cc090c58c85994234835bd9b44b038f0" translate="yes" xml:space="preserve">
          <source>For measuring time in better granularity than one second, use the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module from Perl 5.8 onwards (or from CPAN before then), or, if you have gettimeofday(2), you may be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface of Perl. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 시간을 측정하려면 Perl 5.8 이후 (또는 그 이전의 CPAN)부터 &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; 모듈을 사용 하거나 gettimeofday (2)가있는 경우 Perl 의 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스 를 사용할 수 있습니다. . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a7dc3da9f9150a0f4e59b825d03d586115ca6af" translate="yes" xml:space="preserve">
          <source>For modules which ARE classes, and need to handle inherited methods, stubs are needed to ensure that the method inheritance mechanism works properly. You can load the stubs into the module at 'require' time, by adding the statement 'SelfLoader-&amp;gt;load_stubs();' to the module to do this.</source>
          <target state="translated">클래스이며 상속 된 메서드를 처리해야하는 모듈의 경우 메서드 상속 메커니즘이 제대로 작동하도록하려면 스텁이 필요합니다. 'SelfLoader-&amp;gt; load_stubs ();'문을 추가하여 '필수'시간에 스텁을 모듈에로드 할 수 있습니다. 이를 위해 모듈에</target>
        </trans-unit>
        <trans-unit id="25217607f7b7b4f54ca08eb0f1fc36241da39944" translate="yes" xml:space="preserve">
          <source>For modules which are not classes, this section is not relevant. This section is only relevant if you have methods which could be inherited.</source>
          <target state="translated">클래스가 아닌 모듈의 경우이 섹션은 관련이 없습니다. 이 섹션은 상속 가능한 메소드가있는 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a15f44066dff1f2c0c9c7cbcbbd443cbb90819" translate="yes" xml:space="preserve">
          <source>For modules, get the CGI or LWP modules from CPAN. For textbooks, see the two especially dedicated to web stuff in the question on books. For problems and questions related to the web, like &quot;Why do I get 500 Errors&quot; or &quot;Why doesn't it run from the browser right when it runs fine on the command line&quot;, see the troubleshooting guides and references in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; or in the CGI MetaFAQ:</source>
          <target state="translated">모듈의 경우 CPAN에서 CGI 또는 LWP 모듈을 가져 오십시오. 교과서의 경우 특히 도서 관련 질문에 대한 웹 전용 두 가지를 참조하십시오. &quot;500 개의 오류가 발생하는 이유&quot;또는 &quot;명령 줄에서 제대로 실행될 때 브라우저에서 제대로 실행되지 않는 이유&quot;와 같은 웹과 관련된 문제 및 질문은 &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 또는 다음 의 문제 해결 안내서 및 참조를 참조하십시오. CGI MetaFAQ :</target>
        </trans-unit>
        <trans-unit id="c19610a9a975a0cf5248edf9977288237aa0d121" translate="yes" xml:space="preserve">
          <source>For more about scripts versus blocks, see UAX#24 &quot;Unicode Script Property&quot;: &lt;a href=&quot;http://www.unicode.org/reports/tr24&quot;&gt;http://www.unicode.org/reports/tr24&lt;/a&gt;</source>
          <target state="translated">스크립트 대 블록에 대한 자세한 내용은 UAX # 24 &quot;유니 코드 스크립트 속성&quot;을 &lt;a href=&quot;http://www.unicode.org/reports/tr24&quot;&gt;참조하십시오&lt;/a&gt; . http://www.unicode.org/reports/tr24</target>
        </trans-unit>
        <trans-unit id="a0f84e3d4e18aa471a205e575dceae5b441a5a9b" translate="yes" xml:space="preserve">
          <source>For more benchmark results see &lt;a href=&quot;http://bloodgate.com/perl/benchmarks.html&quot;&gt;http://bloodgate.com/perl/benchmarks.html&lt;/a&gt;.</source>
          <target state="translated">더 많은 벤치 마크 결과는 &lt;a href=&quot;http://bloodgate.com/perl/benchmarks.html&quot;&gt;http://bloodgate.com/perl/benchmarks.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a12676c43bab4536e6ed20980a2aaf16b4eccc1" translate="yes" xml:space="preserve">
          <source>For more complex signal handling, you might see the standard POSIX module. Lamentably, this is almost entirely undocumented, but the</source>
          <target state="translated">보다 복잡한 신호 처리를 위해 표준 POSIX 모듈이 표시 될 수 있습니다. 불행히도, 이것은 거의 전적으로 문서화되어 있지 않지만</target>
        </trans-unit>
        <trans-unit id="be1e0dddb201330ac943f0c7f8b66035ebd2739a" translate="yes" xml:space="preserve">
          <source>For more detail on each item in this checklist, see below.</source>
          <target state="translated">이 점검 목록의 각 항목에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b905a813e9b57da3dea6d150de2f4e3eac205961" translate="yes" xml:space="preserve">
          <source>For more detail on looping constructs (and some that weren't mentioned in this overview) see &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">루핑 구조 (및이 개요에서 언급되지 않은 일부)에 대한 자세한 내용은 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cce3d22b488b424d06498a184d62a8579f8068a" translate="yes" xml:space="preserve">
          <source>For more detailed explanation of the available commands and output formats, see your own local documentation of</source>
          <target state="translated">사용 가능한 명령 및 출력 형식에 대한 자세한 설명은 해당 지역의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="191b44055a5c64626669b9bb810cf968868b2305" translate="yes" xml:space="preserve">
          <source>For more detailed information, see &lt;a href=&quot;http://unicode.org/reports/tr15/&quot;&gt;http://unicode.org/reports/tr15/&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr15/&quot;&gt;http://unicode.org/reports/tr15/를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71e7ea87ff241717fc4e23b38966813c9a86baa7" translate="yes" xml:space="preserve">
          <source>For more details (FAQ), check out the home of DJGPP at:</source>
          <target state="translated">자세한 내용 (FAQ)은 다음 위치에서 DJGPP 홈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2b7ea18856481cbfb2fbce20aa82b169672d93cb" translate="yes" xml:space="preserve">
          <source>For more details on Unicode properties, see &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Unicode Character Properties in perlunicode&lt;/a&gt;; for a complete list of possible properties, see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;, which notes all forms that have &lt;code&gt;/i&lt;/code&gt; differences. It is also possible to define your own properties. This is discussed in &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">유니 코드 속성에 대한 자세한 내용 &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;은 perlunicode의 유니 코드 문자 속성을&lt;/a&gt; 참조하십시오 . 가능한 특성의 전체 목록을 보려면 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops에서 \ p {} 및 \ P {}를 통해 액세스 할&lt;/a&gt; 수있는 특성을 참조하십시오 . &lt;code&gt;/i&lt;/code&gt; 차이점 이있는 모든 양식에 대해 설명합니다 . 자신의 속성을 정의 할 수도 있습니다. 이는 &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode의 사용자 정의 문자 특성에서 설명&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2cbbe4fe0a4baf76f7b9458c97576bdbd741475c" translate="yes" xml:space="preserve">
          <source>For more details on regular expression efficiency, see</source>
          <target state="translated">정규 표현식 효율성에 대한 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="ebe9afb005e64603315c0b4b48ed47e449ce83f7" translate="yes" xml:space="preserve">
          <source>For more details on the mechanics of skip and todo tests see &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">건너 뛰기 및 할일 테스트 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;harness&quot;&gt;Test :: Harness를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7baab4b3bb4b02cd4142daf0edbd11721551241c" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f61d1799248ab35eaa772a394c6295835033e37c" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;sources&lt;/code&gt; parameter in &lt;a href=&quot;parser#new&quot;&gt;new in TAP::Parser&lt;/a&gt;, &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, and &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;parser#new&quot;&gt;은 TAP :: Parser&lt;/a&gt; , &lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; 및 &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt; 에서 new 의 &lt;code&gt;sources&lt;/code&gt; 매개 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d792a0910cc22b1db3814d0f9e477cca4ea1652" translate="yes" xml:space="preserve">
          <source>For more details, see the documentation and code of &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; and &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; 및 &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; 문서 및 코드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e28556232fac8aa9e7b56eb26466d9231a13cb3c" translate="yes" xml:space="preserve">
          <source>For more details, see the individual descriptions at &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">자세한 내용은 &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; 의 개별 설명을 참조하십시오 . , &lt;code&gt;$^E&lt;/code&gt; 및 &lt;code&gt;$?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cfca851970ab4784648ba74e553f012851bc695" translate="yes" xml:space="preserve">
          <source>For more information about case mappings see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21&quot;&gt;http://www.unicode.org/unicode/reports/tr21&lt;/a&gt;</source>
          <target state="translated">사례 매핑에 대한 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21&quot;&gt;http://www.unicode.org/unicode/reports/tr21을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a52fba09ce9a3f5f4483e33536b3e5c091d8d89a" translate="yes" xml:space="preserve">
          <source>For more information about case mappings see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;</source>
          <target state="translated">사례 매핑에 대한 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a7f733567279e64844bd80ab92f020d566ce85e" translate="yes" xml:space="preserve">
          <source>For more information about encodings--for instance, to learn what</source>
          <target state="translated">인코딩에 대한 자세한 내용 (예 :</target>
        </trans-unit>
        <trans-unit id="2561ce48ee706059d4bfdc21d19fd5f166cfc40f" translate="yes" xml:space="preserve">
          <source>For more information about the portability of these functions, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; and other available platform-specific documentation.</source>
          <target state="translated">이러한 기능의 이식성에 대한 자세한 정보는 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 및 기타 사용 가능한 플랫폼 별 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0b48a366c382047ff56f3b46da60ad7835f72b7" translate="yes" xml:space="preserve">
          <source>For more information on Pod, check out &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; and &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">포드에 대한 자세한 내용은 &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 및 &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7368b700a1d6f50c9c2914d3baee02fbd55cba3c" translate="yes" xml:space="preserve">
          <source>For more information on any of these modules, please see its respective documentation.</source>
          <target state="translated">이러한 모듈에 대한 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="416652247fb1fd02b42bcffea330cb4fb44ecfe8" translate="yes" xml:space="preserve">
          <source>For more information on file locking, see also &lt;a href=&quot;perlopentut#File-Locking&quot;&gt;File Locking in perlopentut&lt;/a&gt; if you have it (new for 5.6).</source>
          <target state="translated">파일 잠금에 대한 자세한 정보 &lt;a href=&quot;perlopentut#File-Locking&quot;&gt;는 perlopentut의 파일 잠금 (파일이있는&lt;/a&gt; 경우)을 참조하십시오 (5.6의 새로운 기능).</target>
        </trans-unit>
        <trans-unit id="099e98950b7e5d3724fc0c2a1b6e16e56fceb5bc" translate="yes" xml:space="preserve">
          <source>For more information on output layers, see the entries for &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and the &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; module documentation.</source>
          <target state="translated">출력 레이어에 대한 정보의 항목 참조 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 하고 &lt;a href=&quot;open&quot;&gt;열&lt;/a&gt; 에서 &lt;a href=&quot;perlfunc&quot;&gt;을 perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO의&lt;/a&gt; 모듈 문서.</target>
        </trans-unit>
        <trans-unit id="e818032a9be9224ab5cbe363750ba1600bb48228" translate="yes" xml:space="preserve">
          <source>For more information on references and blessings, consult &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">참조와 축복에 대한 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3875443a1c771cfef5af62913463726b3c0dc4e" translate="yes" xml:space="preserve">
          <source>For more information on the Perl internals, please see the documents listed at &lt;a href=&quot;perl#Internals-and-C-Language-Interface&quot;&gt;Internals and C Language Interface in perl&lt;/a&gt;.</source>
          <target state="translated">Perl 내부에 대한 자세한 정보 &lt;a href=&quot;perl#Internals-and-C-Language-Interface&quot;&gt;는 perl의 내부 및 C 언어 인터페이스에&lt;/a&gt; 나열된 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e1c38bc7063ae4d32b5c046d7a962931ee4b2aa" translate="yes" xml:space="preserve">
          <source>For more information on the matching &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; and substitution &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operators, see &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. For information on the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operation, see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">일치하는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 및 대체 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자 에 대한 자세한 정보 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;는 perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 . 상의 정보는 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 작업을 참조 &lt;a href=&quot;functions/split&quot;&gt;분할&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d861195f361843be9490e2a15ea16594084c17c5" translate="yes" xml:space="preserve">
          <source>For more information on these options, you can run &lt;code&gt;perldoc perlrun&lt;/code&gt; .</source>
          <target state="translated">이러한 옵션에 대한 자세한 정보는 &lt;code&gt;perldoc perlrun&lt;/code&gt; 을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae1bf8b301cb7d0e378d5bfae6b8ca1419913f8d" translate="yes" xml:space="preserve">
          <source>For more information on writing subroutines, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴 작성에 대한 자세한 정보는 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54bca26b413776465d316ff152cfba7e50928bfd" translate="yes" xml:space="preserve">
          <source>For more information see &quot;man strptime&quot;, which should be on all unix systems.</source>
          <target state="translated">자세한 정보는 &quot;man strptime&quot;을 참조하십시오. 이는 모든 유닉스 시스템에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1baf9669b89021435a3869d8ee27cb001b8531d" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;../perlipc&quot;&gt;perlipc를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a8c608dc66ccc771771da6fa1ec2512b26eb2f6" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;perlipc&quot;&gt;perlipc를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f020267b66a1cdd001af710aa00960332272626" translate="yes" xml:space="preserve">
          <source>For more information, consult &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; , &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 및 &lt;a href=&quot;perlpod&quot;&gt;perlpod를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34baaca1017f55f5261393ae901ca335f5962ac3" translate="yes" xml:space="preserve">
          <source>For more information, consult &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d20dd1c8dbc4552d5c14d5ca92e5a6e145a49a2" translate="yes" xml:space="preserve">
          <source>For more information, including instructions for other platforms such as Windows and Mac OS, read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Windows 및 Mac OS와 같은 다른 플랫폼에 대한 지시 사항을 포함하여 자세한 정보는 &lt;a href=&quot;perlrun&quot;&gt;perlrun을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="1f6b2985afc24c6ba2ce53974a41c02581d47c16" translate="yes" xml:space="preserve">
          <source>For more on references see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;</source>
          <target state="translated">참조에 대한 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 및 &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="570bd0b65c4a2212785bd93937b2532931fb04d1" translate="yes" xml:space="preserve">
          <source>For more on the implications and differences between character semantics and byte semantics, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">문자 의미와 바이트 의미의 의미와 차이점에 대한 자세한 내용은 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db99609d275f010ab9ef2f1e664305363a10f9ac" translate="yes" xml:space="preserve">
          <source>For more on this, see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 및 &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="272ef40c7df3b1032622640835458da768522456" translate="yes" xml:space="preserve">
          <source>For more up-to-date information, see &lt;a href=&quot;https://metacpan.org/release/ExtUtils-MakeMaker&quot;&gt;https://metacpan.org/release/ExtUtils-MakeMaker&lt;/a&gt;.</source>
          <target state="translated">최신 정보는 &lt;a href=&quot;https://metacpan.org/release/ExtUtils-MakeMaker&quot;&gt;https://metacpan.org/release/ExtUtils-MakeMaker를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc54ba1fbc7345fca3a79ce3cc6b3a13627fa07b" translate="yes" xml:space="preserve">
          <source>For most list operators, the check function expects all the kid ops to be present already, so calling &lt;code&gt;newLISTOP(OP_JOIN, ...)&lt;/code&gt; (e.g.) is not appropriate. What you want to do in that case is create an op of type OP_LIST, append more children to it, and then call &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt;. See &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt; for more information.</source>
          <target state="translated">대부분의리스트 연산자의 경우, check 함수는 모든 키즈 op가 이미 존재할 것으로 예상하므로 &lt;code&gt;newLISTOP(OP_JOIN, ...)&lt;/code&gt; (예)를 호출하는 것은 적절하지 않습니다. 이 경우에 수행하려는 작업은 OP_LIST 유형의 op를 작성하고 더 많은 하위를 추가 한 다음 &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt; 를 호출하는 것 입니다. 자세한 내용은 &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="641019bad56b8716009f9130458dd08e4eb5dd36" translate="yes" xml:space="preserve">
          <source>For most purposes, access to Unicode properties from the Perl core is through regular expression matches, as described in the next section. For some special purposes, and to access the properties that are not suitable for regular expression matching, all the Unicode character properties that Perl handles are accessible via the standard &lt;a href=&quot;unicode/ucd&quot;&gt;Unicode::UCD&lt;/a&gt; module, as described in the section &lt;a href=&quot;#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 Perl 코어에서 유니 코드 속성에 액세스하려면 다음 섹션에 설명 된대로 정규식 일치를 사용하십시오. 특수한 목적으로 정규 표현식 일치에 적합하지 않은 속성에 액세스하기 위해 Perl이 처리하는 모든 유니 코드 문자 속성은 &lt;a href=&quot;unicode/ucd&quot;&gt;유니 코드 :: UCD &lt;/a&gt;&lt;a href=&quot;#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;를 통해 액세스 할 수있는 속성&lt;/a&gt; 섹션에 설명 된대로 표준 유니 코드 :: UCD 모듈을 통해 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="8d5ede1c7a0a1dfb0fe304691530ed6a243c7af0" translate="yes" xml:space="preserve">
          <source>For most use-cases the behavior described above is acceptable (this module and it's predecessor, &lt;code&gt;Compress::Zlib&lt;/code&gt; , have used it for over 10 years without an issue), but in a few very specific use-cases the amount of memory required for &lt;code&gt;$output&lt;/code&gt; can prohibitively large. For example, if the compressed data stream contains the same pattern repeated thousands of times, a relatively small compressed data stream can uncompress into hundreds of megabytes. Remember &lt;code&gt;inflate&lt;/code&gt; will keep allocating memory until</source>
          <target state="translated">대부분의 유스 케이스의 경우 위에서 설명한 동작이 허용됩니다 (이 모듈 및 이전 버전 인 &lt;code&gt;Compress::Zlib&lt;/code&gt; , 문제없이 10 년 이상 사용함). 매우 특정한 유스 케이스의 경우 필요한 메모리 양 &lt;code&gt;$output&lt;/code&gt; 은 엄청나게 클 수 있습니다. 예를 들어, 압축 된 데이터 스트림에 수천 번 반복 된 동일한 패턴이 포함되어 있으면 비교적 작은 압축 된 데이터 스트림이 수백 메가 바이트로 압축 해제 될 수 있습니다. &lt;code&gt;inflate&lt;/code&gt; 할 때까지 메모리 할당을 유지 한다는 것을 기억하십시오</target>
        </trans-unit>
        <trans-unit id="a47940c15fef4c6625772cdc1427a983c441c3c1" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Bzip2 object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Compress :: Bzip2 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adee5e79d5d3d779e5af1d2aba42639fd752741d" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Deflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Compress :: Deflate 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddb04253a83c249a7e883f277739dcda8e2faecb" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Gzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Compress :: Gzip 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4db349e7c47820dab5028b29921ade4c7bb32501" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::RawDeflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Compress :: RawDeflate 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8861e38ef9ff01891126a94c9ec532f08b55ad77" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Zip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Compress :: Zip 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a5826884fe147f7ccc4745dc4c0dec56e5a8942" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::AnyInflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: AnyInflate 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="000b46928e33aec75c1330e3f6828a697055beec" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::AnyUncompress object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서이 메소드는 IO :: Uncompress :: AnyUncompress 오브젝트가 소멸되면 (명시 적으로 또는 범위를 벗어난 오브젝트에 대한 참조가있는 변수에 의해) 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="621ae7f532cdf338357018b0efb4e6b8937e23cb" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Bunzip2 object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: Bunzip2 객체가 삭제되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ebe07c14944aa0924ad00011dbfa6cf95fcffd3" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Gunzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: Gunzip 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02829219c19fdbb8502226558182b539540ef773" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Inflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: Inflate 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39bac215cf7e9ee43af43133ee6260672e9eebea" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::RawInflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: RawInflate 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0e9e60d5738504f44dbe5db42b611750817984b" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Unzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">대부분의 Perl 버전에서 IO :: Uncompress :: Unzip 객체가 소멸되면 (명시 적으로 또는 범위를 벗어난 객체에 대한 참조가있는 변수에 의해)이 메소드가 자동으로 호출됩니다. Perl 버전 5.005-5.00504 및 5.8.0은 예외입니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드는 자동으로 호출되지만 프로그램이 종료 될 때 모든 활성 객체가 전역 적으로 파괴 될 때까지 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebd39cf1198af939c9fe739680f896002c72f24d" translate="yes" xml:space="preserve">
          <source>For much more detail on using git with the Perl repository, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;.</source>
          <target state="translated">Perl 저장소에서 git 사용에 대한 자세한 내용은 &lt;a href=&quot;perlgit&quot;&gt;perlgit을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd2242f4fd4838cfce99d23a663a50e2e5c87ecf" translate="yes" xml:space="preserve">
          <source>For multilevel structures, you may wish to use an approach more like this one. It uses the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt;:</source>
          <target state="translated">다단계 구조의 경우 이와 같은 접근 방식을 사용하는 것이 좋습니다. CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4aaeeb42eefa8440218480ef685b6c057da2ebd8" translate="yes" xml:space="preserve">
          <source>For native multibyte encodings (either fixed or variable length), the current implementation of the regular expressions may introduce recoding errors for regular expression literals longer than 127 bytes.</source>
          <target state="translated">네이티브 멀티 바이트 인코딩 (고정 길이 또는 가변 길이)의 경우 정규 표현식의 현재 구현에서는 127 바이트보다 긴 정규 표현식 리터럴에 대한 레코딩 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0739f14c22b332e1c9ef31d85863c468a6ec30" translate="yes" xml:space="preserve">
          <source>For natural language processing (so that, for example, apostrophes are included in words), use instead &lt;code&gt;\b{wb}&lt;/code&gt;</source>
          <target state="translated">자연어 처리 (예 : 어포 스트로피가 단어에 포함되도록) 대신 &lt;code&gt;\b{wb}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34e4b4c1e84670ba2445432138762ce8b98922fa" translate="yes" xml:space="preserve">
          <source>For negative numbers in base see also &lt;a href=&quot;#brsft()&quot;&gt;brsft&lt;/a&gt;.</source>
          <target state="translated">기본 음수는 &lt;a href=&quot;#brsft()&quot;&gt;brsft를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11739ff4ce5853fede0de1666a77252b4cca5762" translate="yes" xml:space="preserve">
          <source>For numbers in the range 160 (0x00A0) to 255 (0x00FF), this maps from the character code for a Latin-1 character (like 233 for lowercase e-acute) to the US-ASCII character that best aproximates it (like &quot;e&quot;). You may find this useful if you are rendering POD in a format that you think deals well only with US-ASCII characters.</source>
          <target state="translated">160 (0x00A0) ~ 255 (0x00FF) 범위의 숫자 인 경우 라틴 -1 문자의 문자 코드 (예 : 소문자 e-acute의 경우 233)에서 가장 근접한 US-ASCII 문자 (예 : &quot;e &quot;). US-ASCII 문자 만 처리하는 형식으로 POD를 렌더링하는 경우이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0418167b8295aaa112b520d273cbff7734fb4037" translate="yes" xml:space="preserve">
          <source>For numeric conversions, you can specify the size to interpret the number as using &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; . For integer conversions (&lt;code&gt;d u o x X b i D U O&lt;/code&gt; ), numbers are usually assumed to be whatever the default integer size is on your platform (usually 32 or 64 bits), but you can override this to use instead one of the standard C types, as supported by the compiler used to build Perl:</source>
          <target state="translated">숫자 변환의 경우 &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;ll&lt;/code&gt; 을 사용하여 숫자를 해석 할 크기를 지정할 수 있습니다 . 정수 변환 ( &lt;code&gt;d u o x X b i D U O&lt;/code&gt; )의 경우 숫자는 일반적으로 플랫폼의 기본 정수 크기 (일반적으로 32 또는 64 비트)로 가정되지만 지원되는 표준 C 유형 중 하나를 사용하도록이를 재정의 할 수 있습니다. Perl을 빌드하는데 사용 된 컴파일러에 의해 :</target>
        </trans-unit>
        <trans-unit id="3f073c1258e51f971ca716359b2a89c0272776c0" translate="yes" xml:space="preserve">
          <source>For numeric conversions, you can specify the size to interpret the number as using &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; . For integer conversions (&lt;code&gt;d u o x X b i D U O&lt;/code&gt; ), numbers are usually assumed to be whatever the default integer size is on your platform (usually 32 or 64 bits), but you can override this to use instead one of the standard C types, as supported by the compiler used to build Perl:</source>
          <target state="translated">숫자 변환의 경우 &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;ll&lt;/code&gt; 을 사용하여 숫자를 해석 할 크기를 지정할 수 있습니다 . 정수 변환 ( &lt;code&gt;d u o x X b i D U O&lt;/code&gt; )의 경우 숫자는 일반적으로 플랫폼의 기본 정수 크기 (일반적으로 32 또는 64 비트)로 가정되지만 지원되는 표준 C 유형 중 하나를 사용하도록이를 재정의 할 수 있습니다. Perl을 빌드하는데 사용 된 컴파일러에 의해 :</target>
        </trans-unit>
        <trans-unit id="59b31b25c9f5d592cd415ce42cd1cd5b58c1c703" translate="yes" xml:space="preserve">
          <source>For objects, a method, &lt;code&gt;CARP_TRACE&lt;/code&gt; , will be called, if it exists. If this method doesn't exist, or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used. It is recommended that the object's type is part of the string to make debugging easier.</source>
          <target state="translated">객체의 경우 &lt;code&gt;CARP_TRACE&lt;/code&gt; 메소드 가 존재하는 경우 호출됩니다. 이 메소드가 존재하지 않거나 &lt;code&gt;Carp&lt;/code&gt; 로 재귀 되거나 예외가 발생하면,이를 건너 뛰고 Carp는 다음 옵션으로 넘어 가고 그렇지 않으면 검사를 중지하고 리턴 된 문자열이 사용됩니다. 디버깅하기 쉽도록 객체 유형이 문자열의 일부인 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="34e2a99f6a2eb99d86babea525e84b0d07848c0f" translate="yes" xml:space="preserve">
          <source>For old code and interim backwards compatibility, the &lt;code&gt;Thread&lt;/code&gt; module has been reworked to function as a frontend for the new interpreter threads (</source>
          <target state="translated">오래된 코드와 이전 버전과의 호환성을 위해 &lt;code&gt;Thread&lt;/code&gt; 모듈은 새로운 인터프리터 스레드의 프론트 엔드로 작동하도록 재 작업되었습니다 (</target>
        </trans-unit>
        <trans-unit id="54678b0f46a42f75ba9339772dde807022e3f850" translate="yes" xml:space="preserve">
          <source>For options that take list or hash values, it is necessary to indicate this by appending an &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; sign after the type:</source>
          <target state="translated">목록 또는 해시 값을 사용하는 옵션의 경우 유형 뒤에 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 기호를 추가하여이를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed4fe0865e6bc07b5c076581d59bd74aedec7133" translate="yes" xml:space="preserve">
          <source>For options that take values it must be specified whether the option value is required or not, and what kind of value the option expects.</source>
          <target state="translated">값을 갖는 옵션의 경우 옵션 값이 필요한지 여부와 옵션에 필요한 값을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="14b3ef641443710b672e456ac43669f979bd2658" translate="yes" xml:space="preserve">
          <source>For ordinary files you can also use the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">일반 파일의 경우 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 기능을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18923d06b00ab1b78a669fe54fca08f48f38928d" translate="yes" xml:space="preserve">
          <source>For other Perl-based conversion options see the &lt;code&gt;Convert::*&lt;/code&gt; modules on CPAN.</source>
          <target state="translated">다른 Perl 기반 변환 옵션에 대해서는 CPAN 의 &lt;code&gt;Convert::*&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecf4231003ccccf0ccb3fdcd4e5a986799fbca1f" translate="yes" xml:space="preserve">
          <source>For other filetypes, like &lt;code&gt;chardevs&lt;/code&gt; and &lt;code&gt;blockdevs&lt;/code&gt; we'll warn that the extraction of this particular item didn't work.</source>
          <target state="translated">다른 파일 형식의 경우, 같은 &lt;code&gt;chardevs&lt;/code&gt; 및 &lt;code&gt;blockdevs&lt;/code&gt; 우리는이 특정 항목의 추출이 작동하지 않는 것을 경고합니다.</target>
        </trans-unit>
        <trans-unit id="a61d39f00af378aaa32b4a9a3dedd635bdcf3408" translate="yes" xml:space="preserve">
          <source>For other locales, starting in Perl 5.16, you can specify</source>
          <target state="translated">Perl 5.16부터 다른 로케일의 경우 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55153fcdbe0c92eb8adc0abec175ecdf7f05a3ca" translate="yes" xml:space="preserve">
          <source>For other termination statuses, the severity portion of the subprocess's exit status is used: if the severity was success or informational, these bits are all 0; if the severity was warning, they contain a value of 1; if the severity was error or fatal error, they contain the actual severity bits, which turns out to be a value of 2 for error and 4 for severe_error. Fatal is another term for the severe_error status.</source>
          <target state="translated">다른 종료 상태의 경우 서브 프로세스 종료 상태의 심각도 부분이 사용됩니다. 심각도가 성공 또는 정보 인 경우이 비트는 모두 0입니다. 심각도가 경고 인 경우 값은 1입니다. 심각도가 오류이거나 치명적인 오류 인 경우 실제 심각도 비트를 포함하며, 오류의 경우 2, 심각 _ 오류의 경우 4로 나타납니다. 치명적인 오류는 심각한 오류 상태의 또 다른 용어입니다.</target>
        </trans-unit>
        <trans-unit id="d9c9ebb36f114d2e29800b2f2a876e7e2d770bfb" translate="yes" xml:space="preserve">
          <source>For our File::MP3 class, we can check to make sure that the path we're given ends with &quot;.mp3&quot;:</source>
          <target state="translated">File :: MP3 클래스의 경우 제공된 경로가 &quot;.mp3&quot;으로 끝나는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90aad3aef5b3704234dd7e152135fa69067f60cd" translate="yes" xml:space="preserve">
          <source>For our example, we want to be able to emit debugging info to help in tracing during development. We keep also one convenience function around internally to help print out warnings; whowasi() returns the function name that calls it.</source>
          <target state="translated">이 예에서는 개발 중에 추적하는 데 도움이되는 디버깅 정보를 생성 할 수 있기를 원합니다. 우리는 또한 경고를 인쇄 할 수 있도록 내부적으로 하나의 편의 기능을 유지합니다. whowasi ()는이를 호출하는 함수 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aa18cdabf84f58c0c8a60b20d7ee4d847450d128" translate="yes" xml:space="preserve">
          <source>For our example, we're using a real hash so we'll do just the simple thing, but we'll have to go through the LIST field indirectly.</source>
          <target state="translated">이 예에서는 실제 해시를 사용하므로 간단한 작업 만 수행하지만 LIST 필드를 간접적으로 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="a68ea5110cc4475ea5587d223e48012123b172f2" translate="yes" xml:space="preserve">
          <source>For packing floating point numbers you have the choice between the pack codes &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; pack into (or unpack from) single-precision or double-precision representation as it is provided by your system. If your systems supports it, &lt;code&gt;D&lt;/code&gt; can be used to pack and unpack (&lt;code&gt;long double&lt;/code&gt; ) values, which can offer even more resolution than &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; . &lt;b&gt;Note that there are different long double formats.&lt;/b&gt;</source>
          <target state="translated">부동 소수점 숫자를 패킹하는 경우 팩 코드 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 중에서 선택할 수 있습니다 . &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 는 시스템에서 제공하는 단 정밀도 또는 배정 밀도 표현으로 포장 (또는 포장 풀기)합니다. 시스템에서 지원하는 경우 &lt;code&gt;D&lt;/code&gt; 를 사용하여 값을 압축 및 압축 풀기 ( &lt;code&gt;long double&lt;/code&gt; )하여 &lt;code&gt;f&lt;/code&gt; 또는 &lt;code&gt;d&lt;/code&gt; 보다 훨씬 더 높은 해상도를 제공 할 수 있습니다 . &lt;b&gt;다른 long double 형식이 있습니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="66df4e6482b9f11564ff3b3f20d96a2cc85b3ceb" translate="yes" xml:space="preserve">
          <source>For parsing or generating CSV, though, using &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt; rather than implementing it yourself is highly recommended; you'll save yourself odd bugs popping up later by just using code which has already been tried and tested in production for years.</source>
          <target state="translated">그러나 CSV를 구문 분석하거나 생성하려면 직접 구현하는 대신 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV를&lt;/a&gt; 사용 하는 것이 좋습니다. 몇 년 동안 이미 생산 및 테스트 된 코드를 사용하여 나중에 발생하는 이상한 버그를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee0891ac5c639e853c5a4e5edc84af67afe5f45" translate="yes" xml:space="preserve">
          <source>For platforms that do not support the L</source>
          <target state="translated">L을 지원하지 않는 플랫폼의 경우</target>
        </trans-unit>
        <trans-unit id="6ef063b83223c50f839dae38551b2b8ac38cb283" translate="yes" xml:space="preserve">
          <source>For portability do not assume that the result of inet_aton() is 32 bits wide, in other words, that it would contain only the IPv4 address in network order.</source>
          <target state="translated">이식성을 위해 inet_aton ()의 결과가 32 비트 너비, 즉 네트워크 순서에 IPv4 주소 만 포함한다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a2f756b0930efbec9e5ee4bb36d81103dee350c4" translate="yes" xml:space="preserve">
          <source>For portability, when using features that may not be implemented on every machine, test the construct in an eval to see if it fails. If you know what version or patchlevel a particular feature was implemented, you can test &lt;code&gt;$]&lt;/code&gt; (&lt;code&gt;$PERL_VERSION&lt;/code&gt; in &lt;code&gt;English&lt;/code&gt; ) to see if it will be there. The &lt;code&gt;Config&lt;/code&gt; module will also let you interrogate values determined by the &lt;b&gt;Configure&lt;/b&gt; program when Perl was installed.</source>
          <target state="translated">이식성을 위해, 모든 머신에서 구현되지 않을 수있는 기능을 사용하는 경우, 어느 정도의 구조를 테스트하여 실패 여부를 확인하십시오. 당신이 어떤 버전을 알거나 특정 기능이 구현 된 패치 레벨 경우 테스트 할 수 있습니다 &lt;code&gt;$]&lt;/code&gt; ( &lt;code&gt;$PERL_VERSION&lt;/code&gt; 에서 &lt;code&gt;English&lt;/code&gt; 가있을 것입니다 있는지 확인하기 위해). &lt;code&gt;Config&lt;/code&gt; 모듈은 또한 당신이 결정 값을 심문하게됩니다 &lt;b&gt;구성&lt;/b&gt; 펄 설치할 때 프로그램을.</target>
        </trans-unit>
        <trans-unit id="2535552b980c53cc7ba860a8dd5bb061008869b5" translate="yes" xml:space="preserve">
          <source>For portably packed integers, either use the formats &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; or else use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers described immediately below. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;.</source>
          <target state="translated">이식 가능한 정수의 경우 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 형식을 사용하거나 바로 아래에 설명 된 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정자를 사용하십시오 . &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f894cb82cd4f998730f7156c0afde9903978c5fb" translate="yes" xml:space="preserve">
          <source>For portably packed integers, either use the formats &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; or else use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers described immediately below. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;.</source>
          <target state="translated">이식 가능한 정수의 경우 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 형식을 사용하거나 바로 아래에 설명 된 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정자를 사용하십시오 . &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b632d6b9c2c212334172ecdd5444e30d59c76fb4" translate="yes" xml:space="preserve">
          <source>For purposes for forward compatibility, any result which does not match the following grammar is currently referred to as &lt;a href=&quot;result/unknown&quot;&gt;TAP::Parser::Result::Unknown&lt;/a&gt;. It is</source>
          <target state="translated">순방향 호환성을 위해 다음 문법과 일치하지 않는 결과는 현재 &lt;a href=&quot;result/unknown&quot;&gt;TAP :: Parser :: Result :: Unknown&lt;/a&gt; 입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="abd99590407faa93008cdde9678d67dea3d2be33" translate="yes" xml:space="preserve">
          <source>For purposes of Pod processing, there are four types of paragraphs in a Pod block:</source>
          <target state="translated">포드 처리를 위해 포드 블록에는 네 가지 유형의 단락이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c27afbc45a634cfd67eaae651454448b0cf48fa" translate="yes" xml:space="preserve">
          <source>For reading RFC 1950 files/buffers, see the companion module &lt;a href=&quot;../uncompress/inflate&quot;&gt;IO::Uncompress::Inflate&lt;/a&gt;.</source>
          <target state="translated">RFC 1950 파일 / 버퍼를 읽으려면 컴패니언 모듈 &lt;a href=&quot;../uncompress/inflate&quot;&gt;IO :: Uncompress :: Inflate를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a855ff5b11238f17f076a8b7ebdcff40a540c026" translate="yes" xml:space="preserve">
          <source>For reading RFC 1951 files/buffers, see the companion module &lt;a href=&quot;../uncompress/rawinflate&quot;&gt;IO::Uncompress::RawInflate&lt;/a&gt;.</source>
          <target state="translated">RFC 1951 파일 / 버퍼를 읽으려면 컴패니언 모듈 &lt;a href=&quot;../uncompress/rawinflate&quot;&gt;IO :: Uncompress :: RawInflate를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c1e04df00546215699a3d4161d10f783f59e5d" translate="yes" xml:space="preserve">
          <source>For reading RFC 1952 files/buffers, see the companion module &lt;a href=&quot;../uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">RFC 1952 파일 / 버퍼를 읽으려면 컴패니언 모듈 &lt;a href=&quot;../uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45f2b20453bc89baeb5e50beb84ad2c8f70cd376" translate="yes" xml:space="preserve">
          <source>For reading bzip2 files/buffers, see the companion module &lt;a href=&quot;../uncompress/bunzip2&quot;&gt;IO::Uncompress::Bunzip2&lt;/a&gt;.</source>
          <target state="translated">bzip2 파일 / 버퍼를 읽으려면 컴패니언 모듈 &lt;a href=&quot;../uncompress/bunzip2&quot;&gt;IO :: Uncompress :: Bunzip2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="187e155fdbfcf5fc691664f658b9590cb0a606e3" translate="yes" xml:space="preserve">
          <source>For reading zip files/buffers, see the companion module &lt;a href=&quot;../uncompress/unzip&quot;&gt;IO::Uncompress::Unzip&lt;/a&gt;.</source>
          <target state="translated">zip 파일 / 버퍼를 읽으려면 컴패니언 모듈 &lt;a href=&quot;../uncompress/unzip&quot;&gt;IO :: Uncompress :: Unzip을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd2eb9a3cc8fd3a8df073b0ec5e2b4d099b5a11" translate="yes" xml:space="preserve">
          <source>For reference &lt;code&gt;Name_hash&lt;/code&gt; in &lt;a href=&quot;#Example-1&quot;&gt;Example 1&lt;/a&gt; shows the standard implementation of a simple class &lt;code&gt;Name&lt;/code&gt; in the well-known hash based way. It also demonstrates the predictable failure to construct a common subclass &lt;code&gt;NamedFile&lt;/code&gt; of &lt;code&gt;Name&lt;/code&gt; and the class &lt;code&gt;IO::File&lt;/code&gt; (whose objects</source>
          <target state="translated">참고로 &lt;code&gt;Name_hash&lt;/code&gt; 의 &lt;a href=&quot;#Example-1&quot;&gt;실시 예 1 개&lt;/a&gt; 나타내는 간단한 클래스의 표준 구현 &lt;code&gt;Name&lt;/code&gt; 잘 알려진 해시 기반 방식이다. 또한 공통의 서브 클래스 구성 할 수있는 예측 실패 보여줍니다 &lt;code&gt;NamedFile&lt;/code&gt; 의 &lt;code&gt;Name&lt;/code&gt; 과 클래스 &lt;code&gt;IO::File&lt;/code&gt; 오브젝트 (</target>
        </trans-unit>
        <trans-unit id="c814c526315b7581980ad4c15539a698f43dc88e" translate="yes" xml:space="preserve">
          <source>For reference on how regular expressions are used in matching operations, plus various examples of the same, see discussions of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;??&lt;/code&gt; in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">정규식이 일치하는 작업에 사용되는 방법과 그에 대한 다양한 예에 대한 참조는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;??&lt;/code&gt; 에 대한 설명을 참조하십시오 . 에서 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop에서 정규 표현식 견적 같은 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fad7e87806bab30783c3c4927bdef95cd0d3e97d" translate="yes" xml:space="preserve">
          <source>For resolving Pod E&amp;lt;...&amp;gt; sequences</source>
          <target state="translated">포드 E &amp;lt;...&amp;gt; 시퀀스 해결</target>
        </trans-unit>
        <trans-unit id="6b992296626805bd58c646a7af77319599bf4d43" translate="yes" xml:space="preserve">
          <source>For results that are less &quot;raw&quot; than this function returns, or to get the values for any property, not just the few covered by this function, use the &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; function.</source>
          <target state="translated">이 함수가 반환하는 것보다 덜 &quot;원시&quot;인 결과를 &lt;a href=&quot;#charprop()&quot;&gt;보거나이&lt;/a&gt; 함수가 다루는 소수만이 아닌 모든 속성의 값을 얻으려면 charprop () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5465aa0069dd7e57a3ecfdd26acfc8c3e9bcb5cc" translate="yes" xml:space="preserve">
          <source>For scripts see UTR #24: &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr24/&quot;&gt;http://www.unicode.org/unicode/reports/tr24/&lt;/a&gt;</source>
          <target state="translated">스크립트는 UTR # 24를 참조하십시오 : &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr24/&quot;&gt;http://www.unicode.org/unicode/reports/tr24/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbe77ef0bb7f245eb32b185bc4ca0da0057fd61e" translate="yes" xml:space="preserve">
          <source>For security reasons, which are probably detailed in your system's documentation for the C library &lt;code&gt;tmpnam()&lt;/code&gt; function, this interface should not be used; instead see &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">C 라이브러리 &lt;code&gt;tmpnam()&lt;/code&gt; 함수 에 대한 시스템 설명서에 자세히 설명되어있는 보안상의 이유로이 인터페이스를 사용해서는 안됩니다. 대신 &lt;a href=&quot;file/temp&quot;&gt;File :: Temp&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="804ad42eea097048c3a5ad09bc9b03cdfa4b060a" translate="yes" xml:space="preserve">
          <source>For sequential data set access try:</source>
          <target state="translated">순차 데이터 세트 액세스의 경우 :</target>
        </trans-unit>
        <trans-unit id="ef5bb90320f25f28778d12700a90184c79a71a09" translate="yes" xml:space="preserve">
          <source>For simple names like 'foo', when the normal search fails to find a matching page, a search with the &quot;perl&quot; prefix is tried as well. So &quot;perldoc intro&quot; is enough to find/render &quot;perlintro.pod&quot;.</source>
          <target state="translated">'foo'와 같은 간단한 이름의 경우 일반 검색에서 일치하는 페이지를 찾지 못하면 &quot;perl&quot;접두사를 사용한 검색도 시도됩니다. 따라서 &quot;perldoc intro&quot;는 &quot;perlintro.pod&quot;를 찾거나 렌더링하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="556d75ad92e978ff3b11a57397aef51991f4ff7e" translate="yes" xml:space="preserve">
          <source>For simple uses, &lt;a href=&quot;spec/functions&quot;&gt;File::Spec::Functions&lt;/a&gt; provides convenient functional forms of these methods.</source>
          <target state="translated">간단한 사용을 위해 &lt;a href=&quot;spec/functions&quot;&gt;File :: Spec :: Functions&lt;/a&gt; 는 이러한 메소드의 편리한 기능적 형태를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d03e819dd2058b21b6af8f56092068c3f695190" translate="yes" xml:space="preserve">
          <source>For single-byte locales, Perl generally takes the tack to use locale rules on code points that can fit in a single byte, and Unicode rules for those that can't (though this isn't uniformly applied, see the note at the end of this section). This prevents many problems in locales that aren't UTF-8. Suppose the locale is ISO8859-7, Greek. The character at 0xD7 there is a capital Chi. But in the ISO8859-1 locale, Latin1, it is a multiplication sign. The POSIX regular expression character class &lt;code&gt;[[:alpha:]]&lt;/code&gt; will magically match 0xD7 in the Greek locale but not in the Latin one.</source>
          <target state="translated">단일 바이트 로케일의 경우 Perl은 일반적으로 단일 바이트에 맞는 코드 포인트에 로케일 규칙을 사용하고 그렇지 않은 코드 포인트에 대해서는 유니 코드 규칙을 사용하도록 압정을 취합니다. 이 섹션의). 이것은 UTF-8이 아닌 로케일에서 많은 문제를 방지합니다. 로케일이 ISO8859-7, 그리스인이라고 가정하십시오. 0xD7의 문자에는 대문자 Chi가 있습니다. 그러나 ISO8859-1 로켈 Latin1에서는 곱셈 부호입니다. POSIX 정규 표현식 문자 클래스 &lt;code&gt;[[:alpha:]]&lt;/code&gt; 는 그리스어 로켈에서는 0xD7과 마술 적으로 일치하지만 라틴어에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="380d5b1307da78e3f0b19da4a2093d734fd7d578" translate="yes" xml:space="preserve">
          <source>For small inputs asin() and acos() may return complex numbers even when real numbers would be enough and correct, this happens because of floating-point inaccuracies. You can see these inaccuracies for example by trying theses:</source>
          <target state="translated">작은 입력의 경우 실수가 충분하고 올바른 경우에도 asin () 및 acos ()가 복소수를 반환 할 수 있습니다. 이는 부동 소수점 부정확성으로 인해 발생합니다. 예를 들어 다음을 시도하여 이러한 부정확성을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0bc5ddd0ee51281e4f9659982e9a429afe81e41" translate="yes" xml:space="preserve">
          <source>For small systems, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt; both provide minimal object systems that take care of basic boilerplate for you.</source>
          <target state="translated">소형 시스템의 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt; 는 기본 상용구를 관리하는 최소한의 객체 시스템을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="649df46c734150d637b1c77793718377fdc210a4" translate="yes" xml:space="preserve">
          <source>For some applications, the Perl parser mangles constants too much. It is possible to hook into this process via &lt;code&gt;overload::constant()&lt;/code&gt; and &lt;code&gt;overload::remove_constant()&lt;/code&gt; functions.</source>
          <target state="translated">일부 응용 프로그램의 경우 Perl 파서가 상수를 너무 많이 맹 글링합니다. &lt;code&gt;overload::constant()&lt;/code&gt; 및 &lt;code&gt;overload::remove_constant()&lt;/code&gt; 함수 를 통해이 프로세스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c75f56e634e770bcbf3c0f23b36b82ec0fc811d" translate="yes" xml:space="preserve">
          <source>For some combinations of base character and modifiers, there are</source>
          <target state="translated">기본 문자와 수정 자의 일부 조합에는</target>
        </trans-unit>
        <trans-unit id="5b2480bf16f6be7c86b401cccabe7d726d8e24b1" translate="yes" xml:space="preserve">
          <source>For some concrete examples, see the implementation of the first() and reduce() functions of List::Util 1.18. There you will also find a header file that emulates the multicall API on older versions of perl.</source>
          <target state="translated">구체적인 예는 List :: Util 1.18의 first () 및 reduce () 함수 구현을 참조하십시오. 또한 이전 버전의 perl에서 다중 호출 API를 에뮬레이트하는 헤더 파일도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c83ee66f318d1a73763c0a4e4314ae7b7e4530e" translate="yes" xml:space="preserve">
          <source>For some dual-life modules, it has not yet been determined if the CPAN version or the blead source is canonical. Until that is done, those modules should be in</source>
          <target state="translated">일부 이중 수명 모듈의 경우 CPAN 버전 또는 블리드 소스가 정식인지 여부는 아직 결정되지 않았습니다. 완료 될 때까지 해당 모듈은</target>
        </trans-unit>
        <trans-unit id="52922f69d414d9ab836b3e1640882c87c88c29f9" translate="yes" xml:space="preserve">
          <source>For some languages this issue may never come up (Danish is rarely expressed as &quot;da-DK&quot;, but instead is just &quot;da&quot;). And for other languages, the whole concept of a &quot;generic&quot; form may verge on being uselessly vague, particularly for interfaces involving voice media in forms of Arabic or Chinese.</source>
          <target state="translated">일부 언어의 경우이 문제가 발생하지 않을 수 있습니다 (덴마크는 &quot;da-DK&quot;로 표현되는 경우가 거의없고 대신 &quot;da&quot;입니다). 그리고 다른 언어의 경우, &quot;일반&quot;형식의 전체 개념은 특히 아랍어 또는 중국어 형식의 음성 미디어와 관련된 인터페이스에 대해 모호하게 모호해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df7b58f3cdc3f5432c07cbb3014a32ed5bbfa9f" translate="yes" xml:space="preserve">
          <source>For some methods, the first parameter can be modified. That includes the possibility that you return a reference to a completely different object instead. Although keeping the reference and just changing its contents is preferred over creating and returning a different reference.</source>
          <target state="translated">일부 방법의 경우 첫 번째 매개 변수를 수정할 수 있습니다. 여기에는 완전히 다른 객체에 대한 참조를 반환 할 가능성이 포함됩니다. 참조를 유지하고 내용을 변경하는 것이 다른 참조를 작성하고 리턴하는 것보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="91b1402159268a636b935e75a5ef943d82112546" translate="yes" xml:space="preserve">
          <source>For some reason which I forget, Unix machines like to have PERL_DL_NONLAZY set for tests.</source>
          <target state="translated">내가 잊어 버린 이유 때문에 유닉스 머신은 테스트를 위해 PERL_DL_NONLAZY를 설정하는 것을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="a7901ef2b61f75100e0830a3d919762868ec72c6" translate="yes" xml:space="preserve">
          <source>For some reason, the Fahrenheit to Celsius conversion fails to return the expected output. This is what it does:</source>
          <target state="translated">어떤 이유로 화씨에서 섭씨로의 변환은 예상 출력을 반환하지 못합니다. 이것이하는 일입니다 :</target>
        </trans-unit>
        <trans-unit id="6836cb564e9866aa0dd506ea484f1257d833a6cb" translate="yes" xml:space="preserve">
          <source>For some reason, this table is incomplete! Several countries are missing from it, and I cannot find them anywhere on the UN site. I no longer use this as a source of data.</source>
          <target state="translated">어떤 이유로이 테이블은 불완전합니다! 여러 국가가 빠져 있는데 UN 사이트 어디에서도 찾을 수 없습니다. 더 이상 이것을 데이터 소스로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7a2085644f6e69e810ea72163b3697d3339d4a3" translate="yes" xml:space="preserve">
          <source>For some specific applications, you can use one of the DBM modules. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;. More generically, you should consult the &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt; or &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; modules from CPAN. Starting from Perl 5.8, &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; is part of the standard distribution. Here's one example using &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;'s &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; functions:</source>
          <target state="translated">일부 특정 애플리케이션의 경우 DBM 모듈 중 하나를 사용할 수 있습니다. &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File을&lt;/a&gt; 참조하십시오 . 보다 일반적으로 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt; 또는 &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; 모듈을 참조해야합니다 . Perl 5.8부터 &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; 은 표준 배포판의 일부입니다. 다음은 &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; 의 &lt;code&gt;store&lt;/code&gt; 및 &lt;code&gt;retrieve&lt;/code&gt; 기능을 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="51552d3184ebb138bb755fdbaf9df407078be4d9" translate="yes" xml:space="preserve">
          <source>For special considerations when Perl is embedded in a C program, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;Using embedded Perl with POSIX locales in perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl이 C 프로그램에 임베드 될 때 특별 고려 사항 &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;은 perlembed에서 POSIX 로케일에 임베드 된 Perl 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db2592239bcf5cba780f2c2b2c780b3dad39ed83" translate="yes" xml:space="preserve">
          <source>For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised', but this internal state is stored in a separate pad entry.</source>
          <target state="translated">상태 변수의 경우 SVs_PADSTALE은 '아직 초기화되지 않음'을 의미하도록 오버로드되지만이 내부 상태는 별도의 패드 항목에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f0dd4dac3c9b3c360654ba0693c4a0d4f581ae73" translate="yes" xml:space="preserve">
          <source>For streams all in the same encoding, don't use encode/decode; instead set the file encoding when you open the file or immediately after with &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; as described later below.</source>
          <target state="translated">모두 동일한 인코딩으로 된 스트림의 경우 인코딩 / 디코딩을 사용하지 마십시오. 대신 파일을 열 때 또는 나중에 나중에 설명하는 것처럼 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용한 후 파일 인코딩을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dfae2e55787ddda9febdb90b2ecaeb6ae6a59fe" translate="yes" xml:space="preserve">
          <source>For streams being handed</source>
          <target state="translated">전달되는 스트림</target>
        </trans-unit>
        <trans-unit id="9dedf3c911e70154c6e95a2be8f174842c7bae09" translate="yes" xml:space="preserve">
          <source>For streams coming</source>
          <target state="translated">오는 스트림</target>
        </trans-unit>
        <trans-unit id="e0011302da40ab3a00fabe609704d25b18704f41" translate="yes" xml:space="preserve">
          <source>For string conversions, specifying a precision truncates the string to fit the specified width:</source>
          <target state="translated">문자열 변환의 경우 정밀도를 지정하면 문자열이 지정된 너비에 맞게 잘립니다.</target>
        </trans-unit>
        <trans-unit id="715b9be15d81e36207f8641c990be0fb81823314" translate="yes" xml:space="preserve">
          <source>For string values, &lt;code&gt;%&lt;/code&gt; returns the sum of the byte values saving you the trouble of a sum loop with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">문자열 값의 경우 &lt;code&gt;%&lt;/code&gt; 는 바이트 값의 합계를 반환하여 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 를 사용하여 합계 루프의 문제를 줄입니다 .</target>
        </trans-unit>
        <trans-unit id="2c32ad512fb42bb2f5a39ca4f1c4f07aae935ceb" translate="yes" xml:space="preserve">
          <source>For successful testing you may need to turn on the sticky bit for your world readable /tmp directory if you have not already done so (see man chmod).</source>
          <target state="translated">테스트를 성공적으로 수행하려면 아직 읽을 수없는 경우 세계에서 읽을 수있는 / tmp 디렉토리의 고정 비트를 켜야합니다 (man chmod 참조).</target>
        </trans-unit>
        <trans-unit id="992f6aafd7fd171cd3b566817c93beb472bf462c" translate="yes" xml:space="preserve">
          <source>For such purposes we have &lt;code&gt;use_ok&lt;/code&gt; and &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">이러한 목적으로 &lt;code&gt;use_ok&lt;/code&gt; 및 &lt;code&gt;require_ok&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d0546a793b6579ee297b5975d16d0d21606bafc" translate="yes" xml:space="preserve">
          <source>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless $no_file is true or a trailing separator or /. or /.. is present. On Unix this means that $no_file true makes this return ( '', $path, '' ).</source>
          <target state="translated">디렉토리와 파일 이름을 구분하는 구문이없는 시스템의 경우 $ no_file이 true이거나 후미 구분 기호 또는 /가 아니면 마지막 파일이 경로라고 가정합니다. 또는 / ..가 있습니다. 유닉스에서 이것은 $ no_file true가이 리턴 ( '', $ path, '')을 만든다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b23c14e40a72fd26594732c2e008c8f7079954f" translate="yes" xml:space="preserve">
          <source>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless &lt;code&gt;$no_file&lt;/code&gt; is true or a trailing separator or</source>
          <target state="translated">디렉토리와 파일 이름을 구분하는 구문이없는 시스템의 경우 &lt;code&gt;$no_file&lt;/code&gt; 이 true이거나 후미 구분 기호 또는</target>
        </trans-unit>
        <trans-unit id="41699a22da98ee5d514ab051852b7fdbdda93994" translate="yes" xml:space="preserve">
          <source>For tab indents, you'd use a tab character:</source>
          <target state="translated">탭 들여 쓰기에는 탭 문자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="873e054c44e61faf311e2453c2e600c934773fe0" translate="yes" xml:space="preserve">
          <source>For that use &lt;a href=&quot;http://search.cpan.org/perldoc/Shell::Command&quot;&gt;Shell::Command&lt;/a&gt;.</source>
          <target state="translated">이를 위해 &lt;a href=&quot;http://search.cpan.org/perldoc/Shell::Command&quot;&gt;Shell :: Command&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8e31e8dfe4611868531ce4559928a6d1882ff0a" translate="yes" xml:space="preserve">
          <source>For the</source>
          <target state="translated">대한</target>
        </trans-unit>
        <trans-unit id="9111ece894932df874025e3e103411a73321fa27" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , the argument cannot be &lt;code&gt;0&lt;/code&gt; (zero). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;1&lt;/code&gt; (one). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-1&lt;/code&gt; (minus one). For the &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;sech&lt;/code&gt; , the argument cannot be</source>
          <target state="translated">를 들어 &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , 인수가 될 수 없습니다 &lt;code&gt;0&lt;/code&gt; (영). 를 들어 &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , 인수가 될 수 없습니다 &lt;code&gt;1&lt;/code&gt; (하나). 를 들어 &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , 인수가 될 수 없습니다 &lt;code&gt;-1&lt;/code&gt; (마이너스 일). 를 들어 &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;sech&lt;/code&gt; , 인수가 될 수 없습니다</target>
        </trans-unit>
        <trans-unit id="18728ff4c7a96c743723724ec7c8d3bf1df62e46" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , the argument cannot be &lt;code&gt;0&lt;/code&gt; (zero). For the logarithmic functions and the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;1&lt;/code&gt; (one). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-1&lt;/code&gt; (minus one). For the &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , the argument cannot be &lt;code&gt;i&lt;/code&gt; (the imaginary unit). For the &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-i&lt;/code&gt; (the negative imaginary unit). For the &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , the argument cannot be</source>
          <target state="translated">를 들어 &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , 인수가 될 수 없습니다 &lt;code&gt;0&lt;/code&gt; (영). 대수 함수와 &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; 의 경우 인수는 &lt;code&gt;1&lt;/code&gt; 이 될 수 없습니다 . 를 들어 &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , 인수가 될 수 없습니다 &lt;code&gt;-1&lt;/code&gt; (마이너스 일). 들어 &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , 인수는 수 &lt;code&gt;i&lt;/code&gt; (허수 부). 를 들어 &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; 이면 인수는 &lt;code&gt;-i&lt;/code&gt; (음수의 허수 단위)가 될 수 없습니다 . 를 들어 &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , 인수가 될 수 없습니다</target>
        </trans-unit>
        <trans-unit id="83159320f2b2918a98eed25d2752aaca30a22922" translate="yes" xml:space="preserve">
          <source>For the DynaLoader developer/porter there is a similar debugging variable added to the C code (see dlutils.c) and enabled if Perl was built with the &lt;b&gt;-DDEBUGGING&lt;/b&gt; flag. This can also be set via the PERL_DL_DEBUG environment variable. Set to 1 for minimal information or higher for more.</source>
          <target state="translated">DynaLoader 개발자 / 포터의 경우 비슷한 디버깅 변수가 C 코드에 추가되고 (dlutils.c 참조) Perl이 &lt;b&gt;-DDEBUGGING&lt;/b&gt; 플래그 로 빌드 된 경우 활성화됩니다 . PERL_DL_DEBUG 환경 변수를 통해 설정할 수도 있습니다. 최소한의 정보는 1로 설정하고 더 많은 정보는 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="df6005966cffcf3e4fd44657df74e3aab23993c1" translate="yes" xml:space="preserve">
          <source>For the above line, the explanation is</source>
          <target state="translated">위의 줄에 대한 설명은</target>
        </trans-unit>
        <trans-unit id="1b868cb4c593515bd8834adf9737c636cf76ddff" translate="yes" xml:space="preserve">
          <source>For the block property, new-style block names are returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">블록 특성의 경우 새 스타일 블록 이름이 리턴됩니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e62a0b0dfb533953b1b1d8670e578cf8cef3f43" translate="yes" xml:space="preserve">
          <source>For the constructs except here-docs, single characters are used as starting and ending delimiters. If the starting delimiter is an opening punctuation (that is &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;, or &lt;code&gt;&amp;lt;&lt;/code&gt; ), the ending delimiter is the corresponding closing punctuation (that is &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt;). If the starting delimiter is an unpaired character like &lt;code&gt;/&lt;/code&gt; or a closing punctuation, the ending delimiter is the same as the starting delimiter. Therefore a &lt;code&gt;/&lt;/code&gt; terminates a &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; construct, while a &lt;code&gt;]&lt;/code&gt; terminates both &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq[]&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq]]&lt;/a&gt;&lt;/code&gt; constructs.</source>
          <target state="translated">here-docs를 제외한 구문의 경우 단일 문자가 시작 및 끝 구분 기호로 사용됩니다. 시작 구분 기호가 여는 문장 부호 (즉 , &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;{&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; )) 인 경우 끝 구분 기호는 해당하는 닫는 문장 부호 (즉 , &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;}&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 입니다. 시작 구분 기호가 &lt;code&gt;/&lt;/code&gt; 또는 닫는 문장 부호 와 같이 짝이없는 문자 인 경우 끝 구분 기호는 시작 구분 기호와 같습니다. 따라서 a &lt;code&gt;/&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 구문을 종료하고 a &lt;code&gt;]&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq[]&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq]]&lt;/a&gt;&lt;/code&gt; 를 모두 종료합니다 . 구조물.</target>
        </trans-unit>
        <trans-unit id="e4f199a5411adb8b18d5dcd3eca491b6d0afa516" translate="yes" xml:space="preserve">
          <source>For the details of the current situation with calling external programs, see &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;2 (and DOS) programs under Perl in Starting OS&lt;/a&gt;. Set us mention a couple of features:</source>
          <target state="translated">외부 프로그램 호출에 대한 현재 상황에 대한 세부 사항은 &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;OS 시작의 Perl 아래 2 (및 DOS) 프로그램을&lt;/a&gt; 참조하십시오 . 다음과 같은 몇 가지 기능을 언급하십시오.</target>
        </trans-unit>
        <trans-unit id="f1218216e6666aa08fea7db0711070bf940dc1b0" translate="yes" xml:space="preserve">
          <source>For the example above, this produces the key &quot;13 1 2 3 4 5 6 7&quot;.</source>
          <target state="translated">위의 예에서는 키 &quot;13 1 2 3 4 5 6 7&quot;이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb3be8f56df5259eb022c810ec0d5fe6e171757" translate="yes" xml:space="preserve">
          <source>For the full and latest information about Unicode see the latest Unicode standard, or the Unicode Consortium's website &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</source>
          <target state="translated">유니 코드에 대한 전체 및 최신 정보는 최신 유니 코드 표준 또는 유니 코드 컨소시엄 웹 사이트 &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8668a856ebdec95f7f9bedf605f00147e6a5c893" translate="yes" xml:space="preserve">
          <source>For the inverse cosine operation, you may use the &lt;code&gt;Math::Trig::acos()&lt;/code&gt; function, or use this relation:</source>
          <target state="translated">역 코사인 연산의 경우 &lt;code&gt;Math::Trig::acos()&lt;/code&gt; 함수를 사용하거나 다음 관계를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a905ba655e6e826aa1adf29366a4b3be68fc4622" translate="yes" xml:space="preserve">
          <source>For the inverse sine operation, you may use the &lt;code&gt;Math::Trig::asin&lt;/code&gt; function, or use this relation:</source>
          <target state="translated">&lt;code&gt;Math::Trig::asin&lt;/code&gt; 경우 Math :: Trig :: asin 함수를 사용 하거나이 관계를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6876721cfa8799910e64a479d1896bac8905fc75" translate="yes" xml:space="preserve">
          <source>For the long explanation, see David Goldberg's &quot;What Every Computer Scientist Should Know About Floating-Point Arithmetic&quot; (&lt;a href=&quot;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&quot;&gt;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&lt;/a&gt;).</source>
          <target state="translated">자세한 설명은 David Goldberg의 &quot;모든 컴퓨터 과학자가 부동 소수점 산술에 대해 알아야 할 사항&quot;( &lt;a href=&quot;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&quot;&gt;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&lt;/a&gt; )을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab2b9b857d720a0495db321b12b78ce4f7c0fe32" translate="yes" xml:space="preserve">
          <source>For the most part, everything should just work.</source>
          <target state="translated">대부분의 경우 모든 것이 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="64bfdda2355e6cc7b725609cd6e4467f4aa79c60" translate="yes" xml:space="preserve">
          <source>For the most part, the &lt;b&gt;Pod::Parser&lt;/b&gt; base class should be able to do most of the input parsing for you and leave you free to worry about how to interpret the commands and translate the result.</source>
          <target state="translated">대부분의 경우, &lt;b&gt;Pod :: Parser&lt;/b&gt; 기본 클래스는 대부분의 입력 구문 분석을 수행 할 수 있어야하며 명령 해석 및 결과 변환 방법에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e7967ce42595fba722f8b428604ad3ef68e4c" translate="yes" xml:space="preserve">
          <source>For the pattern of regex operators (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;), the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation is processed, but before escapes are processed. This allows the pattern to match literally (except for &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; ). For example, the following matches:</source>
          <target state="translated">정규 표현식 연산자 패턴 ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; )의 경우 &lt;code&gt;\Q&lt;/code&gt; 의 인용은 보간이 처리 된 후 이스케이프가 처리되기 전에 적용됩니다. 이를 통해 패턴이 문자 그대로 일치 할 수 있습니다 ( &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 제외 ). 예를 들어, 다음이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3962dca7589f77e8258212e6709cb6dc2b855dcb" translate="yes" xml:space="preserve">
          <source>For the purpose of inheritance every overloaded package behaves as if &lt;code&gt;fallback&lt;/code&gt; is present (possibly undefined). This may create interesting effects if some package is not overloaded, but inherits from two overloaded packages.</source>
          <target state="translated">상속을 위해 모든 오버로드 된 패키지는 폴 &lt;code&gt;fallback&lt;/code&gt; 존재하는 것처럼 작동합니다 (아마도 정의되지 않은 것 같습니다). 일부 패키지가 오버로드되지 않았지만 두 개의 오버로드 된 패키지에서 상속되는 경우 흥미로운 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82c1e221649c157f620843ea4889acff34e37d34" translate="yes" xml:space="preserve">
          <source>For the purpose of this pragma, interpolation of precompiled regular expressions (i.e., the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) is</source>
          <target state="translated">이 pragma의 목적 상, 미리 컴파일 된 정규 표현식의 보간 (즉, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의 결과 )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba3e421d172c8c68f6d89fe7339af35a2610b123" translate="yes" xml:space="preserve">
          <source>For the regular expression, /\bPerl\b/, there has to be a word boundary before the &quot;P&quot; and after the &quot;l&quot;. As long as something other than a word character precedes the &quot;P&quot; and succeeds the &quot;l&quot;, the pattern will match. These strings match /\bPerl\b/.</source>
          <target state="translated">정규식 / \ bPerl \ b /의 경우 &quot;P&quot;앞과 &quot;l&quot;뒤에 단어 경계가 있어야합니다. 단어 이외의 문자가 &quot;P&quot;앞에오고 &quot;l&quot;에 성공하면 패턴이 일치합니다. 이 문자열은 / \ bPerl \ b /와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6f420a434584dca0d2af03f0912dee0967b4dc89" translate="yes" xml:space="preserve">
          <source>For the reverse of stringifying, see the &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;emake&lt;/code&gt; 화의 역순은 &lt;code&gt;make&lt;/code&gt; 및 emake를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb38c53d822d8e08d87924c605322b6766068193" translate="yes" xml:space="preserve">
          <source>For the reverse operation, we'll have to determine the number of items in the buffer before we can let &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; rip it apart:</source>
          <target state="translated">역 동작을하려면, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 전에 버퍼에있는 아이템의 수를 결정해야합니다 :</target>
        </trans-unit>
        <trans-unit id="4dc883c9ac944705d2c3538c7663a30491ff44ec" translate="yes" xml:space="preserve">
          <source>For the reverse, see &lt;a href=&quot;#chr&quot;&gt;chr&lt;/a&gt;. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more about Unicode.</source>
          <target state="translated">반대의 경우, &lt;a href=&quot;#chr&quot;&gt;chr을&lt;/a&gt; 참조하십시오 . 유니 코드에 대한 자세한 내용은 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cbf2eafc92f15723736c9c72868093d76361c9" translate="yes" xml:space="preserve">
          <source>For the reverse, see &lt;a href=&quot;chr&quot;&gt;chr&lt;/a&gt;. See &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more about Unicode.</source>
          <target state="translated">반대의 경우, &lt;a href=&quot;chr&quot;&gt;chr을&lt;/a&gt; 참조하십시오 . 유니 코드에 대한 자세한 내용은 &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="467ceafc8b99b23ed78b230316a1d2fd5db20386" translate="yes" xml:space="preserve">
          <source>For the reverse, use &lt;a href=&quot;#ord&quot;&gt;ord&lt;/a&gt;.</source>
          <target state="translated">반대로, &lt;a href=&quot;#ord&quot;&gt;ord를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6051659642df2e97b5594ae4ac7df1aad97530d" translate="yes" xml:space="preserve">
          <source>For the reverse, use &lt;a href=&quot;ord&quot;&gt;ord&lt;/a&gt;.</source>
          <target state="translated">반대로, &lt;a href=&quot;ord&quot;&gt;ord를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7f75a65f093671232956735031c2585d37439c1" translate="yes" xml:space="preserve">
          <source>For the rounding mode, see &lt;a href=&quot;#fegetround&quot;&gt;fegetround&lt;/a&gt;.</source>
          <target state="translated">반올림 모드는 &lt;a href=&quot;#fegetround&quot;&gt;fegetround를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a7023212a15791913a95ba1c43764471fafd45" translate="yes" xml:space="preserve">
          <source>For the sake of speed and efficiency, most of the encodings are now supported via a</source>
          <target state="translated">속도와 효율성을 위해 대부분의 인코딩은 이제</target>
        </trans-unit>
        <trans-unit id="ad21271dd49f14dc112f37ba2aaf54b53f9fb3d0" translate="yes" xml:space="preserve">
          <source>For the sake of speed for a common case, in the above algorithms backslashes in the command name are not considered as shell metacharacters.</source>
          <target state="translated">일반적인 경우 속도를 높이기 위해 위의 알고리즘에서 명령 이름의 백 슬래시는 셸 메타 문자로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13bb8b6279ccfe0d9f624beb9c39acf42987a9f6" translate="yes" xml:space="preserve">
          <source>For the tangent operation, you may use the &lt;code&gt;Math::Trig::tan&lt;/code&gt; function, or use the familiar relation:</source>
          <target state="translated">탄젠트 연산의 경우 &lt;code&gt;Math::Trig::tan&lt;/code&gt; 함수를 사용하거나 익숙한 관계를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2285c9ff17a7e14c88876a7216e0b2f44e88a62a" translate="yes" xml:space="preserve">
          <source>For the time being, any necessary padding must be done by the user. Fortunately, this is a simple operation: if the length of a Base64-encoded digest isn't a multiple of 4, simply append &quot;=&quot; characters to the end of the digest until it is:</source>
          <target state="translated">당분간 필요한 패딩은 사용자가 수행해야합니다. 다행히도 이것은 간단한 작업입니다. Base64로 인코딩 된 다이제스트의 길이가 4의 배수가 아닌 경우 다이제스트 끝에 &quot;=&quot;문자를 추가 할 때까지 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="08b2d3f59edd8b61350507d43c91115b5897da2d" translate="yes" xml:space="preserve">
          <source>For the various values of PERLIO see &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;.</source>
          <target state="translated">PERLIO의 다양한 값은 &lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrun&lt;/a&gt; 의 PERLIO를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8844b265400f6667c325f1ddff5acf01441d43a0" translate="yes" xml:space="preserve">
          <source>For these purposes &quot;formats&quot; are a kind-of CV; eval&quot;&quot;s are too (except they're not callable at will and are always thrown away after the eval&quot;&quot; is done executing). Require'd files are simply evals without any outer lexical scope.</source>
          <target state="translated">이러한 목적을 위해 &quot;형식&quot;은 일종의 CV입니다. eval &quot;&quot;도 마찬가지입니다 (단, 그들이 마음대로 호출 할 수없고 eval &quot;&quot;이 실행 된 후에 항상 버려집니다 &quot;). 필요한 파일은 외부 어휘 범위없이 간단히 사라집니다.</target>
        </trans-unit>
        <trans-unit id="ce3d10f5200fd9f35eb39a2e2f3aff9e21a56d2a" translate="yes" xml:space="preserve">
          <source>For this discussion, we'll implement an array whose elements are a fixed size at creation. If you try to create an element larger than the fixed size, you'll take an exception. For example:</source>
          <target state="translated">이 토론에서는 생성시 요소의 크기가 고정 된 배열을 구현합니다. 고정 크기보다 큰 요소를 만들려고하면 예외가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd7f12ddaa1b6fb60aa095946c012384bca946" translate="yes" xml:space="preserve">
          <source>For this grouping operator there is no need to describe the ordering, since only whether or not &lt;code&gt;S&lt;/code&gt; can match is important.</source>
          <target state="translated">이 그룹화 연산자의 경우 &lt;code&gt;S&lt;/code&gt; 를 일치시킬 수 있는지 여부 만 중요하기 때문에 순서를 설명 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cc327a8066a607761f2f00ba1baa6fe5fc670e29" translate="yes" xml:space="preserve">
          <source>For this particular case an INIT: keyword would generate the same C code as the PREINIT: keyword. Another correct, but error-prone example:</source>
          <target state="translated">이 특별한 경우에 INIT : 키워드는 PREINIT : 키워드와 동일한 C 코드를 생성합니다. 정확하지만 오류가 발생하기 쉬운 다른 예 :</target>
        </trans-unit>
        <trans-unit id="145862e7b4274977f12fe15b3504a6befbd27f0c" translate="yes" xml:space="preserve">
          <source>For this reason, Unicode strings need to be converted to UTF-8-encoded bytestrings before they are handed off to &lt;code&gt;add_data()&lt;/code&gt; :</source>
          <target state="translated">이러한 이유로, 유니 코드 문자열은 &lt;code&gt;add_data()&lt;/code&gt; 로 전달되기 전에 UTF-8로 인코딩 된 바이트 문자열로 변환되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2b9d5527f46d12ea221667541772074c58883c4" translate="yes" xml:space="preserve">
          <source>For this reason, the use of &lt;code&gt;END&lt;/code&gt; blocks in threads is &lt;b&gt;strongly&lt;/b&gt; discouraged.</source>
          <target state="translated">이러한 이유로, 사용 &lt;code&gt;END&lt;/code&gt; 의 스레드 블록입니다 &lt;b&gt;강하게&lt;/b&gt; 낙담.</target>
        </trans-unit>
        <trans-unit id="6e04b91b7b687e03cffdfdf3a54823d050aa6f6b" translate="yes" xml:space="preserve">
          <source>For this to happen, the class must not be inverted (see &lt;a href=&quot;#Negation&quot;&gt;Negation&lt;/a&gt;) and the character must be explicitly specified, and not be part of a multi-character range (not even as one of its endpoints). (&lt;a href=&quot;#Character-Ranges&quot;&gt;Character Ranges&lt;/a&gt; will be explained shortly.) Therefore,</source>
          <target state="translated">이를 위해서는 클래스를 &lt;a href=&quot;#Negation&quot;&gt;뒤집지&lt;/a&gt; 말아야하고 ( 부정 참조 ) 문자를 명시 적으로 지정해야하며 다중 문자 범위의 일부가 아니어야합니다 (끝점 중 하나가 아님). ( &lt;a href=&quot;#Character-Ranges&quot;&gt;문자 범위에&lt;/a&gt; 대해서는 간략히 설명하겠습니다.) 따라서</target>
        </trans-unit>
        <trans-unit id="e5f1c25c243913e44f46f14a2a6685401a32ac3f" translate="yes" xml:space="preserve">
          <source>For those grammatical pedants out there, there's an &lt;code&gt;isn't()&lt;/code&gt; function which is an alias of &lt;code&gt;isnt()&lt;/code&gt; .</source>
          <target state="translated">거기 그 문법의 pedants를 들어, 거기 &lt;code&gt;isn't()&lt;/code&gt; 의 별칭입니다 기능 &lt;code&gt;isnt()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0194baebcc4ad338a3d27044bda911227e0fa177" translate="yes" xml:space="preserve">
          <source>For those of you who don't like additional global variables being created, &lt;code&gt;getopt()&lt;/code&gt; and &lt;code&gt;getopts()&lt;/code&gt; will also accept a hash reference as an optional second argument. Hash keys will be &lt;code&gt;x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) with key values the value of the argument or &lt;code&gt;1&lt;/code&gt; if no argument is specified.</source>
          <target state="translated">추가 전역 변수 작성을 원하지 않는 사용자에게는 &lt;code&gt;getopt()&lt;/code&gt; 및 &lt;code&gt;getopts()&lt;/code&gt; 도 해시 참조를 선택적 두 번째 인수로 허용합니다. 해시 키는 &lt;code&gt;x&lt;/code&gt; (여기서 &lt;code&gt;x&lt;/code&gt; 는 스위치 이름)이며 키 값은 인수 값이거나 인수가 지정되지 않은 경우 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b7b01e9b9a30ca0a332a8ff42ff01fc2ab10b42" translate="yes" xml:space="preserve">
          <source>For those preferring a higher-level interface to socket programming, the IO::Socket module provides an object-oriented approach. If for some reason you lack this module, you can just fetch IO::Socket from CPAN, where you'll also find modules providing easy interfaces to the following systems: DNS, FTP, Ident (RFC 931), NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--to name just a few.</source>
          <target state="translated">소켓 프로그래밍에 대한 높은 수준의 인터페이스를 선호하는 사람들을 위해 IO :: Socket 모듈은 객체 지향 접근 방식을 제공합니다. 어떤 이유로 든이 모듈이없는 경우 CPAN에서 IO :: Socket을 가져올 수 있습니다. 여기서 DNS, FTP, Ident (RFC 931), NIS 및 NISPlus, NNTP와 같은 시스템에 쉽게 인터페이스를 제공하는 모듈을 찾을 수 있습니다. , Ping, POP3, SMTP, SNMP, SSLeay, Telnet 및 Time 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e42062d65775a1867386b08263976fa1b5777e72" translate="yes" xml:space="preserve">
          <source>For those times when it is necessary to have platform-specific code, consider keeping the platform-specific code in one place, making porting to other platforms easier. Use the &lt;code&gt;Config&lt;/code&gt; module and the special variable &lt;code&gt;$^O&lt;/code&gt; to differentiate platforms, as described in &lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;.</source>
          <target state="translated">플랫폼 별 코드가 필요한 경우 플랫폼 별 코드를 한 곳에 보관하여 다른 플랫폼으로 쉽게 포팅 할 수 있습니다. 사용 &lt;code&gt;Config&lt;/code&gt; 모듈과 특수 변수 &lt;code&gt;$^O&lt;/code&gt; 에 설명 된대로 미분 플랫폼, &lt;a href=&quot;#PLATFORMS&quot;&gt;플랫폼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84af40bcdd6cb4fcbd3aceb5a4aa3593a23036aa" translate="yes" xml:space="preserve">
          <source>For those to work, the Pod-processing subclass of Pod::Simple::PullParser has to have defined a $parser-&amp;gt;run method -- so it is advised that all Pod::Simple::PullParser subclasses do so. See the Synopsis above, or the source for Pod::Simple::RTF.</source>
          <target state="translated">이들이 작동하려면 Pod :: Simple :: PullParser의 포드 처리 서브 클래스가 $ parser-&amp;gt; run 메소드를 정의해야하므로 모든 Pod :: Simple :: PullParser 서브 클래스가 그렇게하는 것이 좋습니다. 위의 개요 또는 Pod :: Simple :: RTF 소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57708cdc23a61a116a94a02091f20a5743825ee2" translate="yes" xml:space="preserve">
          <source>For those variables that have an &lt;b&gt;awk&lt;/b&gt; version, both long and short English alternatives are provided. For example, the &lt;code&gt;$/&lt;/code&gt; variable can be referred to either $RS or $INPUT_RECORD_SEPARATOR if you are using the English module.</source>
          <target state="translated">&lt;b&gt;awk&lt;/b&gt; 버전 이있는 변수의 경우 길고 짧은 영어 대안이 모두 제공됩니다. 예를 들어, 영어 모듈을 사용하는 경우 &lt;code&gt;$/&lt;/code&gt; 변수는 $ RS 또는 $ INPUT_RECORD_SEPARATOR로 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a0a89c68e7b08863ca5af8b26671ca9622ae82" translate="yes" xml:space="preserve">
          <source>For thread safety, modules should not write directly to this array. Instead, use the function &lt;a href=&quot;#wrap_op_checker&quot;&gt;wrap_op_checker&lt;/a&gt;.</source>
          <target state="translated">스레드 안전을 위해 모듈은이 어레이에 직접 쓰지 않아야합니다. 대신 &lt;a href=&quot;#wrap_op_checker&quot;&gt;wrap_op_checker&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cacce03e577b17c33a4569c50a9b7a97dcf2d96" translate="yes" xml:space="preserve">
          <source>For threaded builds, perl requires the context pointer for the current thread, without &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; , perl will call a function to retrieve the context.</source>
          <target state="translated">스레드 빌드의 경우 perl에는 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 없이 현재 스레드에 대한 컨텍스트 포인터가 필요합니다 . perl은 컨텍스트를 검색하는 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5847b93f0e1805fa116eb823dc4911eae257671b" translate="yes" xml:space="preserve">
          <source>For three or more arguments if MODE is &lt;code&gt;|-&lt;/code&gt; , the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt; , the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt; ) with the command. See &lt;a href=&quot;../perlipc#Using-open()-for-IPC&quot;&gt;Using open() for IPC in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to a command that pipes both in</source>
          <target state="translated">MODE가 &lt;code&gt;|-&lt;/code&gt; 인 경우 세 개 이상의 인수의 경우 파일 이름은 출력을 파이프 할 명령으로 해석되고 MODE가 &lt;code&gt;-|&lt;/code&gt; , 파일 이름은 출력을 우리에게 파이프하는 명령으로 해석됩니다. 2 인수 (및 1 인수) 형식에서 대시 ( &lt;code&gt;-&lt;/code&gt; )를 명령으로 바꿔야 합니다. &lt;a href=&quot;../perlipc#Using-open()-for-IPC&quot;&gt;이에&lt;/a&gt; 대한 자세한 예는 perlipc에서 IPC에 open () 사용을 참조하십시오 . ( 둘 다 파이프하는 명령 을 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6dd4431238a703da90497fd4857cf48e6171b713" translate="yes" xml:space="preserve">
          <source>For three or more arguments if MODE is &lt;code&gt;|-&lt;/code&gt;, the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt;, the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt; ) with the command. See &lt;a href=&quot;perlipc#Using-open()-for-IPC&quot;&gt;Using open() for IPC in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to a command that pipes both in</source>
          <target state="translated">MODE가 &lt;code&gt;|-&lt;/code&gt; 인 경우 세 개 이상의 인수의 경우 파일 이름은 출력을 파이프 할 명령으로 해석되고 MODE가 &lt;code&gt;-|&lt;/code&gt; , 파일 이름은 출력을 우리에게 파이프하는 명령으로 해석됩니다. 2 인수 (및 1 인수) 형식에서 대시 ( &lt;code&gt;-&lt;/code&gt; )를 명령으로 바꿔야 합니다. &lt;a href=&quot;perlipc#Using-open()-for-IPC&quot;&gt;이에&lt;/a&gt; 대한 자세한 예는 perlipc에서 IPC에 open () 사용을 참조하십시오 . ( 둘 다 파이프하는 명령 을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bf83195223f53cdba1b00e5a9f41ecd342d04331" translate="yes" xml:space="preserve">
          <source>For typed lexicals PadnameTYPE points at the type stash. For &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lexicals, PadnameOURSTASH points at the stash of the associated global (so that duplicate &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations in the same package can be detected). PadnameGEN is sometimes used to store the generation number during compilation.</source>
          <target state="translated">입력 된 어휘의 경우 PadnameTYPE은 숨김 유형을 가리 킵니다. 들어 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lexicals, 관련 세계의 숨겨 놓은에서 PadnameOURSTASH 포인트 (즉, 중복, 그래서 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 같은 패키지의 선언 검출 할 수있다). PadnameGEN은 컴파일 중에 생성 번호를 저장하는 데 사용되기도합니다.</target>
        </trans-unit>
        <trans-unit id="91986aaa66a7c1fc5ea1ae9b7846d756f92bfc49" translate="yes" xml:space="preserve">
          <source>For various reasons &lt;code&gt;\K&lt;/code&gt; may be significantly more efficient than the equivalent &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; construct, and it is especially useful in situations where you want to efficiently remove something following something else in a string. For instance</source>
          <target state="translated">여러 가지 이유로 &lt;code&gt;\K&lt;/code&gt; 는 동등한 &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; 구문 보다 훨씬 더 효율적일 수 있으며 , 문자열에서 다른 것을 따르는 것을 효율적으로 제거하려는 상황에서 특히 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="177cf62cd78233abf54102693c9e9acbadd8394b" translate="yes" xml:space="preserve">
          <source>For versions &amp;lt; 5.6.0, the changes are. - no use of 'our' (uses 'use vars' instead) - no 'use warnings'</source>
          <target state="translated">&amp;lt;5.6.0 버전의 경우 변경 사항이 적용됩니다. - 'our'를 사용하지 않습니다 (대신에 'use vars'를 사용합니다)- 'use warnings'</target>
        </trans-unit>
        <trans-unit id="60941c7eb5c54adfbab7ac22e457a8c4e15f2100" translate="yes" xml:space="preserve">
          <source>For writing RFC 1950 files/buffers, see the companion module IO::Compress::Deflate.</source>
          <target state="translated">RFC 1950 파일 / 버퍼 작성에 대해서는 컴패니언 모듈 IO :: Compress :: Deflate를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="685182a7768729bc793033bd0e68d3c4f3af5f73" translate="yes" xml:space="preserve">
          <source>For writing RFC 1951 files/buffers, see the companion module IO::Compress::RawDeflate.</source>
          <target state="translated">RFC 1951 파일 / 버퍼 작성에 대해서는 컴패니언 모듈 IO :: Compress :: RawDeflate를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9243b703bb54f6641362690a1ee88fd13adf9954" translate="yes" xml:space="preserve">
          <source>For writing RFC 1952 files/buffers, see the companion module IO::Compress::Gzip.</source>
          <target state="translated">RFC 1952 파일 / 버퍼 작성에 대해서는 컴패니언 모듈 IO :: Compress :: Gzip을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bf658d02b726edd2f1c254066ded7736fd6d5a9" translate="yes" xml:space="preserve">
          <source>For writing bzip2 files/buffers, see the companion module IO::Compress::Bzip2.</source>
          <target state="translated">bzip2 파일 / 버퍼를 작성하려면 컴패니언 모듈 IO :: Compress :: Bzip2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e13d75b855f37f1330f6f4c1ef3a45768526e035" translate="yes" xml:space="preserve">
          <source>For writing zip files/buffers, see the companion module IO::Compress::Zip.</source>
          <target state="translated">zip 파일 / 버퍼를 작성하려면 컴패니언 모듈 IO :: Compress :: Zip을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="535406d475920b171aa234460dc25648f86b16d6" translate="yes" xml:space="preserve">
          <source>For your convenience, Perl has added the &lt;code&gt;Non_Canonical&lt;/code&gt; decomposition type to mean any of the several compatibility decompositions.</source>
          <target state="translated">편의상 Perl은 &lt;code&gt;Non_Canonical&lt;/code&gt; 분해 유형을 추가 하여 여러 호환성 분해를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53ad46f1c41b22f84b5d3b3f5d59b0ffd2ec8775" translate="yes" xml:space="preserve">
          <source>For your convenience, Perl sets up a few special filehandles that are already open when you run. These include &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;STDERR&lt;/code&gt; , and &lt;code&gt;ARGV&lt;/code&gt; . Since those are pre-opened, you can use them right away without having to go to the trouble of opening them yourself:</source>
          <target state="translated">편의상 Perl은 실행할 때 이미 열려있는 몇 가지 특수 파일 핸들을 설정합니다. 여기에는 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;STDERR&lt;/code&gt; 및 &lt;code&gt;ARGV&lt;/code&gt; 가 포함 됩니다. 그것들은 미리 열렸으므로 직접 열지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="30e11a0cc028d202d8463cc9e66bddef5da4b46a" translate="yes" xml:space="preserve">
          <source>For, begin, and end will let you have regions of text/code/data that are not generally interpreted as normal Pod text, but are passed directly to particular formatters, or are otherwise special. A formatter that can use that format will use the region, otherwise it will be completely ignored.</source>
          <target state="translated">for, begin 및 end를 사용하면 일반적으로 일반 포드 텍스트로 해석되지 않지만 특정 포맷터로 직접 전달되거나 특수한 텍스트 / 코드 / 데이터 영역을 사용할 수 있습니다. 해당 형식을 사용할 수있는 포맷터는 영역을 사용하고 그렇지 않으면 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="75b520175307f045a1bd5432ec6c11ebe784b1ea" translate="yes" xml:space="preserve">
          <source>Force a title for the page (don't try to determine it from the content). The value of this string should already be &amp;amp;-escaped.</source>
          <target state="translated">페이지 제목을 강요하십시오 (콘텐츠에서 결정하지 마십시오). 이 문자열의 값은 이미 &amp;amp; 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="000583668b82be86fbb138b24c7dd36579b394a2" translate="yes" xml:space="preserve">
          <source>Force bsd_glob() to return an error when it encounters a directory it cannot open or read. Ordinarily bsd_glob() continues to find matches.</source>
          <target state="translated">bsd_glob ()가 열거 나 읽을 수없는 디렉토리가 발견되면 오류를 리턴하도록합니다. 일반적으로 bsd_glob ()는 계속 일치 항목을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f44e8f61765329d123a6aeba46d29dc380866fc3" translate="yes" xml:space="preserve">
          <source>Force byte semantics rather than character semantics</source>
          <target state="translated">문자 의미보다는 강제 바이트 의미</target>
        </trans-unit>
        <trans-unit id="e13bf2b7599ac8779de2f3726115bde91fbbaded" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task it would normally refuse to do. Force takes as arguments a method name to be invoked and any number of additional arguments to pass that method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">CPAN이 일반적으로 거부하는 작업을 수행하도록합니다. Force는 메소드 이름을 호출 할 인수와 해당 메소드를 전달할 수있는 추가 인수를 인수로 사용합니다. CPAN.pm이 조치를 거부하지 않도록 오브젝트 내부에 필요한 변경 사항이 있습니다. &lt;code&gt;force&lt;/code&gt; 과 &lt;code&gt;fforce&lt;/code&gt; pragma 에 대한 위의 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6824e435b9c0d512ec0dbbda74a3d74da3f722c9" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task that it normally would have refused to do. Force takes as arguments a method name to be called and any number of additional arguments that should be passed to the called method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">CPAN이 일반적으로 거부 한 작업을 수행하도록합니다. Force는 메소드 이름을 호출 할 인수와 호출 된 메소드에 전달해야하는 추가 인수를 인수로 사용합니다. CPAN.pm이 조치를 거부하지 않도록 오브젝트 내부에 필요한 변경 사항이 있습니다. &lt;code&gt;force&lt;/code&gt; 과 &lt;code&gt;fforce&lt;/code&gt; pragma 에 대한 위의 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c9a0d4c05ea685c4b81ce563d38fd33d0aeea12" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task that it normally would have refused to do. Force takes as arguments a method name to be called and any number of additional arguments that should be passed to the called method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. The &lt;code&gt;force&lt;/code&gt; is passed recursively to all contained objects. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">CPAN이 일반적으로 거부 한 작업을 수행하도록합니다. Force는 메소드 이름을 호출 할 인수와 호출 된 메소드에 전달해야하는 추가 인수를 인수로 사용합니다. CPAN.pm이 조치를 거부하지 않도록 오브젝트 내부에 필요한 변경 사항이 있습니다. &lt;code&gt;force&lt;/code&gt; 모든 포함 된 개체에 반복적으로 전달됩니다. &lt;code&gt;force&lt;/code&gt; 과 &lt;code&gt;fforce&lt;/code&gt; pragma 에 대한 위의 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f116ab22ad8af5d1edf47652c0fde4ebe02b3188" translate="yes" xml:space="preserve">
          <source>Forces EXPR to be interpreted in scalar context and returns the value of EXPR.</source>
          <target state="translated">EXPR을 스칼라 컨텍스트에서 해석하도록하고 EXPR의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="500df2d2fe4d1817ceeca100a5e6d863aec7944d" translate="yes" xml:space="preserve">
          <source>Forces a reload of all indices.</source>
          <target state="translated">모든 인덱스를 강제로 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="ec27ff3ecad1733cd6196463fe06ab0d70361cc8" translate="yes" xml:space="preserve">
          <source>Forcing AutoLoader to Load a Function</source>
          <target state="translated">자동로드 기능을 강제로로드</target>
        </trans-unit>
        <trans-unit id="4a87f71febe991ae2954e6d639d10481ac9e6d2d" translate="yes" xml:space="preserve">
          <source>Forcing Unicode in Perl (Or Unforcing Unicode in Perl)</source>
          <target state="translated">Perl에서 유니 코드 강제 실행 (또는 Perl에서 유니 코드 강제 해제)</target>
        </trans-unit>
        <trans-unit id="fa74775094fcf161164e8e879c58a4b633ace5dd" translate="yes" xml:space="preserve">
          <source>Forcing a Stack Trace</source>
          <target state="translated">스택 추적 강제</target>
        </trans-unit>
        <trans-unit id="f6c5999fd3e671fe9fe9df464e28ef5ab21206ca" translate="yes" xml:space="preserve">
          <source>Forcing big- or little-endian byte-order on floating-point values for data exchange can work only if all platforms use the same binary representation such as IEEE floating-point. Even if all platforms are using IEEE, there may still be subtle differences. Being able to use &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on floating-point values can be useful, but also dangerous if you don't know exactly what you're doing. It is not a general way to portably store floating-point values.</source>
          <target state="translated">모든 플랫폼이 IEEE 부동 소수점과 같은 이진 표현을 사용하는 경우에만 데이터 교환을 위해 부동 소수점 값에 빅 엔디안 또는 리틀 엔디안 바이트 순서를 강제 할 수 있습니다. 모든 플랫폼에서 IEEE를 사용하더라도 여전히 미묘한 차이가있을 수 있습니다. 부동 소수점 값에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 사용할 수 있으면 유용 할 수 있지만 수행중인 작업을 정확히 모르면 위험 할 수도 있습니다. 부동 소수점 값을 이식 가능하게 저장하는 일반적인 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4fbdd84d18aabd3608a03167cf0b04d250e02a5e" translate="yes" xml:space="preserve">
          <source>Foreach Loops</source>
          <target state="translated">Foreach 루프</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="3142b84bb5d35f3314b7947362fd81b2dce6a441" translate="yes" xml:space="preserve">
          <source>Forking pipe open() constructs will be supported in future.</source>
          <target state="translated">포크 파이프 open () 구성은 향후 지원 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c82bb36a64035b3b3d413194135e78450e65b2bf" translate="yes" xml:space="preserve">
          <source>Format Pod as RTF</source>
          <target state="translated">RTF로 포드 포맷</target>
        </trans-unit>
        <trans-unit id="fee1af11bb1eb0f8161a549c43ed448ab786fe6a" translate="yes" xml:space="preserve">
          <source>Format Pod as plaintext</source>
          <target state="translated">포드를 일반 텍스트로 포맷</target>
        </trans-unit>
        <trans-unit id="7740187b3e5d9aaa6412746917f4e8aaed9600e7" translate="yes" xml:space="preserve">
          <source>Format Pod as validating XHTML</source>
          <target state="translated">XHTML을 검증하는 것으로 포드 포맷</target>
        </trans-unit>
        <trans-unit id="13163280307f8765d0afe577cafca7728ff8779c" translate="yes" xml:space="preserve">
          <source>Format Variables</source>
          <target state="translated">형식 변수</target>
        </trans-unit>
        <trans-unit id="3a1ad455810d4298663c009286d3773850b6eb92" translate="yes" xml:space="preserve">
          <source>Format defined.</source>
          <target state="translated">형식이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="45682ea5e61958bde7db300ab1675b68475b3238" translate="yes" xml:space="preserve">
          <source>Format the output with ANSI color escape sequences. Using this option requires that Term::ANSIColor be installed on your system.</source>
          <target state="translated">ANSI 색상 이스케이프 시퀀스로 출력 형식을 지정하십시오. 이 옵션을 사용하려면 시스템에 Term :: ANSIColor가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1b6f323b8fa9a716a3f6f4fbd038ac4ec784196" translate="yes" xml:space="preserve">
          <source>Format the output with overstrike printing. Bold text is rendered as character, backspace, character. Italics and file names are rendered as underscore, backspace, character. Many pagers, such as &lt;b&gt;less&lt;/b&gt;, know how to convert this to bold or underlined text.</source>
          <target state="translated">오버 스트라이크 인쇄로 출력 형식을 지정하십시오. 굵은 체 텍스트는 문자, 백 스페이스, 문자로 렌더링됩니다. 기울임 꼴 및 파일 이름은 밑줄, 백 스페이스, 문자로 렌더링됩니다. &lt;b&gt;less&lt;/b&gt; 와 같은 많은 호출기 는 이것을 굵게 또는 밑줄이있는 텍스트로 변환하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0070c0e56a4846d0ff72c495dfd2d1f1c3c98911" translate="yes" xml:space="preserve">
          <source>Formats and prints the specified arguments to &lt;code&gt;STDOUT&lt;/code&gt; . See also &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;.</source>
          <target state="translated">지정된 인수를 &lt;code&gt;STDOUT&lt;/code&gt; 하고 STDOUT으로 인쇄합니다 . &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3359bd12a9edc6e1c703375835a3905e7b83f91" translate="yes" xml:space="preserve">
          <source>Formats, like packages and subroutines, are declared rather than executed, so they may occur at any point in your program. (Usually it's best to keep them all together though.) They have their own namespace apart from all the other &quot;types&quot; in Perl. This means that if you have a function named &quot;Foo&quot;, it is not the same thing as having a format named &quot;Foo&quot;. However, the default name for the format associated with a given filehandle is the same as the name of the filehandle. Thus, the default format for STDOUT is named &quot;STDOUT&quot;, and the default format for filehandle TEMP is named &quot;TEMP&quot;. They just look the same. They aren't.</source>
          <target state="translated">패키지 및 서브 루틴과 같은 형식은 실행되지 않고 선언되므로 프로그램의 어느 시점에서나 발생할 수 있습니다. (보통 모두 함께 유지하는 것이 가장 좋습니다.) Perl의 다른 모든 &quot;유형&quot;과는 별도로 고유 한 네임 스페이스가 있습니다. 즉, &quot;Foo&quot;라는 함수가있는 경우 &quot;Foo&quot;라는 형식의 함수와 동일하지 않습니다. 그러나 주어진 파일 핸들과 연관된 형식의 기본 이름은 파일 핸들의 이름과 동일합니다. 따라서 STDOUT의 기본 형식은 &quot;STDOUT&quot;이고 파일 핸들 TEMP의 기본 형식은 &quot;TEMP&quot;입니다. 그들은 똑같이 보입니다. 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7065a0ba158c8bf72a9807e17d920ae802c062cf" translate="yes" xml:space="preserve">
          <source>Formatted Printing of IVs, UVs, and NVs</source>
          <target state="translated">IV, UV 및 NV의 형식화 된 인쇄</target>
        </trans-unit>
        <trans-unit id="7de31570e601ac2cf7d8ef74834052348b7c4a16" translate="yes" xml:space="preserve">
          <source>Formatters may also choose to note errors/warnings as comments, besides or instead of emitting them otherwise (as in messages to STDERR, or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing).</source>
          <target state="translated">포맷터는 또한 오류 / 경고를 주석으로 표시하거나 (STDERR에 보내는 메시지에서와 같이 주석으로 표시하거나 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 대신) 주석으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dc6255b00d803dd218371c361f3f87de9be4719" translate="yes" xml:space="preserve">
          <source>Formatters may also insert additional comments, including: the release date of the Pod formatter program, the contact address for the author(s) of the formatter, the current time, the name of input file, the formatting options in effect, version of Perl used, etc.</source>
          <target state="translated">포맷터는 포드 포맷터 프로그램의 출시 날짜, 포맷터 작성자의 연락처 주소, 현재 시간, 입력 파일 이름, 유효한 포맷 옵션, Perl 버전 등의 추가 설명을 삽입 할 수도 있습니다. 등</target>
        </trans-unit>
        <trans-unit id="6d3ccf37c71280b1f96c4a2ec7fbdbe45afef9e1" translate="yes" xml:space="preserve">
          <source>Formatters may choose to ignore the markup for purposes of resolving the link and use only the renderable characters in the section name, as in:</source>
          <target state="translated">포맷터는 링크를 해결하기 위해 마크 업을 무시하고 다음과 같이 섹션 이름에 렌더링 가능한 문자 만 사용하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4aca088317275f96f5f54edc120b828492554a8" translate="yes" xml:space="preserve">
          <source>Formatters may choose to just not support the S format code, especially in cases where the output format simply has no NBSP character/code and no code for &quot;don't break this stuff across lines&quot;.</source>
          <target state="translated">포맷터는 특히 SB 코드를 지원하지 않도록 선택할 수 있습니다. 특히 출력 형식에 NBSP 문자 / 코드가없고 &quot;줄을 가로 질러이 내용을 나누지 마십시오&quot;라는 코드가없는 경우에 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="699f62e78d3e814aa9e7d06b34b37d145e111b38" translate="yes" xml:space="preserve">
          <source>Formatting Codes</source>
          <target state="translated">서식 코드</target>
        </trans-unit>
        <trans-unit id="ff5d2a34321adb03892b713850bf4a3ad301ed8c" translate="yes" xml:space="preserve">
          <source>Formatting base class</source>
          <target state="translated">기본 클래스 포맷</target>
        </trans-unit>
        <trans-unit id="ff9c8d057ff674339898e634f59656ac3a52e2b6" translate="yes" xml:space="preserve">
          <source>Formatting codes absolutely cannot span paragraphs. If a code is opened in one paragraph, and no closing code is found by the end of that paragraph, the Pod parser must close that formatting code, and should complain (as in &quot;Unterminated I code in the paragraph starting at line 123: 'Time objects are not...'&quot;). So these two paragraphs:</source>
          <target state="translated">형식화 코드는 단락을 포함 할 수 없습니다. 한 단락에서 코드가 열리고 해당 단락의 끝에서 닫는 코드가 발견되지 않으면 포드 파서는 해당 형식화 코드를 닫아야하며, &quot;123 행에서 시작하는 단락의 종료되지 않은 I 코드 : 시간 개체가 아닙니다 ... ' &quot;). 이 두 단락은</target>
        </trans-unit>
        <trans-unit id="7b18147368e5bdc22767f902bd572f166454ac0e" translate="yes" xml:space="preserve">
          <source>Formerly &quot;ji&quot;. Usually in Hebrew script.</source>
          <target state="translated">이전에는 &quot;ji&quot;입니다. 일반적으로 히브리어 스크립트에서.</target>
        </trans-unit>
        <trans-unit id="57f396d4904134a67c253fe83cd6c2ee5405024e" translate="yes" xml:space="preserve">
          <source>Formerly, a reference to an array whose initial element happens to hold a reference to a hash. You used to be able to treat a pseudohash reference as either an array reference or a hash reference. Pseduohashes are no longer supported.</source>
          <target state="translated">이전에는 초기 요소가 해시에 대한 참조를 보유하는 배열에 대한 참조입니다. 예전에는 pseudohash 참조를 배열 참조 또는 해시 참조로 취급 할 수있었습니다. Pseduohashes는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="966aae1b0b42de1dff8ae5df0d18d67c8938fc59" translate="yes" xml:space="preserve">
          <source>Fortunately, all TAP output is perfect. In the event that it is not, this method will return parser errors. Note that a junk line which the parser does not recognize is &lt;code&gt;not&lt;/code&gt; an error. This allows this parser to handle future versions of TAP. The following are all TAP errors reported by the parser:</source>
          <target state="translated">다행히 모든 TAP 출력이 완벽합니다. 그렇지 않은 경우이 메소드는 구문 분석기 오류를 리턴합니다. 파서가 인식하지 못하는 정크 라인 은 오류 가 &lt;code&gt;not&lt;/code&gt; . 이 파서는 향후 버전의 TAP를 처리 할 수 ​​있습니다. 다음은 파서가보고 한 모든 TAP 오류입니다.</target>
        </trans-unit>
        <trans-unit id="87a70390fb6164a360255317db997a9d16310113" translate="yes" xml:space="preserve">
          <source>Fortunately, all encodings that come with &lt;code&gt;Encode&lt;/code&gt; core are &lt;code&gt;PerlIO&lt;/code&gt; -savvy except for &lt;code&gt;hz&lt;/code&gt; and &lt;code&gt;ISO-2022-kr&lt;/code&gt; . For the gory details, see &lt;a href=&quot;encode/encoding&quot;&gt;Encode::Encoding&lt;/a&gt; and &lt;a href=&quot;encode/perlio&quot;&gt;Encode::PerlIO&lt;/a&gt;.</source>
          <target state="translated">다행히 &lt;code&gt;Encode&lt;/code&gt; 코어 와 함께 제공되는 모든 인코딩 은 &lt;code&gt;hz&lt;/code&gt; 및 &lt;code&gt;ISO-2022-kr&lt;/code&gt; 을 제외한 &lt;code&gt;PerlIO&lt;/code&gt; 에 정통 합니다. 자세한 내용은 &lt;a href=&quot;encode/encoding&quot;&gt;Encode :: Encoding&lt;/a&gt; 및 &lt;a href=&quot;encode/perlio&quot;&gt;Encode :: PerlIO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97fed1654379ec219795384ff23955f1b1779107" translate="yes" xml:space="preserve">
          <source>Fortunately, most web servers for the mainframe will correctly translate the &lt;code&gt;\n&lt;/code&gt; in the following statement to its ASCII equivalent (&lt;code&gt;\r&lt;/code&gt; is the same under both Unix and z/OS):</source>
          <target state="translated">다행히도 메인 프레임의 대부분의 웹 서버 는 다음 명령문에서 &lt;code&gt;\n&lt;/code&gt; 을 ASCII와 동등한 것으로 올바르게 변환합니다 ( &lt;code&gt;\r&lt;/code&gt; 은 Unix와 z / OS에서 동일 함).</target>
        </trans-unit>
        <trans-unit id="f8866d15529a7057b903143f3bead50cd0b88e71" translate="yes" xml:space="preserve">
          <source>Fortunately, sometimes this kernel &quot;feature&quot; can be disabled. Unfortunately, there are two ways to disable it. The system can simply outlaw scripts with any set-id bit set, which doesn't help much. Alternately, it can simply ignore the set-id bits on scripts.</source>
          <target state="translated">다행히도이 커널 &quot;기능&quot;을 비활성화 할 수 있습니다. 안타깝게도 두 가지 방법으로 비활성화 할 수 있습니다. 시스템은 단순히 set-id 비트 세트를 사용하여 스크립트를 불법화 할 수 있으므로 큰 도움이되지 않습니다. 또는 스크립트에서 단순히 set-id 비트를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f164c645e50a4c0c3f29fb561f1f66b8762dff" translate="yes" xml:space="preserve">
          <source>Fortunately, you only need to know 10% of what's in the main page to get 90% of the benefit. This page will show you that 10%.</source>
          <target state="translated">다행히도, 메인 페이지에있는 것의 10 % 만 알면 혜택의 90 %를 얻을 수 있습니다. 이 페이지는 10 %를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c005499309629c2dd1540384f9d88388c2791d54" translate="yes" xml:space="preserve">
          <source>Forums</source>
          <target state="translated">Forums</target>
        </trans-unit>
        <trans-unit id="7babeb8dda00cbd2717c46859a597a0ac26af8c6" translate="yes" xml:space="preserve">
          <source>Frame Listing Output Examples</source>
          <target state="translated">프레임리스트 출력 예</target>
        </trans-unit>
        <trans-unit id="e7de308f5cb42aaa93cfde86991651a82d8099b3" translate="yes" xml:space="preserve">
          <source>Framework for localization</source>
          <target state="translated">현지화를위한 프레임 워크</target>
        </trans-unit>
        <trans-unit id="3b8bd7caa7cebf02d88ee7c7bdba92155a41dbde" translate="yes" xml:space="preserve">
          <source>Framework for parsing Pod</source>
          <target state="translated">포드 파싱을위한 프레임 워크</target>
        </trans-unit>
        <trans-unit id="53885018ee90a10b7bc48c0249fdec51585e188f" translate="yes" xml:space="preserve">
          <source>Free (as in beer) books</source>
          <target state="translated">무료 (맥주에서와 같이) 책</target>
        </trans-unit>
        <trans-unit id="2045f9df7f3ddf3a7ca6cf0c4237136b9a9c596f" translate="yes" xml:space="preserve">
          <source>Free an op. Only use this when an op is no longer linked to from any optree.</source>
          <target state="translated">작전을 해제하십시오. op가 더 이상 optree에 연결되어 있지 않은 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eb0e32e0a58271635c4ef7fbb31d2d946383137e" translate="yes" xml:space="preserve">
          <source>Free any magic storage used by the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV가 사용하는 매직 스토리지를 비 웁니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e846928fcc144c7bd2db6d810b3f5976c347e3ce" translate="yes" xml:space="preserve">
          <source>Free the SV at offset po in the current pad.</source>
          <target state="translated">현재 패드에서 오프셋 po에서 SV를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="7da50e46bbfce92aaf6cbf3942c4d4d8527613b3" translate="yes" xml:space="preserve">
          <source>Free the storage associated with the tied handle referenced by</source>
          <target state="translated">에 의해 참조 된 묶인 핸들과 연관된 스토리지를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="97f264039513cfe75ea6d652749d14c6132a0656" translate="yes" xml:space="preserve">
          <source>Free the storage associated with the tied scalar referenced by</source>
          <target state="translated">연결된 스칼라와 연관된 스토리지를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="7b25f5206df2f27aaf3f69eecf641cc773e18f45" translate="yes" xml:space="preserve">
          <source>FreeBSD core dumps from readdir_r with ithreads</source>
          <target state="translated">idirs가있는 readdir_r의 FreeBSD 코어 덤프</target>
        </trans-unit>
        <trans-unit id="fffe09c3013e58f78e37a3579c3723dc99001d0b" translate="yes" xml:space="preserve">
          <source>Freely available locale definitions</source>
          <target state="translated">자유롭게 사용할 수있는 로캘 정의</target>
        </trans-unit>
        <trans-unit id="1a3d88c35190d4b2447d53bf45570277fd2a7644" translate="yes" xml:space="preserve">
          <source>Frees the all the elements of a hash, leaving it empty. The XS equivalent of &lt;code&gt;%hash = ()&lt;/code&gt; . See also &lt;a href=&quot;#hv_undef&quot;&gt;hv_undef&lt;/a&gt;.</source>
          <target state="translated">해시의 모든 요소를 ​​비우고 비워 둡니다. XS는 &lt;code&gt;%hash = ()&lt;/code&gt; 합니다. &lt;a href=&quot;#hv_undef&quot;&gt;hv_undef&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ef04d800d79b6e48aac64a67f720581e376f905" translate="yes" xml:space="preserve">
          <source>Frequently Asked Question (although not necessarily frequently answered, especially if the answer appears in the Perl FAQ shipped standard with Perl).</source>
          <target state="translated">자주 묻는 질문 (특히 Perl과 함께 제공되는 Perl FAQ에 답변이 표시되는 경우 자주 대답하지는 않지만).</target>
        </trans-unit>
        <trans-unit id="36c4bb75f29e144b11648c4e613d655770d581ce" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions About MakeMaker</source>
          <target state="translated">MakeMaker에 대한 질문과 대답</target>
        </trans-unit>
        <trans-unit id="760b682e1618036dbf7afb1d053c8ac3b71a79ee" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions about IO::Compress</source>
          <target state="translated">IO :: Compress에 대한 질문과 대답</target>
        </trans-unit>
        <trans-unit id="af90cef80988974dd76636b3adb5f472768f785d" translate="yes" xml:space="preserve">
          <source>Frequently asked questions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="82bcb61f5c6950aaf9895e515089a465e02bfa4c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.hp.com/products1/evolution/9000/faqs.html&quot;&gt;http://www.hp.com/products1/evolution/9000/faqs.html&lt;/a&gt;</source>
          <target state="translated">에서 &lt;a href=&quot;http://www.hp.com/products1/evolution/9000/faqs.html&quot;&gt;http://www.hp.com/products1/evolution/9000/faqs.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="448f239f3b8eb7ee92d28473b865c15012705b26" translate="yes" xml:space="preserve">
          <source>From C this function will be called with the following statements.</source>
          <target state="translated">C에서이 함수는 다음 명령문으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bc39bc50c4c934bc3c2b768db25fc832488e05a0" translate="yes" xml:space="preserve">
          <source>From Greek &amp;sigma;ύ&amp;nu;&amp;tau;&amp;alpha;&amp;xi;&amp;iota;&amp;sigmaf;, &amp;ldquo;with-arrangement&amp;rdquo;. How things (particularly symbols) are put together with each other.</source>
          <target state="translated">그리스어 &amp;sigma;ύ&amp;nu;&amp;tau;&amp;alpha;&amp;xi;&amp;iota;&amp;sigmaf;에서 &quot;배열&quot;. 사물 (특히 기호)이 서로 어떻게 결합되는지.</target>
        </trans-unit>
        <trans-unit id="42d1e5fd6ff04686a3ddd2292e038e6c2c64eded" translate="yes" xml:space="preserve">
          <source>From Help Consulting, for Windows.</source>
          <target state="translated">Windows 용 도움말 컨설팅에서.</target>
        </trans-unit>
        <trans-unit id="1cd8946f3bf218d8104a97d7a0815f8406dc267b" translate="yes" xml:space="preserve">
          <source>From Swift: someone who eats eggs big end first. Also used of computers that store the most significant &lt;b&gt;byte&lt;/b&gt; of a word at a lower byte address than the least significant byte. Often considered superior to little-endian machines. See also &lt;b&gt;little-endian&lt;/b&gt;.</source>
          <target state="translated">스위프트에서 : 계란을 먼저 먹는 사람. 최하위 &lt;b&gt;바이트&lt;/b&gt; 보다 하위 바이트 주소에 워드의 최상위 &lt;b&gt;바이트&lt;/b&gt; 를 저장하는 컴퓨터에도 사용됩니다 . 리틀 엔디안 머신보다 우수한 것으로 종종 간주됩니다. &lt;b&gt;little-endian&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="38010d6f3cc7fb3edd4ad08b9ae938ebd7fc3879" translate="yes" xml:space="preserve">
          <source>From Swift: someone who eats eggs little end first. Also used of computers that store the least significant &lt;b&gt;byte&lt;/b&gt; of a word at a lower byte address than the most significant byte. Often considered superior to big-endian machines. See also &lt;b&gt;big-endian&lt;/b&gt;.</source>
          <target state="translated">스위프트에서 : 계란을 먼저 먹는 사람. 또한 최상위 &lt;b&gt;바이트&lt;/b&gt; 보다 하위 바이트 주소에 워드의 최하위 &lt;b&gt;바이트&lt;/b&gt; 를 저장하는 컴퓨터에서 사용됩니다 . 종종 빅 엔디안 머신보다 우수한 것으로 간주됩니다. &lt;b&gt;big-endian&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="326d38f7c69627e156c632c28265510708e39ea4" translate="yes" xml:space="preserve">
          <source>From how far away you can see a variable, looking through one. Perl has two visibility mechanisms. It does &lt;b&gt;dynamic scoping&lt;/b&gt; of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;&lt;b&gt;variables&lt;/b&gt;, meaning that the rest of the &lt;b&gt;block&lt;/b&gt;, and any &lt;b&gt;subroutines&lt;/b&gt; that are called by the rest of the block, can see the variables that are local to the block. Perl does &lt;b&gt;lexical scoping&lt;/b&gt; of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, meaning that the rest of the block can see the variable, but other subroutines called by the block</source>
          <target state="translated">멀리서 보면 변수를 통해 변수를 볼 수 있습니다. Perl에는 두 가지 가시성 메커니즘이 있습니다. 이 수행 &lt;b&gt;동적 범위 지정&lt;/b&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; &lt;b&gt; 변수&lt;/b&gt; 의 나머지 부분 즉, &lt;b&gt;블록&lt;/b&gt; , 및 &lt;b&gt;서브 루틴&lt;/b&gt; 블록의 나머지 부분에 의해 호출 블록에 국부적 변수를 참조 할 수있다. Perl은 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수에 대한 &lt;b&gt;어휘 범위 지정&lt;/b&gt; 을 수행 합니다. 즉, 나머지 블록은 변수를 볼 수 있지만 블록에 의해 호출 된 다른 서브 루틴은</target>
        </trans-unit>
        <trans-unit id="3d95a8fc94b9e55edd8dcfe43899b426ece0c816" translate="yes" xml:space="preserve">
          <source>From the command line, you can use the &lt;code&gt;cpan&lt;/code&gt; command's &lt;code&gt;-l&lt;/code&gt; switch:</source>
          <target state="translated">명령 행에서 &lt;code&gt;cpan&lt;/code&gt; 명령의 &lt;code&gt;-l&lt;/code&gt; 스위치를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0863cef08a10ff845303e3c15c48a839f8d3f9f0" translate="yes" xml:space="preserve">
          <source>From the command line, you can use the djtar utility provided with DJGPP to unpack and expand these files. For example:</source>
          <target state="translated">명령 행에서 DJGPP와 함께 제공된 djtar 유틸리티를 사용하여 이러한 파일의 압축을 풀고 확장 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="translated">명령 행에서 :</target>
        </trans-unit>
        <trans-unit id="d445d94e4dd2201f89b37cfbbd3453a506d83550" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl array. From the C level this is a pointer to an AV.</source>
          <target state="translated">펄 레벨에서 이것은 펄 배열에 대한 참조입니다. C 레벨에서 이것은 AV에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7f363a7d4784c758d110ec4bcb974b6c5c5684cc" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl array. From the C level this is a pointer to an AV. This is a fixed variant of T_AVREF that decrements the refcount appropriately when returning an AV*. Introduced in perl 5.15.4.</source>
          <target state="translated">펄 레벨에서 이것은 펄 배열에 대한 참조입니다. C 레벨에서 이것은 AV에 대한 포인터입니다. 이것은 AV *를 반환 할 때 참조 횟수를 적절하게 감소시키는 T_AVREF의 고정 변형입니다. perl 5.15.4에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c48843f42734f52f4bf8423d32ddff93043f82f2" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl hash. From the C level this is a pointer to an HV.</source>
          <target state="translated">펄 레벨에서 이것은 펄 해시에 대한 참조입니다. C 레벨에서 이것은 HV에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="ea09196132f236e8b94218aff14a881b8e5f0e36" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl hash. From the C level this is a pointer to an HV. This is a fixed variant of T_HVREF that decrements the refcount appropriately when returning an HV*. Introduced in perl 5.15.4.</source>
          <target state="translated">펄 레벨에서 이것은 펄 해시에 대한 참조입니다. C 레벨에서 이것은 HV에 대한 포인터입니다. 이것은 HV *를 반환 할 때 refcount를 적절하게 감소시키는 T_HVREF의 고정 변형입니다. perl 5.15.4에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="65032422ec42df48f1031883e99a8b1b19f04fbb" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl subroutine (e.g. $sub = sub { 1 };). From the C level this is a pointer to a CV.</source>
          <target state="translated">perl 레벨에서 이것은 perl 서브 루틴에 대한 참조입니다 (예 : $ sub = sub {1};). C 레벨에서 이것은 CV에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="5b7e3054d443080121c5abde91b6e93c7323ccbd" translate="yes" xml:space="preserve">
          <source>From the shell, saying</source>
          <target state="translated">껍질에서</target>
        </trans-unit>
        <trans-unit id="856c187ed12caf89813ef33a23ce9aead8f27ac1" translate="yes" xml:space="preserve">
          <source>From the viewpoint of parsing, lexical variable scope and closures,</source>
          <target state="translated">구문 분석, 어휘 변수 범위 및 클로저 관점에서</target>
        </trans-unit>
        <trans-unit id="c5f6042fc1cf780179e4cf386ecd882f23297382" translate="yes" xml:space="preserve">
          <source>From then on, you use the &lt;code&gt;maketext&lt;/code&gt; function to access entries in whatever lexicon(s) belong to the language handle you got. So, this:</source>
          <target state="translated">그런 다음 &lt;code&gt;maketext&lt;/code&gt; 함수를 사용하여 사용 하는 언어 핸들에 속하는 어휘집에있는 항목에 액세스합니다. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="cb76778ecb1d96c51a66d0bba753022fa7deeffa" translate="yes" xml:space="preserve">
          <source>From there we can get more complex. If the hash values are the same, we can provide a secondary sort on the hash key.</source>
          <target state="translated">거기에서 우리는 더 복잡해질 수 있습니다. 해시 값이 동일하면 해시 키에 대한 보조 정렬을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be6cd2dadd81d9d30843c2caf56c66b7990b6773" translate="yes" xml:space="preserve">
          <source>From this version on the typical SCM (software configuration management) directories are ignored. These are: RCS, CVS, SCCS, .svn, .hg, .git, .sync</source>
          <target state="translated">이 버전에서는 일반적인 SCM (소프트웨어 구성 관리) 디렉토리가 무시됩니다. RCS, CVS, SCCS, .svn, .hg, .git, .sync</target>
        </trans-unit>
        <trans-unit id="71c8fee3496d71438c7692e0f92208858f4356f7" translate="yes" xml:space="preserve">
          <source>From this, we can see that the date column stretches from column 1 to column 10 - ten characters wide. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;-ese for &quot;character&quot; is &lt;code&gt;A&lt;/code&gt; , and ten of them are &lt;code&gt;A10&lt;/code&gt; . So if we just wanted to extract the dates, we could say this:</source>
          <target state="translated">이를 통해 날짜 열이 열 1에서 열 10-10 자로 확장됨을 알 수 있습니다. &quot;character&quot; 의 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; - ese는 &lt;code&gt;A&lt;/code&gt; 이고 10 개는 &lt;code&gt;A10&lt;/code&gt; 입니다. 따라서 날짜를 추출하고 싶다면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d91e5e8ffd6992838dcbb57817947850fffcf4" translate="yes" xml:space="preserve">
          <source>From time to time, we may mark language constructs and features which we consider to have been mistakes as &lt;b&gt;discouraged&lt;/b&gt;. Discouraged features aren't currently candidates for removal, but we may later deprecate them if they're found to stand in the way of a significant improvement to the Perl core.</source>
          <target state="translated">때때로 실수로 간주되는 언어 구성과 기능을 &lt;b&gt;낙담&lt;/b&gt; 으로 표시 할 수 있습니다 . 권장 기능은 현재 제거 대상이 아니지만 나중에 Perl 코어가 크게 개선되는 것으로 밝혀지면 사용이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="593b03925f9977503d5df5613ab598e54813e4e2" translate="yes" xml:space="preserve">
          <source>Full Listing of Core Typemaps</source>
          <target state="translated">코어 타입 맵의 전체 목록</target>
        </trans-unit>
        <trans-unit id="d09e10be00d851e0182ce329905088abb2292e7d" translate="yes" xml:space="preserve">
          <source>Full path to the file that contains the module</source>
          <target state="translated">모듈이 포함 된 파일의 전체 경로</target>
        </trans-unit>
        <trans-unit id="fa7054d0e0a5e06ed1cc20f1f072c76f977dd60d" translate="yes" xml:space="preserve">
          <source>Full-Text Searching in Perl</source>
          <target state="translated">Perl에서 전체 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="d52b0f8730cd0cb1d50429fd4e409ebd2910fe3a" translate="yes" xml:space="preserve">
          <source>Full-fledged support for I/O layers is now implemented provided Perl is configured to use PerlIO as its IO system (which is now the default).</source>
          <target state="translated">Perl이 IO 시스템 (현재는 기본값)으로 PerlIO를 사용하도록 구성된 경우 I / O 계층에 대한 완벽한 지원이 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="950f94e743e045d06f1163691f50c811b3f47b68" translate="yes" xml:space="preserve">
          <source>Fully build and test the Perl distribution. Make sure that no tests are failing with &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;aout_test&lt;/code&gt; targets; fix the bugs in Perl and the Perl test suite detected by these tests. Make sure that &lt;code&gt;all_test&lt;/code&gt; make target runs as clean as possible. Check that</source>
          <target state="translated">Perl 배포판을 완전히 빌드하고 테스트하십시오. &lt;code&gt;test&lt;/code&gt; 및 &lt;code&gt;aout_test&lt;/code&gt; 대상에서 실패한 테스트가 없는지 확인하십시오 . 이 테스트에서 감지 된 Perl 및 Perl 테스트 스위트의 버그를 수정하십시오. &lt;code&gt;all_test&lt;/code&gt; 가 대상을 최대한 깨끗하게 실행 해야 합니다. 확인</target>
        </trans-unit>
        <trans-unit id="f1bfa995d978ef3acade5580113154220abfa2db" translate="yes" xml:space="preserve">
          <source>Fully install Perl, including &lt;code&gt;installcmd&lt;/code&gt; target. Copy the generated DLLs to &lt;code&gt;LIBPATH&lt;/code&gt; ; copy the numbered Perl executables (as in</source>
          <target state="translated">&lt;code&gt;installcmd&lt;/code&gt; 대상을 포함하여 Perl을 완전히 설치하십시오 . 생성 된 DLL을 &lt;code&gt;LIBPATH&lt;/code&gt; 에 복사 하십시오 . 번호가 매겨진 Perl 실행 파일 복사</target>
        </trans-unit>
        <trans-unit id="1ca8ebe0f337f78ac7630965aa7b6d0b1fa91b13" translate="yes" xml:space="preserve">
          <source>Fully qualified name of currently executing subroutine.</source>
          <target state="translated">현재 실행중인 서브 루틴의 완전한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4e532a9d21737b951917e92fa5d156c715111a5d" translate="yes" xml:space="preserve">
          <source>Fully qualified subroutine names are also supported. For example,</source>
          <target state="translated">완전한 서브 루틴 이름도 지원됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7135f28e774ac1a9fabb4c75a3d1bb1ada58e29b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;DumpArray()&lt;/code&gt; allows dumping of multiple values (useful when you need to analyze returns of functions).</source>
          <target state="translated">함수 &lt;code&gt;DumpArray()&lt;/code&gt; 사용하면 여러 값을 덤프 할 수 있습니다 ( 함수의 반환 값을 분석해야 할 때 유용함).</target>
        </trans-unit>
        <trans-unit id="5d11bb00bc4644e08a9be122f115fe39fdd04b5f" translate="yes" xml:space="preserve">
          <source>Function Interface</source>
          <target state="translated">기능 인터페이스</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91de2ff9bd67512188b1968893d91c44f301c251" translate="yes" xml:space="preserve">
          <source>Function and method names seem to work best as all lowercase. E.g., &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; .</source>
          <target state="translated">함수와 메소드 이름은 모두 소문자로 가장 잘 작동하는 것 같습니다. 예를 들어 &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c032df1ce97ecae06d159792d2c62e3c02159e83" translate="yes" xml:space="preserve">
          <source>Function and method names seem to work best as all lowercase. e.g., &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; .</source>
          <target state="translated">함수와 메소드 이름은 모두 소문자로 가장 잘 작동하는 것 같습니다. 예를 들어 &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7563cdfec9156bd4ab2730b5c15af3243697fb62" translate="yes" xml:space="preserve">
          <source>Function called by &lt;code&gt;do_readline&lt;/code&gt; to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses &lt;code&gt;File::Glob&lt;/code&gt; this glob starter is only used by miniperl during the build process. Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.</source>
          <target state="translated">glob를 생성하기 위해 &lt;code&gt;do_readline&lt;/code&gt; 에 의해 호출되는 함수 (또는 VMS에서 perl 내부의 glob 수행). 이 코드는 인라인으로 사용되었지만 이제 perl은 &lt;code&gt;File::Glob&lt;/code&gt; 사용합니다. 이 glob 스타터는 빌드 프로세스 중 miniperl에서만 사용됩니다. 멀리 옮기면 pp_hot.c가 줄어 듭니다. pp_hot.c를 줄이면 펄 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="9280dd949d70767204a52eb0931da78deffc83d9" translate="yes" xml:space="preserve">
          <source>Function must be called with an already existing SV like</source>
          <target state="translated">기존 SV와 같은 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c163bb94cadf4c0b267646fb2499c8ab2b33874" translate="yes" xml:space="preserve">
          <source>Function pointer, pointing at a function used to handle extended keywords. The function should be declared as</source>
          <target state="translated">확장 키워드를 처리하는 데 사용되는 함수를 가리키는 함수 포인터 함수는 다음과 같이 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="280143fbedd7265a424b9acd0af7c98a66e476a6" translate="yes" xml:space="preserve">
          <source>Functional Interface</source>
          <target state="translated">기능성 인터페이스</target>
        </trans-unit>
        <trans-unit id="7def83b37bed0c4a472856ea76a2171ece16649f" translate="yes" xml:space="preserve">
          <source>Functional style</source>
          <target state="translated">기능적 스타일</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1c61e24efc6706988ce877b75d28b4c69b714a46" translate="yes" xml:space="preserve">
          <source>Functions Returning &lt;code&gt;B::OP&lt;/code&gt; objects or for walking op trees</source>
          <target state="translated">&lt;code&gt;B::OP&lt;/code&gt; 객체를 반환 하거나 op 트리를 걷기위한 함수</target>
        </trans-unit>
        <trans-unit id="32ee6f99309a14456cfb212326be3dca1a77b910" translate="yes" xml:space="preserve">
          <source>Functions Returning &lt;code&gt;B::SV&lt;/code&gt; , &lt;code&gt;B::AV&lt;/code&gt; , &lt;code&gt;B::HV&lt;/code&gt; , and &lt;code&gt;B::CV&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;B::SV&lt;/code&gt; , &lt;code&gt;B::AV&lt;/code&gt; , &lt;code&gt;B::HV&lt;/code&gt; 및 &lt;code&gt;B::CV&lt;/code&gt; 객체를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="854549ed50f6375d5b5e7597bbf2e5898d7693ff" translate="yes" xml:space="preserve">
          <source>Functions Returning B::OP objects or for walking op trees</source>
          <target state="translated">B :: OP 객체를 반환하거나 op 트리를 걷기위한 함수</target>
        </trans-unit>
        <trans-unit id="19372f8fa99b3b7135ba966c21643aafea9c2467" translate="yes" xml:space="preserve">
          <source>Functions Returning B::SV, B::AV, B::HV, and B::CV objects</source>
          <target state="translated">B :: SV, B :: AV, B :: HV 및 B :: CV 객체를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="d40a33bf3fa3ed923717e0c5ea11d6e647e8b77a" translate="yes" xml:space="preserve">
          <source>Functions and Attributes</source>
          <target state="translated">기능과 속성</target>
        </trans-unit>
        <trans-unit id="5348c5a5b62cd5dc86c5b99972e10885f9a1a5b3" translate="yes" xml:space="preserve">
          <source>Functions called in list context are assumed to have failed if they return an empty list, or a list consisting only of a single undef element.</source>
          <target state="translated">리스트 컨텍스트에서 호출 된 함수는 빈리스트 또는 단일 undef 요소로만 구성된리스트를 리턴하면 실패한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6c4c388285c500f1aeb8119de16be0528856e0bc" translate="yes" xml:space="preserve">
          <source>Functions for Examining the Symbol Table</source>
          <target state="translated">심벌 테이블 검사 기능</target>
        </trans-unit>
        <trans-unit id="7759ffd239fd25b45ca1d91bf1c8ce464ea7bb64" translate="yes" xml:space="preserve">
          <source>Functions for dealing with RFC3066-style language tags</source>
          <target state="translated">RFC3066 스타일 언어 태그 처리 기능</target>
        </trans-unit>
        <trans-unit id="88e6ab13b92c2e1e7592687e44e6735c69ae3aad" translate="yes" xml:space="preserve">
          <source>Functions to support Perl's traditional &quot;fast&quot; access to the buffer.</source>
          <target state="translated">버퍼에 대한 Perl의 전통적인 &quot;빠른&quot;액세스를 지원하는 기능.</target>
        </trans-unit>
        <trans-unit id="f616156f7ca62c9f603c623fae3a49e7426583da" translate="yes" xml:space="preserve">
          <source>Functions with a prototype of &lt;code&gt;()&lt;/code&gt; are potential candidates for inlining. If the result after optimization and constant folding is either a constant or a lexically-scoped scalar which has no other references, then it will be used in place of function calls made without &lt;code&gt;&amp;amp;&lt;/code&gt; . Calls made using &lt;code&gt;&amp;amp;&lt;/code&gt; are never inlined. (See</source>
          <target state="translated">프로토 타입이 &lt;code&gt;()&lt;/code&gt; 인 함수 는 인라인 가능성이 있습니다. 최적화 및 상수 폴딩 후 결과가 다른 참조가없는 상수 또는 어휘 범위 스칼라 인 경우 &lt;code&gt;&amp;amp;&lt;/code&gt; 없이 수행 된 함수 호출 대신 사용됩니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하여 한 통화는 인라인되지 않습니다. (보다</target>
        </trans-unit>
        <trans-unit id="052d8ad81d99f33b2eb06e6d194282b8675fb201" translate="yes" xml:space="preserve">
          <source>Fundamentals</source>
          <target state="translated">Fundamentals</target>
        </trans-unit>
        <trans-unit id="a9d8d1b8ae4349b8a01d7c63e451fd799a9b7f8b" translate="yes" xml:space="preserve">
          <source>Funnies Section</source>
          <target state="translated">퍼니 섹션</target>
        </trans-unit>
        <trans-unit id="04c4c0235c4dcde402f292623ee26bd9ccce865c" translate="yes" xml:space="preserve">
          <source>Further Resources</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="a4850790bffd17894b4ec0822c491be3c4610fd3" translate="yes" xml:space="preserve">
          <source>Further examples of process-scope changes include &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; and changing uids and gids.</source>
          <target state="translated">프로세스 범위 변경의 추가 예에는 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; 및 변경 uid 및 gid가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5e8e4bbb1cbc5567f472983c6110b377f52c0cca" translate="yes" xml:space="preserve">
          <source>Further reading can be found using the modules and links below.</source>
          <target state="translated">자세한 내용은 아래 모듈 및 링크를 사용하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0759b489099f7e983a5855b98b07fd1e2ddbe3" translate="yes" xml:space="preserve">
          <source>Further, the first element in a range never needs adjustment, as the adjustment would be just adding 0.</source>
          <target state="translated">또한 조정에 0을 추가하기 때문에 범위의 첫 번째 요소를 조정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33028254f3093deff3764d716f328fa4ad9e5425" translate="yes" xml:space="preserve">
          <source>Further:</source>
          <target state="translated">Further:</target>
        </trans-unit>
        <trans-unit id="a080bfabfc41a91686c46efc096f30ef4fbf522d" translate="yes" xml:space="preserve">
          <source>Furthermore, Perl inspects the operands of logical operators to decide whether to use smartmatching for each one by applying the above test to the operands:</source>
          <target state="translated">또한 Perl은 논리 연산자의 피연산자를 검사하여 위의 테스트를 피연산자에 적용하여 각각에 대해 스마트 매칭을 사용할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="51adfdfc6e30f15b7ff308a0a13705b1d26d399a" translate="yes" xml:space="preserve">
          <source>Furthermore, don't forget the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in there, as &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $kv (%hash) {}&lt;/code&gt; iterates over the keys and values, and is generally not useful ($kv would be a key, then a value, and so on).</source>
          <target state="translated">또한, 잊지 마세요 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 거기에, &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $kv (%hash) {}&lt;/code&gt; 키와 값 반복 할 때, 일반적으로 유용하지 않습니다를 ($ KV은 다음 키, 값 등이 될 것이다) .</target>
        </trans-unit>
        <trans-unit id="db93480872e46ff5e0a7c8f5556d4345f41eef53" translate="yes" xml:space="preserve">
          <source>Furthermore, even if you have enabled this feature to be compiled, you need to enable it in runtime with an environment variable: &lt;code&gt;PERL_C_BACKTRACE_ON_ERROR=10&lt;/code&gt; . It must be an integer higher than zero, telling the desired frame count.</source>
          <target state="translated">또한이 기능을 컴파일하도록 설정 한 경우에도 환경 변수 &lt;code&gt;PERL_C_BACKTRACE_ON_ERROR=10&lt;/code&gt; 으로 런타임에 활성화해야합니다 . 원하는 프레임 수를 알려주는 0보다 큰 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="79dbf7bed4736677573eda1bcecd5ea72126d919" translate="yes" xml:space="preserve">
          <source>Furthermore, for doing normal I/O you might need these:</source>
          <target state="translated">또한 정상적인 I / O를 수행하려면 다음이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48cc69c08fdaa003e83ba71f62025b569c3f16f4" translate="yes" xml:space="preserve">
          <source>Furthermore, ftp uris only support anonymous connections, so no named user/password pair can be passed along.</source>
          <target state="translated">또한 ftp uris는 익명 연결 만 지원하므로 명명 된 사용자 / 암호 쌍을 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="524b0aff95e7ba2007348850646d7ceb43e068a9" translate="yes" xml:space="preserve">
          <source>Furthermore, remember that this caveat also applies to fork(), which is emulated by threads on Win32.</source>
          <target state="translated">또한이 경고는 fork ()에도 적용되며 이는 Win32의 스레드에 의해 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d309a10ab62a5f76770beb2bdc55a4d79f7053a2" translate="yes" xml:space="preserve">
          <source>Furthermore, some evil vendors will claim 1003.1 compliance, but in fact are not so: they will not pass the PCTS (POSIX Compliance Test Suites). For example, one vendor may not define &lt;code&gt;EDEADLK&lt;/code&gt; , or the semantics of the errno values set by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(2)&lt;/a&gt;&lt;/code&gt; might not be quite right. Perl does not attempt to verify POSIX compliance. That means you can currently successfully say &quot;use POSIX&quot;, and then later in your program you find that your vendor has been lax and there's no usable &lt;code&gt;ICANON&lt;/code&gt; macro after all. This could be construed to be a bug.</source>
          <target state="translated">또한 일부 악의적 인 공급 업체는 1003.1 준수를 주장하지만 실제로는 그렇지 않습니다. PCTS (POSIX 준수 테스트 스위트)를 통과하지 못합니다. 예를 들어, 한 공급 업체가 &lt;code&gt;EDEADLK&lt;/code&gt; 를 정의하지 않거나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(2)&lt;/a&gt;&lt;/code&gt; 의해 설정된 errno 값의 의미 가 올바르지 않을 수 있습니다. Perl은 POSIX 준수 확인을 시도하지 않습니다. 즉, 현재 &quot;POSIX 사용&quot;이라고 말하면 나중에 프로그램에서 공급 업체가 느슨하고 사용 가능한 &lt;code&gt;ICANON&lt;/code&gt; 매크로 가 없다는 것을 알 수 있습니다. 이것은 버그로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13d4a69739d0088cb136cc4c16c74a337aabc059" translate="yes" xml:space="preserve">
          <source>Furthermore, special values, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;prenormalized&quot;&lt;/code&gt; , can be used, though they are not concerned with &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 와 관련이 없지만 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&quot;prenormalized&quot;&lt;/code&gt; 특수 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a481ff3ccbda516b9f33c8d20b42f50467089ec" translate="yes" xml:space="preserve">
          <source>Furthermore, when called from within the DB package in list context, and with an argument, caller returns more detailed information: it sets the list variable &lt;code&gt;@DB::args&lt;/code&gt; to be the arguments with which the subroutine was invoked.</source>
          <target state="translated">또한리스트 컨텍스트의 DB 패키지 내에서 그리고 인수를 사용하여 호출하면 더 자세한 정보를 리턴합니다. 호출자는리스트 변수 &lt;code&gt;@DB::args&lt;/code&gt; 를 서브 루틴이 호출 된 인수로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="3f058db7875f38874b1a8c89b542a4bd6a932573" translate="yes" xml:space="preserve">
          <source>Furthermore, you should make sure that during &lt;code&gt;make test&lt;/code&gt; you do not have any GNU tool packages in your path: some toolkits like Unixutils include some tools (&lt;code&gt;type&lt;/code&gt; for instance) which override the Windows ones and makes tests fail. Remove them from your path while testing to avoid these errors.</source>
          <target state="translated">또한 &lt;code&gt;make test&lt;/code&gt; 중에 경로에 GNU 도구 패키지가 없는지 확인해야 합니다. Unixutils와 같은 일부 도구 키트에는 Windows 도구 를 무시하고 테스트에 실패하는 일부 도구 ( 예 : &lt;code&gt;type&lt;/code&gt; )가 포함되어 있습니다. 이러한 오류를 피하기 위해 테스트하는 동안 경로에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d46735054f3a821c36d8dc0e38be2dc8069424e8" translate="yes" xml:space="preserve">
          <source>Future Plans and PERL_IMPLICIT_SYS</source>
          <target state="translated">향후 계획 및 PERL_IMPLICIT_SYS</target>
        </trans-unit>
        <trans-unit id="3da52a1809c9844f72a921784eef8acaa0a30f71" translate="yes" xml:space="preserve">
          <source>Future versions of Test::Builder will have a way to turn history off.</source>
          <target state="translated">Test :: Builder의 이후 버전에서는 히스토리를 끌 수있는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51696f9d78549516d07f8c451e43127c08733e4f" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may add additional commands.</source>
          <target state="translated">이 사양의 이후 버전에서는 추가 명령이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca223e70a348b74c3e34848e1279271aecf5c237" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may add additional formatting codes.</source>
          <target state="translated">이 사양의 이후 버전에서는 추가 형식 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="258ec93021438421e3c2a77885ab95a5bc2085a3" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may specify how Pod can accept other encodings. Presumably treatment of other encodings in Pod parsing would be as in XML parsing: whatever the encoding declared by a particular Pod file, content is to be stored in memory as Unicode characters.</source>
          <target state="translated">이 사양의 이후 버전에서는 포드에서 다른 인코딩을 허용하는 방법을 지정할 수 있습니다. 아마도 포드 파싱에서 다른 인코딩을 처리하는 것은 XML 파싱에서와 같이 처리 될 것입니다. 특정 포드 파일에 의해 선언 된 인코딩이 무엇이든 컨텐츠는 메모리에 유니 코드 문자로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="349a5bc532bd3c593d57694baf4470fa82e87c0e" translate="yes" xml:space="preserve">
          <source>GAMESRVR.DLL</source>
          <target state="translated">GAMESRVR.DLL</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="0ba6cc1e2d0d56ce9630a0f34e6f5f991c2e2104" translate="yes" xml:space="preserve">
          <source>GCC gcov Profiling</source>
          <target state="translated">GCC gcov 프로파일 링</target>
        </trans-unit>
        <trans-unit id="3f0f4dcc948d6cb707fe551e6eeba47a39180607" translate="yes" xml:space="preserve">
          <source>GCC/mingw32 support was added in 5.005 (Nick Ing-Simmons).</source>
          <target state="translated">GCC / mingw32 지원은 5.005 (Nick Ing-Simmons)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="33a96db7f69918beb1bb533b8df7e3de1b7deb54" translate="yes" xml:space="preserve">
          <source>GDBM and Threads on HP-UX</source>
          <target state="translated">HP-UX의 GDBM 및 스레드</target>
        </trans-unit>
        <trans-unit id="905e76d37d3d8721076484b8d01762ed235eeb6a" translate="yes" xml:space="preserve">
          <source>GDBM is available for Cygwin.</source>
          <target state="translated">Cygwin에 GDBM을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae00d8f3134d79b137732c9cb7f102d8f0802921" translate="yes" xml:space="preserve">
          <source>GENERAL GUIDELINES</source>
          <target state="translated">일반 지침</target>
        </trans-unit>
        <trans-unit id="3b652c3125ece0a5e5b4b20d19c89323f6ee9348" translate="yes" xml:space="preserve">
          <source>GETTING HELP</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="cd86c073f225f3fdc6eca764a69478ae8ba27649" translate="yes" xml:space="preserve">
          <source>GETTING THE PERL SOURCE</source>
          <target state="translated">펄 소스 얻기</target>
        </trans-unit>
        <trans-unit id="d957a2be14a1b162437963fe1ed8dc23e8a068b0" translate="yes" xml:space="preserve">
          <source>GIT DATA</source>
          <target state="translated">GIT 데이터</target>
        </trans-unit>
        <trans-unit id="bf98dc1a3b408b3c50c0a64164f6cbb372e44595" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLES</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="f25bdd9f8631b9874b5643e6065c3d9abb3ebbf0" translate="yes" xml:space="preserve">
          <source>GLOSSARY</source>
          <target state="translated">GLOSSARY</target>
        </trans-unit>
        <trans-unit id="edd4b1d28d6fabbd459aa39cee2bc60f4dc2cacf" translate="yes" xml:space="preserve">
          <source>GNU &lt;code&gt;info&lt;/code&gt; files</source>
          <target state="translated">GNU &lt;code&gt;info&lt;/code&gt; 파일</target>
        </trans-unit>
        <trans-unit id="9d091b9a5e4c37cafcd83a2e7be1ecc3c772330b" translate="yes" xml:space="preserve">
          <source>GNU C Library documentation on syslog, &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&quot;&gt;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 GNU C 라이브러리 설명서, &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&quot;&gt;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f329865e118f755d9ae2897c3d1036d691b75a09" translate="yes" xml:space="preserve">
          <source>GNU Tar authors have expressed their intention to become completely POSIX-compatible; &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;&gt;http://www.gnu.org/software/tar/manual/html_node/Formats.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">GNU Tar 저자들은 POSIX와 완벽하게 호환 될 의사를 표명했습니다. &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;&gt;http://www.gnu.org/software/tar/manual/html_node/Formats.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b96a59e926131797b97a5280ca47b763871d9867" translate="yes" xml:space="preserve">
          <source>GNU as and GNU ld</source>
          <target state="translated">GNU as 및 GNU ld</target>
        </trans-unit>
        <trans-unit id="ffac9623e4fbfd01208662e12093c3420e35fe08" translate="yes" xml:space="preserve">
          <source>GNU info files</source>
          <target state="translated">GNU 정보 파일</target>
        </trans-unit>
        <trans-unit id="a602c9a5bb16737d2d0e6f0af42d0ffbca2fd496" translate="yes" xml:space="preserve">
          <source>GNU make for OS/390, which is recommended for the build of perl (as well as building CPAN modules and extensions), is available from the &lt;a href=&quot;#Tools&quot;&gt;Tools&lt;/a&gt;.</source>
          <target state="translated">perl 빌드 (CPAN 모듈 및 확장 빌드)에 권장되는 OS / 390 용 GNU make는 &lt;a href=&quot;#Tools&quot;&gt;Tools&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e95dc9b959dea83d9c2c4412bad8dbf6a30b36" translate="yes" xml:space="preserve">
          <source>GNV$UNIX_SHELL</source>
          <target state="translated">GNV$UNIX_SHELL</target>
        </trans-unit>
        <trans-unit id="d7332b9fd2e3b51ce3e0b297993ed332c301d3b1" translate="yes" xml:space="preserve">
          <source>GOODIES</source>
          <target state="translated">GOODIES</target>
        </trans-unit>
        <trans-unit id="5c3f2689267efedfd1b8d32a4de8ae076b08ae19" translate="yes" xml:space="preserve">
          <source>GOTCHAS</source>
          <target state="translated">GOTCHAS</target>
        </trans-unit>
        <trans-unit id="fe0ce1b835b0b5932a5c8ab2b59f416e1e42dc46" translate="yes" xml:space="preserve">
          <source>GOVERNANCE</source>
          <target state="translated">GOVERNANCE</target>
        </trans-unit>
        <trans-unit id="a0dce8feda03c8a60940891df8a100aa6d34a49e" translate="yes" xml:space="preserve">
          <source>GREAT CIRCLE DISTANCES AND DIRECTIONS</source>
          <target state="translated">훌륭한 순환 거리 및 방향</target>
        </trans-unit>
        <trans-unit id="f33d85ab379fda0c05941052326738c9fe2a1ea5" translate="yes" xml:space="preserve">
          <source>GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII, control character ranges and other parts are mapped very differently, mainly to store Greek characters. There are also escape sequences (starting with 0x1B) to cover e.g. the Euro sign.</source>
          <target state="translated">GSM0338은 GSM 핸드셋 용입니다. ASCII와 영숫자를 공유하지만 제어 문자 범위와 다른 부분은 주로 그리스 문자를 저장하기 위해 매우 다르게 매핑됩니다. 유로 기호와 같은 이스케이프 시퀀스 (0x1B로 시작)도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0cf065d2bd69adbe2ec92fa3feabfd7bf3b9886" translate="yes" xml:space="preserve">
          <source>GUI editor written in Perl using wxWidgets and Scintilla with lots of smaller features. Aims for a UI based on Perl principles like TIMTOWTDI and &quot;easy things should be easy, hard things should be possible&quot;.</source>
          <target state="translated">많은 작은 기능을 갖춘 wxWidgets 및 Scintilla를 사용하여 Perl로 작성된 GUI 편집기. TIMTOWTDI와 같은 Perl 원칙을 기반으로하는 UI를 목표로하고 &quot;쉬운 것은 쉬워야하며 어려운 것은 가능해야합니다&quot;.</target>
        </trans-unit>
        <trans-unit id="8e8d08c08351d6aca5a776c4b8922b52fb3e13e8" translate="yes" xml:space="preserve">
          <source>GUIs</source>
          <target state="translated">GUIs</target>
        </trans-unit>
        <trans-unit id="65f937109da9f4d01ac30946e434018e19ee2dcd" translate="yes" xml:space="preserve">
          <source>GUTS</source>
          <target state="translated">GUTS</target>
        </trans-unit>
        <trans-unit id="870b564576a2966c189631c03afc2f57fdfb6686" translate="yes" xml:space="preserve">
          <source>GV Functions</source>
          <target state="translated">GV 기능</target>
        </trans-unit>
        <trans-unit id="e717e9026bec8b632428e734dfdc5a2ec21c2f4d" translate="yes" xml:space="preserve">
          <source>GV_SUPER indicates that we want to look up the method in the superclasses of the &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">GV_SUPER는 &lt;code&gt;stash&lt;/code&gt; 의 수퍼 클래스에서 메소드를 검색하려고 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="93253898f4f199634af1de90ddc5528b941ce169" translate="yes" xml:space="preserve">
          <source>GVs are usually found as values in stashes (symbol table hashes) where Perl stores its global variables.</source>
          <target state="translated">GV는 일반적으로 Perl이 전역 변수를 저장하는 스 태쉬 (기호 테이블 해시)의 값으로 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="da99bf684e2839f1607c7a6984181f3b8083a1e7" translate="yes" xml:space="preserve">
          <source>GZIP INTERFACE</source>
          <target state="translated">GZIP 인터페이스</target>
        </trans-unit>
        <trans-unit id="cb13f819c9cca26bbe274d82fa237ae5e6a86319" translate="yes" xml:space="preserve">
          <source>G_ARRAY</source>
          <target state="translated">G_ARRAY</target>
        </trans-unit>
        <trans-unit id="c9afb596821a60db6f147bb13345cb27d6cd8acd" translate="yes" xml:space="preserve">
          <source>G_DISCARD</source>
          <target state="translated">G_DISCARD</target>
        </trans-unit>
        <trans-unit id="7c0c17b4a676352405579500514e68a451e3e0e0" translate="yes" xml:space="preserve">
          <source>G_EVAL</source>
          <target state="translated">G_EVAL</target>
        </trans-unit>
        <trans-unit id="336b3ba483f4b583d3b8e432539a535eec3195ef" translate="yes" xml:space="preserve">
          <source>G_KEEPERR</source>
          <target state="translated">G_KEEPERR</target>
        </trans-unit>
        <trans-unit id="0d759ade2aa36ab678fa55030c3ec31bde1a4c30" translate="yes" xml:space="preserve">
          <source>G_NOARGS</source>
          <target state="translated">G_NOARGS</target>
        </trans-unit>
        <trans-unit id="f4700a48056cc6ff4268baa6339552754ce5bf82" translate="yes" xml:space="preserve">
          <source>G_SCALAR</source>
          <target state="translated">G_SCALAR</target>
        </trans-unit>
        <trans-unit id="ad1ccfc7340540dee07e8608d1a88363df56cc05" translate="yes" xml:space="preserve">
          <source>G_VOID</source>
          <target state="translated">G_VOID</target>
        </trans-unit>
        <trans-unit id="7a9bbda071163c5693883e06db98012930631d19" translate="yes" xml:space="preserve">
          <source>Garbage collection can be confusing when keys are created in a field hash from normal scalars as well as references. Once a reference is</source>
          <target state="translated">가비지 콜렉션은 참조뿐만 아니라 일반 스칼라에서 필드 해시로 키를 작성할 때 혼동 될 수 있습니다. 일단 참조가</target>
        </trans-unit>
        <trans-unit id="fc30f25cde3aea2004fdaffc34ec529a477f5957" translate="yes" xml:space="preserve">
          <source>Garbage collection in a field hash means that entries will &quot;spontaneously&quot; disappear when the object that created them disappears. That must be borne in mind, especially when looping over a field hash. If anything you do inside the loop could cause an object to go out of scope, a random key may be deleted from the hash you are looping over. That can throw the loop iterator, so it's best to cache a consistent snapshot of the keys and/or values and loop over that. You will still have to check that a cached entry still exists when you get to it.</source>
          <target state="translated">필드 해시에서 가비지 콜렉션은 항목을 작성한 오브젝트가 사라지면 항목이 &quot;자발적으로&quot;사라진다는 것을 의미합니다. 특히 필드 해시를 반복 할 때 명심해야합니다. 루프 내부에서 수행하는 작업으로 인해 객체가 범위를 벗어나는 경우 임의의 키가 반복되는 해시에서 삭제 될 수 있습니다. 루프 반복자를 던질 수 있으므로 키 및 / 또는 값의 일관된 스냅 샷을 캐시하고 반복하는 것이 가장 좋습니다. 캐시 된 항목이 도착해도 여전히 존재하는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc5702bf94c050f203b549ef0c85e9b81b70dad0" translate="yes" xml:space="preserve">
          <source>Garbage-Collected Hashes</source>
          <target state="translated">쓰레기 수집 해시</target>
        </trans-unit>
        <trans-unit id="2ec6ebf4fdb8455b53f8d6215ef9f6363a9f9d67" translate="yes" xml:space="preserve">
          <source>Gather package and POD information from perl module files</source>
          <target state="translated">Perl 모듈 파일에서 패키지 및 POD 정보 수집</target>
        </trans-unit>
        <trans-unit id="ff0ce44a9b44893e7937aae11d3bb72fdbd54b73" translate="yes" xml:space="preserve">
          <source>Gathered below are notes describing details of Perl 5's behavior on VMS. They are a supplement to the regular Perl 5 documentation, so we have focussed on the ways in which Perl 5 functions differently under VMS than it does under Unix, and on the interactions between Perl and the rest of the operating system. We haven't tried to duplicate complete descriptions of Perl features from the main Perl documentation, which can be found in the</source>
          <target state="translated">VMS에서 Perl 5의 동작에 대한 세부 사항을 설명하는 참고 사항이 아래에 수집되어 있습니다. 그것들은 일반적인 Perl 5 문서를 보완하기 때문에 우리는 Perl 5가 Unix에서와 다른 방식으로 VMS에서 다르게 작동하는 방식과 Perl과 나머지 운영 체제 간의 상호 작용에 중점을 두었습니다. 주요 Perl 문서에서 Perl 기능에 대한 완전한 설명을 복제하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b4330768b6cbb368cf11bfc2a1aa3b4b4975bf79" translate="yes" xml:space="preserve">
          <source>Gathers meta data about the &lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt; source, stashes it in &lt;a href=&quot;#meta&quot;&gt;meta&lt;/a&gt; and returns it as a hashref. This is done so that the &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s don't have to repeat common checks. Currently this includes:</source>
          <target state="translated">&lt;a href=&quot;#raw&quot;&gt;원시&lt;/a&gt; 소스 에 대한 메타 데이터를 수집 하여 &lt;a href=&quot;#meta&quot;&gt;메타에 보관&lt;/a&gt; 하고 해시 참조로 반환합니다. 이것은 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 가 일반적인 검사를 반복 할 필요가 없도록하기위한 것입니다. 현재 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0a7877a5c7bf9a390ddf2644ce8f01d2dd749296" translate="yes" xml:space="preserve">
          <source>Gee, yet another template code - as if we hadn't plenty. But &lt;code&gt;@&lt;/code&gt; saves our day by enabling us to specify the offset from the beginning of the pack buffer to the next item: This is just the value the &lt;code&gt;offsetof&lt;/code&gt; macro (defined in &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ) returns when given a &lt;code&gt;struct&lt;/code&gt; type and one of its field names (&quot;member-designator&quot; in C standardese).</source>
          <target state="translated">Gee, 또 다른 템플릿 코드-마치 우리가 충분하지 않은 것처럼. 그러나 &lt;code&gt;@&lt;/code&gt; 는 팩 버퍼의 시작부터 다음 항목까지의 오프셋을 지정하여 하루를 절약합니다. 이것은 &lt;code&gt;struct&lt;/code&gt; 유형과 다음 중 하나가 주어질 때 &lt;code&gt;offsetof&lt;/code&gt; 매크로 ( &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 에 정의 됨 )가 반환 하는 값 입니다. 필드 이름 (C 표준의 &quot;멤버 지정자&quot;).</target>
        </trans-unit>
        <trans-unit id="7264840e686c65159ebed179560079a997c941c5" translate="yes" xml:space="preserve">
          <source>General 32-bit vs. 64-bit issues.</source>
          <target state="translated">일반적인 32 비트 및 64 비트 문제</target>
        </trans-unit>
        <trans-unit id="0b01c727a71003b8392c50d5e2ddffdc179cdf34" translate="yes" xml:space="preserve">
          <source>General Notes</source>
          <target state="translated">일반 사항</target>
        </trans-unit>
        <trans-unit id="7bafdc805eb49ade4dcc8f1b7c25df23aa8d76e7" translate="yes" xml:space="preserve">
          <source>General Perl style guide</source>
          <target state="translated">일반 펄 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="c4a42d220d26c466f9dbb535a2b1b9eda4a1fde7" translate="yes" xml:space="preserve">
          <source>General Thread Utility Routines</source>
          <target state="translated">일반 스레드 유틸리티 루틴</target>
        </trans-unit>
        <trans-unit id="faddfc843ac71019b3393df672837907ac7bbcab" translate="yes" xml:space="preserve">
          <source>General Variables</source>
          <target state="translated">일반 변수</target>
        </trans-unit>
        <trans-unit id="f183e804ff54f5c70fea1801cabc1af8c1ecfaeb" translate="yes" xml:space="preserve">
          <source>General behaviour in list contexts</source>
          <target state="translated">목록 컨텍스트의 일반적인 동작</target>
        </trans-unit>
        <trans-unit id="c3adf35af62fa854c8d064fa3f4201bca217f3c3" translate="yes" xml:space="preserve">
          <source>General behaviour in scalar and void contexts</source>
          <target state="translated">스칼라 및 공백 컨텍스트의 일반적인 동작</target>
        </trans-unit>
        <trans-unit id="f87d868ae9e6c5e095ed3921aff5b72a01552118" translate="yes" xml:space="preserve">
          <source>General examples:</source>
          <target state="translated">일반적인 예 :</target>
        </trans-unit>
        <trans-unit id="1fa7d4327fa3fac797d2494a8dbdc1859972a516" translate="yes" xml:space="preserve">
          <source>General explanations on cross-compiling WinCE</source>
          <target state="translated">크로스 컴파일 WinCE에 대한 일반적인 설명</target>
        </trans-unit>
        <trans-unit id="93ab49617e74fefea30381e0a0b013db01a2c54c" translate="yes" xml:space="preserve">
          <source>General tools</source>
          <target state="translated">일반 도구</target>
        </trans-unit>
        <trans-unit id="bc589851c4083a051730b622221b86c22bbd8a1c" translate="yes" xml:space="preserve">
          <source>Generalized quotes. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일반화 된 따옴표. &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c176de14201d5eb9a9b50ccc11298ef3cd109ef6" translate="yes" xml:space="preserve">
          <source>Generalized quotes. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일반화 된 따옴표. &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop의 인용 부호 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad57f21ae3c6ac53ed83e3da2f741a3990c73305" translate="yes" xml:space="preserve">
          <source>Generally anything not exported is still accessible from outside the module using the &lt;code&gt;YourModule::item_name&lt;/code&gt; (or &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) syntax. By convention you can use a leading underscore on names to informally indicate that they are 'internal' and not for public use.</source>
          <target state="translated">일반적으로 내 보내지 않은 것은 &lt;code&gt;YourModule::item_name&lt;/code&gt; (또는 &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) 구문을 사용하여 모듈 외부에서 여전히 액세스 할 수 있습니다 . 규칙에 따라 이름에 밑줄을 사용하여 '내부'이며 공개적으로 사용되지 않음을 비공식적으로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cc2c98f271588e14fc9b40a4be695fc7549ee7" translate="yes" xml:space="preserve">
          <source>Generally anything not exported is still accessible from outside the module using the ModuleName::item_name (or &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) syntax. By convention you can use a leading underscore on names to indicate informally that they are 'internal' and not for public use.</source>
          <target state="translated">일반적으로 내 보내지 않은 것은 ModuleName :: item_name (또는 &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) 구문을 사용하여 모듈 외부에서 여전히 액세스 할 수 있습니다 . 관례에 따라 이름에 밑줄을 사용하여 '내부'이며 대중 용이 아님을 비공식적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1fe2ca53692f111e8f5344d4ee32097c8e139d1" translate="yes" xml:space="preserve">
          <source>Generally one only needs to call the &lt;code&gt;WriteConstants&lt;/code&gt; function, and then</source>
          <target state="translated">일반적으로 &lt;code&gt;WriteConstants&lt;/code&gt; 함수 만 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="327b665fa95397f25e3867f7836460cb799d0a0c" translate="yes" xml:space="preserve">
          <source>Generally used in a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block at the end of a loop to clear variables and reset &lt;code&gt;??&lt;/code&gt; searches so that they work again. The expression is interpreted as a list of single characters (hyphens allowed for ranges). All variables and arrays beginning with one of those letters are reset to their pristine state. If the expression is omitted, one-match searches (&lt;code&gt;?pattern?&lt;/code&gt; ) are reset to match again. Only resets variables or searches in the current package. Always returns 1. Examples:</source>
          <target state="translated">일반적으로 변수를 지우고 재설정하기 위해 루프 끝의 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록에 사용됩니다 &lt;code&gt;??&lt;/code&gt; 다시 작동하도록 검색합니다. 표현식은 단일 문자 목록으로 해석됩니다 (범위에 허용되는 하이픈). 해당 문자 중 하나로 시작하는 모든 변수 및 배열은 원래 상태로 재설정됩니다. 표현식이 생략되면, 단일 일치 검색 ( &lt;code&gt;?pattern?&lt;/code&gt; )이 다시 일치하도록 재설정됩니다. 현재 패키지에서 변수 또는 검색 만 재설정합니다. 항상 1을 반환합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6ed5d2aaf3ce44a61b56b98845df66b1842be7d7" translate="yes" xml:space="preserve">
          <source>Generally used in a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block at the end of a loop to clear variables and reset &lt;code&gt;??&lt;/code&gt; searches so that they work again. The expression is interpreted as a list of single characters (hyphens allowed for ranges). All variables and arrays beginning with one of those letters are reset to their pristine state. If the expression is omitted, one-match searches (&lt;code&gt;?pattern?&lt;/code&gt; ) are reset to match again. Only resets variables or searches in the current package. Always returns 1. Examples:</source>
          <target state="translated">일반적으로 변수를 지우고 재설정하기 위해 루프 끝의 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록에 사용됩니다 &lt;code&gt;??&lt;/code&gt; 다시 작동하도록 검색합니다. 표현식은 단일 문자 목록으로 해석됩니다 (범위에 허용되는 하이픈). 해당 문자 중 하나로 시작하는 모든 변수 및 배열은 원래 상태로 재설정됩니다. 표현식이 생략되면, 단일 일치 검색 ( &lt;code&gt;?pattern?&lt;/code&gt; )이 다시 일치하도록 재설정됩니다. 현재 패키지에서 변수 또는 검색 만 재설정합니다. 항상 1을 반환합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0d7b613cee2366987a969166247d56f35fe8603c" translate="yes" xml:space="preserve">
          <source>Generally, a collection of procedures. In ancient days, referred to a collection of subroutines in a</source>
          <target state="translated">일반적으로 절차 모음. 고대에는 서브 루틴 모음을</target>
        </trans-unit>
        <trans-unit id="f3328c5ae4397dc3c4222ba39a73bb9ae82f5a28" translate="yes" xml:space="preserve">
          <source>Generally, any &lt;b&gt;token&lt;/b&gt; or &lt;b&gt;metasymbol&lt;/b&gt;. Often used more specifically to mean the sort of name you might find in a &lt;b&gt;symbol table&lt;/b&gt;.</source>
          <target state="translated">일반적으로, 어떤은 &lt;b&gt;토큰&lt;/b&gt; 또는 &lt;b&gt;metasymbol&lt;/b&gt; . &lt;b&gt;심볼 테이블&lt;/b&gt; 에서 찾을 수있는 이름의 종류를 의미하기 위해보다 구체적으로 사용되는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="b4a6c168526aaa7b030a8b864e61338267716f45" translate="yes" xml:space="preserve">
          <source>Generally, each argument has one leading &quot;:&quot; and one trailing &quot;:&quot; removed (if any). They are then joined together by a &quot;:&quot;. Special treatment applies for arguments denoting updir paths like &quot;::lib:&quot;, see (4), or arguments consisting solely of colons (&quot;colon paths&quot;), see (5).</source>
          <target state="translated">일반적으로 각 인수에는 하나의 선행 &quot;:&quot;과 하나의 후행 &quot;:&quot;이 제거됩니다 (있는 경우). 그런 다음 &quot;:&quot;로 연결됩니다. &quot;:: lib :&quot;와 같은 updir 경로를 나타내는 인수, (4) 참조 또는 콜론 ( &quot;콜론 경로&quot;)만으로 구성된 인수, (5) 참조에는 특별한 처리가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbca80a0f1b382deb6a1f5ce103056435b9b61d1" translate="yes" xml:space="preserve">
          <source>Generally, if you want to store an undefined value in an AV or HV, you should not use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , but rather create a new undefined value using the &lt;code&gt;newSV&lt;/code&gt; function, for example:</source>
          <target state="translated">일반적으로 AV 또는 HV에 정의되지 않은 값을 저장하려면 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 사용하지 말고 &lt;code&gt;newSV&lt;/code&gt; 함수를 사용하여 새 정의되지 않은 값을 작성하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7888dab6e27a5d395183c226ba655dd95d81794" translate="yes" xml:space="preserve">
          <source>Generate C code for XS modules' constants.</source>
          <target state="translated">XS 모듈 상수에 대한 C 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="55b679a0cfa0771f77ea49b9d53b6db25d85485e" translate="yes" xml:space="preserve">
          <source>Generate C/C++ code for the XS initializer function.</source>
          <target state="translated">XS 이니셜 라이저 기능을위한 C / C ++ 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="6d7a20114b9e2f4adde607a7de6cdc77812cd5c3" translate="yes" xml:space="preserve">
          <source>Generate MYMETA information as a hash either from an existing CPAN Meta file (META.json or META.yml) or from internal data.</source>
          <target state="translated">기존 CPAN 메타 파일 (META.json 또는 META.yml) 또는 내부 데이터에서 MYMETA 정보를 해시로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="fad9ff08051acbfd579989fe7d09533be58fc8b2" translate="yes" xml:space="preserve">
          <source>Generate XS code to import C header constants</source>
          <target state="translated">C 헤더 상수를 가져 오는 XS 코드 생성</target>
        </trans-unit>
        <trans-unit id="cf1ca662ada637e9d6d3c74e2b646acad00573f4" translate="yes" xml:space="preserve">
          <source>Generate a summary file called</source>
          <target state="translated">라는 요약 파일 생성</target>
        </trans-unit>
        <trans-unit id="a58e7b39e158d6f21c17511a146b04839f328ccd" translate="yes" xml:space="preserve">
          <source>Generate an accessor method for each element of structs and unions. The generated methods are named after the element name; will return the current value of the element if called without additional arguments; and will set the element to the supplied value (and return the new value) if called with an additional argument. Embedded structures and unions are returned as a pointer rather than the complete structure, to facilitate chained calls.</source>
          <target state="translated">구조체와 공용체의 각 요소에 대한 접근 자 메서드를 생성하십시오. 생성 된 메소드는 요소 이름을 따라 이름이 지정됩니다. 추가 인수없이 호출되면 요소의 현재 값을 반환합니다. 추가 인수로 호출하면 요소를 제공된 값으로 설정하고 새 값을 반환합니다. 임베디드 구조 및 공용체는 체인 호출을 용이하게하기 위해 완전한 구조가 아닌 포인터로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="37ce6c2156457df8501e4c1fb83210aa39acfaeb" translate="yes" xml:space="preserve">
          <source>Generate an index at the top of the HTML file (default behaviour).</source>
          <target state="translated">HTML 파일 맨 위에 색인을 생성하십시오 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="da1068fe142a5298b63a98d32acd80f4a76500cb" translate="yes" xml:space="preserve">
          <source>Generate an index at the top of the HTML file. This is the default behaviour.</source>
          <target state="translated">HTML 파일 맨 위에 색인을 생성하십시오. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="255b7210c6594b83b698aa3fb4e69e8ff01d426e" translate="yes" xml:space="preserve">
          <source>Generate and return a fresh cop hints hash containing no entries.</source>
          <target state="translated">항목이없는 새로운 경찰 힌트 해시를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d85a3b5f2926e3396853e594219b817c7146a9d2" translate="yes" xml:space="preserve">
          <source>Generate stubs for a SelfLoading module</source>
          <target state="translated">자체로드 모듈에 대한 스텁 생성</target>
        </trans-unit>
        <trans-unit id="0ba19194216be13c7f866968bcf3a987117cf5e8" translate="yes" xml:space="preserve">
          <source>Generate test reports if CPAN::Reporter is installed (yes/no)?</source>
          <target state="translated">CPAN :: Reporter가 설치된 경우 테스트 보고서를 생성합니까 (예 / 아니오)?</target>
        </trans-unit>
        <trans-unit id="548e0abe962fe7973873ce7fe29b5c45581f9fb6" translate="yes" xml:space="preserve">
          <source>Generate the Makefile and run make. Change the test number in Mytest.t to &quot;9&quot; and add the following tests:</source>
          <target state="translated">Makefile을 생성하고 make를 실행하십시오. Mytest.t의 테스트 번호를 &quot;9&quot;로 변경하고 다음 테스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2e30a1f598292d25659b6f3a250f216bc967e7e7" translate="yes" xml:space="preserve">
          <source>Generate the default target 'all'.</source>
          <target state="translated">기본 대상 'all'을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4d962473f477d6b33e6a92b907153b952636d0f9" translate="yes" xml:space="preserve">
          <source>Generate the metafile target.</source>
          <target state="translated">메타 파일 대상을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4db92d1f5198cc69e763847675b8fcf87ee5935e" translate="yes" xml:space="preserve">
          <source>Generate the signature target.</source>
          <target state="translated">서명 대상을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="de5fc6d42feef255045834472628eb831eead292" translate="yes" xml:space="preserve">
          <source>Generated internally. Is zero or undefined if name is 7 bit ASCII, &quot;no&quot; if the name is 8 bit (and so should only match if SvUTF8() is false), &quot;yes&quot; if the name is utf8 encoded.</source>
          <target state="translated">내부적으로 생성됩니다. 이름이 7 비트 ASCII 인 경우 0 또는 정의되지 않음, 이름이 8 비트 인 경우 &quot;no&quot;(SvUTF8 ()이 false 인 경우에만 일치해야 함), 이름이 utf8로 인코딩 된 경우 &quot;yes&quot;</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="c167e00e247a5f64156fc2c863e8097c40ce0f9e" translate="yes" xml:space="preserve">
          <source>Generates Foo__Bar.3 style man page names</source>
          <target state="translated">Foo__Bar.3 스타일 매뉴얼 페이지 이름을 생성합니다</target>
        </trans-unit>
        <trans-unit id="43bc892fe6a292ae97df44de7203d863e807362e" translate="yes" xml:space="preserve">
          <source>Generates a .pm file which is backwards compatible with the specified perl version.</source>
          <target state="translated">지정된 perl 버전과 호환되는 .pm 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e7c963d48f673cb2a0857ed31de8d6aa72aa362b" translate="yes" xml:space="preserve">
          <source>Generates a make fragment defining all the macros initialized in init_dist.</source>
          <target state="translated">init_dist에서 초기화 된 모든 매크로를 정의하는 make 조각을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17a9c3599652e9b94156636fc524075142b2c6bc" translate="yes" xml:space="preserve">
          <source>Generates a set of @commands which print the $text to a $file.</source>
          <target state="translated">$ text를 $ file에 인쇄하는 일련의 @command를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="790a5b36d77c0cf3beb51e493e823c8123ef2b5c" translate="yes" xml:space="preserve">
          <source>Generates and returns a &lt;code&gt;HV *&lt;/code&gt; representing the content of a &lt;code&gt;refcounted_he&lt;/code&gt; chain.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; 체인 의 내용을 나타내는 &lt;code&gt;HV *&lt;/code&gt; 를 생성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bcbbd96d2dbbc6700210cc4fb74779eab56f16fe" translate="yes" xml:space="preserve">
          <source>Generates and returns a standard Perl hash representing the full set of hint entries in the cop</source>
          <target state="translated">경찰의 전체 힌트 항목 세트를 나타내는 표준 Perl 해시를 생성하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1421406c3adcfc5c7625f4edebffbd408bd80ab6" translate="yes" xml:space="preserve">
          <source>Generates and returns a standard Perl hash representing the full set of key/value pairs in the cop hints hash</source>
          <target state="translated">경찰 힌트 해시의 전체 키 / 값 쌍 세트를 나타내는 표준 Perl 해시를 생성하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="855ea3ad4660369a0d200ca547e9d16bbf1aed26" translate="yes" xml:space="preserve">
          <source>Generates cross reference reports for Perl programs</source>
          <target state="translated">Perl 프로그램에 대한 상호 참조 보고서를 생성합니다</target>
        </trans-unit>
        <trans-unit id="e3de133c1c2ce09b6435425a01ca3e82f3c58065" translate="yes" xml:space="preserve">
          <source>Generates one copy of</source>
          <target state="translated">하나의 사본을 생성합니다</target>
        </trans-unit>
        <trans-unit id="1d207670d95f5fc2643606a3d629315363ac612b" translate="yes" xml:space="preserve">
          <source>Generates one fewer copies of</source>
          <target state="translated">하나의 적은 사본을 생성합니다</target>
        </trans-unit>
        <trans-unit id="28d7a6917a623daf227d101d7b6ed8834cb89f78" translate="yes" xml:space="preserve">
          <source>Generates prototype code for all xsubs. Default is false.</source>
          <target state="translated">모든 xsub에 대한 프로토 타입 코드를 생성합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="2960b94d28c15d7a694d51b3079b6bc63fbdd48f" translate="yes" xml:space="preserve">
          <source>Generates targets to create the specified directories and set its permission to PERM_DIR.</source>
          <target state="translated">지정된 디렉토리를 작성하고 해당 권한을 PERM_DIR로 설정하기위한 대상을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d6e4b3f200d78c6e8a91d9d2272c0f5fb9f6e05c" translate="yes" xml:space="preserve">
          <source>Generates the distmeta target to add META.yml and META.json to the MANIFEST in the distdir.</source>
          <target state="translated">distdir의 MANIFEST에 META.yml 및 META.json을 추가하기 위해 distmeta 대상을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b310c6f5942ab86898d599d13d2e861f310c17d2" translate="yes" xml:space="preserve">
          <source>Generates the distsignature target to add SIGNATURE to the MANIFEST in the distdir.</source>
          <target state="translated">distdir의 MANIFEST에 SIGNATURE를 추가하기 위해 distsignature 대상을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3730e292a86874c44122818bef743a546bb5f8f3" translate="yes" xml:space="preserve">
          <source>Generates the manifypods target. This target generates man pages from all POD files in MAN1PODS and MAN3PODS.</source>
          <target state="translated">manifypods 대상을 생성합니다. 이 대상은 MAN1PODS 및 MAN3PODS의 모든 POD 파일에서 매뉴얼 페이지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="91c589b5a085cc257f1fe2c1088920f6a3260335" translate="yes" xml:space="preserve">
          <source>Generates the path name for the controlling terminal.</source>
          <target state="translated">제어 터미널의 경로 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="aa78442f98d8c0e48e911fd577f2432ab2e641a7" translate="yes" xml:space="preserve">
          <source>Generates the value of</source>
          <target state="translated">의 가치를 생성</target>
        </trans-unit>
        <trans-unit id="b08e002657b5f8d224393deee9469ccf8c547be4" translate="yes" xml:space="preserve">
          <source>Generating Combined Tags</source>
          <target state="translated">결합 된 태그 생성</target>
        </trans-unit>
        <trans-unit id="2a21214ce61b2e34bac827b1129511447eeb1d87" translate="yes" xml:space="preserve">
          <source>Generating the Makefile and running &lt;code&gt;make&lt;/code&gt; created a directory called blib (which stands for &quot;build library&quot;) in the current working directory. This directory will contain the shared library that we will build. Once we have tested it, we can install it into its final location.</source>
          <target state="translated">메이크 파일을 생성하고 실행 &lt;code&gt;make&lt;/code&gt; 현재 작업 디렉토리 ( &quot;빌드 라이브러리&quot;의 약자)라는 디렉토리의 정교를 만들었습니다. 이 디렉토리에는 빌드 할 공유 라이브러리가 포함됩니다. 테스트를 마치면 최종 위치에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb265528826c32e783457930a0be091d852e5fb2" translate="yes" xml:space="preserve">
          <source>Generating this fatal compile error is one of the main advantages of using the constants interface, since you'll immediately know if you mistype a color name.</source>
          <target state="translated">이 치명적인 컴파일 오류를 생성하는 것은 상수 인터페이스를 사용하는 주요 이점 중 하나입니다. 색상 이름을 잘못 입력하면 즉시 알 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="94d49b2add1a84693cb6f6742d43aadc63779926" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF ARRAYS</source>
          <target state="translated">해시 생성</target>
        </trans-unit>
        <trans-unit id="b10605adc6dd4bbb3891b18fa40d3ef6fd2660e3" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF COMPLEX RECORDS</source>
          <target state="translated">복잡한 기록의 해시 생성</target>
        </trans-unit>
        <trans-unit id="c99d686abb8c25c079ecc27374e7ae409f23b172" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF HASHES</source>
          <target state="translated">해시 해시 생성</target>
        </trans-unit>
        <trans-unit id="a9893d509c65cb98b9af7180a27be528798c38c2" translate="yes" xml:space="preserve">
          <source>Generation of an ARRAY OF ARRAYS</source>
          <target state="translated">배열의 배열 생성</target>
        </trans-unit>
        <trans-unit id="36fe3d03032c0fb4a7e4a93e553c5c4b5ad3dfa9" translate="yes" xml:space="preserve">
          <source>Generation of an ARRAY OF HASHES</source>
          <target state="translated">해시 배열 생성</target>
        </trans-unit>
        <trans-unit id="812c1b37318e9ec5939e34ef662accc038427024" translate="yes" xml:space="preserve">
          <source>Generic interface to Perl Compiler backends</source>
          <target state="translated">Perl Compiler 백엔드에 대한 일반 인터페이스</target>
        </trans-unit>
        <trans-unit id="bc3a1464aaf3caaf7316afc754a4e8005c14f861" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;REMOTE_FILE&lt;/code&gt; from the server and store locally. &lt;code&gt;LOCAL_FILE&lt;/code&gt; may be a filename or a filehandle. If not specified, the file will be stored in the current directory with the same leafname as the remote file.</source>
          <target state="translated">서버에서 &lt;code&gt;REMOTE_FILE&lt;/code&gt; 을 가져와 로컬에 저장하십시오. &lt;code&gt;LOCAL_FILE&lt;/code&gt; 은 파일 이름 또는 파일 핸들 일 수 있습니다. 지정하지 않으면 파일은 원격 파일과 동일한 리프 이름으로 현재 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d0dc372b2e257044afda97bb0f77031c7a35e177" translate="yes" xml:space="preserve">
          <source>Get a directory listing of &lt;code&gt;DIR&lt;/code&gt; , or the current directory in long format.</source>
          <target state="translated">&lt;code&gt;DIR&lt;/code&gt; 의 디렉토리 목록 또는 긴 형식의 현재 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7ec34cee796d547d14608ac7cf6e0f3edbd159c0" translate="yes" xml:space="preserve">
          <source>Get a directory listing of &lt;code&gt;DIR&lt;/code&gt; , or the current directory.</source>
          <target state="translated">&lt;code&gt;DIR&lt;/code&gt; 의 디렉토리 목록 또는 현재 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="374636ae19b296dfea98703295aaecfbdd2c1a97" translate="yes" xml:space="preserve">
          <source>Get a line from the filehandle and store it into the SV, optionally appending to the currently-stored string. If &lt;code&gt;append&lt;/code&gt; is not 0, the line is appended to the SV instead of overwriting it. &lt;code&gt;append&lt;/code&gt; should be set to the byte offset that the appended string should start at in the SV (typically, &lt;code&gt;SvCUR(sv)&lt;/code&gt; is a suitable choice).</source>
          <target state="translated">파일 핸들에서 한 줄을 가져와 SV에 저장하고 선택적으로 현재 저장된 문자열에 추가합니다. 경우 &lt;code&gt;append&lt;/code&gt; 0이 아닌 라인은 덮어 대신 SV에 추가된다. &lt;code&gt;append&lt;/code&gt; 는 추가 된 문자열이 SV에서 시작해야하는 바이트 오프셋으로 설정되어야합니다 (일반적으로 &lt;code&gt;SvCUR(sv)&lt;/code&gt; 가 적합합니다).</target>
        </trans-unit>
        <trans-unit id="c598cea0161d91f18f52f5688b3c025ff94ad39c" translate="yes" xml:space="preserve">
          <source>Get a list of all remaining tests.</source>
          <target state="translated">남은 모든 테스트 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="63a593cb77f2c61ac75772edd049eee1d24e24f8" translate="yes" xml:space="preserve">
          <source>Get a list of all the currently enabled pragmas:</source>
          <target state="translated">현재 활성화 된 모든 pragma 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7b7cd7f6b002e314d08f78b71b5b591a4f70ba81" translate="yes" xml:space="preserve">
          <source>Get a login for the Perl Authors Upload Server (PAUSE) if you don't already have one: &lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;</source>
          <target state="translated">아직 Perl Authors Upload Server (PAUSE)에 로그인하지 않은 경우 &lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5bbade2b6657ae3b6cb3e4431498e73906ee530" translate="yes" xml:space="preserve">
          <source>Get a sensible string out of the SV somehow. A private implementation of the &lt;code&gt;SvPV_force&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">어떻게 든 SV에서 현명한 문자열을 얻으십시오. 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 &lt;code&gt;SvPV_force&lt;/code&gt; 매크로 의 개인 구현 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64dbc32740e54d691c9e2c5cda1ba05449ef3105" translate="yes" xml:space="preserve">
          <source>Get a sensible string out of the SV somehow. If &lt;code&gt;flags&lt;/code&gt; has &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate, else not. &lt;code&gt;sv_pvn_force&lt;/code&gt; and &lt;code&gt;sv_pvn_force_nomg&lt;/code&gt; are implemented in terms of this function. You normally want to use the various wrapper macros instead: see &lt;code&gt;SvPV_force&lt;/code&gt; and &lt;code&gt;SvPV_force_nomg&lt;/code&gt;</source>
          <target state="translated">어떻게 든 SV에서 현명한 문자열을 얻으십시오. 경우 &lt;code&gt;flags&lt;/code&gt; 가 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당하는 경우, 다른 없습니다. &lt;code&gt;sv_pvn_force&lt;/code&gt; 및 &lt;code&gt;sv_pvn_force_nomg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다. 일반적으로 다양한 래퍼 매크로를 대신 사용하려고합니다. &lt;code&gt;SvPV_force&lt;/code&gt; 및 &lt;code&gt;SvPV_force_nomg&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7220eec11b9f4342ece5e624c0e6dd46adeb9c" translate="yes" xml:space="preserve">
          <source>Get a single character</source>
          <target state="translated">하나의 문자를 얻을</target>
        </trans-unit>
        <trans-unit id="b607b471bd641ae0bad56d53e93561f4a5dcc663" translate="yes" xml:space="preserve">
          <source>Get a single word describing the status of the aggregated tests. Depending on the outcome of the tests returns 'PASS', 'FAIL' or 'NOTESTS'. This token is understood by &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Reporter&quot;&gt;CPAN::Reporter&lt;/a&gt;.</source>
          <target state="translated">집계 된 테스트의 상태를 설명하는 단일 단어를 가져옵니다. 테스트 결과에 따라 'PASS', 'FAIL'또는 'NOTESTS'가 반환됩니다. 이 토큰은 &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Reporter&quot;&gt;CPAN :: Reporter에&lt;/a&gt; 의해 이해됩니다 .</target>
        </trans-unit>
        <trans-unit id="94e908780575d3c7b13c6f58aed85812783fe4af" translate="yes" xml:space="preserve">
          <source>Get all remaining lines from the file. It will croak() if accidentally called in a scalar context.</source>
          <target state="translated">파일에서 나머지 줄을 모두 가져옵니다. 실수로 스칼라 컨텍스트에서 호출되면 croak ()됩니다.</target>
        </trans-unit>
        <trans-unit id="aed3f8067239d43cc5fd9e2c71aefda5e7ddcfa2" translate="yes" xml:space="preserve">
          <source>Get an a list of file handles which can be passed to &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; to determine the readiness of this parser.</source>
          <target state="translated">에 전달 될 수있는 파일 핸들의 목록 가져 오기 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 이 파서의 준비 상태를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="57c71ad46ac7b3fc7bffe5d8abfd2437d2bcda85" translate="yes" xml:space="preserve">
          <source>Get an array of descriptions in the order in which they were added to the aggregator.</source>
          <target state="translated">애그리 게이터에 추가 된 순서대로 설명 배열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4fd330b00e5fd43c7facb1ce40b15978badf9d49" translate="yes" xml:space="preserve">
          <source>Get current value of extended library search path. If &lt;code&gt;type&lt;/code&gt; is present and positive, works with &lt;code&gt;END_LIBPATH&lt;/code&gt; , if negative, works with &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; , otherwise with &lt;code&gt;BEGIN_LIBPATH&lt;/code&gt; .</source>
          <target state="translated">확장 라이브러리 검색 경로의 현재 값을 가져옵니다. 경우 &lt;code&gt;type&lt;/code&gt; 존재하고 긍정적으로 작동 &lt;code&gt;END_LIBPATH&lt;/code&gt; 부정적인와 함께 작동하는 경우, &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 그렇지 않은 경우로, &lt;code&gt;BEGIN_LIBPATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00cf4729c08b5fcd57e241d25d2cbdeb99dcc776" translate="yes" xml:space="preserve">
          <source>Get feedback before publishing</source>
          <target state="translated">게시하기 전에 피드백 받기</target>
        </trans-unit>
        <trans-unit id="7db8371110606460ae544aa3da9ce0f0de1a1f3f" translate="yes" xml:space="preserve">
          <source>Get file status. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; . The data returned is identical to the data from Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">파일 상태를 가져옵니다. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 . 반환 된 데이터는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 함수 의 데이터와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fa68e261aa81f581b5a90ba1e9bfd725ef59d405" translate="yes" xml:space="preserve">
          <source>Get name of current operating system.</source>
          <target state="translated">현재 운영 체제의 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="689e6ea9037095052aff1101fdfdc680b6e214b0" translate="yes" xml:space="preserve">
          <source>Get numeric formatting information. Returns a reference to a hash containing the current underlying locale's formatting values. Users of this function should also read &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;, which provides a comprehensive discussion of Perl locale handling, including &lt;a href=&quot;perllocale#The-localeconv-function&quot;&gt;a section devoted to this function&lt;/a&gt;.</source>
          <target state="translated">숫자 서식 정보를 얻습니다. 현재 기본 로케일의 서식 값이 포함 된 해시에 대한 참조를 리턴합니다. 이 함수의 사용자는 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 읽어야합니다.이 함수는이 함수에 관한 &lt;a href=&quot;perllocale#The-localeconv-function&quot;&gt;섹션을&lt;/a&gt; 포함하여 Perl 로케일 처리에 대한 포괄적 인 토론을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f984cefe527deb4addc8cf500f9c5727ae40d0" translate="yes" xml:space="preserve">
          <source>Get option associated with the socket. Other levels than SOL_SOCKET may be specified here.</source>
          <target state="translated">소켓과 관련된 옵션을 가져옵니다. SOL_SOCKET 이외의 다른 레벨이 여기에 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1c28860360a4fa7e9af6746bedcb431787f46a" translate="yes" xml:space="preserve">
          <source>Get or set a pragma. To get the state of a pragma:</source>
          <target state="translated">pragma를 얻거나 설정하십시오. 프라 그마 상태를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="77c12013a4f3faabdfd45c20cf7f2e5379d28bb4" translate="yes" xml:space="preserve">
          <source>Get or set the list of extensions that files must have in order to be considered tests. Defaults to ['.t'].</source>
          <target state="translated">테스트로 간주하기 위해 파일에 필요한 확장명 목록을 가져 오거나 설정하십시오. 기본값은 [ '.t']입니다.</target>
        </trans-unit>
        <trans-unit id="b3f02dbc79ab20b0a28ad615d9d491d7daece201" translate="yes" xml:space="preserve">
          <source>Get pathname of current working directory</source>
          <target state="translated">현재 작업 디렉토리의 경로 이름 가져 오기</target>
        </trans-unit>
        <trans-unit id="fe08fded31b445465eb024604de34561803ebc20" translate="yes" xml:space="preserve">
          <source>Get terminal control attributes.</source>
          <target state="translated">터미널 제어 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a59623bd1c16560f3bf3b733cb7fef045dc9eb39" translate="yes" xml:space="preserve">
          <source>Get the &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt; module from CPAN.</source>
          <target state="translated">CPAN에서 &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt; 모듈을 받으십시오 .</target>
        </trans-unit>
        <trans-unit id="f445ac9afb3e26b0227b0cd9d1470f0c1289598c" translate="yes" xml:space="preserve">
          <source>Get the &lt;a href=&quot;http://www.cpan.org/modules/by-module/Roman&quot;&gt;http://www.cpan.org/modules/by-module/Roman&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;http://www.cpan.org/modules/by-module/Roman&quot;&gt;http://www.cpan.org/modules/by-module/Roman&lt;/a&gt; 모듈을 받으십시오 .</target>
        </trans-unit>
        <trans-unit id="006addc7b486481a4d34e5ae872451f7b6a5b8f4" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; of a capture variable. There's a special callback for this so that Perl doesn't have to do a FETCH and run &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; on the result, since the length is (in Perl's case) known from an offset stored in &lt;code&gt;rx-&amp;gt;offs&lt;/code&gt; , this is much more efficient:</source>
          <target state="translated">캡처 변수 의 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 가져 옵니다 . 이것에 대한 특별한 콜백이있어서 Perl이 FETCH를 수행 하고 결과에서 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 실행할 필요가 없습니다 . 길이는 ( &lt;code&gt;rx-&amp;gt;offs&lt;/code&gt; 의 경우) rx-&amp;gt; offs에 저장된 오프셋에서 알려져 있기 때문에 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a11deed8b7fb50959590945fa161672220265d44" translate="yes" xml:space="preserve">
          <source>Get the EMX development suite and gzip/tar, from either Hobbes ( &lt;a href=&quot;http://hobbes.nmsu.edu&quot;&gt;http://hobbes.nmsu.edu&lt;/a&gt; ) or Leo ( &lt;a href=&quot;http://www.leo.org&quot;&gt;http://www.leo.org&lt;/a&gt; ), and then follow the instructions for Unix.</source>
          <target state="translated">Hobbes ( &lt;a href=&quot;http://hobbes.nmsu.edu&quot;&gt;http://hobbes.nmsu.edu&lt;/a&gt; ) 또는 Leo ( &lt;a href=&quot;http://www.leo.org&quot;&gt;http://www.leo.org&lt;/a&gt; ) 에서 EMX 개발 스위트 및 gzip / tar을 가져온 다음 Unix의 지시 사항을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="bd4becd7b8dc2161e4cfcda2010cf7c1c881bcda" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator's process.</source>
          <target state="translated">이 반복기 프로세스의 종료 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="84b89fd72831dd053c82f16626d634a48a2598fb" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator. Always returns zero.</source>
          <target state="translated">이 반복자의 종료 상태를 가져옵니다. 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3a54d4a203ed01a0cc006bea81ab1571b475a38" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator. For an array iterator this will always be zero.</source>
          <target state="translated">이 반복자의 종료 상태를 가져옵니다. 배열 반복자의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="133e8c41853aab1cbe28dc6fb07183856dc1f08a" translate="yes" xml:space="preserve">
          <source>Get the header and the first &lt;code&gt;NUMLINES&lt;/code&gt; of the body for the message &lt;code&gt;MSGNUM&lt;/code&gt; . Returns a reference to an array which contains the lines of text read from the server.</source>
          <target state="translated">&lt;code&gt;NUMLINES&lt;/code&gt; 메시지에 대한 본문 의 첫 번째 NUMLINES 와 헤더를 &lt;code&gt;MSGNUM&lt;/code&gt; . 서버에서 읽은 텍스트 줄이 포함 된 배열에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a54ca3db20c68a6648a2c8195a312d093894414c" translate="yes" xml:space="preserve">
          <source>Get the login name of the owner of the current process.</source>
          <target state="translated">현재 프로세스 소유자의 로그인 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e120bfbb1d3603fe717d8918b14899076a8087c1" translate="yes" xml:space="preserve">
          <source>Get the message &lt;code&gt;MSGNUM&lt;/code&gt; from the remote mailbox. If &lt;code&gt;FH&lt;/code&gt; is not given then get returns a reference to an array which contains the lines of text read from the server. If &lt;code&gt;FH&lt;/code&gt; is given then the lines returned from the server are printed to the filehandle &lt;code&gt;FH&lt;/code&gt; .</source>
          <target state="translated">원격 사서함에서 &lt;code&gt;MSGNUM&lt;/code&gt; 메시지를 가져 옵니다. 경우 &lt;code&gt;FH&lt;/code&gt; 가 주어지지 않는 한 다음 서버에서 읽을 텍스트의 라인을 포함하는 배열에 대한 참조 수익을 얻을. 경우 &lt;code&gt;FH&lt;/code&gt; 가 지정되고있는 서버에서 반환 된 행은 핸들에 인쇄됩니다 &lt;code&gt;FH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="171a80b6f7c9c9b0de0c2c1387e261c225bb5f1c" translate="yes" xml:space="preserve">
          <source>Get the results of the last test run. Returns a &lt;code&gt;result_class()&lt;/code&gt; instance.</source>
          <target state="translated">마지막 테스트 실행 결과를 얻습니다. &lt;code&gt;result_class()&lt;/code&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="90d44fbd255026683b10ff974054e3d86ff08631" translate="yes" xml:space="preserve">
          <source>Get the shebang line for a script file.</source>
          <target state="translated">스크립트 파일의 shebang 줄을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="697c2b6a1d382211fc2dd0bca44da6d75975210e" translate="yes" xml:space="preserve">
          <source>Get the text content of Pod</source>
          <target state="translated">포드의 텍스트 컨텐츠 가져 오기</target>
        </trans-unit>
        <trans-unit id="8a6470e93add70210e01a18515324d36b81b5961" translate="yes" xml:space="preserve">
          <source>Get the value at offset</source>
          <target state="translated">오프셋 값을 얻습니다</target>
        </trans-unit>
        <trans-unit id="b4b20b8862126ed2accf702e1ec733c901c8db4d" translate="yes" xml:space="preserve">
          <source>Get the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad</source>
          <target state="translated">현재 패드 에서 오프셋 &lt;code&gt;po&lt;/code&gt; 의 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="72cc9b87213c59838a0c486fddb38c60d8bcb990" translate="yes" xml:space="preserve">
          <source>Get the value from slot &lt;code&gt;po&lt;/code&gt; in the base (DEPTH=1) pad of a padlist</source>
          <target state="translated">패드리스트의베이스 (DEPTH = 1) 패드에있는 슬롯 &lt;code&gt;po&lt;/code&gt; 에서 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c15dfba3a3a5eb3e6fb48d7c0b41882c9028755a" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator's process.</source>
          <target state="translated">이 반복자 프로세스의 대기 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a8e5109ddd83023961a33c488ce31369f7a956bb" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator. Always returns zero.</source>
          <target state="translated">이 반복기의 대기 상태를 가져옵니다. 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd379b83821718a59329d33da5c3c07390f8df61" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator. For an array iterator this will always be zero.</source>
          <target state="translated">이 반복기의 대기 상태를 가져옵니다. 배열 반복자의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="3a194d016da71ce2734ee5b70b1ec1fd4e7b2f88" translate="yes" xml:space="preserve">
          <source>Get your book listed</source>
          <target state="translated">당신의 책을 나열하십시오</target>
        </trans-unit>
        <trans-unit id="a862124c43c274d34647a9768c5732fb7edcd167" translate="yes" xml:space="preserve">
          <source>Get/set subroutine or variable attributes</source>
          <target state="translated">서브 루틴 또는 변수 속성 가져 오기 / 설정</target>
        </trans-unit>
        <trans-unit id="d95e69f9c878364f21361c49a01e8572507003e4" translate="yes" xml:space="preserve">
          <source>GetFileContents</source>
          <target state="translated">GetFileContents</target>
        </trans-unit>
        <trans-unit id="0e09541d86291862cd9e2e7048d551c2058e9bb4" translate="yes" xml:space="preserve">
          <source>GetOptions does not return a false result when an option is not supplied</source>
          <target state="translated">옵션이 제공되지 않으면 GetOptions는 잘못된 결과를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87d3b5ae9087dfd036d22e3daee54391ea6d78e7" translate="yes" xml:space="preserve">
          <source>GetOptions does not split the command line correctly</source>
          <target state="translated">GetOptions가 명령 줄을 올바르게 분할하지 않습니다</target>
        </trans-unit>
        <trans-unit id="46612c2fb2a3f4d1528e0cd7f5288c84da4524f8" translate="yes" xml:space="preserve">
          <source>GetOptions returns true to indicate success. It returns false when the function detected one or more errors during option parsing. These errors are signalled using warn() and can be trapped with &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; .</source>
          <target state="translated">GetOptions는 성공을 나타 내기 위해 true를 반환합니다. 옵션 구문 분석 중에 함수가 하나 이상의 오류를 감지하면 false를 리턴합니다. 이 오류는 warn ()을 사용하여 표시되며 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 으로 트랩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b726fe0f0e4cd3ba3741be1513769194ec024e4" translate="yes" xml:space="preserve">
          <source>GetOptions() will not interpret a leading &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; as option starters if the next argument is a reference. To force &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as option starters, use &lt;code&gt;&quot;&amp;gt;&amp;lt;&quot;&lt;/code&gt; . Confusing? Well, &lt;b&gt;using a starter argument is strongly deprecated&lt;/b&gt; anyway.</source>
          <target state="translated">다음 인수가 참조 인 경우 GetOptions ()는 선행 &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; 를 옵션 스타터로 해석하지 않습니다 . &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 를 옵션 스타터로 강제 실행하려면 &lt;code&gt;&quot;&amp;gt;&amp;lt;&quot;&lt;/code&gt; 를 사용하십시오 . 혼란 스러운가? 음, &lt;b&gt;스타터 인수를 사용하여 강력하게되지 않습니다&lt;/b&gt; 어쨌든.</target>
        </trans-unit>
        <trans-unit id="b9732e721546ff2bc7ea74a9d199d6d228afae46" translate="yes" xml:space="preserve">
          <source>GetOptions() will return a true value if the command line could be processed successfully. Otherwise, it will write error messages using die() and warn(), and return a false result.</source>
          <target state="translated">명령 줄을 성공적으로 처리 할 수 ​​있으면 GetOptions ()는 true 값을 반환합니다. 그렇지 않으면 die () 및 warn ()을 사용하여 오류 메시지를 작성하고 잘못된 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3750099056a52cd3d76c09c5969009aae1b2738" translate="yes" xml:space="preserve">
          <source>Getopt::Long</source>
          <target state="translated">Getopt::Long</target>
        </trans-unit>
        <trans-unit id="ee86fdfdf70c8935b9943d5d042784e3c2ea2b52" translate="yes" xml:space="preserve">
          <source>Getopt::Long - Extended processing of command line options</source>
          <target state="translated">Getopt :: Long-확장 된 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="9f1cb7796236a18d5a48dd6147f6ef96a3c237e4" translate="yes" xml:space="preserve">
          <source>Getopt::Long can be configured by calling subroutine Getopt::Long::Configure(). This subroutine takes a list of quoted strings, each specifying a configuration option to be enabled, e.g. &lt;code&gt;ignore_case&lt;/code&gt; , or disabled, e.g. &lt;code&gt;no_ignore_case&lt;/code&gt; . Case does not matter. Multiple calls to Configure() are possible.</source>
          <target state="translated">Getopt :: Long은 서브 루틴 Getopt :: Long :: Configure ()를 호출하여 구성 할 수 있습니다. 이 서브 루틴은 구성 옵션을 지정 각각 예를 들어, 사용 가능하도록 인용 문자열 목록을 소요 &lt;code&gt;ignore_case&lt;/code&gt; 예를 들어, 또는 비활성화 &lt;code&gt;no_ignore_case&lt;/code&gt; . 사건은 중요하지 않습니다. Configure ()를 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e500819062670bf30da6e44490f24a19a2b2b19" translate="yes" xml:space="preserve">
          <source>Getopt::Long can be used in an object oriented way as well:</source>
          <target state="translated">Getopt :: Long은 객체 지향 방식으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc4bf4d0ae35771f0ba93156da87e25f9c34e7d" translate="yes" xml:space="preserve">
          <source>Getopt::Long encourages the use of Pod::Usage to produce help messages. For example:</source>
          <target state="translated">Getopt :: Long은 Pod :: Usage를 사용하여 도움말 메시지를 생성하도록 권장합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2e568fc541602443fba9f2e2602a6ef4699382b" translate="yes" xml:space="preserve">
          <source>Getopt::Long is the Perl5 successor of &lt;code&gt;newgetopt.pl&lt;/code&gt; . This was the first Perl module that provided support for handling the new style of command line options, in particular long option names, hence the Perl5 name Getopt::Long. This module also supports single-character options and bundling.</source>
          <target state="translated">Getopt :: Long은 &lt;code&gt;newgetopt.pl&lt;/code&gt; 의 Perl5 후속 제품입니다 . 이것은 새로운 스타일의 명령 행 옵션, 특히 긴 옵션 이름, 따라서 Perl5 이름 Getopt :: Long 처리를 지원하는 최초의 Perl 모듈이었습니다. 이 모듈은 단일 문자 옵션 및 번들링도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="baeccd76f672aaa366456df8bb56a2d544addefb" translate="yes" xml:space="preserve">
          <source>Getopt::Long is thread safe when using ithreads as of Perl 5.8. It is</source>
          <target state="translated">Getopt :: Long은 Perl 5.8부터 ithread를 사용할 때 스레드로부터 안전합니다. 그것은</target>
        </trans-unit>
        <trans-unit id="0969a40bae8913a7683a1a070a431edeaeab53a5" translate="yes" xml:space="preserve">
          <source>Getopt::Long supports three styles of bundling. To enable bundling, a call to Getopt::Long::Configure is required.</source>
          <target state="translated">Getopt :: Long은 세 가지 스타일의 번들링을 지원합니다. 번들링을 사용하려면 Getopt :: Long :: Configure를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c364d3e4d70b8c945dae76119e75bf89e0b572cc" translate="yes" xml:space="preserve">
          <source>Getopt::Long supports two useful variants of simple options:</source>
          <target state="translated">Getopt :: Long은 간단한 옵션의 두 가지 유용한 변형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="35548099a37e6129ad92eb2599c19e8e81824308" translate="yes" xml:space="preserve">
          <source>Getopt::Long will provide a help message using module &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. The message, derived from the SYNOPSIS POD section, will be written to standard output and processing will terminate.</source>
          <target state="translated">Getopt :: Long은 &lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage&lt;/a&gt; 모듈을 사용하여 도움말 메시지를 제공합니다 . SYNOPSIS POD 섹션에서 파생 된 메시지가 표준 출력에 기록되고 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="23debd03657a7e0cf1c9081bd9b34c843df29188" translate="yes" xml:space="preserve">
          <source>Getopt::Long will provide a standard version message that includes the program name, its version (if $main::VERSION is defined), and the versions of Getopt::Long and Perl. The message will be written to standard output and processing will terminate.</source>
          <target state="translated">Getopt :: Long은 프로그램 이름, 버전 ($ main :: VERSION이 정의 된 경우) 및 Getopt :: Long 및 Perl 버전을 포함하는 표준 버전 메시지를 제공합니다. 메시지가 표준 출력에 기록되고 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="231784d11e2ac3af47374629249969cb6df988d0" translate="yes" xml:space="preserve">
          <source>Getopt::Std</source>
          <target state="translated">Getopt::Std</target>
        </trans-unit>
        <trans-unit id="050f7a7a02c0f512f89945ac517880bcdb5ae514" translate="yes" xml:space="preserve">
          <source>Gets or sets the number of concurrent test runs the harness is handling. By default, this value is 1 -- for parallel testing, this should be set higher.</source>
          <target state="translated">하네스가 처리중인 동시 테스트 실행 수를 가져 오거나 설정합니다. 기본적으로이 값은 1입니다. 병렬 테스트의 경우이 값을 더 높게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="daa629c55c1f0a45358dee6010d69ea52181b0b2" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;mro_isarev&lt;/code&gt; for this class, returned as an arrayref of class names. These are every class that &quot;isa&quot; the given class name, even if the isa relationship is indirect. This is used internally by the MRO code to keep track of method/MRO cache invalidations.</source>
          <target state="translated">이 클래스 의 &lt;code&gt;mro_isarev&lt;/code&gt; 를 가져와 클래스 이름의 arrayref로 반환합니다. 이것들은 isa 관계가 간접적 인 경우에도 주어진 클래스 이름을 &quot;사실&quot;하는 모든 클래스입니다. 이것은 메소드 / MRO 캐시 무효화를 추적하기 위해 MRO 코드에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd14d8ab490abe0a698ffc2511ce53075831cc54" translate="yes" xml:space="preserve">
          <source>Gets/sets the current test number we're on. You usually shouldn't have to set this.</source>
          <target state="translated">현재 테스트중인 테스트 번호를 가져 오거나 설정합니다. 일반적으로 이것을 설정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3706dd8132de9e8897f7e90d7114484c9d4b2bb9" translate="yes" xml:space="preserve">
          <source>Gets/sets the number of tests we expect this test to run and prints out the appropriate headers.</source>
          <target state="translated">이 테스트가 실행될 것으로 예상되는 테스트 수를 가져오고 설정하고 적절한 헤더를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f884a4b1be1eb753e1154cd093d629796012ffc9" translate="yes" xml:space="preserve">
          <source>Getter/setter for frontend object. Method just allows to subclass CPAN.pm.</source>
          <target state="translated">프론트 엔드 객체의 Getter / setter. 메소드는 CPAN.pm의 서브 클래스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1acf2787a8aee315df9ae150576ddc4f44be77a7" translate="yes" xml:space="preserve">
          <source>Getter/setter for the &quot;generation&quot; of the test suite run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">테스트 스위트 실행의 &quot;세대&quot;에 대한 Getter / Setter. 1 세대는 1 (일)이고 다음 세대는 2, 3 등입니다.</target>
        </trans-unit>
        <trans-unit id="df0821c683786b3a185e90a15a8887e90823f964" translate="yes" xml:space="preserve">
          <source>Getter/setter for the instance of the &lt;code&gt;state_class&lt;/code&gt; .</source>
          <target state="translated">게터 /의 인스턴스에 대한 세터 &lt;code&gt;state_class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0a2a42561baa9a96f6b60d628e8035a5add88f" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for maintaining state. This class should either subclass from &lt;code&gt;App::Prove::State&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">상태를 유지하는 데 사용되는 클래스 이름에 대한 Getter / Setter 이 클래스는 &lt;code&gt;App::Prove::State&lt;/code&gt; 서브 클래스 이거나 동일한 인터페이스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5b0e960fe4e828ae0c4af986bdc86fc8e330536" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for tracking test results. This class should either subclass from &lt;code&gt;App::Prove::State::Result&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">테스트 결과 추적에 사용되는 클래스 이름에 대한 Getter / Setter 이 클래스는 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 서브 클래스 이거나 동일한 인터페이스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="eabe8c9a6205eacd9d12103fd632a371642529ec" translate="yes" xml:space="preserve">
          <source>Getter/setter for the time of the test suite run.</source>
          <target state="translated">테스트 스위트 실행 시간에 대한 게터 / 세터.</target>
        </trans-unit>
        <trans-unit id="6796c34d6d781e2d3a0ac04017b688fdbad6d325" translate="yes" xml:space="preserve">
          <source>Getting Started with Getopt::Long</source>
          <target state="translated">Getopt :: Long 시작하기</target>
        </trans-unit>
        <trans-unit id="1252190bfc7e0e95dec199e97b41cd19bd2e58b1" translate="yes" xml:space="preserve">
          <source>Getting changes into a maint branch</source>
          <target state="translated">메인 지점으로 변경하기</target>
        </trans-unit>
        <trans-unit id="36235f076eea8a428b643f4a70d6dbb8c2bed724" translate="yes" xml:space="preserve">
          <source>Getting perl source</source>
          <target state="translated">펄 소스 얻기</target>
        </trans-unit>
        <trans-unit id="dfa7f5176d7ce9da792b1bc4befb42509ca613ce" translate="yes" xml:space="preserve">
          <source>Getting the Perl Source for AmigaOS</source>
          <target state="translated">AmigaOS 용 Perl 소스 얻기</target>
        </trans-unit>
        <trans-unit id="ca13f2cfdfff6452c98f50feff43bb9608b60008" translate="yes" xml:space="preserve">
          <source>Getting the fat out of XSUBs</source>
          <target state="translated">XSUB에서 지방 제거</target>
        </trans-unit>
        <trans-unit id="1e5b964707fd03837f1c6270f09aa1a8d502762e" translate="yes" xml:space="preserve">
          <source>Getting this message indicates that the outcome of the match arguably should have been the opposite of what actually happened. If you think that is the case, you may wish to make the &lt;code&gt;non_unicode&lt;/code&gt; warnings category fatal; if you agree with Perl's decision, you may wish to turn off this category.</source>
          <target state="translated">이 메시지를 얻는 것은 경기 결과가 실제로 일어난 것과 반대 였음을 나타냅니다. 이런 경우라고 생각되면 &lt;code&gt;non_unicode&lt;/code&gt; warnings 범주를 치명적 으로 만들 수 있습니다 . Perl의 결정에 동의하면이 범주를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57b1bd007b42e02300f16d8e99034836448a153" translate="yes" xml:space="preserve">
          <source>Getting your patch accepted</source>
          <target state="translated">패치 승인 받기</target>
        </trans-unit>
        <trans-unit id="80db569e43bb9df0657e208673f0728aa476a744" translate="yes" xml:space="preserve">
          <source>Gigantic thanks to Jarkko Hietaniemi, for agreeing to put this in the core when I hadn't written it yet, and for generally being helpful, supportive, and competent. (Usually the rule is &quot;choose any one.&quot;) Also big thanks to Abhijit Menon-Sen for all of the same things.</source>
          <target state="translated">Jarkko Hietaniemi에게 감사의 말을 전한다. 아직 쓰지 않았을 때이를 핵심에 포함시키고 일반적으로 도움이되고,지지하며, 유능하다. (보통 규칙은 &quot;어느 하나를 선택하는 것&quot;입니다.) 또한 같은 모든 일에 대해 Abhijit Menon-Sen에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="c447f4baf429b1b41a12ae13b0f7bf296acd86b4" translate="yes" xml:space="preserve">
          <source>Gisle Aas &amp;lt;gisle@aas.no&amp;gt;</source>
          <target state="translated">Gisle Aas &amp;lt;gisle@aas.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e2bf29bf784713e55d54fd683f2ddb22d16ebc1e" translate="yes" xml:space="preserve">
          <source>Gisle Aas made a number of improvements to the documentation for 2.07 and his advice and assistance is also greatly appreciated.</source>
          <target state="translated">Gisle Aas는 2.07에 대한 문서를 여러 가지로 개선했으며 그의 조언과 지원 또한 대단히 감사합니다.</target>
        </trans-unit>
        <trans-unit id="d5205d4410276cc0ebead8a23281418d320e5d50" translate="yes" xml:space="preserve">
          <source>Gisle Aas's &quot;illustrated perlguts&quot;, also known as</source>
          <target state="translated">Gisle Aas의 &quot;그림 된 perlguts&quot;</target>
        </trans-unit>
        <trans-unit id="8a1336646a79e293474d5da63f8a9e49f7c504c4" translate="yes" xml:space="preserve">
          <source>Give a seed the pseudorandom number generator, see &lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;.</source>
          <target state="translated">씨앗에 의사 난수 생성기를 제공하십시오 ( &lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="ecbf54e25625127b374bd97fb6bf30d58f7f39f4" translate="yes" xml:space="preserve">
          <source>Give examples of use in your documentation</source>
          <target state="translated">문서에서 사용 예제를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="576b2bd7a5f1aafe83cdf1ff1d6086595bd3253e" translate="yes" xml:space="preserve">
          <source>Give meaningful error messages when a test fails.</source>
          <target state="translated">테스트가 실패하면 의미있는 오류 메시지를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="22362db21ca02fd220365037ef3ce1c3ae84669f" translate="yes" xml:space="preserve">
          <source>Give some example uses of the program or function. Don't skimp; users often find this the most useful part of the documentation. The examples are generally given as verbatim paragraphs.</source>
          <target state="translated">프로그램이나 기능의 사용 예를 제시하십시오. 뛰어 넘지 마십시오. 사용자는 종종이 문서에서 가장 유용한 부분을 찾습니다. 예제는 일반적으로 완전 단락으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="50b41e662ea9282912cd0935127aa4fdcf1ffa2b" translate="yes" xml:space="preserve">
          <source>Give the module a version/issue/release number.</source>
          <target state="translated">모듈에 버전 / 문제 / 릴리스 번호를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="280f5d0aaefd1eefc611f50ae84a5b211fd8c124" translate="yes" xml:space="preserve">
          <source>Given 'tests' and optional 'rules' as input, returns a new &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; object. Each member of &lt;code&gt;@tests&lt;/code&gt; should be either a a test file name, or a two element arrayref, where the first element is a test file name, and the second element is a test description. By default, we'll use the test name as the description.</source>
          <target state="translated">'tests'와 선택적인 'rules'가 입력으로 주어지면 새로운 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 객체를 반환 합니다. &lt;code&gt;@tests&lt;/code&gt; 의 각 멤버는 테스트 파일 이름이거나 두 개의 요소 arrayref 여야합니다. 첫 번째 요소는 테스트 파일 이름이고 두 번째 요소는 테스트 설명입니다. 기본적으로 테스트 이름을 설명으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="88ad438932c9bdde0a7a6699aa6fd02d2661a215" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, returns the value &lt;code&gt;x - n*y&lt;/code&gt; , where &lt;code&gt;n&lt;/code&gt; is the integer closest to &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt;. [C99]</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 가 주어지면 x &lt;code&gt;x - n*y&lt;/code&gt; 값을 반환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt; 에 가장 가까운 정수 입니다. [C99]</target>
        </trans-unit>
        <trans-unit id="4516641ce73c8bc0e4fc5ba5d53992584effc072" translate="yes" xml:space="preserve">
          <source>Given a $parser that's an object of class Pod::Simple::PullParser (or a subclass)...</source>
          <target state="translated">Pod :: Simple :: PullParser (또는 서브 클래스) 클래스의 객체 인 $ parser가 주어진다면 ...</target>
        </trans-unit>
        <trans-unit id="8f7ab85a46c82118f02884a07c3492a612ad0bc1" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, detects what kind of source it is and returns</source>
          <target state="translated">&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source가&lt;/a&gt; 주어지면 소스의 종류를 감지하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b116ea0f536335d3865a0d04bc8e08d1c2acb6e8" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, finds the most suitable &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; to use to create a &lt;a href=&quot;iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; (see &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;). Dies on error.</source>
          <target state="translated">&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source가&lt;/a&gt; 주어지면 &lt;a href=&quot;iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt; 를 작성하는 데 가장 적합한 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 찾습니다 ( &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; 참조 ). 오류로 사망합니다.</target>
        </trans-unit>
        <trans-unit id="b30c1dfc72170a71448f9b395e9b03e816f03b3d" translate="yes" xml:space="preserve">
          <source>Given a PerlIO * create a 'native' FILE * suitable for passing to code expecting to be compiled and linked with ANSI C</source>
          <target state="translated">PerlIO가 주어지면 * '네이티브'파일을 생성하십시오 * ANSI C와 컴파일되고 링크 될 것으로 예상되는 코드로 전달하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="34f965aed65d5f567330c1f887c60f3d7277e8d9" translate="yes" xml:space="preserve">
          <source>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</source>
          <target state="translated">메모리 덩어리가 주어지면 경기장 목록의 헤드에 연결하고 사용 가능한 SV 목록으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="ea0db9ec916b80f6d45682cc0643494437b81c63" translate="yes" xml:space="preserve">
          <source>Given a function argument and the corresponding function value, store them into the cache.</source>
          <target state="translated">함수 인수와 해당 함수 값이 주어지면 캐시에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="368b29d6322d5568fa6515033d024e6d8d044278" translate="yes" xml:space="preserve">
          <source>Given a function argument, is the corresponding function value in the cache, and if so, is it fresh enough to use?</source>
          <target state="translated">함수 인수가 주어지면 캐시에 해당 함수 값이 있습니까? 그렇다면 사용하기에 충분합니까?</target>
        </trans-unit>
        <trans-unit id="f996cfe932df1fdf5f95873d9c8a6b9f9b2d54ff" translate="yes" xml:space="preserve">
          <source>Given a function argument, look up the corresponding function value in the cache and return it.</source>
          <target state="translated">함수 인수가 주어지면 캐시에서 해당 함수 값을 찾아서 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="c3509e606900720895e02d9e89cbafec46d210bc" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt; ) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">키 ( &lt;code&gt;$key&lt;/code&gt; )가 주어지면 이 메소드는 데이터베이스에서 키 와 연관된 값을 읽습니다. 데이터베이스에서 읽은 값은 &lt;code&gt;$value&lt;/code&gt; 매개 변수에 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7f4f0181b47fc4d73d9cd3bbfb5acee403880eb" translate="yes" xml:space="preserve">
          <source>Given a list of args get the names of tests that should run</source>
          <target state="translated">인수 목록이 주어지면 실행해야 할 테스트 이름을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="16258c75193474948085fd76ec96dab72f546f03" translate="yes" xml:space="preserve">
          <source>Given a list of file names, strip out those that refer to a parent directory. (Does not strip symlinks, only '.', '..', and equivalents.)</source>
          <target state="translated">파일 이름 목록이 제공되면 상위 디렉토리를 참조하는 파일 이름을 제거하십시오. 심볼릭 링크를 제거하지 않고 '.', '..'및 동등한 항목 만 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3f60dd44db71eb2a881f946f782f7b4489542b29" translate="yes" xml:space="preserve">
          <source>Given a list of scalars or reference variables, writes out their contents in perl syntax. The references can also be objects. The content of each variable is output in a single Perl statement. Handles self-referential structures correctly.</source>
          <target state="translated">스칼라 또는 참조 변수 목록이 제공되면 해당 컨텐츠를 perl 구문으로 작성하십시오. 참조는 객체 일 수도 있습니다. 각 변수의 내용은 단일 Perl 문으로 출력됩니다. 자기 참조 구조를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3e530c4f306640476d631e5c36d6a2f051774865" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름 또는 숫자가 주어지면 이것이 나타내는 유니 코드 문자의 수를 반환합니다. 예를 들어 &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; 및 &lt;code&gt;e2char('057')&lt;/code&gt; 모두 47을 반환합니다. &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 및 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 은 모두 유니 코드 번호가 47 인 &quot;/&quot;를 의미합니다. 이름에 알려진 값이 없거나 (이름이 &quot;qacute&quot;인 경우) 구문 적으로 유효하지 않은 경우 (이름이 &quot;1/4 인 경우&quot; &quot;), undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2023da106c6aa26bd0acc5076b02991c20277361" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름이나 숫자가 주어지면 해당 문자열이 반환됩니다. 예를 들어 &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; 및 &lt;code&gt;e2char('057')&lt;/code&gt; 모두 &quot;/&quot;를 반환합니다. &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 모두 평균 &quot;/&quot;. 이름에 알려진 값이 없거나 (이름이 &quot;qacute&quot;인 경우) 구문 상 유효하지 않은 경우 (이름이 &quot;1/4&quot;인 경우) undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68ff8a7e4af810b7a363c9f43756d64a041cba7a" translate="yes" xml:space="preserve">
          <source>Given a packed socket address (such as from getsockname(), getpeername(), or returned by getaddrinfo() in a &lt;code&gt;addr&lt;/code&gt; field), returns the hostname and symbolic service name it represents. $flags may be a bitmask of &lt;code&gt;NI_*&lt;/code&gt; constants, or defaults to 0 if unspecified.</source>
          <target state="translated">압축 된 소켓 주소 (예 : getsockname (), getpeername () 또는 &lt;code&gt;addr&lt;/code&gt; 필드의 getaddrinfo ()에 의해 리턴 됨)에서 호스트 이름과 그것이 나타내는 기호 서비스 이름을 리턴합니다. $ flags는 &lt;code&gt;NI_*&lt;/code&gt; 상수 의 비트 마스크 이거나 지정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b3ab833b08cd320284ae184893dbedaee3a8efff" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대한 포인터 와 &lt;code&gt;=~&lt;/code&gt; 연산 (예 : &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt; )에 대한 대치가 주어지면, replace ()는 연산에 따라 &lt;code&gt;SV&lt;/code&gt; 내의 문자열을 수정하여 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="7df1b1c7c83c78e200c9f9cd553763264fc01f76" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt; , which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">문자열과 패턴 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;/\b\w*\b/&lt;/code&gt; , C 프로그램에서 &quot;/ \\ b \\ w * \\ b /&quot;로 표시 될 수 있음)이 있으면 match ( )는 문자열이 패턴과 일치하면 1을 반환하고 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb2d005ca978881d5ba03242206b93769db89d30" translate="yes" xml:space="preserve">
          <source>Given a template, returns a filehandle to the temporary file and the name of the file.</source>
          <target state="translated">템플릿이 주어지면 파일 핸들을 임시 파일과 파일 이름으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3247eafd3bd6b87dad8bb050e03ecb6550fab7f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt; , a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt; , matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">감안할 때 &lt;code&gt;SV&lt;/code&gt; , 패턴 및 빈에 대한 포인터 &lt;code&gt;AV&lt;/code&gt; 를 , 일치 () 평가 &lt;code&gt;$string =~ $pattern&lt;/code&gt; 리스트 문맥, 그리고 채우기에</target>
        </trans-unit>
        <trans-unit id="d73be34ecb8afbc83a1abc326b027cd0e5ff7367" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element of a hash, returns true if the specified element in the hash has ever been initialized, even if the corresponding value is undefined.</source>
          <target state="translated">해시의 요소를 지정하는 표현식이 주어지면 해당 값이 정의되지 않은 경우에도 해시의 지정된 요소가 초기화 된 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3860c44bdd22a4566d9e655bb9fabca95c5a3818" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">해시의 요소 또는 슬라이스를 지정하는 표현식이 주어지면 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 는 해당 해시에서 지정된 요소를 삭제하여 해당 요소의 exist ()가 더 이상 true를 리턴하지 않도록합니다. 해시 요소를 정의되지 않은 값으로 설정하면 키가 제거되지 않지만 삭제하면 키가 제거됩니다. &lt;a href=&quot;exists&quot;&gt;존재&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c148d1ff0a7aebcb28822b3e1311889c861ad3aa" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">해시의 요소 또는 슬라이스를 지정하는 표현식이 주어지면 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 는 해당 해시에서 지정된 요소를 삭제하여 해당 요소의 exist ()가 더 이상 true를 리턴하지 않도록합니다. 해시 요소를 정의되지 않은 값으로 설정하면 키가 제거되지 않지만 삭제하면 키가 제거됩니다. &lt;a href=&quot;#exists&quot;&gt;존재&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="b769dfb6b889a385d12cb35d230597545507bff1" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 이름을 지정하는 표현식이 주어지면, 지정된 서브 루틴이 정의되지 않았더라도 선언 된 경우 true를 리턴합니다. 존재하거나 정의 된 서브 루틴 이름을 언급하는 것으로 선언하는 것으로 간주되지 않습니다. 존재하지 않는 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다. AUTOLOAD 메소드는 처음 호출 될 때 존재하게합니다. &lt;a href=&quot;../perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e2f23a5798654b28edd73d121507fc1d6cf61ce" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 이름을 지정하는 표현식이 주어지면, 지정된 서브 루틴이 정의되지 않았더라도 선언 된 경우 true를 리턴합니다. 존재하거나 정의 된 서브 루틴 이름을 언급하는 것으로 선언하는 것으로 간주되지 않습니다. 존재하지 않는 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다. AUTOLOAD 메소드는 처음 호출 될 때 존재하게합니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec3e095107124a6ef85e395cac4af42d46355e9a" translate="yes" xml:space="preserve">
          <source>Given an object, return a Perl scalar number (int/float) representing this number.</source>
          <target state="translated">객체가 주어지면이 숫자를 나타내는 Perl 스칼라 숫자 (int / float)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="798afe5be4d4f8caba61172a6204d0e7a4433382" translate="yes" xml:space="preserve">
          <source>Given an open filehandle and the associated filename, make a safe unlink. This is achieved by first checking that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by stat() are compared). Then the filename is unlinked and the filehandle checked once again to verify that the number of links on that file is now 0. This is the closest you can come to making sure that the filename unlinked was the same as the file whose descriptor you hold.</source>
          <target state="translated">열린 파일 핸들과 관련 파일 이름이 주어지면 안전하게 연결 해제하십시오. 파일 이름과 파일 핸들이 처음에 동일한 파일을 가리키고 파일에 대한 링크 수가 1인지 확인하여 (stat ()에서 반환 된 모든 필드를 비교) 확인합니다. 그런 다음 파일 이름이 연결 해제되고 파일 핸들이 다시 한 번 확인되어 해당 파일의 링크 수가 0인지 확인합니다. 연결되지 않은 파일 이름이 설명자가 보유한 파일과 동일한 지 확인하는 가장 가까운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7c8d7de16830e305c76870f7520f278ced8e53b9" translate="yes" xml:space="preserve">
          <source>Given both a hostname and service name, this function attempts to resolve the host name into a list of network addresses, and the service name into a protocol and port number, and then returns a list of address structures suitable to connect() to it.</source>
          <target state="translated">호스트 이름과 서비스 이름이 모두 주어지면이 함수는 호스트 이름을 네트워크 주소 목록으로, 서비스 이름을 프로토콜 및 포트 번호로 확인한 다음 connect ()에 적합한 주소 구조 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef7becd595d52be668be1e1f52b6edfa071be390" translate="yes" xml:space="preserve">
          <source>Given just a host name, this function attempts to resolve it to a list of network addresses, and then returns a list of address structures giving these addresses.</source>
          <target state="translated">호스트 이름 만 지정하면이 함수는 해당 주소를 네트워크 주소 목록으로 확인한 다음 해당 주소를 제공하는 주소 구조 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df00cd802473947a22a033a5fee10eaeb326c652" translate="yes" xml:space="preserve">
          <source>Given just a service name, this function attempts to resolve it to a protocol and port number, and then returns a list of address structures that represent it suitable to bind() to. This use should be combined with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag; see below.</source>
          <target state="translated">서비스 이름 만 지정하면이 함수는 서비스 이름을 프로토콜 및 포트 번호로 확인한 다음 bind ()에 적합한 주소 구조 목록을 리턴합니다. 이 사용은 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 플래그 와 결합되어야합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47c398084bf96dcff46eefda9cdadf3fedccfe90" translate="yes" xml:space="preserve">
          <source>Given neither name, it generates an error.</source>
          <target state="translated">이름이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4946a614ce699917e8a48264ad588e74a71edfe3" translate="yes" xml:space="preserve">
          <source>Given that the file glob is just a cut-down regular expression and that it has already done a lot of the hard work in pattern matching the filenames, wouldn't it be handy to be able to use the patterns in the fileglob to drive the new filename?</source>
          <target state="translated">파일 glob은 단순한 정규 표현식이며 파일 이름과 일치하는 패턴에서 많은 노력을 이미했다는 것을 감안할 때 fileglob의 패턴을 사용하여 파일 글로브를 구동하는 것이 편리하지 않습니다. 새로운 파일명?</target>
        </trans-unit>
        <trans-unit id="1a0688e5deb209d4898cf79e8c4e93da364593b3" translate="yes" xml:space="preserve">
          <source>Given that we failed to load &lt;code&gt;Compress::Zlib&lt;/code&gt; and that the use of an external</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 를로드하지 못하고 외부 사용을 가정 한 경우</target>
        </trans-unit>
        <trans-unit id="25d0946db041e6b8ec000e3934554230eea3d997" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">테스트의 파일 이름과 설명이 스칼라로 주어지면 새 &lt;a href=&quot;job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8321e912ffb7fc1712a163f5114b8b8cfc71ea6c" translate="yes" xml:space="preserve">
          <source>Given the following module, PerlIO::via::Hex :</source>
          <target state="translated">다음 모듈이 주어지면 PerlIO :: via :: Hex :</target>
        </trans-unit>
        <trans-unit id="b1732b671f9a08843781c433880de7a9be2cae19" translate="yes" xml:space="preserve">
          <source>Given the following notations:</source>
          <target state="translated">다음과 같은 표기법이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="d2cba25d77a3267a4c7e81b67be7cfba4a549ed5" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad.</source>
          <target state="translated">어휘 변수의 이름이 주어지면 현재 컴파일중인 패드에서 해당 위치를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4e332da4ace4bc5d01c9ceda2ce9f67dcc253135" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set,</source>
          <target state="translated">optree의 루트가 주어지면 &lt;code&gt;op_next&lt;/code&gt; 포인터를 사용하여 실행 순서대로 트리를 링크하고 실행 된 첫 번째 op를 리턴하십시오. 이 작업이 이미 완료되면 다시 실행되지 않으며 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 가 반환됩니다. 경우 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 이미 설정되어 있지 않은,</target>
        </trans-unit>
        <trans-unit id="084725aa23e7fe3c0d543b97b1c7320210101746" translate="yes" xml:space="preserve">
          <source>Given the sheer volume of Perl documentation, this isn't a trivial undertaking, but if you can point to documentation that suggests the behaviour you're seeing is</source>
          <target state="translated">펄 문서의 많은 양을 감안할 때, 이것은 사소한 일이 아니지만보고있는 행동을 제안하는 문서를 가리킬 수 있다면</target>
        </trans-unit>
        <trans-unit id="a51193d192cf9332f4f5d4257e036cab9b0cff3c" translate="yes" xml:space="preserve">
          <source>Given this as an input string in a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; would correctly return the string &quot;&amp;lt;&amp;lt;'EOMSG'\nThis is the message.\nEOMSG&quot;, leaving the string &quot; || die;\nexit;&quot; in the original variable. In other words, the two separate pieces of the here document are successfully extracted and concatenated.</source>
          <target state="translated">이를 스칼라 컨텍스트에서 입력 문자열로 지정하면 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 &quot;&amp;lt;&amp;lt; 'EOMSG'\ n이 메시지입니다. \ nEOMSG&quot;문자열을 올바르게 리턴하고 &quot;|| die; \ nexit;&quot; 원래 변수에서. 다시 말해, 여기 문서의 두 개의 분리 된 조각이 성공적으로 추출되고 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a8255eb67db18215cafd66b8bf6854ff058e58c2" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; , giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">두 개의 perl 버전이 주어지면 코어 모듈 내용의 변경 사항을 설명하는 쌍 목록을 반환합니다. 이 목록은 해시에 저장하기에 적합합니다. 키는 라이브러리 이름이고 값은 해시 참조입니다. 각 해시 참조에는 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 중 하나 또는 둘 다에 대한 항목이 있으며 각 왼쪽 및 오른쪽 perl 분포에서 라이브러리 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3e8e0d7ce171e4fc80eeb08f47d5a4cc76a6ae2" translate="yes" xml:space="preserve">
          <source>Given two versions of perl, this prints a human-readable table of all module changes between the two. The output format may change in the future, and is meant for</source>
          <target state="translated">두 가지 버전의 perl이 주어지면 두 모듈 사이의 모든 모듈 변경 사항을 사람이 읽을 수있는 표로 인쇄합니다. 출력 형식은 향후 변경 될 수 있으며</target>
        </trans-unit>
        <trans-unit id="d8e6036259b26c2d9989b981df7306264ca46f69" translate="yes" xml:space="preserve">
          <source>Gives a description of each test prior to performing it.</source>
          <target state="translated">수행하기 전에 각 테스트에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="95e8be14901e94fb491dfdf5b70ee1b95c0f63d7" translate="yes" xml:space="preserve">
          <source>Gives more detailed information about each test, after it has been performed. Note that any failed tests ought to print out some extra information whether or not -v is thrown.</source>
          <target state="translated">각 테스트가 수행 된 후 각 테스트에 대한 자세한 정보를 제공합니다. 실패한 테스트는 -v의 발생 여부에 관계없이 몇 가지 추가 정보를 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cd5accb9bbe824d3f2172984bdf0c7f749a0330" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt; . The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">&lt;code&gt;&amp;amp;xsub&lt;/code&gt; 에 의해 바인드 된 C 함수를 포함하는 DLL 또는 Perl DLL에 대한 정보를 제공합니다 . &lt;code&gt;how&lt;/code&gt; 의 의미 : 기본 (2) : 이름; 0 : 핸들; 1 : 모듈 이름.</target>
        </trans-unit>
        <trans-unit id="9ce00937b225bda0f6de7705049c711ca2d0c0b1" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; , which is faster.</source>
          <target state="translated">stringify 과부하가 없을 때와 같이 &lt;code&gt;arg&lt;/code&gt; 의 문자열 값을 제공합니다 . 이것을 사용하여 참조 주소를 가져 오는 경우 (두 참조가 동일한 것을 가리키는 지 확인하는 데 유용) &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cfe98f7aeaa456c4237c94f0fd4653d71593c9bc" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt; .</source>
          <target state="translated">이전 답변에 사용 된 힌트 유형을 제공합니다. &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; 또는 &lt;code&gt;previous&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d71dccbe06d617b4160092d77a20fffa36b965b4" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt; .</source>
          <target state="translated">구조체에 클래스 타입 인 구조체 요소를 제공하는 것은 구조체가 중첩되는 방법입니다. 여기서 &lt;code&gt;Timeval&lt;/code&gt; 은 시간 (초 및 마이크로 초)을 &lt;code&gt;Rusage&lt;/code&gt; 에는 두 가지 요소가 있으며 각 요소는 &lt;code&gt;Timeval&lt;/code&gt; 유형 입니다 .</target>
        </trans-unit>
        <trans-unit id="d166f9da4bac6d857f7dc131be5d65de1b02def6" translate="yes" xml:space="preserve">
          <source>Giving additional meanings to a symbol or construct. Actually, all languages do overloading to one extent or another, since people are good at figuring out things from &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">심볼이나 구성에 추가적인 의미를 부여합니다. 사실, 사람들은 &lt;b&gt;문맥&lt;/b&gt; 으로부터 사물을 파악하는 데 능숙하기 때문에 모든 언어가 어느 정도 오버로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8b8f975ca429de01bb46828d5e9ad364deeb90c" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">에 대한 잘못된 값주기 &lt;code&gt;$sock_type&lt;/code&gt; 것 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f57f0ea36677c92cf9afe99cb8959d03cc0961e" translate="yes" xml:space="preserve">
          <source>Giving up control</source>
          <target state="translated">통제권 부여</target>
        </trans-unit>
        <trans-unit id="ac34b82dc93bde9b29a5a3004c3ddbeef7e257a6" translate="yes" xml:space="preserve">
          <source>Glob elements can be extracted through the postfix dereferencing feature:</source>
          <target state="translated">후위 역 참조 기능을 통해 글로브 요소를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2bba5393d5751445bbbac73e8d2d26ee97a6c53" translate="yes" xml:space="preserve">
          <source>Glob-style pattern matching for rules</source>
          <target state="translated">규칙에 대한 전역 스타일 패턴 일치</target>
        </trans-unit>
        <trans-unit id="f4853985ae8961c644b701f3a4211e427659afca" translate="yes" xml:space="preserve">
          <source>Global Destruction</source>
          <target state="translated">글로벌 파괴</target>
        </trans-unit>
        <trans-unit id="d4326c5fc3d6b26143e4368742fe314ae01c47ca" translate="yes" xml:space="preserve">
          <source>Global Overriding</source>
          <target state="translated">글로벌 재정의</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="c74b56bb1057578230abe272aa56e202301adbc0" translate="yes" xml:space="preserve">
          <source>Global destruction.</source>
          <target state="translated">세계적인 파괴.</target>
        </trans-unit>
        <trans-unit id="e7f5c9eb53159b83da104e3bda376cd7346692a8" translate="yes" xml:space="preserve">
          <source>Global matching</source>
          <target state="translated">글로벌 매칭</target>
        </trans-unit>
        <trans-unit id="3650821866c81f2ac2894b41d87da9c715e1e8ce" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">저장 가능한 AnyDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="4909b3a46d83dbbf52b8710b4dc26c66ca78944e" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">저장 가능 사용을 위해 NDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="d57f000cec87f12e43b8b27b36323279bd6bf351" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">저장 가능 사용을 위해 SDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="1ef566e266fcd5938f2e20f4951576b582c8951b" translate="yes" xml:space="preserve">
          <source>Go and write your program. Everywhere in your program where you would say:</source>
          <target state="translated">가서 프로그램을 작성하십시오. 프로그램의 모든 곳에서 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="17a5012f10d8e9cdb0ba165e243a06151fb8f234" translate="yes" xml:space="preserve">
          <source>Go into the newly-created directory and type:</source>
          <target state="translated">새로 작성된 디렉토리로 이동하여 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="29c6ec10417b35abc144d3f4a0729c76abf5e284" translate="yes" xml:space="preserve">
          <source>Going past the 70th column in a verbatim block might be ungracefully wrapped by some formatters.</source>
          <target state="translated">축약 형 블록에서 70 번째 열을지나 가면 일부 포매터가 비정상적으로 랩핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">좋은 습관</target>
        </trans-unit>
        <trans-unit id="7d80a18b9b9c68e6a7c1c8a8d0dbf303700b7763" translate="yes" xml:space="preserve">
          <source>Good example:</source>
          <target state="translated">좋은 예 :</target>
        </trans-unit>
        <trans-unit id="4143405b286941b2e4ea2b9f669d260327d04f9b" translate="yes" xml:space="preserve">
          <source>Good for tracking down why things don't work with your particular setup.</source>
          <target state="translated">특정 설정에서 작동하지 않는 이유를 추적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f73c69efaf3df1b92a97b27aa347eb13fea306c3" translate="yes" xml:space="preserve">
          <source>Good patches (tight code, complete, correct) stand more chance of going in. Sloppy or incorrect patches might be placed on the back burner until the pumpking has time to fix, or might be discarded altogether without further notice.</source>
          <target state="translated">좋은 패치 (긴밀한 코드, 완전하고 정확한)는 들어갈 가능성이 더 큽니다. 호박이 고칠 시간이 지날 때까지 느슨하거나 잘못된 패치가 백 버너에 놓이거나 더 이상 예고없이 폐기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e99dfa2e51dca66243d416a2cf4eff66499d06" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; and &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">기존 모듈을 찾는 좋은 장소는 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 및 &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org를&lt;/a&gt; 포함 하고 &lt;code&gt;module-authors@perl.org&lt;/code&gt; ( &lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list&lt;/a&gt; 에 문의)를 포함합니다 . /module-authors.html ).</target>
        </trans-unit>
        <trans-unit id="1707029b59612c93d147b82e0c5b435886ce180c" translate="yes" xml:space="preserve">
          <source>Gory details of parsing quoted constructs</source>
          <target state="translated">인용 된 구문 분석 구문 분석 세부 사항</target>
        </trans-unit>
        <trans-unit id="23f16c19388eabd103562554c9bfa091b6dac302" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; .</source>
          <target state="translated">알았어? Perl 5.8.7에서 &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; 은 현재 의미에서 UTF-8을 의미하며, 이는 보수적이고 엄격하며 보안을 &lt;b&gt;중요시합니다. &quot;utf8&quot;&lt;/b&gt; 은 이전 의미에서 자유롭고 느슨한 UTF-8을 의미합니다. lax. 따라서 버전 2.10 이상을 &lt;code&gt;Encode&lt;/code&gt; 하면 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 미묘하지만 중요한 차이점이 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="0b4fc0a0d78b25de463f95089769282373893971" translate="yes" xml:space="preserve">
          <source>Got that? Larry is always right, even when he was wrong. It's rare to see either Rule exercised, but they are often alluded to.</source>
          <target state="translated">알았어? 래리는 그가 틀렸을 때에도 항상 옳습니다. 규칙을 행사하는 것은 드물지만 종종 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="ca69ac23523fe10118230a18e01d42c76c8abcda" translate="yes" xml:space="preserve">
          <source>Goto celib-palm-3.0\inc\cewin32.h, search for</source>
          <target state="translated">celib-palm-3.0 \ inc \ cewin32.h로 이동하여</target>
        </trans-unit>
        <trans-unit id="5890e910925d55654694f7ac1d42c03b68abbff2" translate="yes" xml:space="preserve">
          <source>Gotta have a plan!</source>
          <target state="translated">계획이있어!</target>
        </trans-unit>
        <trans-unit id="df8da02e8026798b67902a6787a5e32f5d1a8e68" translate="yes" xml:space="preserve">
          <source>Gprof Profiling</source>
          <target state="translated">Gprof 프로파일 링</target>
        </trans-unit>
        <trans-unit id="3259bccd5547a6fb8f77a4aaea022a14a41cb136" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;</source>
          <target state="translated">그레이엄 바 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42879164d6188855410d722427bd053e05e54ab7" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">그레이엄 바 &amp;lt;gbarr@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3732fa7e665009645e9e3e4379dd15edc1deb872" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04f7ed11e65f8179b2c21de31c70c0e5a2b54f2f" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7820aa7c6db183e706a7e84c2116e052f42811c0" translate="yes" xml:space="preserve">
          <source>Graham Barr, the original Configure script of libnet.</source>
          <target state="translated">libnet의 원래 구성 스크립트 인 Graham Barr</target>
        </trans-unit>
        <trans-unit id="6433e49daadbc911a68d39c3c194d36d03e3dce3" translate="yes" xml:space="preserve">
          <source>Graham Barr. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">그레이엄 바. 현재 Perl Porter가 관리합니다. 모든 버그를 &amp;lt;perlbug@perl.org&amp;gt;에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="87a1ea2f5e9ab380ccaeb3b75aeec67585ecc358" translate="yes" xml:space="preserve">
          <source>Graham Barr. atmark() by Lincoln Stein. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">그레이엄 바. Lincoln Stein의 atmark (). 현재 Perl Porter가 관리합니다. 모든 버그를 &amp;lt;perlbug@perl.org&amp;gt;에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="851fd61fa3fb1f5808ef8c8f9dd236974160fdad" translate="yes" xml:space="preserve">
          <source>Graham Knop &amp;lt;haarg@haarg.org&amp;gt;</source>
          <target state="translated">그레이엄 노브 &amp;lt;haarg@haarg.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="ca8c988917ca583e838e2647bffdc0dd152b9fb8" translate="yes" xml:space="preserve">
          <source>Grammatical note on local()</source>
          <target state="translated">local ()에 대한 문법 노트</target>
        </trans-unit>
        <trans-unit id="844b43fd71cbef7f18e867fe292f5c5684e1ab12" translate="yes" xml:space="preserve">
          <source>Great care is necessary when defining the command if quoting needs to be done. For instance, you would need to say:</source>
          <target state="translated">인용이 필요한 경우 명령을 정의 할 때 각별한주의가 필요합니다. 예를 들어, 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c5e7d8a89c7b18aac43a9485b1546ac5b284f75" translate="yes" xml:space="preserve">
          <source>Group ID&amp;mdash;in Unix, the numeric group ID that the &lt;b&gt;operating system&lt;/b&gt; uses to identify you and members of your &lt;b&gt;group&lt;/b&gt;.</source>
          <target state="translated">그룹 ID&amp;mdash;Unix에서 &lt;b&gt;운영 체제&lt;/b&gt; 가 사용자와 &lt;b&gt;그룹&lt;/b&gt; 구성원을 식별하는 데 사용 하는 숫자 그룹 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="16a718e915556d62f893e87ee82787d36995c7e4" translate="yes" xml:space="preserve">
          <source>Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">그룹 Perl의 기능은 la perlfunc.pod</target>
        </trans-unit>
        <trans-unit id="ba2d2b2b97d3fc7cff00f1012c3e7d17c04c2768" translate="yes" xml:space="preserve">
          <source>Group of languages collectively called &quot;Otom&amp;iacute;&quot;.</source>
          <target state="translated">&quot;Otom&amp;iacute;&quot;로 통칭 된 언어 그룹.</target>
        </trans-unit>
        <trans-unit id="cb77c777665eaa5c9fc03cd1712f2d2993483948" translate="yes" xml:space="preserve">
          <source>Group ownwership of directories that already exist will not be changed.</source>
          <target state="translated">이미 존재하는 디렉토리의 그룹 소유권은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc00408fdf05ce5150089b75b75b23c46962261d" translate="yes" xml:space="preserve">
          <source>Grouping things and hierarchical matching</source>
          <target state="translated">사물 그룹화 및 계층 적 일치</target>
        </trans-unit>
        <trans-unit id="fee5f710c9ba7310f55f4c68e3911ad898f334f8" translate="yes" xml:space="preserve">
          <source>Growing Your Own</source>
          <target state="translated">자신의 성장</target>
        </trans-unit>
        <trans-unit id="7864c5c65bb01ac0a14a3115852b7c02219c584f" translate="yes" xml:space="preserve">
          <source>Guaran&amp;iacute;</source>
          <target state="translated">Guaran&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="23ca9988de5733d8c8247a3e4e4982df4f209ed4" translate="yes" xml:space="preserve">
          <source>Guess the name of this package by examining the working directory's name. MakeMaker calls this only if the developer has not supplied a NAME attribute.</source>
          <target state="translated">작업 디렉토리 이름을 검사하여이 패키지의 이름을 추측하십시오. MakeMaker는 개발자가 NAME 속성을 제공하지 않은 경우에만이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="07aa51a012723e8368dc093b343c1ff642baa052" translate="yes" xml:space="preserve">
          <source>Guess.U</source>
          <target state="translated">Guess.U</target>
        </trans-unit>
        <trans-unit id="b6684e2eba17124bde1d0355e24c5684aef1bed6" translate="yes" xml:space="preserve">
          <source>Guesses encoding from data</source>
          <target state="translated">데이터에서 인코딩을 추측</target>
        </trans-unit>
        <trans-unit id="73b139c37c0097cfe3599d3082c96b0c2aee8d6a" translate="yes" xml:space="preserve">
          <source>Guidelines for Converting Perl 4 Library Scripts into Modules</source>
          <target state="translated">Perl 4 라이브러리 스크립트를 모듈로 변환하기위한 지침</target>
        </trans-unit>
        <trans-unit id="c758bdbdcf1ca454825428e4f69546fbfdaf18d9" translate="yes" xml:space="preserve">
          <source>Guidelines for Module Creation</source>
          <target state="translated">모듈 생성 지침</target>
        </trans-unit>
        <trans-unit id="5fc6aecec704586c9198ddc6d24910690ea4c4e4" translate="yes" xml:space="preserve">
          <source>Guidelines for Reusing Application Code</source>
          <target state="translated">응용 프로그램 코드 재사용 지침</target>
        </trans-unit>
        <trans-unit id="9f22068b470b55c5659b24a529d486d165efe1e8" translate="yes" xml:space="preserve">
          <source>Gulliver's Travels</source>
          <target state="translated">걸리버 여행기</target>
        </trans-unit>
        <trans-unit id="d3d42475682a0666adb5abe77243023160ef0a45" translate="yes" xml:space="preserve">
          <source>Gunzip/gzip for OS/390 is discussed at:</source>
          <target state="translated">OS / 390 용 Gunzip / gzip은 다음에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="93a0fe097041b93e0be65ee154daffc6b1381bc9" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</source>
          <target state="translated">구루 사미 사라 티 &amp;lt;gsar@activestate.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d960951b2cdfc9f9204beae43f12a4a11b295b41" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy gsar@activestate.com</source>
          <target state="translated">Gurusamy Sarathy gsar@activestate.com</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="58edf605e14f939b5061c16becc3c237b2cf3c47" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</source>
          <target state="translated">H.Merijn 브랜드 &amp;lt;hmbrand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="47ce9e7227c5c88413414b245a64737d1d7aa032" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;autoflush( EXPR )</source>
          <target state="translated">핸들-&amp;gt; 자동 플러시 (EXPR)</target>
        </trans-unit>
        <trans-unit id="e39692187e35b8d86da8462f683967a48317dea2" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_left(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_left(EXPR)</target>
        </trans-unit>
        <trans-unit id="209a918918c25cd99d83f2f0dbbc4f467dc693f1" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_per_page(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_per_page(EXPR)</target>
        </trans-unit>
        <trans-unit id="f1d2f9361bebc33157aeedef49dc5f8e73598847" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="0c9bdf53fa0c2bc01c5c44ec8066b07d741898ab" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_page_number(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_page_number(EXPR)</target>
        </trans-unit>
        <trans-unit id="7462f62c1d1e40bafc8b07b413de84a660ada74e" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_top_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_top_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="69f09f09d96a3982a3608cf0a03c946ae72aee61" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;input_line_number( EXPR )</source>
          <target state="translated">핸들-&amp;gt; 입력 _ 라인 _ 번호 (EXPR)</target>
        </trans-unit>
        <trans-unit id="789c59b41e5418de142d321c95b023de4bdfe79e" translate="yes" xml:space="preserve">
          <source>HASHES OF ARRAYS</source>
          <target state="translated">배열의 해시</target>
        </trans-unit>
        <trans-unit id="530c7188bb0935938e3b58577815f4334a49e6ef" translate="yes" xml:space="preserve">
          <source>HASHES OF HASHES</source>
          <target state="translated">해시 해시</target>
        </trans-unit>
        <trans-unit id="a880c390a6cf41f70f9a43af2b194442bbe8c615" translate="yes" xml:space="preserve">
          <source>HEY</source>
          <target state="translated">HEY</target>
        </trans-unit>
        <trans-unit id="fc5d4b9117ba9e87388174aee4f4970bdfe8d066" translate="yes" xml:space="preserve">
          <source>HH</source>
          <target state="translated">HH</target>
        </trans-unit>
        <trans-unit id="5b8cce18efcb259ac8ee29e1cd21dcc198081fdb" translate="yes" xml:space="preserve">
          <source>HHHH</source>
          <target state="translated">HHHH</target>
        </trans-unit>
        <trans-unit id="9c2ea135ec1db4f446c806f7895ae6f2c302104a" translate="yes" xml:space="preserve">
          <source>HINTS AND TIPS</source>
          <target state="translated">힌트와 팁</target>
        </trans-unit>
        <trans-unit id="f6dc58f5e8036353a7ac15516c30ac562e23dc26" translate="yes" xml:space="preserve">
          <source>HISTORY</source>
          <target state="translated">HISTORY</target>
        </trans-unit>
        <trans-unit id="d0e8f9a5a2dbdd8722af6ec7f2972e1375fb801e" translate="yes" xml:space="preserve">
          <source>HMAC-SHA-1/224/256/384/512</source>
          <target state="translated">HMAC-SHA-1/224/256/384/512</target>
        </trans-unit>
        <trans-unit id="a76f8ee2872265eb6fe359928ee6904e71dc9d05" translate="yes" xml:space="preserve">
          <source>HOW IT WORKS</source>
          <target state="translated">작동 방식</target>
        </trans-unit>
        <trans-unit id="eab9f433c21086a197b4e1c36ca01d70a2e0dffa" translate="yes" xml:space="preserve">
          <source>HOW TO USE MAKETEXT</source>
          <target state="translated">메이크 텍스트를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="6ab52b908787e3ae467e585a2243118089d23d99" translate="yes" xml:space="preserve">
          <source>HP Itanium 2 systems are usually referred to with model description &quot;HP Integrity&quot;.</source>
          <target state="translated">HP Itanium 2 시스템은 일반적으로 &quot;HP Integrity&quot;모델 설명과 함께 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="9e3417f4faadcebc07bb9497031485b632cc05e1" translate="yes" xml:space="preserve">
          <source>HP also ships servers with the 128-bit Itanium processor(s). The cx26x0 is told to have Madison 6. As of the date of this document's last update, the following systems contain Itanium or Itanium 2 chips (this is likely to be out of date):</source>
          <target state="translated">HP는 또한 서버에 128 비트 Itanium 프로세서를 제공합니다. cx26x0에는 Madison 6이 설치되어 있습니다.이 문서의 마지막 업데이트 날짜를 기준으로 다음 시스템에는 Itanium 또는 Itanium 2 칩이 포함되어 있습니다 (오래되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="2d0a2c854fdfe25037f6f2462163a3677a8c0d9a" translate="yes" xml:space="preserve">
          <source>HP has asked the porting centre to move Open Source binaries from /opt to /usr/local, so binaries produced since the start of July 2002 are located in /usr/local.</source>
          <target state="translated">HP는 포팅 센터에 오픈 소스 바이너리를 / opt에서 / usr / local로 이동하도록 요청했으며, 2002 년 7 월 시작 이후 생성 된 바이너리는 / usr / local에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a764a39116b67d584d0e922398f34d8a6157ce49" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing only perl-5.10.1 was available (with 5.16.3 being the latest stable release from the porters point of view).</source>
          <target state="translated">HP 포팅 센터는 고객 요구에 부응하고 오픈 소스 커뮤니티의 업데이트를 릴리스하려고합니다. &quot;최신&quot;은 상대적이지만 사전 컴파일 된 Perl 바이너리를 사용할 수 있다는 것은 명백합니다. 현재로서는 perl-5.10.1 만 사용 가능했습니다 (포터의 관점에서 5.16.3이 가장 안정적인 릴리스 임).</target>
        </trans-unit>
        <trans-unit id="9dbd2af4559edefe4dd19c07c7c19b95825a0430" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset.</source>
          <target state="translated">HP의 HP9000 Unix 시스템은 HP의 자체 정밀 아키텍처 (PA-RISC) 칩에서 실행됩니다. HP-UX는 Motorola MC68000 칩 제품군에서 실행되었지만이 칩이 장착 된 시스템은 더 이상 사용되지 않으며이 문서는 Motorola 칩셋에서 Perl을 컴파일하는 문제를 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d006886dc4fd65e0adca5c8c02c5767eb4d1359" translate="yes" xml:space="preserve">
          <source>HP-UX 11 Y2K patch &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 Patch Bundle&quot; has been reported to break the io/fs test #18 which tests whether utime() can change timestamps. The Y2K patch seems to break utime() so that over NFS the timestamps do not get changed (on local filesystems utime() still works). This has probably been fixed on your system by now.</source>
          <target state="translated">HP-UX 11 Y2K 패치 &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 패치 번들&quot;은 utime ()이 타임 스탬프를 변경할 수 있는지 테스트하는 io / fs 테스트 # 18을 위반하는 것으로보고되었습니다. Y2K 패치는 NFS를 통해 타임 스탬프가 변경되지 않도록 utime ()을 중단하는 것처럼 보입니다 (로컬 파일 시스템에서 utime ()은 여전히 ​​작동 함). 이것은 아마도 지금까지 시스템에서 수정되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="97187cfde6c75a8b8deebd75a13a60ae1c81f420" translate="yes" xml:space="preserve">
          <source>HP-UX 11i documentation on syslog, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 HP-UX 11i 설명서, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed2a9bb260e4ae72bbe1af113a3b7bdf4f05246c" translate="yes" xml:space="preserve">
          <source>HP-UX Kernel Parameters (maxdsiz) for Compiling Perl</source>
          <target state="translated">Perl 컴파일을위한 HP-UX 커널 매개 변수 (maxdsiz)</target>
        </trans-unit>
        <trans-unit id="83019d5a780dd0ff3c9db7fabc3a90c74127c6c2" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the new Itanium processor. This requires the use of a different version of HP-UX (currently 11.23 or 11i v2), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX는 새로운 Itanium 프로세서에서도 실행됩니다. 이를 위해서는 다른 버전의 HP-UX (현재 11.23 또는 11i v2)를 사용해야하며 아래 및 이후 섹션에서 자세히 설명하는 몇 가지 차이점을 제외하고 Perl은 아무런 문제없이 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="6054c4b79943ef67e4dcb28eb588b66781f366f6" translate="yes" xml:space="preserve">
          <source>HP-UX supports dynamically loadable libraries (shared libraries). Shared libraries end with the suffix .sl. On Itanium systems, they end with the suffix .so.</source>
          <target state="translated">HP-UX는 동적으로로드 가능한 라이브러리 (공유 라이브러리)를 지원합니다. 공유 라이브러리는 접미사 .sl로 끝납니다. Itanium 시스템에서는 접미사 .so로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="b4319bb42f0da477a0906018447c3096d305eb37" translate="yes" xml:space="preserve">
          <source>HP-UX versions</source>
          <target state="translated">HP-UX 버전</target>
        </trans-unit>
        <trans-unit id="0c355dad6ecf8b6970623574fcecedac49554b22" translate="yes" xml:space="preserve">
          <source>HP-UX versions before 10.30 require a separate installation of a POSIX threads library package. Two examples are the HP DCE package, available on &quot;HP-UX Hardware Extensions 3.0, Install and Core OS, Release 10.20, April 1999 (B3920-13941)&quot; or the Freely available PTH package, available on H.Merijn's site (&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt;). The use of PTH will be unsupported in perl-5.12 and up and is rather buggy in 5.11.x.</source>
          <target state="translated">10.30 이전의 HP-UX 버전은 POSIX 스레드 라이브러리 패키지를 별도로 설치해야합니다. 두 가지 예는 &quot;HP-UX Hardware Extensions 3.0, 설치 및 코어 OS, 1999 년 4 월 10.20 (B3920-13941)&quot;에서 제공되는 HP DCE 패키지 또는 H.Merijn 사이트 ( &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http : //mirrors.develooper.com/hpux/&lt;/a&gt; ). PTH 사용은 perl-5.12 이상에서 지원되지 않으며 5.11.x에서는 다소 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="9386c18987cda4e4b47eab3b2d462dd758250ce8" translate="yes" xml:space="preserve">
          <source>Ha! Try that with your garden variety regexp package...</source>
          <target state="translated">하아! 귀하의 정원 다양성 정규식 패키지로 시도하십시오 ...</target>
        </trans-unit>
        <trans-unit id="d88e3f220c919ffbf868396a7d774a5334f737c8" translate="yes" xml:space="preserve">
          <source>Hack, hack, hack. Keep in mind that Perl runs on many different platforms, with different operating systems that have different capabilities, different filesystem organizations, and even different character sets. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; gives advice on this.</source>
          <target state="translated">해킹, 해킹, 해킹 Perl은 기능이 다른 운영 체제, 파일 시스템 구성 및 문자 집합이 다른 여러 플랫폼에서 실행됩니다. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; 가 이에 대한 조언을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa83b6b9d8de018c03b6e14834f7dbb735668abf" translate="yes" xml:space="preserve">
          <source>Hackathons</source>
          <target state="translated">Hackathons</target>
        </trans-unit>
        <trans-unit id="70b5ad218deb587375e9d9ea493155e8eea890e8" translate="yes" xml:space="preserve">
          <source>Hackathons are a very different kind of gathering where Perl hackers gather to do just that, hack nonstop for an extended (several day) period on a specific project or projects. Information about hackathons can be located in the same place as information about &lt;a href=&quot;#Workshops&quot;&gt;workshops&lt;/a&gt; as well as in &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;.</source>
          <target state="translated">해커 톤은 Perl 해커가 특정 프로젝트 또는 프로젝트에서 장기간 (몇 일) 동안 논스톱 해킹을하기 위해 수집하는 매우 다른 종류의 모임입니다. 해커 &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;톤&lt;/a&gt; 에 대한 정보는 &lt;a href=&quot;#Workshops&quot;&gt;워크샵&lt;/a&gt; 에 대한 정보와 같은 장소와 irc : //irc.perl.org/#perl에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b2f425b8ec6dc0f52bcfb2fe8c13331b8f6480" translate="yes" xml:space="preserve">
          <source>Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</source>
          <target state="translated">이전 유니 코드 버전에서 작동하기 위해 Perl 해킹 (매우 심각한 해커 전용)</target>
        </trans-unit>
        <trans-unit id="c241df4cb37e7ba32f33cd5ab23a83488a78b7ae" translate="yes" xml:space="preserve">
          <source>Hacking tools and documentation</source>
          <target state="translated">해킹 툴 및 문서</target>
        </trans-unit>
        <trans-unit id="2cd3bee34e1e2aafe8cc6f8bcda061ef9d49610f" translate="yes" xml:space="preserve">
          <source>Half a &lt;b&gt;byte&lt;/b&gt;, equivalent to one &lt;b&gt;hexadecimal&lt;/b&gt; digit, and worth four &lt;b&gt;bits&lt;/b&gt;.</source>
          <target state="translated">1 &lt;b&gt;바이트의 &lt;/b&gt;&lt;b&gt;16 진수에&lt;/b&gt; 해당하며 4 &lt;b&gt;비트에&lt;/b&gt; 해당하는 반 &lt;b&gt;바이트&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6d8ab5e201dd91380811a77b55a7a931f3d5eee4" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt; . This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">의 중간 &lt;code&gt;ok()&lt;/code&gt; 와 &lt;code&gt;is()&lt;/code&gt; 거짓말 &lt;code&gt;cmp_ok()&lt;/code&gt; . 이진 펄 연산자를 사용하여 두 개의 인수를 비교할 수 있습니다. 비교가 참이면 테스트가 통과되고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="86179df6c35646296ecd922e347bf8fb4cdc3c6c" translate="yes" xml:space="preserve">
          <source>Hand-editing</source>
          <target state="translated">Hand-editing</target>
        </trans-unit>
        <trans-unit id="2243466296e92364f7bf27ac345ae2a71eab76a8" translate="yes" xml:space="preserve">
          <source>Handle is open.</source>
          <target state="translated">핸들이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb0ae5137688cc1b8e62808a86d332a61061726" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt; .</source>
          <target state="translated">컴파일 타임 범위 항목을 처리합니다. 블록 종료시 힌트를 복원하고 어휘 변수 범위를 올바르게 만들기 위해 패드 시퀀스 번호를 처리합니다. 함께 사용할 수있는 savestack 인덱스를 돌려줍니다 &lt;code&gt;block_end&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="aadca6115d853e86175413031bcfebcbec35442a" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit.</source>
          <target state="translated">컴파일 타임 범위 종료를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a78a213e08f22079d0727d65ee7cd82040828af3" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">쓰기 전용으로 열린 핸들은 작동하지 않습니다. 읽기 전용으로 열린 핸들은 배열을 수정하려고 시도하지 않는 한 작동합니다. 검색 가능한 데이터 소스에 핸들을 부착해야합니다. 즉 파이프 나 소켓이 없다는 의미입니다. 경우 &lt;code&gt;Tie::File&lt;/code&gt; 가 아닌 시크 핸들을 공급 것을 감지 할 수 있으며, &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 예외가 발생합니다. (유닉스 시스템에서는이를 감지 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3dca08a90c7ec673523c972aeb9655cc6ba04e87" translate="yes" xml:space="preserve">
          <source>Handles the installing and uninstalling of perl modules, scripts, man pages, etc...</source>
          <target state="translated">perl 모듈, 스크립트, 매뉴얼 페이지 등의 설치 및 제거를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="caa1714db5e5ddfa607afe3449dc66f6283180d0" translate="yes" xml:space="preserve">
          <source>Handling Duplicate Keys</source>
          <target state="translated">중복 키 처리</target>
        </trans-unit>
        <trans-unit id="0f01c504507d7832a1cac719e698e1e7e8a378a8" translate="yes" xml:space="preserve">
          <source>Handling Malformed Data</source>
          <target state="translated">잘못된 데이터 처리</target>
        </trans-unit>
        <trans-unit id="f0f0fc76a1e441991cde68774fcefb6a0861fb18" translate="yes" xml:space="preserve">
          <source>Handling Unicode</source>
          <target state="translated">유니 코드 처리</target>
        </trans-unit>
        <trans-unit id="5c331b1b1b146d85b0798abcb652f4dbd9cc2a65" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">유니 코드 처리는 대부분 투명합니다. 평소와 같이 문자열을 사용하십시오. &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 유니 코드 문자에서 작동합니다. 정규식은 유니 코드 문자에서 작동합니다 ( &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 및 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="88d69acff614c1d827ede2f260f6a46a48647c42" translate="yes" xml:space="preserve">
          <source>Handling simple options is straightforward:</source>
          <target state="translated">간단한 옵션 처리는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8e71d792bc3c7ca46b9ebe6e4e08dc39ffe6877b" translate="yes" xml:space="preserve">
          <source>Handling the SIGHUP Signal in Daemons</source>
          <target state="translated">데몬에서 SIGHUP 신호 처리</target>
        </trans-unit>
        <trans-unit id="6e120aed62a343cea2462c78b0c345bd93d57340" translate="yes" xml:space="preserve">
          <source>Handy Values</source>
          <target state="translated">편리한 가치</target>
        </trans-unit>
        <trans-unit id="049503c569a7548e0e0aaf7ff650cdb7e260c634" translate="yes" xml:space="preserve">
          <source>Handy for putting in notes which might be useful for debugging, but don't indicate a problem.</source>
          <target state="translated">디버깅에 유용 할 수있는 메모를 작성하는 데 유용하지만 문제를 나타내지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57d70b3a1b3e8f06b27f21ad6f5e77255bd44b1f" translate="yes" xml:space="preserve">
          <source>Handy for things like...</source>
          <target state="translated">다음과 같은 것들에 편리합니다 ...</target>
        </trans-unit>
        <trans-unit id="04a45a64a65bd1462cbe3b6ef2c3619b7fc7d816" translate="yes" xml:space="preserve">
          <source>Handy for this sort of thing:</source>
          <target state="translated">이런 종류의 일에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="eb631afbbf9621a14aebc98eacec8ff594f19f3b" translate="yes" xml:space="preserve">
          <source>Handy tip: put &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; in your</source>
          <target state="translated">핸디 팁 : 넣어 &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="951499a6cfa4736aa7a1d36a7019e79078429a7e" translate="yes" xml:space="preserve">
          <source>HangulSyllableType.txt</source>
          <target state="translated">HangulSyllableType.txt</target>
        </trans-unit>
        <trans-unit id="dc5f45cb92e25fd3e9f4ed85dddd70a19341bbf4" translate="yes" xml:space="preserve">
          <source>Hard and symbolic (&quot;soft&quot;) links; linkname should specify target.</source>
          <target state="translated">단단하고 상징적 인 ( &quot;소프트&quot;) 링크; linkname은 target을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdae1ec5d05114509a53fe67f0320c6eadea6400" translate="yes" xml:space="preserve">
          <source>Hard links are implemented on Win32 under NTFS only. They are natively supported on Windows 2000 and later. On Windows NT they are implemented using the Windows POSIX subsystem support and the Perl process will need Administrator or Backup Operator privileges to create hard links.</source>
          <target state="translated">하드 링크는 NTFS에서만 Win32에 구현됩니다. Windows 2000 이상에서 기본적으로 지원됩니다. Windows NT에서는 Windows POSIX 서브 시스템 지원을 사용하여 구현되며 Perl 프로세스는 하드 링크를 작성하려면 관리자 또는 백업 운영자 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7cec0c304aaf210bfe25cbb78814c09191b199ee" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;Circular References&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">하드 참조는 영리합니다. 참조 카운트를 추적하여 참조 카운트가 0이 될 때 참조되는 것을 자동으로 해제합니다. (자기 참조 또는 순환 데이터 구조의 값에 대한 참조 수는 약간의 도움 없이는 0이되지 않을 수 있습니다 . 자세한 설명 은 &lt;a href=&quot;#Circular-References&quot;&gt;순환 참조&lt;/a&gt; 를 참조 하십시오 .) 해당 항목이 오브젝트 인 경우 오브젝트가 파괴됩니다. 오브젝트에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 . 어떤 의미에서 Perl의 모든 것은 객체이지만, 우리는 일반적으로 클래스 패키지에 공식적으로 &quot;축복 된&quot;객체에 대한 단어를 예약합니다.</target>
        </trans-unit>
        <trans-unit id="66e944742ea0249f6f2a6fd52c3e9e415e65aaeb" translate="yes" xml:space="preserve">
          <source>Harness output delegate for default console output</source>
          <target state="translated">기본 콘솔 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="2dd2c2e596e19cb5f6f12eac61588cccdf06ec03" translate="yes" xml:space="preserve">
          <source>Harness output delegate for file output</source>
          <target state="translated">파일 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="363bd8bca1592722722a3ac3fe8ee3189add2d7b" translate="yes" xml:space="preserve">
          <source>Harness output delegate for parallel console output</source>
          <target state="translated">병렬 콘솔 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="ba951792ddfec9b17fd8944b4026a028108c3aa1" translate="yes" xml:space="preserve">
          <source>Has already been</source>
          <target state="translated">이미되었습니다</target>
        </trans-unit>
        <trans-unit id="d8861f9d9089d32f3fb836f33024a00d9824a27b" translate="yes" xml:space="preserve">
          <source>Has global effect, persists after the application exits.</source>
          <target state="translated">전역 효과가 있으며 응용 프로그램이 종료 된 후에도 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="d791fc07c3f03c0d15e5cd282a309f1887be4bb0" translate="yes" xml:space="preserve">
          <source>Has it been done before?</source>
          <target state="translated">전에 한 적이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2929382f580bfdd31a77bfbbda12fefbb2e9c2b6" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; ,&lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , or &lt;code&gt;\F&lt;/code&gt; .</source>
          <target state="translated">일치 연산자와 동일한 동작을합니다. 또한 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 양식이 적용되는 경우 이전 피연산자 에서 언급 된 것 중 하나를 포함하는 정규식 일치를 기반으로 한 대체 결과로 수정 된 경우 &lt;code&gt;=~&lt;/code&gt; 의 왼쪽 피연산자 가 오염됩니다. 같은 -mapping &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e911d125c069efa7d913b344e0f08f8969421a" translate="yes" xml:space="preserve">
          <source>Hash API Extensions</source>
          <target state="translated">해시 API 확장</target>
        </trans-unit>
        <trans-unit id="ffc5f6e94a276eeaf94de20a0e4f426d64a6723d" translate="yes" xml:space="preserve">
          <source>Hash Algorithm - Hash algorithms like the one used in Perl are well known to be vulnerable to collision attacks on their hash function. Such attacks involve constructing a set of keys which collide into the same bucket producing inefficient behavior. Such attacks often depend on discovering the seed of the hash function used to map the keys to buckets. That seed is then used to brute-force a key set which can be used to mount a denial of service attack. In Perl 5.8.1 changes were introduced to harden Perl to such attacks, and then later in Perl 5.18.0 these features were enhanced and additional protections added.</source>
          <target state="translated">해시 알고리즘-Perl에서 사용되는 것과 같은 해시 알고리즘은 해시 함수에 대한 충돌 공격에 취약한 것으로 잘 알려져 있습니다. 이러한 공격에는 비효율적 인 동작을 생성하는 동일한 버킷에 충돌하는 일련의 키 구성이 포함됩니다. 이러한 공격은 종종 키를 버킷에 매핑하는 데 사용되는 해시 함수의 시드를 찾는 데 달려 있습니다. 그런 다음이 시드는 서비스 거부 공격을 마운트하는 데 사용할 수있는 키 세트를 무차별 화하는 데 사용됩니다. Perl 5.8.1에서는 Perl을 이러한 공격으로 강화하기 위해 변경 사항이 도입되었으며 나중에 Perl 5.18.0에서 이러한 기능이 향상되었으며 추가 보호 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f61062d96868959d8bad3f3f9d8706be2a8eb3f6" translate="yes" xml:space="preserve">
          <source>Hash Manipulation Functions</source>
          <target state="translated">해시 조작 함수</target>
        </trans-unit>
        <trans-unit id="305905caf9fb73ce326146ab6da346f5a44d3d5e" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38990845f56b0504f14a42e264d2e90a4529057f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다. 묶음 해시는 항목 삽입 및 삭제 순서의 변경과 관련하여 Perl의 해시와 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c5186b59e1d86cc131a1fce52452e4e4a1c3b7" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ca36bf1a5daf8ef9f034a1d277717a3712e5c2" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다. 묶음 해시는 항목 삽입 및 삭제 순서의 변경과 관련하여 Perl의 해시와 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="450c7d18d41b71db86a014ec4874cb370e9139cb" translate="yes" xml:space="preserve">
          <source>Hash keys are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">해시 키는 오염 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb008d092d1635eab043a4b8199104071bf333" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">해시 키는 문자열이므로 실제로 참조를 키로 사용할 수 없습니다. 그렇게하려고 시도하면 perl은 참조를 문자열 형식으로 바꿉니다 (예 : &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). 거기에서 최소한 자체적으로 추가 작업을 수행하지 않으면 문자열 형식의 참조를 다시 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="28bd740a5fed92f4652182fc91352eb825ae6b82" translate="yes" xml:space="preserve">
          <source>Hash subscripts are similar, only instead of square brackets curly brackets are used. For example:</source>
          <target state="translated">해시 첨자는 비슷하지만 대괄호 대신 중괄호가 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f05d6e4a748b9c8f33a3dd349b88ed9bc020a76" translate="yes" xml:space="preserve">
          <source>Hash values do not spring into existence upon mere reference.</source>
          <target state="translated">해시 값은 단순한 참조로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="060e2951a35019d6292c77892149e6ae4655ab4b" translate="yes" xml:space="preserve">
          <source>Hash::Util</source>
          <target state="translated">Hash::Util</target>
        </trans-unit>
        <trans-unit id="6df60ce76a6dd2245295b960eb619bae5a40a333" translate="yes" xml:space="preserve">
          <source>Hash::Util - A selection of general-utility hash subroutines</source>
          <target state="translated">Hash :: Util-일반 유틸리티 해시 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="fc6dfd7516cd148dfcfbc9b4b53977f84b109b02" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash</source>
          <target state="translated">Hash::Util::FieldHash</target>
        </trans-unit>
        <trans-unit id="2761eb764ac1f31cb8db8bfca9f4810ccd72d904" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash - Support for Inside-Out Classes</source>
          <target state="translated">Hash :: Util :: FieldHash-인사이드 아웃 클래스 지원</target>
        </trans-unit>
        <trans-unit id="5003cfd9a645097d80f1b1984336d3badcf5c150" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) being in the hash.</source>
          <target state="translated">해시는 스칼라 쌍을 포함합니다. 첫 번째는 키이고 두 번째는 값입니다. 키는 문자열로 강제 변환되지만 값은 문자열, 숫자 또는 참조의 모든 종류의 스칼라 일 수 있습니다. 키 &lt;code&gt;$key&lt;/code&gt; 가 % hash에 있으면 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; 가 true를 반환합니다. 주어진 키에 대한 값은 다음과 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 있는 경우, &lt;code&gt;$hash{$key}&lt;/code&gt; 될 것 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; true를 돌려줍니다. 이것은 해시에있는 ( &lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a5674cfb04f68937d23325c6f7c4d9203e5e6faf" translate="yes" xml:space="preserve">
          <source>Hashes have no particular internal order, though you can sort the keys and loop through them.</source>
          <target state="translated">해시는 특정 내부 순서가 없지만 키를 정렬하고 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a5b7f57189106155ae1686164009308c7fb48e" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context. UNTIE is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">해시는 연결될 첫 번째 Perl 데이터 유형입니다 (dbmopen () 참조). 연결 해시를 구현하는 클래스는 다음 메소드를 정의해야합니다. TIEHASH는 생성자입니다. FETCH 및 STORE는 키 및 값 쌍에 액세스합니다. EXISTS는 키가 해시에 있는지 여부를보고하고 DELETE는 키를 삭제합니다. CLEAR는 모든 키와 값 쌍을 삭제하여 해시를 비 웁니다. FIRSTKEY 및 NEXTKEY는 모든 키를 반복하기 위해 keys () 및 each () 함수를 구현합니다. 스칼라 컨텍스트에서 연결된 해시가 평가되면 SCALAR가 트리거됩니다. &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 가 발생 하면 UNTIE가 호출 되고, 묶인 변수가 가비지 수집 될 때 DESTROY가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="00ee967aadbfebd86b3235daf9d26b53205682c3" translate="yes" xml:space="preserve">
          <source>Hashing order and checksums</source>
          <target state="translated">해싱 순서 및 체크섬</target>
        </trans-unit>
        <trans-unit id="3f4d761db68098a751847d9083882bbf309c01a1" translate="yes" xml:space="preserve">
          <source>Hashref of .pm files and *.pl files to be installed. e.g.</source>
          <target state="translated">.pm 파일 및 * .pl 파일의 Hashref가 설치됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e654482e1464037d016cd8389b44c8067b3f7edd" translate="yes" xml:space="preserve">
          <source>Hashref of .xs files. MakeMaker will default this. e.g.</source>
          <target state="translated">.xs 파일의 해시 참조 MakeMaker가이를 기본값으로 설정합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="54306e4b7a73d064c3f0a92d38a328cc3c6fc248" translate="yes" xml:space="preserve">
          <source>Hashref of pod-containing files. MakeMaker will default this to all EXE_FILES files that include POD directives. The files listed here will be converted to man pages and installed as was requested at Configure time.</source>
          <target state="translated">포드 포함 파일의 해시 참조 MakeMaker는이를 기본적으로 POD 지시문이 포함 된 모든 EXE_FILES 파일로 설정합니다. 여기에 나열된 파일은 구성 페이지에서 요청한대로 매뉴얼 페이지로 변환되어 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="e03929c9c89c518c1a46f519dc21b0db453de58a" translate="yes" xml:space="preserve">
          <source>Hashref of symbol names for routines to be made available as universal symbols. Each key/value pair consists of the package name and an array of routine names in that package. Used only under AIX, OS/2, VMS and Win32 at present. The routine names supplied will be expanded in the same way as XSUB names are expanded by the XS() macro. Defaults to</source>
          <target state="translated">루틴에 대한 기호 이름의 Hashref는 범용 기호로 사용 가능합니다. 각 키 / 값 쌍은 패키지 이름과 해당 패키지의 루틴 이름 배열로 구성됩니다. 현재 AIX, OS / 2, VMS 및 Win32에서만 사용됩니다. 제공된 루틴 이름은 XSUB 이름이 XS () 매크로에 의해 확장되는 것과 같은 방식으로 확장됩니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="0e5b1d03af67cbc5ad483521c6061ce63fe7c5e2" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">맨 페이지를 작성할 파일을 * .pm 및 * .pod 파일에 할당하는 Hashref MakeMaker는 POD 지시문에 대한 모든 * .pod 및 * .pm 파일을 구문 분석합니다. POD를 포함하는 파일은 MAN3PODS hashref의 기본 키입니다. 그런 다음 &lt;code&gt;make&lt;/code&gt; 동안 make 페이지로 변환되고 &lt;code&gt;make install&lt;/code&gt; 중에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c40a20db4b296ec67dfa94b908457cfde4c540" translate="yes" xml:space="preserve">
          <source>Have a .ucm file ready. You can get it from somewhere or you can write your own from scratch or you can grab one from the Encode distribution and customize it. For the UCM format, see the next Chapter. In the example below, I'll call my theoretical encoding myascii, defined in</source>
          <target state="translated">.ucm 파일을 준비하십시오. 어딘가에서 가져 오거나 처음부터 직접 작성할 수도 있고 Encode 배포판에서 가져 와서 사용자 정의 할 수도 있습니다. UCM 형식에 대해서는 다음 장을 참조하십시오. 아래 예제에서는 이론적 인코딩 myascii를</target>
        </trans-unit>
        <trans-unit id="7e1aafb3365aa620ad71622b6d9e66ff51332860" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;code&gt;look&lt;/code&gt; (!) command.</source>
          <target state="translated">상기 모습이 &lt;code&gt;look&lt;/code&gt; (!) 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d27c15838302800e87f5a9ade00864fd9b117bc" translate="yes" xml:space="preserve">
          <source>Have a look at the CPAN::Site module.</source>
          <target state="translated">CPAN :: Site 모듈을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="2682f428ec2cd20e9cdf6753b7db50d45fa0c287" translate="yes" xml:space="preserve">
          <source>Have you got it right?</source>
          <target state="translated">맞습니까?</target>
        </trans-unit>
        <trans-unit id="3d1c0002422cc934d4f43ea061dac2a317b36bcc" translate="yes" xml:space="preserve">
          <source>Have you looked at CPAN (see &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;)? The chances are that someone has already written a module that can solve your problem. Have you read the appropriate manpages? Here's a brief index:</source>
          <target state="translated">CPAN을 살펴 보셨습니까 ( &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 참조 )? 누군가가 이미 문제를 해결할 수있는 모듈을 작성했을 가능성이 있습니다. 적절한 맨 페이지를 읽었습니까? 다음은 간단한 색인입니다.</target>
        </trans-unit>
        <trans-unit id="fea81edd1a4ca564780d9031bb647dc99cf58fa7" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others. If in any doubt ask for suggestions in comp.lang.perl.misc.</source>
          <target state="translated">Sort라는 57 개의 모듈을 모두 가지고 있어도 누구나 쉽게 사용할 수 없습니다 (Sort :: Quick이라는 23 개의 모듈을 사용하는 것이 약간 나아질 것입니다 :-). 다른 사람과 함께 모듈을 설치하려고하는 사람을 상상해보십시오. 의심스러운 경우 comp.lang.perl.misc에 제안을 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c3a74f90c179abbbb2a8aabfd9df58154dbdba" translate="yes" xml:space="preserve">
          <source>Having PERLDOCDEBUG set to a positive integer will make perldoc emit even more descriptive output than the &lt;code&gt;-D&lt;/code&gt; switch does; the higher the number, the more it emits.</source>
          <target state="translated">PERLDOCDEBUG를 양의 정수로 설정하면 perldoc이 &lt;code&gt;-D&lt;/code&gt; 스위치 보다 더 설명적인 출력을 방출합니다 . 숫자가 높을수록 더 많이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="475dd7f4c80bb5dca06b4bee66ecdd1370715023" translate="yes" xml:space="preserve">
          <source>Having RSX and the latest</source>
          <target state="translated">RSX 및 최신</target>
        </trans-unit>
        <trans-unit id="831389895e5cb7d92cb0b30b5f20a040e5b28ad0" translate="yes" xml:space="preserve">
          <source>Having a comma after the last element of an enum list</source>
          <target state="translated">열거 형 목록의 마지막 요소 뒤에 쉼표가있는 경우</target>
        </trans-unit>
        <trans-unit id="eb3a777ac79c8871a640c69bcf5b76d7b538148e" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">의미가 있습니다. Perl은 사람들이하려고하는 일 중 일부는 의미가 없다고 생각합니다. 특히, &lt;b&gt;값을&lt;/b&gt; 지정하지 않은 변수를 사용 하고 존재하지 않는 데이터에 대해 특정 작업을 수행합니다. 예를 들어, 파일 끝을 지나서 데이터를 읽으려고하면 Perl이 정의되지 않은 값을 전달합니다. Camel 챕터 27,&amp;ldquo;함수&amp;rdquo;의 &lt;b&gt;거짓&lt;/b&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf9f1d17b3780ae4ae6a7c92cd0343417040db2e" translate="yes" xml:space="preserve">
          <source>Having done your bit, please be prepared to wait, to be told the bug is in your code, or possibly to get no reply at all. The volunteers who maintain Perl are busy folks, so if your problem is an obvious bug in your own code, is difficult to understand or is a duplicate of an existing report, you may not receive a personal reply.</source>
          <target state="translated">비트를 마친 후에는 코드에 버그가 있거나 응답이 전혀 없을 때까지 기다리십시오. Perl을 유지 관리하는 자원 봉사자들은 바쁜 사람들이므로 문제가 자신의 코드에서 명백한 버그이거나 이해하기 어렵거나 기존 보고서의 복제본 인 경우 개인 응답을받지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61dfbdc92422646f02edc5b064d4a445a5156276" translate="yes" xml:space="preserve">
          <source>Having multiple DBM implementations makes it trivial to copy database formats:</source>
          <target state="translated">여러 DBM 구현이 있으면 데이터베이스 형식을 복사하는 것이 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a36716594c37d5edd82c337ce9f21f289c12c13" translate="yes" xml:space="preserve">
          <source>Having pseudo-process IDs be negative integers breaks down for the integer &lt;code&gt;-1&lt;/code&gt; because the wait() and waitpid() functions treat this number as being special. The tacit assumption in the current implementation is that the system never allocates a thread ID of &lt;code&gt;1&lt;/code&gt; for user threads. A better representation for pseudo-process IDs will be implemented in future.</source>
          <target state="translated">의사 프로세스 ID를 음수로 설정 하면 wait () 및 waitpid () 함수가이 숫자를 특수한 것으로 간주하므로 정수 &lt;code&gt;-1&lt;/code&gt; 에 대해 정수가 분해됩니다 . 현재 구현에서 암묵적인 가정은 시스템 이 사용자 스레드에 대해 스레드 ID &lt;code&gt;1&lt;/code&gt; 을 할당하지 않는다는 것 입니다. 의사 프로세스 ID에 대한 더 나은 표현은 향후에 구현 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fff5183df30472b7e88394295e20e9d8990e8e07" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt; . If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 를 읽으면 아마도 &lt;code&gt;$X&lt;/code&gt; 저장된 묶인 객체의 여분의 사본으로 인해 오류가 발생했을 것입니다 . 그렇지 않으면 &lt;b&gt;DB_File&lt;/b&gt; 소멸자 DESTROY가 호출 될 때까지 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="893bf15d4ad790d3a646d05f171a2db30641c0d1" translate="yes" xml:space="preserve">
          <source>Having threads support requires all of Perl and all of the XS modules in the Perl installation to be rebuilt; it is not just a question of adding the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module (i.e., threaded and non-threaded Perls are binary incompatible).</source>
          <target state="translated">스레드를 지원하려면 Perl 설치의 모든 Perl 및 모든 XS 모듈을 다시 빌드해야합니다. &lt;a href=&quot;threads&quot;&gt;쓰레드&lt;/a&gt; 모듈 을 추가하는 것의 문제가 아닙니다 (즉, 쓰레드 및 쓰레드가 아닌 Perls는 이진 호환되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="123977c7eddfac195115408ec1d6b6b93c199204" translate="yes" xml:space="preserve">
          <source>Having to do with numbers represented in base 2. That means there&amp;rsquo;s basically two numbers: 0 and 1. Also used to describe a file of &amp;ldquo;nontext&amp;rdquo;, presumably because such a file makes full use of all the binary bits in its bytes. With the advent of &lt;b&gt;Unicode&lt;/b&gt;, this distinction, already suspect, loses even more of its meaning.</source>
          <target state="translated">기본 2에 표시된 숫자와 관련이 있습니다. 이는 기본적으로 0과 1이라는 두 개의 숫자가 있음을 의미합니다.&amp;ldquo;비 텍스트&amp;rdquo;파일을 설명하는 데 사용됩니다. 아마도 이러한 파일은 바이트의 모든 이진 비트를 완전히 사용하기 때문입니다. &lt;b&gt;유니 코드&lt;/b&gt; 의 출현으로 , 이미 의심되는이 구별은 그 의미를 훨씬 더 많이 상실합니다.</target>
        </trans-unit>
        <trans-unit id="2a50b726078402c27e07b8c0e368389163cec09c" translate="yes" xml:space="preserve">
          <source>Having to even think about the &lt;code&gt;$^S&lt;/code&gt; variable in your exception handlers is simply wrong. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; as currently implemented invites grievous and difficult to track down errors. Avoid it and use an &lt;code&gt;END{}&lt;/code&gt; or CORE::GLOBAL::die override instead.</source>
          <target state="translated">예외 처리기에서 &lt;code&gt;$^S&lt;/code&gt; 변수에 대해 생각 해야하는 것은 단순히 잘못된 것입니다. 현재 구현 된 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 은 슬프고 어려운 오류를 추적합니다. 이를 피하고 대신 &lt;code&gt;END{}&lt;/code&gt; 또는 CORE :: GLOBAL :: die 대체를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9dd5e433024c5701e895446816548ab95da2bc1b" translate="yes" xml:space="preserve">
          <source>Hawai'ian</source>
          <target state="translated">Hawai'ian</target>
        </trans-unit>
        <trans-unit id="fec5f9830205e3861054b7879046770547986753" translate="yes" xml:space="preserve">
          <source>Head.U</source>
          <target state="translated">Head.U</target>
        </trans-unit>
        <trans-unit id="0c0e898a8ae956ef15e057a684b77851cb08216e" translate="yes" xml:space="preserve">
          <source>Head1 through head4 produce headings, head1 being the highest level. The text in the rest of this paragraph is the content of the heading. For example:</source>
          <target state="translated">Head1에서 head4까지는 표제를 생성하며 head1은 최상위 레벨입니다. 이 단락의 나머지 부분에있는 텍스트는 제목의 내용입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="967ca9215da8ba98cad45c97fab5f98884cce72e" translate="yes" xml:space="preserve">
          <source>Heading Content&quot; command or to a &quot;=item Item Content&quot; command. This specification does not specify what behavior should be in the case of a given document having several things all seeming to produce the same</source>
          <target state="translated">제목 내용 &quot;명령 또는&quot;= 항목 항목 내용 &quot;명령이 사양에서는 특정 문서가 모두 동일한 내용을 생성하는 것으로 보이는 여러 문서가있는 경우의 동작을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a7c06f07a69ec449fd37c3b79a4e6409f1c6971" translate="yes" xml:space="preserve">
          <source>Hearing the word &quot;in&quot; is an</source>
          <target state="translated">&quot;에&quot;라는 단어를 듣는 것은</target>
        </trans-unit>
        <trans-unit id="7801d25365100494fe3fa68254035e723fdad847" translate="yes" xml:space="preserve">
          <source>Hebrew; now it doesn't.</source>
          <target state="translated">헤브라이 사람; 지금은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84135281bd9f7278283b58aab96226bf3b6fa87a" translate="yes" xml:space="preserve">
          <source>Heed the moderators.</source>
          <target state="translated">중재자에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="a675c00310a9bb5810f1eb379886d21c46bbc50c" translate="yes" xml:space="preserve">
          <source>Help save the world! Share your code in a form that makes it easy to reuse.</source>
          <target state="translated">세상을 구하십시오! 재사용하기 쉬운 형태로 코드를 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="72b65259063cf5501bdb369bad55680bb3e05273" translate="yes" xml:space="preserve">
          <source>Help testing test modules built with Test::Builder</source>
          <target state="translated">Test :: Builder로 빌드 한 테스트 모듈 테스트 지원</target>
        </trans-unit>
        <trans-unit id="b604e9e00b8aff400d6b282c4559d7681123e27e" translate="yes" xml:space="preserve">
          <source>Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">Perl에서 구현 된 PerlIO 레이어를위한 헬퍼 클래스</target>
        </trans-unit>
        <trans-unit id="4057a75cb8ff5877d986e9f1a93f90da05a4393c" translate="yes" xml:space="preserve">
          <source>Helper for grok_number(), accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">grok_number ()의 헬퍼는 &quot;무한대&quot;또는 &quot;숫자가 아님&quot;의 다양한 철자법을 허용하며 다음 플래그 조합 중 하나를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d886854c3e45c23f2a67ad8886bba6332d21933" translate="yes" xml:space="preserve">
          <source>Helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils :: Constant의 도우미 함수</target>
        </trans-unit>
        <trans-unit id="537e8e5aa520f3bdee23b191d8b4efb107769f00" translate="yes" xml:space="preserve">
          <source>Helper routine for MM-&amp;gt;fixin(), overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">쉘에 의해 해석 될 실제 shebang 행이 없기 때문에 MM-&amp;gt; fixin ()의 헬퍼 루틴이 재정의되므로 $ Config {startperl} 앞에 추가하고 포함 할 수있는 모든 스위치에 대해 shebang 행 인수를 보존합니다 .</target>
        </trans-unit>
        <trans-unit id="754ebef25d2322da9a737d155f7bf715f1ba74eb" translate="yes" xml:space="preserve">
          <source>Helper subroutine for subdirs</source>
          <target state="translated">서브 디렉토리에 대한 헬퍼 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8a7149426bc5c4ad71c933b4d1d21cfffd9c3bea" translate="yes" xml:space="preserve">
          <source>Helpers for POD parsing and conversion</source>
          <target state="translated">POD 파싱 및 변환을위한 도우미</target>
        </trans-unit>
        <trans-unit id="a1d186be4c77271bc365d307a5b69f017e030f41" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;unimport&lt;/code&gt; 루틴에서 호출되는 &lt;b&gt;컴파일시&lt;/b&gt; 사용자의 코드.</target>
        </trans-unit>
        <trans-unit id="1698c95c1d69a8153fa73a579994fee537ea27f4" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt; .</source>
          <target state="translated">따라서 당신은 그것을 추상화하기 위해 다음과 같은 간단한 함수를 도출합니다. 주어진 두 정수 사이의 임의의 정수를 선택합니다 (포함). 예를 들어 &lt;code&gt;random_int_between(50,120)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc265d279911dd3bbb1e57f33ddb7cc94242a04f" translate="yes" xml:space="preserve">
          <source>Hence, at this point, the start of the buffer that we allocated lives at &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; in memory and the PV pointer is pointing into the middle of this allocated storage.</source>
          <target state="translated">따라서이 시점에서 우리가 할당 한 버퍼의 시작은 메모리의 &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; 에 있으며 PV 포인터는이 할당 된 스토리지의 중간을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="045ed35d9ead65236dd53e0cae88ac0c2f700143" translate="yes" xml:space="preserve">
          <source>Hence, checking &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; is the best way to see whether something is a scalar.</source>
          <target state="translated">따라서 &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; 를 확인하는 것이 스칼라인지 확인하는 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cb8da77ebcbcb4587ef2329234538c69cccafa62" translate="yes" xml:space="preserve">
          <source>Hence, on Mac OS, both</source>
          <target state="translated">따라서 Mac OS에서는 둘 다</target>
        </trans-unit>
        <trans-unit id="28d05e677bb92a81e181eb6f8a5252850baf1f6f" translate="yes" xml:space="preserve">
          <source>Hence, putting it all together:</source>
          <target state="translated">따라서 모든 것을 종합하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78ae19820d96f656888a032f8938f666eaec4599" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">따라서 목록 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 을 호출하는 목적은 지정된 각 추출기를 반복되는 나머지 문자열에 적용하여 처리 된 문자열을 가능한 많은 겹치지 않는 필드로 분할하는 것입니다. 따라서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 Perl의 &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 서브 루틴 의 일반화 된 형태입니다 .</target>
        </trans-unit>
        <trans-unit id="6e76b82b230d1b216ea5fc74faa050d88bd7bb1a" translate="yes" xml:space="preserve">
          <source>Henk P. Penning maintains a site that collects data about CPAN sites:</source>
          <target state="translated">Henk P. Penning은 CPAN 사이트에 대한 데이터를 수집하는 사이트를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7f6138ce4b63e599ea6c8a23a9a9d862a811b01c" translate="yes" xml:space="preserve">
          <source>Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt; - for the suggestion of creating directories recursively.</source>
          <target state="translated">Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt;-디렉토리를 재귀 적으로 생성 할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="1f2206fdca717cfb115864c58cfc1242ec1e8f30" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$ARTICLE&lt;/code&gt; 은 전역 (패키지) 스칼라 변수 여야하며 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8ff0824227f04d195446a9ca4c80c3a2f4841adc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$ARTICLE&lt;/code&gt; 은 전역 (패키지) 스칼라 변수 여야하며 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7adfbace1a84aad46b6dc65bb49ec212586f4854" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt; , but with opposite values.</source>
          <target state="translated">여기서 &lt;code&gt;--verbose&lt;/code&gt; 및 &lt;code&gt;--quiet&lt;/code&gt; 은 동일한 변수 &lt;code&gt;$verbose&lt;/code&gt; 제어 하지만 반대 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="869e9b788a94b86ab899941e02856974518155a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a 'tag team' handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">여기 &lt;code&gt;//g&lt;/code&gt; 및 &lt;code&gt;\G&lt;/code&gt; 한 정규 표현식에서 다른 문자열의 '태그 팀'핸드 오프를 만들 수 있습니다. 독립 하위 표현식이있는 정규 표현식은 문자열을 독립 하위 표현식으로 핸드 오프하고 문자열을 엔 클로징 정규 표현식으로 다시 핸드 오프하는 방식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="4b495cc26b10b4cfa7edd523e971b1223bc39631" translate="yes" xml:space="preserve">
          <source>Here again Perl works just like the shell in that the &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; clobbers an existing file.</source>
          <target state="translated">여기서 다시 Perl은 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 가 기존 파일을 클로버 한다는 점에서 쉘처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="0b249e3305de27f4ee7d8f5a9ef3f95983593269" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place.</source>
          <target state="translated">다음은 Perl의 기능 (일부 키워드 및 명명 된 연산자와 같은 기능처럼 보이는 기능 포함)을 범주별로 정렬 한 것입니다. 일부 기능은 둘 이상의 위치에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="86585cb3324adc532f3c4c9a1e007eedd102a2eb" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 유용한 통조림 레시피 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="213525a9716fa0289377679cccd7e684d87732e5" translate="yes" xml:space="preserve">
          <source>Here are a couple of possibilities:</source>
          <target state="translated">몇 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de690581aef8b0c61e87b43058be3d94a077aff4" translate="yes" xml:space="preserve">
          <source>Here are a few examples to demonstrate usage of Perl's benchmarking tools.</source>
          <target state="translated">다음은 Perl 벤치마킹 도구의 사용법을 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a8331c63f719d3fa459c3be0fc4500f91a2bc542" translate="yes" xml:space="preserve">
          <source>Here are a few examples which illustrate the key concepts - as such most of them are of little practical use.</source>
          <target state="translated">주요 개념을 설명하는 몇 가지 예는 다음과 같습니다. 대부분 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d45496eb99d38ab7ab859d9d23312ec9997a265" translate="yes" xml:space="preserve">
          <source>Here are a few hints for creating high-quality patches:</source>
          <target state="translated">다음은 고품질 패치를 생성하기위한 몇 가지 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="ee5bae63f174379946589f4804bf6cb746e57ff8" translate="yes" xml:space="preserve">
          <source>Here are a few notes on the C function</source>
          <target state="translated">다음은 C 함수에 대한 몇 가지 참고 사항입니다.</target>
        </trans-unit>
        <trans-unit id="4cf9a82c924ee686ad6e561bd6e1b0affa2a2991" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">다음은 몇 가지 간단한 예입니다. 먼저 여러 배열을 함수에 전달하고 모든 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 표시하여 이전의 모든 마지막 요소의 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="778c5e77d32e09526eea8078cdc25093f593316e" translate="yes" xml:space="preserve">
          <source>Here are a few ways, all painful, to deal with it:</source>
          <target state="translated">여기에 대처하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d368f7513a7890d1d9530618552892450a6a185" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at</source>
          <target state="translated">다음은 Berkeley DB FAQ에서 가져온 몇 가지 단어입니다.</target>
        </trans-unit>
        <trans-unit id="3de0d7b44e720bda0c9a25fbb58e38764c2a5fa0" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; in action:</source>
          <target state="translated">다음은 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b13167d0662ec600bc247b1050d48340c5a1f9fa" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">다음은 여러 종류의 파일 열기 예입니다. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 을 사용하는 사람들은 모두 &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 에서 상수를 가져 왔다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b269a27d981a83ad06f7f43ed4b5271ebb95e10" translate="yes" xml:space="preserve">
          <source>Here are examples of the constructors and the valid options available for DB_HASH, DB_BTREE and DB_RECNO respectively.</source>
          <target state="translated">다음은 각각 DB_HASH, DB_BTREE 및 DB_RECNO에 사용 가능한 생성자와 유효한 옵션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="feffd8fe1a5cbaddbff753bfdc84e56b03609303" translate="yes" xml:space="preserve">
          <source>Here are some code samples showing a possible usage of Storable:</source>
          <target state="translated">다음은 Storable의 가능한 사용법을 보여주는 코드 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="b97373427a9280cf0da7790f9dd7dc5b0d29339d" translate="yes" xml:space="preserve">
          <source>Here are some concerns to keep in mind when using an endianness modifier:</source>
          <target state="translated">엔디안 수정자를 사용할 때 명심해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c18e94a9efc11f05f3d5f2b6edc571204b41c5d4" translate="yes" xml:space="preserve">
          <source>Here are some examples of how that works on an ASCII platform:</source>
          <target state="translated">다음은 ASCII 플랫폼에서 작동하는 방법에 대한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca06cec84a9ef5e9ca766f7b0195777a639a43ed" translate="yes" xml:space="preserve">
          <source>Here are some examples of how to use these:</source>
          <target state="translated">사용 방법에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84bd37d6cce9f50a387d161b1db1876dd2e66de5" translate="yes" xml:space="preserve">
          <source>Here are some examples of that:</source>
          <target state="translated">그 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb016178c05ee24cc48ff8dddc178e709d61edd0" translate="yes" xml:space="preserve">
          <source>Here are some examples of usage of the &quot;cmd&quot; shell:</source>
          <target state="translated">&quot;cmd&quot;쉘 사용법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b17211739968de398ac6cabe7b5c9c6e7b2ffe53" translate="yes" xml:space="preserve">
          <source>Here are some examples that explain the reasons why certain results occur while handling infinity:</source>
          <target state="translated">다음은 무한대를 처리하는 동안 특정 결과가 발생하는 이유를 설명하는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="5a87004d684b1273adb1c5dad1a3b884a901f693" translate="yes" xml:space="preserve">
          <source>Here are some examples that you should be able to type into your command shell:</source>
          <target state="translated">다음은 명령 셸에 입력 할 수있는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="1ffece14922bda83136b1a5ca004aee395c4815b" translate="yes" xml:space="preserve">
          <source>Here are some further observations based on experiments: The C runtime breaks arguments at spaces and passes them to programs in argc/argv. Double quotes can be used to prevent arguments with spaces in them from being split up. You can put a double quote in an argument by escaping it with a backslash and enclosing the whole argument within double quotes. The backslash and the pair of double quotes surrounding the argument will be stripped by the C runtime.</source>
          <target state="translated">다음은 실험을 기반으로 한 추가 관찰 사항입니다. C 런타임은 공백에서 인수를 중단하고 argc / argv의 프로그램으로 전달합니다. 공백이있는 인수가 분리되지 않도록 큰 따옴표를 사용할 수 있습니다. 백 슬래시로 이스케이프 처리하고 큰 인수로 전체 인수를 묶으면 인수에 큰 따옴표를 넣을 수 있습니다. 인수를 둘러싼 백 슬래시와 큰 따옴표 쌍은 C 런타임에 의해 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0b595570315b5625b2174cdd7459401aaf7451f5" translate="yes" xml:space="preserve">
          <source>Here are some more examples; be aware that when using an explicit index, the &lt;code&gt;$&lt;/code&gt; may need escaping:</source>
          <target state="translated">다음은 몇 가지 예입니다. 명시 적 인덱스를 사용할 때 &lt;code&gt;$&lt;/code&gt; 는 이스케이프해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c694403eaca658591930c8c7c2bb34296f84a099" translate="yes" xml:space="preserve">
          <source>Here are some notable values:</source>
          <target state="translated">다음은 주목할만한 값입니다.</target>
        </trans-unit>
        <trans-unit id="cc7e40e86aef57a83594c5dfdd7f8a1c23f71b5f" translate="yes" xml:space="preserve">
          <source>Here are some other examples:</source>
          <target state="translated">다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5552dd4aff82cc5a2b99f42ba7a6d2949d5c6e2e" translate="yes" xml:space="preserve">
          <source>Here are some other functions:</source>
          <target state="translated">다른 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79024a11d0139db04c2facf9ae0e8d93da4c05aa" translate="yes" xml:space="preserve">
          <source>Here are some other more substantive style issues to think about:</source>
          <target state="translated">고려해야 할 다른 실질적인 스타일 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8de6ff6be7dbb16b2f90d46db02214f1b31982a4" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">다음은 구문 상 유효한 선언의 일부 샘플이며, perl에 의해 내부적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 호출 로 해석되는 방법에 대한 주석이 있습니다. 이 예제는 주로 패키지 정의 속성의 가능한 메소드 조회에 대해 &quot;적절한 패키지&quot;가 발견되는 방법을 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ef6c8462426b25783d9f2c73bd41688e54925d5" translate="yes" xml:space="preserve">
          <source>Here are some variants, most of which don't work:</source>
          <target state="translated">다음은 일부 변형이며 대부분 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0361977099d002d67600facecf96ac617d8167ef" translate="yes" xml:space="preserve">
          <source>Here are the current possible types, with short descriptions:</source>
          <target state="translated">간단한 설명과 함께 현재 가능한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67895007dd0c6840199574bcaf648ce79505acd6" translate="yes" xml:space="preserve">
          <source>Here are the methods for the DotFiles tied hash.</source>
          <target state="translated">다음은 DotFiles 연결 해시의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bdd9e497208f79834038783c1e02aab82a664f8b" translate="yes" xml:space="preserve">
          <source>Here are the methods:</source>
          <target state="translated">방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="308b3fd3c823fd8f4a8be7a1c05819c0bdbe51b4" translate="yes" xml:space="preserve">
          <source>Here are the places where Perl will assume &lt;code&gt;$_&lt;/code&gt; even if you don't use it:</source>
          <target state="translated">사용하지 않더라도 Perl이 &lt;code&gt;$_&lt;/code&gt; 가정하는 장소는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0a9a64ecb96bf415307190a704ba59f675ea62cc" translate="yes" xml:space="preserve">
          <source>Here are the possible keys for the hash:</source>
          <target state="translated">해시에 사용할 수있는 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="133a7307c88c0ca94d0fd77ce650ab97042a4831" translate="yes" xml:space="preserve">
          <source>Here are the quote-like operators that apply to pattern matching and related activities.</source>
          <target state="translated">패턴 일치 및 관련 활동에 적용되는 따옴표와 같은 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c59988c08aece7bd08debf7ada77c7366bd57099" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt; ; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 에서 사용되는 규칙은 다음과 같습니다 . 우리는 유닉스와 최대한 호환되도록 노력합니다.</target>
        </trans-unit>
        <trans-unit id="4aa7fef747fea48e4e4795cd9eaeefa09930bbdb" translate="yes" xml:space="preserve">
          <source>Here are the short and long forms of the values the &lt;code&gt;General Category&lt;/code&gt; property can have:</source>
          <target state="translated">다음은 &lt;code&gt;General Category&lt;/code&gt; 속성이 가질 수있는 짧고 긴 형식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="420394a2a2618e29901a0ab672922a30d23423d8" translate="yes" xml:space="preserve">
          <source>Here are the statistics for Perl 5.005_62 on my system:</source>
          <target state="translated">내 시스템의 Perl 5.005_62에 대한 통계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd03473c869638bd902e9d6b0f20d91be736706a" translate="yes" xml:space="preserve">
          <source>Here are the suggested ways of modifying your include path, including environment variables, run-time switches, and in-code statements:</source>
          <target state="translated">환경 변수, 런타임 스위치 및 코드 내 명령문을 포함하여 포함 경로를 수정하는 제안 된 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c09b558fc05cb8053f5a3187154e8896a601ad3a" translate="yes" xml:space="preserve">
          <source>Here are the ways that Perl knows that a string should be treated as Unicode:</source>
          <target state="translated">문자열을 유니 코드로 처리해야한다는 것을 Perl이 알고있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4358e9bb262d19ae65de17de5c9b7a341e07eea3" translate="yes" xml:space="preserve">
          <source>Here are what those parameters to the new() constructor mean:</source>
          <target state="translated">new () 생성자에 대한 매개 변수의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3c80c52da3a7596fb4bd95e7f557fcc03ea2102" translate="yes" xml:space="preserve">
          <source>Here documents are found in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. Check for these three things:</source>
          <target state="translated">여기에 문서가 &lt;a href=&quot;perlop&quot;&gt;perlop에&lt;/a&gt; 있습니다. 다음 세 가지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="484c5007fac2b871f4ec1de41d18168107149ae5" translate="yes" xml:space="preserve">
          <source>Here in our DotFiles example, we'll be careful not to let them try to overwrite the file unless they've called the clobber() method on the original object reference returned by tie().</source>
          <target state="translated">여기서는 DotFiles 예제에서 tie ()에 의해 반환 된 원래 객체 참조에서 clobber () 메서드를 호출하지 않는 한 파일을 덮어 쓰지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="47c02f53e38b9b0fb6a0ae2769d47d0a5b5b6556" translate="yes" xml:space="preserve">
          <source>Here is a DBM Filter that does it:</source>
          <target state="translated">이를 수행하는 DBM 필터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f525e8a25cabfe7d14de3785ff13475d1795d58b" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine which prints whatever parameters are passed to it.</source>
          <target state="translated">다음은 전달 된 매개 변수를 인쇄하는 Perl 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="45cd387e7d7083c724152df763a18216115c4120" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine,</source>
          <target state="translated">Perl 서브 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="badb362bb0ad7ef4caa28ee99b671c9b8a6d2d3a" translate="yes" xml:space="preserve">
          <source>Here is a brief checklist on how to use Maketext to localize applications:</source>
          <target state="translated">다음은 Maketext를 사용하여 응용 프로그램을 지역화하는 방법에 대한 간단한 점검 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e180555a648403b54c19cc98b95102cc9c7da450" translate="yes" xml:space="preserve">
          <source>Here is a code snippet to tell what &quot;word&quot; characters are in the current locale, in that locale's order:</source>
          <target state="translated">다음은 현재 로케일에있는 &quot;워드&quot;문자를 해당 로케일 순서로 알려주는 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="8cd600b00d9b275c1b848cf418f2f3dc7bc149f6" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface available:</source>
          <target state="translated">사용 가능한 인터페이스의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ffd58769a04701c527d60f25ae6cee8c3577aa1" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface:</source>
          <target state="translated">인터페이스 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86773bb3e419f5d3ec6cdc84464ead386b08f646" translate="yes" xml:space="preserve">
          <source>Here is a filter which a variation of the &lt;code&gt;Joe2Jim&lt;/code&gt; filter. As well as substituting all occurrences of &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; it keeps a count of the number of substitutions made in the context object.</source>
          <target state="translated">다음은 &lt;code&gt;Joe2Jim&lt;/code&gt; 필터 의 변형 된 필터입니다. &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 의 모든 발생 을 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 으로 대체 할뿐만 아니라 컨텍스트 오브젝트에서 작성된 대체 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4d0499c68821327c798829729804b1a0bcda02ab" translate="yes" xml:space="preserve">
          <source>Here is a formula to ensurrogate a Unicode character \x{10000} and above;</source>
          <target state="translated">다음은 유니 코드 문자 \ x {10000} 이상을 포괄하는 공식입니다.</target>
        </trans-unit>
        <trans-unit id="5e13ad2f9de57b9ee78127b86f1be789cace5f69" translate="yes" xml:space="preserve">
          <source>Here is a less often used example:</source>
          <target state="translated">덜 자주 사용되는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6f9d3fd360afdcd3acc8bec172ad26a0315b6d8" translate="yes" xml:space="preserve">
          <source>Here is a list of the common features of the anonymous sub and the &lt;code&gt;filter()&lt;/code&gt; method.</source>
          <target state="translated">다음은 익명 서브와 &lt;code&gt;filter()&lt;/code&gt; 메소드 의 공통 기능 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="1832b72be8a1d9f95753e5f4c415597ea4ff02d1" translate="yes" xml:space="preserve">
          <source>Here is a list of the valid options:</source>
          <target state="translated">유효한 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8914294fa8d99540ed79b9d165dee16297f1d6a9" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt; :</source>
          <target state="translated">다음은 &lt;code&gt;given&lt;/code&gt; 더 긴 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b951146917555dc2bff07eaf853fe90ebe90da08" translate="yes" xml:space="preserve">
          <source>Here is a more complete description of how &lt;code&gt;carp&lt;/code&gt; and &lt;code&gt;croak&lt;/code&gt; work. What they do is search the call-stack for a function call stack where they have not been told that there shouldn't be an error. If every call is marked safe, they give up and give a full stack backtrace instead. In other words they presume that the first likely looking potential suspect is guilty. Their rules for telling whether a call shouldn't generate errors work as follows:</source>
          <target state="translated">&lt;code&gt;carp&lt;/code&gt; 와 &lt;code&gt;croak&lt;/code&gt; 작동 방식에 대한 자세한 설명은 다음과 같습니다 . 그들이하는 일은 오류가 없어야한다는 말을하지 않은 함수 호출 스택을 호출 스택에서 검색하는 것입니다. 모든 통화가 안전하다고 표시되면 포기하고 전체 스택 역 추적을 제공합니다. 다시 말해 그들은 잠재적으로 보이는 최초의 용의자가 유죄라고 추정합니다. 호출이 오류를 발생시키지 않아야 하는지를 알려주는 규칙은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e9d5f1ad420c45c5ca7b8cd720763979928a0e80" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;).</source>
          <target state="translated">다음은 위에서 설명한 일부 방법을 사용하는보다 완전한 예입니다. 또한 직접 API 인터페이스를 사용 (참조하게 &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;는 API 인터페이스&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="481b0824c1ad273d7763f1ffdf818909caa88617" translate="yes" xml:space="preserve">
          <source>Here is a possible workaround: create a toplevel</source>
          <target state="translated">가능한 해결 방법은 다음과 같습니다. 최상위 수준을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aac02f3544d72b59392576f2e2d1edbb502cf904" translate="yes" xml:space="preserve">
          <source>Here is a real example. Netscape 2.0 keeps a record of the locations you visit along with the time you last visited them in a DB_HASH database. This is usually stored in the file</source>
          <target state="translated">다음은 실제 예입니다. Netscape 2.0은 사용자가 방문한 위치와 마지막으로 방문한 시간을 DB_HASH 데이터베이스에 기록합니다. 이것은 일반적으로 파일에 저장됩니다</target>
        </trans-unit>
        <trans-unit id="645c6ed6c5edc9279cd1369bce1c3b76531901ff" translate="yes" xml:space="preserve">
          <source>Here is a sample chunk of code to break up and put back together again some fixed-format input lines, in this case from the output of a normal, Berkeley-style ps:</source>
          <target state="translated">다음은 일반적인 버클리 스타일 ps의 출력에서 ​​일부 고정 형식 입력 행을 분리하고 다시 결합하는 샘플 코드입니다.</target>
        </trans-unit>
        <trans-unit id="38eab965034c311c9ba1e3fb718a8ef1f540a4a4" translate="yes" xml:space="preserve">
          <source>Here is a script that saves, redirects, and restores &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; using various methods:</source>
          <target state="translated">다음은 다양한 방법을 사용하여 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 을 저장, 리디렉션 및 복원하는 스크립트입니다 .</target>
        </trans-unit>
        <trans-unit id="bf170b2ef98b6313890763a8318d77c620c61ec2" translate="yes" xml:space="preserve">
          <source>Here is a script which uses it:</source>
          <target state="translated">이를 사용하는 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d109e8133d36be8ec27bcf8a10b412b1b37621e9" translate="yes" xml:space="preserve">
          <source>Here is a short breakdown of perl's operation:</source>
          <target state="translated">다음은 펄 운영에 대한 간단한 분석입니다.</target>
        </trans-unit>
        <trans-unit id="b641d2582f209503d29beece571a8e6d76517863" translate="yes" xml:space="preserve">
          <source>Here is a short example which shows how &lt;code&gt;IO::Select&lt;/code&gt; could be used to write a server which communicates with several sockets while also listening for more connections on a listen socket</source>
          <target state="translated">다음은 &lt;code&gt;IO::Select&lt;/code&gt; 사용하여 여러 소켓과 통신하는 서버를 작성하고 청취 소켓에서 더 많은 연결을 수신 하는 방법을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f42a88335a66627a85ff6a9bee66b1f0bc358b5d" translate="yes" xml:space="preserve">
          <source>Here is a short, but incomplete summary:</source>
          <target state="translated">짧지 만 불완전한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="120acde3518e6786e0d2c79e05b71648be345e7b" translate="yes" xml:space="preserve">
          <source>Here is a simple XSUB which illustrates the mechanics of calling both the &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; methods from C.</source>
          <target state="translated">다음은 C에서 &lt;code&gt;PrintID&lt;/code&gt; 및 &lt;code&gt;Display&lt;/code&gt; 메소드를 모두 호출하는 메커니즘을 보여주는 간단한 XSUB입니다 .</target>
        </trans-unit>
        <trans-unit id="fe479990bde1cedb7827b08a0b51384331185af7" translate="yes" xml:space="preserve">
          <source>Here is a simple constructor:</source>
          <target state="translated">다음은 간단한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="8cf9fcb79a6528df89e621ddbe45b24482b8eaf2" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how to add a new target to the generated Makefile:</source>
          <target state="translated">생성 된 Makefile에 새 대상을 추가하는 방법에 대한 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40cda83fc05639dd468f5eab757cfe3f54097a29" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">다음은 &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt; 코어 모듈을 사용하는 간단한 기술 예입니다 . 이 모듈은 내부 객체 구현을 지원하기 위해 코어에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="126689dd133c61c2158a4c313ed301c9a4876c96" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;Extra RECNO Methods&lt;/a&gt; for a workaround).</source>
          <target state="translated">다음은 RECNO를 사용하는 간단한 예입니다 (5.004_57 이전의 Perl 버전을 사용하는 경우이 예는 작동하지 않습니다 . 해결 &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;방법&lt;/a&gt; 은 추가 RECNO 메소드 참조 ).</target>
        </trans-unit>
        <trans-unit id="319b9d58a92f86f8037b1f0bce75684db1494b7b" translate="yes" xml:space="preserve">
          <source>Here is a skeleton for the</source>
          <target state="translated">여기에 대한 골격이 있습니다</target>
        </trans-unit>
        <trans-unit id="550484c98d2783ef867d760a633e2f2132a4d47b" translate="yes" xml:space="preserve">
          <source>Here is a snippet of XSUB which defines</source>
          <target state="translated">다음은 XSUB의 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="002abcfd840947931c322494ad132e91e82ebd0f" translate="yes" xml:space="preserve">
          <source>Here is a snippet of code that is loosely based on Tom Christiansen's</source>
          <target state="translated">다음은 Tom Christiansen의 느슨한 코드를 기반으로 한 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="45cde31767fc2f9538502554458696cb23085fa9" translate="yes" xml:space="preserve">
          <source>Here is a trivial XSUB which prints the context in which it is currently executing.</source>
          <target state="translated">다음은 현재 실행중인 컨텍스트를 인쇄하는 간단한 XSUB입니다.</target>
        </trans-unit>
        <trans-unit id="10eee1483a3720a88b88f2a6e6f0dd7de0f97165" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt; . It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">다음은 &lt;code&gt;deflate&lt;/code&gt; 사용의 간단한 예입니다 . 단순히 표준 입력을 읽고 수축시켜 표준 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="1868baee762e5828998b63475228ea8991afb128" translate="yes" xml:space="preserve">
          <source>Here is a very brief example of a policy module that expires each cache item after ten seconds.</source>
          <target state="translated">다음은 10 초 후에 각 캐시 항목을 만료시키는 정책 모듈의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7f88bfdf5db7c3c03b6f8f2495da889972cfe524" translate="yes" xml:space="preserve">
          <source>Here is a very spartan uudecoder that will work on EBCDIC:</source>
          <target state="translated">다음은 EBCDIC에서 작동하는 스파르타 우 데코더입니다.</target>
        </trans-unit>
        <trans-unit id="d946c977086b5be12c98dcb6ff1ce5c76b228d28" translate="yes" xml:space="preserve">
          <source>Here is an efficient way to delete all files that haven't been modified for at least a week:</source>
          <target state="translated">적어도 일주일 동안 수정되지 않은 모든 파일을 삭제하는 효율적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70fccfa6b6af36450513847e29399b60a48adeac" translate="yes" xml:space="preserve">
          <source>Here is an example from big5-eten.</source>
          <target state="translated">다음은 big5-eten의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e9c9019a4b9d1c2c747c162dad5a190290c7d35f" translate="yes" xml:space="preserve">
          <source>Here is an example of backtracking: Let's say you want to find the word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</source>
          <target state="translated">역 추적의 예는 다음과 같습니다. &quot;Food is the foo table&quot;문자열에서 &quot;foo&quot;다음에 나오는 단어를 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="ea40af6afb8d235271ee69af60576e5fd7626d85" translate="yes" xml:space="preserve">
          <source>Here is an example of how to access the option name and value from within a subroutine:</source>
          <target state="translated">다음은 서브 루틴 내에서 옵션 이름과 값에 액세스하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="205e5e253d5e8d9713777fb82bdd5445436cb1b6" translate="yes" xml:space="preserve">
          <source>Here is an example of how your own code can go broken:</source>
          <target state="translated">자신의 코드가 어떻게 깨질 수 있는지에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="748768cc7486ba197e2bf8648f0ea7277ae15d72" translate="yes" xml:space="preserve">
          <source>Here is an example of the script which &quot;calculates&quot; the side of circumscribed octagon using the above package:</source>
          <target state="translated">위 패키지를 사용하여 외접 팔각형의면을 &quot;계산&quot;하는 스크립트의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="404268aa749a8cb74398fcef4885ddfb5e393936" translate="yes" xml:space="preserve">
          <source>Here is an example of these principles in action:</source>
          <target state="translated">다음은 이러한 원칙의 실제 예입니다.</target>
        </trans-unit>
        <trans-unit id="d36af1892ac909ba4b83e53e087863bb90d56692" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;NVtime&lt;/code&gt; from C:</source>
          <target state="translated">다음은 C에서 &lt;code&gt;NVtime&lt;/code&gt; 을 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="7c9994bdad12e2f359f710fa2f6ef403d1effd52" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt; .</source>
          <target state="translated">다음은 &lt;code&gt;inflate&lt;/code&gt; 를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e2da397e1c17983df2e6041276a4e28620f94d" translate="yes" xml:space="preserve">
          <source>Here is an example of using an optional parameter to override the default buffer size.</source>
          <target state="translated">다음은 선택적 매개 변수를 사용하여 기본 버퍼 크기를 대체하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8f3c57546ccedafc9770a8f0efa81f37adc91294" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">다음은 &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; 선택적 매개 변수 목록을 사용하여 기본 버퍼 크기와 압축 수준을 재정의하는 예입니다. 다른 모든 옵션은 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87545ecf0b6e7815b60232cfb74673f436cd6fe1" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;deflateInit&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">다음은 &lt;code&gt;deflateInit&lt;/code&gt; 선택적 매개 변수 목록을 사용하여 기본 버퍼 크기 및 압축 레벨을 대체 하는 예입니다 . 다른 모든 옵션은 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="09d05a4a26dea0db21fa2d5b84da51786c319d41" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;inflateInit&lt;/code&gt; optional parameter to override the default buffer size.</source>
          <target state="translated">다음은 &lt;code&gt;inflateInit&lt;/code&gt; 선택적 매개 변수를 사용 하여 기본 버퍼 크기를 대체 하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c7cbd7a5ef78ce531e711de3f32a263a9851ff1b" translate="yes" xml:space="preserve">
          <source>Here is an example of using the filter:</source>
          <target state="translated">필터를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4ff3e36580b38b61c7a227d4955c81060aeb814" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Filter::sh&lt;/code&gt; 를 사용하는 예제 스크립트는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="012645975f14da1f34bb102f202aaf2953a30bc6" translate="yes" xml:space="preserve">
          <source>Here is an example script which uses the interface. It implements a</source>
          <target state="translated">다음은 인터페이스를 사용하는 스크립트 예입니다. 그것은 구현</target>
        </trans-unit>
        <trans-unit id="1cbf7c7be1c22fad45e3015eadd538010d85816f" translate="yes" xml:space="preserve">
          <source>Here is an example that makes use of this tie:</source>
          <target state="translated">이 타이를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8ff5767311ec468cc89661ca51ca82e04f18ab9" translate="yes" xml:space="preserve">
          <source>Here is an example that renames all c files to cpp.</source>
          <target state="translated">다음은 모든 c 파일의 이름을 cpp로 바꾸는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="80e0e9e4bb3140e634ddeaa722387560a0149a79" translate="yes" xml:space="preserve">
          <source>Here is an example to illustrate how the bits actually fall in place:</source>
          <target state="translated">다음은 비트가 실제로 어떻게 배치되는지 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d0e29b3fe9551af38ec63a152fe4f4ef139ee92e" translate="yes" xml:space="preserve">
          <source>Here is an example where a string containing blank-separated words, numbers and single dashes is to be split into its components. Using &lt;code&gt;/\s+/&lt;/code&gt; alone won't work, because spaces are not required between dashes, or a word or a dash. Additional places for a split are established by looking ahead and behind:</source>
          <target state="translated">다음은 공백으로 분리 된 단어, 숫자 및 단일 대시를 포함하는 문자열을 해당 구성 요소로 분할하는 예입니다. 사용 &lt;code&gt;/\s+/&lt;/code&gt; 혼자하지 않습니다 작업 공간은 대시 또는 단어 나 대시 사이에 필요하지 않기 때문에. 분할을위한 추가 장소는 앞뒤로보고 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b737180e2561bd5a0699f794a8b8783a4667057" translate="yes" xml:space="preserve">
          <source>Here is an example which illustrates the problem from a &lt;b&gt;DB_File&lt;/b&gt; perspective:</source>
          <target state="translated">다음은 &lt;b&gt;DB_File&lt;/b&gt; 관점 에서 문제점을 설명하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f644e6370d9a6fe28106ff279c08d32f76b322b7" translate="yes" xml:space="preserve">
          <source>Here is an extreme example. Consider the Fibonacci sequence, defined by the following function:</source>
          <target state="translated">다음은 극단적 인 예입니다. 다음 함수로 정의 된 피보나치 시퀀스를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="87cc084321780edd34384cbc3149445fe191a094" translate="yes" xml:space="preserve">
          <source>Here is an interesting idea that doesn't involve the Debug filter. Currently Perl subroutines have fairly limited support for formal parameter lists. You can specify the number of parameters and their type, but you still have to manually take them out of the &lt;code&gt;@_&lt;/code&gt; array yourself. Write a source filter that allows you to have a named parameter list. Such a filter would turn this:</source>
          <target state="translated">다음은 디버그 필터와 관련이없는 흥미로운 아이디어입니다. 현재 Perl 서브 루틴은 공식 매개 변수 목록에 대한 지원이 상당히 제한되어 있습니다. 매개 변수의 수와 유형을 지정할 수 있지만 여전히 수동으로 &lt;code&gt;@_&lt;/code&gt; 배열에서 직접 가져와야 합니다. 명명 된 매개 변수 목록을 가질 수있는 소스 필터를 작성하십시오. 그러한 필터는 이것을 돌릴 것입니다 :</target>
        </trans-unit>
        <trans-unit id="cdf048c5ea517c38dde03f3aa3ec4c135c3bd31b" translate="yes" xml:space="preserve">
          <source>Here is another real-life example. By default, whenever Perl writes to a DBM database it always writes the key and value as strings. So when you use this:</source>
          <target state="translated">또 다른 실제 예가 있습니다. 기본적으로 Perl은 DBM 데이터베이스에 쓸 때마다 항상 키와 값을 문자열로 기록합니다. 따라서 이것을 사용할 때 :</target>
        </trans-unit>
        <trans-unit id="25d95fcca3eab15fb28653dc8409bb9ada80176a" translate="yes" xml:space="preserve">
          <source>Here is how &lt;code&gt;Encode&lt;/code&gt; handles the UTF8 flag.</source>
          <target state="translated">다음은 &lt;code&gt;Encode&lt;/code&gt; 가 UTF8 플래그를 처리하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="89e87986f55aa1d049d1fc43e956c467b865ddf7" translate="yes" xml:space="preserve">
          <source>Here is how to query the database for the &lt;b&gt;de&lt;/b&gt; (Deutsch or German) locale.</source>
          <target state="translated">다음은 &lt;b&gt;de&lt;/b&gt; (Deutsch 또는 German) 로캘에 대한 데이터베이스를 쿼리하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="b74dc5032afa362c898993b212d8c65907cee21d" translate="yes" xml:space="preserve">
          <source>Here is how to use this module.</source>
          <target state="translated">이 모듈을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e417973919b13f8ed343cc33d50cf8bf18dd96fb" translate="yes" xml:space="preserve">
          <source>Here is how to write your native data out using UTF-8 (or UTF-EBCDIC) and then read it back in.</source>
          <target state="translated">다음은 UTF-8 (또는 UTF-EBCDIC)을 사용하여 기본 데이터를 작성한 후 다시 읽는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e23347f9a27415c41076a210002eea6fcec860f7" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 를 사용하는 &lt;code&gt;File&lt;/code&gt; 클래스 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd300984a980fc559dc1a1ab348f5e54e30db5c" translate="yes" xml:space="preserve">
          <source>Here is same snippet of code rewritten using &lt;code&gt;globmap&lt;/code&gt;</source>
          <target state="translated">다음은 &lt;code&gt;globmap&lt;/code&gt; 을 사용하여 다시 작성된 동일한 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="9d1d9e97293f2045a09f6d838c3b2ec8fb4c6f77" translate="yes" xml:space="preserve">
          <source>Here is some explanation of that format:</source>
          <target state="translated">그 형식에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6967e582bf81d06472d4e74fa87d3738c79e15a" translate="yes" xml:space="preserve">
          <source>Here is the Perl subroutine</source>
          <target state="translated">여기 Perl 서브 루틴이 있습니다</target>
        </trans-unit>
        <trans-unit id="c14eb5e60796cb8513e72c1a3dc8468ba095c078" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; . Overloaded arithmetic operators</source>
          <target state="translated">여기에 대한 답이 있습니다 : str ()의 경우, 과부하 이후 명시적인 재귀가 필요하지 않습니다 &lt;code&gt;.&lt;/code&gt; -operator는 기존 오버로드 된 연산자 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 대체됩니다 . 오버로드 된 산술 연산자</target>
        </trans-unit>
        <trans-unit id="0490d051b62ee770784e189641a4237c3b3f3c05" translate="yes" xml:space="preserve">
          <source>Here is the complete Debug filter:</source>
          <target state="translated">다음은 완전한 디버그 필터입니다.</target>
        </trans-unit>
        <trans-unit id="1389bf6f29596689df97762593fe5eec3e652d54" translate="yes" xml:space="preserve">
          <source>Here is the complete list of POP macros available, along with the types they return.</source>
          <target state="translated">다음은 사용 가능한 전체 POP 매크로 목록과 반환되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="41758a39c9a7b172d40507117ebc8d6513b795ee" translate="yes" xml:space="preserve">
          <source>Here is the crux of the problem. A side-effect of opening the &lt;b&gt;DB_File&lt;/b&gt; database in step 2 is that an initial block from the database will get read from disk and cached in memory.</source>
          <target state="translated">다음은 문제의 요점입니다. 2 단계 에서 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스 를 여는 부작용은 데이터베이스의 초기 블록을 디스크에서 읽고 메모리에 캐시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c51e4961cb27feed1f60a5e6765893809aef1e36" translate="yes" xml:space="preserve">
          <source>Here is the hooking interface:</source>
          <target state="translated">후킹 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a16851851d330cec48f9b8e9d6adc8c31c07b46b" translate="yes" xml:space="preserve">
          <source>Here is the list of options. Some options can be in short format (-f) or long (--from) one.</source>
          <target state="translated">다음은 옵션 목록입니다. 일부 옵션은 짧은 형식 (-f) 또는 긴 (--from) 옵션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a0c7a2e7021b69e05a0894a3173e1357ec31a3" translate="yes" xml:space="preserve">
          <source>Here is the list of things which may be &quot;broken&quot; on EMX (from EMX docs):</source>
          <target state="translated">EMX 문서에서 EMX에서 &quot;깨질 수있는&quot;항목의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ff240e57cd35b4f33c424da68af14cbdadb7f0a" translate="yes" xml:space="preserve">
          <source>Here is the module.</source>
          <target state="translated">다음은 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1061d133b7ebfd4153ef09e5ea8f0d70a6682093" translate="yes" xml:space="preserve">
          <source>Here is the output (split into several lines):</source>
          <target state="translated">다음은 출력입니다 (여러 줄로 분리).</target>
        </trans-unit>
        <trans-unit id="8d77260497f2dd38213b4c5d12c82639b7bb64d8" translate="yes" xml:space="preserve">
          <source>Here is the output from the code above.</source>
          <target state="translated">위 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afa8a8a3c0bd9e2f5b6e60996a561b236f9c8638" translate="yes" xml:space="preserve">
          <source>Here is the output from the script:</source>
          <target state="translated">다음은 스크립트의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="3165612e15dd81d081ad2ea3bdee303a0e8cef7a" translate="yes" xml:space="preserve">
          <source>Here is the output:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc7f872b555210687127240090558fcc03c8212f" translate="yes" xml:space="preserve">
          <source>Here is the relevant quote from the dbopen man page where it defines the use of the R_CURSOR flag with seq:</source>
          <target state="translated">다음은 dbopen 매뉴얼 페이지에서 seq와 함께 R_CURSOR 플래그의 사용을 정의하는 관련 인용문입니다.</target>
        </trans-unit>
        <trans-unit id="2219210520e554129a1633cb7206210581ad4e0f" translate="yes" xml:space="preserve">
          <source>Here is the sample C file:</source>
          <target state="translated">샘플 C 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b7d8db184d6d571b8ca9a214519cc03ef4c5e4a" translate="yes" xml:space="preserve">
          <source>Here is the script above rewritten using the &lt;code&gt;seq&lt;/code&gt; API method.</source>
          <target state="translated">다음은 &lt;code&gt;seq&lt;/code&gt; API 메소드를 사용하여 다시 작성된 위의 스크립트 입니다.</target>
        </trans-unit>
        <trans-unit id="2e67d178bb0da6449165979cec1cd5461e419a26" translate="yes" xml:space="preserve">
          <source>Here is the text of</source>
          <target state="translated">여기에 텍스트가 있습니다</target>
        </trans-unit>
        <trans-unit id="ff1b450e27d60fd1ad40e7bb902cfa0aa22a3e80" translate="yes" xml:space="preserve">
          <source>Here is what C has that Perl doesn't:</source>
          <target state="translated">펄이 가지고 있지 않은 C는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16fc2b68835145e65475f1bb3c3809808bf7eb3b" translate="yes" xml:space="preserve">
          <source>Here is yet another way to print your environment:</source>
          <target state="translated">환경을 인쇄하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d8ed8a023e586883874c39ef49b4107598cdc9c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;Rules data structure in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">여기 간단한 예가 있습니다. 데이터 구조 및 관련 glob 스타일 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;은 TAP :: Parser :: Scheduler의 규칙 데이터 구조를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac9540016a9d087f8c1a19391a980dab40c0a80" translate="yes" xml:space="preserve">
          <source>Here the first call caches the list (1,2,3,4,5,6,7). The second call does not really make sense. &lt;code&gt;Memoize&lt;/code&gt; cannot guess what behavior &lt;code&gt;iota&lt;/code&gt; should have in scalar context without actually calling it in scalar context. Normally &lt;code&gt;Memoize&lt;/code&gt;</source>
          <target state="translated">여기서 첫 번째 호출은 목록 (1,2,3,4,5,6,7)을 캐시합니다. 두 번째 전화는 실제로 의미가 없습니다. &lt;code&gt;Memoize&lt;/code&gt; 는 실제로 스칼라 컨텍스트에서 호출하지 않고 스칼라 컨텍스트에서 &lt;code&gt;iota&lt;/code&gt; 의 동작을 추측 할 수 없습니다 . 일반적으로 &lt;code&gt;Memoize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9449cd01fe2c1ad3593def47ef2650f44e48880d" translate="yes" xml:space="preserve">
          <source>Here the first line will load &lt;code&gt;Carp&lt;/code&gt;</source>
          <target state="translated">여기에 첫 번째 줄은 &lt;code&gt;Carp&lt;/code&gt; 를로드합니다</target>
        </trans-unit>
        <trans-unit id="5ec7a9d65cd4bf61cf8b315b7aa4990f3fbae6e4" translate="yes" xml:space="preserve">
          <source>Here the generated XS function returns nothing on success, and will die() with a meaningful error message on error.</source>
          <target state="translated">여기서 생성 된 XS 함수는 성공시 아무 것도 반환하지 않으며 오류시 의미있는 오류 메시지와 함께 die ()가됩니다.</target>
        </trans-unit>
        <trans-unit id="083a79c03137ba3c061edc8bbcb5ea85ceb9fdd1" translate="yes" xml:space="preserve">
          <source>Here the multi-argument form of pipe open() is preferred because the pattern and indeed even the filenames themselves might hold metacharacters.</source>
          <target state="translated">여기서는 파이프 인수 open ()의 다중 인수 형식이 선호됩니다. 패턴과 파일 이름 자체에도 메타 문자가 포함될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="84ce6346e023cfe513980b15261a23a5e8073bce" translate="yes" xml:space="preserve">
          <source>Here the number of bytes chopped off (1) is shown next as the OFFSET. The portion of the string between the &quot;real&quot; and the &quot;fake&quot; beginnings is shown in parentheses, and the values of &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; reflect the fake beginning, not the real one. (The first character of the string buffer happens to have changed to &quot;\1&quot; here, not &quot;1&quot;, because the current implementation stores the offset count in the string buffer. This is subject to change.)</source>
          <target state="translated">여기서 잘린 바이트 수 (1)가 다음에 오프셋으로 표시됩니다. &quot;실제&quot;와 &quot;가짜&quot;시작 사이의 문자열 부분은 괄호 안에 표시되며 &lt;code&gt;SvCUR&lt;/code&gt; 및 &lt;code&gt;SvLEN&lt;/code&gt; 의 값은 실제 시작이 아닌 가짜 시작을 반영합니다. 현재 구현에서는 문자열 버퍼에 오프셋 수를 저장하기 때문에 문자열 버퍼의 첫 번째 문자는 &quot;1&quot;이 아니라 &quot;\ 1&quot;로 변경되었습니다. 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f2e253f1bb4668aac3cfa34c16cf32f5c7d557" translate="yes" xml:space="preserve">
          <source>Here translator() is a subroutine which takes</source>
          <target state="translated">여기서 translator ()는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="69ad459c54b1acfe7be7330c75e06154ad271928" translate="yes" xml:space="preserve">
          <source>Here we can see a much more complex program, with various optimisations in play. At regnode 10 we see an example where a character class with only one character in it was turned into an &lt;code&gt;EXACT&lt;/code&gt; node. We can also see where an entire alternation was turned into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; node. As a consequence, some of the regnodes have been marked as optimised away. We can see that the &lt;code&gt;$&lt;/code&gt; symbol has been converted into an &lt;code&gt;EOL&lt;/code&gt; regop, a special piece of code that looks for &lt;code&gt;\n&lt;/code&gt; or the end of the string.</source>
          <target state="translated">여기서 우리는 다양한 최적화가 진행되는 훨씬 더 복잡한 프로그램을 볼 수 있습니다. regnode 10에서 문자가 하나만있는 문자 클래스가 &lt;code&gt;EXACT&lt;/code&gt; 노드 로 바뀌는 예를 볼 수 있습니다. 또한 전체 교대가 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 노드 로 전환 된 위치를 확인할 수 있습니다 . 결과적으로 일부 레지 노드는 최적화 된 것으로 표시되었습니다. &lt;code&gt;$&lt;/code&gt; 기호가 &lt;code&gt;\n&lt;/code&gt; 또는 문자열의 끝 을 찾는 특수 코드 인 &lt;code&gt;EOL&lt;/code&gt; regop 으로 변환되었음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e88298fdbd00bad0c423ba34b385ffbc4d523ec" translate="yes" xml:space="preserve">
          <source>Here we describe the internal form your code is converted to by Perl. Start with a simple example:</source>
          <target state="translated">여기에서는 코드가 Perl에 의해 변환되는 내부 양식에 대해 설명합니다. 간단한 예부터 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a54d30dda627090722af6ca7619feef7f811fd" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under AmigaOS.</source>
          <target state="translated">여기에서는 AmigaOS에서 Perl을 빌드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5a948596d25d15dea7b9635c0bba86ef5734411f" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under OS/2.</source>
          <target state="translated">여기서는 OS / 2에서 Perl을 빌드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0ac29b536b198edfced84637724dab1c5327400" translate="yes" xml:space="preserve">
          <source>Here we document the backslash sequences that don't fall in one of the categories above. These are:</source>
          <target state="translated">여기서 우리는 위의 범주 중 하나에 속하지 않는 백 슬래시 시퀀스를 문서화합니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="78599b796151b0cc81f36fe73ffc3c8ea3b46215" translate="yes" xml:space="preserve">
          <source>Here we list environment variables with are either OS/2- and DOS- and Win*-specific, or are more important under OS/2 than under other OSes.</source>
          <target state="translated">여기에는 OS / 2 및 DOS 및 Win *에 특정한 환경 변수가 나열되어 있거나 다른 OS보다 OS / 2에서 더 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2d28d2754acd9ac1365a8c90a3604a80ec81bb16" translate="yes" xml:space="preserve">
          <source>Here we list major changes which could make you by surprise.</source>
          <target state="translated">여기 놀라움으로 만들 수있는 주요 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa194969d86c572c4f360d304be10a58d841a2b" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt; . After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">여기서는 RETVAL을 처리 할 때 INPUT : 섹션에서 &lt;code&gt;MyObject&lt;/code&gt; 로 변환하고 MyObject 에서 변환 하면 전역 변수 &lt;code&gt;global_state&lt;/code&gt; 가 수정 된다고 가정합니다 . 이러한 변환이 수행 된 후에는 메모리 누수를 방지하기 위해 이전 &lt;code&gt;global_state&lt;/code&gt; 값을 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ed5c8e65b6eb8ae2e55830259cac345b514bb1" translate="yes" xml:space="preserve">
          <source>Here we'll create some files that will generate a test library. These will include a C source file and a header file. We'll also create a Makefile.PL in this directory. Then we'll make sure that running make at the Mytest2 level will automatically run this Makefile.PL file and the resulting Makefile.</source>
          <target state="translated">여기에서는 테스트 라이브러리를 생성 할 파일을 만듭니다. 여기에는 C 소스 파일과 헤더 파일이 포함됩니다. 이 디렉토리에 Makefile.PL도 작성합니다. 그런 다음 Mytest2 수준에서 make를 실행하면이 Makefile.PL 파일과 결과 Makefile이 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="930cec360a8de0d300404f1ae97c04e5862e5b86" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">여기에서는 typeglobs를 사용하여 심볼 테이블 앨리어싱을 수행합니다. 그러나 그것은 미묘한 미묘하고 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수를 사용하는 경우에도 작동하지 않습니다. 전역 만 ( &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 로 위장해도 ) 기호 테이블에 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="5ca4ef30e473f35ac20ca9ad8e996a139eaf86fb" translate="yes" xml:space="preserve">
          <source>Here we've created a reference to an anonymous array of three elements whose final element is itself a reference to another anonymous array of three elements. (The multidimensional syntax described later can be used to access this. For example, after the above, &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; would have the value &quot;b&quot;.)</source>
          <target state="translated">여기에서는 최종 요소 자체가 3 개의 요소로 구성된 익명의 다른 배열에 대한 참조 인 3 개의 요소로 구성된 익명 배열에 대한 참조를 만들었습니다. (나중에 설명 된 다차원 구문을 사용하여이를 액세스 할 수 있습니다. 예를 들어, 위의 &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; 값은 &quot;b&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="977db011c41d89278867b065d331c7d420016e2c" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt; , or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">다음은 Perl 시스템 추상화의 예입니다. 나중에 볼 수 있습니다 : &lt;code&gt;PerlMem_malloc&lt;/code&gt; 은 시스템의 &lt;code&gt;malloc&lt;/code&gt; 또는 Perl의 자체 &lt;code&gt;malloc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="afea48b05d5e51f5f1638375ce5b0e27610663a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a full program showing how to make use of locale-sensitive sorting, Unicode casing, and managing print widths when some of the characters take up zero or two columns, not just one column each time. When run, the following program produces this nicely aligned output:</source>
          <target state="translated">다음은 로케일 구분 정렬, 유니 코드 케이싱 및 인쇄 문자 관리 방법을 보여주는 전체 프로그램입니다. 매번 한 열이 아닌 일부 문자가 0 개 또는 2 개의 열을 차지할 때입니다. 실행될 때 다음 프로그램은 이처럼 잘 정렬 된 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a19b2363612bc52e7e1f472c3c8e257075049a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how to implicitly manage the translation; all encoding and decoding is done automatically, just as with streams that have a particular encoding attached to them:</source>
          <target state="translated">번역을 암시 적으로 관리하는 방법은 다음과 같습니다. 모든 인코딩 및 디코딩은 특정 인코딩이 첨부 된 스트림과 마찬가지로 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c2be9aec08f68310e7254caae4389bbea07c40" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt; , a little utility to cleanly remove an installed module.</source>
          <target state="translated">여기의 &lt;code&gt;modrm&lt;/code&gt; , 약간의 유틸리티는 정상적으로 설치된 모듈을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="acb297651ed81fb994c8862e1324045de85e7420" translate="yes" xml:space="preserve">
          <source>Here's a UDP program similar to the sample Internet TCP client given earlier. However, instead of checking one host at a time, the UDP version will check many of them asynchronously by simulating a multicast and then using select() to do a timed-out wait for I/O. To do something similar with TCP, you'd have to use a different socket handle for each host.</source>
          <target state="translated">다음은 앞서 제공된 샘플 인터넷 TCP 클라이언트와 유사한 UDP 프로그램입니다. 그러나 UDP 버전은 한 번에 하나의 호스트를 확인하는 대신 멀티 캐스트를 시뮬레이션 한 다음 select ()를 사용하여 I / O에 대한 시간 초과 대기를 수행하여 많은 호스트를 비동기식으로 확인합니다. TCP와 비슷한 작업을 수행하려면 각 호스트마다 다른 소켓 핸들을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f4b45b7c3f776b4fbc38fc3bb7e907362d3ca50" translate="yes" xml:space="preserve">
          <source>Here's a brief lead of how to upgrade the compiler to the latest level. Of course this is subject to changes. You can only upgrade versions from ftp-available updates if the first three digit groups are the same (in where you can skip intermediate unlike the patches in the developer snapshots of Perl), or to one version up where the &quot;base&quot; is available. In other words, the AIX compiler patches are cumulative.</source>
          <target state="translated">다음은 컴파일러를 최신 레벨로 업그레이드하는 방법에 대한 간단한 설명입니다. 물론 이것은 변경 될 수 있습니다. 처음 세 자리 그룹이 동일하거나 (Perl의 개발자 스냅 샷의 패치와 달리 중간 단계를 건너 뛸 수있는 경우) &quot;base&quot;를 사용할 수있는 한 버전으로 업그레이드 할 경우에만 ftp 사용 가능 업데이트에서 버전을 업그레이드 할 수 있습니다. 다시 말해, AIX 컴파일러 패치는 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="9083bbfd93bc36a0ba2fe1e425a822a01dff192a" translate="yes" xml:space="preserve">
          <source>Here's a brief recap of the options we covered:</source>
          <target state="translated">다음은 우리가 다룬 옵션에 대한 간략한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="b70c746e9664f4a89ae78b4bc44345a9debc8745" translate="yes" xml:space="preserve">
          <source>Here's a classic non-closure function-generating function:</source>
          <target state="translated">고전적인 비 폐쇄 함수 생성 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="737671b9935a9677418172be58d93041b2c042de" translate="yes" xml:space="preserve">
          <source>Here's a client that creates a TCP connection to the &quot;daytime&quot; service at port 13 of the host name &quot;localhost&quot; and prints out everything that the server there cares to provide.</source>
          <target state="translated">다음은 호스트 이름 &quot;localhost&quot;의 포트 13에서 &quot;daytime&quot;서비스에 대한 TCP 연결을 작성하고 해당 서버가 제공하는 모든 것을 인쇄하는 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="b9872b20edef13d184c9e33e7e54f0406f2852dd" translate="yes" xml:space="preserve">
          <source>Here's a diversion: copy &quot;runperl.bat&quot; to &quot;runperl&quot;, and type &quot;runperl&quot;. Explain the observed behavior, or lack thereof. :) Hint: .gnidnats llits er'uoy fi ,&quot;lrepnur&quot; eteled :tniH</source>
          <target state="translated">전환은 다음과 같습니다. &quot;runperl.bat&quot;를 &quot;runperl&quot;로 복사하고 &quot;runperl&quot;을 입력하십시오. 관찰 된 행동 또는 그 부족을 설명하십시오. :) 힌트 : .gnidnats ll'er'uoy fi, &quot;lrepnur&quot;eteled : tniH</target>
        </trans-unit>
        <trans-unit id="cf12c485957b201d4ea57553686d7cb0039dde88" translate="yes" xml:space="preserve">
          <source>Here's a list of the backslash sequences that are character classes. They are discussed in more detail below. (For the backslash sequences that aren't character classes, see &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.)</source>
          <target state="translated">다음은 문자 클래스 인 백 슬래시 시퀀스 목록입니다. 아래에서 더 자세히 설명합니다. 문자 클래스가 아닌 백 슬래시 시퀀스는 &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ab128180a319c2d07a98a10caf6a07254c0f651" translate="yes" xml:space="preserve">
          <source>Here's a list of the currently unsupported API, and also the version of Perl below which it is unsupported:</source>
          <target state="translated">현재 지원되지 않는 API 목록과 지원되지 않는 Perl 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33b154fc2c3c454de669961df32cf81dfe425d93" translate="yes" xml:space="preserve">
          <source>Here's a little program that generates all permutations of all the words on each line of input. The algorithm embodied in the &lt;code&gt;permute()&lt;/code&gt; function is discussed in Volume 4 (still unpublished) of Knuth's</source>
          <target state="translated">다음은 각 입력 줄에 모든 단어의 순열을 생성하는 작은 프로그램입니다. &lt;code&gt;permute()&lt;/code&gt; 함수에 구현 된 알고리즘 은 Knuth 's Volume 4 (여전히 게시되지 않음)에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac1edab256d838d310d923b4a7442c76a785939d" translate="yes" xml:space="preserve">
          <source>Here's a little program that's somewhat like fmt(1):</source>
          <target state="translated">다음은 fmt (1)과 비슷한 작은 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="fd6a03a6db0cc55634b2b495ac28f42a4ed52934" translate="yes" xml:space="preserve">
          <source>Here's a lovely Perlish solution by Larry Rosler. It exploits properties of bitwise xor on ASCII strings.</source>
          <target state="translated">Larry Rosler의 멋진 Perlish 솔루션입니다. ASCII 문자열에서 비트 xor의 속성을 이용합니다.</target>
        </trans-unit>
        <trans-unit id="c5fae574ad1367dcbd0544744e45226bb907e0c9" translate="yes" xml:space="preserve">
          <source>Here's a mailbox appender for BSD systems.</source>
          <target state="translated">다음은 BSD 시스템 용 메일 박스 어 펜더입니다.</target>
        </trans-unit>
        <trans-unit id="39554d786a12cee063a370b311126f557d404cc0" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt; . One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">보다 복잡한 예는 다음과 같습니다. &lt;code&gt;struct netconfig&lt;/code&gt; 가 클래스 &lt;code&gt;Net::Config&lt;/code&gt; 축복 되기를 원한다고 가정합니다 . 이를 수행하는 한 가지 방법은 밑줄 (_)을 사용하여 다음과 같이 패키지 이름을 구분하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef76926490bf6bc7991a173108bb3e76598bbc43" translate="yes" xml:space="preserve">
          <source>Here's a more extensive illustration using vec():</source>
          <target state="translated">다음은 vec ()를 사용하는보다 광범위한 그림입니다.</target>
        </trans-unit>
        <trans-unit id="9b21353c7b746d6125b0bd9ccdf2d5f6e32ae7e7" translate="yes" xml:space="preserve">
          <source>Here's a more sophisticated example of using %Config:</source>
          <target state="translated">% Config를 사용하는보다 정교한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79fc5a3fa5bc2df2e735e49c28e40c308b498181" translate="yes" xml:space="preserve">
          <source>Here's a much better web-page hit counter:</source>
          <target state="translated">훨씬 더 나은 웹 페이지 조회수 카운터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d392ab49a010fb0ac59f9f0078cb125cae17692b" translate="yes" xml:space="preserve">
          <source>Here's a partial table of features the different packages offer:</source>
          <target state="translated">서로 다른 패키지가 제공하는 기능의 일부 표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a14f9ddca1a8bfb40a30abc5c0f1b2c1f62eef" translate="yes" xml:space="preserve">
          <source>Here's a quick mapping for the utilities/modules, and their names for the $BLACKLIST, $METHOD_FAIL and other internal functions.</source>
          <target state="translated">다음은 유틸리티 / 모듈과 $ BLACKLIST, $ METHOD_FAIL 및 기타 내부 함수의 이름에 대한 빠른 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="cda00e934fa6376dbf363c4a7973b5685c850503" translate="yes" xml:space="preserve">
          <source>Here's a reservoir-sampling algorithm from the Camel Book:</source>
          <target state="translated">Camel Book의 저수지 샘플링 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e206bb004fc82d9ef3fcc3d4b1c49d6f3d42ac3" translate="yes" xml:space="preserve">
          <source>Here's a safe backtick or pipe open for read:</source>
          <target state="translated">다음은 읽을 수있는 안전한 백틱 또는 파이프입니다.</target>
        </trans-unit>
        <trans-unit id="a7cce3c8a9d58b666d239193afb2494a20bba3a2" translate="yes" xml:space="preserve">
          <source>Here's a sample TCP client using Internet-domain sockets:</source>
          <target state="translated">인터넷 도메인 소켓을 사용하는 샘플 TCP 클라이언트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c9e5f5e52c5d8da22662f4567979deb732ae0a9" translate="yes" xml:space="preserve">
          <source>Here's a sample Unix-domain client:</source>
          <target state="translated">다음은 샘플 Unix 도메인 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="d1aee0a8129cd8627dd813843d4743d6011f0d62" translate="yes" xml:space="preserve">
          <source>Here's a sample plugin, for your reference:</source>
          <target state="translated">다음은 참조 용 샘플 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="bee38889229a5c9d4ff45e0c3ab7e676e43a251f" translate="yes" xml:space="preserve">
          <source>Here's a sample program,</source>
          <target state="translated">다음은 샘플 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="705113e6af32ce6049ec614b7bd8ea0f06bc826f" translate="yes" xml:space="preserve">
          <source>Here's a sample showing how to create and use a record whose fields are of many different sorts:</source>
          <target state="translated">다음은 다양한 종류의 필드를 가진 레코드를 만들고 사용하는 방법을 보여주는 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="16fbac9b09446fb7fa1607fa6cbcd3cd579323e7" translate="yes" xml:space="preserve">
          <source>Here's a sample:</source>
          <target state="translated">샘플은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d48d2b1ee87d318b2f88933c600ad433cc38ac05" translate="yes" xml:space="preserve">
          <source>Here's a short bibliography courtesy of J&amp;uuml;rgen Christoffel:</source>
          <target state="translated">J&amp;uuml;rgen Christoffel의 짧은 참고 문헌은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b6db8c67bc1492d1475adb966fe40db79852b40" translate="yes" xml:space="preserve">
          <source>Here's a simple client that takes a remote host to fetch a document from, and then a list of files to get from that host. This is a more interesting client than the previous one because it first sends something to the server before fetching the server's response.</source>
          <target state="translated">다음은 원격 호스트가 문서를 가져오고 해당 호스트에서 가져올 파일 목록을 가져 오는 간단한 클라이언트입니다. 이것은 서버의 응답을 가져 오기 전에 먼저 서버로 무언가를 전송하기 때문에 이전 클라이언트보다 더 흥미로운 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="6d6b6f3994774d06d8f1e409ff389cf7bc440169" translate="yes" xml:space="preserve">
          <source>Here's a simple example of a switch based on pattern matching, lined up in a way to make it look more like a switch statement. We'll do a multiway conditional based on the type of reference stored in $whatchamacallit:</source>
          <target state="translated">다음은 패턴 일치를 기반으로 한 스위치의 간단한 예입니다. 스위치 문처럼 보이도록 정렬되어 있습니다. $ whatchamacallit에 저장된 참조 유형에 따라 다 방향 조건부를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="adf661fec1c7ed224422528dd69c23adb6998e67" translate="yes" xml:space="preserve">
          <source>Here's a simple example to illustrate the difference between the two range operators:</source>
          <target state="translated">다음은 두 범위 연산자의 차이점을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="24f0b23833358ef065f35cfbec9242ef09ccac71" translate="yes" xml:space="preserve">
          <source>Here's a simple program which converts between Celsius and Fahrenheit, it too has a problem:</source>
          <target state="translated">다음은 섭씨와 화씨를 변환하는 간단한 프로그램입니다. 문제도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0837b2c8d138afbded4f97677c64e44b344b5f56" translate="yes" xml:space="preserve">
          <source>Here's a simple-minded example program that rewrites its command-line parameters as integers correctly formatted in the current locale:</source>
          <target state="translated">다음은 명령 행 매개 변수를 현재 로케일에서 올바르게 형식화 된 정수로 다시 작성하는 간단한 예제 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f4b1ca0d619e6e130110c613ca994de9ad0679d7" translate="yes" xml:space="preserve">
          <source>Here's a small example showing shared memory usage.</source>
          <target state="translated">다음은 공유 메모리 사용량을 보여주는 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca0b16455dba662fbcb02846342b83e69dabc681" translate="yes" xml:space="preserve">
          <source>Here's a summary of the possible predicates:</source>
          <target state="translated">가능한 술어에 대한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58dc9ec13109b06fde34d79108b2ec3645eaf897" translate="yes" xml:space="preserve">
          <source>Here's a test to make sure that the data contains nothing but &quot;word&quot; characters (alphabetics, numerics, and underscores), a hyphen, an at sign, or a dot.</source>
          <target state="translated">데이터에 &quot;단어&quot;문자 (알파벳, 숫자 및 밑줄), 하이픈, at 부호 또는 점만 포함되어 있는지 확인하는 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="759693dd6cb991ad225a2379fc23020ea66b9451" translate="yes" xml:space="preserve">
          <source>Here's a trick for interpolating a subroutine call into a string:</source>
          <target state="translated">서브 루틴 호출을 문자열로 보간하는 요령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="566b3956738219763456c200fc999f82ae79bed2" translate="yes" xml:space="preserve">
          <source>Here's a truly obscure example:</source>
          <target state="translated">다음은 실제로 모호한 예입니다.</target>
        </trans-unit>
        <trans-unit id="673e00298dcf732578c132c6f7ebc33b00f2f5a5" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">백틱을 합리적으로 안전하게 수행하는 방법이 있습니다. 쉘이 확장 할 수있는 문자열로 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 가 어떻게 호출되지 않는지 주목하십시오 . 이것은 쉘 이스케이프 될 수있는 것을 호출하는 가장 좋은 방법입니다. 쉘을 전혀 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="eaaae86ddf2180ef145c4679eb81721d464c8d5e" translate="yes" xml:space="preserve">
          <source>Here's an even simpler example: I wrote a simple ray tracer; the program would look in a certain direction, figure out what it was looking at, and then convert the `color' value (typically a string like `red') of that object to a red, green, and blue pixel value, like this:</source>
          <target state="translated">더 간단한 예는 다음과 같습니다. 간단한 광선 추적기를 작성했습니다. 프로그램은 특정 방향으로보고,보고있는 것을 파악한 다음 해당 객체의`color '값 (일반적으로`red'와 같은 문자열)을 빨강, 녹색 및 파랑 픽셀 값으로 변환합니다. :</target>
        </trans-unit>
        <trans-unit id="eb7f2b2a1f46da14792dc92fada7de16651b64e3" translate="yes" xml:space="preserve">
          <source>Here's an example of a module as a blessed scalar:</source>
          <target state="translated">다음은 축복 스칼라 인 모듈의 예입니다.</target>
        </trans-unit>
        <trans-unit id="433e4046c8d4a59acb27a1b8715b8d822849f3f4" translate="yes" xml:space="preserve">
          <source>Here's an example of a semaphore:</source>
          <target state="translated">세마포어의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5da5564566886484e5f1909e68561f2893fc59f" translate="yes" xml:space="preserve">
          <source>Here's an example of a simple .t file for the fictional Film module.</source>
          <target state="translated">허구 영화 모듈을위한 간단한 .t 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00e3c595287e645175478199893dcfbab0d3f383" translate="yes" xml:space="preserve">
          <source>Here's an example of a somewhat interesting tied hash class: it gives you a hash representing a particular user's dot files. You index into the hash with the name of the file (minus the dot) and you get back that dot file's contents. For example:</source>
          <target state="translated">다음은 다소 흥미로운 연결 해시 클래스의 예입니다. 특정 사용자의 도트 파일을 나타내는 해시를 제공합니다. 파일 이름 (점에서 빼기)으로 해시에 색인을 작성하고 해당 점 파일의 내용을 다시 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44172aa24b9ebcb09c3ac7dacdd0f49ad41ffcca" translate="yes" xml:space="preserve">
          <source>Here's an example of how to copy a binary file:</source>
          <target state="translated">이진 파일을 복사하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db4ebf9573581d82c8cc95cd18272cd15b08d992" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">다음은 문자열을 전달하는 방법과 일치하는 정규식의 예입니다. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 패턴을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="637519bbaa8687d335368b0791bb0e149bbe34ba" translate="yes" xml:space="preserve">
          <source>Here's an example of running that program, which we'll call</source>
          <target state="translated">다음은 그 프로그램을 실행하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="f582133574110a3518036c490af80a6f46ec43be" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;code&gt;$|&lt;/code&gt; on your own, though.</source>
          <target state="translated">다음 은 시스템 레벨에서 &lt;code&gt;REMOTE&lt;/code&gt; 라는 파일 핸들 을 비 블로킹 으로 설정하는 예입니다 . 당신은 &lt;code&gt;$|&lt;/code&gt; 를 협상해야합니다 | 그래도</target>
        </trans-unit>
        <trans-unit id="5747af8299e3ce8766cc1e6c9250f3bd0c64b9fc" translate="yes" xml:space="preserve">
          <source>Here's an example of using open2():</source>
          <target state="translated">다음은 open2 ()를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="52ee3997caaa83f241ead3aa88bc5b3a35f1e445" translate="yes" xml:space="preserve">
          <source>Here's an example of using the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 변수 를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="244af372fc1dc3d578b9e7b6c1576ec36ffa9ff8" translate="yes" xml:space="preserve">
          <source>Here's an example of what a stack backtrace via &lt;code&gt;T&lt;/code&gt; command might look like:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 명령을 통한 스택 역 추적의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e488d97af419d58ca23b439a55505523edbe2e65" translate="yes" xml:space="preserve">
          <source>Here's an example of what you need for a simple module:</source>
          <target state="translated">간단한 모듈에 필요한 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="daccc2549e31545d57fdedfeee9273ddd1b0ff86" translate="yes" xml:space="preserve">
          <source>Here's an example script file:</source>
          <target state="translated">예제 스크립트 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acda0e1d4c96684fdc356f00d807ddf1f623f6ae" translate="yes" xml:space="preserve">
          <source>Here's an example that looks up nonnumeric uids in the passwd file:</source>
          <target state="translated">다음은 passwd 파일에서 숫자가 아닌 uid를 찾는 예입니다.</target>
        </trans-unit>
        <trans-unit id="5c0f7a1e07a375e4333db5cd9cca105a10ea230a" translate="yes" xml:space="preserve">
          <source>Here's an example that makes sure that whoever runs this program knows their password:</source>
          <target state="translated">다음은이 프로그램을 실행하는 사람이 자신의 비밀번호를 알고 있는지 확인하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2ba3dad78e5e2c46821c06eb650b17001a0a2ef6" translate="yes" xml:space="preserve">
          <source>Here's an example to test whether Nagle's algorithm is enabled on a socket:</source>
          <target state="translated">다음은 소켓에서 Nagle 알고리즘이 활성화되어 있는지 테스트하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d274e7c0c009a3ac1b895b776347d105b0d85baa" translate="yes" xml:space="preserve">
          <source>Here's an example using a recursive regular expression. The goal is to capture all of the text within angle brackets, including the text in nested angle brackets. This sample text has two &quot;major&quot; groups: a group with one level of nesting and a group with two levels of nesting. There are five total groups in angle brackets:</source>
          <target state="translated">다음은 재귀 정규 표현식을 사용하는 예입니다. 중첩 된 꺾쇠 괄호 안의 텍스트를 포함하여 꺾쇠 괄호 안의 모든 텍스트를 캡처하는 것이 목표입니다. 이 샘플 텍스트에는 두 가지 &quot;주요&quot;그룹이 있습니다. 하나의 중첩 수준을 가진 그룹과 두 수준의 중첩을 가진 그룹입니다. 꺾쇠 괄호에는 총 5 개의 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f04271f847d0c8988094c50219a148be404036" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="translated">다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea18952ce84912806a08117b90f220eff293cf76" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt; :</source>
          <target state="translated">다음은 &lt;code&gt;..&lt;/code&gt; 를 사용하는 또 다른 예입니다 .</target>
        </trans-unit>
        <trans-unit id="43b272b51e8dfc98c92e4358c6ca3238363075ae" translate="yes" xml:space="preserve">
          <source>Here's another example. Let's say you'd like to match a number at the end of a string, and you also want to keep the preceding part of the match. So you write this:</source>
          <target state="translated">또 다른 예가 있습니다. 문자열 끝에서 숫자를 일치시키고 일치하는 부분을 유지하려고한다고 가정 해 봅시다. 그래서 당신은 이것을 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="6d394fbb45cdbc9850e3f0051e919676f4c5a2f8" translate="yes" xml:space="preserve">
          <source>Here's another interesting wanted function. It will find all symbolic links that don't resolve:</source>
          <target state="translated">또 다른 흥미로운 기능이 있습니다. 해결되지 않은 모든 심볼릭 링크를 찾을 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
