<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="95121980b89b7a9fb796f03c8d74599823515afb" translate="yes" xml:space="preserve">
          <source>In general, there's no need to worry about the order of calls. They will be left-to-right, breadth-first, most-derived-first. This works perfectly for most inherited methods (including destructors), but is inappropriate for some kinds of methods (such as constructors, cloners, debuggers, and initializers) where it's more appropriate that the least-derived methods be called first (as more-derived methods may rely on the behaviour of their &quot;ancestors&quot;). In that case, instead of using the &lt;code&gt;EVERY&lt;/code&gt; pseudo-class:</source>
          <target state="translated">일반적으로 통화 순서에 대해 걱정할 필요가 없습니다. 그것들은 왼쪽에서 오른쪽으로, 가장 넓고, 가장 먼저 파생 될 것입니다. 이것은 대부분의 상속 된 메소드 (소멸자를 포함)에 완벽하게 작동하지만 가장 파생되지 않은 메소드를 먼저 호출하는 것이 더 적합한 일부 생성자 (생성자, 복제기, 디버거 및 초기화 프로그램)에는 부적합합니다 방법은 &quot;조상&quot;의 행동에 의존 할 수 있습니다). 이 경우 &lt;code&gt;EVERY&lt;/code&gt; 의사 클래스 를 사용하는 대신 :</target>
        </trans-unit>
        <trans-unit id="294f7f9dd3d63c6c658291241c38389ef5522490" translate="yes" xml:space="preserve">
          <source>In general, though, it's best to use the &lt;code&gt;Sv*V&lt;/code&gt; macros.</source>
          <target state="translated">그러나 일반적으로 &lt;code&gt;Sv*V&lt;/code&gt; 매크로 를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="aabaf80efaeb23cca024ae206403fa19e6f8a255" translate="yes" xml:space="preserve">
          <source>In general, with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, more detailed information will be available in the exit status for DCL scripts or other native VMS tools, and will give the expected information for Posix programs. It has not been made the default in order to preserve backward compatibility.</source>
          <target state="translated">일반적으로 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 를 사용하면 DCL 스크립트 또는 기타 기본 VMS 도구의 종료 상태에서보다 자세한 정보를 사용할 수 있으며 Posix 프로그램에 대한 예상 정보를 제공합니다. 이전 버전과의 호환성을 유지하기 위해 기본값으로 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d941c018a8912081ee9a18eaddf237ed10e20a20" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;How can I make my Perl program run faster?&lt;/a&gt;).</source>
          <target state="translated">일반적으로이 작업을 수행 할 수 없습니다. 그래도 상황에 맞는 몇 가지가 있습니다. 사람들은 일반적으로 소스 코드를 제공하지 않고 자신의 작업 물을 배포하려고하기 때문에이 질문을합니다. 대부분의 솔루션은 편의를 위해 디스크 공간을 교환합니다. 대부분의 솔루션은 단순히 최종 제품에 Perl 인터프리터를 번들로 제공하기 때문에 속도가 크게 향상되지는 않을 것입니다 (그러나 &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;Perl 프로그램을 더 빠르게 실행하려면 어떻게해야합니까? 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9eadd2908a4639d8decf9b9f18aef810c6f9990" translate="yes" xml:space="preserve">
          <source>In general, you don't &quot;declare&quot; a structure. Just use a (probably anonymous) hash reference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; for details. Here's an example:</source>
          <target state="translated">일반적으로 구조를 &quot;선언&quot;하지 않습니다. (아마도 익명의) 해시 참조를 사용하십시오. 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 및 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 를 참조하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f00c5d5b02fc95d1502392b2b9783083f707dee" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">받는 사람에게 색상 인식 디스플레이 장치가 있는지 여부를 모르기 때문에 일반적으로 알 수 없습니다. 색상을 이해하는 ANSI 터미널이있는 경우 CPAN 의 &lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f87cb8b42da40e06ddcf5b3026af1eac6aa3d5a" translate="yes" xml:space="preserve">
          <source>In general, you either have to know what you're dealing with, or you have to guess. The API function &lt;code&gt;is_utf8_string&lt;/code&gt; can help; it'll tell you if a string contains only valid UTF-8 characters, and the chances of a non-UTF-8 string looking like valid UTF-8 become very small very quickly with increasing string length. On a character-by-character basis, &lt;code&gt;isUTF8_CHAR&lt;/code&gt; will tell you whether the current character in a string is valid UTF-8.</source>
          <target state="translated">일반적으로, 당신은 당신이 다루고있는 것을 알아야하거나 추측해야합니다. API 함수 &lt;code&gt;is_utf8_string&lt;/code&gt; 이 도움이 될 수 있습니다. 문자열에 유효한 UTF-8 문자 만 포함되어 있는지 알려주고 UTF-8이 아닌 것처럼 보이는 UTF-8이 아닌 문자열의 문자열 길이가 길어질수록 매우 빠르게 줄어 듭니다. 문자별로 &lt;code&gt;isUTF8_CHAR&lt;/code&gt; 은 문자열의 현재 문자가 유효한 UTF-8인지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="26ea48aedd1cf988ca4c353ab67e2113694ba714" translate="yes" xml:space="preserve">
          <source>In human terms, it's a funny way of passing arguments to a subroutine when you define it as well as when you call it. It's useful for setting up little bits of code to run later, such as callbacks. You can even do object-oriented stuff with it, though Perl already provides a different mechanism to do that--see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">휴먼 용어로, 서브 루틴을 정의 할 때와 호출 할 때 서브 루틴에 인수를 전달하는 재미있는 방법입니다. 콜백과 같이 나중에 실행되도록 약간의 코드를 설정하는 데 유용합니다. Perl은 이미 객체 지향 작업을 수행 할 수도 있지만 Perl은 이미이를위한 다른 메커니즘을 제공합니다 ( &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6ba4c53f21b8779523425f16e680264ebae0decb" translate="yes" xml:space="preserve">
          <source>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that named sequence, and certain characters should match a sequence of multiple characters use under caseless &lt;code&gt;/i&lt;/code&gt; matching. Following those rules could lead to highly confusing situations:</source>
          <target state="translated">반전 괄호 문자 클래스에서, 펄은 일반적으로 명명 된 순서라고하는 유니 코드 규칙을 무시하고 특정 문자가 여러 문자의 순서는 대소 문자 구별에 따라 사용과 일치해야합니다 &lt;code&gt;/i&lt;/code&gt; 일치. 이러한 규칙을 따르면 혼란스러운 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a70875c03150cbfc8e14e2cc2dec49ecd50454" translate="yes" xml:space="preserve">
          <source>In its most basic usage, &lt;code&gt;ok(...)&lt;/code&gt; simply takes a single scalar expression. If its value is true, the test passes; if false, the test fails. Examples:</source>
          <target state="translated">가장 기본적인 사용법에서 &lt;code&gt;ok(...)&lt;/code&gt; 는 단일 스칼라 식을 취합니다. 값이 true이면 테스트가 통과됩니다. 거짓이면 테스트가 실패합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4d817298c353371e9d0b73c75cf1950195e64063" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;cond_wait&lt;/code&gt; takes a shared, &lt;b&gt;unlocked&lt;/b&gt; variable followed by a shared, &lt;b&gt;locked&lt;/b&gt; variable. The second variable is unlocked and thread execution suspended until another thread signals the first variable.</source>
          <target state="translated">두번째 형태에서, &lt;code&gt;cond_wait&lt;/code&gt; 는 공유 취 &lt;b&gt;해제&lt;/b&gt; 공유, 다음 가변 &lt;b&gt;로크&lt;/b&gt; 변수. 다른 스레드가 첫 번째 변수에 신호를 보낼 때까지 두 번째 변수가 잠금 해제되고 스레드 실행이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9702efe584ddf3df38f0a305879394e6c945fd" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;cond_timedwait&lt;/code&gt; takes a &lt;b&gt;locked&lt;/b&gt; variable and an absolute timeout in</source>
          <target state="translated">두 인수 형식에서 &lt;code&gt;cond_timedwait&lt;/code&gt; 는 &lt;b&gt;잠긴&lt;/b&gt; 변수와</target>
        </trans-unit>
        <trans-unit id="fbaa31119043f388b0d536e0c6af6beff83b01ef" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; compares the two scalar values to see if they match. They match if both are undefined, or if</source>
          <target state="translated">두 인수 형식에서 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; 는 두 스칼라 값을 비교하여 일치하는지 확인합니다. 둘 다 정의되지 않은 경우 또는</target>
        </trans-unit>
        <trans-unit id="278b05f5c861132c7f4bc86f277c1645adbbdf57" translate="yes" xml:space="preserve">
          <source>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</source>
          <target state="translated">덜 장황한 용어로, 작업의 첫 번째 부분은 패턴을 컴퓨터가 문자열에서 일치하는 점을 찾기 위해 효율적으로 사용할 수있는 것으로 바꾸는 것이고, 두 번째 부분은 검색 자체를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f53ef23dfb1a32e84061a4ee3198583f6963d3be" translate="yes" xml:space="preserve">
          <source>In line 7, we make sure that the SV will have enough room to accommodate the old string, the new string and the null terminator. If &lt;code&gt;LEN&lt;/code&gt; isn't big enough, &lt;code&gt;SvGROW&lt;/code&gt; will reallocate space for us.</source>
          <target state="translated">7 행에서 SV에 이전 문자열, 새 문자열 및 널 종료자를 수용 할 수있는 충분한 공간이 있는지 확인하십시오. 경우 &lt;code&gt;LEN&lt;/code&gt; 이 큰만큼이 아닌, &lt;code&gt;SvGROW&lt;/code&gt; 는 우리를 위해 공간을 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="6338eafb38b19e3533d3d49a05621b9aaa4f97d8" translate="yes" xml:space="preserve">
          <source>In line mode, &lt;code&gt;filter_read&lt;/code&gt; will append the next source line to the end of the &lt;code&gt;$_&lt;/code&gt; scalar.</source>
          <target state="translated">라인 모드에서 &lt;code&gt;filter_read&lt;/code&gt; 는 다음 소스 라인을 &lt;code&gt;$_&lt;/code&gt; 스칼라 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a450e27bd36ea332e7d75f6381cc8a12782b5b7a" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , like so:</source>
          <target state="translated">목록 컨텍스트 (보통 원하는 것)에서이 함수는 사용자가 어떤 언어로 출력을 받아 들일 것인지를 나타내는 (최우선의) 언어 태그 목록을 반환합니다 (아마도 비어 있음). &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; 또는 &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; 처럼 :</target>
        </trans-unit>
        <trans-unit id="239ff52c002bacbd9ef8a650976d52e44cb1392b" translate="yes" xml:space="preserve">
          <source>In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.</source>
          <target state="translated">목록 컨텍스트에서 두 개의 요소 목록을 리턴합니다. 첫 번째 요소는 패턴을 포함하고 두 번째 요소는 패턴을 컴파일 할 때 사용 된 수정자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a8954af69f3e9417a81eb4843c66328678eb290e" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;//g&lt;/code&gt; 는 일치하는 그룹화 목록을 반환하거나 그룹화가없는 경우 전체 정규식과 일치하는 목록을 반환합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="4a59e7f9e300ced2156a7bfdcb5c2ed656175ffd" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;//g&lt;/code&gt; 는 일치하는 그룹화 목록을 반환하거나 그룹화가없는 경우 전체 정규 표현식과 일치하는 목록을 반환합니다. 단어 만 원한다면</target>
        </trans-unit>
        <trans-unit id="ce23af9639d689001f6ad6f1b438efaee509bdfe" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;extract_delimited&lt;/code&gt; returns a array of three elements, the extracted substring (</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;extract_delimited&lt;/code&gt; 는 추출 된 하위 문자열 (</target>
        </trans-unit>
        <trans-unit id="85fefe43cf3ce99aee8bf62db2fc923ea0e22144" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt; . So we could rewrite it as</source>
          <target state="translated">목록 컨텍스트에서 그룹화와 일치하는 &lt;code&gt;/regex/&lt;/code&gt; 는 일치하는 값 목록 &lt;code&gt;($1,$2,...)&lt;/code&gt; 을 반환합니다 . 그래서 우리는 그것을 다음과 같이 다시 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c008355e8673133191ef9e0d9724c780f81e596e" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned.</source>
          <target state="translated">목록 컨텍스트에서 남은 시간과 간격이 모두 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff8ef7b7f3933511d227abc0760c6958871615f" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt; .</source>
          <target state="translated">목록 컨텍스트에서 남은 시간과 간격이 모두 반환됩니다. 간격은 항상 &lt;code&gt;setitimer()&lt;/code&gt; 사용하여 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="1f52db4aa7cef4591f6ad21954e80ef3d1ce4ff3" translate="yes" xml:space="preserve">
          <source>In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.</source>
          <target state="translated">목록 컨텍스트에서 두 번째 매개 변수가 존재하고 TRUE를 평가하면이 메소드는 연관 배열을 리턴합니다. 연관 배열의 키는 BTREE에서 일치하는 값에 해당하며 배열의 값은 BTREE에서 특정 값이 발생한 횟수의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="611c9c24bc1f7655268ae0a922a1bafe9f75484e" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt; . Note that the values will be returned in an apparently random order.</source>
          <target state="translated">리스트 컨텍스트에서 &lt;code&gt;$key&lt;/code&gt; 와 일치하는 모든 값을 반환합니다 . 값은 명백하게 임의의 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e8a08a17d7e9ccb66ceef8551ab60c5578a3cb" translate="yes" xml:space="preserve">
          <source>In list context, it's just the list argument separator, and inserts both its arguments into the list. These arguments are also evaluated from left to right.</source>
          <target state="translated">목록 컨텍스트에서는 목록 인수 구분자 일 뿐이며 두 인수를 모두 목록에 삽입합니다. 이러한 주장은 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d53a53afd4d30e8bf9ee4f38d18899b7c7ca7c4f" translate="yes" xml:space="preserve">
          <source>In list context, returns a (possibly empty) list of filename expansions on the value of EXPR such as the standard Unix shell</source>
          <target state="translated">목록 컨텍스트에서 표준 Unix 쉘과 같은 EXPR 값에 대한 파일 이름 확장명 목록 (비어 있음)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f4ce95673df56dca54efc694ff26b54d19e3c4c" translate="yes" xml:space="preserve">
          <source>In list context, returns a list consisting of all the values of the named hash. In Perl 5.12 or later only, will also return a list of the values of an array; prior to that release, attempting to use an array argument will produce a syntax error. In scalar context, returns the number of values.</source>
          <target state="translated">목록 컨텍스트에서 명명 된 해시의 모든 값으로 구성된 목록을 반환합니다. Perl 5.12 이상에서만 배열 값 목록을 리턴합니다. 해당 릴리스 이전에 배열 인수를 사용하려고하면 구문 오류가 발생합니다. 스칼라 문맥에서 값의 개수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bcc561bb33b529c7d0fa7662daf305595924e45" translate="yes" xml:space="preserve">
          <source>In list context, returns a list value consisting of the elements of LIST in the opposite order. In scalar context, concatenates the elements of LIST and returns a string value with all characters in the opposite order.</source>
          <target state="translated">목록 컨텍스트에서 LIST의 요소로 구성된 목록 값을 반대 순서로 반환합니다. 스칼라 컨텍스트에서 LIST의 요소를 연결하고 모든 문자가 반대 순서로있는 문자열 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8b48751518b742e90690dec941b028dbd41c2485" translate="yes" xml:space="preserve">
          <source>In list context, returns the value or values deleted, or the last such element in scalar context. The return list's length always matches that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions.</source>
          <target state="translated">목록 컨텍스트에서 삭제 된 값 또는 스칼라 컨텍스트의 마지막 해당 요소를 리턴합니다. 반환 목록의 길이는 항상 인수 목록의 길이와 일치합니다. 존재하지 않는 요소를 삭제하면 정의되지 않은 값이 해당 위치에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14dda5a0315cd38b494f1396d6549e05a88ce769" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">목록 컨텍스트에서 LIST를 정렬하고 정렬 된 목록 값을 리턴합니다. 스칼라 문맥에서 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c275967193060ed0f99b2fe8baeb485ea49b9b81" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">목록 컨텍스트에서 LIST를 정렬하고 정렬 된 목록 값을 리턴합니다. 스칼라 문맥에서 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f04d016b9064bf9bf9d2d6da3b96e6acf6fd1521" translate="yes" xml:space="preserve">
          <source>In literal patterns, the code is parsed at the same time as the surrounding code. While within the pattern, control is passed temporarily back to the perl parser, until the logically-balancing closing brace is encountered. This is similar to the way that an array index expression in a literal string is handled, for example</source>
          <target state="translated">리터럴 패턴에서 코드는 주변 코드와 동시에 구문 분석됩니다. 패턴 내에서 제어는 논리적 밸런싱 닫기 브레이스가 발생할 때까지 일시적으로 perl 파서로 다시 전달됩니다. 이는 리터럴 문자열의 배열 인덱스 표현식이 처리되는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1a35afb8085f46becc13477af444009e4d377a40" translate="yes" xml:space="preserve">
          <source>In many cases, methods that are used to set the internal state of the object will return the object itself, so method calls can be conveniently chained together.</source>
          <target state="translated">대부분의 경우 객체의 내부 상태를 설정하는 데 사용되는 메서드는 객체 자체를 반환하므로 메서드 호출을 편리하게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b8eb0a3ccf1ee1e198f508015d1976e62c80e9" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, sysopen() fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">많은 시스템에서 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그는 독점 모드에서 파일을 여는 데 사용할 수 있습니다. 이것은 잠금 이 &lt;b&gt;아닙니다&lt;/b&gt; . 배타성은 파일이 이미 존재하면 sysopen ()이 실패 함을 의미합니다. &lt;code&gt;O_EXCL&lt;/code&gt; 은 네트워크 파일 시스템에서 작동하지 않을 수 있으며 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그가 설정되어 있지 않으면 아무런 영향을 미치지 않습니다 . &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; 설정 하면 파일이 기호 링크 인 경우 파일이 열리지 않습니다. 파일 경로의 심볼릭 링크로부터 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8450d241305d74878facdc73fccc0a1c6ea4d3de" translate="yes" xml:space="preserve">
          <source>In module</source>
          <target state="translated">모듈에서</target>
        </trans-unit>
        <trans-unit id="286bdc943117014c33efb93a016a5d1869678221" translate="yes" xml:space="preserve">
          <source>In module filtering context, it can be used as Perl version filter.</source>
          <target state="translated">모듈 필터링 컨텍스트에서 Perl 버전 필터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a173a70aa245271ccb4f943a053fd8f7539c03d6" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , and &lt;code&gt;OUTPUT&lt;/code&gt; . An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">보다 실용적인 용어로, typemap은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 C 함수 매개 변수와 값을 Perl 값에 맵핑 하는 데 사용되는 코드 조각 모음입니다 . 타입 맵 파일은 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 으로 레이블이 지정된 3 개의 섹션으로 구성 될 수 있습니다 . 레이블이 지정되지 않은 초기 섹션은 &lt;code&gt;TYPEMAP&lt;/code&gt; 섹션으로 간주됩니다 . INPUT 섹션은 컴파일러에게 Perl 값을 특정 C 유형의 변수로 변환하는 방법을 알려줍니다. OUTPUT 섹션은 컴파일러에게 특정 C 유형의 값을 Perl이 이해할 수있는 값으로 변환하는 방법을 알려줍니다. TYPEMAP 섹션은 주어진 C 유형을 Perl 값에 맵핑하는 데 사용해야하는 INPUT 및 OUTPUT 코드 단편 중 어느 것을 컴파일러에 알려줍니다. 섹션 라벨 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 또는 &lt;code&gt;OUTPUT&lt;/code&gt; 은 행의 첫 번째 열에서 시작해야하며 대문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="428ffc575a57b1bff79640b48a60fb8f688d9deb" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for xs based extensions.</source>
          <target state="translated">대부분의 경우 사람들은 일반 모듈이든 xs 기반 확장이든 시스템의 / bin / make 프로그램보다는 GNU make로 더 나은 결과를보고했습니다.</target>
        </trans-unit>
        <trans-unit id="f5afec4e8618986f557789f84e21b385879c2564" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &quot;binmode&quot; before you pass it as argument to the addfile() method.</source>
          <target state="translated">대부분의 경우 addio () 메소드에 인수로 전달하기 전에 $ io_handle이 &quot;binmode&quot;에 있는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c59025c8c8f5462c9fb0d9eec8118a96c3e872c2" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">대부분의 경우 addio () 메소드에 인수로 전달하기 전에 $ io_handle이 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 에 있는지 확인하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="525f40bb529483f51193d29f821ebe7da0a52cf3" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt; , which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt; , but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt; . Generally speaking, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 문서화되지 않은 시스템 서비스 &lt;code&gt;$SIGPRC&lt;/code&gt; 를 통해 구현되며 $ SIRCRC 와 동일한 호출 시퀀스를 &lt;code&gt;$FORCEX&lt;/code&gt; &lt;code&gt;$EXIT&lt;/code&gt; 호출을 강제로 실행하지 않고 대상 프로세스에서 예외를 발생시킵니다 . 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 CRTL의 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 함수 의 동작을 따르지만 해당 함수와 달리 신호 처리기 내에서 호출 할 수 있습니다. 또한 일부 버전의 CRTL에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 과 달리 Perl의 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 전달 된 신호의 유효성을 확인하고 인식 할 수없는 신호를 보내려고 시도하지 않고 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eede988897716aa1422cf3adeb53444b2cab13f0" translate="yes" xml:space="preserve">
          <source>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</source>
          <target state="translated">대부분의 경우 단순히 문자열 연결을 사용하는 것이 더 쉬우 며 스칼라 컨텍스트를 강제 실행하기도합니다.</target>
        </trans-unit>
        <trans-unit id="ace8b1ddef61865f0aa48c02a6d220e56f6740dd" translate="yes" xml:space="preserve">
          <source>In most cases, patches to modules in</source>
          <target state="translated">대부분의 경우 모듈에 패치</target>
        </trans-unit>
        <trans-unit id="3d608639121073b361e23e425be9ba9c84646ab9" translate="yes" xml:space="preserve">
          <source>In most cases, you can just run it interactively from a command line without any special arguments and follow the prompts.</source>
          <target state="translated">대부분의 경우 특별한 인수없이 명령 행에서 대화식으로 실행하고 프롬프트를 따라갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1846566ce8422fbda676e86cc15846d05061a2" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;#round()&quot;&gt;round()&lt;/a&gt;, &lt;a href=&quot;#bround()&quot;&gt;bround()&lt;/a&gt; or &lt;a href=&quot;#bfround()&quot;&gt;bfround()&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#round()&quot;&gt;round ()&lt;/a&gt; , &lt;a href=&quot;#bround()&quot;&gt;bround ()&lt;/a&gt; 또는 &lt;a href=&quot;#bfround()&quot;&gt;bfround ()&lt;/a&gt; 중 하나를 사용 하거나 추가 정확도로 수학 연산에 원하는 정확도를 전달 하여 결과를 명시 적으로 반올림해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbf91aec7f60195ab2e4c16d72de4bd0b0dad318" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;bigint#round()&quot;&gt;round() in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;bigint#bround()&quot;&gt;bround() in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;bigint#bfround()&quot;&gt;bfround() in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">대부분의 경우, 당신은 아마 라운드 결과는 명시 적 중 하나를 사용한다 &lt;a href=&quot;bigint#round()&quot;&gt;수학 ::에서 BigInt에서) (원형&lt;/a&gt; , &lt;a href=&quot;bigint#bround()&quot;&gt;수학에서 bround () :에서 BigInt&lt;/a&gt; 또는 &lt;a href=&quot;bigint#bfround()&quot;&gt;수학 ::에서 BigInt의를 bfround ()&lt;/a&gt; 또는 수학 연산에 원하는 정확성을 전달하여 추가 매개 변수로 :</target>
        </trans-unit>
        <trans-unit id="a42b298f707283d45326f409618401d12bc90d6e" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt;, you can use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 외부 모듈을 작성합니다. &quot;C와 Perl을 연결하는 방법에 대한 정보는 어디에서 얻을 수 있습니까? [h2xs, xsubpp]&quot;를 참조하십시오. 그러나 함수가 시스템 호출이고 시스템이 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt; 지원 하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc로&lt;/a&gt; 문서화 됨)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d19f51a558abe46dfdc218b96bc734b3c276b079" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt; , one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt; , Mac OS uses &lt;code&gt;\015&lt;/code&gt; , and z/OS uses &lt;code&gt;\025&lt;/code&gt; .</source>
          <target state="translated">대부분의 운영 체제에서 파일의 줄은 줄 바꿈으로 끝납니다. 줄 바꿈으로 사용되는 것은 OS마다 다를 수 있습니다. 유닉스는 전통적으로 &lt;code&gt;\012&lt;/code&gt; 사용 하고 DOSish I / O 유형 중 하나는 &lt;code&gt;\015\012&lt;/code&gt; 하고 Mac OS는 &lt;code&gt;\015&lt;/code&gt; 를 사용하고 z / OS는 &lt;code&gt;\025&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="59c4293bfbaf72968d51c71aab642ca2822c9579" translate="yes" xml:space="preserve">
          <source>In multithreaded scripts Perl coordinates the threads so that any thread may modify its copy of the &lt;code&gt;$0&lt;/code&gt; and the change becomes visible to ps(1) (assuming the operating system plays along). Note that the view of &lt;code&gt;$0&lt;/code&gt; the other threads have will not change since they have their own copies of it.</source>
          <target state="translated">다중 스레드 스크립트에서 Perl은 스레드가 &lt;code&gt;$0&lt;/code&gt; 의 사본을 수정할 수 있도록 변경을 수행하고 변경 사항이 ps (1)에 표시되도록합니다 (운영 체제가 작동한다고 가정). 다른 스레드 의 &lt;code&gt;$0&lt;/code&gt; 보기는 자체 사본이 있으므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ff5aa25fe59ffebaa3d9b983e6ed41dcfbb4c10" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that either advertises a &lt;b&gt;service&lt;/b&gt; or just hangs around at a known location and waits for &lt;b&gt;clients&lt;/b&gt; who need service to get in touch with it.</source>
          <target state="translated">네트워킹에서 &lt;b&gt;서비스를&lt;/b&gt; 알리거나 알려진 위치에서 멈추고 서비스가 필요한 &lt;b&gt;클라이언트&lt;/b&gt; 가 서비스를 받기를 기다리는 &lt;b&gt;프로세스&lt;/b&gt; 입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe020f31c58d30517974e8b54ebe9cc4a8fb1397" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that initiates contact with a &lt;b&gt;server&lt;/b&gt; process in order to exchange data and perhaps receive a service.</source>
          <target state="translated">네트워킹에서 데이터를 교환하고 서비스를 받기 위해 &lt;b&gt;서버&lt;/b&gt; 프로세스 와의 연결을 시작 하는 &lt;b&gt;프로세스&lt;/b&gt; 입니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7faa009c2918d4804b660feca8b23ad35925a6e" translate="yes" xml:space="preserve">
          <source>In networking, an agreed-upon way of sending messages back and forth so that neither correspondent will get too confused.</source>
          <target state="translated">네트워킹에서, 상대방이 너무 혼동하지 않도록 합의하여 메시지를주고받는 방법.</target>
        </trans-unit>
        <trans-unit id="71b3fd1615492dc9bf230d9f033afbf83da86082" translate="yes" xml:space="preserve">
          <source>In normal &amp;ldquo;computerese&amp;rdquo;, the piece of data of the size most efficiently handled by your computer, typically 32 bits or so, give or take a few powers of 2. In Perl culture, it more often refers to an alphanumeric &lt;b&gt;identifier&lt;/b&gt; (including underscores), or to a string of nonwhitespace &lt;b&gt;characters&lt;/b&gt; bounded by whitespace or string boundaries.</source>
          <target state="translated">일반적인 &quot;컴퓨터&quot;에서 컴퓨터가 가장 효율적으로 처리하는 크기의 데이터 조각 (일반적으로 32 비트 정도)은 2의 거듭 제곱을 제공하거나 취합니다. Perl 문화권에서는 더 자주 영숫자 &lt;b&gt;식별자&lt;/b&gt; (밑줄 포함)를 나타냅니다. ) 또는 공백 또는 문자열 경계로 묶인 공백 이 아닌 &lt;b&gt;문자&lt;/b&gt; 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="2b1437a6901ce1f87cee7f4d6385fbba76b51c73" translate="yes" xml:space="preserve">
          <source>In object-oriented code, we often find that one object references another object. This is called &lt;b&gt;composition&lt;/b&gt;, or a &lt;b&gt;has-a&lt;/b&gt; relationship.</source>
          <target state="translated">객체 지향 코드에서는 종종 한 객체가 다른 객체를 참조한다는 것을 알 수 있습니다. 이것은 호출 &lt;b&gt;조성물&lt;/b&gt; , 또는이 &lt;b&gt;갖는-A&lt;/b&gt; 관계.</target>
        </trans-unit>
        <trans-unit id="0840885f4ae0e15a9e1a64e6e2f2e63bb6055bf6" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">예전 에는 전화 번호부와 같은 실제 색인에서 &lt;b&gt;키&lt;/b&gt; 를 찾는 행위 . 그러나 지금은 단지 해당 찾을 키 또는 위치의 어떤 종류를 사용하는 행위의 &lt;b&gt;값을&lt;/b&gt; 인덱스가 관여하지 않는 경우에도,. Perl의 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 함수가 단순히 한 문자열의 위치 (인덱스)를 다른 문자열로 찾는 지점까지 변질되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8954164487b10a1a06bdaedbfbaa22faf258c328" translate="yes" xml:space="preserve">
          <source>In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see</source>
          <target state="translated">이전 유니 코드 버전에서는 적은 수의 문자 (모두 CJK 호환 표의 문자 임)가 잘못된 분해 매핑을 가질 수 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="25564a5fe1398dbc91939b7e3cb0a5bccfb1e2c1" translate="yes" xml:space="preserve">
          <source>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not &quot;characters&quot;, so converting &quot;data&quot; into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</source>
          <target state="translated">어떤 의미에서, 당신이 요구하는 것은 의미가 없습니다. 인코딩은 문자이고 이진 데이터는 &quot;문자&quot;가 아니므로 &quot;데이터&quot;를 어떤 인코딩으로 변환하는 것은 어떤 문자 세트와 인코딩을 알지 않는 한 의미가 없습니다 이진 데이터가 들어있는 경우 이진 데이터가 아니라 지금입니까?</target>
        </trans-unit>
        <trans-unit id="0665aadb9203e48ab11fdbdc61f426bdf069c8ef" translate="yes" xml:space="preserve">
          <source>In one's own MANIFEST.SKIP file, certain directives can be used to include the contents of other MANIFEST.SKIP files. At present two such directives are recognized.</source>
          <target state="translated">자신의 MANIFEST.SKIP 파일에서 특정 지시문을 사용하여 다른 MANIFEST.SKIP 파일의 내용을 포함 할 수 있습니다. 현재 두 가지 지침이 인정됩니다.</target>
        </trans-unit>
        <trans-unit id="775d518fe37c14b3f79041d34b5efaca033dd3ab" translate="yes" xml:space="preserve">
          <source>In one-liner form:</source>
          <target state="translated">한 줄짜리 형태로 :</target>
        </trans-unit>
        <trans-unit id="3a599813be17001915e0601602237bd798d15d3b" translate="yes" xml:space="preserve">
          <source>In one-shot mode this flag will be set to true if the Perl &lt;code&gt;-T&lt;/code&gt; operator thinks the file contains text.</source>
          <target state="translated">원샷 모드에서 Perl &lt;code&gt;-T&lt;/code&gt; 연산자가 파일에 텍스트가 있다고 생각하면 이 플래그가 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a387689b89f7b0ad51aa990a4b2c214ffa94375" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt; ). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;SYNOPSIS in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">메소드가 아직 정의되지 않은 경우에도 오브젝트 메소드 검색 및 / 또는 프로토 타입 검사가 올바르게 작동하려면 각 서브 루틴을 &quot;포워드 선언&quot;해야합니다 ( &lt;code&gt;sub NAME;&lt;/code&gt; ). &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsub의 시놉시스를&lt;/a&gt; 참조하십시오 . 이러한 순방향 선언은 코드가없는 자리 표시자인 &quot;서브 루틴 스텁&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0241ec9af4c551ca21dc35ad3b6791e44a33543" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use a plug-in library for core math routines. Any module which conforms to the API can be used by Math::BigInt by using this in your program:</source>
          <target state="translated">여러 개의 큰 정수 라이브러리를 허용하기 위해 Math :: BigInt가 핵심 수학 루틴에 플러그인 라이브러리를 사용하도록 다시 작성되었습니다. Math :: BigInt는 API를 따르는 모든 모듈을 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db68f3a19f1d4b1da9de666e4465352494a86e3b" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use library modules for core math routines. Any module which follows the same API as this can be used instead by using the following:</source>
          <target state="translated">여러 개의 큰 정수 라이브러리를 허용하기 위해 Math :: BigInt가 핵심 수학 루틴에 라이브러리 모듈을 사용하도록 다시 작성되었습니다. 다음과 같이 API와 동일한 API를 따르는 모든 모듈을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f9d107daff2d5afbf356c8809d8a77ed4fb993" translate="yes" xml:space="preserve">
          <source>In order to build your own version of Perl you will need 'make', which is part of Apple's developer tools - also known as Xcode. From Mac OS X 10.7 &quot;Lion&quot; onwards, it can be downloaded separately as the 'Command Line Tools' bundle directly from &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; (you will need a free account to log in), or as a part of the Xcode suite, freely available at the App Store. Xcode is a pretty big app, so unless you already have it or really want it, you are advised to get the 'Command Line Tools' bundle separately from the link above. If you want to do it from within Xcode, go to Xcode -&amp;gt; Preferences -&amp;gt; Downloads and select the 'Command Line Tools' option.</source>
          <target state="translated">자신 만의 버전의 Perl을 빌드하려면 Xcode라고도하는 Apple 개발자 도구의 일부인 'make'가 필요합니다. Mac OS X 10.7 &quot;Lion&quot;부터 &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; 에서 직접 'Command Line Tools'번들로 별도로 다운로드 하거나 (로그인하려면 무료 계정이 필요함) 또는 Xcode 제품군의 일부로 App Store에서 무료로 사용할 수 있습니다. Xcode는 꽤 큰 앱이므로 이미 가지고 있거나 실제로 원하지 않는 한 위의 링크와 별도로 'Command Line Tools'번들을 얻는 것이 좋습니다. Xcode 내에서 수행하려면 Xcode-&amp;gt; 환경 설정-&amp;gt; 다운로드로 이동하여 '명령 줄 도구'옵션을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a93cd8781d8e041e8355a0aefc4276597d7a98e8" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">문자열을 한 문자 집합에서 다른 문자 집합으로 변환하려면 위 표의 오른쪽 열과 같이 Perl의 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 연산자 와 함께 간단한 숫자 목록 만 있으면됩니다. 테이블의 데이터는 ASCII / Latin1 순서로되어 있으므로 EBCDIC 열은 사용하기 쉬운 ASCII / Latin1-EBCDIC 조작을 쉽게 역순으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f5fa67b20e8cfe8e347f59bf69babb07bc272aa" translate="yes" xml:space="preserve">
          <source>In order to install a new regexp handler, &lt;code&gt;$^H{regcomp}&lt;/code&gt; is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the &lt;code&gt;comp&lt;/code&gt; method is executed, and the resulting &lt;code&gt;regexp&lt;/code&gt; structure's engine field is expected to point back at the same structure.</source>
          <target state="translated">새로운 정규 표현식 핸들러를 설치하기 위해 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 는 정수로 설정되어 (적절하게 캐스팅 된 경우) 이러한 구조 중 하나로 해석됩니다. 컴파일 할 때 &lt;code&gt;comp&lt;/code&gt; 메소드가 실행되고 결과 &lt;code&gt;regexp&lt;/code&gt; 구조의 엔진 필드는 동일한 구조로 되돌아 갈 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="437d80cea54e562ec941100e6a72df58383866f9" translate="yes" xml:space="preserve">
          <source>In order to keep lib.pm small and simple, it only works with Unix filepaths. This doesn't mean it only works on Unix, but non-Unix users must first translate their file paths to Unix conventions.</source>
          <target state="translated">lib.pm을 작고 단순하게 유지하기 위해 Unix 파일 경로에서만 작동합니다. 그렇다고 유닉스에서만 작동한다는 의미는 아니지만, 비 유닉스 사용자는 먼저 파일 경로를 유닉스 규칙으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="364bb5f6d99dcae74466742fdf303cf213f25184" translate="yes" xml:space="preserve">
          <source>In order to maintain maximum compatibility with earlier versions of Perl, this function will return either the floating point notation or the multiple dotted notation, depending on whether the original version contained 1 or more dots, respectively.</source>
          <target state="translated">이전 버전의 Perl과의 최대 호환성을 유지하기 위해이 함수는 원래 버전에 각각 1 개 이상의 도트가 포함되어 있는지 여부에 따라 부동 소수점 표기법 또는 다중 점 표기법을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="381ea4e1bb108f2a93fb8d7c5edae34da5e15c66" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">이전 버전의 MakeMaker에서 속성의 이식성을 유지하기 위해 &lt;code&gt;Makefile.PL&lt;/code&gt; 과 함께 &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9248f937d9955a6043a592d635bc82f1867f0186" translate="yes" xml:space="preserve">
          <source>In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</source>
          <target state="translated">RECNO와 Perl의 호환성을 높이기 위해 모든 RECNO 어레이에 대한 어레이 오프셋은 Berkeley DB에서와 같이 1이 아니라 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c8f50d2afd74c2c616567dbb29c3d95a6bbbba68" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공격 키 세트를 생성 할 시드를 알 수 없도록하기 위해이 시드는 프로세스 시작시 임의로 초기화됩니다. PERL_HASH_SEED 환경 변수를 사용하여이를 대체 할 수 있습니다 ( &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;perlrun의 PERL_HASH_SEED&lt;/a&gt; 참조) . 이 환경 변수는 항목이 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 통해 표시되는 방식이 아니라 실제로 저장되는 방식을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="e1eda6692f2f4e28d3303c1b91852403d3cf17be" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">Maketext를 이해하고 모든 구성 요소가 어떻게 결합되는지 알아 보려면 &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="5ff6fc777d96f10921d74c27d5ed5e70b4334507" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt; , does just that.</source>
          <target state="translated">rot13 필터를 사용하려면 소스 파일을 rot13 형식으로 인코딩하는 방법이 필요합니다. 아래의 스크립트 인 &lt;code&gt;mkrot13&lt;/code&gt; 은 바로 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="21d2fc600dcdd5c6cb297e557194c37b7f0f485a" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt; below.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;사용 기능 'unicode_strings'&lt;/a&gt; 를 지정 하지 않으면 Perl은 전체 내부 유니 코드 지원을 설정하지 않습니다 . ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 경우 자동으로 선택됩니다 .) 이렇게하지 않으면 예기치 않은 놀라움이 발생할 수 있습니다. 아래 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;의 유니 코드 버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd47550c4a48b602de1804d810fabdd19f1a7062" translate="yes" xml:space="preserve">
          <source>In order to process interior sequences, subclasses implementations of this method will probably want to invoke either &lt;b&gt;interpolate()&lt;/b&gt; or &lt;b&gt;parse_text()&lt;/b&gt;, passing it the text block &lt;code&gt;$text&lt;/code&gt; , and the corresponding line number in &lt;code&gt;$line_num&lt;/code&gt; , and then perform any desired processing upon the returned result.</source>
          <target state="translated">내부 시퀀스를 처리하기 위해이 메소드의 서브 클래스 구현은 아마도 &lt;b&gt;interpolate ()&lt;/b&gt; 또는 &lt;b&gt;parse_text ()&lt;/b&gt; 를 호출 하여 텍스트 블록 &lt;code&gt;$text&lt;/code&gt; 및 해당 행 번호를 &lt;code&gt;$line_num&lt;/code&gt; 전달한 다음 원하는 처리를 수행 하려고합니다. 반환 된 결과</target>
        </trans-unit>
        <trans-unit id="96a9bbcaad8032f3708be9f9aad29a52e4a152b3" translate="yes" xml:space="preserve">
          <source>In order to test that our extension works, we now need to look at the file Mytest.t. This file is set up to imitate the same kind of testing structure that Perl itself has. Within the test script, you perform a number of tests to confirm the behavior of the extension, printing &quot;ok&quot; when the test is correct, &quot;not ok&quot; when it is not.</source>
          <target state="translated">확장 기능이 작동하는지 테스트하려면 Mytest.t 파일을 확인해야합니다. 이 파일은 Perl 자체와 동일한 종류의 테스트 구조를 모방하도록 설정되었습니다. 테스트 스크립트 내에서 확장의 동작을 확인하기 위해 여러 테스트를 수행하여 테스트가 올 바르면 &quot;확인&quot;을 인쇄하고 그렇지 않으면 &quot;확인하지 않음&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e8108d3bcd39eeb2141d68d5707c2daf6f01568e" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for details.</source>
          <target state="translated">Perl 객체를 이해하려면 먼저 Perl의 참조를 이해해야합니다. 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="769d36508232140bd94018f22812d43183fa9db1" translate="yes" xml:space="preserve">
          <source>In order to use &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD subroutine you</source>
          <target state="translated">사용하려면 &lt;b&gt;자동로드&lt;/b&gt; 의 AUTOLOAD 서브 루틴을 사용하면</target>
        </trans-unit>
        <trans-unit id="af99082b46921b802ae95263001ef07cb7aa2040" translate="yes" xml:space="preserve">
          <source>In ordinary paragraphs and in some command paragraphs, various formatting codes (a.k.a. &quot;interior sequences&quot;) can be used:</source>
          <target state="translated">일반적인 단락과 일부 명령 단락에서 다양한 형식화 코드 (일명 &quot;내부 시퀀스&quot;)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a0be2abf85a22324ace726b3f113f3ddb049b" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">다른 부울 컨텍스트에서, 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 테스트 또는 비교가 없는 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 경고 pragma 또는 &lt;b&gt;-w&lt;/b&gt; 명령 행 스위치 ( &lt;code&gt;$^W&lt;/code&gt; 변수)가 유효한 경우 경고를 유발합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="633c40ae3272eb641ed90a2b64f933bcfc1ab4fa" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. That will happen on the p5p list.</source>
          <target state="translated">다른 경우에는 패치에 더 많은 작업이나 토론이 필요합니다. 이는 p5p 목록에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b3796099c87e59fc24644465a4e8f63a8bac8d4" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; 을 사용하려는 다른 파일에서 :</target>
        </trans-unit>
        <trans-unit id="3b8bb595443598bbfebd43734b72b246e5109db8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:</source>
          <target state="translated">모듈을 사용하려는 다른 파일에는 모듈을로드하고 심볼을 가져 오는 세 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac5b44cbcccec7c46874f1c0dae34c3e4179f83" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt; 's class hierarchy that resulted in the original call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉,에 대한 호출 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 의 깊이 우선, 왼쪽에서 오른쪽으로 검색 다시 시작 &lt;code&gt;$self&lt;/code&gt; 에 원래 통화 결과의 클래스 계층 구조 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4828bb0cda42f406a7ca05570f3e0910c8f19571" translate="yes" xml:space="preserve">
          <source>In other words, each type of bracket specified as a delimiter must be balanced and correctly nested within the substring, and any other kind of (&quot;non-delimiter&quot;) bracket in the substring is ignored.</source>
          <target state="translated">다시 말해서, 분리 문자로 지정된 각 유형의 대괄호는 서브 스트링 내에 균형이 있고 올바르게 중첩되어야하며, 서브 스트링에있는 다른 종류의 ( &quot;비 구분자&quot;) 괄호는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="74fd5671e652ca312e8092bc1ce538f5b223a43a" translate="yes" xml:space="preserve">
          <source>In other words, if you try this:</source>
          <target state="translated">즉, 시도하면</target>
        </trans-unit>
        <trans-unit id="877ca893c0d0ee5563d6603bca839b1fc7617192" translate="yes" xml:space="preserve">
          <source>In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.</source>
          <target state="translated">즉, implicate_supers_strictly는 문자열 목록 (언어 태그 인 것으로 추정되며, 그렇지 않은 문자열은 무시 됨)을 취하고 주어진 전체 목록 뒤에 모든 주어진 태그의 빼기 형식을 삽입합니다. 입력 목록에 이미 표시된 태그</target>
        </trans-unit>
        <trans-unit id="25d319aebdebcd5625f4059cfe98447477589bac" translate="yes" xml:space="preserve">
          <source>In other words, in the &quot;C&quot; (or English) locale the above will probably print something like:</source>
          <target state="translated">즉, &quot;C&quot;(또는 영어) 로켈에서 위의 내용은 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="550ff39ed161b9edd0e84b02fed3dec9d30c2e67" translate="yes" xml:space="preserve">
          <source>In other words, it does not check the full recursion stack.</source>
          <target state="translated">즉, 전체 재귀 스택을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0fc4bff9ab6a124fdea1a036cef443002eab13f" translate="yes" xml:space="preserve">
          <source>In other words, it takes this:</source>
          <target state="translated">다시 말해, 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9c65668195992fe68f06679feb8eacf4cd2f8800" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">즉, 코드 포인트가 64 x 또는 대문자로 된 문자입니다. &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; 는 127이고 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 의 ord 는 64 이므로 &lt;code&gt;\c@&lt;/code&gt; 은 NULL 이므로 xor'ing 64 자체는 0을 생성하므로 ASCII 플랫폼에서 DELETE입니다 .</target>
        </trans-unit>
        <trans-unit id="2b7ead3432ce6ef0a214c631da3fb65f28ad59d4" translate="yes" xml:space="preserve">
          <source>In other words, it's the projection of the vector onto the</source>
          <target state="translated">다시 말해 벡터가</target>
        </trans-unit>
        <trans-unit id="173982625284de4ecdaf57b42d11dd41503a3a62" translate="yes" xml:space="preserve">
          <source>In other words, once the &lt;code&gt;(*COMMIT)&lt;/code&gt; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</source>
          <target state="translated">다시 말해, 일단 &lt;code&gt;(*COMMIT)&lt;/code&gt; 이 입력되고 패턴이 일치하지 않으면 정규식 엔진은 나머지 문자열에서 더 이상 일치를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="080def995649dc7c78c927509a6265da0f050d82" translate="yes" xml:space="preserve">
          <source>In other words, text outside bracket groups is turned into string literals. Text in brackets is rather more complex, and currently follows these rules:</source>
          <target state="translated">즉, 대괄호 그룹 외부의 텍스트는 문자열 리터럴로 바뀝니다. 괄호 안의 텍스트는 다소 복잡하며 현재 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f68e3679fc5753d52f8311d0156c23ac089d43c6" translate="yes" xml:space="preserve">
          <source>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&amp;lt;use strict;&amp;gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&amp;lt;...&amp;gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</source>
          <target state="translated">즉, &quot;head1&quot;에 대한 포드 처리 핸들러는 &quot;&amp;lt;strict;&amp;gt;를 기억 했습니까?&quot;에 동일한 처리를 적용합니다. 일반 단락 (예 : &quot;C &amp;lt;...&amp;gt;&quot;와 같은 형식화 코드)에 대한 구문 분석 및 적절한 형식화가 가능하며 리터럴 공백 및 / 또는 탭 형식의 공백은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0443748797b84576038c7f78a4ac322e4d4dc07" translate="yes" xml:space="preserve">
          <source>In other words, the author of a module should be considered to have final say on modifications to their module whenever possible (bearing in mind that it's expected that everyone involved will work together and arrive at reasonable compromises when there are disagreements).</source>
          <target state="translated">다시 말해, 모듈 작성자는 가능할 때마다 모듈을 수정하는 것에 대해 최종적으로 언급하는 것으로 간주되어야합니다 (관련된 모든 사람들이 협력하여 의견 불일치가있을 경우 합리적인 타협에 도달 할 것이라는 점을 명심하십시오).</target>
        </trans-unit>
        <trans-unit id="585a94d48c61cb81b39fc84dfe81f19ca97413b7" translate="yes" xml:space="preserve">
          <source>In other words, the implementation of &lt;code&gt;extract_tagged&lt;/code&gt; is exactly equivalent to:</source>
          <target state="translated">다시 말해 &lt;code&gt;extract_tagged&lt;/code&gt; 의 구현 은 다음과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6437ac2d46829a1156ddedffd3475d352ba0e256" translate="yes" xml:space="preserve">
          <source>In other words, the previous example, would become:</source>
          <target state="translated">다시 말해, 앞의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb35ba757de61444a9e16187e2167074637a80ae" translate="yes" xml:space="preserve">
          <source>In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions: &lt;code&gt;/^$/&lt;/code&gt; matches only if you're at the beginning of the line AND the end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar. &lt;code&gt;/ab/&lt;/code&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.</source>
          <target state="translated">다시 말해, 내장 된 어설 션을 사용하는 것처럼 서로 옆에있는 두 개의 너비가 0 인 어설 션이 서로 AND 인 것처럼 작동합니다. &lt;code&gt;/^$/&lt;/code&gt; 는 시작 부분에있는 경우에만 일치합니다. 라인과 라인의 끝을 동시에. 더 근본적인 진실은 정규식에서 병치가 수직 막대를 사용하여 명시 적 OR을 작성할 때를 제외하고 항상 AND를 의미한다는 것입니다. &lt;code&gt;/ab/&lt;/code&gt; 는 &quot;a&quot;와 일치 한 다음 &quot;b&quot;와 일치하는 것을 의미하지만 &quot;a&quot;는 너비가 0이 아닌 너비가 1 개이므로 다른 위치에서 일치하는 항목이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="459d5640fff6f70049a1cb4e21dd9d95f811c50c" translate="yes" xml:space="preserve">
          <source>In other words, this is valid:</source>
          <target state="translated">다시 말해, 이것은 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="b1e37082db8f86fab9970e0f78a995b4a26a2a25" translate="yes" xml:space="preserve">
          <source>In other words, you can write:</source>
          <target state="translated">즉, 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760e520ac926fbcbcf184f0f289efd734964ab6f" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use binmode() on binary data, like images, for example.</source>
          <target state="translated">즉, 플랫폼에 관계없이 이미지와 같이 이진 데이터에 binmode ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c34e83f6eab1310b3613a944eb5e27cd7e611dd" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt; , change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt; . Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt; ) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">즉 : 교체 할 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; 하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , 제거 &lt;code&gt;DynaLoader&lt;/code&gt; 에서 &lt;code&gt;@ISA&lt;/code&gt; 변경 &lt;code&gt;bootstrap&lt;/code&gt; 에 의해 &lt;code&gt;XSLoader::load&lt;/code&gt; . &lt;code&gt;XSLoader::load&lt;/code&gt; 행에서 패키지 이름을 인용 하고 인수 앞에 쉼표 ( &lt;code&gt;,&lt;/code&gt; )를 추가하십시오 ( 위의 &lt;code&gt;$VERSION&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc33d1c173d87ad8a862029ec4420d308b38832f" translate="yes" xml:space="preserve">
          <source>In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions. It then sets the &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; arrays and the &lt;code&gt;$VERSION&lt;/code&gt; scalar; finally it tells perl to bootstrap the module. Perl will call its dynamic loader routine (if there is one) and load the shared library.</source>
          <target state="translated">이 경우 Mytest.pm은 perl에게 Exporter 및 Dynamic Loader 확장이 필요하다고 알려줍니다. 그런 다음 &lt;code&gt;@ISA&lt;/code&gt; 및 &lt;code&gt;@EXPORT&lt;/code&gt; 배열과 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라를 설정합니다. 마지막으로 펄에게 모듈을 부트 스트랩하도록 지시합니다. Perl은 동적 로더 루틴 (있는 경우)을 호출하고 공유 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="92b4893cf24b728e0fae1966639d9078e63fc3f7" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; :</source>
          <target state="translated">이 예에서는 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; 의해 참조되는 기본 해시에서 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1f779d9a34032474fc9a65f77cb8d2776cbce1" translate="yes" xml:space="preserve">
          <source>In our example we're going to create a shouting handle.</source>
          <target state="translated">이 예에서는 소리 핸들을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a13dbabebbc5437dccc50e5be8ddf3c33a642ee8" translate="yes" xml:space="preserve">
          <source>In our example, 'undef' is really an element containing &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces. Observe:</source>
          <target state="translated">이 예에서 'undef'는 실제로 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 개의 공백을 포함하는 요소 입니다. 관찰 :</target>
        </trans-unit>
        <trans-unit id="aabcb2149f4617fcf7efa6bbc92a17b687ef3353" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">이 예에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실제로 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 수의 공간이므로 여기에서 수행 할 작업이 조금 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1787ee08eebed75ede8020208e3ff9eccca1a6" translate="yes" xml:space="preserve">
          <source>In our example, a deleted item is &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces:</source>
          <target state="translated">이 예에서 삭제 된 항목은 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 공백입니다.</target>
        </trans-unit>
        <trans-unit id="91424799b59a91080c214218f5e7f8c9b0b084d8" translate="yes" xml:space="preserve">
          <source>In our example, just to show you that you don't</source>
          <target state="translated">이 예에서는</target>
        </trans-unit>
        <trans-unit id="11b35d0e0b09647c243a787b95c24ae27233aecd" translate="yes" xml:space="preserve">
          <source>In our example, that would remove all the user's dot files! It's such a dangerous thing that they'll have to set CLOBBER to something higher than 1 to make it happen.</source>
          <target state="translated">이 예에서는 모든 사용자의 도트 파일을 제거합니다! CLOBBER를 1보다 큰 값으로 설정해야하는 것은 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="8f92d427a1809586b396dc516bf348aaa08bbed7" translate="yes" xml:space="preserve">
          <source>In our example, we want to make sure there are no blank (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) entries, so &lt;code&gt;EXTEND&lt;/code&gt; will make use of &lt;code&gt;STORESIZE&lt;/code&gt; to fill elements as needed:</source>
          <target state="translated">이 예에서는 빈 ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 항목 이 없는지 확인하려고 하므로 &lt;code&gt;EXTEND&lt;/code&gt; 는 &lt;code&gt;STORESIZE&lt;/code&gt; 를 사용 하여 필요에 따라 요소를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="24d1f4e04fd957695cb0fc036193c59fca0468cd" translate="yes" xml:space="preserve">
          <source>In our example, we will determine that if an element consists of &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces only, it does not exist:</source>
          <target state="translated">이 예에서는 요소가 다음으로 구성되어 있는지 확인합니다. &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 공백으로 만 존재하지 않는 것으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9241072dd02f63704e06d0e4788fd47ef3eca294" translate="yes" xml:space="preserve">
          <source>In our example, we'll use a little shortcut if there is a</source>
          <target state="translated">이 예에서는</target>
        </trans-unit>
        <trans-unit id="6a2c73ee683cc447274fd115e41a8a6212c0860c" translate="yes" xml:space="preserve">
          <source>In our intranet, we have many modules for internal use. How can I integrate these modules with CPAN.pm but without uploading the modules to CPAN?</source>
          <target state="translated">인트라넷에는 내부 용으로 많은 모듈이 있습니다. CPAN.pm과 모듈을 CPAN에 업로드하지 않고 어떻게 통합 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e3d33b8a8cd9ee1cbb39097ccf83087f357647e8" translate="yes" xml:space="preserve">
          <source>In our tied hash DotFiles example, we use a regular hash for the object containing several important fields, of which only the &lt;code&gt;{LIST}&lt;/code&gt; field will be what the user thinks of as the real hash.</source>
          <target state="translated">우리의 공동 해시 DotFiles의 예에서 우리는 몇 가지 중요한 필드를 포함하는 개체에 대한 일반 해시를 사용하는 단지의 &lt;code&gt;{LIST}&lt;/code&gt; 필드 사용자가 실제 해시로 생각합니다.</target>
        </trans-unit>
        <trans-unit id="07709450f49a2785357dceda9bbcd6e033ef5380" translate="yes" xml:space="preserve">
          <source>In paragraphs where formatting codes (like E&amp;lt;...&amp;gt;, B&amp;lt;...&amp;gt;) are understood (i.e.,</source>
          <target state="translated">서식 코드 (예 : E &amp;lt;...&amp;gt;, B &amp;lt;...&amp;gt;)가 이해되는 단락에서 (즉,</target>
        </trans-unit>
        <trans-unit id="fb0742f46f732e81f9ef6b26f9dd077a50514538" translate="yes" xml:space="preserve">
          <source>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the &lt;code&gt;parse_text&lt;/code&gt; routine in Pod::Parser as an example of a correct implementation.</source>
          <target state="translated">포드를 파싱하는 데있어 까다로운 부분은 포맷팅 코드를 올바르게 파싱하는 것입니다. 구현 자는 올바른 구현의 예로 Pod :: Parser 의 &lt;code&gt;parse_text&lt;/code&gt; 루틴에 있는 코드를 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e44b2915e9ebcfa80eaf0cd0b8fc6a537b378a7a" translate="yes" xml:space="preserve">
          <source>In parsing an L&amp;lt;...&amp;gt; code, Pod parsers must distinguish at least four attributes:</source>
          <target state="translated">L &amp;lt;...&amp;gt; 코드를 구문 분석 할 때 포드 파서는 최소한 네 가지 속성을 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="173ae1b4c7abf280ed9de2a2e4233e82968c1ade" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt; . But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt; ) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt; ). Casing in this document is for improved legibility.</source>
          <target state="translated">이러한 구문을 구문 분석 할 때 Perl은 항상 {braces} 내의 모든 위치에서 대문자 / 소문자 차이를 무시합니다. 따라서 &lt;code&gt;\p{Greek}&lt;/code&gt; 은 &lt;code&gt;\p{greek}&lt;/code&gt; 와 같은 의미 입니다. 그러나 왼쪽 괄호 앞에 &lt;code&gt;&quot;p&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 의 대소 문자를 변경하면 구문의 의미가 &quot;match&quot;( &lt;code&gt;\p{}&lt;/code&gt; )에서 &quot;does n't match&quot;( &lt;code&gt;\P{}&lt;/code&gt; ). 이 문서의 케이스는 가독성을 향상시키기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9aaf8e25ca7ca9dd8d4b03a35ad6a47a7f371c04" translate="yes" xml:space="preserve">
          <source>In particular</source>
          <target state="translated">특히</target>
        </trans-unit>
        <trans-unit id="2f4b20effb603658d4594f20068f3202a019f207" translate="yes" xml:space="preserve">
          <source>In particular have a hunt around for the following:</source>
          <target state="translated">특히 다음을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="549a73d37bd647b3d02bdfb1ed4587a94e6c791c" translate="yes" xml:space="preserve">
          <source>In particular the following metacharacters have their standard</source>
          <target state="translated">특히 다음 메타 문자는 표준을 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="d9ca3d8c112df43cded72f31c7db395214aede20" translate="yes" xml:space="preserve">
          <source>In particular,</source>
          <target state="translated">특히,</target>
        </trans-unit>
        <trans-unit id="ef80eb5daee93a0d4fde8126fc49aefdc4e89c82" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Tie::File&lt;/code&gt; will</source>
          <target state="translated">특히, &lt;code&gt;Tie::File&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2db3c0671aba0d3ee80c31fffb1da43c83f4160e" translate="yes" xml:space="preserve">
          <source>In particular, braces do not need to be balanced:</source>
          <target state="translated">특히 중괄호는 균형을 맞출 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cbf0bbf93ed5b0e470ae4c77978f151618da6e4" translate="yes" xml:space="preserve">
          <source>In particular, follow these general guidelines for patching Perl sources:</source>
          <target state="translated">특히 Perl 소스 패치에 대한 다음 일반 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="588a69fc1734910196fa33dcc3398592c9c2b486" translate="yes" xml:space="preserve">
          <source>In particular, if you are using Info-Zip you need to have zip version 3.x or better to update a Zip64 archive and unzip version 6.x to read a zip64 archive.</source>
          <target state="translated">특히 Info-Zip을 사용하는 경우 Zip64 아카이브를 업데이트하려면 zip 버전 3.x 이상이 필요하고 zip64 아카이브를 읽으려면 버전 6.x의 압축을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b8504eca27d4d7dd980e055d06368ef344507bf5" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">특히 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; FH를 사용하여 파이프를 열면 &quot;|-&quot; 부모 프로세스에서 close ()를 사용하여 원치 않는 기록기를 닫을 수 없습니다. 이 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="55f883bf0e56efd410000618d8c0d414be5f0032" translate="yes" xml:space="preserve">
          <source>In particular, it is not possible to write general-purpose classes in this technique, classes that can advertise themselves as &quot;Put me on your @ISA list and use my methods&quot;. If the other class has different ideas about how the object body is used, there is trouble.</source>
          <target state="translated">특히,이 기술에서 범용 클래스를 작성하는 것은 불가능합니다. &quot;@ISA 목록에 저를두고 내 방법을 사용하십시오&quot;라고 스스로 광고 할 수있는 클래스입니다. 다른 클래스가 객체 바디 사용 방법에 대해 다른 아이디어를 가지고 있다면 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd11e0201dc297df1cba370809db0d5939f0ec0" translate="yes" xml:space="preserve">
          <source>In particular, the extensions &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; and &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; are not supported under EBCDIC; likewise for the (now deprecated) &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma.</source>
          <target state="translated">특히 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: Collate&lt;/a&gt; 및 &lt;a href=&quot;unicode/normalize&quot;&gt;유니 코드 :: Normalize&lt;/a&gt; 확장 은 EBCDIC에서 지원되지 않습니다. (현재 사용되지 않는) &lt;a href=&quot;encoding&quot;&gt;인코딩&lt;/a&gt; pragma에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="b491336832fe24926f813912697f1c74d79ed48d" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt; , regardless of any &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">특히, 특수 &lt;code&gt;${^_XYZ}&lt;/code&gt; 변수는 현재 범위 내에 있는 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 선언에 관계없이 항상 패키지 &lt;code&gt;main&lt;/code&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5adbc38d169db3c0edbc488274012a781b34d025" translate="yes" xml:space="preserve">
          <source>In particular, this API does &lt;b&gt;not&lt;/b&gt; provide the following functions:</source>
          <target state="translated">특히이 API는 다음 기능을 제공 하지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="26d259999f6bd5eabc0e32bc92fd018cffcba101" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">특히 아직 설치되지 않은 확장을 테스트하는 데 사용되는 &lt;code&gt;@INC&lt;/code&gt; 의 구조에 적용 할 수 있습니다. 제거 된 확장 기능을 실행하면 훨씬 더 많은 오버 헤드가 같은 확장을 실행하는 것보다 이후에있을 수 있음이 수단 &lt;code&gt;make install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2e58986eb4f3be556785c248e50c152e1a4485" translate="yes" xml:space="preserve">
          <source>In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:</source>
          <target state="translated">특히 이는 할당을 위해 두 집계 중에서 선택하기 위해 이것을 사용해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">특히:</target>
        </trans-unit>
        <trans-unit id="f7e08b6bdc00b0694ecd1bf1d445c34c08eeec2b" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">코드의 텍스트가 아니라 소스 코드 / 패턴에 그대로 나타나는 것보다 실행 시간 정보에서 파생 패턴 / 코드는 패턴이 컴파일과 동시에 컴파일 및 보안의 이유입니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 은 범위 내에 있어야합니다. 코드 스 니펫이 포함 된 사용자 제공 패턴이 실행되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ea88d26430c6d46158be27b80e4634d3a9d07c0" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE,EXPR&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14 이상에서 &lt;code&gt;fchdir&lt;/code&gt; C 함수를 지원하지 않는 Windows 이외의 시스템 에서는 디렉토리 핸들 ( &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE, EXPR&lt;/a&gt; 참조 )이 새 스레드로 복사되지 않습니다. &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; 에서 &lt;code&gt;d_fchdir&lt;/code&gt; 변수를 사용할 수 있습니다 하여 시스템이이를 지원하는지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="978dbedfe97270c6d04770e8f1b09ed5adf8e8d1" translate="yes" xml:space="preserve">
          <source>In perl 5.8.0, &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; was also used to mark placeholders in restricted hashes. This caused such hash entries not to appear when iterating over the hash or when checking for the keys with the &lt;code&gt;hv_exists&lt;/code&gt; function.</source>
          <target state="translated">perl 5.8.0에서는 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용하여 제한된 해시에서 플레이스 홀더를 표시했습니다. 이로 인해 해시를 반복하거나 &lt;code&gt;hv_exists&lt;/code&gt; 함수로 키를 확인할 때 이러한 해시 항목이 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2d10ca79661f6cd0c4cfd21cf2e8aa0ee582a6a" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared amongst all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">perl 5.8.1 이상에서 Test :: Builder는 스레드로부터 안전합니다. 테스트 번호는 모든 스레드간에 공유됩니다. 이것은 하나의 스레드가 &lt;code&gt;current_test()&lt;/code&gt; 사용하여 테스트 번호를 설정하면 의미합니다 를 하면 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1269cc2ad1ea6f2d742e35bd480e05b3838a6225" translate="yes" xml:space="preserve">
          <source>In perl v5.8.0, you can work around this as follows;</source>
          <target state="translated">perl v5.8.0에서는 다음과 같이이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3903f5f9bb5ec2db6467ae7e05ade21cf24078e9" translate="yes" xml:space="preserve">
          <source>In perls older than 5.8.1, map suffers from this problem as well. But since 5.8.1, this has been fixed, and map is context aware - in void context, no lists are constructed.</source>
          <target state="translated">5.8.1 이전의 perls에서는 맵에서도이 문제가 발생합니다. 그러나 5.8.1 이후로이 문제는 해결되었으며지도는 상황을 인식합니다. 무효 상황에서는 목록이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="201c993ba430d2b34780a5f6bce751f372ee2124" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill()&quot;&gt;kill()&lt;/a&gt;, above.</source>
          <target state="translated">이식 가능한 Perl 코드 에서 강제 종료 프로세스 에는 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; 해서는 안됩니다. 분기 프로세스를 종료하면 안전하지 않으며 예측할 수없는 결과가 나타납니다. 위의 &lt;a href=&quot;#kill()&quot;&gt;kill ()을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64e70c5c9f546a348d8be9f13ed9b3d5b217325e" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;io/socket/ip&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">실제로이 논리는 &lt;a href=&quot;io/socket/ip&quot;&gt;IO :: Socket :: IP에&lt;/a&gt; 의해 더 잘 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f10d5bbc85368eaaed58b49509d8d5537fcea2c6" translate="yes" xml:space="preserve">
          <source>In practice this makes seldom a difference as &lt;b&gt;parts and results&lt;/b&gt; of expressions will be truncated anyway, but this can, for instance, affect the return value of subroutines:</source>
          <target state="translated">실제로 이것은 표현식의 &lt;b&gt;부분과 결과&lt;/b&gt; 가 잘 리기 때문에 거의 차이 가 없지만, 예를 들어 서브 루틴의 리턴 값에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8bdda291d4d16e099108c0540471c243257c86" translate="yes" xml:space="preserve">
          <source>In practice, Perl scripts that call programs that return _POSIX_EXIT type status values will be expecting those values, and programs that call traditional VMS programs will either be expecting the previous behavior or just checking for a non-zero status.</source>
          <target state="translated">실제로, _POSIX_EXIT 유형 상태 값을 리턴하는 프로그램을 호출하는 Perl 스크립트는 해당 값을 예상하고 기존 VMS 프로그램을 호출하는 프로그램은 이전 동작을 예상하거나 0이 아닌 상태를 점검합니다.</target>
        </trans-unit>
        <trans-unit id="6ed326b6d59e850419b57af366a49ca220934029" translate="yes" xml:space="preserve">
          <source>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</source>
          <target state="translated">실제로이 문자는 자주 사용되지 않지만 포맷터는이를 지원하거나 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="796550631a5df07b05a560a67d63d7ad67fdf7c5" translate="yes" xml:space="preserve">
          <source>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</source>
          <target state="translated">이전 섹션에서는 숫자와 문자열을 묶는 방법을 살펴 보았습니다. 그것이 몇 가지 걸림돌이 아니었다면 C 구조에는 다른 것이 포함되어 있지 않으므로이 섹션을 즉시 결론 지을 수 있습니다. 따라서 이미 모든 것을 알고 있습니다. 죄송합니다. 계속 읽어주세요.</target>
        </trans-unit>
        <trans-unit id="692b842adc759f56816c9c058cae643b8a51086a" translate="yes" xml:space="preserve">
          <source>In principle the unpack() command can be used to convert the bytes back to a number (if the underlying type is known to be a number).</source>
          <target state="translated">원칙적으로 unpack () 명령을 사용하여 바이트를 숫자로 다시 변환 할 수 있습니다 (기본 유형이 숫자라고 알려진 경우).</target>
        </trans-unit>
        <trans-unit id="1221515422031848620efe6d264c7054adcd4f04" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">이전 펄 버전에서는 디렉토리 핸들이 열려있는 스폰 스레드가 인터프리터와 충돌했습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[펄 # 75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d807cc153636cb39c76e4cb0277ef6012694dae7" translate="yes" xml:space="preserve">
          <source>In programs:</source>
          <target state="translated">프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="48c74c56dfa96426cf79d4567af2599b0fde094e" translate="yes" xml:space="preserve">
          <source>In recent years, vendors have begun to supply systems free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">최근 몇 년 동안 공급 업체는 이러한 고유 보안 버그가없는 시스템을 공급하기 시작했습니다. 이러한 시스템에서 커널은 간섭을받는 경로 이름을 사용하지 않고 set-id 스크립트의 이름을 전달하여 인터프리터에 열면 대신 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fc7a0ac9fe9f163678a08865a8ae2ec22fbc06ff" translate="yes" xml:space="preserve">
          <source>In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;, meaning that it doesn't represent a character in the string, but a condition at a certain position.</source>
          <target state="translated">정규 표현식에서 단어 경계 (\ b)는 &quot;제로 폭 주장&quot;으로, 문자열의 문자를 나타내지 않고 특정 위치의 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b5ca67e58e909ea0b763b445166b0dc50f9fff9" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt; , for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt; . If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; , by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; .</source>
          <target state="translated">정규 표현식에서 배열 첨자와 문자 클래스를 명확하게하기 위해 &lt;code&gt;${foo[2]}&lt;/code&gt; 구문이 필요할 때가 있습니다. 예를 들어, &lt;code&gt;/$length[2345]/&lt;/code&gt; 는 &lt;code&gt;$length&lt;/code&gt; 뒤에 문자 클래스 &lt;code&gt;[2345]&lt;/code&gt; 로 해석됩니다 . 배열 첨자가 원하는 것이라면 &lt;code&gt;/${length[2345]}/&lt;/code&gt; 를보기 흉한 &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; 로 바꾸지 않고 배열의 이름을 일치하지 않는 것으로 바꾸면 경고를 피할 수 있습니다 내장 키워드를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 경고 를 끄는 것 ; .</target>
        </trans-unit>
        <trans-unit id="870f19d24df4b4eee6c062f874fd2afacdfc9f30" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">스칼라 컨텍스트에서는 내부에서 동일한 패턴 으로 원시 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 를 문자열화할 때 perl과 동일하게 리턴합니다 . 인수가 컴파일 된 참조가 아닌 경우이 루틴은 false를 리턴하지만 스칼라 컨텍스트로 정의되고 목록 컨텍스트의 빈 목록을 리턴합니다. 따라서 다음</target>
        </trans-unit>
        <trans-unit id="0a19f93e8a70aa3709a4c5eb5c497d67c74952ec" translate="yes" xml:space="preserve">
          <source>In scalar context will return just the IP address.</source>
          <target state="translated">스칼라 컨텍스트에서는 IP 주소 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1370034b95e83c1602601f8f2c93a5f4f13c28ad" translate="yes" xml:space="preserve">
          <source>In scalar context without arguments, this method returns the number of parsers aggregated. In list context without arguments, returns the parsers in the order they were added.</source>
          <target state="translated">인수가없는 스칼라 컨텍스트에서이 메소드는 집계 된 구문 분석기 수를 리턴합니다. 인수가없는 목록 컨텍스트에서 파서가 추가 된 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e333b48f248d91366426a74dfbbc3da65c8ea7d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&quot;..&quot;&lt;/code&gt; returns a boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and various editors. Each &lt;code&gt;&quot;..&quot;&lt;/code&gt; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 는 부울 값을 반환합니다. 연산자는 플립 플롭처럼 쌍 안정하며 &lt;b&gt;sed&lt;/b&gt; , &lt;b&gt;awk&lt;/b&gt; 및 다양한 편집기 의 라인 범위 (쉼표) 연산자를 에뮬레이트합니다 . 각 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 연산자는이를 포함하는 서브 루틴에 대한 호출에서도 고유 한 부울 상태를 유지합니다. 왼쪽 피연산자가 false 인 한 false입니다. 왼쪽 피연산자가 true이면 오른쪽 피연산자가 true가 될 때까지 범위 연산자는 true를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4702696bd1a6606f8c00bfa48b7462e238b219f8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 ctime (3) 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50ab8480db61cacd9dd3820b8d1635a7c8fbf2e8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 는 성공 또는 실패를 나타내는 부울 값을 리턴하고 성공하면 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 연관된 정보를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d1818a475de168c2b1a7d2bb086c2af5a3f3a97b" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$user&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d16f2c8ac24f3fef816016a050127e8baea1e4f0" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 ctime (3) 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c038fe7af8fd4fba37237e821dee5726e03d9bcf" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 는 성공 또는 실패를 나타내는 부울 값을 리턴하고 성공하면 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 연관된 정보를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f361652bf48a4a2a1736272eaacbdbdece5ad741" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$user&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67f63380dd91d8509df2b85f67d144a31345d453" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function; see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">스칼라 컨텍스트에서 각 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 실행은 다음 일치를 찾아 일치하는 경우 true를 리턴하고 일치하지 않으면 false를 리턴합니다. 마지막 일치 이후의 위치는 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 읽거나 설정할 수 있습니다 . &lt;a href=&quot;functions/pos&quot;&gt;pos를&lt;/a&gt; 참조하십시오 . 실패한 일치는 일반적으로 검색 위치를 문자열의 시작으로 재설정하지만 &lt;code&gt;/c&lt;/code&gt; 수정자를 추가하여 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; )이를 피할 수 있습니다 . 대상 문자열을 수정하면 검색 위치도 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8800b54c59ca34fbb2fd00902e130cb43eb3acc5" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">스칼라 컨텍스트에서 꺾쇠 괄호로 파일 핸들을 평가하면 해당 파일에서 다음 줄 (있는 경우 새 줄 포함)이 생성되거나 파일 끝에서 또는 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 생성됩니다. 때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (때로는 파일 소리내어 먹는다 모드라고도 함)와 파일이 비어, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="90d5e99280edc013a52bda47119a081391fd852e" translate="yes" xml:space="preserve">
          <source>In scalar context, just the filehandle is returned.</source>
          <target state="translated">스칼라 컨텍스트에서는 파일 핸들 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26e7b891880cf2546cd4182b9d0f0a5ab5924094" translate="yes" xml:space="preserve">
          <source>In scalar context, the function returns the most preferred language tag (or undef if no preference was seen).</source>
          <target state="translated">스칼라 컨텍스트에서이 함수는 가장 선호하는 언어 태그를 반환합니다 (또는 기본 설정이 없으면 undef).</target>
        </trans-unit>
        <trans-unit id="b1d9f6c7ff92d9e4431c44fd49623f31abe26893" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time in the timer is returned.</source>
          <target state="translated">스칼라 컨텍스트에서 타이머의 남은 시간이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f286b508bea32b55376de76bb51800a879183e4c" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time is returned.</source>
          <target state="translated">스칼라 컨텍스트에서 남은 시간이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc032fde56245f910fbc6d13638ce22e45ea79e" translate="yes" xml:space="preserve">
          <source>In scalar context, you get the name, unless the function was a lookup by name, in which case you get the other thing, whatever it is. (If the entry doesn't exist you get the undefined value.) For example:</source>
          <target state="translated">스칼라 문맥에서 함수가 이름으로 조회하지 않는 한 이름을 얻습니다.이 경우 다른 것을 얻습니다. 항목이 존재하지 않으면 정의되지 않은 값을 얻습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="070ead24adcf97bbf0458e41cddfaf9060fd1c75" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , do not change their behavior with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 범위에서 ; 위의 거의 모든 연산자는 인수를 정수 형식으로 만들고 정수 결과를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 예외 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 정수 를 사용 하여 동작을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fd63b759e64d942882eb1c88a05afcfdaffadf" translate="yes" xml:space="preserve">
          <source>In searching for &lt;code&gt;/\bfoo\b/&lt;/code&gt; , only locations in &lt;code&gt;$_&lt;/code&gt; that contain &lt;code&gt;f&lt;/code&gt; will be looked at, because &lt;code&gt;f&lt;/code&gt; is rarer than &lt;code&gt;o&lt;/code&gt; . In general, this is a big win except in pathological cases. The only question is whether it saves you more time than it took to build the linked list in the first place.</source>
          <target state="translated">을 찾기 위해 &lt;code&gt;/\bfoo\b/&lt;/code&gt; 에 위치 만 &lt;code&gt;$_&lt;/code&gt; 포함 &lt;code&gt;f&lt;/code&gt; 있으므로 보았다한다 &lt;code&gt;f&lt;/code&gt; 보다 드물다 &lt;code&gt;o&lt;/code&gt; . 일반적으로 병리학 적 사례를 제외하고는 큰 승리입니다. 유일한 질문은 연결 목록을 작성하는 데 걸리는 시간보다 더 많은 시간을 절약 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d510b9d55974c5ad5785f6cfe4077983c695078d" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">요컨대, Perl 4는 Perl 5와 Perl 6의 부모입니다. Perl 5는 더 오래된 형제이며, 언어는 다르지만, 한 언어를 알고있는 사람은 다른 언어와 많은 유사점을 발견 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a022deee593194afb675e77892be1749073d500f" translate="yes" xml:space="preserve">
          <source>In simple cases, it is equivalent to:</source>
          <target state="translated">간단한 경우에는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffcc65b4ec59c10cd981321f645c18e2c2833005" translate="yes" xml:space="preserve">
          <source>In simple terms, this is what happens:</source>
          <target state="translated">간단히 말해서, 이것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="d121139946109160493990901ec9a05c62500b61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">당신이 사용하도록 설정해야 할 상황에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , 당신은 또한 더러운 검사를해야 사용 가능. 더 좋은 방법은 세이프 컴 파트먼트 내에서 신중하게 제한된 평가를 사용하십시오. 이 두 가지 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2046d35bd71cc3166ad97adddb890d2444c1f0f" translate="yes" xml:space="preserve">
          <source>In some cases (starting server processes, for instance) you'll want to completely dissociate the child process from the parent. This is often called daemonization. A well-behaved daemon will also chdir() to the root directory so it doesn't prevent unmounting the filesystem containing the directory from which it was launched, and redirect its standard file descriptors from and to</source>
          <target state="translated">경우에 따라 (예 : 서버 프로세스 시작) 하위 프로세스를 상위 프로세스와 완전히 분리해야 할 수도 있습니다. 이를 종종 데몬 화라고합니다. 잘 동작하는 데몬은 chdir ()을 루트 디렉토리로 보내서 시작된 디렉토리를 포함하는 파일 시스템을 마운트 해제하지 못하도록하고 표준 파일 디스크립터를이 디렉토리로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="fd4562e3425450ab12fc121ff9cd696fd05153a4" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless C&amp;lt;:_exit&amp;gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">경우에 따라 File :: Temp로 만든 파일이 END 블록 내에서 제거됩니다. 하위 프로세스가 종료 될 때 END 블록이 트리거되므로 (하위가 C &amp;lt;: _ exit&amp;gt;를 사용하지 않는 한) File :: Temp는 특정 프로세스 ID로 작성된 임시 파일 만 제거합니다. 이는 하위 프로세스가 상위 프로세스에서 작성된 임시 파일을 제거하려고 시도하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4cd284f272380bf09ca4f9468d05eb334cb95414" translate="yes" xml:space="preserve">
          <source>In some cases the 'application' can then be reduced to a small</source>
          <target state="translated">어떤 경우에는 '응용 프로그램'을 작은 것으로 줄일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="df381c2814bde8cd15795ab2d100f8c130800cb5" translate="yes" xml:space="preserve">
          <source>In some cases this</source>
          <target state="translated">경우에 따라</target>
        </trans-unit>
        <trans-unit id="cde62ba475df964750a3cdf495be48e1d052051b" translate="yes" xml:space="preserve">
          <source>In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</source>
          <target state="translated">경우에 따라 파일을 만들 때이 변수가 true 인 경우에만 파일이 유지됩니다. 즉, 임시 파일을 만들 수 없으며이 변수를 설정하고 프로그램이 종료 될 때 임시 파일이 계속 남아있을 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="3905e6a37b63c12afc3763addc4e36a653fc636f" translate="yes" xml:space="preserve">
          <source>In some cases, using substr() or vec() to simulate arrays can be highly beneficial. For example, an array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one 125-byte bit vector--a considerable memory savings. The standard Tie::SubstrHash module can also help for certain types of data structure. If you're working with specialist data structures (matrices, for instance) modules that implement these in C may use less memory than equivalent Perl modules.</source>
          <target state="translated">경우에 따라 배열을 시뮬레이션하기 위해 substr () 또는 vec ()를 사용하는 것이 매우 유리할 수 있습니다. 예를 들어, 1,000 개의 부울 배열은 최소 20,000 바이트의 공간을 차지하지만 125 바이트 비트 벡터로 변환 할 수있어 상당한 메모리 절약 효과를 얻을 수 있습니다. 표준 Tie :: SubstrHash 모듈은 특정 유형의 데이터 구조에 도움이 될 수 있습니다. C에서 이러한 데이터를 구현하는 특수 데이터 구조 (예 : 매트릭스)로 작업하는 경우 동등한 Perl 모듈보다 적은 메모리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e84c8e00f2a5bb70e605cd2c69e1dd80d922f5" translate="yes" xml:space="preserve">
          <source>In some cases, yes. You can use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">어떤 경우에는 그렇습니다. &lt;code&gt;iter&lt;/code&gt; 클래스 메소드를 사용하여 메모리에서 모든 파일을 한 번에 읽지 않고 tarball의 파일을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da7c53f5c4edfd54be873e35b150cbb2e0f64102" translate="yes" xml:space="preserve">
          <source>In some cases, you may be able to make several patterns into a single regular expression. Beware of situations that require backtracking though.</source>
          <target state="translated">경우에 따라 여러 패턴을 단일 정규식으로 만들 수 있습니다. 역 추적이 필요한 상황에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="55ed1ae3a3af36b978490ace319abb286ca584e8" translate="yes" xml:space="preserve">
          <source>In some cases, you'll want to completely skip an entire testing script.</source>
          <target state="translated">경우에 따라 전체 테스트 스크립트를 완전히 건너 뛰고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b444fb6bd755ce68abe6b0c45e2101b6fb938848" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">일부 상황에서, 백 슬래시 다음에 2 개 또는 1 개의 8 진수가 뒤 따르는 경우, 때때로 경고와 함께, 일부 버그로 인해 때로는 놀라운 결과가 나오는 8 진수 이스케이프로 해석 될 수 있습니다. 또한 작은 스 니펫을 함께 연결하여 정규 표현식을 작성하고 3 자리 미만을 사용하는 경우 하나의 스 니펫 시작 부분은 스 니펫 끝 부분에 숫자를 추가하는 것으로 해석 될 수 있습니다. 스 니펫 문제에 대한 자세한 설명 및 예제는 &lt;a href=&quot;#Absolute-referencing&quot;&gt;절대 참조&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="941b228759db0ad2f21515f9edebce99234327a5" translate="yes" xml:space="preserve">
          <source>In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</source>
          <target state="translated">향후 버전의 I18N :: LangTags에서는 RFC2482 스타일 언어 태그에 대한 지원을 포함 할 계획입니다. 기본적으로 ASCII 문자가 평면 14로 이동 된 일반 언어 태그입니다.</target>
        </trans-unit>
        <trans-unit id="b0260d31b907a523df71ffe831436a5256c0c0bb" translate="yes" xml:space="preserve">
          <source>In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.</source>
          <target state="translated">일부 문헌에서이 구축물을 &quot;원자 매칭&quot;또는 &quot;포지티브 매칭&quot;이라고한다.</target>
        </trans-unit>
        <trans-unit id="79419ef5fc7d87682a2736d33053a4e99ddcc17b" translate="yes" xml:space="preserve">
          <source>In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.</source>
          <target state="translated">일부 플랫폼에서는 1 초 미만의 해상도로 알람을받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6aef2a6b389cc51b9d270ade7d87dfa403f876dd" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt; . In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">일부 플랫폼에서는 &lt;code&gt;ps&lt;/code&gt; 로 표시된 수정 된 이름 뒤에 임의의 양의 패딩 (예 : 공백 문자)이있을 수 있습니다 . 일부 플랫폼에서이 패딩은 사용자가 무엇을하든 인수 영역의 원래 길이까지 확장 될 수 있습니다 (예 : Linux 2.2의 경우).</target>
        </trans-unit>
        <trans-unit id="08216ba09095e01bafc1d8f5f89aaf1f507c0440" translate="yes" xml:space="preserve">
          <source>In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.</source>
          <target state="translated">경우에 따라 특정 심볼을 내 보내지 못하게 할 수도 있습니다. 일반적으로 이는 일부 시스템에는 없을 수있는 함수 나 상수가있는 확장에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f0ffd2574e55bd73781b2f238993d92b6b53578" translate="yes" xml:space="preserve">
          <source>In spite of its name,</source>
          <target state="translated">그 이름에도 불구하고</target>
        </trans-unit>
        <trans-unit id="3a8cbd2876234fb0eafe4d9966f4f375e97df144" translate="yes" xml:space="preserve">
          <source>In such cases, to force an additional variable to be declared together with declarations of other variables, place the declaration into a PREINIT: section. The PREINIT: keyword may be used one or more times within an XSUB.</source>
          <target state="translated">이 경우 추가 변수를 다른 변수 선언과 함께 선언하려면 선언을 PREINIT : 섹션에 배치하십시오. PREINIT : 키워드는 XSUB 내에서 한 번 이상 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9198f5929b9dd8df4d3b09d9577116cbbad276" translate="yes" xml:space="preserve">
          <source>In such cases, you are advised to either split the test file into smaller ones, or use a reverse approach, doing &quot;normal&quot; (code) compares and triggering &lt;code&gt;fail()&lt;/code&gt; should anything go unexpected.</source>
          <target state="translated">이러한 경우 테스트 파일을 더 작은 파일로 분할하거나 역 접근 방식을 사용하여 &quot;정상&quot;(코드) 비교를 수행하고 예기치 않은 상황이 발생 &lt;code&gt;fail()&lt;/code&gt; 트리거하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a4b3a6172283064c4d2c38bcdfc1abf019578af1" translate="yes" xml:space="preserve">
          <source>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</source>
          <target state="translated">요약하면, Perl은 일반적으로 유니 코드가 아닌 코드 포인트를 정규 표현식 일치에 대한 일반적인 유니 코드 지정되지 않은 코드 포인트로 취급하여 결과가 무엇인지 논쟁 할 수있을 때만 경고를 발생시킵니다. 그러나이 경고가 치명적이면 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdfe847eef52d0f5e340cab498d8b20a1e1ac3a3" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt; . When the user types</source>
          <target state="translated">요약하면, 일부 foo의 경우 컴파일러 백엔드 모듈을 &quot;B :: Foo&quot;라고하고 해당 이름의 해당 디렉토리에 있어야합니다. &lt;code&gt;compile&lt;/code&gt; 이라는 함수를 정의해야합니다 . 사용자가 입력 할 때</target>
        </trans-unit>
        <trans-unit id="fc74db358d542b3438f19ea437ddcca2306a63f1" translate="yes" xml:space="preserve">
          <source>In summary, local() doesn't make what you think of as private, local variables. It gives a global variable a temporary value. my() is what you're looking for if you want private variables.</source>
          <target state="translated">요약하면 local ()은 개인 로컬 변수로 생각하지 않습니다. 전역 변수에 임시 값을 제공합니다. 개인 변수를 원한다면 my ()가 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="f27d5775b98cc1edc00b71d0a359c25acea44018" translate="yes" xml:space="preserve">
          <source>In telephony, the temporary electrical circuit between the caller&amp;rsquo;s and the callee&amp;rsquo;s phone. In networking, the same kind of temporary circuit between a &lt;b&gt;client&lt;/b&gt; and a &lt;b&gt;server&lt;/b&gt;.</source>
          <target state="translated">전화 통신에서 발신자와 수신자의 전화 사이의 임시 전기 회로. 네트워킹에서 &lt;b&gt;클라이언트&lt;/b&gt; 와 &lt;b&gt;서버&lt;/b&gt; 간의 동일한 종류의 임시 회로 .</target>
        </trans-unit>
        <trans-unit id="8a961ce11a5972421c4f26b07fe69c91b0c3c7f5" translate="yes" xml:space="preserve">
          <source>In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file. We changed this to a relative path so that we could move the extension directory if we wanted to.</source>
          <target state="translated">.xs 파일에는 mylib.h 헤더 파일의 절대 경로가있는 #include 지시문이 있습니다. 원하는 경우 확장 디렉토리를 이동할 수 있도록 이것을 상대 경로로 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="f2ed93444f2e4f61ea8ed89fb84f5492a5e66658" translate="yes" xml:space="preserve">
          <source>In the 5.9.x development version of perl you can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="translated">perl의 5.9.x 개발 버전 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; 를 사용하여 구문 분석 프로세스에 대한 추적 정보를 볼 수 있습니다. 간단한 패턴부터 시작하여 더 복잡한 패턴을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="695cc6d82e9a098f429aaf4feaee8cd47933f5d7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">에서 &lt;code&gt;Encode&lt;/code&gt; 모듈, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 의 정식 이름 실제로 &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;8&quot;&lt;/code&gt; 사이의 하이픈 은 중요합니다. 그것없이, &lt;code&gt;Encode&lt;/code&gt; 는 &quot;자유&quot;적이며 (아마도 지나치게) 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4feedfc56c9ca92e3c18dcd179dd65dfefb5217" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SvPV&lt;/code&gt; macro, the length of the string returned is placed into the variable &lt;code&gt;len&lt;/code&gt; (this is a macro, so you do</source>
          <target state="translated">에서 &lt;code&gt;SvPV&lt;/code&gt; 의 매크로, 반환 된 문자열의 길이는 변수에 배치됩니다 &lt;code&gt;len&lt;/code&gt; 당신이 할 수 있도록,이 매크로입니다 (</target>
        </trans-unit>
        <trans-unit id="070901afbf1f09255274e8877eb8bc2c70b45164" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form,</source>
          <target state="translated">에서 &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 형태</target>
        </trans-unit>
        <trans-unit id="95cc687da96e0b7f7623a95a00b37de925f9f2e9" translate="yes" xml:space="preserve">
          <source>In the C part of the XS file (above the first MODULE line) you have</source>
          <target state="translated">XS 파일의 C 부분 (첫 번째 MODULE 줄 위)에는</target>
        </trans-unit>
        <trans-unit id="9da81592ea409347d5f06bd8bb3e9dfa81794242" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt; , and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; . There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">설명을 위해 의도적으로 난독 화 된 위의 RE에서 구분 기호는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 이고 수정자는 &lt;code&gt;mx&lt;/code&gt; 이며 구분 기호 제거 후 RE는 &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; 합니다. 분리 문자를 영숫자가 아닌 공백이 아닌 선택으로 제한하도록 권장하는 이유는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e13a699e1847e4e4560a850a3ff6592656db6884" translate="yes" xml:space="preserve">
          <source>In the above &quot;TAP&quot;, the second and fourth lines will generate &quot;Unknown&quot; tokens.</source>
          <target state="translated">위의 &quot;TAP&quot;에서 두 번째 및 네 번째 줄은 &quot;알 수없는&quot;토큰을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="058e91307a10961fd993a819105cb638818d3bdd" translate="yes" xml:space="preserve">
          <source>In the above [A, C] example, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; hook could return:</source>
          <target state="translated">위의 [A, C] 예에서 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 후크는 다음을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb159de765838e35dcdde7356fd1bd005beb7684" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt; .)</source>
          <target state="translated">위의 스레드 객체는 스칼라 컨텍스트에서 상위 스레드로 반환되고 스레드의 진입 점 함수 &lt;code&gt;foo&lt;/code&gt; 는 목록 (배열) 컨텍스트에서 호출되어 상위 스레드가 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 에서 목록 (배열)을받을 수 있습니다. () 전화. ( &lt;code&gt;'array'&lt;/code&gt; 는 &lt;code&gt;'list'&lt;/code&gt; 와 동의어입니다 .)</target>
        </trans-unit>
        <trans-unit id="9d73b10ae1520507352b424e24dd93e5f334c96c" translate="yes" xml:space="preserve">
          <source>In the above, your &lt;code&gt;frobnicate&lt;/code&gt; function has been changed to be made aware of whether or not it's dealing with UTF-8 data, so that it can handle the string appropriately.</source>
          <target state="translated">위의 &lt;code&gt;frobnicate&lt;/code&gt; 함수는 UTF-8 데이터를 처리하는지 여부를 인식하도록 변경되어 문자열을 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c7cb8befa26cf8853246bc9e4f9d7c53539559" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; 는 정렬 (정렬) 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 정렬 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="15ce031d9fce06ed575c3914c8c9ea6101622d1e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 과 &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6468a6eaf61ca1746bc5af34d7e2d7db949b3755" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; 는 통화 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 통화 서식 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="aa4035e23872d9d83606fa0ea98c9a044e6d0674" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">이 없을 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; 는 숫자 형식 로케일을 선택한다. 양쪽의 부재 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 는 숫자 형식을 선택한다.</target>
        </trans-unit>
        <trans-unit id="6ab8079d22785df117a0b766ea8b7c3baae6e9c3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; 은 날짜 및 시간 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 날짜와 시간 포맷 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="68e71f53c7f8acf89933bfc63a04da9641a2aa37" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">괄호가없는 경우 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 와 같은 목록 연산자의 우선 순위는 연산자 의 왼쪽 또는 오른쪽을보고 있는지에 따라 매우 높거나 매우 낮습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8e8c77934a4391ccf6a1b211036cc4430a6aec4a" translate="yes" xml:space="preserve">
          <source>In the argument hashref,</source>
          <target state="translated">hashref 인수에서</target>
        </trans-unit>
        <trans-unit id="c8faecb0e00885cd9d3471fff022824b0e193793" translate="yes" xml:space="preserve">
          <source>In the beginning there was ASCII, the &quot;American Standard Code for Information Interchange&quot;, which works quite well for Americans with their English alphabet and dollar-denominated currency. But it doesn't work so well even for other English speakers, who may use different currencies, such as the pound sterling (as the symbol for that currency is not in ASCII); and it's hopelessly inadequate for many of the thousands of the world's other languages.</source>
          <target state="translated">처음에는 &quot;정보 교환을위한 미국 표준 코드&quot;인 ASCII가 있었는데, 이는 영어 알파벳과 달러 표시 통화로 미국인들에게 잘 작동합니다. 그러나 파운드 스털링과 같은 다른 통화를 사용하는 다른 영어 사용자들에게는 그다지 효과적이지 않습니다 (해당 통화의 기호가 ASCII가 아님). 그리고 세계의 수많은 다른 언어들에게는 절망적으로 부적절합니다.</target>
        </trans-unit>
        <trans-unit id="4d58fb76f14dae3b712c2d1ef16b33d41abd7aa5" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt; 및 &lt;b&gt;-m&lt;/b&gt; 의 경우 해당 옵션이 스크립트 내에서 사용되지 않기 때문에 이는 오류입니다. 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 대신 프라그를.</target>
        </trans-unit>
        <trans-unit id="468d95254e2569de4c93c44e90ecaaab6e1c8a96" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">의 경우 &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , 임의의 정규화를 실시하지 않고, 조합 문자 불연속 수축이 수행된다. 따라서 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;이다&lt;/b&gt; 등가 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . 소스 문자열이 사전 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; 되어 있으면 (정규화 =&amp;gt; '사전 정규화') 정규화 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5830f7641c2c9f00de57771005c708cf9a4d5c74" translate="yes" xml:space="preserve">
          <source>In the case of a perl test suite, typically</source>
          <target state="translated">펄 테스트 스위트의 경우 일반적으로</target>
        </trans-unit>
        <trans-unit id="93b5501796f0c8e106f09c3c3a171aba6b8b3835" translate="yes" xml:space="preserve">
          <source>In the case of a shared array, all the array's elements are shared, and for a shared hash, all the keys and values are shared. This places restrictions on what may be assigned to shared array and hash elements: only simple values or references to shared variables are allowed - this is so that a private variable can't accidentally become shared. A bad assignment will cause the thread to die. For example:</source>
          <target state="translated">공유 배열의 경우 모든 배열의 요소가 공유되고 공유 해시의 경우 모든 키와 값이 공유됩니다. 이것은 공유 배열과 해시 요소에 할당 될 수있는 것에 제한을 둡니다 : 공유 변수에 대한 간단한 값이나 참조 만 허용됩니다 &amp;ndash; 이것은 개인 변수가 실수로 공유 될 수 없도록하기위한 것입니다. 할당이 잘못되면 스레드가 죽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e771b6edcf0a67e48248188d99cc8c1ee77f6d9" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">문자열의 경우 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 는 파일을로드하려고한다고 가정합니다. 그러나 간단한 단어의 경우 모듈을 의미한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="92d133184cc1d94941d92f9ddbb74be254d7536c" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will be equivalent to</source>
          <target state="translated">무제한 해시의 경우 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c7996f6bbe611631e0062a5b0c8688fa0df75c4" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will return an empty list.</source>
          <target state="translated">무제한 해시의 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bbcb89949ef30fa331653e26c292cc6bfd5402d5" translate="yes" xml:space="preserve">
          <source>In the case of branching constructs like the following:</source>
          <target state="translated">분기와 같은 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="235ed9f8205c1cb0e0f0c89543ab0c301b45cc8b" translate="yes" xml:space="preserve">
          <source>In the case where bsd_glob() has found some matching paths, but is interrupted by an error, it will return a list of filenames &lt;b&gt;and&lt;/b&gt; set &amp;amp;File::Glob::ERROR.</source>
          <target state="translated">bsd_glob ()가 일부 일치하는 경로를 발견했다,하지만 오류에 의해 중단 된 경우, 파일 이름의 목록이 반환됩니다 &lt;b&gt;및&lt;/b&gt; 세트 및 파일 :: 글롭 :: ERROR를.</target>
        </trans-unit>
        <trans-unit id="ab44e54a843289d8fb48be15296e74831fd77123" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; . The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD, NFKD 및 FCD의 경우 답은 &lt;code&gt;YES&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; 여야합니다 . 대답은 &lt;code&gt;MAYBE&lt;/code&gt; NFC, NFKC 및 FCC의 경우에 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e0ab2727afbd4185da2de81e38250408bd5cc4" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">아래 코드에서 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; 하면 &quot;void context에서 쓸모없는 xxx 사용&quot; 경고가 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fd1596cdd97dc35baf217614ea25fccb283e4de" translate="yes" xml:space="preserve">
          <source>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</source>
          <target state="translated">메모리 요구 사항에 대한 속도를 고려할 때 균형은 더 빠른 실행을 위해 기울어졌습니다. 이는 C 컴파일러가 구조를 위해 메모리를 할당하는 방식에 영향을 미쳤습니다. 16 비트 또는 32 비트 피연산자가 메모리의 위치 간 또는 CPU 레지스터 사이에서 짝수 또는 다중으로 정렬 된 경우 더 빠르게 이동할 수있는 아키텍처 4 개 또는 8 배의 주소에서 C 컴파일러는 구조에 여분의 바이트를 넣음으로써 이러한 속도 이점을 제공합니다. C 해안선을 넘지 않으면 큰 슬픔을 일으키지 않을 것입니다 (큰 데이터 구조를 디자인 할 때주의해야하거나 아키텍처간에 코드를 이식 할 수 있기를 원하지만 (그렇지 않으면 안됩니다) ?)).</target>
        </trans-unit>
        <trans-unit id="9d33a076ef77a2ea3c1cd018606852167138e6c8" translate="yes" xml:space="preserve">
          <source>In the context of the</source>
          <target state="translated">맥락에서</target>
        </trans-unit>
        <trans-unit id="d491c48b25f3ad65e82b4c5c2097be0b50a9588c" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">현재 구현에서 스칼라 상수는 실제로는 inlinable 서브 루틴입니다. Perl 5.004부터는 일부 서브 루틴 호출 대신 적절한 스칼라 상수가 직접 삽입되므로 서브 루틴 호출의 오버 헤드가 절약됩니다. 언제 어떻게 발생하는지에 대한 자세한 내용은 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0455a3b2b53d95f4e20ec0b4340a717b68f76c" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt; , magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; 에 명시 적으로 값이 할당되지 않은 경우 매직 자동 생성이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4e78aa2b33a6d6dac51bbc3211d37de72733b0" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">기본 구성에서 옵션 이름은 고유성으로 축약 될 수 있으며 대소 문자는 중요하지 않으며 긴 옵션 이름의 경우에도 단일 대시로 충분합니다. 또한 옵션은 비 옵션 인수 사이에 배치 될 수 있습니다. &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Getopt :: Long&lt;/a&gt; 을 구성하는 방법에 대한 자세한 내용은 Getopt :: Long 구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e72101fd159fd0afaf983f558f5b87febb7113ce" translate="yes" xml:space="preserve">
          <source>In the description it is mentioned that</source>
          <target state="translated">설명에서 그것은 언급된다</target>
        </trans-unit>
        <trans-unit id="ef03d8c00322da2ed4dc98f0803a382ee30a4ed1" translate="yes" xml:space="preserve">
          <source>In the diagram, the further right you go the more deeply nested the scope is. It is only when control is back with perl on the extreme left of the diagram that you will have dropped back to the enclosing scope and any temporaries you have left hanging around will be freed.</source>
          <target state="translated">다이어그램에서 오른쪽으로 갈수록 범위가 더 깊게 중첩됩니다. 제어가 다이어그램의 가장 왼쪽에 perl로 돌아와서 둘러싸는 범위로 다시 떨어졌을 때만 매달려 있던 임시 공간이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="6f416a980a416e375bc66bc2d4fa36e45d3dee04" translate="yes" xml:space="preserve">
          <source>In the event that your XS code may need the underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale, there are macros available to access this; see &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;Locale-related functions and macros in perlapi&lt;/a&gt;.</source>
          <target state="translated">XS 코드에 기본 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 이 필요할 수있는 경우 여기에 액세스 할 수있는 매크로가 있습니다. &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;perlapi의 로케일 관련 함수 및 매크로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf76bf6bac3fdd00f94042b70f25cd2c0127da6a" translate="yes" xml:space="preserve">
          <source>In the example above $DB_HASH is actually a pre-defined reference to a hash object. &lt;b&gt;DB_File&lt;/b&gt; has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.</source>
          <target state="translated">위의 예에서 $ DB_HASH는 실제로 해시 객체에 대한 사전 정의 된 참조입니다. &lt;b&gt;DB_File&lt;/b&gt; 에는이 세 가지 사전 정의 된 참조가 있습니다. $ DB_HASH 외에도 $ DB_BTREE 및 $ DB_RECNO도 있습니다.</target>
        </trans-unit>
        <trans-unit id="383bad82dbf36df5fcbc2607474fc2833874c49f" translate="yes" xml:space="preserve">
          <source>In the example above, no file in</source>
          <target state="translated">위의 예에서 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6fdb80f186445ea957d140c9ee93d85c7f7bc67" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 메서드는 스레드가 종료 되 자마자 반환합니다. 스레드가 완료 될 때까지 대기하고 스레드가 리턴 한 값을 수집하는 것 외에도 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 은 스레드에 필요한 OS 정리도 수행합니다. 이러한 정리는 특히 많은 스레드를 생성하는 장기 실행 프로그램의 경우 중요 할 수 있습니다. 반환 값을 원하지 않고 스레드가 끝날 때까지 기다리지 않으려면 다음에 설명 된대로 &lt;code&gt;detach()&lt;/code&gt; 메서드를 대신 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4fb9b67eb5a1d7e86fa97df408aad4ebc6c2e68" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the WRITER filehandle, so it closes it. However, because WRITER was opened using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">위의 예에서, 실제 부모는 WRITER 파일 핸들에 쓰고 싶지 않으므로 닫습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; 사용하여 WRITER를 열었으므로 특수한 동작이 있습니다.이를 닫으면 하위 프로세스가 종료 될 때까지 대기하는 waitpid () ( &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt; 참조)를 호출합니다 . 하위 프로세스가 &quot;다른 작업 수행&quot;으로 표시된 섹션에서 발생하는 작업을 기다리는 경우 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e18ac50c69f2e5daf082fad97b93479b32118e7a" translate="yes" xml:space="preserve">
          <source>In the example above, we've created a global variable to temporarily store the computed value of our eval'ed expression. It is also possible and in most cases a better strategy to fetch the return value from</source>
          <target state="translated">위의 예에서는 계산 된 계산 된 값을 계산 된 값으로 임시 저장하기위한 전역 변수를 만들었습니다. 또한 반환 값을 가져 오는 더 나은 전략이 가능하며 대부분의 경우</target>
        </trans-unit>
        <trans-unit id="215f011f187069670df6baefac97d219cfd4d544" translate="yes" xml:space="preserve">
          <source>In the example above, you can see that we passed &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; to &lt;code&gt;has()&lt;/code&gt; when creating our &lt;code&gt;is_on&lt;/code&gt; attribute. This tells &lt;code&gt;Moose&lt;/code&gt; that this attribute must be a boolean value. If we try to set it to an invalid value, our code will throw an error.</source>
          <target state="translated">위의 예에서 &lt;code&gt;is_on&lt;/code&gt; 속성을 만들 때 &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; 을 &lt;code&gt;has()&lt;/code&gt; 전달한 것을 볼 수 있습니다 . 이것은 &lt;code&gt;Moose&lt;/code&gt; 에게이 속성이 부울 값이어야 함을 알려줍니다 . 유효하지 않은 값으로 설정하려고하면 코드에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7091546bde153dd7889f18e20c48c8bc55eaa567" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt; ) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">예제 필터에서 객체 ( &lt;code&gt;$ref&lt;/code&gt; )는 다른 Perl 객체와 마찬가지로 축복을받습니다. 이 예에서는 익명 배열을 사용하지만 필수 사항은 아닙니다. 이 예제는 컨텍스트 정보를 저장할 필요가 없으므로 스칼라 또는 해시 참조도 사용할 수 있습니다. 다음 섹션에서는 컨텍스트 데이터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7cad79aaf9d1ce6eabd545156fa679d72897f6d5" translate="yes" xml:space="preserve">
          <source>In the example script below, the &lt;code&gt;match&lt;/code&gt; sub uses this feature to find and print the first matching key/value pair given a partial key.</source>
          <target state="translated">아래 예제 스크립트에서 &lt;code&gt;match&lt;/code&gt; 하위는이 기능을 사용하여 부분 키가 지정된 첫 번째 일치 키 / 값 쌍을 찾아 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="874b0ca5f6d74bc36f1a8bf750e4d758cb8b0d1e" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">위의 예제에서 파일 핸들을 사용하기 전에 스칼라 변수에 할당했습니다. 해시 나 배열의 표현식이나 첨자가 아닌 단순한 스칼라 변수 만 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 diamond 연산자 와 같은 내장 함수 와 함께 사용할 수 있기 때문 입니다. 간단한 스칼라 변수 이외의 것을 파일 핸들로 사용하는 것은 불법이며 컴파일되지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d5cb1050428e1b3c39a6dbeac5fa82c4e3ee30c" translate="yes" xml:space="preserve">
          <source>In the examples given to date, any temporaries created in the callback (i.e., parameters passed on the stack to the</source>
          <target state="translated">현재까지 제공된 예에서, 콜백에서 생성 된 모든 임시 (즉, 스택에 전달 된 매개 변수는</target>
        </trans-unit>
        <trans-unit id="52df5ff09c57ff6bd4a65152023282e8e3fdf423" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt; , the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">확장 사용 양식에서 덤프 할 참조에 사용자 지정 이름을 지정할 수 있습니다. 이름이 &lt;code&gt;*&lt;/code&gt; 로 시작 하면 출력은 해시 및 배열에 대한 제공된 참조의 역 참조 된 유형과 코드 참조를 설명합니다. &lt;code&gt;Terse&lt;/code&gt; 플래그가 설정 되면 가능한 경우 이름의 출력을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e093183cde30fbf5834bc8c2f2306668f0a93ab" translate="yes" xml:space="preserve">
          <source>In the eyes of the operating system, pseudo-processes created via the fork() emulation are simply threads in the same process. This means that any process-level limits imposed by the operating system apply to all pseudo-processes taken together. This includes any limits imposed by the operating system on the number of open file, directory and socket handles, limits on disk space usage, limits on memory size, limits on CPU utilization etc.</source>
          <target state="translated">운영 체제의 관점에서 fork () 에뮬레이션을 통해 생성 된 의사 프로세스는 단순히 동일한 프로세스의 스레드입니다. 이는 운영 체제에 의해 부과 된 모든 프로세스 수준 제한이 함께 모은 모든 의사 프로세스에 적용됨을 의미합니다. 여기에는 운영 체제가 열린 파일 수, 디렉토리 및 소켓 핸들 수, 디스크 공간 사용 제한, 메모리 크기 제한, CPU 사용 제한 등에 대한 제한이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c87855f737ebcf54612bd0d985e7951567552bdc" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; . (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">위의 마지막 예에서 첫 번째 ASCII 16 진수는 코드 포인트 48, 문자 &quot;0&quot;이며 57부터 57까지의 모든 코드 포인트 ( &quot;9&quot;)는 ASCII 16 진수입니다. 코드 포인트 58에서 64는 아니지만 65 ( &quot;A&quot;)에서 70 ( &quot;F&quot;)은 97 ( &quot;a&quot;)에서 102 ( &quot;f&quot;)입니다. 103은 ASCII 16 진수가 아닌 코드 포인트 범위를 시작합니다. 이 범위는 무한대로 확장되며 컴퓨터의 &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 변수에서 찾을 수 있습니다 . (이 변수는 Perl이 플랫폼에서 얻을 수있는 무한대에 가까우며 일부 작업이 작동하기에는 너무 높을 수 있으므로 목적에 따라 더 작은 수를 사용하고자 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="acc9782ed3f3e2b680013d144689804f90d54bf6" translate="yes" xml:space="preserve">
          <source>In the first example, an error handler, the flow of control could be as follows. You have created an interface to an external library. Control can reach the external library like this</source>
          <target state="translated">첫 번째 예인 오류 처리기에서 제어 흐름은 다음과 같습니다. 외부 라이브러리에 대한 인터페이스를 작성했습니다. 제어는 이와 같이 외부 라이브러리에 도달 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="837426c8f21e7781853f5f83912529e607900661" translate="yes" xml:space="preserve">
          <source>In the first form, often referred to as a &quot;string eval&quot;, the return value of EXPR is parsed and executed as if it were a little Perl program. The value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This means, that in particular, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">&quot;문자열 평가&quot;라고도하는 첫 번째 형식에서는 EXPR의 반환 값이 작은 Perl 프로그램 인 것처럼 구문 분석되고 실행됩니다. 식의 값 (스칼라 컨텍스트 내에서 자체 결정됨)이 먼저 구문 분석되고 오류가없는 경우 현재 Perl 프로그램의 어휘 컨텍스트 내에서 블록으로 실행됩니다. 즉, 특히 외부 어휘 변수를 볼 수 있으며 패키지 변수 설정 또는 서브 루틴 및 형식 정의는 계속 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="9907ef81620f333168bdff52969249681c5309f5" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt; . In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">첫 번째 양식에서 &lt;code&gt;id_2obj()&lt;/code&gt; 함수에 대해 작업 할 오브젝트를 등록하십시오 . 두 번째 형식에서는 가비지 수집을 위해 지정된 해시 참조를 추가로 표시합니다. 이는 객체가 범위를 벗어날 때 &lt;code&gt;id($obj)&lt;/code&gt; 키 아래에 주어진 해시의 모든 항목이 해시에서 삭제됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="886a42840b4db0f0804225c4bdd1da338f8eaea4" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt; . In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">첫 번째 형태에서, 익명의 해시는 &lt;code&gt;$class&lt;/code&gt; 의 클래스에 축복을 받고 있습니다. 두 번째 형태에서는 익명 해시가 현재 패키지에 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba19d40237087370736921c2b055d0f9f4e8621" translate="yes" xml:space="preserve">
          <source>In the first two versions, the body of the subroutine is lexically in the main package,</source>
          <target state="translated">처음 두 버전에서 서브 루틴의 본문은 기본 패키지에 어휘 적으로 있습니다.</target>
        </trans-unit>
        <trans-unit id="78475acfd51fd678e0727a44ada7dcef5de0bc33" translate="yes" xml:space="preserve">
          <source>In the first version above, you let the appropriate encoding layer handle the conversion. In the second, you explicitly translate from one encoding to the other.</source>
          <target state="translated">위의 첫 번째 버전에서는 적절한 인코딩 계층이 변환을 처리하도록합니다. 두 번째에서는 한 인코딩에서 다른 인코딩으로 명시 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2414010bede2999a6fc168db89c621d8bb7bb77d" translate="yes" xml:space="preserve">
          <source>In the following all questions and explanations regarding config variables are collected.</source>
          <target state="translated">다음에는 구성 변수에 관한 모든 질문과 설명이 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="33eb6a227648440eaeed500f955607df47c5aa25" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;code&gt;$pad_len&lt;/code&gt; is the length to which you wish to pad the string, &lt;code&gt;$text&lt;/code&gt; or &lt;code&gt;$num&lt;/code&gt; contains the string to be padded, and &lt;code&gt;$pad_char&lt;/code&gt; contains the padding character. You can use a single character string constant instead of the &lt;code&gt;$pad_char&lt;/code&gt; variable if you know what it is in advance. And in the same way you can use an integer in place of &lt;code&gt;$pad_len&lt;/code&gt; if you know the pad length in advance.</source>
          <target state="translated">다음 예에서 &lt;code&gt;$pad_len&lt;/code&gt; 은 문자열을 채울 길이이며 &lt;code&gt;$text&lt;/code&gt; 또는 &lt;code&gt;$num&lt;/code&gt; 은 &lt;code&gt;$pad_char&lt;/code&gt; 문자열을 포함 하고 $ pad_char 는 채움 문자를 포함합니다. 사전에 &lt;code&gt;$pad_char&lt;/code&gt; 변수 대신 단일 문자열 상수를 사용할 수 있습니다 . 또한 패드 길이를 미리 알고 있다면 &lt;code&gt;$pad_len&lt;/code&gt; 대신 정수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76ac42f7d8b0a7d53378ec8bb6883cc947c8612a" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in precedence order.</source>
          <target state="translated">다음 섹션에서이 연산자는 우선 순위에 따라 다룹니다.</target>
        </trans-unit>
        <trans-unit id="4b178b275b86ca37ae6642cdcf850388ebe0add6" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt; ); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt; .</source>
          <target state="translated">다음 표에서 숫자는 우선 순위를 나타냅니다. 예를 들어, 아래 표는 &lt;code&gt;'!'&lt;/code&gt; 에 대한 구현이없는 경우 Perl은 &lt;code&gt;'bool'&lt;/code&gt; 을 사용하여 (즉, &lt;code&gt;'bool'&lt;/code&gt; 의 메소드가 리턴 한 값을 반전하여 ) 구현합니다. 부울 변환도 구현되지 않으면 Perl은 &lt;code&gt;'0+'&lt;/code&gt; 를 사용 하거나 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a38bcdad9de0c83d52fd95f8565a94b07788e8" translate="yes" xml:space="preserve">
          <source>In the following tables:</source>
          <target state="translated">다음 표에서 :</target>
        </trans-unit>
        <trans-unit id="770598786b9fb05b86d05d808ab206b9dce08c07" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">LIST가 지정된 경우 (명령 이름 뒤에 추가 인수) 파이프가 열려있는 형식으로 세 개 이상의 인수를 사용하면 플랫폼에서 지원하는 경우 LIST가 호출 된 명령의 인수가됩니다. 비 파이프 모드에 대해 세 개 이상의 인수 로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 의미는 아직 정의되지 않았지만 실험적인 &quot;계층&quot;은 추가 LIST 인수를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351023ba55a42928810e8ea146d7f9a69c7e4007" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">LIST가 지정된 경우 (명령 이름 뒤에 추가 인수) 파이프가 열려있는 형식으로 세 개 이상의 인수를 사용하면 플랫폼에서 지원하는 경우 LIST가 호출 된 명령의 인수가됩니다. 비 파이프 모드에 대해 세 개 이상의 인수 로 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 의미는 아직 정의되지 않았지만 실험적인 &quot;계층&quot;은 추가 LIST 인수를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d9756e636c498fe9304eb168ab8f26e641d5c72" translate="yes" xml:space="preserve">
          <source>In the future, this module will likely use File::Spec for determining paths, as it does now for Mac OS (where Unix-style or Mac-style paths work, and Unix-style paths are converted properly to Mac-style paths before being added to @INC).</source>
          <target state="translated">앞으로이 모듈은 경로를 결정하기 위해 File :: Spec을 사용할 것입니다 (현재 Unix 스타일 또는 Mac 스타일 경로가 작동하는 Mac OS 및 Unix 스타일 경로가 이전에 Mac 스타일 경로로 올바르게 변환 됨) @INC에 추가).</target>
        </trans-unit>
        <trans-unit id="46cedf56be184729e0d91d65fc9c0d53cad92704" translate="yes" xml:space="preserve">
          <source>In the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">마지막 예에서 문자열의 끝은 단어 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6405a42cdbbb08be1356ae610a2c353a3021f6e3" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression, so we use &lt;code&gt;$1&lt;/code&gt; to replace the quoted string with just what was quoted. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regexp in the string:</source>
          <target state="translated">마지막 예에서는 전체 문자열이 일치했지만 작은 따옴표 안의 부분 만 그룹화되었습니다. 와 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자, 일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 우리가 사용하는, 그래서 등, 대체 표현의 사용을 즉시 사용할 수있는 &lt;code&gt;$1&lt;/code&gt; 인용되었다 단지 무엇을 함께 인용 문자열을 바꿀 수 있습니다. 전역 수정자를 사용하여 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 는 문자열에서 모든 정규 표현식을 검색하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="06c06ffd743a05cb45342ceadd66f34d1f6c47cc" translate="yes" xml:space="preserve">
          <source>In the last regex, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regex.</source>
          <target state="translated">마지막 정규 표현식에서 슬래시 &lt;code&gt;'/'&lt;/code&gt; 도 정규 표현식을 구분하는 데 사용되므로 백 슬래시입니다.</target>
        </trans-unit>
        <trans-unit id="11c4a29ccb7ab2ebd1eeaf108124208b060d0f4a" translate="yes" xml:space="preserve">
          <source>In the last regexp, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome), however, and it is often more readable to change delimiters.</source>
          <target state="translated">마지막 정규 표현식에서 슬래시 &lt;code&gt;'/'&lt;/code&gt; 도 정규 표현식을 구분하는 데 사용되므로 백 슬래시입니다. 그러나 이로 인해 LTS (leaning toothpick syndrome)가 발생할 수 있으며 구분 기호를 변경하는 것이 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3c351aa56c66843f422f8613ab5ba80764ad66e0" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, &lt;code&gt;'a'&lt;/code&gt; matches because the first character position in the string is the earliest point at which the regexp can match.</source>
          <target state="translated">마지막 문장에서 &lt;code&gt;'c'&lt;/code&gt; 가 클래스 의 첫 번째 문자이지만 문자열의 첫 번째 문자 위치가 정규 표현식과 일치 할 수있는 가장 빠른 지점이므로 &lt;code&gt;'a'&lt;/code&gt; 가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="eb7827ba059fba337cd380ecde1e864bd7488e84" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt; .</source>
          <target state="translated">마지막 문장에서 &lt;code&gt;'c'&lt;/code&gt; 가 클래스의 첫 번째 문자 이지만 정규식과 일치시킬 수있는 가장 빠른 지점은 &lt;code&gt;'a'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9813d8232f26905286fe72c0fb88aaeece44db" translate="yes" xml:space="preserve">
          <source>In the latter case, characters that map to 0212 are first converted to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or 'geta mark') then fed to the decoding engine. U+FFFD is not used, in order to preserve text layout as much as possible.</source>
          <target state="translated">후자의 경우, 0212로 매핑되는 문자는 먼저 U + 3013 (EUC-JP에서 0xA2AE로 변환됩니다. '두부'또는 'geta 마크'라고도하는 흰색 사각형)은 디코딩 엔진에 공급됩니다. 텍스트 레이아웃을 최대한 유지하기 위해 U + FFFD가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8f8d594e47a7aed4b47d21c04c8b5fc5ac50b38" translate="yes" xml:space="preserve">
          <source>In the latter, foo.h is taken as</source>
          <target state="translated">후자에서 foo.h는</target>
        </trans-unit>
        <trans-unit id="9b81dfce26cb69eddfbb13b42d7a921ee8ba05af" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUB의 매개 변수 목록에서 하나에 의해 매개 변수 이름 앞에 수 있습니다 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 키워드. &lt;code&gt;IN&lt;/code&gt; 키워드가 기본값이고 다른 키워드는 Perl 인터페이스가 C 인터페이스와 어떻게 다른지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c32d4238ee6ff96fa8bb06b99ee3f8b0689422e" translate="yes" xml:space="preserve">
          <source>In the method descriptions below</source>
          <target state="translated">아래의 방법 설명에서</target>
        </trans-unit>
        <trans-unit id="1b237b2ec2e195bf52f7f15f0ad99e5a2c78e4b1" translate="yes" xml:space="preserve">
          <source>In the more general case, you can use the &lt;code&gt;/g&lt;/code&gt; modifier in a &lt;code&gt;while&lt;/code&gt; loop, keeping count of matches.</source>
          <target state="translated">보다 일반적인 경우 일치 횟수를 유지 &lt;code&gt;while&lt;/code&gt; 루프 에서 &lt;code&gt;/g&lt;/code&gt; 수정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="784f063825aaf77ec4d5f9b15d7c0e7efc2377c9" translate="yes" xml:space="preserve">
          <source>In the mylib directory, create a file mylib.h that looks like this:</source>
          <target state="translated">mylib 디렉토리에서 다음과 같은 mylib.h 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="79fbf0c13d713302225cff8f61abd9dd7ac74b43" translate="yes" xml:space="preserve">
          <source>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</source>
          <target state="translated">다음 단락에서는 여기에 사용 된 용어에 대한 간단한 설명이 이어집니다 (다른 사람이나 문서에서 사용하는 용어와 다를 수 있기 때문).</target>
        </trans-unit>
        <trans-unit id="5152e34177e8a3d4c184b97093704f88de6ca9db" translate="yes" xml:space="preserve">
          <source>In the notation discussed so far, the characters &quot;[&quot; and &quot;]&quot; are given special meaning, for opening and closing bracket groups, and &quot;,&quot; has a special meaning inside bracket groups, where it separates items in the group. This begs the question of how you'd express a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and how you'd express a literal comma inside a bracket group. For this purpose I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot; means a literal '[' character anywhere in Bracket Notation (i.e., regardless of whether you're in a bracket group or not), and ditto for &quot;~]&quot; meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho &quot;,&quot; means a literal comma outside of bracket groups -- it's only inside bracket groups that commas are special.)</source>
          <target state="translated">지금까지 설명한 표기법에서 &quot;[&quot;및 &quot;]&quot;문자는 대괄호 그룹을 열고 닫는 데 특별한 의미가 있으며 &quot;,&quot;는 대괄호 그룹 내부에 특별한 의미가 있으며 그룹에서 항목을 구분합니다. 이것은 대괄호 표기법 문자열에서 리터럴 &quot;[&quot;또는 &quot;]&quot;를 표현하는 방법과 대괄호 그룹 내에서 리터럴 쉼표를 표현하는 방법에 대한 의문을 제기합니다. 이 목적을 위해 &quot;~&quot;(물결표)를 이스케이프 문자로 채택했습니다. &quot;~ [&quot;는 대괄호 표기법의 임의의 위치에 리터럴 '['문자를 의미합니다 (즉, 대괄호 그룹에 있는지 여부에 관계없이), 리터럴 ']'을 의미하는 &quot;~]&quot;및 리터럴 쉼표를 의미하는 &quot;~&quot;를 의미합니다. (Altho &quot;,&quot;은 대괄호 그룹 외부의 리터럴 쉼표를 의미합니다.쉼표가 특수한 괄호 그룹 내부에만 있습니다.)</target>
        </trans-unit>
        <trans-unit id="9c42fcbdbf3cd24cfb1dac2e8ba1cbc829f18933" translate="yes" xml:space="preserve">
          <source>In the olden, less enlightened times, we all used to use ASCII. Most of us did, anyway. The big problem with ASCII is that it's American. Well, no, that's not actually the problem; the problem is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of it being a standard was lost.</source>
          <target state="translated">오래되고 깨달은 시대에는 모두 ASCII를 사용했습니다. 어쨌든 우리 대부분은 그렇게했습니다. ASCII의 큰 문제는 그것이 미국인이라는 것입니다. 글쎄요, 그건 사실 문제가 아닙니다. 문제는 로마 알파벳을 사용하지 않는 사람들에게는 특히 유용하지 않다는 것입니다. 예전에는 특정 언어가 128에서 255 사이의 시퀀스의 상위 범위에 자신의 알파벳을 붙이는 것이 었습니다. 물론 우리는 ASCII가 아닌 많은 변형과 그 전체 요점으로 끝났습니다. 표준이되는 것은 없어졌다.</target>
        </trans-unit>
        <trans-unit id="50b947f69a6b2d22a725a2d7ba0813fc1f66f21b" translate="yes" xml:space="preserve">
          <source>In the one case the code, which does exactly the same thing as far as outputting any debugging information is concerned, in other words nothing, takes 14 seconds, and in the other case the code takes one hundredth of a second. Looks fairly definitive. Use a &lt;code&gt;$DEBUG&lt;/code&gt; variable BEFORE you call the subroutine, rather than relying on the smart functionality inside it.</source>
          <target state="translated">어떤 경우에는 디버깅 정보를 출력하는 것과 정확히 똑같은 일을하는 코드, 즉 아무 것도 14 초가 걸리지 않으며 다른 경우에는 코드가 100 분의 1 초가 걸립니다. 상당히 결정적인 것으로 보입니다. 서브 루틴을 호출하기 전에 &lt;code&gt;$DEBUG&lt;/code&gt; 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cd2461949e5dab65a2af380d7f878aad8f12946" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">호출의 1 인수 및 2 인수 형태에서, 모드 및 파일 이름은 바람직하게는 공백으로 분리되어 연결되어야합니다 (순서대로). 해당 모드가 &lt;code&gt;&amp;lt;&lt;/code&gt; 일 때 이러한 형식으로 모드를 생략 할 수는 있지만 생략해서는 안됩니다 . filename 인수가 알려진 리터럴 인 경우에는 항상 2 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1895cc93a277f17a7d9aa8c8fca89d99b0c8a2" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">호출의 1 인수 및 2 인수 형태에서, 모드 및 파일 이름은 바람직하게는 공백으로 분리되어 연결되어야합니다 (순서대로). 해당 모드가 &lt;code&gt;&amp;lt;&lt;/code&gt; 일 때 이러한 형식으로 모드를 생략 할 수는 있지만 생략해서는 안됩니다 . filename 인수가 알려진 리터럴 인 경우에는 항상 2 인수 형식의 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="9baa512a702be95a00f5cdfa9d3fa8d7a2a0b696" translate="yes" xml:space="preserve">
          <source>In the opposite way, to resolve a hostname to the IP address you can write this:</source>
          <target state="translated">반대로 호스트 이름을 IP 주소로 확인하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb2e91137fed6da0013b83630021f3d72198be0" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">옵션 스펙에서 옵션 이름 뒤에는 등호 &lt;code&gt;=&lt;/code&gt; 및 문자 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가옵니다 . 등호는이 옵션에 값이 필요함을 나타냅니다. 문자 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 는이 값이 임의의 문자열임을 나타냅니다. 다른 가능한 값 유형은 정수 값의 경우 &lt;code&gt;i&lt;/code&gt; , 부동 소수점 값의 경우 &lt;code&gt;f&lt;/code&gt; 입니다. 콜론을 사용하여 &lt;code&gt;:&lt;/code&gt; 등호 (=) 대신하면 옵션 값은 선택을 나타냅니다. 이 경우 적합한 값을 제공하지 않으면 문자열 값 옵션에 빈 문자열 &lt;code&gt;''&lt;/code&gt; 이 할당되고 숫자 옵션은 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="53db56988ad2d32c572da0df498153024ad7a10e" translate="yes" xml:space="preserve">
          <source>In the past, the Perl community experimented with a technique called &quot;inside-out objects&quot;. An inside-out object stores its data outside of the object's reference, indexed on a unique property of the object, such as its memory address, rather than in the object itself. This has the advantage of enforcing the encapsulation of object attributes, since their data is not stored in the object itself.</source>
          <target state="translated">과거에 Perl 커뮤니티는 &quot;내부 객체&quot;라는 기술을 실험했습니다. 인사이드 아웃 객체는 객체 자체가 아닌 메모리 주소와 같은 객체의 고유 속성에 대해 색인화 된 객체 참조 외부에 데이터를 저장합니다. 이는 데이터가 객체 자체에 저장되지 않기 때문에 객체 속성의 캡슐화를 시행하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3a725cb056826efb62b17fb21f5a5c69a3ce79" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">과거에는 주요 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 선택 사항이지만 생략하면 사용 중지 경고가 표시됩니다. v5.22.0부터는 생략하면 구문 오류가 발생합니다. 이전 코드 에서이 구문이 발생하면 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 만 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="3a63857af592db7e75d88e816c7c7a1180f9eb89" translate="yes" xml:space="preserve">
          <source>In the pathological case that a script is called via a relative path</source>
          <target state="translated">병리학 적 경우 상대 경로를 통해 스크립트가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b5cb98f00aa6aaa22eb71c271690cbb1ebc9df81" translate="yes" xml:space="preserve">
          <source>In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot; and after the &quot;m&quot;. These patterns match /\Bam\B/:</source>
          <target state="translated">/ \ Bam \ B / 패턴에서 &quot;a&quot;앞과 &quot;m&quot;뒤에 단어 문자가 있어야합니다. 이 패턴은 / \ Bam \ B /와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d454ee791b9ae0c5bbb81657f656033f3c0c5a24" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">특유의에서는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 형태 버전과 비교한다 포지티브 소수 부분과 같은 5.006, 이어도 &lt;code&gt;$]&lt;/code&gt; , 또는 비교 될 것이다 폼 v5.6.1의 V-문자열 &lt;code&gt;$^V&lt;/code&gt; ($ 일명 PERL_VERSION). VERSION이 현재 Perl 인터프리터 버전보다 큰 경우 예외가 발생합니다. Perl은 파일의 나머지 부분을 구문 분석하지 않습니다. 런타임시 유사한 검사를 수행 할 수있는 &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt; 와 비교하십시오 . 대칭 적으로 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용하면 지정된 버전보다 오래된 Perl 버전을 원하는 것으로 지정할 수 &lt;a href=&quot;functions/no&quot;&gt;없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74d3b7e92857ff92a78ee1a11cb1e6022b249cb3" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">특유의에서는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 형태 버전과 비교한다 포지티브 소수 부분과 같은 5.006, 이어도 &lt;code&gt;$]&lt;/code&gt; , 또는 비교 될 것이다 폼 v5.6.1의 V-문자열 &lt;code&gt;$^V&lt;/code&gt; ($ 일명 PERL_VERSION). VERSION이 현재 Perl 인터프리터 버전보다 큰 경우 예외가 발생합니다. Perl은 파일의 나머지 부분을 구문 분석하지 않습니다. 런타임시 유사한 검사를 수행 할 수있는 &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt; 와 비교하십시오 . 대칭 적으로 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용하면 지정된 버전보다 오래된 Perl 버전을 원하는 것으로 지정할 수 &lt;a href=&quot;no&quot;&gt;없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5da666074fc2ec75362b3b68f86858be734f6e9" translate="yes" xml:space="preserve">
          <source>In the presence of multiple classes it can be non-trivial to make sure that every relevant destructor is called for every object. Perl calls the first one it finds on the inheritance tree (if any) and that's it.</source>
          <target state="translated">여러 클래스가있는 경우 모든 관련 소멸자가 모든 객체에 대해 호출되도록하는 것이 쉽지 않을 수 있습니다. Perl은 상속 트리에서 찾은 첫 번째 것을 호출합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="cd34d34a3c68755abc29d11ed297638bd9fdb29d" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt; ). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt; ). It should also set &lt;code&gt;subcoffset&lt;/code&gt; , the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">의 존재에 &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; 의 플래그 만의 추가와 함께 &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 또는 &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; 플래그, 엔진은 (여전히 존재 그렇게해야하지만, 전체 버퍼를 복사하지 않도록 선택할 수 있습니다 &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; 또는 설정되는 관련 비트 &lt;code&gt;PL_sawampersand&lt;/code&gt; 를 ) . 이 경우, 버퍼의 논리적 시작에서 물리적 시작 (즉, &lt;code&gt;subbeg&lt;/code&gt; ) 까지의 바이트 수를 나타내도록 &lt;code&gt;suboffset&lt;/code&gt; 을 설정할 수 있습니다 . 또한 오프셋의 문자 &lt;code&gt;subcoffset&lt;/code&gt; 을 설정해야합니다 . 후자는 바이트가 아닌 문자로 작동하는 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 를 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b073c0a34c41b3ba5f06418d694ba351020d4acc" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt; , and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">이전 예제에서 함수 전용 변수는 하나의 함수 만 참조를 기억했기 때문에 작성했습니다. 변수가 범위 내에있는 동안 여러 함수를 정의 할 수 있으며 각 함수는 &quot;개인&quot;변수를 공유 할 수 있습니다. 어휘 변수가 범위 내에있는 동안 함수 외부에서 액세스 할 수 있고 참조를 작성할 수 있기 때문에 실제로 &quot;정적&quot;이 아닙니다. 이 예에서 &lt;code&gt;increment_count&lt;/code&gt; 와 &lt;code&gt;return_count&lt;/code&gt; 는 변수를 공유합니다. 한 함수는 값에 추가하고 다른 함수는 단순히 값을 반환합니다. 둘 다 &lt;code&gt;$count&lt;/code&gt; 액세스 할 수 있으며 범위를 벗어 났으므로 액세스 할 수있는 다른 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d099eddc17fd02123a62f3b5a7b0e3fc3ac46d20" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt; . In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;{}&lt;/code&gt; 코드는 빈 익명 해시에 대한 참조를 만듭니다. 는 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 함수는 그 기준을 취하고있는 클래스 해쉬 연관 &lt;code&gt;$class&lt;/code&gt; . 가장 간단한 경우 &lt;code&gt;$class&lt;/code&gt; 변수는 문자열 &quot;File&quot;을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c1001ba58ff0530a993f349b4836f78782ab43f8" translate="yes" xml:space="preserve">
          <source>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</source>
          <target state="translated">이전 섹션에서는 바이너리 메시지 길이를 실제 메시지 앞에 접두어로 구성한 네트워크 메시지를 보았습니다. 널 바이트가 데이터의 일부일 수있는 경우 널 바이트를 추가해도 작동하지 않으므로 길이 다음에 너무 많은 바이트의 데이터를 패킹하는 것이 자주 사용되는 레시피입니다. 다음은 두 기술을 모두 사용하는 예입니다. 소스 및 대상 주소가있는 두 개의 널 종료 문자열 후에 길이 바이트 후에 짧은 메시지 (휴대 전화로)가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="4d306b4b58fb980badf24b06473c4af8a30ac12e" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 를 사용하여 정수 또는 리틀 엔디안 바이트 순서로 정수를 패킹하고 언팩 하는 방법을 배웠습니다 . 이것은 훌륭하지만 64 비트 정수뿐만 아니라 모든 종류의 부호있는 정수를 제외하기 때문에 여전히 제한적입니다. 예를 들어, 플랫폼 독립적 인 방식으로 부호있는 big-endian 16 비트 정수 시퀀스를 풀려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bb18f0a7b082417093abe50cb091ae0ce9d7c1a" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt; . If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">드물게이 모듈을 통해 특정 상수가 선언되었는지 런타임에 감지해야하는 경우,이 함수를 사용하여 해시 &lt;code&gt;%constant::declared&lt;/code&gt; 를 검사 할 수 있습니다 . 주어진 상수 이름에 패키지 이름이 포함되어 있지 않으면 현재 패키지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3168d71bbd1d6362a03e87b3b6357cbc463ee97" translate="yes" xml:space="preserve">
          <source>In the scalar context, returns the modified collator (but it is &lt;b&gt;not&lt;/b&gt; a clone from the original).</source>
          <target state="translated">스칼라 컨텍스트에서 수정 된 콜 레이터를 리턴합니다 ( 원본의 복제본 은 &lt;b&gt;아님&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e123d33b9c36acd15c038a592d06bccf26e5a4c" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일 설정을 따릅니다 . 이것은 알파벳, 숫자, 문장 부호,</target>
        </trans-unit>
        <trans-unit id="ea3c9a616e33a3cad4631e8af654cde72ce4e1bd" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">데이터 정렬을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 환경 변수를 찾아 문자의 데이터 정렬 (순서 지정)에 대한 애플리케이션의 개념을 판별합니다. 예를 들어, &quot;b&quot;는 라틴 알파벳에서 &quot;a&quot;뒤에 있지만 &quot;&amp;aacute;&quot;와 &quot;&amp;aring;&quot;는 어디에 속합니까? &quot;color&quot;는 영어로 &quot;chocolate&quot;을 따르지만 전통적인 스페인어는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="85dc6b4df5881b7609167c49737d8fd061975bdc" translate="yes" xml:space="preserve">
          <source>In the second example, an event driven program, the flow of control will be more like this</source>
          <target state="translated">두 번째 예인 이벤트 중심 프로그램에서 제어 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0aec5f41df04fa608d73972b5b60d0e21665dd44" translate="yes" xml:space="preserve">
          <source>In the second example, however, we have stored another reference to the tied object in $x. That means that when untie() gets called there will still be a valid reference to the object in existence, so the destructor is not called at that time, and thus the file is not closed. The reason there is no output is because the file buffers have not been flushed to disk.</source>
          <target state="translated">그러나 두 번째 예에서는 묶인 객체에 대한 다른 참조를 $ x에 저장했습니다. 즉, untie ()가 호출 될 때 존재하는 객체에 대한 유효한 참조가 여전히 존재하므로 그 때 소멸자가 호출되지 않으므로 파일이 닫히지 않습니다. 출력이없는 이유는 파일 버퍼가 디스크로 플러시되지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="69631891c8053c89e0b6bca3447bddf1c255a6c7" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">두 번째 형태에서, BLOCK 내의 코드는 한 번만 구문 분석되며, 동시에 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체를 둘러싼 코드 는 구문 분석되고 현재 Perl 프로그램의 컨텍스트 내에서 실행됩니다. 이 형식은 일반적으로 첫 번째 (아래 참조)보다 예외를 더 효율적으로 잡는 데 사용되며 컴파일시 BLOCK 내에서 코드를 검사하는 이점도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a4b1f50ba31b2407de5a923935b79599705457e" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">두 번째 형태에서, BLOCK 내의 코드는 한 번만 구문 분석되며, 동시에 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체를 둘러싼 코드 는 구문 분석되고 현재 Perl 프로그램의 컨텍스트 내에서 실행됩니다. 이 형식은 일반적으로 첫 번째 (아래 참조)보다 예외를 더 효율적으로 잡는 데 사용되며 컴파일시 BLOCK 내에서 코드를 검사하는 이점도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d9a2ff0446afe648b7cb9385c3e87c463ddf6fa" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second 'the'.</source>
          <target state="translated">두 번째 일치 에서 정규 표현식이 문자열의 첫 번째 문자 위치에서 일치하고 중지 되었기 때문에 &lt;code&gt;$`&lt;/code&gt; 는 &lt;code&gt;''&lt;/code&gt; 와 같습니다 . 그것은 두 번째 'the'를 보지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="37e9c3cdd59dd9ca84f70e11b37a63713067a365" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt; . This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">제 2 단계에서, 구현의 자유 상속성 (또는 그 부족)이 설명된다. 이를 위해 &lt;code&gt;Name&lt;/code&gt; 의 공통 서브 클래스 인 &lt;code&gt;NamedFile&lt;/code&gt; 이라는 클래스 와 표준 클래스 &lt;code&gt;IO::File&lt;/code&gt; 합니다. &lt;code&gt;IO::File&lt;/code&gt; 객체 때문에 테스트에 상속성을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="979450caa584768989298a5e328245eeac253de3" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">엄밀히 말하면, 스크립트는 시작된 쉘과 다른 프로세스로 실행됩니다. 프로세스에 대한 변경 사항은 상위 항목에 반영되지 않으며 변경 후 생성 된 모든 하위 항목에만 반영됩니다. 쉘 에서 스크립트의 출력을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 함으로써 가짜로 만들 수있는 쉘 마술이 있습니다 . 자세한 내용은 comp.unix.questions FAQ를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5c6294b971049c13607515864de8d9b4202e94" translate="yes" xml:space="preserve">
          <source>In the symbian subdirectory there is</source>
          <target state="translated">symbian 서브 디렉토리에는</target>
        </trans-unit>
        <trans-unit id="a6664c3e7887f18c07bf996abcbf98da47057e7d" translate="yes" xml:space="preserve">
          <source>In the syntax descriptions that follow, list operators that expect a list (and provide list context for elements of the list) are shown with LIST as an argument. Such a list may consist of any combination of scalar arguments or list values; the list values will be included in the list as if each individual element were interpolated at that point in the list, forming a longer single-dimensional list value. Commas should separate literal elements of the LIST.</source>
          <target state="translated">다음 구문 설명에서 목록을 예상하고 목록의 요소에 대한 목록 컨텍스트를 제공하는 목록 연산자는 LIST를 인수로 사용하여 표시됩니다. 이러한 목록은 스칼라 인수 또는 목록 값의 조합으로 구성 될 수 있습니다. 각 개별 요소가 목록의 해당 지점에서 보간 된 것처럼 목록 값이 목록에 포함되어 더 긴 1 차원 목록 값을 형성합니다. 쉼표는 LIST의 리터럴 요소를 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe67245ac84887f626543e24a3e6a624b4a7332b" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt; . (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt; ) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie () 호출에서 &lt;code&gt;VARIABLE&lt;/code&gt; 은 매혹 될 변수의 이름입니다. &lt;code&gt;CLASSNAME&lt;/code&gt; 은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. &lt;code&gt;LIST&lt;/code&gt; 의 추가 인수는 해당 클래스에 적합한 생성자 메서드 (TIESCALAR (), TIEARRAY (), TIEHASH () 또는 TIEHANDLE ())에 전달됩니다. (일반적으로 이들은 C의 dbminit () 함수에 전달 될 수있는 인수입니다.) &quot;new&quot;메소드에 의해 리턴 된 오브젝트도 tie () 함수에 의해 리턴됩니다. 이는 다른 메소드에 액세스하려는 경우 유용합니다. 에 &lt;code&gt;CLASSNAME&lt;/code&gt; . (실제로 올바른 &quot;유형&quot;에 대한 참조를 반환 할 필요는 없습니다 (예 : HASH 또는 &lt;code&gt;CLASSNAME&lt;/code&gt; ) 제대로 축복 된 개체 인 한) tied () 함수를 사용하여 기본 개체에 대한 참조를 검색 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e605f529d11854bba56a166fe10700b1dd88fb" translate="yes" xml:space="preserve">
          <source>In the two-argument (and one-argument) form, opening &lt;code&gt;&amp;lt;-&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; opens STDIN and opening &lt;code&gt;&amp;gt;-&lt;/code&gt; opens STDOUT.</source>
          <target state="translated">2 인수 (및 1 인수) 양식에서 &lt;code&gt;&amp;lt;-&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 열면 STDIN이 열리고 &lt;code&gt;&amp;gt;-&lt;/code&gt; 가 열리면 STDOUT이 열립니다.</target>
        </trans-unit>
        <trans-unit id="305b7a93b43681322f3469e0f0cb84a704ec6817" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt; ) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">좀 더 복잡한 초기화가 필요한 SV의 경우 newSV (len)를 사용하여 빈 SV를 만들 수 있습니다. 경우 &lt;code&gt;len&lt;/code&gt; 형 NULL의 빈 SV가 반환 0, 형 PV의 다른 SV에 함께 반환합니다 (1 + 렌 &lt;code&gt;NUL&lt;/code&gt; ) 할당 스토리지, SvPVX를 통해 액세스 할 수의 바이트. 두 경우 모두 SV에 undef 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08f73822da4db28b0244d63be2806e6742a13f9" translate="yes" xml:space="preserve">
          <source>In the words of Chaim Frenkel: &quot;Perl's grammar can not be reduced to BNF. The work of parsing perl is distributed between yacc, the lexer, smoke and mirrors.&quot;</source>
          <target state="translated">Chaim Frenkel의 말에 따르면 : &quot;Perl의 문법은 BNF로 줄일 수 없습니다. perl을 파싱하는 작업은 yacc, 어휘 분석기, 연기 및 거울 사이에 배포됩니다.&quot;</target>
        </trans-unit>
        <trans-unit id="eea8935b77be896004ea3b86596d8c4b9f389127" translate="yes" xml:space="preserve">
          <source>In the work crew model, several threads are created that do essentially the same thing to different pieces of data. It closely mirrors classical parallel processing and vector processors, where a large array of processors do the exact same thing to many pieces of data.</source>
          <target state="translated">작업 승무원 모델에서는 다른 데이터 조각과 본질적으로 동일한 작업을 수행하는 여러 스레드가 생성됩니다. 그것은 고전적인 병렬 처리 및 벡터 프로세서를 밀접하게 반영합니다. 여기의 프로세서는 많은 데이터에 대해 똑같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="c55ef95af3c2d0a3702a06238a73d0da82b1e62b" translate="yes" xml:space="preserve">
          <source>In the year 2010 App::cpanminus was launched as a new approach to a cpan shell with a considerably smaller footprint. Very cool stuff.</source>
          <target state="translated">2010 년 App :: cpanminus는 설치 공간이 훨씬 작은 cpan 쉘에 대한 새로운 접근 방식으로 시작되었습니다. 아주 멋진 것들.</target>
        </trans-unit>
        <trans-unit id="113762dd3316218250364ac4d21aa3eda82fed63" translate="yes" xml:space="preserve">
          <source>In theory &lt;code&gt;Strtol&lt;/code&gt; and &lt;code&gt;Strtoul&lt;/code&gt; may not be defined if the machine perl is built on doesn't actually have strtol and strtoul. But as those 2 functions are part of the 1989 ANSI C spec we suspect you'll find them everywhere by now.</source>
          <target state="translated">이론적으로 &lt;code&gt;Strtol&lt;/code&gt; 과 &lt;code&gt;Strtoul&lt;/code&gt; 은 펄이 내장 된 머신에 실제로 strtol과 strtoul이없는 경우 정의되지 않을 수 있습니다. 그러나이 두 함수가 1989 ANSI C 사양의 일부이므로 지금은 어디에서나 찾을 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d524f396baff67e45d81dc7f8d13d5cf1e77d980" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">이론적으로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 은 -2 ** 63에서 2 ** 63-1까지 신뢰할 수 있습니다. 그러나 구현의 해결 방법은 부동 소수점 숫자를 사용하기 때문에 시간이 갈수록 정확하지 않습니다. 이것은 버그이며 향후 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="cbe5df9e111a076eb83a7b1ca2b907e2c293b988" translate="yes" xml:space="preserve">
          <source>In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined. The defined test avoids problems where the line has a string value that would be treated as false by Perl; for example a &quot;&quot; or a &lt;code&gt;&quot;0&quot;&lt;/code&gt; with no trailing newline. If you really mean for such values to terminate the loop, they should be tested for explicitly:</source>
          <target state="translated">이러한 루프 구성에서 할당 된 값 (할당이 자동이든 명시 적이든)이 정의되었는지 여부를 테스트합니다. 정의 된 테스트는 행에 Perl에 의해 false로 처리되는 문자열 값이있는 문제를 피합니다. 예를 들어, 줄 바꿈이없는 &quot;&quot;또는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 입니다. 루프를 종료하기 위해 이러한 값을 실제로 의미하는 경우 명시 적으로 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e44b8059bd25cac80d7a80701ceeb87c0cc485a" translate="yes" xml:space="preserve">
          <source>In this -exec rendering, each opcode is executed in the order shown. The add opcode, marked with '*', is discussed in more detail.</source>
          <target state="translated">이 -exec 렌더링에서 각 opcode는 표시된 순서대로 실행됩니다. '*'로 표시된 추가 opcode에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fd1f4af2f36f22296f6e12cb734299d228fd203a" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt; . If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">이 대안에서는 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 앞에 &lt;code&gt;'\d+\.'&lt;/code&gt; \ d +' 를 두는 것이 중요합니다 . . 만약 &lt;code&gt;'\d+\.'&lt;/code&gt; 먼저 정규 표현식이 행복하게 일치하고 숫자의 소수 부분을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c0e19afab75cca33f669db41034484d08b958820" translate="yes" xml:space="preserve">
          <source>In this call,</source>
          <target state="translated">이 전화에서</target>
        </trans-unit>
        <trans-unit id="6f085ed6c4e3052eb0bb052f156e9a4157a1fe5d" translate="yes" xml:space="preserve">
          <source>In this call, the two arrays will be populated as shown below (for Unicode 6.0):</source>
          <target state="translated">이 호출에서 두 배열은 아래와 같이 채워집니다 (유니 코드 6.0의 경우).</target>
        </trans-unit>
        <trans-unit id="9ebdd72fd702032acef9641f741ed417c8e827d9" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;IO::Compress::Zip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields.</source>
          <target state="translated">이 경우 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 은 &lt;code&gt;$rawdata&lt;/code&gt; 가 0 개 이상의 일치하는 하위 필드로 구성되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="7445390dec364c96fb636b6c3a3e08bbc004467f" translate="yes" xml:space="preserve">
          <source>In this case a possible way around this problem is to predefine a series of C functions to act as the interface to Perl, thus</source>
          <target state="translated">이 경우이 문제를 해결할 수있는 방법은 Perl의 인터페이스 역할을하는 일련의 C 함수를 미리 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e58eeb1fce65fa0151692bc12dbf74ccd83c8127" translate="yes" xml:space="preserve">
          <source>In this case it is possible to speed up the routine (often quite substantially) by using the lightweight callback API. The idea is that the calling context only needs to be created and destroyed once, and the sub can be called arbitrarily many times in between.</source>
          <target state="translated">이 경우 경량 콜백 API를 사용하여 루틴의 속도를 높일 수 있습니다 (종종 상당히 실질적으로). 아이디어는 호출 컨텍스트를 한 번만 작성하고 파괴하면되고 서브를 임의로 여러 번 호출 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a45b342cd0260187347347f25fa6f1ce0fc4500" translate="yes" xml:space="preserve">
          <source>In this case the flow of control can consist of only the repeated sequence</source>
          <target state="translated">이 경우 제어 흐름은 반복 된 시퀀스로만 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de52280d051bfe1e84ce26c045f4bd463f4ae0ee" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">이 경우 함수 &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; 및 &lt;code&gt;fn3&lt;/code&gt; 은 호출 할 Perl 서브 루틴을 기억하는 데 사용됩니다. 각 함수는 &lt;code&gt;Pcb&lt;/code&gt; 함수 에서 &lt;code&gt;Map&lt;/code&gt; 배열 에 액세스 하고 실제로 Perl 서브 루틴을 호출하는 데 사용되는 별도의 고정 배선 인덱스를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba717b73fce507fddc399244f240ef5b6f054dd" translate="yes" xml:space="preserve">
          <source>In this case the input fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; will be transformed into this Perl regular expression</source>
          <target state="translated">이 경우 입력 파일 글로브 &lt;code&gt;*.tar.gz&lt;/code&gt; 는이 Perl 정규식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="779676f9752f28e10579e10de2beca329de72fea" translate="yes" xml:space="preserve">
          <source>In this case the main point to note is that only the last item in the list is returned from the subroutine.</source>
          <target state="translated">이 경우 주목할 점은 목록의 마지막 항목 만 서브 루틴에서 반환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="570da359699c43b4bafeef5621d77b9bbf97eae1" translate="yes" xml:space="preserve">
          <source>In this case the program will be run multiple times using each target file.</source>
          <target state="translated">이 경우 각 대상 파일을 사용하여 프로그램이 여러 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0f3bc0334984124b9519a2c06691727251a21f" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt; . We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">이 경우 문자열에 &lt;code&gt;foo&lt;/code&gt; 가 포함되어야하며 뒤에 &lt;code&gt;bar&lt;/code&gt; 가 있어야한다는 것을 알고 있습니다 . &lt;code&gt;fbm_instr()&lt;/code&gt; 에 구현 된 Fast Boyer-Moore 매칭을 사용 하여 이러한 문자열의 위치를 ​​찾을 수 있습니다. 그것들이 존재하지 않는다면 훨씬 비싼 정규식 엔진에 의지 할 필요가 없습니다. 더 좋은 점은 존재하는 경우 해당 위치를 사용하여 전체 패턴이 일치하는지 확인하기 위해 정규식 엔진이 다루어야하는 검색 공간을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7adf1e07cf7e2de470c351018728e0b1e6d507de" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 복제 할 항목으로 대체됩니다. 0으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="6c66364cb0f3415ad0b76d2776349bcfcc95f50e" translate="yes" xml:space="preserve">
          <source>In this case, because the &lt;code&gt;JMPENV&lt;/code&gt; level recorded in the &lt;code&gt;CxEVAL&lt;/code&gt; differs from the current one, &lt;code&gt;docatch&lt;/code&gt; just does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; and the C stack unwinds to:</source>
          <target state="translated">때문에이 경우 &lt;code&gt;JMPENV&lt;/code&gt; 의 레벨이 기록 &lt;code&gt;CxEVAL&lt;/code&gt; 현재의 다르면 &lt;code&gt;docatch&lt;/code&gt; 단이 수행 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 와 C로 스택을 풀려 :</target>
        </trans-unit>
        <trans-unit id="38ba605349bb20448e174208a445c574b3bbbe89" translate="yes" xml:space="preserve">
          <source>In this case, if</source>
          <target state="translated">이 경우</target>
        </trans-unit>
        <trans-unit id="bb541d2c2f3bc8d3faf27ff1a86aae9a349b1c56" translate="yes" xml:space="preserve">
          <source>In this case, it finds a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File&lt;/code&gt; class. Note that the object passed to &lt;code&gt;save()&lt;/code&gt; in this case is still a &lt;code&gt;File::MP3&lt;/code&gt; object, even though the method is found in the &lt;code&gt;File&lt;/code&gt; class.</source>
          <target state="translated">이 경우 &lt;code&gt;File&lt;/code&gt; 클래스 에서 &lt;code&gt;save()&lt;/code&gt; 메서드를 찾습니다 . 이 경우 &lt;code&gt;save()&lt;/code&gt; 에 전달 된 객체 는 &lt;code&gt;File&lt;/code&gt; 클래스 에서 메서드를 찾더라도 여전히 &lt;code&gt;File::MP3&lt;/code&gt; 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="d9ed12158dee993299753ff9f1084ddd79644a4a" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt; s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">이 경우 BEGIN은 활성화 된 참조가 없기 때문에 실행 직후에 해제됩니다 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 하위 프로토 타입에는 클로저 가 아니기 때문에 CvWEAKOUTSIDE가 설정되어 있고 $ a는 동일한 CV를 가리 키므로 BEGIN에 기여하지 않습니다. refcount 중 하나. $ a가 실행될 때 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; 는 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 체인을 따르고 해제 된 BEGIN에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="445e238a2cf161c353789dd6ff6ac3c0dc14cd3f" translate="yes" xml:space="preserve">
          <source>In this case, the data flow from the pipeline can be represented as follows:</source>
          <target state="translated">이 경우 파이프 라인의 데이터 흐름은 다음과 같이 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ef174320084e5b9df3d70ddc86b3f46c5bccd4" translate="yes" xml:space="preserve">
          <source>In this case, the function will overload both of the three way comparison operators. For all overload operations using non-alpha characters, you must type the parameter without quoting, separating multiple overloads with whitespace. Note that &quot;&quot; (the stringify overload) should be entered as \&quot;\&quot; (i.e. escaped).</source>
          <target state="translated">이 경우이 함수는 3 방향 비교 연산자 모두에 과부하가 걸립니다. 알파벳이 아닌 문자를 사용하는 모든 과부하 작업의 경우 따옴표없이 여러 개의 과부하를 공백으로 구분하여 매개 변수를 입력해야합니다. &quot;&quot;(문자열 화 과부하)는 \ &quot;\&quot;(즉 이스케이프 처리)로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d4b7be359855c6b427d300bbc65846d64f8cf9d" translate="yes" xml:space="preserve">
          <source>In this case, the reference count for the variables will never reach 0, and the references will never be garbage-collected. This can lead to memory leaks.</source>
          <target state="translated">이 경우 변수의 참조 횟수는 0에 도달하지 않으며 참조는 가비지 수집되지 않습니다. 메모리 누수가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6f51a2de8f8d888eeb99016141d99a3d195bd9" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details.</source>
          <target state="translated">이 경우, yes-pattern은 직접 실행되지 않으며 no-pattern은 허용되지 않습니다. 정신에는 변함이 &lt;code&gt;(?{0})&lt;/code&gt; 하지만 더 효율적입니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="18c031d44e01689714a7d1be31709243cd683ac5" translate="yes" xml:space="preserve">
          <source>In this case, there's not much to see, but of course normally there's pages of stuff to wade through, and 'l' can be very useful. To reset your view to the line we're about to execute, type a lone period '.':</source>
          <target state="translated">이 경우에는 볼 것이 많지 않지만 일반적으로 살펴볼 내용이 있으며 'l'은 매우 유용 할 수 있습니다. 실행하려는 행으로보기를 재설정하려면 고독 기간 '.'을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d6cf564bd8d8897a564d43efb035ccf8128bfa59" translate="yes" xml:space="preserve">
          <source>In this case, you cannot omit the first</source>
          <target state="translated">이 경우 첫 번째를 생략 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c6ff251bc24fa4db8e24130b2fd6042c3837352e" translate="yes" xml:space="preserve">
          <source>In this case, you use the &lt;code&gt;detach()&lt;/code&gt; method. Once a thread is detached, it'll run until it's finished; then Perl will clean up after it automatically.</source>
          <target state="translated">이 경우 &lt;code&gt;detach()&lt;/code&gt; 메서드 를 사용합니다 . 스레드가 분리되면 완료 될 때까지 실행됩니다. Perl은 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="f06a2a722f183edc4aa583848f94d04c7c5ace33" translate="yes" xml:space="preserve">
          <source>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn't do Y, it's against this specification, and should really be fixed. &quot;X should do Y&quot; means that it's recommended, but X may fail to do Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be</source>
          <target state="translated">이 문서에서 &quot;must&quot;/ &quot;must not&quot;, &quot;should&quot;/ &quot;should not&quot;및 &quot;may&quot;는 기존의 의미를 갖습니다 (RFC 2119 참조). &quot;X must do Y&quot;는 X가 그렇지 않으면 Y는이 사양에 위배되며 실제로 수정해야합니다. &quot;X는 Y를해야한다&quot;는 것이 권장된다는 것을 의미하지만, 정당한 이유가 있다면 X는 Y를하지 못할 수도 있습니다. &quot;X는 Y를 할 수있다&quot;는 단지 X는 Y를 자유롭게 할 수 있다는 점에 불과하다.</target>
        </trans-unit>
        <trans-unit id="f65b8f5200f2d0ab93731dfb5d397ad4f5889d0a" translate="yes" xml:space="preserve">
          <source>In this documentation, &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; on the first line of the program will stand in for whatever method works on your system. You are advised to use a specific path if you care about a specific version.</source>
          <target state="translated">이 문서 에서 프로그램의 첫 번째 줄에있는 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 은 시스템에서 작동하는 모든 방법에 적합합니다. 특정 버전에 관심이있는 경우 특정 경로를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="317bfd052c319e12e1dcc797f6ad498f8171149f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;--all&lt;/code&gt; will</source>
          <target state="translated">이 예에서 &lt;code&gt;--all&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="e92bf3ad9ffe37a0d52db0112f7aacb357e3a712" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt; , which can see the new &lt;code&gt;$x&lt;/code&gt; . A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt; .</source>
          <target state="translated">이 예에서, 새로운 &lt;code&gt;$x&lt;/code&gt; 는 &lt;code&gt;whatever&lt;/code&gt; 불릴 때 생성 되며 새로운 &lt;code&gt;inner&lt;/code&gt; 는 새로운 &lt;code&gt;$x&lt;/code&gt; 볼 수 있습니다 . &quot;state&quot;서브는 첫 번째 호출에서 &lt;code&gt;whatever&lt;/code&gt; 까지의 &lt;code&gt;$x&lt;/code&gt; 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd205d2b3e2dec6816acf70e5f088db6d1ebf4c2" translate="yes" xml:space="preserve">
          <source>In this example, only the first two assignments will be done immediately; after this, all the changes to the file will be deferred up to the user-specified memory limit.</source>
          <target state="translated">이 예에서는 처음 두 할당 만 즉시 수행됩니다. 그 후에 파일에 대한 모든 변경 사항은 사용자가 지정한 메모리 한도까지 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="19c920ce6f8f3e81b20912d17931330182ad0a53" translate="yes" xml:space="preserve">
          <source>In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes. This will demonstrate manipulation of complex Perl data types from an XSUB.</source>
          <target state="translated">이 예에서는 배열에 대한 참조를 입력 매개 변수로 사용하고 해시 배열에 대한 참조를 반환합니다. XSUB에서 복잡한 Perl 데이터 유형을 조작하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b22f4e4bd19dab41fd1e0219238248b0317aa35c" translate="yes" xml:space="preserve">
          <source>In this example, we will get the following output:</source>
          <target state="translated">이 예제에서는 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ee2620c9071c60e99d08be588513a407e9d8d25d" translate="yes" xml:space="preserve">
          <source>In this example, we'll do some more work with the argument stack. The previous examples have all returned only a single value. We'll now create an extension that returns an array.</source>
          <target state="translated">이 예에서는 인수 스택에 대해 더 많은 작업을 수행합니다. 이전 예제는 모두 단일 값만 반환했습니다. 이제 배열을 반환하는 확장을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bc42a21b3f25368390b359d2c6a1e02f5038d3de" translate="yes" xml:space="preserve">
          <source>In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries. To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us.</source>
          <target state="translated">이 예제에서는 이제 사전 정의 된 C 라이브러리와 상호 작용할 XSUB를 작성하기 시작합니다. 우선, 우리 자신의 작은 라이브러리를 구축 한 다음 h2xs가 .pm 및 .xs 파일을 작성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ccfbfd9001b68d4bb9123e9a75f5be994042b170" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt; , so it could be factored out:</source>
          <target state="translated">이 형식에서는 교대를 단순화하는 방법을 쉽게 알 수 있습니다. 대안 1, 2 및 4는 모두 &lt;code&gt;\d+&lt;/code&gt; 시작 하므로 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b24fb7d07c9db355f07769493a9de293acc8111" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a category of functions and the value is a short description of that category.</source>
          <target state="translated">이 해시에서 각 키는 기능 범주를 나타내며 값은 해당 범주에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3f56d8b8bdb8c26426f0b6660b2be0710caeb9c2" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is a short description of that function.</source>
          <target state="translated">이 해시에서 각 키는 함수를 나타내고 값은 해당 함수에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="4112ec477caea48107dc76ca327ecc26b9559568" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is the category. The category can be a comma separated list.</source>
          <target state="translated">이 해시에서 각 키는 함수를 나타내며 값은 범주입니다. 범주는 쉼표로 구분 된 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b991cc90d42bab8c037a6310ce95c7fd23aada4" translate="yes" xml:space="preserve">
          <source>In this instance the &quot;Store&quot; and &quot;Fetch&quot; methods are encapsulated inside a &quot;Filter&quot; method.</source>
          <target state="translated">이 경우 &quot;Store&quot;및 &quot;Fetch&quot;메소드는 &quot;Filter&quot;메소드 안에 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="d35ad5c2c0618e945079ac0ca929cf4d613d24d9" translate="yes" xml:space="preserve">
          <source>In this library, the numbers are represented in base B = 10**N, where N is the largest possible value that does not cause overflow in the intermediate computations. The base B elements are stored in an array, with the least significant element stored in array element zero. There are no leading zero elements, except a single zero element when the number is zero.</source>
          <target state="translated">이 라이브러리에서 숫자는 기본 B = 10 ** N으로 표시되며, 여기서 N은 중간 계산에서 오버플로를 발생시키지 않는 가능한 가장 큰 값입니다. 기본 B 요소는 배열에 저장되며 최하위 요소는 배열 요소 0에 저장됩니다. 숫자가 0 일 때 단일 0 요소를 제외하고 선행 0 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df68cfd3648ab58a91a7f368ccaceffbf7d1f325" translate="yes" xml:space="preserve">
          <source>In this particular case we don't have to call</source>
          <target state="translated">이 특별한 경우에 우리는 전화 할 필요가 없습니다</target>
        </trans-unit>
        <trans-unit id="dad6a924b2e38abcfe4b4ffded7acf8266a85c31" translate="yes" xml:space="preserve">
          <source>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</source>
          <target state="translated">이 패스에서 우리가 방출해야 할 각 regop에 필요한 공간의 양을 계산하기 위해 입력 패턴이 구문 분석됩니다. 이 크기는 또한 프로그램에서 멀리뛰기가 필요한지 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41f31a4be766288871cf075eb0ef8be8f75f8e7b" translate="yes" xml:space="preserve">
          <source>In this pod section each line obeys the format</source>
          <target state="translated">이 포드 섹션에서 각 줄은 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2a40391b3aa03b91dc32950cbb01e23eafc7a333" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;^&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">이 정규 표현식에서 첫 번째 최소 수량화를 기대할 수 있습니다 &lt;code&gt;.*?&lt;/code&gt; 빈 문자열 과 일치해야합니다. 단어의 시작과 일치하도록 &lt;code&gt;^&lt;/code&gt; 앵커로 제한되지 않기 때문입니다 . 그러나 원칙 0이 여기에 적용됩니다. 전체 정규 표현식이 문자열의 시작 부분에서 일치 할 수 있기 때문에</target>
        </trans-unit>
        <trans-unit id="1677ca4d68d5b3cd757901e02552a2ca6071fc8c" translate="yes" xml:space="preserve">
          <source>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the &lt;code&gt;/g&lt;/code&gt; flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the &lt;code&gt;\s+&lt;/code&gt;, and the &lt;code&gt;$&lt;/code&gt; anchor can match to the absolute end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the &lt;code&gt;^\s+&lt;/code&gt; would remove all by itself:</source>
          <target state="translated">이 정규식에서 앵커는 대체보다 우선 순위가 낮기 때문에 문자열의 시작 또는 끝에서 대체가 일치합니다. 으로 &lt;code&gt;/g&lt;/code&gt; 은 모두를 얻을 수 있도록 플래그, 대체 모든 가능한 일치한다. 후행 줄 바꿈은 &lt;code&gt;\s+&lt;/code&gt; 와 일치 하고 &lt;code&gt;$&lt;/code&gt; 앵커는 문자열의 절대 끝과 일치 할 수 있으므로 줄 바꿈도 사라집니다. 줄 바꿈을 출력에 추가하면 &lt;code&gt;^\s+&lt;/code&gt; 가 모두 자동으로 제거 하는 &quot;공백&quot;(공백으로 구성됨) 줄을 유지하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="77b676e373d337a1558a3681668f6ee37714295f" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. This idea has several variations.</source>
          <target state="translated">이 성명에서, &lt;code&gt;World&lt;/code&gt; 정규식과입니다 &lt;code&gt;//&lt;/code&gt; 둘러싸 &lt;code&gt;/World/&lt;/code&gt; 일치하는 문자열을 검색 할 펄을 알려줍니다. 연산자 &lt;code&gt;=~&lt;/code&gt; 는 문자열을 정규식 일치와 연결하고 정규식이 일치하면 true를, 정규식이 일치하지 않으면 false를 생성합니다. 이 경우 &lt;code&gt;World&lt;/code&gt; 는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 의 두 번째 단어와 일치 하므로 표현이 참입니다. 이 아이디어에는 몇 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c818981124c0efd397c772e8c5a5bccf099d60f4" translate="yes" xml:space="preserve">
          <source>In this way (as for perl's scalars) a pointer to a PerlIOBuf can be treated as a pointer to a PerlIOl.</source>
          <target state="translated">이런 식으로 (perl의 스칼라에서와 같이) PerlIOBuf에 대한 포인터는 PerlIOl에 대한 포인터로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c607bae4c1c842072097188930b7f5e712b730" translate="yes" xml:space="preserve">
          <source>In those 8 cases above, the value of EXPR is used directly as a boolean, so no smartmatching is done. You may think of &lt;code&gt;when&lt;/code&gt; as a smartsmartmatch.</source>
          <target state="translated">위의 8 가지 경우에 EXPR 값은 부울로 직접 사용되므로 스마트 매칭이 수행되지 않습니다. &lt;code&gt;when&lt;/code&gt; 스마트 스마트 매크로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9186d74e76b80422b13adb44366ed78c8afac4f7" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">이러한 경우 Filter :: Simple을로드 하는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문에 필터링 서브 루틴 및 종료 자 스펙을 직접 추가하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="95167fe0e36a49f5080da73352ed44710a152f26" translate="yes" xml:space="preserve">
          <source>In those cases, you would turn off &lt;code&gt;strict 'refs'&lt;/code&gt; temporarily so you can play around with the symbol table. For example:</source>
          <target state="translated">이러한 경우에는 &lt;code&gt;strict 'refs'&lt;/code&gt; 일시적으로 해제 하여 기호 테이블을 가지고 놀 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6200c4c82d6daee49dcd17953c7919b7352b65f" translate="yes" xml:space="preserve">
          <source>In time-critical applications, it is worthwhile to avoid splitting into more fields than necessary. Thus, when assigning to a list, if LIMIT is omitted (or zero), then LIMIT is treated as though it were one larger than the number of variables in the list; for the following, LIMIT is implicitly 3:</source>
          <target state="translated">시간이 중요한 응용 분야에서는 필요 이상으로 더 많은 필드로 분할하지 않는 것이 좋습니다. 따라서리스트에 지정할 때 LIMIT가 생략 된 경우 (또는 0), LIMIT는리스트에있는 변수의 수보다 하나 더 큰 것으로 취급됩니다. 다음의 경우 LIMIT는 암시 적으로 3입니다.</target>
        </trans-unit>
        <trans-unit id="61aec1693f3cca77d878f9993860b197db04ab69" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http://whatever/Foo%3a%3aBar&lt;/a&gt;, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;?&quot;.</source>
          <target state="translated">회전 &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo :: Bar&lt;/a&gt; 로 &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;에 http : // 어떤 / 푸 % 3A % 3aBar&lt;/a&gt; 은 &quot;푸 % 3A % 3aBar&quot;전에 넣어 것. 기본값은 &quot; &lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt; ?&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="fe66d5d405c8ef8a7eac08fc91eff0a843fd6e3f" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; into &lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http://whatever/man/1/crontab&lt;/a&gt;, what to put before the &quot;1/crontab&quot;. The default value is &quot;&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;&quot;.</source>
          <target state="translated">선회 &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; 에&lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt; // 어떤 / 사람 / 1 / crontab을 : HTTP&lt;/a&gt; 은 &quot;1 / crontab을&quot;전에 넣어 무엇을,. 기본값은 &quot; &lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="43281809d91fd31f1807b9436030386775e6651b" translate="yes" xml:space="preserve">
          <source>In typical VMS style, only the first letter of the value of this logical name is actually checked in a case insensitive mode, and it is considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</source>
          <target state="translated">일반적인 VMS 스타일에서는이 논리 이름 값의 첫 문자 만 실제로 대소 문자를 구분하지 않는 모드에서 검사되며 값이 &quot;T&quot;, &quot;1&quot;또는 &quot;E&quot;인 경우 활성화 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="573e7b50018345b4e76799c05af940dc27c74f2b" translate="yes" xml:space="preserve">
          <source>In ualarm() you tried to use number of microseconds or interval (also in microseconds) more than 1_000_000 and setitimer() is not available in your system to emulate that case.</source>
          <target state="translated">ualarm ()에서 1_000_000보다 큰 수의 마이크로 초 또는 간격 (마이크로 초)을 사용하려고 시도했으며 시스템에서 setitimer ()를 사용하여 해당 사례를 에뮬레이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f02423b74e4b6df478931aa6ac2f4633241db988" translate="yes" xml:space="preserve">
          <source>In verbose mode, a warning is printed if shadows are found (i.e., more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">상세 모드에서 그림자가 발견되면 경고가 인쇄됩니다 (예 : 동일한 POD 이름을 가진 둘 이상의 POD 파일이 발견되면</target>
        </trans-unit>
        <trans-unit id="8a3ebab20ae57eb43347721d9e5a409b1ce17a43" translate="yes" xml:space="preserve">
          <source>In version 2.37 the first argument to the callback function was changed from string to object. This was done to make room for extensions and more detailed control. The object stringifies to the option name so this change should not introduce compatibility problems.</source>
          <target state="translated">버전 2.37에서는 콜백 함수의 첫 번째 인수가 문자열에서 객체로 변경되었습니다. 이것은 확장 및 더 자세한 제어를위한 공간을 만들기 위해 수행되었습니다. 객체는 옵션 이름으로 문자열 화되므로이 변경으로 인해 호환성 문제가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="880a8be23ba2ee8779ff63078e49dfc5216b39eb" translate="yes" xml:space="preserve">
          <source>In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:</source>
          <target state="translated">버전 5.000 및 5.001에서는 위의 행을 사용하는 대신 다음 행을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1cc474b32c69cb459158c3dcaef8e4f4b651d874" translate="yes" xml:space="preserve">
          <source>In versions 5.6 and later, Perl won't recompile the regular expression if the variable hasn't changed, so you probably don't need the &lt;code&gt;/o&lt;/code&gt; option. It doesn't hurt, but it doesn't help either. If you want any version of Perl to compile the regular expression only once even if the variable changes (thus, only using its initial value), you still need the &lt;code&gt;/o&lt;/code&gt;.</source>
          <target state="translated">버전 5.6 이상에서 변수가 변경되지 않은 경우 Perl은 정규식을 다시 컴파일하지 않으므로 &lt;code&gt;/o&lt;/code&gt; 옵션이 필요하지 않습니다 . 아프지는 않지만 도움이되지 않습니다. 변수가 변경 되더라도 (따라서 초기 값만 사용하여) Perl 버전에서 정규 표현식을 한 번만 컴파일하도록하려면 &lt;code&gt;/o&lt;/code&gt; 가 여전히 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cb448bdd461c35050663768e40f737fb69d01266" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly. You need to change the &quot;use lib&quot; line to read:</source>
          <target state="translated">감마 버전 이전의 5.002 버전에서는 예제 1의 테스트 스크립트가 제대로 작동하지 않습니다. &quot;lib 사용&quot;줄을 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="47fb4d46b782f60712d6e476480e232acaeda83d" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs. This means that you cannot say &quot;make test&quot; to run the test script. You will need to add the following line before the &quot;use extension&quot; statement:</source>
          <target state="translated">5.002b1h 이전 5.002 버전에서는 test.pl 파일이 h2xs에 의해 자동으로 작성되지 않았습니다. 즉, 테스트 스크립트를 실행하기 위해 &quot;make test&quot;라고 말할 수 없습니다. &quot;확장자 사용&quot;문 앞에 다음 줄을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac1080be96df0c995d03afc96266140d8a96249c" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt; .</source>
          <target state="translated">5.004 이전의 Perl 버전에서는 &lt;code&gt;I18N::Collate&lt;/code&gt; 라이브러리 모듈을 사용하여 로케일 당 데이터 정렬이 가능했습니다 . 이 모듈은 이제 약간 더 이상 사용되지 않으며 새로운 응용 프로그램에서는 피해야합니다. &lt;code&gt;LC_COLLATE&lt;/code&gt; 의 기능은 이제 펄 핵심 언어에 통합되어 있습니다 : 하나는 완전히 일반적으로 로케일 고유의 스칼라 데이터를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , 그래서의 스칼라 참조와 저글링에 대한 필요가 더 이상 존재 &lt;code&gt;I18N::Collate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48a813c6d738225545b449a151bcdc156058f932" translate="yes" xml:space="preserve">
          <source>In your XS code, when you define an argument with a C type or when you are using a &lt;code&gt;CODE:&lt;/code&gt; and an &lt;code&gt;OUTPUT:&lt;/code&gt; section together with a C return type of your XSUB, it'll be the typemapping mechanism that makes this easy.</source>
          <target state="translated">XS 코드에서 C 유형으로 인수를 정의하거나 &lt;code&gt;CODE:&lt;/code&gt; 사용하는 경우 : 및 &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션을 XSUB의 C 리턴 유형과 함께 사용하는 경우이를 용이하게하는 유형 맵핑 메커니즘이됩니다.</target>
        </trans-unit>
        <trans-unit id="9357861451f0b2f036dafa4da40d9ece429bcae6" translate="yes" xml:space="preserve">
          <source>In-line functions that are in headers that are accessible to XS code need to be able to compile without warnings with commonly used extra compilation flags, such as gcc's &lt;code&gt;-Wswitch-default&lt;/code&gt; which warns whenever a switch statement does not have a &quot;default&quot; case. The use of these extra flags is to catch potential problems in legal C code, and is often used by Perl aggregators, such as Linux distributors.</source>
          <target state="translated">XS 코드에 액세스 할 수있는 헤더에있는 인라인 함수는 gcc와 같이 일반적으로 사용되는 추가 컴파일 플래그를 사용하여 경고없이 컴파일 할 수 있어야합니다. &lt;code&gt;-Wswitch-default&lt;/code&gt; switch 문에 &quot;default&quot;가없는 경우 경고하는 를 . 이러한 추가 플래그를 사용하면 합법적 인 C 코드에서 잠재적 인 문제를 포착 할 수 있으며 Linux 배포자와 같은 Perl 어 그리 게이터가 종종 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fac261b8677bb294fa8e76c7f44d73a02d84ebb" translate="yes" xml:space="preserve">
          <source>In-memory IO, scalar IO</source>
          <target state="translated">인 메모리 IO, 스칼라 IO</target>
        </trans-unit>
        <trans-unit id="022b1dbe77251c047456c4feb5d0409e122d6848" translate="yes" xml:space="preserve">
          <source>In-place upgrade of the supplied SV to a version object.</source>
          <target state="translated">제공된 SV를 버전 객체로 전체 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="1930e5219f1534978185f9ba376df01339047154" translate="yes" xml:space="preserve">
          <source>Inappropriate documentation</source>
          <target state="translated">부적절한 문서</target>
        </trans-unit>
        <trans-unit id="72a5f6c42a6c39ea891ecb24d22128fd281d0e18" translate="yes" xml:space="preserve">
          <source>Inc</source>
          <target state="translated">Inc</target>
        </trans-unit>
        <trans-unit id="70b0bede26554e7ae42316f8d3fd932a7cdc066c" translate="yes" xml:space="preserve">
          <source>Incidentally, note that each class's &lt;code&gt;%Lexicon&lt;/code&gt; inherits-and-extends the lexicons in its superclasses. This is not because these are special hashes</source>
          <target state="translated">또한 각 클래스의 &lt;code&gt;%Lexicon&lt;/code&gt; 은 수퍼 클래스에서 상속하고 확장합니다. 이것은 특별한 해시이기 때문이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="56c1bcd0fe0c175606142de66e47a332c19454ad" translate="yes" xml:space="preserve">
          <source>Incidentally, note that there's no easy way to express a data paragraph starting with something that looks like a command. Consider:</source>
          <target state="translated">또한 명령처럼 보이는 것으로 시작하여 데이터 단락을 표현하는 쉬운 방법은 없습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="af23144864617d68a82ad427e6d70d917f0fe977" translate="yes" xml:space="preserve">
          <source>Incidentally, note the variance in the result values between the two examples; this is typical of benchmarking. If this were a real benchmark, you would probably want to run a lot more iterations.</source>
          <target state="translated">또한 두 예제 사이의 결과 값의 차이에 유의하십시오. 이것은 벤치마킹의 전형입니다. 이것이 실제 벤치 마크라면 더 많은 반복을 실행하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="11c54a59d8a9668fa20146e40c46116f6e7acc35" translate="yes" xml:space="preserve">
          <source>Include</source>
          <target state="translated">Include</target>
        </trans-unit>
        <trans-unit id="7f36757a0ff9e21d096da46852dca59689517203" translate="yes" xml:space="preserve">
          <source>Include /usr/ccs/bin/ in your PATH.</source>
          <target state="translated">PATH에 / usr / ccs / bin /을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="5f7213221d8f17a14d6c7b8882fe3f1c79362499" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile (default behaviour).</source>
          <target state="translated">파일에 POD 오류가있는 경우 (기본 동작) 출력 파일에 &quot;POD ERRORS&quot;섹션을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1f63d3adcc78e2a751c9de88b5a592a5d6f05fed" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile. This section is included by default.</source>
          <target state="translated">파일에 POD 오류가있는 경우 출력 파일에 &quot;POD ERRORS&quot;섹션을 포함하십시오. 이 섹션은 기본적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1be836334b7992bf64bdd66feaf2cdd670e862a6" translate="yes" xml:space="preserve">
          <source>Include a single css source in the header:</source>
          <target state="translated">헤더에 단일 CSS 소스를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="82da13ca7b8da7d4d7bd6d25f32b5e4df5ab790d" translate="yes" xml:space="preserve">
          <source>Include a single javascript source:</source>
          <target state="translated">단일 자바 스크립트 소스를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="dacfcf246f0e94f511558260bbdd933b10ed8af6" translate="yes" xml:space="preserve">
          <source>Include any non-POD text from the input file in the output as well. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">입력 파일의 비 POD 텍스트도 출력에 포함하십시오. POD를 렌더링하고 코드를 그대로 유지 한 상태에서 POD 블록으로 문서화 된 코드를 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b3aefa9c8a28918cfdeb274cb63c2499f4f13ccf" translate="yes" xml:space="preserve">
          <source>Include code for safely storing static data in the .xs file. Extensions that do no make use of static data can ignore this option.</source>
          <target state="translated">정적 데이터를 .xs 파일에 안전하게 저장하기위한 코드를 포함합니다. 정적 데이터를 사용하지 않는 확장은이 옵션을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73830e720872f365cfd2f2dbd3697deb29a3d139" translate="yes" xml:space="preserve">
          <source>Include file dirs eg: &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</source>
          <target state="translated">파일 디렉토리 포함 예 : &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7dea1bf3fcc056eca7b649b6605fbf3217e27a" translate="yes" xml:space="preserve">
          <source>Include tests with your module</source>
          <target state="translated">모듈에 테스트 포함</target>
        </trans-unit>
        <trans-unit id="44cae264b95e40204b6c9817100d817393044faa" translate="yes" xml:space="preserve">
          <source>Include the `nstore' option to have the &lt;code&gt;Storable&lt;/code&gt; database written in `network order'. (See &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; for more details about this.)</source>
          <target state="translated">은`nstore '를 가지고있는 옵션을 포함 &lt;code&gt;Storable&lt;/code&gt; `네트워크의 순서로 기입 데이터베이스를'. (참조 &lt;a href=&quot;storable&quot;&gt;저장 가능&lt;/a&gt; 이에 대한 자세한 내용은.)</target>
        </trans-unit>
        <trans-unit id="428c39cb578db360bfc5803c8ec5f4e60b61ea16" translate="yes" xml:space="preserve">
          <source>Include the code from the &lt;b&gt;.h&lt;/b&gt; file as a comment in the &lt;b&gt;.ph&lt;/b&gt; file. This is primarily used for debugging</source>
          <target state="translated">&lt;b&gt;.h&lt;/b&gt; 파일 의 코드를 &lt;b&gt;.ph&lt;/b&gt; 의 주석으로 포함&lt;b&gt;&lt;/b&gt; 파일 하십시오. 이것은 주로 디버깅에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="5318c44a39f5f77944d683ed2f0ae1a7ab04539f" translate="yes" xml:space="preserve">
          <source>Include the following line in the XS section of your XS file: (don't break the line)</source>
          <target state="translated">XS 파일의 XS 섹션에 다음 줄을 포함하십시오 : (줄을 끊지 마십시오)</target>
        </trans-unit>
        <trans-unit id="eb7645ad7831d7d6fd6181e27396b77155390482" translate="yes" xml:space="preserve">
          <source>Include the main program in the output, even if subroutines were also specified. This rendering is normally suppressed when a subroutine name or reference is given.</source>
          <target state="translated">서브 루틴도 지정된 경우에도 기본 프로그램을 출력에 포함하십시오. 서브 루틴 이름 또는 참조가 제공되면이 렌더링은 일반적으로 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="39d690d519d42e4c1222e708f1a7882603060ecf" translate="yes" xml:space="preserve">
          <source>Include verbose configuration data in the report.</source>
          <target state="translated">보고서에 자세한 구성 데이터를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="7af107d55e07795d28db937bc5e2e6b3d1acdce5" translate="yes" xml:space="preserve">
          <source>Included in the official Perl distribution, as in a standard module, a standard tool, or a standard Perl &lt;b&gt;manpage&lt;/b&gt;.</source>
          <target state="translated">표준 모듈, 표준 도구 또는 표준 Perl &lt;b&gt;맨 페이지&lt;/b&gt; 와 같이 공식 Perl 배포에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c36d5529b0434732ae50f5c4cfddc9ab638ebdc" translate="yes" xml:space="preserve">
          <source>Included recommended modules?</source>
          <target state="translated">권장 모듈이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="2d5cfde693773293f9c93c5da459379d1390e74a" translate="yes" xml:space="preserve">
          <source>Included suggested modules?</source>
          <target state="translated">제안 된 모듈이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="fd1eb7c27a0ef162dc3c74b06bcd124d36810aee" translate="yes" xml:space="preserve">
          <source>Included with the standard Cygwin netrelease is the inetutils package which includes libutil.a.</source>
          <target state="translated">표준 Cygwin netrelease에는 libutil.a를 포함하는 inetutils 패키지가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62deb9b6c9960c6cf27bcef72a0cb725d958b5ee" translate="yes" xml:space="preserve">
          <source>Includes the closing tag of &amp;lt;/title&amp;gt; and through the rest of the head till the opening of the body</source>
          <target state="translated">&amp;lt;/ title&amp;gt;의 닫는 태그를 포함하고 본문이 열릴 때까지 나머지 머리를 통해</target>
        </trans-unit>
        <trans-unit id="9abdbb8c9871ea5d015e2e60e10f71a6f7c5bffa" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">라이브러리 모듈의 포함은 더 잘 이루어집니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 도 자동 오류 검사를하고 문제가있을 경우 예외를 발생 연산자를.</target>
        </trans-unit>
        <trans-unit id="fc7468d33bdeb93695da594528f2501435fe4708" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">라이브러리 모듈의 포함은 더 잘 이루어집니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 도 자동 오류 검사를하고 문제가있을 경우 예외를 발생 연산자를.</target>
        </trans-unit>
        <trans-unit id="d536a03f0c3143f6e1f810634a3c64f1cee1463a" translate="yes" xml:space="preserve">
          <source>Incompatibility with AIX Toolbox lib gdbm</source>
          <target state="translated">AIX Toolbox lib gdbm과의 비 호환성</target>
        </trans-unit>
        <trans-unit id="e53b7251c10e4fb16639ff0eb74e48d3fdb255f3" translate="yes" xml:space="preserve">
          <source>Increment OBJ by one.</source>
          <target state="translated">OBJ를 하나씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a3b00269821fb57d8ea2de1fc824b0f5f9a60902" translate="yes" xml:space="preserve">
          <source>Increment an SV's reference count. Use the &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SV의 참조 카운트를 증가시킵니다. 사용 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 대신 랩퍼.</target>
        </trans-unit>
        <trans-unit id="0e74e496959812fcc073992ca705206317cb9544" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; . The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; 의 참조 횟수를 증가시킵니다 . &lt;code&gt;refcounted_he&lt;/code&gt; 에 대한 포인터 도 반환됩니다. 이 함수에 널 포인터를 전달하는 것이 안전합니다. 조치가 발생하지 않으며 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e3802b6aa343742e73ae6047c081fca9075a08d1" translate="yes" xml:space="preserve">
          <source>Increment the version number for every change, no matter how small</source>
          <target state="translated">아무리 작아도 변경 될 때마다 버전 번호를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="4c98c7bfa60bc9d7d9626649411d920868a3e57d" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt; , which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; 을 증가 시켜 모든 패키지에서 메소드 캐싱을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="3272c368109726f88d497737f134b46e95de8369" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the given SV, returning the SV.</source>
          <target state="translated">주어진 SV의 참조 카운트를 증가시켜 SV를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3fb59bb686d8260401f92a3aa6f2bbde8cfdc66" translate="yes" xml:space="preserve">
          <source>Indeed, a negative real number can be noted &lt;code&gt;[x,pi]&lt;/code&gt; (the modulus</source>
          <target state="translated">실제로 음의 실수는 &lt;code&gt;[x,pi]&lt;/code&gt; (모듈러스</target>
        </trans-unit>
        <trans-unit id="a04774d4b73d320e20f71b059e1b914a71747c31" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt; ), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">실제로주기를 종료하려면 $ cnt가 false가되어야합니다. 그러나 위조를 검사 하는 연산자 &lt;code&gt;bool&lt;/code&gt; 이 오버로드되고 (이번 오버로드 된 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 통해 ) 긴 문자열을 리턴하므로 &lt;code&gt;symbolic&lt;/code&gt; 유형의 모든 오브젝트 가 모두 참입니다. 이를 극복하려면 객체를 0과 비교할 수있는 방법이 필요합니다. 실제로 숫자 변환 루틴을 작성하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="62ba8e1b3397c92c36fc4b8d835f19b0c882946b" translate="yes" xml:space="preserve">
          <source>Indent lines by multiples of</source>
          <target state="translated">여러 줄로 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="62114f3245956b96ef644ac166335fb4a4e9a90b" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">해시 함수, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반환 항목에 해시 당 무작위 순서 로 사용되는 시드에 관계없이 . 삽입으로 해시를 수정하면 해당 해시의 반복 ​​순서가 변경됩니다. 이 동작은 &lt;a href=&quot;hash/util&quot;&gt;Hash :: Util의 &lt;/a&gt; &lt;code&gt;hash_traversal_mask()&lt;/code&gt; 를 사용하거나 PERL_PERTURB_KEYS 환경 변수 를 사용하여 재정의 할 수 있습니다 ( &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun의 PERL_PERTURB_KEYS&lt;/a&gt; 참조) . 이 기능은 저장된 실제 순서가 아니라 키의 &quot;표시&quot;순서를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="074fa110a121b41d1fc8547d15dc9f9c647ba94b" translate="yes" xml:space="preserve">
          <source>Independent subexpressions</source>
          <target state="translated">독립 하위 식</target>
        </trans-unit>
        <trans-unit id="f095033a2da35066ce69235bfd888bf108da82db" translate="yes" xml:space="preserve">
          <source>Index/Value Array Slices</source>
          <target state="translated">인덱스 / 값 배열 슬라이스</target>
        </trans-unit>
        <trans-unit id="9376bb53130ade1b5bef94ae526efe4afa9ba571" translate="yes" xml:space="preserve">
          <source>India Pale Ale. Also the International Phonetic Alphabet, the standard alphabet used for phonetic notation worldwide. Draws heavily on Unicode, including many combining characters.</source>
          <target state="translated">인도 창백한 에일. 또한 전 세계의 음성 표기법에 사용되는 표준 알파벳 인 International Phonetic Alphabet도 있습니다. 많은 결합 문자를 포함하여 유니 코드를 많이 그립니다.</target>
        </trans-unit>
        <trans-unit id="7939b23cc59e5fecb713c284b9570bf5c06bc4a8" translate="yes" xml:space="preserve">
          <source>Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List :: Util이 C 컴파일러로 컴파일되었는지 표시</target>
        </trans-unit>
        <trans-unit id="257f1f56edc7d22d13ca3e932a232d7b1ce1cb6a" translate="yes" xml:space="preserve">
          <source>Indicates how many bits are produced by the function used to generate normalized random numbers.</source>
          <target state="translated">정규화 된 난수를 생성하는 데 사용되는 함수에 의해 생성 된 비트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e61b5d3c6d9951043a7c42ee4ac908615e6dda5" translate="yes" xml:space="preserve">
          <source>Indicates if the test suite is currently passing.</source>
          <target state="translated">테스트 스위트가 현재 통과 중인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89c8d4afc13dccaac0824429842e2b3486822df1" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. A single typemap may be specified as a string, or multiple typemaps can be specified in an array reference, with the last typemap having the highest precedence.</source>
          <target state="translated">사용자 제공 유형 맵이 기본 유형 맵보다 우선해야 함을 나타냅니다. 단일 유형 맵을 문자열로 지정하거나 배열 유형에 여러 유형 맵을 지정할 수 있으며 마지막 유형 맵이 가장 높은 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a07031906aeffe3119baa721e29202522fd91917" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. This option may be used multiple times, with the last typemap having the highest precedence.</source>
          <target state="translated">사용자 제공 유형 맵이 기본 유형 맵보다 우선해야 함을 나타냅니다. 이 옵션은 마지막 유형 맵이 가장 높은 우선 순위와 함께 여러 번 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6c6be6a26747d93fbb6c3ceadc3f2de48a2c99" translate="yes" xml:space="preserve">
          <source>Indicates that arguments returned from a callback should be discarded. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 반환 된 인수는 버려야 함을 나타냅니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0527e8a268302f8a5a261750f72fb958d828bf1d" translate="yes" xml:space="preserve">
          <source>Indicates that no arguments are being sent to a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에 인수가 전송되지 않음을 나타냅니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1a4d2b29fe4bc866080992a5b7a34bdbecb2aeb" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">호출자가 결과의 호스트 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 호스트 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ec72841bfda828e77f110fabfe3b01a8c116ba" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">호출자가 결과의 서비스 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 서비스 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f532e8b4a0494e58b3d4e84b40bc705bd9387b6c" translate="yes" xml:space="preserve">
          <source>Indicates that the caller will pass a numeric address, rather than a hostname, and that getaddrinfo() must not perform a resolve operation on this name. This flag will prevent a possibly-slow network lookup operation, and instead return an error if a hostname is passed.</source>
          <target state="translated">호출자가 호스트 이름이 아닌 숫자 주소를 전달하고 getaddrinfo ()가이 이름에 대해 확인 작업을 수행하지 않아야 함을 나타냅니다. 이 플래그는 네트워크 조회 작업이 느리게 진행되는 것을 방지하고 대신 호스트 이름이 전달되면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c8087750e8c32a23d6ccd2949d0b7dadc5ebeea" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt; ) field of the result to be filled in.</source>
          <target state="translated">호출자 가 결과 의 표준 호스트 이름 ( &lt;code&gt;canonname&lt;/code&gt; ) 필드를 채우길 원함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0a02454d6f3918d6c495eef14a92688abca3837e" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a method. A subroutine so marked will not trigger the &quot;Ambiguous call resolved as CORE::%s&quot; warning.</source>
          <target state="translated">참조 된 서브 루틴이 메소드임을 나타냅니다. 이렇게 표시된 서브 루틴은 &quot;모호한 호출이 CORE :: % s로 해결되었습니다&quot;경고를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c805274f5974d7ec81414a21a79ac4005ac17f0" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a valid lvalue and can be assigned to. The subroutine must return a modifiable value such as a scalar variable, as described in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">참조 된 서브 루틴이 유효한 lvalue이며 할당 될 수 있음을 나타냅니다. 서브 루틴은 &lt;a href=&quot;perlsub&quot;&gt;perlsub에&lt;/a&gt; 설명 된대로 스칼라 변수와 같은 수정 가능한 값을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="945cc6067d92cdd88f1d4d49015ca5f672222998" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 및 &lt;a href=&quot;threads/shared&quot;&gt;스레드 :: 공유&lt;/a&gt; 모듈 과 함께 사용될 때 참조 된 변수가 다른 스레드에서 공유 될 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f5dc796b3c6e09f2adbe1df261ece3a878874b6e" translate="yes" xml:space="preserve">
          <source>Indicates that the socket address relates to a &lt;code&gt;SOCK_DGRAM&lt;/code&gt; socket, for the services whose name differs between TCP and UDP protocols.</source>
          <target state="translated">TCP와 UDP 프로토콜간에 이름이 다른 서비스에 대해 소켓 주소가 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 소켓과 관련됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d2c743e25365a9bdf3ff9b009f1ca948b97e6afb" translate="yes" xml:space="preserve">
          <source>Indicates that this resolution is for a local bind() for a passive (i.e. listening) socket, rather than an active (i.e. connecting) socket.</source>
          <target state="translated">이 해결 방법은 활성 (예 : 연결) 소켓이 아닌 수동 (예 : 수신) 소켓에 대한 로컬 bind ()에 대한 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f10eaccf1b997cf7e5e0f8a8f4fab0ca55e7525" translate="yes" xml:space="preserve">
          <source>Indicates the macro to be used to generate normalized random numbers. Uses randfunc, often divided by (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits)) in order to normalize the result. In C programs, the macro &lt;code&gt;Drand01&lt;/code&gt; is mapped to drand01.</source>
          <target state="translated">정규화 된 난수를 생성하는 데 사용되는 매크로를 나타냅니다. 결과를 정규화하기 위해 종종 (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits))로 나눈 randfunc를 사용합니다. C 프로그램에서 매크로 &lt;code&gt;Drand01&lt;/code&gt; 은 drand01 에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="46fbaffe89877f1dd0586f026a063f6bfd1ece0d" translate="yes" xml:space="preserve">
          <source>Indicates the name of the random number function to use. Values include drand48, random, and rand. In C programs, the &lt;code&gt;Drand01&lt;/code&gt; macro is defined to generate uniformly distributed random numbers over the range [0., 1.[ (see drand01 and nrand).</source>
          <target state="translated">사용할 난수 함수의 이름을 나타냅니다. drand48, random 및 rand 값이 포함됩니다. C 프로그램에서 &lt;code&gt;Drand01&lt;/code&gt; 매크로는 [0., 1. [범위에 걸쳐 균일하게 분포 된 난수를 생성하도록 정의됩니다 (drand01 및 nrand 참조).</target>
        </trans-unit>
        <trans-unit id="0e9d38aea41337c4a340bd6ff37e0fceaaf530c7" translate="yes" xml:space="preserve">
          <source>Indicates the random number generating seed function. Values include srand48, srandom, and srand.</source>
          <target state="translated">난수 생성 시드 함수를 나타냅니다. 값은 srand48, srandom 및 srand를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="90e351cd851905a73031d78312feecb33ffe731a" translate="yes" xml:space="preserve">
          <source>Indicates the type of the argument of the seedfunc.</source>
          <target state="translated">seedfunc의 인수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2261f14a4235af1795b8d1185c5372fb55826237" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 에게 모든 일이 심하게 진행되고 있음을 나타냅니다 . 여기에는 추가 테스트 스크립트 실행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe441aac507416c2ecf5fefc2720f5a5e7cc6991" translate="yes" xml:space="preserve">
          <source>Indicates to the harness that things are going so badly all testing should terminate. This includes the running of any additional test scripts.</source>
          <target state="translated">상황이 나 빠지고 있음을 하네스에 표시하여 모든 테스트를 종료해야합니다. 여기에는 추가 테스트 스크립트 실행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bdde223b122eaee17c31cfd6ef76f52ec58ce6f0" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current item is a YAML block.</source>
          <target state="translated">현재 항목이 YAML 블록인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ac3f8f7cb3f69c816245189833fb5047e4be353" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current line could be parsed.</source>
          <target state="translated">현재 행을 구문 분석 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="765249e9b3e3ba66799eb3c3e692065e2ef4bdde" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a SKIP directive.</source>
          <target state="translated">주어진 결과에 SKIP 지시어가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e5feadbfd972a9ef3f2203c437baf1b81be3303" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO directive.</source>
          <target state="translated">주어진 결과에 TODO 지시문이 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5ae3ac2f7146f745d483818a88c053580ae4ad1e" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO or SKIP directive.</source>
          <target state="translated">주어진 결과에 TODO 또는 SKIP 지시문이 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33c1162df0e994c2dba92771958227447c3c8740" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a TAP version line.</source>
          <target state="translated">이 버전이 TAP 버전인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="82a274793f5ee26247829ddf91f4a9bd5a24bbd9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a YAML chunk.</source>
          <target state="translated">이것이 YAML 청크인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="551b037463cdc6d8ee7a155c709c206438a14ea9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment.</source>
          <target state="translated">이것이 주석인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fa47f2a4b95862bdf9eb043bb9b755ecb73bbd6f" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &lt;code&gt;merge&lt;/code&gt; option.</source>
          <target state="translated">이것이 주석인지 여부를 나타냅니다. STDERR이 STDOUT에 병합 된 경우 주석은 일반적으로 TAP 스트림에만 나타납니다. &lt;code&gt;merge&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5add899043fa2f2909dd47a1020e2ad33a37e66d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a pragma line.</source>
          <target state="translated">이것이 pragma 행인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7023aeaf089510f19833c997992b3c941c8dc92d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a test line.</source>
          <target state="translated">이것이 테스트 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f9b15b44f69cccc124e6789e9d93a4a06a7d51c" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is bailout line.</source>
          <target state="translated">이것이 구제 금융 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a3a5d84e52530eeac47fceba7db01f6e0dcbe22" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is the test plan line.</source>
          <target state="translated">이것이 테스트 계획 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9010b0739ea277aa1257ee6d74e58336f2039de7" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">렉서 버퍼의 옥텟 ( &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; )을 유니 코드 문자의 UTF-8 인코딩으로 해석 해야하는지 여부를 나타냅니다 . 그렇지 않은 경우 라틴 -1 문자로 해석해야합니다. 스칼라 에 대한 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6add24acec866ad90335d7337161ba97a738a82e" translate="yes" xml:space="preserve">
          <source>Indicating the Film::Rating() method is broken.</source>
          <target state="translated">Film :: Rating () 메서드를 나타내는 것이 깨졌습니다.</target>
        </trans-unit>
        <trans-unit id="065a6d5ea3be3a587038269a904d146bb9a0a3c1" translate="yes" xml:space="preserve">
          <source>Indirect Object Syntax</source>
          <target state="translated">간접 객체 구문</target>
        </trans-unit>
        <trans-unit id="3fba9ca2a9139d262136aa9779aba86f7f14b1e8" translate="yes" xml:space="preserve">
          <source>Individual Results</source>
          <target state="translated">개별 결과</target>
        </trans-unit>
        <trans-unit id="cb52fbb620cf2997c4aa4b5107c331f4b77d2de2" translate="yes" xml:space="preserve">
          <source>Individual test results.</source>
          <target state="translated">개별 테스트 결과.</target>
        </trans-unit>
        <trans-unit id="a6118403aceb71cf86308ba3cff213cbc8856dc0" translate="yes" xml:space="preserve">
          <source>Individual test suite results.</source>
          <target state="translated">개별 테스트 스위트 결과.</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="68dcf262960464f7812ef1f6844ea3187d8ab76d" translate="yes" xml:space="preserve">
          <source>Infinity and Not a Number</source>
          <target state="translated">무한대와 숫자가 아님</target>
        </trans-unit>
        <trans-unit id="ec4c72e2c7996edd7fe98bac862051d171e8f331" translate="yes" xml:space="preserve">
          <source>Inflate Interface</source>
          <target state="translated">팽창 인터페이스</target>
        </trans-unit>
        <trans-unit id="ae8803342c993280c888b28837c9da6527d39370" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 전체 내용을 팽창시킵니다 . 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beedaffabd6b03c265ffb648f984a13e030e2063" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; . The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 의 전체 내용을 압축하고 압축되지 않은 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 . &lt;code&gt;$input&lt;/code&gt; 및 &lt;code&gt;$output&lt;/code&gt; 매개 변수 중 하나 스칼라 또는 스칼라 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ddcc47830d9749b1f6958774d6b7383d928afa" translate="yes" xml:space="preserve">
          <source>Information on installing the Perl documentation in HTML format can be found in the</source>
          <target state="translated">HTML 형식으로 Perl 문서를 설치하는 것에 대한 정보는</target>
        </trans-unit>
        <trans-unit id="63a11938f1b7522fad4baac591e5655e30cc1a15" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt; . The variable is a structured string that looks something like this:</source>
          <target state="translated">현재 perl 바이너리가 컴파일 된 git commit에 대한 정보는 &lt;code&gt;$Config::Git_Data&lt;/code&gt; 변수에서 찾을 수 있습니다 . 변수는 다음과 같은 구조화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4fa18069a4aed5716a8df64d9e082aca15aa5195" translate="yes" xml:space="preserve">
          <source>Informative call that array is likely to grow to have</source>
          <target state="translated">배열이 성장할 가능성이 높은 정보 호출</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fdd8dbf1164cff77c53c1fcf6f05a5248f3597e3" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt; :</source>
          <target state="translated">상속은 두 클래스가 코드를 공유 할 수있게합니다. 기본적으로 부모 클래스의 모든 메서드는 자식에서도 사용할 수 있습니다. 자식은 부모의 메서드를 명시 적으로 &lt;b&gt;재정 의하여&lt;/b&gt; 자체 구현을 제공 할 수 있습니다. 우리는이 예를 들어, &lt;code&gt;File::MP3&lt;/code&gt; 객체를, 그것은이 &lt;code&gt;print_info()&lt;/code&gt; 에서 방법 &lt;code&gt;File&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbc41c48400edb2d66f46abd2eeeb9f193aa61fe" translate="yes" xml:space="preserve">
          <source>Inheritance and Overloading</source>
          <target state="translated">상속과 오버로딩</target>
        </trans-unit>
        <trans-unit id="b4102e1cbc70e34f207d4b05daf2f7d154eb2cce" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::ExtraHash*</source>
          <target state="translated">* Tie :: ExtraHash *에서 상속</target>
        </trans-unit>
        <trans-unit id="07845e4fa81351b41e3aca0473590f0745f203e3" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::Memoize*</source>
          <target state="translated">* Tie :: Memoize *에서 상속</target>
        </trans-unit>
        <trans-unit id="c5a788b89ced595ecbe83baf444c015d5af4ed62" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::StdHash*</source>
          <target state="translated">* Tie :: StdHash *에서 상속</target>
        </trans-unit>
        <trans-unit id="2af015f1a7a88588d2bedaaf274af7c154500941" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ee435be5e637cbc759b674414f3dfaaeaa6a310" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::Memoize&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: Memoize&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0942164c538c56917cf82fee8d95de867370af98" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::StdHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: StdHash&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="697bba69426638bf8ad3245a38ff2084b17b3805" translate="yes" xml:space="preserve">
          <source>Init methods</source>
          <target state="translated">초기화 방법</target>
        </trans-unit>
        <trans-unit id="469d92ba331e1f193a058b9d59b36d9c2695f1be" translate="yes" xml:space="preserve">
          <source>Init.U</source>
          <target state="translated">Init.U</target>
        </trans-unit>
        <trans-unit id="188fedc6f79203e40eb5a91d186ec6c30916e7f9" translate="yes" xml:space="preserve">
          <source>Initial discussion of the ability to modify IO streams behaviour used the term &quot;discipline&quot; for the entities which were added. This came (I believe) from the use of the term in &quot;sfio&quot;, which in turn borrowed it from &quot;line disciplines&quot; on Unix terminals. However, this document (and the C code) uses the term &quot;layer&quot;.</source>
          <target state="translated">IO 스트림 동작을 수정하는 기능에 대한 초기 논의는 추가 된 엔티티에 대해 &quot;징계&quot;라는 용어를 사용했습니다. 이것은 &quot;sfio&quot;라는 용어의 사용에서 비롯된 것으로, Unix 터미널의 &quot;라인 규칙&quot;에서 차용되었습니다. 그러나이 문서 (및 C 코드)에는 &quot;계층&quot;이라는 용어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af26189aae099c8b0074103f2d4d6fbc19c70e2f" translate="yes" xml:space="preserve">
          <source>Initial port of perl to WinCE. It was performed in separate directory named</source>
          <target state="translated">WinCE에 대한 perl의 초기 포트. 별도의 디렉토리에서 수행되었습니다</target>
        </trans-unit>
        <trans-unit id="64a1cc8196dec5ffb0b6abf423df9a7b0c6e0219" translate="yes" xml:space="preserve">
          <source>Initial version (GSAR 20-FEB-97)</source>
          <target state="translated">초기 버전 (GSAR 20-FEB-97)</target>
        </trans-unit>
        <trans-unit id="681e3458dd2b1a02b6b17850e74b7b6f830be8ea" translate="yes" xml:space="preserve">
          <source>Initialisation in &lt;code&gt;pregcomp()&lt;/code&gt; mostly involves the creation and data-filling of a special structure, &lt;code&gt;RExC_state_t&lt;/code&gt; (defined in</source>
          <target state="translated">&lt;code&gt;pregcomp()&lt;/code&gt; 초기화는 대부분 특수 구조 인 &lt;code&gt;RExC_state_t&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="c7a9076545ffc08af19383275c9bb0a670aaa64a" translate="yes" xml:space="preserve">
          <source>Initialises a deflation object.</source>
          <target state="translated">수축 오브젝트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b36a0f0079e64fa2a033c629779d3f623a057d8c" translate="yes" xml:space="preserve">
          <source>Initialises a deflation stream.</source>
          <target state="translated">수축 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6050c58e3e77b97a8c7a9c2f34e629bf70ca3f1a" translate="yes" xml:space="preserve">
          <source>Initialises an inflation object.</source>
          <target state="translated">인플레이션 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d6dc7f91e03e45468b8ef5863382d6fe3515a834" translate="yes" xml:space="preserve">
          <source>Initialises an inflation stream.</source>
          <target state="translated">인플레이션 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a08fb78f0ee25d9e540249a9eb4c3ec2aebf86f6" translate="yes" xml:space="preserve">
          <source>Initialization values for some globals</source>
          <target state="translated">일부 글로벌의 초기화 값</target>
        </trans-unit>
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">MAKE 환경 변수 또는 $ Config {make}에서 MAKE를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">플랫폼 전용으로 사용되는 매크로를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">MakeMaker 및 기타 도구 버전을 나타내는 매크로 초기화</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">링크와 관련된 매크로를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">SigSet 객체를 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">모든 신호를 포함하도록 SigSet 객체를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">를 초기화 AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_ * INSTALL * 된 installdirs, LIB_EXT, LIBPERL_A, MAP_TARGET 이름, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB , PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">EXE_FILES 목록에서 MAN1PODS를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">PM 파일 목록에서 MAN3PODS를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">PMLIBDIRS에서 PMLIBDIRS 및 PM을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">새로운 Perl 인터프리터를 초기화합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">새 객체를 초기화합니다. 이 메소드는 기본적으로 스텁이므로 적절하게 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">파일 경로에서 디렉토리와 파일 이름 사이의 구분자 인 DIRFILESEP 매크로를 초기화합니다. 즉. / Unix에서는 \, Win32에서는 \, VMS에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">tools_other ()가 사용하는 컴파일 및 링크와 관련된 매크로 정의를 초기화하고 $ MM 객체에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">tools_other ()가 사용하는 간단한 매크로 정의를 초기화하고 $ MM 객체에 배치합니다. 이들은 보수적 인 크로스 플랫폼 버전을 사용하며 성능을 위해 플랫폼 별 버전으로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">일반적인 (그리고 빠른) Unix 명령을 사용하도록 도구를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">함수 매개 변수 초기화</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 초기화</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">새로운 것으로 초기화</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">현재 메시지에서 데이터 전송을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">창 제한으로 인해 &lt;code&gt;perl -i.bak&lt;/code&gt; 파일을 편집하지 않고 파일의 &lt;code&gt;perl -i&lt;/code&gt; 편집 이 작동하지 않으므로 백업 확장자를 지정하지 않고 &lt;code&gt;perl -i&lt;/code&gt; 를 사용하면 Perl이 자동으로 접미사 &lt;code&gt;.bak&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">입력 파일 글롭</target>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">입력 및 출력 매개 변수</target>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">Perl 파일 핸들에 대한 입력 및 출력 파이프가 지원됩니다. &quot;파일 이름&quot;은 비동기 실행을 위해 lib $ spawn ()에 전달됩니다. Perl이 종료 될 때 &quot;분리 된&quot;서브 프로세스를 남기지 않도록 Perl 스크립트에서 연 파이프를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;장치&lt;/b&gt; 에서 입력 또는 출력 .</target>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">입력 라이브러리 및 경로 스펙은 Unix 링커에서 사용 하는 &lt;code&gt;-l&lt;/code&gt; 및 &lt;code&gt;-L&lt;/code&gt; 접두어를 사용 하거나 사용하지 않고 승인됩니다 .</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">입력 라이브러리 및 경로 스펙은 Unix 링커에서 사용 하는 &lt;code&gt;-l&lt;/code&gt; 및 &lt;code&gt;-L&lt;/code&gt; 접두어를 사용 하거나 사용하지 않고 승인됩니다 . 접두사가없는 경우 토큰은 실제로 디렉토리 인 경우 검색 할 디렉토리로, 그렇지 않으면 검색 할 라이브러리로 간주됩니다. ext ()의 Unix-OS / 2 버전이 필요하기 때문에 자신의 확장이 Unix 또는 OS / 2로 이식되기를 원하는 저자는 Unix 접두사를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">입력 문자열은 decode () d 다음 encode () d입니다. 간단한 2 단계 구현.</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">이러한 루틴의 입력은 BigFloat 오브젝트 또는 다음 네 가지 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">이 루틴에 대한 입력 값은 숫자처럼 보이며 16 진 및 2 진 숫자를 포함하여 정수가되는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">배열의 시작 부분에 LIST 요소를 삽입하여 기존 요소를 위로 이동하여 공간을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">배열의 시작 부분에 LIST 요소를 삽입하여 기존 요소를 위로 이동하여 공간을 확보하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">현재 lexing 포인트 ( &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; ) 바로 다음에 렉서 버퍼 ( &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; )에 문자를 삽입 하여 필요한 경우 버퍼를 재 할당하십시오. 이것은 나중에 실행되는 어휘 코드가 마치 입력에 나타난 것처럼 문자를 볼 수 있음을 의미합니다. 일반적인 구문 분석의 일부로이 작업을 수행하지 않는 것이 좋으며이 기능을 사용하면 대부분 삽입 된 문자가 의도하지 않은 방식으로 해석 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">POD, 주석 및 C 전 처리기 지시문 삽입</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">다음과 같은 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">SV 내에서 지정된 오프셋 / 길이에 문자열을 삽입합니다. Perl substr () 함수와 유사합니다. 손잡이는 마술을 얻는다.</target>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">sharpbang 또는 동등한 매직 번호를 @file 세트에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">, 안쪽 &lt;code&gt;(?{...})&lt;/code&gt; 블록, &lt;code&gt;$_&lt;/code&gt; 정규식에 일치되는 문자열을 의미합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 를 사용 하여이 문자열 내에서 현재 일치 위치를 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Perl 프로그램 내에서 &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt; 모듈을 사용하여 설치된 모든 배포판을 표시 할 수 있지만 마법을 수행하는 데 시간이 걸릴 수 있습니다. Perl과 함께 제공되는 표준 라이브러리는 &quot;Perl&quot;로 표시됩니다 (단, &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList로 라이브러리를&lt;/a&gt; 얻을 수는 있음 ).</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 코드 블록 안에 &lt;code&gt;$?&lt;/code&gt; 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 로 전달할 값을 포함합니다 . &lt;code&gt;$?&lt;/code&gt; 를 수정할 수 있습니까? 프로그램의 종료 값을 변경합니다. &lt;code&gt;$?&lt;/code&gt; 변경에주의 ? 실수로 (예 : &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 통해 무언가 실행 ).</target>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">내부 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 주어질 값을 포함합니다 . &lt;code&gt;$?&lt;/code&gt; 를 수정할 수 있습니까? 에서 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 프로그램의 종료 상태를 변경합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">(A)의 내부 &lt;code&gt;CHECK&lt;/code&gt; 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">(A)의 내부 &lt;code&gt;END&lt;/code&gt; 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">의 내부 &lt;code&gt;INIT&lt;/code&gt; 의 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">그런 내부</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">Perl 코어 ( &lt;code&gt;PERL_CORE&lt;/code&gt; 정의) 내에서 &lt;code&gt;Perl_&lt;/code&gt; 접두사를 사용하거나 사용하지 않고 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">블록 안에서는 &lt;code&gt;;&lt;/code&gt; 줄임표 앞에 &lt;code&gt;{ ... }&lt;/code&gt; 가 해시 참조 생성자가 아니라 블록 임을 나타냅니다 . 이제 줄임표가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">인사이드 아웃 객체</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">인사이드 아웃 클래스는 상속의 자유를 제공하지만 평소와 같이 가격이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">명시 적 객체 레지스트리를 가진 &lt;code&gt;id()&lt;/code&gt; 함수를 기반으로 한 내부 구현 . 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수를 기반으로 한 내부 구현 . &lt;code&gt;DESTROY&lt;/code&gt; 메소드 가 필요합니다 . 스레드 지원을 위해서는 &lt;code&gt;CLONE&lt;/code&gt; 메소드 (표시되지 않음)도 필요합니다. 대신에 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; 함수는 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 약간의 기능 차이가 사용될 수있다. 이것은 인사이드 아웃 클래스의 기본 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$UTF8{Euro}&lt;/code&gt; 검사 하면 &quot;\ xe2 \ x82 \ xac&quot;의 3 바이트가 포함되어 있음을 알 수 있습니다. 그러나 숫자 0x20AC는 1 자만 포함합니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 으로 왕복 여행을 완료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">Visual C ++ 2005를 먼저 설치 한 다음 Platform SDK를 설치하십시오. 기본 설치 위치를 선택한 것으로 가정하여 다음과 같이 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">Visual C ++ 2008-2013 Express를 설치 한 후 다음을 사용하여 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">명명 된 이벤트에 대한 콜백을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">신호 마스크를 설치하고 신호가 도착할 때까지 프로세스를 일시 중단하십시오. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;signal_mask&lt;/code&gt; 의 인수. 자세한 내용은 시스템의 &lt;code&gt;sigsuspend&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">성공적으로 테스트되었지만 아직 설치되지 않은 모든 배포를 설치하십시오. &lt;code&gt;is_tested&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">여기에서 거기까지 파일 설치</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;정규 신호&lt;/b&gt; 의 핸들러로 my_handler ()를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">정규 신호의 처리기로 my_handler ()를 설치하고 오류 신호 중 하나를 수신하면 Perl 스택 추적을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">툴킷을 먼저 설치 한 다음 플랫폼 SDK, .NET Framework SDK를 설치하십시오. 기본 설치 위치를 선택한 것으로 가정하여 다음과 같이 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Bundle::OS2_default&lt;/code&gt; 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">첫 번째 단계에서 생성 한 번들 파일을 다음과 같이 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">Install은 파일을 NetWare Perl이 설치된 Windows 시스템으로 복사하므로이 파일은 NetWare 서버로 수동으로 복사해야합니다. 또는 통과</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용한 설치 이상</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">설치 접두사</target>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">DOS에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">Windows에서 Perl 설치</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">계획 9에 Perl 문서 설치</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">OS / 400 PASE에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">BS2000에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">동적 확장 설치</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">UNIVERSAL에 핸들러를 설치하면 ... err..universal이됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">정적 확장 설치</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">AmigaOS에 내장 된 Perl 설치</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">내장 된 perl 설치</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">확장 설치</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">대신 &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , 우리가 쓸 수 &lt;code&gt;$a[1][2]&lt;/code&gt; ; 그것은 같은 것을 의미합니다. 대신에 &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , 우리가 쓸 수 &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 그것은 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 대신 &lt;code&gt;:utf8&lt;/code&gt; 을 사용 하면 데이터가 이미 UTF8로 내부적으로 표현 된 경우 인코딩 단계를 건너 뜁니다. 이것은 쓸 때 좋은 동작으로 널리 받아 들여지지 만 읽을 때 위험한 바이트 시퀀스가있을 때 내부 불일치가 발생하기 때문에 위험 할 수 있습니다. 입력에 &lt;code&gt;:utf8&lt;/code&gt; 을 사용하면 보안 위반이 발생할 수 있으므로 대신 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 및 &lt;code&gt;encode&lt;/code&gt; 대신 &lt;code&gt;_utf8_on&lt;/code&gt; 및 &lt;code&gt;_utf8_off&lt;/code&gt; 사용할 수 있지만 이는 잘못된 스타일로 간주됩니다. 특히 &lt;code&gt;_utf8_on&lt;/code&gt; 은 &lt;code&gt;:utf8&lt;/code&gt; 과 같은 이유로 위험 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">파일 이름 대신 다른 아카이브 등 의 기존 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체에 파일 이름을 전달할 수도 있습니다. 객체는 복제되며 사실상 별칭이 아닌 원본의 사본이됩니다.</target>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">숫자 대신 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 &quot;남은 모든 것을 소비&quot;를 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dTHX&lt;/code&gt; 를 사용하여 스레드 컨텍스트를 페치 해야하는 실제 C 함수 대신 동일한 이름의 매크로를 정의하고 오버 헤드를 피할 수 있습니다. 또한 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; 에 의해 할당 된 메모리를 해제 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">대신 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">기능 번들을 이름별로로드하는 대신 Perl에서 기능 번들을 암시 적으로로드하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;$SIG{ALRM}&lt;/code&gt; 을 설정하는 대신 :</target>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">Makefile.PL에 VERSION을 지정하는 대신 MakeMaker가 파일을 구문 분석하여 버전 번호를 결정할 수 있습니다. 구문 분석 루틴에서는 VERSION_FROM으로 이름 지정된 파일에 버전 번호를 계산하기위한 단일 행이 포함되어 있어야합니다. $ VERSION 할당 또는 &lt;code&gt;package Name VERSION&lt;/code&gt; 과 같은 것을 포함하는 파일의 첫 번째 라인 이 사용됩니다. 다음 줄은 정상적으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">위의 프로세스 대신 Filter :: Simple을 사용하면 소스 코드 필터를 설정하는 작업이 다음과 같이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">쉘의 &lt;code&gt;expand&lt;/code&gt; 명령 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">쉘의 &lt;code&gt;unexpand -a&lt;/code&gt; 명령 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">이 대신에 :</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; 를 사용하는 대신 &lt;code&gt;/m&lt;/code&gt; (및 아마도 &lt;code&gt;/s&lt;/code&gt; ) 정규식 수정자를 사용해야합니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 어휘 범위 (전체 파일도 포함)에 대해 &lt;code&gt;/m&lt;/code&gt; 을 활성화 할 수 있습니다 . (이전 버전의 경우 : &lt;code&gt;$*&lt;/code&gt; 가 true 값으로 설정되면 모든 정규식은 마치 마치 &lt;code&gt;/m&lt;/code&gt; 을 합니다.)</target>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;foreach()&lt;/code&gt; 사용할 수 있습니다 루프를 . 예를 들어, 배열에서 특정 문자열이 몇 번 발생하는지 계산하는 한 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">순수 Perl을 사용하여 오버로드 된 인터페이스를 작성하는 대신 OVERLOAD 키워드를 사용하여 함수에 대한 추가 Perl 이름 (위의 ALIAS : 키워드)을 정의 할 수도 있습니다. 그러나 오버로드 된 함수는 세 개의 매개 변수로 정의되어야합니다 (네 개의 매개 변수가 필요한 nomethod () 함수 제외). 함수에 OVERLOAD : 키워드가있는 경우 xsubpp에 의해 생성 된 c 파일에 여러 추가 행이 정의되어 과부하 마법에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">다중 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 명령문 을 작성하는 대신 상수 이름 대신 키가 정의 될 상수의 이름 인 해시에 대한 참조를 제공하여 단일 명령문에서 다중 상수를 정의 할 수 있습니다. 분명히이 방법을 사용하여 정의 된 모든 상수는 단일 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8을&lt;/a&gt; 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; 또는 드물게 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">대신 거의 확실하게 &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; 또는 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">대신 &lt;code&gt;bytes_to_utf8&lt;/code&gt; 은 문자열 인수 의 UTF-8 인코딩 &lt;b&gt;사본&lt;/b&gt; 을 제공합니다. 이는 원래 SV에 영향을주지 않으면 서 데이터를 비교 등에 사용할 수 있도록하는 데 유용합니다. &lt;code&gt;utf8_to_bytes&lt;/code&gt; 도 있습니다다른 방법으로 있지만 문자열에 단일 바이트로 표현할 수없는 255 이상의 문자가 포함되어 있으면 자연스럽게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">대신 Windows에서 일반 텍스트 파일을 실행하는 데 사용 가능한 모든 방법은 &quot;확장자&quot;파일을 사용합니다. 이것을 사용하여 펄 스크립트를 실행하는 세 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">대신 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">대신 다음 솔루션이 다소 효과적입니다. 이것에 대한 좋은 점은 1) 바로 사용할 수 있습니다. 2) * / * / *. c와 같은 패턴으로 올바른 작업을 수행하기 때문에 더 강력합니다. 3) 사용 여부를 결정할 수 있습니다. 4) 방법을 확장하여 모든 사용자 정의 (또는 완전히 다른 종류의 와일드 카드 확장)를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">대신, 부울 검사에는 &lt;code&gt;blessed&lt;/code&gt; ( &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈에서), 특정 클래스 검사 에는 &lt;code&gt;isa&lt;/code&gt; , 유형 검사에는 &lt;code&gt;reftype&lt;/code&gt; ( &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; )도 사용하십시오. (자세한 내용과 &lt;code&gt;blessed/isa&lt;/code&gt; 예 는 &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">대신, 부울 검사에는 &lt;code&gt;blessed&lt;/code&gt; ( &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈에서), 특정 클래스 검사 에는 &lt;code&gt;isa&lt;/code&gt; , 유형 검사에는 &lt;code&gt;reftype&lt;/code&gt; ( &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; )도 사용하십시오. (자세한 내용과 &lt;code&gt;blessed/isa&lt;/code&gt; 예 는 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">대신 단일 백 슬래시와 함께 큰 따옴표를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">대신 IV, UV, IVSIZE, I32SIZE 등의 정의를 사용하십시오. 그것이 보장 &lt;b&gt;되지&lt;/b&gt; 않기 때문에 I32와 같은 것을 피하십시오</target>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">종속성과 함께 모듈을 설치하는 방법에 대한 지침. 여기에 포함 할 제안 정보 :</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">파일 스펙의 일부로 나타나는 콜론과 대상 구분 기호를 구분하기 위해 대상을 표시하는 콜론 앞에 공백이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">정수 산술</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">정수 이진 로그 [C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">정수 이진 로그 [C99].</target>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">정수. 선택적인 선행 더하기 또는 빼기 기호 다음에 일련의 숫자가옵니다.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">로컬 디렉토리 통합</target>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">인텔 헥스</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEX는 바이너리 데이터를 나타내는 파일 형식으로, 주로 다양한 칩을 텍스트 파일로 프로그래밍하는 데 사용됩니다. (참조 &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex을&lt;/a&gt; 자세한 설명과 &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt; 풀어 할 수있는 모토로라 S 레코드 형식에 대한) (file_format를 각 줄은 콜론 ( ':')으로 시작하고 그 뒤에 바이트 수를 지정하는 일련의 16 진수 문자가옵니다.</target>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">제거 된 버전의 패키지에 대해 임의의 스크립트를 테스트하는 방법 으로 명령 줄에서 &lt;b&gt;-M&lt;/b&gt; 옵션 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">DCL (Digital Command Language) 쉘에서 Perl과 상호 작용하려면 종종 Unix 쉘과 다른 따옴표가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">확장과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">IO :: Socket이 포함 된 대화식 클라이언트</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">대화식 모드 :</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">대화식 세션은 기본적으로 &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 으로 잠금 파일을 유지합니다 . 자물쇠 . 배치 작업은 잠금 파일없이 실행될 수 있으며 서로 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 를 사용하여 임의의 &lt;code&gt;expression&lt;/code&gt; 을 대화식으로 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">흥미롭게도 결과 파일 형식이 같더라도 보고서를 생성하는 알고리즘이 다르기 때문에 결과가 약간 다릅니다. 경과 시간, 사용자 및 시스템 시간은 &lt;code&gt;Devel::Profiler&lt;/code&gt; 가 자체 실행을 실행 하는 데 걸린 시간을 명확하게 표시 하지만 열 목록은 이전의 것보다 더 정확하게 느껴집니다. &lt;code&gt;Devel::DProf&lt;/code&gt; . 예를 들어 102 % 수치가 사라졌습니다. 여기서 우리는 도구를 마음대로 사용할 수 있고 도구를 사용하기 전에 장단점을 인식해야합니다. 흥미롭게도, 각 서브 루틴에 대한 호출 수는 두 보고서에서 동일하며 백분율이 다릅니다. &lt;code&gt;Devel::Proviler&lt;/code&gt; 의 저자는 다음과 같이 말합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">인터페이스 전략</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm과 Kwalify.pm 사이의 인터페이스</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">버클리 DB에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">EMX에서 cwd 로의 인터페이스. &lt;code&gt;Cwd::cwd&lt;/code&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib 압축 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">다른 프로그래밍 언어의 인터페이스 / 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">일부 Win32 API 함수에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm의 내부 구성 처리</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm의 내부 디버깅</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">$ dl_debug가 true로 설정되면 내부 디버깅 메시지가 활성화됩니다. 현재 $ dl_debug를 설정하면 DynaLoader의 Perl 측에만 영향을줍니다. 이 메시지는 애플리케이션 개발자가 DynaLoader 사용 문제를 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">내부 함수 Hash :: Util :: FieldHash :: _ fieldhash</target>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; 인수 유형 에 따라 필터를 추가하는 내부 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm에 대한 tar 아카이브의 내부 처리</target>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">오류 및 경고 인쇄를위한 내부 방법. 옵션이 없으면 단순히 &quot;@_&quot;를 인쇄합니다. 다음 옵션이 인식되어 출력을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time :: gmtime 및 Time :: localtime에서 사용하는 내부 객체</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm에 대한 내부 큐 지원</target>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">내부적으로 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 는 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 를 통해 실제 연결 인터페이스로 구현됩니다 . 해당 패키지의 메소드는 이러한 함수를 다시 호출합니다. 그러나이 목적 으로 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 의 사용은 다음 릴리스에서 변경 될 수 있습니다. 예를 들어, 이것은 대신 마술로 구현 될 수 있습니다 (mgvtbl의 확장이 필요함).</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">내부적으로 CPAN.pm은 UTF-8 문자 세트를 사용합니다. 터미널에 ISO-8859-1 문자 집합이 필요한 경우 구성 파일에서 term_is_latin을 true로 설정하여 변환기를 활성화 할 수 있습니다. 그렇게하는 한 가지 방법은</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">내부 인코딩-&amp;gt; 유니 코드 및 유니 코드-&amp;gt; 인코딩 맵은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">내부적으로 벤치 마크 객체는 아래 &lt;a href=&quot;#NOTES&quot;&gt;참고에&lt;/a&gt; 설명 된 타이밍 값을 보유 합니다. 다음 방법을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">내부적으로 이것은 사용자 정의 엔진이 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 지정되어 있지 않으면 &lt;code&gt;NULL&lt;/code&gt; 로 설정되며 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; 에 의해 지시 되는 구조체에서 Perl의 자체 콜백 세트에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode :: ?? :: ISO_2022_ *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">Encode :: CN에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode :: JP에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode :: JP :: 2022_JP *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode :: KR에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">내부적으로 Perl은 현재 플랫폼의 기본 8 비트 문자 세트 (예 : Latin-1)를 UTF-8로 기본 설정하여 유니 코드 문자열을 인코딩합니다. 특히 문자열의 모든 코드 포인트가 &lt;code&gt;0xFF&lt;/code&gt; 이하인 경우 Perl은 기본 8 비트 문자 세트를 사용합니다. 그렇지 않으면 UTF-8을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">내부적으로 (C 컴파일러에서 제공 한) 기본 정수 산술이 사용됩니다. 이것은 산술 연산에 대한 Perl의 고유 한 의미가 보존되지 않을 수 있음을 의미합니다. 일반적인 문제의 원인 중 하나는 음수의 계수이며 Perl은 한 가지 방법이지만 하드웨어는 다른 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">내부적으로 이것을 종종 Pod :: Simple :: Progress 클래스의 객체로 설정합니다. 해당 클래스는 문서화되지 않았지만 소스를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">내부적으로 컴퓨터는 이진수로 부동 소수점 숫자를 나타냅니다. 디지털 (2의 거듭 제곱) 컴퓨터는 모든 숫자를 정확하게 저장할 수는 없습니다. 일부 실수는 프로세스에서 정밀도를 잃습니다. 이것은 컴퓨터가 숫자를 저장하는 방법과 Perl뿐만 아니라 모든 컴퓨터 언어에 영향을 미치는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">내부 및 C 언어 인터페이스</target>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">국제화 (I18N) 및 현지화 (L10N)는 최소한 원칙적으로 EBCDIC 플랫폼에서도 지원됩니다. 세부 사항은 시스템에 따라 다르며 아래 &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS 문제&lt;/a&gt; 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">국제화 및 로캘</target>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">C 및 POSIX 표준에 정의 된 국제화는 불완전하고 부적절하며 너무 큰 입도를 갖는 것으로 비판받을 수 있습니다. (로컬은 단일 스레드, 창 그룹 등에 적용하는 것이 더 유용한 경우 전체 프로세스에 적용됩니다.) 또한 표준 그룹과 같이 세계를 국가로 나누는 경향이 있습니다. 모두는 세계가 은행가, 자전거 타는 사람, 게이머 등으로 똑같이 나눌 수 있다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">인터넷 라인 터미네이터</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">인터넷 프로토콜 또는 지적 재산권.</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">인터넷 TCP 클라이언트 및 서버</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">RFC 3066에 정의 된 인터넷 언어 태그는 인간 언어를 나타내는 형식입니다. 2 자로 된 ISO 639-1 언어 코드는 국가 코드 ( &quot;en-US&quot;)로 인증 된 형식과 마찬가지로 잘 알려져 있습니다 (영어의 경우 &quot;en&quot;). &quot;i-mingo&quot;와 같은 임의 길이의 비 ISO 코드는 잘 알려져 있지 않으며 최근 (2001 년) 3 글자 ISO-639-2 코드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">보간 된 스칼라 및 배열은 내부적으로 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 로 변환 됩니다. 담금질 작업. 따라서 &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; 는 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">배열 또는 슬라이스 보간은 &lt;code&gt;$&quot;&lt;/code&gt; 값으로 구분 된 순서대로 요소 를 보간하므로 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 보간 과 같습니다 . &lt;code&gt;@*&lt;/code&gt; 와 같은 &quot;문구&quot;배열 은 일반적으로 이름이 중괄호 &lt;code&gt;@{*}&lt;/code&gt; 묶인 경우에만 보간 되지만 배열 &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; 및 &lt;code&gt;@-&lt;/code&gt; 는 중괄호없이 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">패턴 보간에는 몇 가지 단점이 있습니다. &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; 및 &lt;code&gt;@-&lt;/code&gt; 는 보간되지 않으며 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; 구문 은 여러 다른 추정값에 의해 배열 요소 또는 &lt;code&gt;$var&lt;/code&gt; 이어 RE 대안 으로 투표됩니다 . 여기서 &lt;code&gt;${arr[$bar]}&lt;/code&gt; 표기법 이 유용합니다. &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; 는 &lt;code&gt;$arr&lt;/code&gt; 변수의 정규 표현식 이 아닌 숫자 뒤에 배열 요소 &lt;code&gt;-9&lt;/code&gt; 로 해석됩니다 . 이것은 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; 의 해석입니다. 다른 견적 자 사이에 투표가 발생할 수 있으므로 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 16 진 문자열로 해석하십시오. &quot;0x&quot;또는 &quot;x&quot;접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">결과를 엄격하게 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 이진 문자열로 해석하십시오. &quot;0b&quot;또는 &quot;b&quot;접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 8 진 문자열로 해석하고 해당 값을 리턴하십시오. &quot;0&quot;(영) 접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; 필드의 해석은 시스템마다 다르지만 일반적으로 사용자의 전체 이름, 사무실 위치, 회사 전화 번호 및 집 전화 번호를 포함하는 4 개의 쉼표로 구분 된 필드를 보유합니다. gecos 필드 의 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 사용자의 대문자로 된 로그인 &lt;code&gt;name&lt;/code&gt; 으로 대체해야합니다 . &lt;code&gt;shell&lt;/code&gt; 필드가 빈 경우로 가정해야</target>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">약간 더 높은 수준의 함수 &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; 및 &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt; 를 사용하여 버퍼의 옥텟 해석을 추상화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 16 진 문자열로 해석하고 해당 값을 리턴합니다. &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작할 수있는 문자열을 변환하려면 &lt;a href=&quot;#oct&quot;&gt;oct를&lt;/a&gt; 참조하십시오 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 16 진 문자열로 해석하고 해당 값을 리턴합니다. &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작할 수있는 문자열을 변환하려면 &lt;a href=&quot;oct&quot;&gt;oct를&lt;/a&gt; 참조하십시오 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">EXPR을 8 진 문자열로 해석하고 해당 값을 리턴합니다. (EXPR이 &lt;code&gt;0x&lt;/code&gt; 로 시작 하면 16 진 문자열로 해석됩니다. EXPR이 &lt;code&gt;0b&lt;/code&gt; 로 시작 하면 2 진 문자열로 해석됩니다. 앞의 공백은 세 경우 모두 무시됩니다. 다음은 10 진수, 2 진수, 표준 Perl 표기법의 8 진 및 16 진 :</target>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">프로세스 간 통신 (IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">프로세스 간 통신.</target>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">교차는 일반적으로 두 개 이상의 클래스와 일치하는 공통 문자를 얻는 데 사용됩니다. 첫 번째 세트에 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 를 사용하지 않는 것이 중요합니다 . 그것은 아무것도 교차하지 않고 빈 세트가됩니다.</target>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">소개</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">Perl 5.005에 도입</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">Perl 5.10.0에 도입</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">Perl 5.12에서 도입</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">Perl 5.14.0에 도입</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0에 도입</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0에 도입</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">Perl 5.6.0에서 도입</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">Perl 5.6.1에 도입</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0에서 도입</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">Perl 5.9.0에서 도입</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">Perl 5.9.2에서 도입</target>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">소개 : 5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">소개 : Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">소개 : Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">소개 : Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">소개 : Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">perl5.7.0 직후에 도입 된이 추상화는 운영 체제와 C 라이브러리가 작업을 수행하는 방식에서 IO를 분리함으로써 IO가 수행되는 방식을 perl이 더 많이 제어 할 수 있도록하는 위 추상화를 다시 구현 한 것입니다. USE_PERLIO의 경우 PerlIO *에는 추가 간접 계층이 있습니다. 포인터를 가리키는 포인터입니다. 이를 통해 PerlIO *는 알려진 값을 유지하면서 구현을 스왑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">캐치 블록을 소개합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">(읽기 전용이 아닌) 글로벌 소개</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">&lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; ( &lt;code&gt;nm&lt;/code&gt; 에 BSD 스타일 출력이있는 경우)를 사용하여 추가 한 데이터가 실제로 읽혔는지 확인하는 한 읽기 전용 (const) 전역을 소개해도됩니다. 뿐. (있는 경우 해당 명령의 출력에 표시되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">for () 안에 변수 소개</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">서론</target>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">지정된 숨김의 모든 하위 클래스에서 메소드 캐싱을 무효화하여이 클래스의 변경 사항을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">주어진 클래스에 따라 클래스의 메소드 캐시를 무효화합니다. 이것은 일반적으로 필요하지 않습니다. 순수 perl 코드가 메소드 캐시를 혼동시킬 수있는 유일한 경우는 &lt;a href=&quot;constant&quot;&gt;상수&lt;/a&gt; 내부와 같이 읽기 전용 스칼라 값을 사용하여 새 상수 서브 루틴을 수동으로 설치하는 경우 입니다. 다른 사례를 찾은 경우이를 수정하거나 예외를 여기에 기록 할 수 있도록 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">설치된 모듈의 재고 관리</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">반전 목록은 유니 코드 속성 값 정의를 지정하는 간단한 방법입니다. 목록의 0 번째 항목은 속성 값이있는 가장 낮은 코드 포인트입니다. 다음 항목 (항목 [1])은 속성 값이없는 항목을 넘어 가장 낮은 코드 포인트입니다. 그리고 그 다음에 나오는 다음 항목 ([2])은 속성 값 등이있는 것보다 가장 낮은 코드 포인트입니다. 달리 말하면 목록의 각 요소는 속성 값 (짝수 요소) 또는 속성 값 (홀수 요소)이없는 범위의 시작을 제공합니다. 이 데이터 구조의 이름은 목록의 각 요소가 해당 범위가 목록에 있는지 여부에 관계없이 토글 (또는 반전)한다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">호출하려면 명령을 실행하거나 코드 참조 및 선택적으로 해시 참조 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">마술 방법 (FETCH와 같은)을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; 가 true를 반환 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 가 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; 이 true를 반환 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">구문 분석 할 행이 더 이상 없을 때 호출됩니다. 함께 제공되는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 객체 가 없으므로 &lt;code&gt;TAP::Parser&lt;/code&gt; 객체가 대신 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">'get'매직이있는 경우 SV에서 &lt;code&gt;mg_get&lt;/code&gt; 을 호출 합니다. 예를 들어, 이것은 묶인 변수에서 &lt;code&gt;FETCH&lt;/code&gt; 를 호출 합니다. 이 매크로는 인수를 두 번 이상 평가합니다.</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">SV에 'set'매직이있는 경우 &lt;code&gt;mg_set&lt;/code&gt; 을 호출 합니다. &lt;code&gt;$|&lt;/code&gt; 와 같은 마법 변수 인 경우 스칼라를 수정 한 후에 필요합니다. 또는 묶인 변수 ( &lt;code&gt;STORE&lt;/code&gt; 호출 ). 이 매크로는 인수를 두 번 이상 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">VMS 디버거를 호출합니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">디버깅 모드를 호출합니다. 주로 해커를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">링커를 호출하여 객체 파일에서 라이브러리 파일을 생성합니다. 스칼라 컨텍스트에서 라이브러리 파일의 이름이 리턴됩니다. 목록 컨텍스트에서 라이브러리 파일 및 작성된 모든 임시 파일이 리턴됩니다. 필수 &lt;code&gt;objects&lt;/code&gt; 매개 변수에는 처리 할 오브젝트 파일의 이름이 문자열 (하나의 오브젝트 파일의 경우) 또는 목록 참조 (하나 이상의 파일의 경우)로 포함됩니다. 다음 매개 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">링커를 호출하여 객체 파일에서 실행 파일을 생성합니다. 스칼라 컨텍스트에서 실행 파일 이름이 리턴됩니다. 목록 컨텍스트에서 실행 파일 및 작성된 모든 임시 파일이 리턴됩니다. 필수 &lt;code&gt;objects&lt;/code&gt; 매개 변수에는 처리 할 오브젝트 파일의 이름이 문자열 (하나의 오브젝트 파일) 또는 목록 참조 (하나 이상의 파일)로 포함됩니다. 선택적 매개 변수는 다음 을 제외 하고 &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">클래스 메소드 호출</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">펄 호출</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">한 번의 호출로 모든 버전의 메소드 호출</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 를 통해 테스트 스크립트를 호출하는 것은 매우 중요한 일이었습니다. 확장의 일부인 다양한 파일을 찾을 수 있도록 모든 &lt;code&gt;-I&lt;/code&gt; 인수 와 함께 perl을 호출 했습니다. 그것은</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">McGillicuddy 전체를위한 아일랜드어. Perl 문화에서 &quot;sharp&quot;와 &quot;bang&quot;의 포트만 토는 &lt;code&gt;#!&lt;/code&gt; 의미합니다 ! 시스템에 인터프리터를 찾을 위치를 알려주는 순서.</target>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">이 릭스 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이 여기의 모든 코드 예제는 공개 도메인에 있습니다. 귀하는이 코드와 그 파생어를 자신의 프로그램에서 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. FAQ에 신용을 부여하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이이 파일의 모든 코드 예제는 공개 도메인에 배치됩니다. 귀하는 자신의 프로그램에서이 코드를 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. 크레딧을 제공하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이이 파일의 모든 코드 예제는 공개 도메인에 배치됩니다. 귀하는 자신의 프로그램에서이 코드를 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. 크레딧을 제공하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">펄은 배우기가 어렵습니까?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">더 잘 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">로컬 또는 어휘 데이터에 대한 참조를 반환하는 것이 안전합니까?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">같은가요? 글쎄요, 어쩌면 아닐 수도 있습니다. 미묘한 차이점은 대괄호로 무언가를 할당 할 때 항상 새로운 것이있는 새로운 참조임을 알고 있다는 것입니다</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">프로세스 식별 번호 0 또는 음수에는 지원되지 않습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">일반적인 기능입니까?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">구현이 이식성이 충분 할까?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">구현이 강력합니까?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">구현이 테스트 되었습니까?</target>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">Perl을위한 예쁜 프린터 (포맷터)가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">자동으로 디코딩하거나 인코딩하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">&quot;ps&quot;와 같은 프로그램에서 perl의 명령 행을 숨길 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">IDE 또는 Windows Perl Editor가 있습니까?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">다른 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">알아야 할 다른 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">충분한 문서가 있습니까?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">제출자 만이 언어에 추가하기를 원하는 것입니까, 아니면 광범위하게 유용한가요? 때때로, 초점을 맞추는 기능을 추가하는 대신 포터는 누군가가보다 일반적인 기능을 구현할 때까지 기다리기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">이 문서가 당신이 쫓은 문서입니까?</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">다음과 같이 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">&lt;code&gt;ualarm&lt;/code&gt; 호출을 발행합니다 . &lt;code&gt;$interval_useconds&lt;/code&gt; 선택 사항이며 지정되지 않은 경우의 결과로, 0이됩니다 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 행동 -like.</target>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;rsync&lt;/code&gt; uri로 가리키는 파일 을 여러 가지 다른 방법 으로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">템플릿을 통해 입력을 확인할 수 있습니다. 인수의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;$x&lt;/code&gt; 에서 참조를 활성화해야하는 &lt;code&gt;$$x = 5&lt;/code&gt; 와 같이 lvalue 컨텍스트에서 특수하게 작동해야하는 항목을 플래그 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">또한 설명서가 포함되어 있으므로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;IO::String&lt;/code&gt; 과 같은 실제 파일 시스템 파일과 관련되지 않은 perl 파일 핸들을 전달하는 것이 불가능했습니다 .</target>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">또한 MM 클래스를 통해 편리한 별칭을 제공합니다 (ExtUtils / 외부에서 MakeMaker 모듈을 원하지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">또한 MY 클래스를 통해 편리한 별명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">또한 모든 &lt;code&gt;HvENAME&lt;/code&gt; 유효한 이름 ( HvENAME )을 적절하게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">또한 EBCDIC에는 ASCII / Latin1 C0 컨트롤 및 DELETE 컨트롤에 거의 동일한 기능이 있습니다. (C0 컨트롤은 ASCII 코드 포인트가 0..0x1F 인 탭, ACK, BEL 등입니다.) 이러한 ASCII / EBCDIC 컨트롤 사이에 매핑이 설정됩니다. ASCII 플랫폼의 C1 컨트롤과 나머지 EBCDIC 컨트롤 사이에는 정확한 매핑이 없습니다. 수행 된 작업은 이러한 컨트롤을 대부분 임의로 임의로 다른 문자 집합의 일치하지 않는 문자에 매핑하는 것입니다. 어쨌든 오늘날 대부분은 EBCDIC에서 거의 사용되지 않으며 많은 불만없이 이름이 삭제되었습니다. 예를 들어 EO (Eight Ones) EBCDIC 컨트롤 (8 비트 1 비트 = 0xFF로 구성됨)은 C1 APC 컨트롤 (0x9F)에 ​​매핑되며 &quot;EO&quot;라는 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">실패시 &lt;code&gt;croak&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">Fast Boyer Moore 일치를 &lt;code&gt;find_byclass()&lt;/code&gt; 하는 fbm_instr () 및 프로그램에서 첫 번째 필수 regop을 사용하여 시작을 찾는 &lt;code&gt;fbm_instr()&lt;/code&gt; 와 같은 몇 가지 다른 루틴을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">또한에서 애플리케이션으로 확장 될 수 &lt;b&gt;C&lt;/b&gt; 에 &lt;b&gt;C&lt;/b&gt; 에 그 제한하면서, &lt;b&gt;R의&lt;/b&gt; 다음의 정의를 이용하여 앞에서 정의한 바와 같이 동작합니다</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">긴 복식과 복식은 같은 것이 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">리소스를 파일에 직접 저장할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">물론 객체 나 클래스에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">이미지를 작성해야하는 파일 이름과 함께 저장 될 오브젝트에 대한 참조로 &lt;code&gt;store&lt;/code&gt; 를 호출하여 정기적 인 절차 적 방식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">다음과 같이 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">perl 동적 확장을로드 할 수 있으며 fork () 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">그러나 다른 클래스의 수퍼 클래스로 사용될 수 있습니다. 이를 용이하게하기 위해 생성 된 생성자 메소드는 두 개의 인수 축복을 사용합니다. 또한 클래스가 해시 기반 인 경우 각 요소의 키 앞에 클래스 이름이 붙습니다 (참조</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">그것은의 기능을 결합</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">$ treewalker coderef를 생성하고 반환합니다.이 코드 참조는 호출, 트래버스 또는 걷을 때 주어진 인수의 optree를 STDOUT에 렌더링합니다. 이를 재사용 할 수 있으며 매번 사용되는 렌더링 스타일을 변경할 수 있습니다. 그 후 coderef는 새로운 스타일로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">보고서로 전환 할 수있는 프로필 정보 데이터베이스를 만듭니다. &lt;code&gt;nytprofhtml&lt;/code&gt; 명령은 유사한 HTML 보고서에 데이터를 회전 &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;(STABLE) : 커버&lt;/a&gt; 보고서 :</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">그것은 현재</target>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">&quot;탈출&quot;의 의미에 따라 다릅니다. URL 이스케이프는 &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 에서 처리됩니다 . 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 문자가 있는 쉘 이스케이프 는</target>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">$-[0] 및 $ + [0]에 잘못된 것을 넣는 단점이 있지만 일반적으로이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">전체 UTS # 18 그룹화, 교차, 결합 및 제거 (빼기) 구문을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">변수를 여전히 대체 할 수 있도록 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 를 보호하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">모든 C 구문을 처리하지는 않지만 에바 내부에서 정의를 분리하려고 시도하므로 변환 할 수있는 정의를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">해당 요소가 이미 있는지 여부는 중요하지 않습니다. 중간에 요소를 필요에 따라 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하여 기쁘게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">서브 루틴에서 리턴 된 모든 항목에 제어가 리턴 될 때 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">서브 루틴에서 실제로 리턴되는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">서브 루틴에서 스칼라 만 실제로 리턴되도록합니다. 물론 서브 루틴은</target>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">다음 변수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">번들링은 상당히 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">배열을 관리하기 위해 매우 간단한 클래스 만 구현합니다. &lt;code&gt;new&lt;/code&gt; 생성자 외에도 정적 및 가상의 메소드를 선언합니다. 정적 메소드 &lt;code&gt;PrintID&lt;/code&gt; 는 단순히 클래스 이름과 버전 번호를 인쇄합니다. 가상 메소드 인 &lt;code&gt;Display&lt;/code&gt; 는 배열의 단일 요소를 인쇄합니다. 다음은 그것을 사용하는 모든 Perl 예제입니다.</target>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">여기에는 TAP :: Parser Cookbook이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">리스트 컨텍스트에서 실행 중이라는 서브 루틴을 표시합니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">서브 루틴이 스칼라 컨텍스트에서 실행 중임을 표시합니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">호출 된 서브 루틴이 void 컨텍스트에서 실행 중임을 나타냅니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">응용 프로그램의 &quot;직접 실행 또는 웹을 통해 실행되는&quot;응용 프로그램이 &quot;현지화&quot;될 수 있도록하는 공통 기능입니다. 등 프로그래밍 된 모든 언어에 적용됩니다. Locale :: Maketext는 소프트웨어 현지화를위한 프레임 워크입니다. 현지화 된 응용 프로그램을 작성하는 데 필요한 텍스트 및 텍스트 처리 코드를 구성하고 액세스하기위한 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">사용자가 어떤 언어로 출력을 선호하는지 감지하는 것은 일반적인 문제입니다.</target>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1950 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1951 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1952 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">목록 컨텍스트를 제외하고이 함수를 호출하는 것은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">비 참조 $ obj를 등록하는 것은 치명적인 오류입니다. 다음 인수 중 비해시 참조는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">그것은 펄 버전에 키가 해시의 해시입니다. 각 키 해시는 다음 키를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">그렇게하는 것이 조금 더 쉽습니다</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">속성 값이있는 모든 코드 포인트의 전체 목록으로 반전 목록을 확장하는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">그것은 사용에 구문 오류입니다 &lt;code&gt;\N{NAME}&lt;/code&gt; 여기서 &lt;code&gt;NAME&lt;/code&gt; 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">여러 모듈을 한 번에로드 할 수 있거나 그 중 하나를로드 할 수없는 경우 전혀로드 할 수 없습니다. 또한 오류 점검 등을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">형식 이름은 정규식 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; -a -zA-Z0-9 _] + \ z / 와 일치하는 것이 좋습니다 . formatname 다음의 공백 뒤에 오는 모든 것은이 영역을 다룰 때 포맷터가 사용할 수있는 매개 변수입니다. 이 매개 변수는 &quot;= end&quot;단락에서 반복해서는 안됩니다. 구현자는 첫 ​​번째 매개 변수의 의미와 구문에서 &quot;= begin&quot;/ &quot;= end&quot;/ &quot;= for&quot;로 확장 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">인코딩 클래스는 &lt;code&gt;Encode::Encoding&lt;/code&gt; 에서 기본 클래스로 상속하는 것이 매우 바람직합니다 . 이를 통해 해당 클래스는 모든 인코딩 객체에 대한 추가 동작을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">또한 인터페이스가 OS / 2, NT 등의 요구를 충족하고 의사 동적 링크 ( 런타임에 &lt;code&gt;ld -A&lt;/code&gt; 사용)를 허용 할 것으로 기대됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">또한 이것이 기본 경계 정의이며 구현시 특정 목적과 로케일에 맞게 결과를 조정하기를 원할 수도 있음을 인식하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">반대로 일어날 수도 있습니다 : &lt;code&gt;prop_aliases('isc')&lt;/code&gt; 는리스트를 반환합니다 &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; 반면 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 반환 &lt;code&gt;(C, Other)&lt;/code&gt; (후자는 의미 펄 확장자 &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;속성 접근 유니 코드 : UCD를 통해 perluniprops의에서&lt;/a&gt; 목록들 사용에서 낙담하는 포함 가능한 형태를.</target>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">&quot;miniperl&quot;및 &quot;perl&quot;에 대한 Symbian 실행 파일을 생성 할 수도 있지만 Symbian에 대한 표준 명령 줄 인터페이스 (장치의 전체 키보드도 아님)가 없기 때문에 주로 데모로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; 및 &lt;code&gt;cplxe&lt;/code&gt; 의 인수로 복소수를 가질 수도 있습니다. 인수의 적절한 구성 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">대신 일치하지 않는 문자를 나열 할 수도 있습니다. 캐럿 ( &lt;code&gt;^&lt;/code&gt; )을 문자 클래스의 첫 번째 문자로 사용하면됩니다. 예를 들어, &lt;code&gt;[^a-z]&lt;/code&gt; 는 소문자 ASCII 문자가 아닌 모든 문자와 일치하므로 백만 개 이상의 유니 코드 코드 포인트가 포함됩니다. 이 클래스는 &quot;부정적&quot;또는 &quot;거꾸로&quot;있다고합니다.</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">Math :: BigFloat 만 요구할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">filename 매개 변수도 생략 할 수 있으므로 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">매개 변수 목록을 통해 직접 값을 반환 할 수도 있습니다. 실제로 전체적으로 다른 작업을하는 것이 바람직한 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">옵션이 취하는 최소 및 최대 인수 수를 지정할 수도 있습니다. &lt;code&gt;foo=s{2,4}&lt;/code&gt; 는 최소 2 개에서 최대 4 개의 인수를 취하는 옵션을 나타냅니다. &lt;code&gt;foo=s{1,}&lt;/code&gt; 는 하나 이상의 값을 나타냅니다. &lt;code&gt;foo:s{,}&lt;/code&gt; 는 0 개 이상의 옵션 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">사전 정의 된 경고 범주가 &lt;code&gt;warnings::enabled&lt;/code&gt; 기능을 사용 하여 호출 모듈에 설정되어 있는지 테스트 할 수도 있습니다 . 이 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">또한 다른 모든 Perl 연산자는 피연산자에 컨텍스트 (일반적으로 문자열 또는 숫자 컨텍스트)를 적용하여 해당 피연산자를 부과 된 컨텍스트로 자동 변환합니다. 대조적으로, 스마트 매치</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">또한 &lt;code&gt;nextStream&lt;/code&gt; 은 언제든지 호출 할 수 있다는 점에 주목할 필요가 있습니다. 다음 데이터로 건너 뛰기 전에 압축 된 데이터 스트림을 모두 사용할 때까지 기다릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">패턴 &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; 의 (? &amp;lt;NAME&amp;gt;)에 의해 정의되지 않은 이름을 참조하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">패턴 어딘가에 선언되지 않은 이름을 참조하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">시도하는 것은 오류입니다</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">모듈 이름이 제공되면 해당 이름이 파일 이름과 일치한다고 가정합니다. 'NAME'항목을 확인하기 위해 포드가 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">이 단계에서 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;/^/&lt;/code&gt; 을 자동으로 최적화 하여 &lt;code&gt;/^/m&lt;/code&gt; 을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">이 단계 에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 대체 텍스트에서 &lt;code&gt;\1&lt;/code&gt; 을 &lt;code&gt;$1&lt;/code&gt; 로 변환하여 변환 할 수 없는 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">인라인 코드는 오버 헤드가 적기 때문에 서브 루틴 또는 메소드 호출보다 빠를 것이 분명하지만,이 접근 방식은 유지 관리가 쉽지 않고 메모리 사용량이 증가한다는 단점이 있습니다. 무료 점심 식사. 목록에서 요소를 검색하는 경우 해시 구조에 데이터를 저장 한 다음 grep ()을 사용하여 전체 배열을 반복하는 것보다 키가 정의되어 있는지 확인하는 것이 더 효율적일 수 있습니다. 예. substr ()은 grep ()보다 빠르지 만 유연하지는 않으므로 액세스 할 수있는 또 다른 단점이 있습니다. 코드에는 실행하는 데 0.01 초가 걸리는 행이 포함될 수 있습니다. 1,000 번 호출하면 중간 크기의 파일을 파싱하는 프로그램에서 단일 코드 위치에서 이미 10 초 지연이 발생합니다.그 라인을 100,000 번 호출하면 전체 프로그램이 견딜 수없는 크롤링으로 느려집니다.</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">@INC (well, scriptdir) 디렉토리 만 검색되도록 &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; new- &amp;gt; find ( &quot;perlvar&quot;) 라고 말하는 것이 일반적 입니다. 이것은 &lt;code&gt;inc&lt;/code&gt; 속성이 기본적으로 true 이기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">일반적으로 시스템에 라이브러리를 동적으로로드 할 수있는 기능이 없으면 XSUB를 빌드 할 수 없습니다. 이것은 올바르지 않습니다. 당신</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">간접 연산자 &lt;code&gt;*&lt;/code&gt; 는 유형의 일부로, 주소 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 변수 의 일부로 간주되어야 한다고 생각하는 것이 편리 합니다. C 유형의 한정자 및 단항 연산자 처리에 대한 자세한 내용은 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">변수 &quot;속성&quot;과의 유사성을 강조하기 위해 콜론 (예 &lt;code&gt;:perlio&lt;/code&gt; )으로 레이어 이름을 시작하는 것이 일반적 입니다. 그러나 PERLIO 환경 변수를 디코딩하는 데 사용되는 레이어 사양 문자열을 구문 분석하는 코드는 콜론을 구분 기호로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">열심히 미래에, 형식 (및 포맷터)의 수를 증가 시키면 직접 유니 코드 문자를 지원 될 것으로 기대된다 (같은 (X) HTML과 수행 &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; ), 특이 체질의 필요성을 줄여 유니 코드 대 매핑</target>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">주석으로 보는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">서브 루틴이 프로토 타입과 서명을 모두 가질 수 있습니다. 프로토 타입은 서브 루틴에 대한 호출 컴파일에 영향을 미치며 서명은 런타임에 인수 값을 어휘 변수에 넣습니다. 그러므로 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">문자와 문자 순서에 고유 한 이름을 지정할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">명시 적으로 변경되지 않아야하는 메소드에 대한 인수는 일정 할 것으로 예상됩니다 (그러나 적용되지는 않음).</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">우리가 경험을 쌓으면서 정확히 &lt;code&gt;'strict'&lt;/code&gt; 것이 시간이 지남에 따라 진화 할 것으로 예상 됩니다. 이것은 오늘날의 Perl에서 그 아래에서 컴파일되는 프로그램이 향후 Perls에서 컴파일되지 않거나 경고가 많거나 적을 수 있음을 의미합니다. 이와 관련하여 이전 버전과의 호환성 약속은 없습니다. 또한이를 활성화하기위한 대체 구문에 대한 제안이 이미 있습니다. 이러한 이유로, 카테고리를 끄지 않으면 &lt;code&gt;experimental::re_strict&lt;/code&gt; 클래스 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">요청에 따라 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">일반적으로 비 UTF-8 로케일과 유니 코드를 혼합하는 것은 좋지 않습니다.이 문제는 그 이유 중 하나입니다. 이 경고는 일반적으로 유니 코드 규칙으로 인해이 작업의 결과에 로캘 0..255로 지정된 범위에있는 문자가 포함되어 유니 코드가 아닌 로캘의 규칙이 적용되는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">보장된다</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">보장된다</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">&lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[0-9]&lt;/code&gt; 의 하위 집합 이외의 범위와 정확히 일치하는 항목을 파지 않으면 이해하기 어렵습니다 . 올바른 원칙은 동일한 대소 문자 ([ae], [AE]) 또는 숫자 ([0-9])의 알파벳 문자로 시작하고 끝나는 범위 만 사용하는 것입니다. 안전하지 않거나 불분명 한 것 의심 스러우면 범위를 완전히 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">새로운 인터페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">그러나 백 슬래시 또는 이스케이프 시퀀스는 현재 버전이 아닌 백 슬래시 다음에 구두점 문자를 사용하지 않으며 향후 Perl 5 버전에서는 사용되지 않습니다. 따라서 단어가 아닌 문자 앞에 백 슬래시를 두는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">표준 perl TIEHASH 인터페이스를 사용하여 구현됩니다. 자세한 내용은 perlfunc (1) 및 perltie (1) 의 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">자세한 정보, 특히 opname, optag 및 opset에 대한 자세한 정의를 보려면 &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; 모듈 설명서를 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">지원되는 'make'프로그램을 사용하고 Config.pm이 알고 있어야합니다. nmake가없는 경우 이전에 언급 한 위치에서 dmake를 얻거나 다음에서 제공되는 이전 버전의 nmake를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">가능한 빨리 &lt;code&gt;make dist&lt;/code&gt; 를 만드는 것이 중요 합니다. 이렇게하면 &lt;code&gt;.h&lt;/code&gt; 파일 을 편집 하고 h2x를 다시 실행 하기로 결정한 경우 자동으로 생성 된 파일에 대한 변경 사항을 쉽게 병합 (1) 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">명령 행에 특수 문자 (예 : 따옴표 또는 백 슬래시)가 포함 된 경우 이러한 CLI가 다르게 작동 할 수 있음을 알아야합니다. 예를 들어, 유닉스 셸에서는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )와 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; )를 사용하여 단어를 그룹화 할 수 있습니다. 다음 대안은 Unix에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">변수에 스레드 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 가없는 경우에도 변수에 알릴 수 있다는 점에 유의해야합니다 . 따라서 변수 값을 확인하고 요구 사항이 충족되지 않으면 대기 상태로 돌아가는 것이 중요합니다. 예를 들어 공유 카운터가 0으로 떨어질 때까지 일시 중지하려면</target>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">이러한 유니 코드 경계를 사용할 때 이후 버전의 유니 코드 표준이 포함 된 이후 버전의 Perl이 코드를 작성할 때와 정확히 같은 방식으로 작동하지 않을 위험이 있다는 점을 인식하는 것이 중요합니다. 이 규칙은 안정적인 것으로 간주되지 않으며 표준의 나머지 부분보다 다소 변경 될 수 있습니다. 유니 코드는 마음대로 변경할 권리가 있으며 Perl은 자신의 구현을 유니 코드의 새로운 규칙으로 업데이트 할 권리가 있습니다. 과거에는 모든 이전 문자와 다른 특성을 가진 새 문자가 표준에 추가 되었기 때문에 일부 변경 사항이 있었으므로 새 문자를 처리하기 위해 새 규칙이 공식화되었습니다. 이전 버전과의 호환성 문제가 발생하지 않아야합니다.그러나 유니 코드 기술위원회는 어떤 이유로 든 변경이 보증된다고 결정했기 때문에 일부 변경으로 인해 기존 문자 처리가 변경되었습니다. 버그를 수정하거나 새로운 규칙으로 더 나은 결과를 얻을 수 있다고 생각하기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">것을 기억하는 것이 중요하다 &lt;code&gt;yield()&lt;/code&gt; , 그것은 하드웨어, OS 실제로 무슨 일 스레딩 라이브러리에 따라 CPU를 포기하는 유일한 힌트입니다. &lt;b&gt;많은 운영 체제에서 yield ()는 작동하지 않습니다. &lt;/b&gt;따라서 &lt;code&gt;yield()&lt;/code&gt; 호출 에 대한 스레드 스케줄링을 구축해서는 안된다는 점에 유의해야 합니다. 플랫폼에서는 작동하지만 다른 플랫폼에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">다음과 같은 방식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; 와 &lt;code&gt;gzreadline&lt;/code&gt; 호출을 혼용하는 것은 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">결과를 완전히 계산 한 다음 명시 적으로 반올림하거나 추가 매개 변수를 수학 함수에 다음과 같이 사용하는 것이 혼란스럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프 에서 사용하는 것이 가장 편리합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">PA-RISC 1.1 또는 2.0 플랫폼에서 PA-RISC 1.0 실행 파일을 더 이상 컴파일 할 수 없습니다. 명령 줄 플래그는 허용되지만 결과 실행 파일은 PA-RISC 1.0 시스템으로 전송 될 때 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">명령 줄 플래그가 여전히 존재하더라도 PA-RISC 1.0 공유 라이브러리를 더 이상 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;EWOULDBLOCK&lt;/code&gt; (또는 동등한) 조건 으로 인해 실패하면 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 false를 리턴 하는 오류로 간주되지 않습니다 . 이것은 여전히 &lt;code&gt;LOCK_NB&lt;/code&gt; 옵션으로 호출 될 때 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 테스트하는 일반적인 규칙을 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">&lt;code&gt;fieldhash&lt;/code&gt; 및 / 또는 &lt;code&gt;fieldhashes&lt;/code&gt; 함수 를 사용할 모든 클래스로 함수를 가져 오는 것은 바람직하지 않습니다 . 수업을 설정하는 데 한 번만 사용됩니다. 수업이 시작되면이 기능은 더 이상 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">이미 체리 피킹 한 변경 사항과 관련된 체리 피킹 펄 델타 항목에 투표를 실시 할 필요는 없습니다. 또는 메인 펌프가 필요한 변경 사항에 대한 투표권을 얻지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">이러한 기준에 맞는 모든 변경 사항을 포함 할 필요는 없으며 일반적으로 보안 문제 해결, 버그 충돌, 회귀 및 심각한 설치 문제에 중점을 두어야합니다. 펄의 설치 또는 실행에 영향을 미치지 않는 (예를 들어 문서의 철자 수정) 과도하게 많은 사소한 변경 사항을 포함하려는 유혹은 무엇인가 간과되는 전반적인 위험을 줄이기 위해 저항해야합니다. 이는 가치가 있고 사용자가 안정성에 대해 완전히 확신 할 수있는 유지 보수 릴리스를 작성하는 것입니다. (두 번째 관심사는 maint-pumpking을 태우거나 포함 할 변경 사항에 투표하는 압도적 인 다른 커미터를 피하는 것입니다 ( 아래 &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;maint 브랜치에 변경하기&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">INCLUDE_EXT를 채울 때 DynaLoader 또는 현재 확장을 언급 할 필요는 없습니다. INCLUDE_EXT가 언급되었지만 비어 있으면 DynaLoader와 현재 확장 만 빌드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">동일한 패키지에 상수와 동일한 이름을 가진 서브 루틴 또는 키워드를 가질 수 없습니다. 이것은 아마도 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">비트 필드를 압축하거나 압축을 풀 수 없으며 정수 바이트 만 가능합니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 항상 다음 바이트 경계에서 시작하여 필요에 따라 0 비트를 추가하여 다음 8의 배수로 올림합니다. 비트 필드를 원하면 &lt;a href=&quot;functions/vec&quot;&gt;vec가&lt;/a&gt; 있습니다. 또는 압축 해제 된 비트 문자열에서 split, substr 및 concatenation을 사용하여 문자열 수준에서 비트 필드 처리를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">실행 파일에 필수 접미사가있는 일부 운영 체제에서는 명령을 호출 할 때 접미사를 사용할 필요가 없으므로 &lt;code&gt;$^X&lt;/code&gt; 값을 파일의 경로 이름 으로 사용하는 것은 안전 하지 않습니다. &lt;code&gt;$^X&lt;/code&gt; 값을 경로 이름으로 변환하려면 다음 명령문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">다양한 문자를 일치시키는 것은 드문 일이 아닙니다. 운 좋게도 범위 내의 모든 문자를 나열하는 대신 하이픈 ( &lt;code&gt;-&lt;/code&gt; )을 사용할 수 있습니다 . 대괄호로 묶은 문자 클래스 안에 하이픈으로 구분 된 두 문자가 있으면 두 문자 사이의 모든 문자가 클래스에있는 것처럼 처리됩니다. 예를 들어, &lt;code&gt;[0-9]&lt;/code&gt; 는 모든 ASCII 숫자와 일치하고 &lt;code&gt;[a-m]&lt;/code&gt; 은 ASCII 알파벳의 전반에서 소문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">현재 Dave Rolsky (&amp;lt;autarch@urth.org&amp;gt;)가 Perl 코어와 별도로 유지 관리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">키 / 값 쌍 사이에 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 를 사용하는 것이 더 읽기 쉽습니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자는 주로 쉼표를위한 단지 시각적으로 독특한 동의어이지만, 법적 간단한 식별자가 될 것 bareword는 인 경우에 그 좌측에 그것은 또한 주선는 피연산자 문자열로 해석 될 수 있습니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 이중 콜론을 포함하는 복합 식별자를 인용하지 않습니다. 이렇게하면 해시를 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">클래스 자체가 공유를 지원하도록 작성되지 않은 경우 객체를 공유하는 것이 현명하지 않은 경우가 많습니다. 예를 들어, 객체의 소멸자는 각 스레드의 범위 종료마다 한 번씩 여러 번 호출 될 수 있습니다. 또 다른 위험은 위에서 언급 한 제한으로 인해 해시 기반 개체의 내용이 손실 될 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">&quot;CODE :&quot;줄에서 시작하는 줄은 들여 쓰지 않아도됩니다. 그러나 가독성을 높이기 위해 CODE를 들여 쓰는 것이 좋습니다. 한 수준과 한 단계 더 다음 줄입니다.</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">OS / 2 및 Win32에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">쉘이나 C 런타임 모두 명령 줄 인수의 와일드 카드 확장을 수행하지 않으므로 와일드 카드를 인용 할 필요가 없습니다. 또한 셸 및 C 런타임의 인용 동작은 가장 기초적입니다 (비표준 셸을 사용하는 경우 일관성이 없을 수 있음). 유일하게 (유용한) 인용 부호는 큰 따옴표 ( &quot;)입니다. 인수에서 공백과 기타 특수 문자를 보호하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">호출하는 Perl 서브 루틴이 비정상적으로 종료 될 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">완료시 문자열의 모든 인수가 처리되지 않았을 수 있습니다. &lt;code&gt;GetOptionsFromString&lt;/code&gt; 은 목록 컨텍스트에서 호출 될 때 리턴 상태와 배열 참조를 나머지 인수에 모두 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">적절한 코드로 &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; 또는 &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; 을 사용하여 스레드에 &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END 블록&lt;/a&gt; 을 추가 할 수 있습니다 . 이 &lt;code&gt;END&lt;/code&gt; 블록은 스레드의 인터프리터가 파괴 될 때 (즉, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 호출 중 또는 프로그램 종료시) 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma 를 사용하여 다른 분석법 순서를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">표준 Devel :: Peek 모듈에서 mstat () 함수를 사용하여 실행시 임의의 지점에서 이러한 통계를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">Solaris에서 스레드 버전의 perl을 빌드 할 수 있습니다. 전체 펄 스레드 구현은 여전히 ​​실험적이므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">10.30 이전의 모든 HP-UX 버전에서 스레드 Perl 버전을 컴파일 할 수 있지만 최소한 HP-UX 11.00에서 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">&lt;code&gt;$Text::Wrap::break&lt;/code&gt; 수정하여 단어를 종료하는 문자를 제어 할 수 있습니다. &lt;code&gt;'[\s:]'&lt;/code&gt; (공백 또는 콜론 앞쪽으로 나누기) 와 같은 문자열 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (공백 또는 아포스트로피 앞쪽으로 나누기) 와 같은 사전 컴파일 된 정규식으로 설정 하십시오. 기본값은 단순히 &lt;code&gt;'\s'&lt;/code&gt; . 즉, 단어는 공백으로 끝납니다. (이것은 무엇보다도 마침표 나 쉼표와 같은 후행 문장 부호가 &quot;첨부 된&quot;단어와 함께 유지됨을 의미합니다.) &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 문자를 먹지 않는 정규식으로 설정 ( 어쩌면 그냥 앞선 주장이 경고를 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">Perl에서 &quot;원형 참조&quot;를 만들면 메모리 누수가 발생할 수 있습니다. 순환 참조는 다음과 같이 두 참조가 서로 참조를 포함 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">작동중인 문자 세트를 판별 할 수 있습니다. 그러나 먼저이 작업을 수행해야한다는 것을 확신해야합니다. 문자 집합을 테스트하지 않고 다른 작업을 수행 할 필요가없는 경우 코드가 더 단순하고 이식성이 뛰어납니다. 실제로 모든 문자 세트에 대해 직선 코드를 이식하기가 쉽지 않은 상황은 거의 없습니다. 이식 가능하게 문자를 지정하는 방법 &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;은 perluniintro의 유니 코드 및 EBCDIC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">자식에서 부모 메서드를 명시 적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">고독한 대시에 대한 특별한 치료를받을 수 있습니다. 예를 들어, 이름이 비어있는 옵션 사양을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">RE 엔진에 주어진 문자열과 결과로 생성 된 유한 오토 마톤을 모두 검사 할 수 있습니다. &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;perlrun의 명령 스위치에&lt;/a&gt; 문서화 된 Perl의 &lt;b&gt;-Dr&lt;/b&gt; 명령 행 스위치 뿐만 아니라 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; pragma 의 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; 인수를 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">동일한 출력 채널에서 print ()를 write ()와 혼합 할 수 있지만 &lt;code&gt;$-&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; )를 직접 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">호출 할 &quot;다음&quot;메소드를 찾을 수없는 경우 재발견에서 예외가 발생 하도록 &lt;code&gt;NEXT&lt;/code&gt; 재발견을 더 까다로울 수 있습니다 (예 : &lt;code&gt;SUPER&lt;/code&gt; 처럼 ).</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 를 수동으로 설정할 수 있으며 이전 Perl 코드에서이를 볼 수 있습니다. 훨씬 오래된 코드는 &lt;a href=&quot;base&quot;&gt;기본&lt;/a&gt; pragma를 사용합니다 . 새 코드의 경우 &lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; pragma를 사용하여 부모 를 선언 하는 것이 좋습니다 . 이 pragma는 &lt;code&gt;@ISA&lt;/code&gt; 설정을 처리합니다 . 또한 부모 클래스를로드하고 패키지가 자체 클래스에서 상속되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출에서 마지막 4 개의 매개 변수 중 일부 또는 전부를 생략하고 기본값을 사용할 수 있습니다. DB_HASH가 가장 많이 사용되는 파일 형식이므로 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;[ $test, $alias ]&lt;/code&gt; 포함 된 배열에 대한 참조로 테스트를 제공하여 테스트 이름 대신 표시 될 별명을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">이러한 영숫자 이름을 적절한 유형에 대한 참조를 리턴하는 표현식으로 대체 할 수 있습니다. 이에 대한 설명은 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">서브 루틴에서 수정 가능한 값을 반환 할 수 있습니다. 이렇게하려면 lvalue를 반환하도록 서브 루틴을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">여러 개의 here-doc을 연속으로 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">빌드 프로세스로 작성된 EXE 및 DLL을 제거 할 수 있습니다. 결과 바이너리는 훨씬 작습니다. 바이너리를 제거하려면 Configure (구성) 메시지가 표시 될 때 &lt;b&gt;-s&lt;/b&gt; 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">테스트에 인수를 제공 할 수 있습니다. 이를 위해서는 arisdottle '::'을 사용하여 prove 자체의 주장과 분리하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">C / XS 및 Perl 모두에서 위의 내장 레이어 외에 사용자 정의 레이어를 작성할 수 있습니다. 이러한 두 계층 (및 후자를 사용하여 Perl로 작성된 하나의 예)에는 Perl 분포가 있습니다.</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">다음과 같이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(?{})&lt;/code&gt; 또는 &lt;code&gt;(??{})&lt;/code&gt; 와 결합 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">향후 Perl 릴리스에서이 동작을 변경하여 유니 코드 규칙이 적용되는지 여부에 따라 동작이 변경되지 않도록하는 것이 좋습니다. 로케일 외부에서 POSIX 클래스는 ASCII 범위의 클래스처럼 작동합니다. 이 제안에 대해 의견이 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 로 이메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">이 사용법에서는 패턴의 끝에 DEFINE 블록을 배치하고 그 안에 정의 된 하위 패턴의 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">비표준 Zip 파일을 실제로 만들어야하는 경우가 아니면이 옵션을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">다음 아카이브에는 perl을 빌드하기에 충분한 유틸리티가 포함되어 있다고보고됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">소문자 이름은 Opcode 모듈에서 사용하도록 예약되어 있으므로 Opcode를 사용하는 응용 프로그램은 태그 이름에 선행 대문자를 사용해야합니다. 모듈 내에서 Opcode를 사용하는 경우 고유성을 보장하기 위해 태그 이름 앞에 모듈 이름을 붙여 다른 모듈과의 충돌을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">스크립트에서 가능한 빨리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 를 통해 스레드를 활성화하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">Configure를 실행할 때이 플래그를 사용하는 것이 좋습니다. 이렇게하지 않으면 나중에 Configure에서 요청할 때 큰 파일에 대한 질문에 대답하면 컴파일 할 수 없거나 예상대로 작동하지 않는 구성이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">Perl과 함께 배포되는 malloc 버전을 사용하는 것이 좋습니다. 할당 요청을보다 빨리 충족시키기 위해 다양한 크기의 할당되지 않은 메모리 풀을 유지합니다. 그러나 일부 플랫폼에서는 가짜 malloc 또는 무료 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">padname 배열에서 어휘 변수의 이름을 가져와야하는 경우 사용하는 적절한 방법입니다. 어휘 변수 이름은 항상 널 종료 자로 저장되며 길이 필드 (CUR)는 다른 목적으로 오버로드되므로 여기에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">따라서 이러한 매크로는 정적 데이터를 사용하는 모든 XS 모듈에서 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">일반적으로 나중에 있도록 펄의 검색 경로에 추가 디렉토리를 추가하는 데 사용됩니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 펄의 기본 검색 경로에 위치하지 않는 모듈을 찾을 수 문을.</target>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">렌더링 할 수없는 문자 (파서가 렌더링 할 수 있거나없는 것으로 해석 할 수없는 알 수없는 E &amp;lt;thing&amp;gt; 시퀀스와는 다른)에 직면 할 때 올바른 판단을 표시하는 것은 개별 포드 포맷터에 달려 있습니다. 분음 부호가있는 라틴 문자 (예 : &quot;E &amp;lt;eacute&amp;gt;&quot;/ &quot;E &amp;lt;233&amp;gt;&quot;)를 해당하는 액센트가없는 US-ASCII 문자 (단순 문자 101, &quot;e&quot;)에 매핑하는 것이 좋습니다. 종종 실현 불가능하고, 렌더링 불가능한 문자는 &quot;?&quot;등으로 표현 될 수있다. 정상적인 폴백을 시도 할 때 (E &amp;lt;233&amp;gt;에서 &quot;e&quot;로) 포드 포맷터는 사용 가능한 경우 &lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode&lt;/a&gt; 의 % Latin1Code_to_fallback 테이블을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">이 정보를 사용하여 채우는 것은 귀하의 책임입니다</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">일반적으로 @_을 통하지 않고 전역 변수 (일반적으로 하나의 매개 변수의 경우 $ _, 두 개의 매개 변수의 경우 $ a 및 $ b)를 사용하여 매개 변수를 전달하는 것이 일반적입니다. (지원되는 API가 없지만 수행중인 작업을 알고 있으면 @_ 메커니즘을 사용할 수 있습니다. 또한 본질적으로 느립니다.)</target>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보통의 인터에 실수 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 때문에, 통화 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 내부적으로 시스템에 구현 될 수있다 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보통의 인터에 실수 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 때문에, 통화 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 내부적으로 시스템에 구현 될 수있다 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">기존의 일부 프로그램을 중단하지 않고 Perl에 새로운 구문을 추가하는 것은 일반적으로 불가능합니다. 이 pragma는 해당 위험을 최소화하는 방법을 제공합니다. 새로운 문법 구조, 또는 그 이상 구조에 새로운 의미 론적 의미에 의해 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; ,와 해당 기능 프라그가 범위에있는 경우에만 구문 분석됩니다. 그럼에도 불구하고 &lt;code&gt;CORE::&lt;/code&gt; 접두사는이 pragma에 관계없이 모든 Perl 키워드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">소스를 필터링 할 때 코드의 비 문자열 부분에만 필터를 적용하거나 다른 방법으로 필터를 적용하려는 경우가 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">이 형식의 open ()을 사용하거나 실제로 여러 하위 프로세스와 함께 pipe ()를 사용하면 프로세스를 교착 상태로 만드는 것이 매우 쉽습니다. 위의 예는 간단하고 exec ()를 호출하기 때문에 &quot;안전&quot;합니다. 일반적인 안전 원리는 &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;파이프 교착 상태 방지를&lt;/a&gt; 참조하십시오 . 그러나 안전한 파이프 개방에는 추가 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">사례 보존을 처리 할 수있는 다양한 상태의 다른 프로그램, 외부 유틸리티 및 Perl 스크립트를 혼합하여 사용하는 것은 매우 쉽습니다. 예를 들어, 이전 버전의 아카이브 유틸리티 또는 MMK 또는 MMS와 같은 빌드 유틸리티로 작성된 파일은 ODS-5 볼륨에서도 모두 대문자로 파일 이름을 생성 할 수 있습니다. 이 파일 이름이 나중에 케이스 보존 환경에서 Perl 스크립트 또는 모듈에 의해 검색되는 경우, 해당 대문자 이름은 Perl 코드의 대소 문자 예상과 일치하지 않을 수 있습니다. 최선의 방법은 사례 보존을 위해 전혀 또는 전혀 접근하지 않는 것입니다. 전혀 사용하지 않거나 전체 툴체인 및 응용 프로그램 환경이 지원하고 사용하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">Perl 프로그램의 소스를 복구하는 것은 매우 쉽습니다. 프로그램을 펄 인터프리터에 공급하고 B :: 계층의 모듈을 사용하면됩니다. B :: Deparse 모듈은 소스를 숨기려는 대부분의 시도를 물리 칠 수 있어야합니다. 다시, 이것은 Perl에 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 문서가 일반 독자에게는 유용하지 않을 가능성이 매우 높습니다. 독자는 &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; 의 처음 몇 섹션의 내용을 이해해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 값의 예상 범위에 특히주의를 기울일 가치가 있습니다. 월의 값은 실제 날짜 (예 : 1..31)이고 월은 1 월 (0..11) 이후의 월 수입니다. 이것은 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 에서 반환 된 값과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 등은 완전한 숫자 나 단어가 아닌 단일 문자와 일치 한다는 점을 강조 할 가치가 있습니다. 숫자로 구성된 숫자와 일치 시키려면 &lt;code&gt;\d+&lt;/code&gt; . 단어를 일치 시키려면 &lt;code&gt;\w+&lt;/code&gt; . 그러나 위에서 언급했듯이 보안 고려 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;code&gt;\G&lt;/code&gt; 잘못 무한 루프가 발생할 수 있습니다 사용. 교체에 &lt;code&gt;\G&lt;/code&gt; 가 포함 된 패턴을 사용할 때는주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">유니 코드에는 0-9와 같 으며 정규식에서 &lt;code&gt;\d&lt;/code&gt; 와 일치하는 여러 가지 다른 숫자 세트가 있음을 강조 할 가치가 있습니다 . 단일 언어로만 사용되는 경우 해당 언어의 &lt;code&gt;Script&lt;/code&gt; 및 &lt;code&gt;Script_Extension&lt;/code&gt; 에 있습니다. 둘 이상의 스크립트에서 사용되는 경우 &lt;code&gt;sc=Common&lt;/code&gt; 에 있지만 많은 스크립트에서 사용되는 경우에만 &lt;code&gt;scx=Common&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">결국 추측 일뿐입니다. 인코딩과 관련하여 항상 명시 적이어야합니다. 그러나 추측 코딩이 필수 인 일부 일본어 환경이 있습니다. 이 모듈은주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">그러나 매우 간단하고 순수한 Perl이며 핵심이 아닌 종속성이 없습니다. 또한 지원되는 기능에 대한 요청시 &quot;무스&quot;API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">백 슬래시 연산자를 사용하여 IO 핸들 (filehandle 또는 dirhandle)에 대한 실제 참조를 작성할 수 없습니다. 가장 많이 얻을 수있는 것은 실제로 완전한 기호 테이블 항목 인 typeglob에 대한 참조입니다. 그러나 아래 &lt;code&gt;*foo{THING}&lt;/code&gt; 구문에 대한 설명을 참조하십시오 . 그러나 유형 glob 및 globrefs는 마치 IO 핸들 인 것처럼 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">그것은에 의해 수 있습니다 &lt;code&gt;$(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">다음을 포함하는 C : \ Program Files \ Microsoft Visual C ++ Toolkit 2003 \ bin에 lib.bat라는 배치 파일을 만드는 것이 유용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">또한 철자가 틀린 것으로 해석 된 철자가 틀린 상수를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">숫자를 검색하는 함수 나 메소드를 추가하는 것이 편리 할 수 ​​있습니다. 모듈 (ModuleName-1.02.tar.Z)을 릴리스 할 때 공지 사항 및 아카이브 파일 이름의 번호를 사용하십시오. 자세한 내용은 perldoc ExtUtils :: MakeMaker.pm을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">스크립트 I / O가 디버거 I / O와 분리되도록 항상 분기 된 디버거를 사용하는 것이 도움이 될 수 있습니다. 프로세스 식별 번호가 아닌 논리 이름 &amp;lt;PERLDB_PIDS&amp;gt;에 값을 지정하여 디버거를 강제로 포크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을 대신 사용하는 것이 더 이식 가능할 수 있습니다 . 새 파일에 새 이름으로 복사하고 (반환 값 확인) 이전 파일을 삭제하면됩니다. 권한, 타임 스탬프, inode 정보 등과 같은 메타 정보를 보존 하는 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 과 실제로 의미 적으로 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">간단한 해결 방법을 코딩하는 것이 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt; 에서 제공되는 Entropy Gathering Daemon (Perl!로 작성)을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">분명히 말할 수 있지만 Perl은 사용자가 쉽게 찾을 수있는 경우에만 유용합니다. 가능하면 두 가지 모두에 좋습니다</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">아마도 chdir () 할 수없는 디렉토리에서 chdir () 할 수 있습니다. fastcwd에 문제가 발생하면 undef를 반환하지만 다른 디렉토리에 남겨 둘 것입니다. 모든 것이 나타납니다이 근무하는 경우 추가 보안의 측정, 들어, fastcwd () 함수는 그것에서 시작하는 것과 같은 디렉토리에 당신을 떠난다 확인합니다.이 변경된 경우는 것입니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 메시지 &quot;불안정 디렉토리 경로, 전류 디렉토리가 예기치 않게 변경되었습니다. &quot; 그런 일은 절대 일어나지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">DynaLoader 자체는 Perl-to-C '접착제'를 거의 제공하지 않기 때문에 비 Perl 라이브러리에 액세스하는 데 실제로는 쓸모가 없다는 점을 강조해야합니다. 예를 들어, C 라이브러리 함수를 호출하거나 인수를 제공하는 메커니즘이 없습니다. AC :: DynaLib 모듈은 일부 일반적인 시스템 유형에 대해 해당 기능을 수행하는 CPAN 사이트에서 사용할 수 있습니다. 또한 2000 년 이후로 C에서 Perl 서브 루틴을 작성할 수있는 모듈 인 Inline :: C도 있습니다. 또한 현지 CPAN 사이트에서도 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">특히, 할당 된 모든 루틴에서 $ _ 를 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 것이 중요 합니다. 에서 암시 적 과제를 찾아보십시오 &lt;code&gt;while&lt;/code&gt; 조건문.</target>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">인쇄합니다 (줄 바꿈이 많지 않음)</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">print가 목록 컨텍스트에서 &lt;code&gt;bdiv()&lt;/code&gt; 를 호출하기 때문에 몫과 나머지를 모두 인쇄합니다 . 또한 &lt;code&gt;bdiv()&lt;/code&gt; 는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">인쇄가 목록 컨텍스트에서 작동하므로 몫과 나머지를 모두 인쇄합니다. 또한 bdiv ()는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">print가 목록 컨텍스트에서 &lt;code&gt;brsft()&lt;/code&gt; 를 호출하기 때문에 몫과 나머지를 모두 인쇄합니다 . 또한 &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; 는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">print가리 스트 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 를 호출하기 때문에 숫자와 분수 부분의 자릿수를 모두 인쇄합니다 . 다음과 같은 것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">각 서브 루틴 호출의 순서 번호와 호출 된 서브 루틴의 이름을 인쇄합니다. 참고 것을 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 패키지로 컴파일되는 &lt;code&gt;DB&lt;/code&gt; 의 사용을 통해 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 지시어.</target>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">이 정보를 쿼리하기위한 여러 가지 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">메소드에 대한 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">거의 발생하지 않지만 때로는 하네스에서 '결측 테스트가 누락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">파생 속성 Comp_Ex (Full_Composition_Exclusion)의 부울을 반환합니다. 이 특성은 컴포지션 제외 + 싱글 톤 + 비스타 터 분해에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">파생 속성 NFC_MAYBE의 부울 (NFC_Quick_Check = Maybe)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFC_NO (NFC_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFD_NO (NFD_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">파생 속성 NFKC_MAYBE (NFKC_Quick_Check = Maybe)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFKC_NO (NFKC_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFKD_NO (NFKD_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">지정된 코드 포인트의 문자가 특정 컴포지션 (한글 컴포지션 포함, 컴포지션 제외 및 비스타 터 분해 제외)에서 이전 코드로 구성 될 수 있는지 여부를 부울 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">코드 포인트에 비스타 터 분해가 있는지 여부를 부울 값으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">코드 포인트가 컴포지션 제외인지 여부를 부울 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">코드 포인트가 싱글 톤인지 여부를 부울 값으로 반환</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공 하면 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 객체를 반환하고 실패하면 undef를 반환합니다 . &lt;code&gt;$Bzip2Error&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$DeflateError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공 하면 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 객체를 반환하고 실패하면 undef를 반환합니다 . &lt;code&gt;$GzipError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$RawDeflateError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$ZipError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH 및 선택적으로 실제 라이브러리의 파일 이름 배열에 대한 참조 인 4 개 또는 5 개의 스칼라 값 배열을 리턴합니다. 이 중 일부는 유닉스를 제외하고는 아무 의미가 없습니다. 아래의 플랫폼 별 세부 사항을 참조하십시오. 파일 이름 목록은 $ need_names 인수가 true 인 경우에만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">&lt;code&gt;PACKAGE&lt;/code&gt; 가 아직로드되지 않았고 성공적으로로드되었다고하는 위치 가 있으면 Fall 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">FCC 형식을 반환합니다 ( &quot;Fast C Contiguous&quot;; cf. UTN # 5).</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">정규화 형식 C (정식 분해와 정식 구성으로 구성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">정규화 형식 D (정식 분해에 의해 형성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">정규화 형식 KC (호환성 분해와 &lt;b&gt;정식&lt;/b&gt; 구성으로 구성)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">정규화 형식 KD (호환성 분해에 의해 형성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">문자의 결합 클래스 (정수)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">문자열에서 각 문자의 분해 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">정규화 양식 &lt;code&gt;$form_name&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">나머지 &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; 입니다. &lt;code&gt;$r&lt;/code&gt; 동일 투표 &lt;code&gt;$x&lt;/code&gt; 이하의 크기보다와 절대치를 &lt;code&gt;$y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">분해를 적용하지 않고 정식 구성 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">정식 정렬 동작에 따라 결합 문자를 재정렬 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; 이면 true ( &lt;code&gt;1&lt;/code&gt; )를 리턴합니다 . &lt;code&gt;NO&lt;/code&gt; 이면 false ( &lt;code&gt;empty string&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; 이면 true ( &lt;code&gt;1&lt;/code&gt; )를 리턴합니다 . &lt;code&gt;NO&lt;/code&gt; 인 경우 거짓 ( &lt;code&gt;empty string&lt;/code&gt; ) ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;MAYBE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">모든 것이 정상이면 true를 반환합니다. 그렇지 않으면 DIAGNOSTICS 섹션의 메시지 중 하나와 함께 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 가됩니다.</target>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">키가 기준과 일치하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
