<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="6cbf1adc0d75868cfd46589662e75f0f79ed5cbb" translate="yes" xml:space="preserve">
          <source>The Bindings area, displaying all variables bindings. If you click a variable name, the value is displayed in the Evaluator area. Double-click a variable name to open a window where the variable value can be edited. Notice however that pid, port, reference, or fun values cannot be edited unless they can be represented in the running system.</source>
          <target state="translated">모든 변수 바인딩을 표시하는 바인딩 영역. 변수 이름을 클릭하면 값이 평가자 영역에 표시됩니다. 변수 이름을 두 번 클릭하여 변수 값을 편집 할 수있는 창을 엽니 다. 그러나 pid, port, reference 또는 fun 값은 실행중인 시스템에 표시 될 수 없으면 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b6c3c38656309049129434a8a3888567bd5d33d" translate="yes" xml:space="preserve">
          <source>The Button area, with buttons for quick access to frequently used functions in the &lt;strong&gt;Process&lt;/strong&gt; menu.</source>
          <target state="translated">&lt;strong&gt;프로세스&lt;/strong&gt; 메뉴 에서 자주 사용하는 기능에 빠르게 액세스 할 수있는 버튼이있는 버튼 영역 .</target>
        </trans-unit>
        <trans-unit id="ada22f32dd020105bdc39ab625188b5d539d360a" translate="yes" xml:space="preserve">
          <source>The C driver is a module that is compiled and linked into a shared library. It uses a driver structure and includes the header file &lt;code&gt;erl_driver.h&lt;/code&gt;.</source>
          <target state="translated">C 드라이버는 컴파일되어 공유 라이브러리에 연결된 모듈입니다. 드라이버 구조를 사용하며 헤더 파일 &lt;code&gt;erl_driver.h&lt;/code&gt; 를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="2a7c12f419c3e677f26c1d74131f78103f5ccbf9" translate="yes" xml:space="preserve">
          <source>The C node can act as a server or a client when setting up the Erlang-C communication. If it acts as a client, it connects to an Erlang node by calling &lt;code&gt;erl_connect()&lt;/code&gt;, which returns an open file descriptor at success:</source>
          <target state="translated">C 노드는 Erlang-C 통신을 설정할 때 서버 또는 클라이언트 역할을 할 수 있습니다. 클라이언트 역할을하는 경우 &lt;code&gt;erl_connect()&lt;/code&gt; 를 호출하여 Erlang 노드에 연결합니다. 그러면 성공시 열린 파일 디스크립터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f778bcd020988cc52d7d8911bac363507b5bc1fe" translate="yes" xml:space="preserve">
          <source>The C node can receive a message from Erlang by calling &lt;code&gt;erl_receive msg()&lt;/code&gt;. This function reads data from the open file descriptor &lt;code&gt;fd&lt;/code&gt; into a buffer and puts the result in an &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt;. &lt;code&gt;ErlMessage&lt;/code&gt; has a field &lt;code&gt;type&lt;/code&gt; defining what kind of data is received. In this case, the type of interest is &lt;code&gt;ERL_REG_SEND&lt;/code&gt; which indicates that Erlang sent a message to a registered process at the C node. The actual message, an &lt;code&gt;ETERM&lt;/code&gt;, is in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">C 노드는 &lt;code&gt;erl_receive msg()&lt;/code&gt; 호출하여 Erlang으로부터 메시지를 수신 할 수 있습니다 . 이 함수는 열린 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt; 에서 데이터를 버퍼로 읽어 결과를 &lt;code&gt;ErlMessage&lt;/code&gt; 구조체 &lt;code&gt;emsg&lt;/code&gt; 에 넣습니다 . &lt;code&gt;ErlMessage&lt;/code&gt; 에는 수신되는 데이터 종류를 정의 하는 필드 &lt;code&gt;type&lt;/code&gt; 이 있습니다. 이 경우 관심 유형은 &lt;code&gt;ERL_REG_SEND&lt;/code&gt; 이며 Erlang은 C 노드에서 등록 된 프로세스로 Erlang이 메시지를 보냈 음 을 나타냅니다. 실제 메시지 &lt;code&gt;ETERM&lt;/code&gt; 은 &lt;code&gt;msg&lt;/code&gt; 필드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cfee0b8169b38821cf004612b6024fa4504a22" translate="yes" xml:space="preserve">
          <source>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</source>
          <target state="translated">연결에 지정된 CA 인증서는 CRL을 확인하는 인증서 체인을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b711437028a29fd162a39304f7e85e3b67e2c19" translate="yes" xml:space="preserve">
          <source>The CGI script response comprises a message header and a message body, separated by a blank line. The message header contains one or more header fields. The body can be empty.</source>
          <target state="translated">CGI 스크립트 응답은 공백으로 구분 된 메시지 헤더와 메시지 본문으로 구성됩니다. 메시지 헤더에는 하나 이상의 헤더 필드가 있습니다. 몸이 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3c9d660d39101e158d800c72dc5b3c5f71e86f" translate="yes" xml:space="preserve">
          <source>The CNT column shows the total number of function calls that was found in the trace. In the ACC column is the total time of the trace from first timestamp to last. And in the OWN column is the sum of the execution time in functions found in the trace, not including called functions. In this case it is very close to the ACC time since the emulator had practically nothing else to do than to execute our test program.</source>
          <target state="translated">CNT 열에는 추적에서 찾은 총 함수 호출 수가 표시됩니다. ACC 열에서 첫 번째 타임 스탬프에서 마지막까지의 총 추적 시간입니다. 그리고 OWN 열에는 호출 된 함수를 포함하지 않고 추적에서 찾은 함수의 실행 시간 합계가 표시됩니다. 이 경우 에뮬레이터가 테스트 프로그램을 실행하는 것 외에는 할 일이 거의 없기 때문에 ACC 시간에 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="0bca2724268527bcfe47363d53f453d381e52758" translate="yes" xml:space="preserve">
          <source>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</source>
          <target state="translated">CPU 토폴로지는 스케줄러를 논리 프로세서에 바인딩 할 때 사용됩니다. CPU 토폴로지가 변경 될 때 스케줄러가 이미 바인드 된 경우, 스케줄러는 새 CPU 토폴로지에 따라 리 바인드 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3e338f2c345acced3a85f3002b3cdda7b33768c1" translate="yes" xml:space="preserve">
          <source>The CPU utilization is defined as the sum of the percentage shares of the CPU cycles spent in all busy processor states (see &lt;code&gt;util/1&lt;/code&gt; below) in average on all CPUs.</source>
          <target state="translated">CPU 사용률은 모든 CPU에서 평균적으로 모든 사용 중인 프로세서 상태 (아래 &lt;code&gt;util/1&lt;/code&gt; 참조)에서 소비 된 CPU주기의 백분율 공유의 합계로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa86529ffc420dbda732a44a0aa8bd483c1ae653" translate="yes" xml:space="preserve">
          <source>The CRL entry extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL 항목 확장자 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270f1611da531780d2eaa5897949ee887332e027" translate="yes" xml:space="preserve">
          <source>The CRL extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL 확장 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9b7329cef621756a648262a641008c28933737d" translate="yes" xml:space="preserve">
          <source>The CRLs will be fetched from a local or external cache. See &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt;.</source>
          <target state="translated">CRL은 로컬 또는 외부 캐시에서 가져옵니다. &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3d829d39e1e62045ec8647a09fccc7a51c77978" translate="yes" xml:space="preserve">
          <source>The CT hook functions can call any logging function in the &lt;code&gt;ct&lt;/code&gt; interface to print information to the log files, or to add comments in the suite overview page.</source>
          <target state="translated">CT 후크 기능은 &lt;code&gt;ct&lt;/code&gt; 인터페이스 에서 로깅 기능을 호출 하여 정보를 로그 파일에 인쇄하거나 제품군 개요 페이지에 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec67be87ba83be4a6a36f46cae0a249d6c031c6" translate="yes" xml:space="preserve">
          <source>The Call Graph is  represented by Erlang terms (the sets are lists), which is suitable for many analyses. But for analyses that look at chains of calls, a list representation is much too slow. Instead the representation offered by the &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; module is used. The translation of the list representation of the Call Graph - or a subgraph thereof - to the &lt;code&gt;digraph&lt;/code&gt; representation does not come for free, so the language used for expressing queries to be described below has a special operator for this task and a possibility to save the &lt;code&gt;digraph&lt;/code&gt; representation for subsequent analyses.</source>
          <target state="translated">콜 그래프는 많은 분석에 적합한 Erlang 용어 (세트가 목록 임)로 표시됩니다. 그러나 호출 체인을 분석하는 분석의 경우 목록 표현이 너무 느립니다. 대신 &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; 모듈에서 제공하는 표현 이 사용됩니다. 또는 그 서브 그래프 - - 통화 그래프의 목록 표현의 번역을받는 &lt;code&gt;digraph&lt;/code&gt; 쿼리를 표현에 사용되는 언어는 아래에 설명이 작업을위한 특별한 연산자와 저장 할 수있는 가능성이 될 수 있도록 표현은, 무료로 제공되지 않습니다 후속 분석을위한 &lt;code&gt;digraph&lt;/code&gt; 표현.</target>
        </trans-unit>
        <trans-unit id="bce56cac593ab0a42cef53b33869a05dc52b528e" translate="yes" xml:space="preserve">
          <source>The Code area, displaying the code being executed. The code is indented and each line is prefixed with its line number. If the process execution is stopped, the current line is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. An existing break point at a line is marked with a stop symbol. In the example shown in the illustration, the execution stopped at line 6, before the execution of &lt;code&gt;fac/1&lt;/code&gt;.</source>
          <target state="translated">실행중인 코드를 표시하는 코드 영역 코드가 들여 쓰기되고 각 줄 앞에 줄 번호가 붙습니다. 프로세스 실행이 중지되면 현재 행은 &lt;code&gt;--&amp;gt;&lt;/code&gt; 로 표시됩니다 . 줄의 기존 중단 점에는 정지 기호가 표시됩니다. 그림에 표시된 예에서 &lt;code&gt;fac/1&lt;/code&gt; 실행 전에 6 행에서 실행이 중지되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4163ad4ae86ebef487e34acf3cb3b300872a11" translate="yes" xml:space="preserve">
          <source>The Common Message and Relay applications are the only applications that diameter itself has any specific knowledge of. The Common Message application is used for messages that diameter itself handles: CER/CEA, DWR/DWA and DPR/DPA. The Relay application is given special treatment with regard to encode/decode since the messages and AVPs it handles are not specifically defined.</source>
          <target state="translated">Common Message and Relay 응용 프로그램은 그 자체로 특정 지식을 가진 유일한 응용 프로그램입니다. 공통 메시지 응용 프로그램은 CER / CEA, DWR / DWA 및 DPR / DPA와 같이 자체적으로 처리되는 메시지에 사용됩니다. 메시지와 처리하는 AVP가 구체적으로 정의되어 있지 않기 때문에 릴레이 응용 프로그램에는 인코딩 / 디코딩과 관련하여 특별한 처리가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="314dbe1e2d1cb12d891485b91d81bb94162ddaf9" translate="yes" xml:space="preserve">
          <source>The Compliance column notes &lt;strong&gt;C&lt;/strong&gt; (Compliant) if the required functionality is implemented, &lt;strong&gt;PC&lt;/strong&gt; (Partially Compliant) if there are limitations, &lt;strong&gt;NC&lt;/strong&gt; (Not Compliant) if functionality is not implemented, or a dash if text is informational or only places requirements that must be met by the user's implementation.</source>
          <target state="translated">필수 기능이 구현 된 경우 규정 준수 열에 &lt;strong&gt;C&lt;/strong&gt; (규정 준수), 제한이있는 경우 &lt;strong&gt;PC&lt;/strong&gt; (부분적 준수), 기능이 구현되지 않은 경우 &lt;strong&gt;NC&lt;/strong&gt; (비준수) 또는 텍스트가 정보를 제공하거나 요구 사항 만 충족해야하는 경우 대시 사용자의 구현에 의해 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5797134c742f2284426627bbcaee9db9ff4f9b" translate="yes" xml:space="preserve">
          <source>The ControlPid may be the identity of a process residing on another Erlang node. This is useful when you want to distribute a user over several Erlang nodes. In such a case one of the nodes has the physical connection. When a user residing on one of the other nodes needs to send a request (with megaco:call/3 or megaco:cast/3), the message will encoded on the originating Erlang node, and then be forwarded to the node with the physical connection. When the reply arrives, it will be forwarded back to the originator. The distributed connection may explicitly be deactivated by a local call to megaco:disconnect/2 or implicitly when the physical connection is deactivated (with megaco:disconnect/2, killing the controlling process, halting the other node, ...).</source>
          <target state="translated">ControlPid는 다른 Erlang 노드에 상주하는 프로세스의 ID 일 수 있습니다. 이것은 여러 Erlang 노드에 사용자를 분배하려는 경우에 유용합니다. 이러한 경우 노드 중 하나가 물리적으로 연결되어 있습니다. 다른 노드 중 하나에 상주하는 사용자가 megaco : call / 3 또는 megaco : cast / 3로 요청을 보내야하는 경우, 메시지는 발신 Erlang 노드에서 인코딩 된 후 물리적 노드로 전달됩니다. 연결. 회신이 도착하면 발신자에게 다시 전달됩니다. 분산 연결은 megaco : disconnect / 2에 대한 로컬 호출에 의해 명시 적으로 비활성화되거나 물리적 연결이 비활성화 될 때 내재적으로 (megaco : disconnect / 2를 사용하여 제어 프로세스를 종료하고 다른 노드를 중지시키는 등) 내재적으로 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78df27997f59e3cf7a226f97555796fd4db3b167" translate="yes" xml:space="preserve">
          <source>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Crashdump Viewer는 Erlang 크래시 덤프를 찾아보기위한 WxWidgets 기반 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e25b4f2128c61d45f1244bb1e42a65e6c254444f" translate="yes" xml:space="preserve">
          <source>The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.</source>
          <target state="translated">Cs (Surrogate) 속성은 U + D800에서 U + DFFF 범위의 문자에만 적용됩니다. 이러한 문자는 유니 코드 문자열에서 유효하지 않으므로 PCRE에서 테스트 할 수 없습니다. Perl은 Cs 속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8b1e5940b411ae8301615a457804bfb0094984" translate="yes" xml:space="preserve">
          <source>The DER encoder omits the encoding for the same &lt;code&gt;BIT STRING&lt;/code&gt;:</source>
          <target state="translated">DER 인코더는 동일한 &lt;code&gt;BIT STRING&lt;/code&gt; 에 대한 인코딩을 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="9e781b3302f49ad7b6f93f77b8bb63523e6ee75c" translate="yes" xml:space="preserve">
          <source>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option &lt;code&gt;dhfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 Diffie-Hellman 매개 변수. 지정된 경우 &lt;code&gt;dhfile&lt;/code&gt; 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="b9e05b3ca4b742f1e879494bc5c683f33ec025ce" translate="yes" xml:space="preserve">
          <source>The DER-encoded trusted certificates. If this option is supplied it overrides option &lt;code&gt;cacertfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 신뢰할 수있는 인증서입니다. 이 옵션이 제공되면 &lt;code&gt;cacertfile&lt;/code&gt; 옵션보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="503452c36c49cb1fd0ea949662ea239d8f9105d2" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt;crypto:engine_load/4&lt;/code&gt; and &lt;code&gt;Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자의 개인 키 또는 암호 엔진 및 선택적으로 암호로 보호 할 수있는 키 참조를 나타내는 맵은 &lt;code&gt;crypto:engine_load/4&lt;/code&gt; 및 &lt;code&gt;Crypto's Users Guide&lt;/code&gt; . 이 옵션이 제공되면 &lt;code&gt;keyfile&lt;/code&gt; 옵션을 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="1412b8d79c31037e94ec8ee160cfa882f7bfb3fb" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DER로 인코딩 된 사용자 인증서. 이 옵션이 제공되면 &lt;code&gt;certfile&lt;/code&gt; 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="25f2f74a7edc47541dafb29c006cde23cd47d9fe" translate="yes" xml:space="preserve">
          <source>The Diameter header of the message. Can be (and typically should be) &lt;code&gt;undefined&lt;/code&gt; for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</source>
          <target state="translated">메시지의 직경 헤더 릴레이가 아닌 응용 프로그램에서 발신 메시지에 대해 &lt;code&gt;undefined&lt;/code&gt; 않을 수 있으며 일반적으로 정의되지 않아야 합니다.이 경우 지름이 적절한 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5efc1791e653c1599eb1a85a25bc63fbc5f68900" translate="yes" xml:space="preserve">
          <source>The EPMD closes the socket when it has sent the information.</source>
          <target state="translated">EPMD는 정보를 보낼 때 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="657accf9a74a7eb0b025905c51aa524bbb4f52c3" translate="yes" xml:space="preserve">
          <source>The ETS type of the dumped table (that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;duplicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;). This type is used when loading the table again.</source>
          <target state="translated">덤프 된 테이블의 ETS 유형 (즉, &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; , &lt;code&gt;duplicate_bag&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; ). 이 유형은 테이블을 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37bd9159078f20014405583883e1e7838b1f320f" translate="yes" xml:space="preserve">
          <source>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</source>
          <target state="translated">EUnit 프레임 워크를 사용하면 Erlang에서 단위 테스트를 매우 쉽게 작성할 수 있습니다. 그러나 몇 가지 다른 방법으로 작성할 수 있으므로 가장 간단한 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="25e6615a6259b426a5c1aa433aefd48dfe9f0730" translate="yes" xml:space="preserve">
          <source>The Election Process</source>
          <target state="translated">선거 과정</target>
        </trans-unit>
        <trans-unit id="d7e47fd1c3278cd7de4abd1246ff9d0b6caf0c35" translate="yes" xml:space="preserve">
          <source>The Encoding can be changed for a file &quot;on the fly&quot; by using function &lt;code&gt;io:setopts/2&lt;/code&gt;. So a file can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then be set for the right encoding before further reading. For functions identifying BOMs, see module &lt;code&gt;unicode(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:setopts/2&lt;/code&gt; 함수를 사용하여 &quot;즉석에서&quot;파일의 인코딩을 변경할 수 있습니다 . 예를 들어 BOM과 같은 위치에 파일을 라틴 1 인코딩으로 분석 한 다음 BOM을 넘어서서 올바른 인코딩을 위해 파일을 설정할 수 있습니다. BOM을 식별하는 함수는 모듈 &lt;code&gt;unicode(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3ce07ca3d080f90844cafbb92cdb028293480a0" translate="yes" xml:space="preserve">
          <source>The Erlang &lt;strong&gt;error logger&lt;/strong&gt; is an event manager (see &lt;code&gt;OTP Design Principles&lt;/code&gt; and &lt;code&gt;gen_event(3)&lt;/code&gt;), registered as &lt;code&gt;error_logger&lt;/code&gt;.</source>
          <target state="translated">Erlang &lt;strong&gt;오류 로거&lt;/strong&gt; 는 &lt;code&gt;error_logger&lt;/code&gt; 로 등록 된 이벤트 관리자입니다 ( &lt;code&gt;OTP Design Principles&lt;/code&gt; 및 &lt;code&gt;gen_event(3)&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a6cec8bd2bf7434e290f227203641824a28b2253" translate="yes" xml:space="preserve">
          <source>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</source>
          <target state="translated">Erlang API는 임의의 곡선 매개 변수를 사용할 수 있지만 FIPS 모드에서는 보안 정책에서 허용하는 매개 변수 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e13d1897ff2db6a5ca229af1382794e443a1fe1" translate="yes" xml:space="preserve">
          <source>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</source>
          <target state="translated">암호화 응용 프로그램의 Erlang API는 FIPS 지원 여부에 관계없이 동일합니다. 그러나 nif 코드는 내부적으로 다른 OpenSSL API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48490447d94b14d0abe2e04b21fbd8bf2b9b8cdb" translate="yes" xml:space="preserve">
          <source>The Erlang BIF &lt;code&gt;spawn&lt;/code&gt; is used to create a new process: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt;. Consider the following module:</source>
          <target state="translated">Erlang BIF &lt;code&gt;spawn&lt;/code&gt; 은 새로운 프로세스를 생성하는데 사용됩니다 : &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt; . 다음 모듈을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bc260aee970be8377de4dc3244ea906f03e3f766" translate="yes" xml:space="preserve">
          <source>The Erlang BIFs.</source>
          <target state="translated">얼랭 BIF.</target>
        </trans-unit>
        <trans-unit id="99fe49d5ed45f059cc301355028f8dfef080429d" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang Distribution 프로토콜은 그 자체로는 안전하지 않으며 그렇게 목표로하지 않습니다. 안전한 분배를 위해서는 분배 노드가 tls를 통한 분배를 사용하도록 구성되어야합니다. 참고 항목 &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; 설정하는 방법에 대한 보안 분산 노드에 대한 자세한 내용은 사용 설명서를.</target>
        </trans-unit>
        <trans-unit id="a40f7e40db92a7107a9e3a5cac4b4ab65b30339c" translate="yes" xml:space="preserve">
          <source>The Erlang Emulator</source>
          <target state="translated">얼랭 에뮬레이터</target>
        </trans-unit>
        <trans-unit id="99377f0e14b45ce54e27b19f84ce7e618a01753c" translate="yes" xml:space="preserve">
          <source>The Erlang I/O-system has been designed (or at least used) in a way where you expect any I/O server to handle any string data. That is, however, no longer the case when working with Unicode characters. The Erlang programmer must now know the capabilities of the device where the data ends up. Also, ports in Erlang are byte-oriented, so an arbitrary string of (Unicode) characters cannot be sent to a port without first converting it to an encoding of choice.</source>
          <target state="translated">Erlang I / O 시스템은 모든 I / O 서버가 문자열 데이터를 처리 할 수있는 방식으로 설계되었습니다. 그러나 유니 코드 문자로 작업 할 때는 더 이상 적용되지 않습니다. Erlang 프로그래머는 이제 데이터가있는 장치의 기능을 알아야합니다. 또한 Erlang의 포트는 바이트 지향이므로 임의의 (유니 코드) 문자 문자열을 먼저 선택한 인코딩으로 변환하지 않고 포트로 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81cc438ebd93249f6378dd48a6614f5a8c1d4ea2" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application consists of both &lt;code&gt;Erlang&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; code. The &lt;code&gt;C&lt;/code&gt; code is delivered as a precompiled executable for windows, solaris and linux (SLES10) in the commercial build. In the open source distribution it is built the same way as all other application using configure and make. You may want to provide the the path to your ODBC libraries using --with-odbc=PATH.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 &lt;code&gt;Erlang&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 코드 로 구성됩니다 . &lt;code&gt;C&lt;/code&gt; 의 코드는 상업 빌드 윈도우, 솔라리스 및 리눅스 (SLES10)에 대한 미리 컴파일 된 실행 파일로 제공됩니다. 오픈 소스 배포에서는 configure 및 make를 사용하는 다른 모든 응용 프로그램과 동일한 방식으로 빌드됩니다. --with-odbc = PATH를 사용하여 ODBC 라이브러리의 경로를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4351bfa2f995c6bd330803859435f644586add" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should run on all Unix dialects including Linux, Windows 2000, Windows XP and NT. But currently it is only tested for Solaris, Windows 2000, Windows XP and NT.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 Linux, Windows 2000, Windows XP 및 NT를 포함한 모든 Unix 언어에서 실행되어야합니다. 그러나 현재는 Solaris, Windows 2000, Windows XP 및 NT에 대해서만 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="c54f824f83f969a528f4d85db8ff3bf2b47f63fe" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should work for any relational database that has an ODBC driver. But currently it is only regularly tested for &lt;code&gt;sqlserver&lt;/code&gt; and &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 ODBC 드라이버가있는 관계형 데이터베이스에서 작동해야합니다. 그러나 현재는 &lt;code&gt;sqlserver&lt;/code&gt; 및 &lt;code&gt;postgres&lt;/code&gt; 에 대해서만 정기적으로 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d474f74418b8768698a57fb6613d328b379dec3" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC interface is in principal database independent, e.i. an erlang program using the interface could be run without changes towards different databases. But as SQL is used it is alas possible to write database dependent programs. Even though SQL is an ANSI-standard meant to be database independent, different databases have proprietary extensions to SQL defining their own data types. If you keep to the ANSI data types you will minimize the problem. But unfortunately there is no guarantee that all databases actually treats the ANSI data types equivalently. For instance an installation of &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; will accept that you create a table column with the ANSI data type &lt;code&gt;integer&lt;/code&gt;, but when retrieving values from this column the driver reports that it is of type &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; and not &lt;code&gt;SQL_INTEGER&lt;/code&gt; as you may have expected.</source>
          <target state="translated">Erlang ODBC 인터페이스는 주 데이터베이스에 독립적입니다. 즉, 인터페이스를 사용하는 erlang 프로그램은 다른 데이터베이스로 변경하지 않고도 실행될 수 있습니다. 그러나 SQL이 사용됨에 따라 데이터베이스 종속 프로그램을 작성할 수 있습니다. SQL은 데이터베이스와 무관 한 ANSI 표준이지만 다른 데이터베이스는 자체 데이터 형식을 정의하는 SQL에 대한 고유 한 확장명을 갖습니다. ANSI 데이터 형식을 유지하면 문제가 최소화됩니다. 그러나 불행히도 모든 데이터베이스가 실제로 ANSI 데이터 유형을 동등하게 취급한다는 보장은 없습니다. 예를 들어, &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; 설치 하면 ANSI 데이터 유형 &lt;code&gt;integer&lt;/code&gt; 를 사용하여 테이블 열을 작성할 수 있습니다.그러나이 열에서 값을 검색 할 때 드라이버 는 예상 한대로 &lt;code&gt;SQL_INTEGER&lt;/code&gt; 가 아닌 &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; 유형임을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="56a64c0ae629896e0d315a11fe6e47437de08daf" translate="yes" xml:space="preserve">
          <source>The Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt; is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the &lt;code&gt;epmd(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">Erlang 포트 매퍼 데몬 &lt;strong&gt;epmd&lt;/strong&gt; 는 Erlang 노드가 시작된 모든 호스트에서 자동으로 시작됩니다. 심볼 노드 이름을 시스템 주소에 매핑합니다. ERTS 의 &lt;code&gt;epmd(1)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d980add9dd240554f189b1c3b37b65443fa21bb5" translate="yes" xml:space="preserve">
          <source>The Erlang Runtime System Application, ERTS, contains functionality necessary to run the Erlang system.</source>
          <target state="translated">ERTS (Erlang Runtime System Application)에는 Erlang 시스템을 실행하는 데 필요한 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec553e20bbac1faf44d07e9ebb7fae6ca5046122" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the SSL/TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSL 응용 프로그램은 현재 지원되는 버전에 대한 SSL / TLS / DTLS 프로토콜을 구현합니다. &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c184aeafc9a6a8c3c28dfd4fc9896eddb1e7172" translate="yes" xml:space="preserve">
          <source>The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options:</source>
          <target state="translated">Erlang 토큰 스캐너는 옵션에 따라 다음 주석의 서브 세트가있는 토큰을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f44e036ac3f33332c9617d1ca93feead49accb2d" translate="yes" xml:space="preserve">
          <source>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</source>
          <target state="translated">Erlang VM은 정규식 일치 재귀가 발생할 때 힙 메모리가 사용되는 PCRE 라이브러리를 사용합니다. 따라서 C 스택이 아닌 머신 힙 사용이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8d4936bbce5dce7c69c00ed9e6d923ffdcef1207" translate="yes" xml:space="preserve">
          <source>The Erlang archives are &lt;code&gt;ZIP&lt;/code&gt; files with extension &lt;code&gt;.ez&lt;/code&gt;. Erlang archives can also be enclosed in &lt;code&gt;escript&lt;/code&gt; files whose file extension is arbitrary.</source>
          <target state="translated">Erlang 아카이브는 확장자가 &lt;code&gt;.ez&lt;/code&gt; 인 &lt;code&gt;ZIP&lt;/code&gt; 파일입니다 . Erlang 아카이브는 파일 확장자가 임의 인 &lt;code&gt;escript&lt;/code&gt; 파일로 묶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75458bb55fedfe4d27d190b85b2453fc10e6e94f" translate="yes" xml:space="preserve">
          <source>The Erlang code in the &quot;Erlang code.&quot; section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</source>
          <target state="translated">&quot;Erlang 코드&quot;의 Erlang 코드 섹션은 모듈 선언 및 사전 정의 된 내보내기 선언 바로 다음에 출력 파일에 작성되므로 추가 내보내기를 추가하고 가져 오기 및 기타 속성을 정의하여 전체 파일에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bada6b35e4702ac9e1f602bd85f459a9e5c8d11" translate="yes" xml:space="preserve">
          <source>The Erlang code is slightly different, as we do not return the result synchronously from &lt;code&gt;port_control&lt;/code&gt;, instead we get it from &lt;code&gt;driver_output&lt;/code&gt; as data in the message queue. The function &lt;code&gt;return_port_data&lt;/code&gt; above receives data from the port. As the data is in binary format, we use &lt;code&gt;binary_to_term/1&lt;/code&gt; to convert it to an Erlang term. Notice that the driver is opened in binary mode (&lt;code&gt;open_port/2&lt;/code&gt; is called with option &lt;code&gt;[binary]&lt;/code&gt;). This means that data sent from the driver to the emulator is sent as binaries. Without option &lt;code&gt;binary&lt;/code&gt;, they would have been lists of integers.</source>
          <target state="translated">Erlang 코드는 &lt;code&gt;port_control&lt;/code&gt; 에서 결과를 동 기적으로 반환하지 않기 때문에 약간 다릅니다. 대신 메시지 큐의 데이터로 &lt;code&gt;driver_output&lt;/code&gt; 에서 결과 를 얻습니다 . 위의 &lt;code&gt;return_port_data&lt;/code&gt; 함수 는 포트에서 데이터를 수신합니다. 데이터는 이진 형식이므로 &lt;code&gt;binary_to_term/1&lt;/code&gt; 을 사용하여 데이터 를 Erlang 용어로 변환합니다. 드라이버가 이진 모드로 열립니다 ( &lt;code&gt;open_port/2&lt;/code&gt; 는 &lt;code&gt;[binary]&lt;/code&gt; 옵션으로 호출 됨 ). 이것은 드라이버에서 에뮬레이터로 전송 된 데이터가 바이너리로 전송됨을 의미합니다. &lt;code&gt;binary&lt;/code&gt; 옵션이 없으면 정수 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="57d172985612cd6cd41a2f597d2b75bb27821e07" translate="yes" xml:space="preserve">
          <source>The Erlang code linter.</source>
          <target state="translated">얼랭 코드 린터.</target>
        </trans-unit>
        <trans-unit id="a5138a7c32b5f91b090191893db4bd11097e1026" translate="yes" xml:space="preserve">
          <source>The Erlang code preprocessor includes functions that are used by the &lt;code&gt;compile&lt;/code&gt; module to preprocess macros and include files before the parsing takes place.</source>
          <target state="translated">Erlang 코드 프리 프로세서에는 &lt;code&gt;compile&lt;/code&gt; 모듈에서 매크로를 사전 처리하고 구문 분석이 발생하기 전에 파일을 포함 시키는 데 사용되는 기능이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d403e45ee407cb0dd03528fe23bfb406bd2d6ae" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlang 크래시 덤프는 Erlang / OTP R9C에서 크게 개선되었습니다. 따라서이 섹션의 정보는 이전 덤프에는 직접 적용 할 수 없습니다. 그러나 이전 덤프에서 &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; 를 사용 하면 충돌 덤프는 이와 유사한 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="737305746ee3808d6e58fd2718a7d171052eb3a2" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump is a readable text file, but it can be difficult to read. Using the Crashdump Viewer tool in the &lt;code&gt;Observer&lt;/code&gt; application simplifies the task. This is a wx-widget-based tool for browsing Erlang crash dumps.</source>
          <target state="translated">Erlang 크래시 덤프는 읽을 수있는 텍스트 파일이지만 읽기 어려울 수 있습니다. &lt;code&gt;Observer&lt;/code&gt; 애플리케이션 에서 Crashdump Viewer 도구를 사용하면 작업이 간소화됩니다. 이것은 Erlang 크래시 덤프를 찾아보기위한 wx-widget 기반 도구입니다.</target>
        </trans-unit>
        <trans-unit id="3019fbc7ca6a8b1745aa1cb4e5822a66509aa10a" translate="yes" xml:space="preserve">
          <source>The Erlang crashdump contains a listing of each living Erlang process in the system. The following fields can exist for a process:</source>
          <target state="translated">Erlang 크래시 덤프에는 시스템에 존재하는 각 Erlang 프로세스의 목록이 포함되어 있습니다. 프로세스에 대해 다음 필드가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db00cf758cc1a463b96d0532ae1f4b69cef5510a" translate="yes" xml:space="preserve">
          <source>The Erlang distribution can in theory use almost any connection-based protocol as bearer. However, a module that implements the protocol-specific parts of the connection setup is needed. The default distribution module is &lt;code&gt;inet_tcp_dist&lt;/code&gt; in the Kernel application. When starting an Erlang node distributed, &lt;code&gt;net_kernel&lt;/code&gt; uses this module to set up listen ports and connections.</source>
          <target state="translated">Erlang 배포판은 이론적으로 거의 모든 연결 기반 프로토콜을 베어러로 사용할 수 있습니다. 그러나 연결 설정의 프로토콜 특정 부분을 구현하는 모듈이 필요합니다. 커널 응용 프로그램에서 기본 배포 모듈은 &lt;code&gt;inet_tcp_dist&lt;/code&gt; 입니다. Erlang 노드 분배를 시작할 때 &lt;code&gt;net_kernel&lt;/code&gt; 은이 모듈을 사용하여 청취 포트 및 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5c65eb0e7a3b5fcbd2b82941f0e7502510e7adf8" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there can exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API.</source>
          <target state="translated">Erlang 드라이버 스레드 API는 UN-ices의 POSIX 스레드 API 및 Windows의 Windows 기본 스레드 API와 함께 사용할 수 있습니다. Erlang 드라이버 스레드 API는 이식 가능하다는 장점이 있지만 POSIX 스레드 API 또는 Windows 기본 스레드 API의 기능을 사용하려는 상황이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd35f4981de74aaf8658339a6b773ed029b97baf" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it is not reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated.</source>
          <target state="translated">Erlang 드라이버 스레드 API는 오류 조건에서 복구하는 것이 합리적인 경우에만 오류 코드를 리턴합니다. 오류 조건에서 복구하는 것이 합리적이지 않으면 전체 런타임 시스템이 종료됩니다. 예를 들어, 뮤텍스 작성 조작이 실패하면 오류 코드가 리턴되지만 뮤텍스에 대한 잠금 조작이 실패하면 전체 런타임 시스템이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f886f4ca7d89492a5c1356ea054f392597b34344" translate="yes" xml:space="preserve">
          <source>The Erlang editing mode provides a command that knows about the Erlang comment structure and can be used to fill text paragraphs in comments. Ex:</source>
          <target state="translated">Erlang 편집 모드는 Erlang 주석 구조에 대해 알고 명령에서 텍스트 단락을 채우는 데 사용할 수있는 명령을 제공합니다. 전의:</target>
        </trans-unit>
        <trans-unit id="6381e25503c0fb716dfd00aadaa0608beadd9a69" translate="yes" xml:space="preserve">
          <source>The Erlang emulator is found by examining the registry keys for the emulator version specified in the release data file. The new emulator must be properly installed before the upgrade for this to work.</source>
          <target state="translated">Erlang 에뮬레이터는 릴리스 데이터 파일에 지정된 에뮬레이터 버전의 레지스트리 키를 검사하여 찾을 수 있습니다. 업그레이드하려면 새 에뮬레이터를 올바르게 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6339e932f018732bcd165eb1f04f836a77855588" translate="yes" xml:space="preserve">
          <source>The Erlang emulator keeps track of a &lt;strong&gt;stack trace&lt;/strong&gt;, information about recent function calls. This information is used if an error occurs, for example:</source>
          <target state="translated">Erlang 에뮬레이터 는 최근 함수 호출에 대한 정보 인 &lt;strong&gt;스택 추적을 추적&lt;/strong&gt; 합니다. 이 정보는 오류가 발생하는 경우에 사용됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="17cd3f882b4ce1af8737a7262e13ec5ab23b1f5e" translate="yes" xml:space="preserve">
          <source>The Erlang emulator.</source>
          <target state="translated">얼랭 에뮬레이터.</target>
        </trans-unit>
        <trans-unit id="5714cdd55594ddeb51b48625444a53558a829eec" translate="yes" xml:space="preserve">
          <source>The Erlang external term format is a representation of an Erlang term as a sequence of bytes, that is, a binary. Conversion between the two representations is done using the following BIFs:</source>
          <target state="translated">Erlang 외부 용어 형식은 Erlang 용어를 바이트 시퀀스, 즉 이진으로 표현한 것입니다. 두 표현 간의 변환은 다음 BIF를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="152d4b6905d9f607d0072156b089899f65fd52eb" translate="yes" xml:space="preserve">
          <source>The Erlang implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">얼랭 구현은 &quot;영리&quot;이며, 각 메시지는 각각의 패턴에 대해 테스트 횟수 최소화 &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a0b3cf2e8db83679b557ee8aff89fcae6b1c98" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter can also be accessed through the interface module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 인터프리터는 인터페이스 모듈 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt; 통해 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ca39c39b895d99de154868388ab2c941551645" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is primarily intended to be used by Debugger, see the User's Guide and &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 인터프리터는 중단 점 및 단계별 코드 실행 메커니즘을 제공합니다. 주로 디버거에서 사용하도록 만들어졌습니다. 사용 설명서 및 &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfe42365ca090c07c2f31a18aa82078cc7413a46" translate="yes" xml:space="preserve">
          <source>The Erlang language is described in the &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual&lt;/a&gt;. An Erlang tutorial can be found in &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;.</source>
          <target state="translated">Erlang 언어는 &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual에&lt;/a&gt; 설명되어 있습니다. Erlang 튜토리얼은 Erlang &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;시작하기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c86834683bf25d823843edf61397923bc0c7af5" translate="yes" xml:space="preserve">
          <source>The Erlang language specification puts no limits on the number of processes, length of atoms, and so on. However, for performance and memory saving reasons, there will always be limits in a practical implementation of the Erlang language and execution environment.</source>
          <target state="translated">Erlang 언어 사양은 프로세스 수, 원자 길이 등을 제한하지 않습니다. 그러나 성능 및 메모리 절약을 위해 Erlang 언어 및 실행 환경의 실제 구현에는 항상 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5868365d112b2d753afe38d0282d35341218fb05" translate="yes" xml:space="preserve">
          <source>The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;.</source>
          <target state="translated">문자열의 Erlang 리터럴 구문은 &quot;\&quot;(백 슬래시) 문자를 이스케이프 코드로 사용합니다. 코드와 셸에서 추가 백 슬래시 ( &quot;\\&quot;)를 사용하여 리터럴 문자열에서 백 슬래시를 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="7436c6776e46ff0b0c98637a1562d8d93f74d6d7" translate="yes" xml:space="preserve">
          <source>The Erlang meta interpreter.</source>
          <target state="translated">Erlang 메타 통역사.</target>
        </trans-unit>
        <trans-unit id="6dd0afebea808766c4e5ba67702ba9bcda564088" translate="yes" xml:space="preserve">
          <source>The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language.</source>
          <target state="translated">Erlang 모드는 물론이 기능을 제공합니다. 사용 된 레이아웃은 일반적인 언어 사용을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e03b514fa1c315e1fd202d5ceb91d82531266ba5" translate="yes" xml:space="preserve">
          <source>The Erlang mode for the Emacs editor includes two &lt;code&gt;Common Test&lt;/code&gt; test suite templates, one with extensive information in the function headers, and one with minimal information. A test suite template provides a quick start for implementing a suite from scratch and gives a good overview of the available callback functions. The two templates follows:</source>
          <target state="translated">Emacs 편집기의 Erlang 모드에는 두 개의 &lt;code&gt;Common Test&lt;/code&gt; 테스트 템플리트가 포함되어 있습니다 . 하나는 기능 헤더에 광범위한 정보가 있고 하나는 최소한의 정보입니다. 테스트 스위트 템플릿은 스위트를 처음부터 빠르게 구현하기위한 빠른 시작을 제공하고 사용 가능한 콜백 함수에 대한 개요를 제공합니다. 두 가지 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd1e16dd7e3186a437be6f5c58e6b98f95a1b6f2" translate="yes" xml:space="preserve">
          <source>The Erlang module can look as follows:</source>
          <target state="translated">Erlang 모듈은 다음과 같이 보일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e4823fe40646d231f25e1af4061079540646bbb" translate="yes" xml:space="preserve">
          <source>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call &lt;code&gt;writev&lt;/code&gt;. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</source>
          <target state="translated">Erlang nif 라이브러리에는 unix 시스템 호출 &lt;code&gt;writev&lt;/code&gt; 에서 사용되는 I / O 벡터를 쉽게 사용할 수있는 기능이 있습니다 . I / O 큐는 스레드로부터 안전하지 않으므로 다른 동기화 메커니즘을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fe4b7ddd1b6e3fddbfb0dc8eba68674fa92a0bc" translate="yes" xml:space="preserve">
          <source>The Erlang node is to be given the short name &lt;code&gt;e1&lt;/code&gt; and must be set to use the same magic cookie as the C node, &lt;code&gt;secretcookie&lt;/code&gt;:</source>
          <target state="translated">Erlang 노드에는 짧은 이름 &lt;code&gt;e1&lt;/code&gt; 이 주어져야하고 &lt;code&gt;secretcookie&lt;/code&gt; C 노드와 동일한 매직 쿠키를 사용하도록 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b252e3e3ea1acfeb31712ba10c8bb1164cc7e6f7" translate="yes" xml:space="preserve">
          <source>The Erlang nodes have different cookies.</source>
          <target state="translated">Erlang 노드에는 다른 쿠키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dac1fcc04ff2d796878d2e221f0d3d0504eeff3" translate="yes" xml:space="preserve">
          <source>The Erlang parser.</source>
          <target state="translated">얼랭 파서.</target>
        </trans-unit>
        <trans-unit id="e3e1a66870ceefa4057accb399287057807ab241" translate="yes" xml:space="preserve">
          <source>The Erlang part of the asynchronous driver consists of the sample file &lt;code&gt;pg_async.erl&lt;/code&gt;.</source>
          <target state="translated">비동기 드라이버의 Erlang 부분은 샘플 파일 &lt;code&gt;pg_async.erl&lt;/code&gt; 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a9c70ac47d5fb1df5bdc0c1579a6d354d215f36" translate="yes" xml:space="preserve">
          <source>The Erlang pretty printer.</source>
          <target state="translated">Erlang 프리티 프린터.</target>
        </trans-unit>
        <trans-unit id="8092d1a007430220494c776fea5b8d0105151629" translate="yes" xml:space="preserve">
          <source>The Erlang process creating a port is said to be the &lt;strong&gt;port owner&lt;/strong&gt;, or the &lt;strong&gt;connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the port owner. If the port owner terminates, so does the port (and the external program, if it is written correctly).</source>
          <target state="translated">포트를 생성하는 Erlang 프로세스는 &lt;strong&gt;포트 소유자&lt;/strong&gt; 또는 &lt;strong&gt;포트&lt;/strong&gt; 의 &lt;strong&gt;연결된 프로세스&lt;/strong&gt; 라고합니다. 포트와의 모든 통신은 포트 소유자를 거쳐야합니다. 포트 소유자가 종료되면 포트 (및 외부 프로그램이 올바르게 작성된 경우)도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="27d54a521c2a5287aa3d01d2b57bd9e14da9ddb9" translate="yes" xml:space="preserve">
          <source>The Erlang representation for &quot;BMPString&quot; and &quot;UniversalString&quot; is either a list of ASCII values or a list of quadruples. The quadruple representation associates to the Unicode standard representation of characters. The ASCII characters are all represented by quadruples beginning with three zeros like {0,0,0,65} for character 'A'. When decoding a value for these strings, the result is a list of quadruples, or integers when the value is an ASCII character.</source>
          <target state="translated">&quot;BMPString&quot;및 &quot;UniversalString&quot;에 대한 Erlang 표현은 ASCII 값 목록 또는 4 중 목록입니다. 4 중 표현은 문자의 유니 코드 표준 표현과 연관됩니다. ASCII 문자는 모두 문자 'A'에 대해 {0,0,0,65}와 같이 3 개의 0으로 시작하는 4 중으로 표시됩니다. 이러한 문자열의 값을 디코딩 할 때 결과는 사중 목록 또는 값이 ASCII 문자 인 경우 정수입니다.</target>
        </trans-unit>
        <trans-unit id="fd34b0812f3e91023a25d2d60c73c4062e69913a" translate="yes" xml:space="preserve">
          <source>The Erlang representation of an ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; is an integer or an atom if a &lt;code&gt;Named Number List&lt;/code&gt; (see &lt;code&gt;T6&lt;/code&gt; in the previous list) is specified.</source>
          <target state="translated">ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; 의 Erlang 표현은 &lt;code&gt;Named Number List&lt;/code&gt; ( 이전 목록의 &lt;code&gt;T6&lt;/code&gt; 참조 )이 지정된 경우 정수 또는 원자 입니다.</target>
        </trans-unit>
        <trans-unit id="6762086b168330d83da3710e72be56df1e3f3f82" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.</source>
          <target state="translated">Erlang 런타임 시스템은 완전한 32 비트 (또는 64 비트) 주소 공간을 사용할 수 있지만 운영 체제는 종종 단일 프로세스가 그보다 적게 사용하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="b825bf5f9dd97f4fdde610e1f993f6d1d34418b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system requires that the contents of the script used to boot the system is a binary Erlang term. This function transforms the &lt;code&gt;File.script&lt;/code&gt; boot script to a binary term, which is stored in the &lt;code&gt;File.boot&lt;/code&gt; file.</source>
          <target state="translated">Erlang 런타임 시스템을 사용하려면 시스템을 부팅하는 데 사용되는 스크립트의 내용이 이진 Erlang 용어 여야합니다. 이 함수는 &lt;code&gt;File.script&lt;/code&gt; 부팅 스크립트를 이진 용어로 변환 하며이 용어는 &lt;code&gt;File.boot&lt;/code&gt; 파일에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ce0572c42ceec3f568ad1851dad4770b2b84b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system uses a generational garbage collection scheme, using an &quot;old heap&quot; for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</source>
          <target state="translated">Erlang 런타임 시스템은 최소한 하나의 가비지 콜렉션에서 살아남은 데이터에 &quot;오래된 힙&quot;을 사용하여 세대 가비지 콜렉션 체계를 사용합니다. 이전 힙에 공간이 더 이상 없으면 전체 스윕 가비지 콜렉션이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b9d9f6b0df9097bbff53b037dc4f96145ca6dbd2" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 의 Erlang 런타임 시스템보기 . 그것을 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="175c0bd0d93fcd68af4b41f5bd3ed0c1384dfa2e" translate="yes" xml:space="preserve">
          <source>The Erlang scanner in the &lt;code&gt;io&lt;/code&gt; module can be used as a starting point when writing a new scanner. Study &lt;code&gt;yeccscan.erl&lt;/code&gt; in order to see how a filter can be added on top of &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; to provide a scanner for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more general approach to scanner implementation is to use a scanner generator. A scanner generator in Erlang called &lt;code&gt;leex&lt;/code&gt; is under development.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈 의 Erlang 스캐너 는 새 스캐너를 작성할 때 시작점으로 사용할 수 있습니다. &lt;code&gt;yeccscan.erl&lt;/code&gt; 을 연구 하여 &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; 위에 필터를 추가 하여 Yecc 파서로 구문 분석하기 전에 문법 파일을 토큰 화하는 Yecc 용 스캐너를 제공하는 방법을 확인하십시오. 스캐너 구현에 대한보다 일반적인 방법은 스캐너 생성기를 사용하는 것입니다. Erlang의 &lt;code&gt;leex&lt;/code&gt; 라는 스캐너 생성기 가 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="37265f6197faced222d42e8a4148f58e5b966cea" translate="yes" xml:space="preserve">
          <source>The Erlang server interface is implemented by module &lt;code&gt;mod_esi&lt;/code&gt;.</source>
          <target state="translated">Erlang 서버 인터페이스는 &lt;code&gt;mod_esi&lt;/code&gt; 모듈로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa8c45ba50425e13e797fcc4854bc1fcf3424403" translate="yes" xml:space="preserve">
          <source>The Erlang shell available over SSH</source>
          <target state="translated">SSH를 통해 사용 가능한 Erlang 쉘</target>
        </trans-unit>
        <trans-unit id="fa1d76065068bd2589fcd099c8a0c8156db2a1c8" translate="yes" xml:space="preserve">
          <source>The Erlang shell understands the command &lt;code&gt;c(Module)&lt;/code&gt; which both compiles and loads &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">얼랑 쉘은 명령 이해 &lt;code&gt;c(Module)&lt;/code&gt; 컴파일 및로드 모두 &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5dceee96a25b9a8c7bf615c2130bf76584510ce" translate="yes" xml:space="preserve">
          <source>The Erlang shell.</source>
          <target state="translated">얼랭 쉘.</target>
        </trans-unit>
        <trans-unit id="a51205151ea58d8438ebe29c7d0e6218f72ff948" translate="yes" xml:space="preserve">
          <source>The Erlang source code has support for the UTF-8 encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can control the encoding by a comment like the following in the beginning of the file:</source>
          <target state="translated">Erlang 소스 코드는 UTF-8 인코딩 및 바이트 단위 인코딩을 지원합니다. Erlang / OTP R16B의 기본값은 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩입니다. Erlang / OTP 17.0에서 UTF-8로 변경되었습니다. 파일 시작 부분에서 다음과 같은 주석으로 인코딩을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469909cd3bb80b2a08960dcf0954a2e053c206c4" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;code&gt;encoding&lt;/code&gt; is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is an invalid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlang 소스 파일 &lt;code&gt;encoding&lt;/code&gt; 은 소스 파일 의 처음 두 줄 중 하나의 주석에 의해 선택됩니다. 정규식 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 과 일치하는 첫 번째 문자열 \ s * [: =] \ s * ([-a-zA-Z0-9]) + 는 인코딩을 선택합니다. 일치하는 문자열이 유효하지 않은 인코딩 인 경우 무시됩니다. 유효한 인코딩은 &lt;code&gt;Latin-1&lt;/code&gt; 및 &lt;code&gt;UTF-8&lt;/code&gt; 이며 문자의 경우 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7ddb53385af1f6753c8713a645cc1fc36907bac" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;strong id=&quot;encoding&quot;&gt;encoding&lt;/strong&gt; is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">Erlang 소스 파일 &lt;strong id=&quot;encoding&quot;&gt;인코딩&lt;/strong&gt; 은 소스 파일 의 처음 두 줄 중 하나의 주석에 의해 선택됩니다. 정규식 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 일치하는 첫 번째 문자열 은 인코딩을 선택합니다. 일치하는 문자열이 유효한 인코딩이 아닌 경우 무시됩니다. 유효한 인코딩은 &lt;code&gt;Latin-1&lt;/code&gt; 및 &lt;code&gt;UTF-8&lt;/code&gt; 이며 문자의 경우 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="978c7190f27ebbf14f966c1feadf6f5410de9629" translate="yes" xml:space="preserve">
          <source>The Erlang system must be started.</source>
          <target state="translated">Erlang 시스템을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9941ae0e376a140dd219d96c5fea5aedb3770d4" translate="yes" xml:space="preserve">
          <source>The Erlang token scanner.</source>
          <target state="translated">Erlang 토큰 스캐너.</target>
        </trans-unit>
        <trans-unit id="a16c12a6b02ac800a11334f62d3a994378ac0165" translate="yes" xml:space="preserve">
          <source>The Erlang web server API data types are as follows:</source>
          <target state="translated">Erlang 웹 서버 API 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65d28c591e7208c326a531484ecbb2f3de4814d0" translate="yes" xml:space="preserve">
          <source>The Evaluator area, where you can evaluate functions within the context of the debugged process, if that process execution is stopped.</source>
          <target state="translated">프로세스 실행이 중지 된 경우 디버그 된 프로세스의 컨텍스트 내에서 함수를 평가할 수있는 평가자 영역.</target>
        </trans-unit>
        <trans-unit id="b8f527b2c601f16975ba4c3206247d354cc52722" translate="yes" xml:space="preserve">
          <source>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP 클라이언트는 항상 수동 FTP 모드를 사용하려고 시도하며 이것이 실패하면 활성 FTP 모드에만 의존합니다. 이 기본 동작은 시작 옵션 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46eb4343e573b38e361697e41777d053a18c2fba" translate="yes" xml:space="preserve">
          <source>The FTP client can be started and stopped dynamically in runtime by calling the &lt;code&gt;ftp&lt;/code&gt; application API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; and &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt;.</source>
          <target state="translated">FTP 클라이언트는 &lt;code&gt;ftp&lt;/code&gt; 애플리케이션 API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; 및 &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt; 를 호출하여 런타임에 동적으로 시작 및 중지 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ff37cf016753285c00cfe38b14f6b9064cd0bb5" translate="yes" xml:space="preserve">
          <source>The Flex scanner is a Megaco scanner written as a linked in driver (in C). There are two ways to get this working:</source>
          <target state="translated">Flex 스캐너는 링크 된 드라이버 (C)로 작성된 Megaco 스캐너입니다. 이 작업을 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0817c2658a9f234929df429f0abce5aa05ce329d" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun은 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; 함수에 대한 인수로 전달 될 수 있으며 ,이를 통해 사용자 정의 된 액티비티 액세스 콜백 모듈을 사용할 수 있습니다. 모듈 이름을 인수로 지정하거나 구성 매개 변수 &lt;code&gt;access_module&lt;/code&gt; 을 사용하여 암시 적으로 얻을 수 있습니다. 사용자 정의 된 콜백 모듈은 트리거, 무결성 제한 조건, 런타임 통계 또는 가상 테이블 제공과 같은 여러 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491576369b07d94c026adb9d94add3cd468dc1c6" translate="yes" xml:space="preserve">
          <source>The GUI main window is opened when Crashdump Viewer has loaded a crashdump. It contains a title bar, a menu bar, information tabs, and a status bar.</source>
          <target state="translated">Crashdump Viewer가 크래시 덤프를로드하면 GUI 기본 창이 열립니다. 제목 표시 줄, 메뉴 표시 줄, 정보 탭 및 상태 표시 줄이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="468c9cc0468cc5c92ee919e07070c915b671da34" translate="yes" xml:space="preserve">
          <source>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the &lt;code&gt;get&lt;/code&gt; operation.</source>
          <target state="translated">에이전트가 MIB에서 다음 일반 변수 인스턴스를 찾아 &lt;code&gt;get&lt;/code&gt; 조작으로 계측을 호출 할 수 있으므로 GetNext 조작 조작은 테이블에 대해서만 정의되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca4179f6bcde085d4b0d34f9240821a74141f758" translate="yes" xml:space="preserve">
          <source>The Gregorian calendar in this module is extended back to year 0. For a given date, the &lt;strong&gt;gregorian days&lt;/strong&gt; is the number of days up to and including the date specified. Similarly, the &lt;strong&gt;gregorian seconds&lt;/strong&gt; for a specified date and time is the number of seconds up to and including the specified date and time.</source>
          <target state="translated">이 모듈의 Gregorian 달력은 0 년으로 다시 확장됩니다. 주어진 날짜의 &lt;strong&gt;gregorian days&lt;/strong&gt; 는 지정된 날짜까지의 날짜 수입니다. 마찬가지로, 지정된 날짜 및 시간에 대한 &lt;strong&gt;그레고리 안 초&lt;/strong&gt; 는 지정된 날짜 및 시간을 포함하여 최대 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="6a32364a7c7faf5d1cbacad811c6e3a642e6422e" translate="yes" xml:space="preserve">
          <source>The HTML overview log file is updated with test results.</source>
          <target state="translated">HTML 개요 로그 파일이 테스트 결과로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="aab4263cb8d1f32842025f35d2e34059d6bef33e" translate="yes" xml:space="preserve">
          <source>The HTML version of the test suite source code is not generated during the test run (and is consequently not available in the log file system).</source>
          <target state="translated">테스트 스위트 소스 코드의 HTML 버전은 테스트 실행 중에 생성되지 않으며 결과적으로 로그 파일 시스템에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e41fc71ae08f56427cd0499723a4d95a81e54bc2" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP 클라이언트 및 서버는 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 정의 된 대로 HTTP 1.1을 준수 합니다.</target>
        </trans-unit>
        <trans-unit id="0a3e013cebd4679eacc44ce278db16ae997e7553" translate="yes" xml:space="preserve">
          <source>The HTTP client default profile is started when the &lt;code&gt;Inets&lt;/code&gt; application is started and is then available to all processes on that Erlang node. Other profiles can also be started at application startup, or profiles can be started and stopped dynamically in runtime. Each client profile spawns a new process to handle each request, unless a persistent connection can be used with or without pipelining. The client adds a &lt;code&gt;host&lt;/code&gt; header and an empty &lt;code&gt;te&lt;/code&gt; header if there are no such headers present in the request.</source>
          <target state="translated">HTTP 클라이언트 기본 프로파일은 &lt;code&gt;Inets&lt;/code&gt; 애플리케이션 이 시작될 때 시작된 다음 해당 Erlang 노드의 모든 프로세스에서 사용할 수 있습니다. 응용 프로그램 시작시 다른 프로파일을 시작하거나 런타임에 프로파일을 동적으로 시작 및 중지 할 수도 있습니다. 파이프 라인을 사용하거나 사용하지 않고 지속적인 연결을 사용할 수없는 경우 각 클라이언트 프로파일은 각 요청을 처리하기 위해 새 프로세스를 생성합니다. 요청에 이러한 헤더가없는 경우 클라이언트는 &lt;code&gt;host&lt;/code&gt; 헤더와 빈 &lt;code&gt;te&lt;/code&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7c7ba7538b9c9c0121b49c6ec91168734deba0dc" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">httpd라고도하는 HTTP 서버 는 게이트웨이 및 프록시 기능과 같은 몇 가지 예외를 제외하고 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 설명 된 대로 HTTP 요청을 처리 합니다. 기본 메커니즘이 지원하는 한 서버는 IPv6을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ed5f93e75e8af313b179c6713c54eb1bf37d9eef" translate="yes" xml:space="preserve">
          <source>The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user.</source>
          <target state="translated">HTTP 표준에서는 대소 문자를 구분하지 않아야합니다. 서버와 통신 할 다른 방법이 없거나 테스트 목적으로 만이 기능을 사용하십시오. 이 옵션을 사용하면 헤더가 자동으로 추가되지 않습니다. 필요한 모든 헤더는 사용자가 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2d85de81f5fcc8588a618440bb02e8ae50bca16" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">HTTP 상태 코드가 클라이언트에 리턴되었습니다 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b82e39a63325ee5467a0018be1f905eeb2f7c52" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as &lt;code&gt;HttpError&lt;/code&gt;.</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜. 패킷은 앞에서 설명한 &lt;code&gt;HttpPacket&lt;/code&gt; 에 따른 형식으로 반환됩니다 . 패킷은 요청, 응답, 헤더 또는 헤더 마크의 끝입니다. 유효하지 않은 행은 &lt;code&gt;HttpError&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="169734960811a4c34c5ce86c1d456ff7cf230d3e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜. 패킷은 ERTS의 &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; 에 설명 된 &lt;code&gt;HttpPacket&lt;/code&gt; 에 따른 형식으로 반환됩니다 . 패시브 모드의 소켓 은 &lt;code&gt;gen_tcp:recv&lt;/code&gt; 에서 &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; 을 반환 하고 활성 소켓은 &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; 과 같은 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0fdd97c77238f0d4bc1a4b8495b731166db58155" translate="yes" xml:space="preserve">
          <source>The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to &lt;code&gt;latin1&lt;/code&gt; encoding, meaning that any characters &amp;gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system).</source>
          <target state="translated">Erlang이 &quot;-oldshell&quot;또는 &quot;-noshell&quot;플래그로 시작될 때 사용되는 I / O 장치는 기본적으로 &lt;code&gt;latin1&lt;/code&gt; 인코딩 으로 설정됩니다 . 즉, 문자&amp;gt; 코드 포인트 255가 이스케이프되고 입력이 일반 8 비트 여야합니다. ISO 라틴어 -1. 인코딩이 유니 코드로 변경되면 표준 파일 디스크립터의 입력 및 출력은 UTF-8 (운영 체제와 상관없이)입니다.</target>
        </trans-unit>
        <trans-unit id="3a9ee44bfdadb9768492101f1c57f8171e2439fd" translate="yes" xml:space="preserve">
          <source>The I/O protocol in Erlang enables bi-directional communication between clients and servers.</source>
          <target state="translated">Erlang의 I / O 프로토콜은 클라이언트와 서버 간의 양방향 통신을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="da4b71eee53848cfe7e0ded6f806a23b361aa596" translate="yes" xml:space="preserve">
          <source>The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:</source>
          <target state="translated">I / O 서버는 요청 목록에 대해 목록의 요청에 따라 다음과 같은 유효한 결과를 응답으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf03aa38e2e7b2e9d865676ed62c6ed1b166de9" translate="yes" xml:space="preserve">
          <source>The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device.</source>
          <target state="translated">I / O 서버는 요청을 처리하고 요청 된 작업 (예 : I / O 장치)을 수행하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="29324f42eeb70cb428190b9afb707250b51d08e0" translate="yes" xml:space="preserve">
          <source>The I/O server is to send one of the following as &lt;code&gt;Reply&lt;/code&gt;:</source>
          <target state="translated">I / O 서버는 다음 중 하나를 &lt;code&gt;Reply&lt;/code&gt; 으로 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="cffff6188b7c071be58063158f15f52414545611" translate="yes" xml:space="preserve">
          <source>The I/O server is to send the &lt;code&gt;Reply&lt;/code&gt; as:</source>
          <target state="translated">I / O 서버는 다음과 같이 &lt;code&gt;Reply&lt;/code&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a68a34b093217c6e79f51f56360324a76a6607db" translate="yes" xml:space="preserve">
          <source>The I/O server replies to the client with an &lt;code&gt;io_reply&lt;/code&gt; tuple, where element &lt;code&gt;Reply&lt;/code&gt; is one of:</source>
          <target state="translated">I / O 서버는 &lt;code&gt;io_reply&lt;/code&gt; 튜플 을 사용하여 클라이언트에 응답합니다. 여기서 &lt;code&gt;Reply&lt;/code&gt; 요소 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6984e80e5ec40501eed04b79f0e90cd3e1a039b" translate="yes" xml:space="preserve">
          <source>The I/O server replies:</source>
          <target state="translated">I / O 서버가 응답합니다 :</target>
        </trans-unit>
        <trans-unit id="615c499b56501d6b2d674044444c5cd252a3aa4d" translate="yes" xml:space="preserve">
          <source>The I/O vector used by the emulator and drivers is a list of binaries, with a &lt;code&gt;SysIOVec&lt;/code&gt; pointing to the buffers of the binaries. It is used in &lt;code&gt;driver_outputv&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver callback. Also, the driver queue is an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터와 드라이버에서 사용하는 I / O 벡터는 바이너리 목록이며 &lt;code&gt;SysIOVec&lt;/code&gt; 은 바이너리 버퍼를 가리 킵니다. 그것은에 사용 &lt;code&gt;driver_outputv&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 의 드라이버 콜백. 또한 드라이버 큐는 &lt;code&gt;ErlIOVec&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11486f73702f77793d0c501dded54bd9d9a0b366" translate="yes" xml:space="preserve">
          <source>The ID of the handler (which is &lt;code&gt;false&lt;/code&gt; if it was registered without an ID).</source>
          <target state="translated">핸들러의 ID입니다 ( ID없이 등록 된 경우 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5910e0f627e6ac1682f658faee394e4ef0132c80" translate="yes" xml:space="preserve">
          <source>The IDs contains normal fully qualified domain names like e.g &lt;code&gt;foo.example.com&lt;/code&gt;, but IP addresses are not recommended. The rfc describes why this is not recommended as well as security considerations about how to aquire the Reference IDs.</source>
          <target state="translated">ID에는 &lt;code&gt;foo.example.com&lt;/code&gt; 과 같은 정규화 된 정규 도메인 이름이 포함 되지만 IP 주소는 권장되지 않습니다. rfc는 이것이 권장되지 않는 이유와 참조 ID를 얻는 방법에 대한 보안 고려 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b28f4dac9c4ee5d63c861a672e8fdeba64970c63" translate="yes" xml:space="preserve">
          <source>The IP addresses must be specified in the standard form (four decimal numbers separated by periods, for example, &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt;. Hosts names are not acceptable, but a broadcast address (preferably limited to the local network) is.</source>
          <target state="translated">IP 주소는 표준 형식으로 지정해야합니다 (예 : &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt; 와 같이 마침표로 구분 된 십진수 네 개) . 호스트 이름은 허용되지 않지만 브로드 캐스트 주소는 로컬 네트워크로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="74be3487335549a3ba00af3a4220139041a986e4" translate="yes" xml:space="preserve">
          <source>The Inets services API.</source>
          <target state="translated">Inets 서비스 API.</target>
        </trans-unit>
        <trans-unit id="2bd655ea5793b54cfcef1365f007ad296dab65da" translate="yes" xml:space="preserve">
          <source>The Interpret Modules window is used for selecting which modules to interpret. Initially, the window displays the modules (&lt;code&gt;erl&lt;/code&gt; files) and subdirectories of the current working directory.</source>
          <target state="translated">모듈 해석 창은 해석 할 모듈을 선택하는 데 사용됩니다. 처음에는이 창 에 현재 작업 디렉토리 의 모듈 ( &lt;code&gt;erl&lt;/code&gt; 파일) 및 하위 디렉토리가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="46568e5f2d41b68efc3d2efed445ca9d877dd874" translate="yes" xml:space="preserve">
          <source>The Kernel application has all the code necessary to run the Erlang runtime system: file servers, code servers, and so on.</source>
          <target state="translated">커널 응용 프로그램에는 Erlang 런타임 시스템을 실행하는 데 필요한 모든 코드 (파일 서버, 코드 서버 등)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2901750e4e178866aa29af00b9514d934b8cb3" translate="yes" xml:space="preserve">
          <source>The Kernel application is the first application started. It is mandatory in the sense that the minimal system based on Erlang/OTP consists of Kernel and STDLIB. Kernel contains the following functional areas:</source>
          <target state="translated">커널 응용 프로그램은 처음 시작된 응용 프로그램입니다. Erlang / OTP 기반의 최소 시스템은 Kernel과 STDLIB로 구성되어야합니다. 커널에는 다음과 같은 기능 영역이 있습니다.</target>
        </trans-unit>
        <trans-unit id="393233a88750cf4fe6f8a18919929901cb57f040" translate="yes" xml:space="preserve">
          <source>The Kernel configuration parameter &lt;code&gt;global_groups&lt;/code&gt; defines the global groups (see also &lt;code&gt;kernel(6)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">커널 구성 매개 변수 &lt;code&gt;global_groups&lt;/code&gt; 는 글로벌 그룹을 정의합니다 ( &lt;code&gt;kernel(6)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="329d0e8d9e7fbac7a43bba657580181c6f878afc" translate="yes" xml:space="preserve">
          <source>The Kernel/STDLIB applications are damaged or the start script is damaged.</source>
          <target state="translated">커널 / STDLIB 응용 프로그램이 손상되었거나 시작 스크립트가 손상되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce538f925bf84002c38fbd4dc502029a22341ac9" translate="yes" xml:space="preserve">
          <source>The Leex module should be considered experimental as it will be subject to changes in future releases.</source>
          <target state="translated">Leex 모듈은 향후 릴리스에서 변경 될 수 있으므로 실험적인 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="c848076de058785ede6b2e785124e2cf00899a54" translate="yes" xml:space="preserve">
          <source>The Linux Trace Toolkit: next generation is an open source system software package for correlated tracing of the Linux kernel, user applications and libraries.</source>
          <target state="translated">Linux Trace Toolkit : 차세대는 Linux 커널, 사용자 애플리케이션 및 라이브러리의 상관 추적을위한 오픈 소스 시스템 소프트웨어 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="9b5f802a372a8d9f81e47da8ffe942e03e117399" translate="yes" xml:space="preserve">
          <source>The Logger backend forwards log events from the API, first through a set of &lt;strong&gt;primary filters&lt;/strong&gt;, then through a set of secondary filters attached to each log handler. The secondary filters are in the following named &lt;strong&gt;handler filters&lt;/strong&gt;.</source>
          <target state="translated">로거 백엔드는 먼저 &lt;strong&gt;기본 필터&lt;/strong&gt; 세트를 통해 API에서 로그 이벤트를 전달한 다음 각 로그 핸들러에 첨부 된 보조 필터 세트를 통해 로그 이벤트를 전달 합니다. 보조 필터는 다음과 같은 명명 된 &lt;strong&gt;핸들러 필터에&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="709c2b894a55cf0a9eb1d8fa9b54a57e464ba3b7" translate="yes" xml:space="preserve">
          <source>The M-bit on a component AVP of a Grouped AVP that does not set M is ignored: such AVPs are not regarded as erroneous at decode.</source>
          <target state="translated">M을 설정하지 않은 그룹화 된 AVP의 컴포넌트 AVP에있는 M- 비트는 무시됩니다. 이러한 AVP는 디코딩시 잘못된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e65c3cb49c60d682bd3249d0c0dd54ec5a5739f" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm is &lt;strong&gt;not&lt;/strong&gt; considered safe for code-signing or software-integrity purposes.</source>
          <target state="translated">MD5 메시지 다이제스트 알고리즘은 코드 서명 또는 소프트웨어 무결성 목적으로 안전한 것으로 간주 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f776c349863aa954c934ed6333465e82a978b325" translate="yes" xml:space="preserve">
          <source>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see &lt;code&gt;supervisor:start_child&lt;/code&gt; for an explanation of the parameters).</source>
          <target state="translated">MFA 대안은 Megaco가 사용자가 작성한 스캐너를 시작하고 감독 할 수있게합니다 ( 매개 변수에 대한 설명 은 &lt;code&gt;supervisor:start_child&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1def19a97ae2b0656b00af132fb7f372cb973f9f" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 and use a provisioned MID of the MGC as the RemoteMid.</source>
          <target state="translated">MG는 명시 적으로 megaco : connect / 4를 호출하고 MGC의 프로비저닝 된 MID를 RemoteMid로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b9106067cc9059d7c61d3ebb7b2686b953f307" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 with the atom 'preliminary_mid' as a temporary MID of the MGC, send an intial message, the Service Change Request, to the MGC and then wait for an initial message, the Service Change Reply. When the reply arrives, the Megaco application will pick the MID of the MGC from the message header and automatically upgrade the connection to be a &quot;normal&quot; connection. By using this method of establishing the connection, the callback function UserMod:handle_connect/2 to be invoked twice. First with a ConnHandle with the remote_mid-field set to preliminary_mid, and then when the connection upgrade is done with the remote_mid-field set to the actual MID of the MGC.</source>
          <target state="translated">MG는 MGC의 임시 MID로서 원자 'preliminary_mid'와 함께 megaco : connect / 4를 명시 적으로 호출하고 초기 메시지 인 서비스 변경 요청을 MGC에 보낸 다음 초기 메시지 인 서비스 변경 응답을 기다릴 수 있습니다. 응답이 도착하면 Megaco 애플리케이션은 메시지 헤더에서 MGC의 MID를 선택하고 연결을 &quot;정상&quot;연결로 자동 업그레이드합니다. 이 연결 설정 방법을 사용하면 콜백 함수 UserMod : handle_connect / 2가 두 번 호출됩니다. 먼저 remote_mid-field가 preliminary_mid로 설정된 ConnHandle을 사용한 다음, remote_mid-field가 MGC의 실제 MID로 설정된 상태에서 연결 업그레이드가 완료된 경우.</target>
        </trans-unit>
        <trans-unit id="aea17cec43c433cc7d5df78c11e5155adf50c978" translate="yes" xml:space="preserve">
          <source>The MIB compiler can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.mib&lt;/code&gt;, and invokes the SNMP MIB compiler for files with that extension. The options &lt;code&gt;db&lt;/code&gt;, &lt;code&gt;group_check&lt;/code&gt;, &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;verbosity&lt;/code&gt;, &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;module_identity&lt;/code&gt; have to be specified to &lt;code&gt;erlc&lt;/code&gt; using the syntax &lt;code&gt;+term&lt;/code&gt;. See &lt;code&gt;erlc(1)&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 명령을 사용하여 OS 명령 행에서 MIB 컴파일러를 호출 할 수 있습니다 . &lt;code&gt;erlc&lt;/code&gt; 는 확장자 &lt;code&gt;.mib&lt;/code&gt; 를 인식하고 해당 확장자를 가진 파일에 대한 SNMP MIB 컴파일러를 호출합니다. 옵션 &lt;code&gt;db&lt;/code&gt; , &lt;code&gt;group_check&lt;/code&gt; , &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;description&lt;/code&gt; , &lt;code&gt;verbosity&lt;/code&gt; , &lt;code&gt;imports&lt;/code&gt; 및 &lt;code&gt;module_identity&lt;/code&gt; 는 구문 &lt;code&gt;+term&lt;/code&gt; 을 사용하여 &lt;code&gt;erlc&lt;/code&gt; 로 지정해야 합니다 . 자세한 내용은 &lt;code&gt;erlc(1)&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f52d6224012981f65b2f6681c14c8ab8b0bbf8" translate="yes" xml:space="preserve">
          <source>The MIB compiler is started with a call to &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; For example:</source>
          <target state="translated">&lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; 호출하여 MIB 컴파일러를 시작 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edd06159b7a6aba946136da4c7e4c2496fb5f976" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; statement to determine if the MIB is version 1 or 2.</source>
          <target state="translated">MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 이해합니다. 그것은 사용 &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; 의 은 MIB 버전 1 또는 2 있는지 확인하기 위해 문을.</target>
        </trans-unit>
        <trans-unit id="f45016e5e003d17ae323b899458860dc734f4ec3" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the MODULE-IDENTITY statement to determinate if the MIB is written in SMI version 1 or 2.</source>
          <target state="translated">MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 이해합니다. MIB가 SMI 버전 1 또는 2로 작성되었는지 여부를 판별하기 위해 MODULE-IDENTITY 문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd9d36a4d02e1cba5060187b622d24d58daaa77e" translate="yes" xml:space="preserve">
          <source>The MIB definition for the table looks as follows:</source>
          <target state="translated">테이블의 MIB 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3670a31f68beb5c49cf1fc0895f0360e583892d6" translate="yes" xml:space="preserve">
          <source>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language. This adapted subset is called the Structure of Management Information (SMI).</source>
          <target state="translated">MIB는 ASN.1 (Abstract Syntax Notation One) 언어의 적응 된 서브 세트로 지정됩니다. 이러한 적응 된 부분 집합을 SMI (Structure of Management Information)라고합니다.</target>
        </trans-unit>
        <trans-unit id="ddf38993bb21f6943082354919313abcba92be9e" translate="yes" xml:space="preserve">
          <source>The MIB must be written as a text file in SMIv1 or SMIv2 using an ASN.1 notation before it will be compiled. This text file must have the same name as the MIB, but with the suffix &lt;code&gt;.mib&lt;/code&gt;. This is necessary for handling the &lt;code&gt;IMPORT&lt;/code&gt; statement.</source>
          <target state="translated">MIB는 컴파일되기 전에 ASN.1 표기법을 사용하여 SMIv1 또는 SMIv2에서 텍스트 파일로 작성되어야합니다. 이 텍스트 파일은 MIB와 이름이 동일하지만 접미 부가 &lt;code&gt;.mib&lt;/code&gt; 여야합니다 . &lt;code&gt;IMPORT&lt;/code&gt; 문 을 처리하는 데 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="28b5820bae2b823215328a884121f24cdebd6ac9" translate="yes" xml:space="preserve">
          <source>The MIB table shown in the previous section can be compiled as follows:</source>
          <target state="translated">이전 섹션에 표시된 MIB 테이블은 다음과 같이 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec9b6855efdcd50624fb2152240f9d6cfd37b82" translate="yes" xml:space="preserve">
          <source>The MIB used in this example is called EX1-MIB. It contains two objects, a variable with a name and a table with friends.</source>
          <target state="translated">이 예에서 사용 된 MIB를 EX1-MIB라고합니다. 여기에는 이름이있는 변수와 친구가있는 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2036f385fe7aec6b74107075c06d9fb946e725a" translate="yes" xml:space="preserve">
          <source>The Makefile rule generated by this option looks as follows:</source>
          <target state="translated">이 옵션으로 생성 된 Makefile 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b70e5f8f89b4686cb29a4a908b91ac8e282aa8a9" translate="yes" xml:space="preserve">
          <source>The Manager sends a request to the Agent.</source>
          <target state="translated">Manager는 요청을 에이전트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46da3a78459a2791fe81dd4c8585eaa2e4cc0ded" translate="yes" xml:space="preserve">
          <source>The Master Agent decodes the incoming UDP packet.</source>
          <target state="translated">마스터 에이전트는 들어오는 UDP 패킷을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="373ff796c178ffe0a9fc192a5614c9c2aa28127a" translate="yes" xml:space="preserve">
          <source>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</source>
          <target state="translated">마스터 에이전트는 요청에서 처리해야 할 항목과 하위 에이전트로 전달할 항목을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="efae611f18882de954fb6f64727d8f6c45904beb" translate="yes" xml:space="preserve">
          <source>The Megaco client (user) starts the flex scanner (load the driver).</source>
          <target state="translated">Megaco 클라이언트 (사용자)가 플렉스 스캐너를 시작합니다 (드라이버로드).</target>
        </trans-unit>
        <trans-unit id="74b78735e0be983743300743d7f123f781d14b1d" translate="yes" xml:space="preserve">
          <source>The Megaco mib is as of yet not standardized and our implementation is based on &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;. Almost all of the mib cannot easily be implemented by the megaco application. Instead these things should be implemented by a user (of the megaco application).</source>
          <target state="translated">Megaco mib는 아직 표준화되지 않았으며 구현은 &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt; 기반입니다 . 거의 모든 mib는 megaco 응용 프로그램으로 쉽게 구현할 수 없습니다. 대신 이러한 것들은 megaco 응용 프로그램의 사용자가 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="69ce7f3a78e528729b8eeea0590643ad39f48cc1" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 application contains implementations for the two protocols specified by the Megaco/H.248 standard; UDP, see &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;, and TCP/TPKT, see &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Megaco / H.248 애플리케이션에는 Megaco / H.248 표준에 지정된 두 프로토콜에 대한 구현이 포함되어 있습니다. UDP, &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; 및 TCP / TPKT, &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aad987e822802dc01bf9dc22e5bb8ea6068aa667" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do in fact supply five different encoding/decoding modules.</source>
          <target state="translated">Megaco / H.248 표준은 일반 텍스트 인코딩과 이진 인코딩 (ASN.1 BER)을 모두 정의하며 두 가지 모두에 대해 인코더와 디코더를 구현했습니다. 우리는 실제로 5 개의 다른 인코딩 / 디코딩 모듈을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa06303bf449e60941f0fbd6f5db8a0257dfe140" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</source>
          <target state="translated">Megaco / H.248 표준은 일반 텍스트 인코딩과 이진 인코딩 (ASN.1 BER)을 모두 정의하며 두 가지 모두에 대해 인코더와 디코더를 구현했습니다. 우리는 다양한 인코딩 / 디코딩 모듈을 제공하며 사용자는 실제로 우리의 erl_dist 모듈과 같이 자체적으로 구현할 수 있습니다. 비표준 인코딩 형식을 사용하면 단점이 있지만 일부 구성에서는 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1180df526f481dbe5f0436fa1406c56c4711af67" translate="yes" xml:space="preserve">
          <source>The Mnesia DBMS can be used for storing data of SNMP tables. This means that an SNMP table can be implemented as a Mnesia table, and that a Mnesia table can be made visible via SNMP. This mapping is largely automated.</source>
          <target state="translated">Mnesia DBMS는 SNMP 테이블의 데이터를 저장하는 데 사용할 수 있습니다. 이는 SNMP 테이블이 Mnesia 테이블로 구현 될 수 있고 Mnesia 테이블이 SNMP를 통해 표시 될 수 있음을 의미합니다. 이 매핑은 대부분 자동화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a591b496e3da82473b635cc4b898494993b158a0" translate="yes" xml:space="preserve">
          <source>The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</source>
          <target state="translated">테이블로드에 대한 Mnesia 알고리즘은 테이블을로드 할 수없는 상황으로 이어질 수 있습니다. 이 상황은 노드가 시작되고 Mnesia가 시스템 충돌로 인해이 로컬 사본이 비활성화 된 후 테이블의 다른 사본이 활성화되었다고 결론을 내릴 때 또는 의심되는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e84c0c6719410c924b39a7531b144a0635ce33f" translate="yes" xml:space="preserve">
          <source>The Mnesia application provides a heavy duty real-time distributed database.</source>
          <target state="translated">Mnesia 애플리케이션은 강력한 실시간 분산 데이터베이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e31cb2dccdf565dc1ca8c735031043aeea8bc8e" translate="yes" xml:space="preserve">
          <source>The Mnesia directory is to be set to &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Mnesia 디렉토리는 &lt;code&gt;M&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="87981337ff090edb8a09d20ade88cd56c81fc2fc" translate="yes" xml:space="preserve">
          <source>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</source>
          <target state="translated">Mnesia 테이블은 트랜잭션을 사용하지 않고 조작 할 수 있습니다. 이것은 몇 가지 심각한 단점이 있지만 트랜잭션 관리자가 관여하지 않고 잠금이 설정되지 않았기 때문에 상당히 빠릅니다. 그러나 더티 작업은 일정한 수준의 일관성을 보장하며 더티 작업은 잘못된 레코드를 반환 할 수 없습니다. 모든 더티 오퍼레이션은 프로그래머에게 위치 투명성을 제공하며 프로그램은 특정 테이블의 위치를 ​​인식 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="12555ca4fb4e5c73fcfb7a6b579630e086477989" translate="yes" xml:space="preserve">
          <source>The Module, Function and/or Arity parts of the tuple may be specified as the atom &lt;code&gt;'_'&lt;/code&gt; which is a &quot;wild-card&quot; matching all modules/functions/arities. Note, if the Module is specified as &lt;code&gt;'_'&lt;/code&gt;, the Function and Arity parts have to be specified as '_' too. The same holds for the Functions relation to the Arity.</source>
          <target state="translated">튜플의 모듈, 기능 및 / 또는 Arity 부분은 모든 모듈 / 기능 / arity와 일치하는 &quot;와일드 카드&quot;인 아톰 &lt;code&gt;'_'&lt;/code&gt; 로 지정할 수 있습니다 . 모듈이 &lt;code&gt;'_'&lt;/code&gt; 로 지정된 경우 기능 및 Arity 부분도 '_'로 지정되어야합니다. Arity와의 기능 관계도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f0af3d5917bbe134a6abcdbbf9104dc4ecd4c736" translate="yes" xml:space="preserve">
          <source>The Monitor window is the main window of Debugger and displays the following:</source>
          <target state="translated">모니터 창은 디버거의 기본 창이며 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="70b4cea5e362ae717c1192bf6736623910297884" translate="yes" xml:space="preserve">
          <source>The NETCONF client is also compliant with RFC 5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the NETCONF protocol.</source>
          <target state="translated">NETCONF 클라이언트는 RFCON 5277 NETCONF 이벤트 알림도 준수합니다.이 알림은 NETCONF 프로토콜에 대한 비동기 메시지 알림 전달 서비스의 메커니즘을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="99b3461576af86b2830e124486fcb6fbe5704dd5" translate="yes" xml:space="preserve">
          <source>The NETCONF client is compliant with RFC 4741 NETCONF Configuration Protocol and RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</source>
          <target state="translated">NETCONF 클라이언트는 RF (SSH)를 통한 NETCONF 구성 프로토콜을 사용하여 RFC 4741 NETCONF 구성 프로토콜 및 RFC 4742를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8604513f6b03eececb0b12edf6062d8892eb4" translate="yes" xml:space="preserve">
          <source>The NETCONF server uses &lt;code&gt;error_logger&lt;/code&gt; for logging of NETCONF traffic. A special purpose error handler is implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;. To use this error handler, add the &lt;code&gt;cth_conn_log&lt;/code&gt; hook in the test suite, for example:</source>
          <target state="translated">NETCONF 서버는 NETCONF 트래픽 로깅에 &lt;code&gt;error_logger&lt;/code&gt; 를 사용 합니다. 특수 목적 오류 처리기는 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 에 구현됩니다 . 이 오류 핸들러를 사용하려면 테스트 스위트에 &lt;code&gt;cth_conn_log&lt;/code&gt; 후크를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d107278e1a70d51b4fdd7f40141f0fe34ee6756" translate="yes" xml:space="preserve">
          <source>The NIF library must be explicitly loaded by Erlang code in the same module.</source>
          <target state="translated">NIF 라이브러리는 동일한 모듈의 Erlang 코드에 의해 명시 적으로로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="41a4ad2b0dc5ffd6f13eaa47aa861d15ed3c8d0c" translate="yes" xml:space="preserve">
          <source>The NIFs of the module are compiled and linked into a shared library. Each NIF is implemented as a normal C function. The macro &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; together with an array of structures defines the names, arity, and function pointers of all the NIFs in the module. The header file &lt;code&gt;erl_nif.h&lt;/code&gt; must be included. As the library is a shared module, not a program, no main function is to be present.</source>
          <target state="translated">모듈의 NIF는 컴파일되어 공유 라이브러리에 링크됩니다. 각 NIF는 일반 C 함수로 구현됩니다. 매크로 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 는 배열 구조와 함께 모듈에있는 모든 NIF의 이름, 특성 및 함수 포인터를 정의합니다. 헤더 파일 &lt;code&gt;erl_nif.h&lt;/code&gt; 가 포함되어야합니다. 라이브러리는 프로그램이 아니라 공유 모듈이므로 주요 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd402b6f90d216badbbd85762e2a8ddff6c71c0f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">네트워크 인터페이스 (Net if) 프로세스는 SNMP PDU를 마스터 에이전트로 전달하고 마스터 에이전트로부터 SNMP PDU를 수신합니다. 프로세스가 네트워크에서 바이트를 수신하여 SNMP PDU로 디코딩하여 마스터 에이전트로 보내는 경우 Net의 가장 일반적인 동작입니다. 마스터 에이전트가 PDU를 처리하면 PDU를 바이트로 인코딩하고 바이트를 네트워크로 전송하는 응답 if PDU를 Net if 프로세스로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="976e6c5625eb166a7240dd083a2239c03ac8b8ec" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">네트워크 인터페이스 (Net if) 프로세스는 SNMP PDU를 관리자 서버로 전달하고 관리자 서버에서 SNMP PDU를받습니다. 프로세스가 관리자 서버로부터 요청 PDU를 수신하고 PDU를 바이트로 인코딩 한 후 바이트를 네트워크로 에이전트에게 전송하는 것이 가장 일반적인 경우 Net의 동작입니다. Net if 프로세스가 에이전트의 응답을 수신하면 SNMP PDU로 디코딩하여 관리자 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e3ad1933c4b353741e7d3dd411a4625d945e51b1" translate="yes" xml:space="preserve">
          <source>The OAM components, and some other OTP applications, define SNMP MIBs. These MIBs are written in SNMPv2 SMI syntax, as defined in RFC 1902. For convenience we also deliver the SNMPv1 SMI equivalent. All MIBs are designed to be v1/v2 compatible, that is, the v2 MIBs do not use any construct not available in v1.</source>
          <target state="translated">OAM 구성 요소 및 일부 다른 OTP 응용 프로그램은 SNMP MIB를 정의합니다. 이러한 MIB는 RFC 1902에 정의 된대로 SNMPv2 SMI 구문으로 작성되었습니다. 편의를 위해 SNMPv1 SMI도 제공합니다. 모든 MIB는 v1 / v2와 호환되도록 설계되었습니다. 즉, v2 MIB는 v1에서 사용할 수없는 구성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfa71a1f0f4b6ee0f7da7bee6b28148c4530dbc7" translate="yes" xml:space="preserve">
          <source>The OS failed to load the NIF library.</source>
          <target state="translated">OS가 NIF 라이브러리를로드하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="6c43c2d0328ac7bd67f0bc31e296a2b1639ba6e7" translate="yes" xml:space="preserve">
          <source>The OTP mibs are stored in the &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; directory. They are defined in SNMPv2 SMI syntax. An SNMPv1 version of the mib is delivered in the &lt;code&gt;mibs/v1&lt;/code&gt; directory. The compiled MIB is located under &lt;code&gt;priv/mibs&lt;/code&gt;, and the generated &lt;code&gt;.hrl&lt;/code&gt; file under the &lt;code&gt;include&lt;/code&gt; directory. To compile a MIB that IMPORTS a MIB in the OTP_Mibs application, give the option &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; to the MIB compiler.</source>
          <target state="translated">OTP &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; 은 $ OTP_ROOT / lib / otp_mibs / mibs / 디렉토리에 저장됩니다. 이들은 SNMPv2 SMI 구문으로 정의됩니다. mib의 SNMPv1 버전은 &lt;code&gt;mibs/v1&lt;/code&gt; 디렉토리에 제공됩니다. 컴파일 된 MIB는 &lt;code&gt;priv/mibs&lt;/code&gt; 아래에 &lt;code&gt;include&lt;/code&gt; 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일은 include 디렉토리 아래에 있습니다 . OTP_Mibs 애플리케이션에서 MIB를 가져 오는 MIB를 컴파일하려면 옵션 &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; 을 MIB 컴파일러에 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ef0289a2a348b65c119233c8ade03f223f5c8802" translate="yes" xml:space="preserve">
          <source>The OTP release that the currently executing ERTS application is part of, as an integer. For details, see &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;. This macro was introduced in OTP release 21.</source>
          <target state="translated">현재 실행중인 ERTS 애플리케이션의 일부인 OTP 릴리스는 정수입니다. 자세한 내용은 &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; 참조하십시오 . 이 매크로는 OTP 릴리스 21에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="16e1639b18798e91125ecf1f057060589779b23c" translate="yes" xml:space="preserve">
          <source>The OTP-MIB mib represents information about Erlang nodes such as node name, number of running processes, virtual machine version etc. If the MIB should be used in a system, it should be loaded into an SNMP agent by using the API function &lt;code&gt;otp_mib:load/1&lt;/code&gt;.</source>
          <target state="translated">OTP-MIB mib는 노드 이름, 실행중인 프로세스 수, 가상 머신 버전 등과 같은 Erlang 노드에 대한 정보를 나타냅니다. MIB를 시스템에서 사용해야하는 경우 API 기능 &lt;code&gt;otp_mib:load/1&lt;/code&gt; 사용하여 SNMP 에이전트에로드해야합니다 . 로드 / 1 .</target>
        </trans-unit>
        <trans-unit id="1d079c6127c093fd0bf885dc8ec3e524eee2389b" translate="yes" xml:space="preserve">
          <source>The OTP-REG mib defines the unique OTP subtree of object identifiers under the Ericsson subtree. Under the OTP subtree several object identifiers are defined. This module is typically included by OTP applications defining their own mibs, or ASN.1 modules in general, that require unique object identifiers under the OTP subtree.</source>
          <target state="translated">OTP-REG mib는 Ericsson 하위 트리 아래에서 객체 식별자의 고유 한 OTP 하위 트리를 정의합니다. OTP 하위 트리 아래에 여러 개체 식별자가 정의되어 있습니다. 이 모듈은 일반적으로 OTP 하위 트리 아래에 고유 한 객체 식별자가 필요한 자체 MIB 또는 일반적으로 ASN.1 모듈을 정의하는 OTP 응용 프로그램에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4e2e6abc0df4b67e259520ad92410685d1db8d" translate="yes" xml:space="preserve">
          <source>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before standard MIBs existed for access control, MIB views, and trap target specification. All objects in this MIB are now obsolete.</source>
          <target state="translated">OTP-SNMPEA-MIB는 표준 MIB가 액세스 제어, MIB보기 및 트랩 대상 스펙을 위해 존재하기 전에 에이전트의 이전 버전에서 사용되었습니다. 이 MIB의 모든 객체는 이제 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="dfdf456ec73d4195574c470386dbc5ef95b5e4be" translate="yes" xml:space="preserve">
          <source>The OTP-TC mib provides the textual convention datatype &lt;code&gt;OwnerString&lt;/code&gt;.</source>
          <target state="translated">OTP-TC mib는 텍스트 규칙 데이터 유형 &lt;code&gt;OwnerString&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="370c0fa4230350b45a2bed8b159298418299327c" translate="yes" xml:space="preserve">
          <source>The Observer application is a container including the following tools for tracing and investigation of distributed systems:</source>
          <target state="translated">옵저버 애플리케이션은 분산 시스템의 추적 및 조사를위한 다음 도구를 포함하는 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="e53532ab978b0a1e5f72db0836d60dcb2627de7d" translate="yes" xml:space="preserve">
          <source>The Observer application is available on the trace control node.</source>
          <target state="translated">관찰자 애플리케이션은 추적 제어 노드에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="acca74abfba6c1293f4de6924079a0d77446f3db" translate="yes" xml:space="preserve">
          <source>The Observer application might not always be available on the node to be traced (in the following called the &quot;traced node&quot;). However, Trace Tool Builder can still be run from another node (in the following called the &quot;trace control node&quot;) as long as the following is fulfilled:</source>
          <target state="translated">추적 할 노드에서 관찰자 응용 프로그램을 항상 사용할 수있는 것은 아닙니다 (이하 &quot;추적 노드&quot;라고 함). 그러나 다음을 충족하는 한 추적 도구 작성기를 다른 노드 (이하 &quot;추적 제어 노드&quot;)에서 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40509725b1b94ac04bace7fdcf93e38e06d1990b" translate="yes" xml:space="preserve">
          <source>The Operation and Maintenance (OAM) support in OTP consists of a generic model for management subsystems in OTP, and some components to be used in these subsystems. This section describes the model.</source>
          <target state="translated">OTP의 OAM (Operation and Maintenance) 지원은 OTP의 관리 서브 시스템 및이 서브 시스템에서 사용되는 일부 구성 요소에 대한 일반 모델로 구성됩니다. 이 섹션에서는 모델에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="808ca5db0eed6b5828cf7aea959f1c6d4f421b35" translate="yes" xml:space="preserve">
          <source>The P flag has been deprecated by RFC 6733.</source>
          <target state="translated">P 플래그는 RFC 6733에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521a731b4b96b784ec12d6942621ae176f880a6a" translate="yes" xml:space="preserve">
          <source>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If &lt;code&gt;{error, match_limit}&lt;/code&gt; is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a &lt;code&gt;nomatch&lt;/code&gt;, which is the default return value when this occurs, but by specifying &lt;code&gt;report_errors&lt;/code&gt;, you are informed when the match fails because of too many internal calls.</source>
          <target state="translated">PCRE 라이브러리는 내부 일치 함수를 호출 할 수있는 횟수를 제한합니다. Erlang 용으로 컴파일 된 라이브러리에서 기본값은 10,000,000입니다. 경우 &lt;code&gt;{error, match_limit}&lt;/code&gt; 반환되고, 정규 표현식의 실행이 한계에 도달했습니다. 이것은 일반적으로 &lt;code&gt;nomatch&lt;/code&gt; 로 간주되며, 이것이 발생할 때의 기본 반환 값이지만 &lt;code&gt;report_errors&lt;/code&gt; 를 지정 하면 내부 호출이 너무 많아서 일치가 실패하면 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="315aa4b073a3e51b4182d67ae5a99c3e8dd60122" translate="yes" xml:space="preserve">
          <source>The PCRE-specific options &lt;code&gt;dupnames&lt;/code&gt;, &lt;code&gt;ungreedy&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt; can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively.</source>
          <target state="translated">PCRE 특정 옵션 &lt;code&gt;dupnames&lt;/code&gt; , &lt;code&gt;ungreedy&lt;/code&gt; 및 &lt;code&gt;extra&lt;/code&gt; 는 각각 J, U 및 X 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b60700ebcda31fdb446fa71f372ef2af6d7bcce" translate="yes" xml:space="preserve">
          <source>The PLT is built using option &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer. The following command builds the recommended minimal PLT for Erlang/OTP:</source>
          <target state="translated">PLT는 &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer 옵션을 사용하여 빌드됩니다 . 다음 명령은 Erlang / OTP에 권장되는 최소 PLT를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="068bb5f6b3073467febaec97d8dca8e259a70b70" translate="yes" xml:space="preserve">
          <source>The PLT is extended to also include the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. Use &lt;code&gt;--plt&lt;/code&gt; to specify which PLT to start from, and &lt;code&gt;--output_plt&lt;/code&gt; to specify where to put the PLT. Notice that the analysis possibly can include files from the PLT if they depend on the new files. This option only works for BEAM files.</source>
          <target state="translated">PLT는 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일도 포함하도록 확장되었습니다 . 사용 &lt;code&gt;--plt&lt;/code&gt; 을 부터 시작하는 PLT 지정하고 &lt;code&gt;--output_plt&lt;/code&gt; 곳 PLT를 넣어하는 지정할 수 있습니다. 새 파일에 의존하는 경우 PLT의 파일이 분석에 포함될 수 있습니다. 이 옵션은 BEAM 파일에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a5ac14853a9b086e8f452912a23bfe90221af508" translate="yes" xml:space="preserve">
          <source>The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.</source>
          <target state="translated">Perl 문서에는 (? {}) 또는 (?? {})와 결합 할 때만 유용 할 수 있다고 명시되어 있습니다. PCRE에는없는 Perl 기능입니다.</target>
        </trans-unit>
        <trans-unit id="05f38ed5f44cf6a58fcb55ac9b9ba9cb03970efa" translate="yes" xml:space="preserve">
          <source>The ProtocolVersion version is the version actually encoded in the reply message.</source>
          <target state="translated">ProtocolVersion 버전은 실제로 응답 메시지에 인코딩 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="544a356532db2cd2759e24c6723c4194d33f11f5" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="translated">공개 키 응용 프로그램은 공개 키 관련 파일 형식, 디지털 서명 및 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt; 합니다. 인코딩 / 디코딩, 서명 / 확인, 암호화 / 복호화 및 유사한 기능을 제공하는 라이브러리 응용 프로그램입니다. 파일을 읽거나 쓰지 않고 파일 내용 또는 부분 파일 내용을 바이너리로 기대하거나 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ebdf434e84c8ed49f35713ff4853c27de0d8e82" translate="yes" xml:space="preserve">
          <source>The Public Key decode- and encode-functions try to use the NIFs in the ASN.1 compilers runtime modules, if they can be found. Thus, to have the ASN1 application in the path of your system gives the best performance.</source>
          <target state="translated">공개 키 디코드 및 인코딩 함수는 ASN.1 컴파일러 런타임 모듈에서 NIF를 찾을 수 있으면이를 사용하려고합니다. 따라서 ASN1 응용 프로그램을 시스템 경로에두면 최상의 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe14f45b872852caa29e8e8cc7c7d6e2482faaf" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog state machine has transitioned into (&lt;code&gt;up&lt;/code&gt;) or out of (&lt;code&gt;down&lt;/code&gt;) the OKAY state. If a &lt;code&gt;#diameter_packet{}&lt;/code&gt; is present in an &lt;code&gt;up&lt;/code&gt; event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</source>
          <target state="translated">RFC 3539 워치 독 상태 머신이 OKAY 상태 로 전환 ( &lt;code&gt;up&lt;/code&gt; ) 또는 아웃 ( &lt;code&gt;down&lt;/code&gt; )되었습니다. 경우 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 에 존재하는 &lt;code&gt;up&lt;/code&gt; 이벤트 다음 기능 신설 전송 연결 교환 레코드가 수신 CER 또는 CEA가 포함되고있다.</target>
        </trans-unit>
        <trans-unit id="dc64b0c1b30970fb85a8fe63a3336e6b7a09937b" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of &amp;plusmn; 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</source>
          <target state="translated">RFC 3539 워치 독 타이머. 정수 값은 RFC의 TwInit (밀리 초)로 해석되며, RFC의 Tw를 계산하기 위해 타이머를 다시 연결할 때마다 &amp;plusmn; 2 초의 지터가 추가됩니다. MFA는 지터가 적용된 상태에서 RFC의 Tw를 직접 반환하므로 콜백에서 지터 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc9e80a4124e3a42a057c7e5dbba54abf671c72" translate="yes" xml:space="preserve">
          <source>The RFC states that if a certificate defines Reference IDs in a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field MUST NOT be used for host name checking, even if it contains valid CN names. Therefore only &lt;code&gt;kb.example.org&lt;/code&gt; and &lt;code&gt;https://www.example.org&lt;/code&gt; matches. The match fails both for &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;foo.example.com&lt;/code&gt; becuase they are in the &lt;code&gt;Subject&lt;/code&gt; field which is not checked because the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field is present.</source>
          <target state="translated">RFC는 인증서가 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드 에 참조 ID를 정의하는 경우 &lt;code&gt;Subject&lt;/code&gt; 필드에 유효한 CN 이름이 포함되어 있어도 호스트 이름 확인에 사용해서는 안된다고 명시하고 있습니다. 따라서 &lt;code&gt;kb.example.org&lt;/code&gt; 및 &lt;code&gt;https://www.example.org&lt;/code&gt; 만 일치합니다. 경기는 모두 실패 &lt;code&gt;example.com&lt;/code&gt; 과 &lt;code&gt;foo.example.com&lt;/code&gt; 을 그들이에 becuase &lt;code&gt;Subject&lt;/code&gt; 때문에 선택하지 않은 필드 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8707a6b8a6bbf5e67f47a831acd5b638d6ca82c3" translate="yes" xml:space="preserve">
          <source>The Report Browser (RB) tool is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; in STDLIB.</source>
          <target state="translated">RB (보고서 브라우저) 도구는 &lt;code&gt;log_mf_h&lt;/code&gt; 의 오류 로거 핸들러 log_mf_h 에 의해 작성된 오류 보고서를 찾아보고 형식화하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e200f59605a43a83406a6a1c3aae57938231fe10" translate="yes" xml:space="preserve">
          <source>The Report Browser Tool</source>
          <target state="translated">보고서 브라우저 도구</target>
        </trans-unit>
        <trans-unit id="4692a2cbc9da1318b1c32468112fcf231936c7b1" translate="yes" xml:space="preserve">
          <source>The Runtime_Tools application is available on both the trace control node and the traced node.</source>
          <target state="translated">Runtime_Tools 애플리케이션은 추적 제어 노드와 추적 노드 모두에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3e6f6adc881738e4e882b8995898a6ee34ae6866" translate="yes" xml:space="preserve">
          <source>The SASL application introduces three types of reports:</source>
          <target state="translated">SASL 응용 프로그램에는 세 가지 유형의 보고서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66565cf9194d0ac12d200f8341003bfd8ef9840" translate="yes" xml:space="preserve">
          <source>The SASL application provides support for:</source>
          <target state="translated">SASL 애플리케이션은 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d6eac0a2617b8363f4e9ff21a3e5cf89ae6de35c" translate="yes" xml:space="preserve">
          <source>The SASL error logging concept described in this section is deprecated since Erlang/OTP 21.0, when the new &lt;code&gt;logging API&lt;/code&gt; was introduced.</source>
          <target state="translated">이 섹션에 설명 된 SASL 오류 로깅 개념은 새 &lt;code&gt;logging API&lt;/code&gt; 가 도입 되었을 때 Erlang / OTP 21.0부터 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06f440d4cdd560b9a71ad7c9c8906b6fd30020a0" translate="yes" xml:space="preserve">
          <source>The SAX events that are sent to the user via the callback.</source>
          <target state="translated">콜백을 통해 사용자에게 전송되는 SAX 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="6c62591fcbde98f13b883726ae2b16d26e6fd6e4" translate="yes" xml:space="preserve">
          <source>The SMP emulator (introduced in R11B) takes advantage of a multi-core or multi-CPU computer by running several Erlang scheduler threads (typically, the same as the number of cores). Each scheduler thread schedules Erlang processes in the same way as the Erlang scheduler in the non-SMP emulator.</source>
          <target state="translated">R11B에 도입 된 SMP 에뮬레이터는 여러 Erlang 스케줄러 스레드 (일반적으로 코어 수와 동일)를 실행하여 멀티 코어 또는 멀티 CPU 컴퓨터를 활용합니다. 각 스케줄러 스레드는 비 SMP 에뮬레이터의 Erlang 스케줄러와 동일한 방식으로 Erlang 프로세스를 스케줄합니다.</target>
        </trans-unit>
        <trans-unit id="886a9eb3b2cede92a51b83a792de6e157b89118c" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional Sub-agents.</source>
          <target state="translated">SNMP 에이전트 시스템은 하나의 마스터 에이전트와 선택적 하위 에이전트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7abe087b7edee22ce1a0361250a19799bdfe6153" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional sub-agents. The Master Agent can be seen as a special kind of sub-agent. It implements the core agent functionality, UDP packet processing, type checking, access control, trap distribution, and so on. From a user perspective, it is used as an ordinary sub-agent.</source>
          <target state="translated">SNMP 에이전트 시스템은 하나의 마스터 에이전트와 선택적 하위 에이전트로 구성됩니다. 마스터 에이전트는 특수한 종류의 하위 에이전트로 볼 수 있습니다. 핵심 에이전트 기능, UDP 패킷 처리, 유형 검사, 액세스 제어, 트랩 분배 등을 구현합니다. 사용자 관점에서 일반 하위 에이전트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3265cc19f00c49d8349eff44b143ef435848cde4" translate="yes" xml:space="preserve">
          <source>The SNMP agent toolkit gets input from three different sources:</source>
          <target state="translated">SNMP 에이전트 툴킷은 세 가지 소스에서 입력을받습니다.</target>
        </trans-unit>
        <trans-unit id="516cef785b21f525314dd4769fb5d4a3d8e52b36" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the agent is one. This function starts the agent entity of the application.</source>
          <target state="translated">SNMP 응용 프로그램은 여러 엔티티로 구성되며 에이전트는 하나입니다. 이 기능은 응용 프로그램의 에이전트 엔티티를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5a5e7e85ae81bf01406a4eba00ac814b17f5f063" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the manager is one. This function starts the manager entity of the application.</source>
          <target state="translated">SNMP 응용 프로그램은 여러 엔티티로 구성되며 관리자는 하나입니다. 이 기능은 응용 프로그램의 관리자 엔티티를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1c525a15cd833eca106834a5297df8dd9f3d8e99" translate="yes" xml:space="preserve">
          <source>The SNMP application should be used to start an SNMP agent. Then the API functions below can be used to load/unload the OTP-MIB into/from the agent. The instrumentation of the OTP-MIB uses Mnesia, hence Mnesia must be started prior to loading the OTP-MIB.</source>
          <target state="translated">SNMP 응용 프로그램을 사용하여 SNMP 에이전트를 시작해야합니다. 그런 다음 아래 API 기능을 사용하여 에이전트에 OTP-MIB를로드 / 언로드 할 수 있습니다. OTP-MIB의 계측에는 Mnesia가 사용되므로 OTP-MIB를로드하기 전에 Mnesia를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="efcaf71f311ac8ed0a4c853a395724aa7b68ecca" translate="yes" xml:space="preserve">
          <source>The SNMP built-in database</source>
          <target state="translated">SNMP 내장 데이터베이스</target>
        </trans-unit>
        <trans-unit id="1f9b4daeb0c18439d5ab9d3febb86ba8cf3f41bc" translate="yes" xml:space="preserve">
          <source>The SNMP development tool provides an environment for rapid agent/manager prototyping and construction. With the following information provided, this tool is used to set up a running multi-lingual SNMP agent/manager:</source>
          <target state="translated">SNMP 개발 도구는 신속한 에이전트 / 관리자 프로토 타이핑 및 구성을위한 환경을 제공합니다. 다음 정보가 제공되면이 도구는 실행중인 다국어 SNMP 에이전트 / 관리자를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4042139e11f084c5315473eee5bae69ee58a652c" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit contains the following parts:</source>
          <target state="translated">SNMP 개발 툴킷에는 다음과 같은 부분이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c676c0d7043a8420fb555224be79bdf5a57f0b38" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit works with all three versions of Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3. They all share the same basic structure and components. And they follow the same architecture.</source>
          <target state="translated">SNMP 개발 툴킷은 세 가지 버전의 Standard Internet Management Framework 모두에서 작동합니다. SNMPv1, SNMPv2 및 SNMPv3. 그것들은 모두 동일한 기본 구조와 구성 요소를 공유합니다. 그리고 그들은 같은 아키텍처를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4c98874c0a92d51a9659461230a55d2c1a730338" translate="yes" xml:space="preserve">
          <source>The SNMP-COMMUNITY-MIB defines managed objects that is used for coexistence between SNMPv1 and SNMPv2c with SNMPv3. Specifically, it contains objects for mapping between community strings and version-independent SNMP message parameters. In addition, this MIB provides a mechanism for performing source address validation on incoming requests, and for selecting community strings based on target addresses for outgoing notifications.</source>
          <target state="translated">SNMP-COMMUNITY-MIB는 SNMPv1과 SNMPv2c와 SNMPv3의 공존에 사용되는 관리 객체를 정의합니다. 특히, 커뮤니티 문자열과 버전 독립적 SNMP 메시지 매개 변수 사이의 맵핑을위한 오브젝트를 포함합니다. 또한이 MIB는 수신 요청에서 소스 주소 유효성 검증을 수행하고 발신 알림의 대상 주소를 기반으로 커뮤니티 문자열을 선택하기위한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8668c117c3657ad50b4bac1040aadc9d90558e41" translate="yes" xml:space="preserve">
          <source>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional read-only managed objects, which is used in the generic SNMP framework defined in RFC2271 and the generic message processing and dispatching module defined in RFC2272. They are generic in the sense that they are not tied to any specific SNMP version.</source>
          <target state="translated">SNMP-FRAMEWORK-MIB 및 SNMP-MPD-MIB는 RFC2271에 정의 된 일반 SNMP 프레임 워크 및 RFC2272에 정의 된 일반 메시지 처리 및 디스패치 모듈에서 사용되는 추가 읽기 전용 관리 객체를 정의합니다. 특정 SNMP 버전과 연결되어 있지 않다는 점에서 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="45b5b2d3e04821e69bc6b70c4958af997f02dac7" translate="yes" xml:space="preserve">
          <source>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed objects for configuration of notification receivers. They are described in detail in RFC2273. Only a brief description is given here.</source>
          <target state="translated">SNMP-TARGET-MIB 및 SNMP-NOTIFICATION-MIB는 알림 수신자 구성을위한 관리 대상 객체를 정의합니다. RFC2273에 자세히 설명되어 있습니다. 여기에는 간단한 설명 만 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8ba60d5c67646e6a39ec77ff47623898401ff5" translate="yes" xml:space="preserve">
          <source>The SNMP-USER-BASED-SM-MIB defines managed objects that is used for the User-Based Security Model.</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB는 사용자 기반 보안 모델에 사용되는 관리 대상 개체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="06a4a7a167128e9dfbd7bbf5787fec903cb71f3c" translate="yes" xml:space="preserve">
          <source>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to control access to the the managed objects for the managers. The View Based Access Control Module (VACM) can be used with any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, the SNMP-COMMUNITY-MIB defines additional objects to map community strings to VACM parameters.</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB는 관리 대상 개체를 정의하여 관리자의 관리 대상 개체에 대한 액세스를 제어합니다. VAM (View Based Access Control Module)은 모든 SNMP 버전과 함께 사용할 수 있습니다. 그러나 SNMPv1 또는 SNMPv2c와 함께 사용되는 경우 SNMP-COMMUNITY-MIB는 커뮤니티 문자열을 VACM 매개 변수에 맵핑하기 위해 추가 오브젝트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf1237e4f8f3b9ace0c3f4bf9ded6dcb4f4634bb" translate="yes" xml:space="preserve">
          <source>The SNMPv3 specifications take a modular approach to SNMP. All modules are separated from each other, and can be extended or replaced individually. Examples of modules are Message definition, Security and Access Control. The main features of SNMPv3 are:</source>
          <target state="translated">SNMPv3 사양은 SNMP에 모듈 방식으로 접근합니다. 모든 모듈은 서로 분리되어 있으며 개별적으로 확장하거나 교체 할 수 있습니다. 모듈의 예로는 메시지 정의, 보안 및 액세스 제어가 있습니다. SNMPv3의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49091ee8eff63f8735f82d85f410f0e974abd772" translate="yes" xml:space="preserve">
          <source>The SSH Authentication Protocol is a general-purpose user authentication protocol run over the SSH Transport Layer Protocol. The &lt;code&gt;ssh&lt;/code&gt; application supports user authentication as follows:</source>
          <target state="translated">SSH 인증 프로토콜은 SSH 전송 계층 프로토콜을 통해 실행되는 범용 사용자 인증 프로토콜입니다. &lt;code&gt;ssh&lt;/code&gt; 를 응용 프로그램이 지원하는 사용자 인증은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="7b0b1cec477594d6b882874c149d3fa88e25a3ad" translate="yes" xml:space="preserve">
          <source>The SSH Connection Protocol provides application-support services over the transport pipe, for example, channel multiplexing, flow control, remote program execution, signal propagation, and connection forwarding. Functions for handling the SSH Connection Protocol can be found in the module &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH 연결 프로토콜은 전송 파이프를 통해 응용 프로그램 지원 서비스 (예 : 채널 멀티플렉싱, 흐름 제어, 원격 프로그램 실행, 신호 전파 및 연결 전달)를 제공합니다. SSH 연결 프로토콜을 처리하는 기능 은 &lt;code&gt;ssh&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; 모듈에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="509aa3afb50ca256dde1f08abd1d170febe86fc9" translate="yes" xml:space="preserve">
          <source>The SSH Transport Protocol is a secure, low-level transport. It provides strong encryption, cryptographic host authentication, and integrity protection. A minimum of Message Authentication Code (MAC) and encryption algorithms are supported. For details, see the &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; manual page in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH 전송 프로토콜은 안전한 저수준 전송입니다. 강력한 암호화, 암호화 호스트 인증 및 무결성 보호 기능을 제공합니다. 최소 MAC (Message Authentication Code) 및 암호화 알고리즘이 지원됩니다. 자세한 내용은 참조 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; 의 매뉴얼 페이지 &lt;code&gt;ssh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24d33b22db4cc904f86f4d5db9025bf058eaf503" translate="yes" xml:space="preserve">
          <source>The SSL/TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">SSL / TLS 분배 옵션은 노드가 시작될 때 참조되는 파일에 기록 될 수 있습니다. 그런 다음이 파일 이름은 명령 행 인수 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="555d2ccf08ac60c2e06799bc61b70df2c88b6a2f" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">Solaris (SunOS 5.x) 메시지는 syslog-daemon &lt;code&gt;syslogd&lt;/code&gt; 에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="23097a6cf28465a184806bf15474a12dff162d12" translate="yes" xml:space="preserve">
          <source>The Standard Erlang Libraries application, &lt;strong&gt;STDLIB&lt;/strong&gt;, is mandatory in the sense that the minimal system based on Erlang/OTP consists of &lt;strong&gt;STDLIB&lt;/strong&gt; and &lt;strong&gt;Kernel&lt;/strong&gt;.</source>
          <target state="translated">표준 Erlang 라이브러리 어플리케이션 인 &lt;strong&gt;STDLIB&lt;/strong&gt; 는 Erlang / OTP 기반의 최소 시스템이 &lt;strong&gt;STDLIB&lt;/strong&gt; 및 &lt;strong&gt;Kernel&lt;/strong&gt; 로 구성된다는 점에서 필수적입니다 .</target>
        </trans-unit>
        <trans-unit id="5c2a74e481bb59b29d7198edb8d96d6f22f60622" translate="yes" xml:space="preserve">
          <source>The System Under Test (SUT) can consist of one or more target nodes. &lt;code&gt;Common Test&lt;/code&gt; contains a generic test server that, together with other test utilities, is used to perform test case execution. The tests can be started from a GUI, from the OS shell, or from an Erlang shell. &lt;strong&gt;Test suites&lt;/strong&gt; are files (Erlang modules) that contain the &lt;strong&gt;test cases&lt;/strong&gt; (Erlang functions) to be executed. &lt;strong&gt;Support modules&lt;/strong&gt; provide functions that the test cases use to do the tests.</source>
          <target state="translated">SUT (System Under Test)는 하나 이상의 대상 노드로 구성 될 수 있습니다. &lt;code&gt;Common Test&lt;/code&gt; 에는 다른 테스트 유틸리티와 함께 ​​테스트 케이스 실행을 수행하는 일반 테스트 서버가 포함되어 있습니다. 테스트는 GUI, OS 셸 또는 Erlang 셸에서 시작할 수 있습니다. &lt;strong&gt;테스트 스위트&lt;/strong&gt; 는 실행할 &lt;strong&gt;테스트 케이스&lt;/strong&gt; (Erlang 함수)를 포함하는 파일 (Erlang 모듈)입니다 . &lt;strong&gt;지원 모듈&lt;/strong&gt; 은 테스트 사례가 테스트를 수행하는 데 사용하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eb87875630edf563277392030eee430765ee9a3b" translate="yes" xml:space="preserve">
          <source>The TCP/IP &lt;code&gt;epmd&lt;/code&gt; daemon only keeps track of the &lt;code&gt;Name&lt;/code&gt; (first) part of an Erlang node name. The &lt;code&gt;Host&lt;/code&gt; part (whatever is after the &lt;code&gt;@&lt;/code&gt;) is implicit in the node name where the &lt;code&gt;epmd&lt;/code&gt; daemon was contacted, as is the IP address where the Erlang node can be reached. Consistent and correct TCP naming services are therefore required for an Erlang network to function correctly.</source>
          <target state="translated">TCP / IP &lt;code&gt;epmd&lt;/code&gt; 데몬 은 Erlang 노드 이름 의 &lt;code&gt;Name&lt;/code&gt; (첫 번째) 부분 만 추적 합니다. &lt;code&gt;Host&lt;/code&gt; (후 뭐든 부 &lt;code&gt;@&lt;/code&gt; 는 )이 노드 이름에 내재적 인 &lt;code&gt;epmd&lt;/code&gt; 와 얼랑 노드가 도달 할 수있는 IP 어드레스이고, 데몬 접촉시켰다. 따라서 Erlang 네트워크가 올바르게 작동하려면 일관되고 올바른 TCP 이름 지정 서비스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="058df102c079061352735c937be80bdb1a45818f" translate="yes" xml:space="preserve">
          <source>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</source>
          <target state="translated">TCP / IP 배포는 연결 기반 프로토콜을 기대하는 핸드 셰이크를 사용합니다. 즉, 핸드 셰이크 절차 후에 프로토콜에 인증이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6657b1618f0a92c332d5f9a74326d92f2550bf02" translate="yes" xml:space="preserve">
          <source>The TCP_NODELAY option for the telnet socket is disabled (set to &lt;code&gt;false&lt;/code&gt;) per default</source>
          <target state="translated">텔넷 소켓의 TCP_NODELAY 옵션 은 기본적으로 비활성화되어 있습니다 ( &lt;code&gt;false&lt;/code&gt; 로 설정 됨 )</target>
        </trans-unit>
        <trans-unit id="27af0d178d9d81560da76e1bb5028c47f5e6d47a" translate="yes" xml:space="preserve">
          <source>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function &lt;code&gt;info/1&lt;/code&gt;).</source>
          <target state="translated">데몬이 수신하는 TFTP 포트입니다. 기본값은 표준화 된 숫자 69입니다. 서버 측에서는 때때로 0으로 설정하는 것이 합리적 일 수 있습니다. 즉, 데몬은 사용 가능한 포트 (기능 &lt;code&gt;info/1&lt;/code&gt; 의해 리턴 된 포트) 만 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="75ccd2ece5259566f90ebb1a8f2c68746b4c7b93" translate="yes" xml:space="preserve">
          <source>The TLS/DTLS handshake protocol and data transfer is run on top of the TLS/DTLS Record Protocol, which uses a keyed-hash Message Authenticity Code (MAC), or a Hash-based MAC (HMAC), to protect the message data integrity. From the TLS RFC: &quot;A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.&quot;</source>
          <target state="translated">TLS / DTLS 핸드 셰이크 프로토콜 및 데이터 전송은 메시지 데이터 무결성을 보호하기 위해 키 해시 MAC (메시지 인증 코드) 또는 HMAC (해시 기반 MAC)를 사용하는 TLS / DTLS 레코드 프로토콜 위에서 실행됩니다. . TLS RFC에서 : &quot;메시지 인증 코드는 메시지와 일부 비밀 데이터에서 계산 된 단방향 해시입니다. 비밀 데이터를 몰라도 위조하기가 어렵습니다. 메시지의 변경 여부를 감지하는 것입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ecf685e6c13939907b870d82ee6d0c05ec6e094e" translate="yes" xml:space="preserve">
          <source>The Text Based Trace Facility</source>
          <target state="translated">텍스트 기반 추적 기능</target>
        </trans-unit>
        <trans-unit id="e8fd67f45550805b41375cc84bc114e897e3206a" translate="yes" xml:space="preserve">
          <source>The Trace Tool Builder, &lt;code&gt;ttb&lt;/code&gt;, is a base for building trace tools for distributed systems.</source>
          <target state="translated">추적 도구 작성기 ( &lt;code&gt;ttb&lt;/code&gt; )는 분산 시스템 의 추적 도구를 작성 하기위한 기반입니다.</target>
        </trans-unit>
        <trans-unit id="64d22e790fe528bf704a212bc1e1c0da643a949f" translate="yes" xml:space="preserve">
          <source>The Trace area also displays Back Trace, a summary of the current function calls on the stack.</source>
          <target state="translated">추적 영역에는 스택의 현재 함수 호출에 대한 요약 인 역 추적도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b692df8320088d88e275d851ad60786d4e949a1f" translate="yes" xml:space="preserve">
          <source>The Trace area, which displays a trace output for the process.</source>
          <target state="translated">프로세스의 추적 출력을 표시하는 추적 영역.</target>
        </trans-unit>
        <trans-unit id="1b50d3d2fc04c4411539dfbb6e62512f2efa0130" translate="yes" xml:space="preserve">
          <source>The Trivial File Transfer Protocol or TFTP is a very simple protocol used to transfer files.</source>
          <target state="translated">TFTP (Trivial File Transfer Protocol)는 파일을 전송하는 데 사용되는 매우 간단한 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="bf89156ef59750c4bb77ca15635b355ebce24e10" translate="yes" xml:space="preserve">
          <source>The Types are:</source>
          <target state="translated">유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ea556d1f13405f24d60defd343780b8d63e1882" translate="yes" xml:space="preserve">
          <source>The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">URL을 요청하기 전에 클라이언트가 있었던 URL (알 수없는 경우이 필드에 빼기 부호가 표시됨)</target>
        </trans-unit>
        <trans-unit id="2cd23bacb56d43630d70d816af467c37a05ab674" translate="yes" xml:space="preserve">
          <source>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; was not &lt;code&gt;NULL&lt;/code&gt;-terminated on older releases.</source>
          <target state="translated">UTF-8 변형은 Erlang / OTP R16에 도입되었으며 &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; 에 의해 리턴 된 문자열 은 이전 릴리스에서 &lt;code&gt;NULL&lt;/code&gt; 로 종료되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="615107616ab4a2ac637d22a3e97ccf0d1ff89d56" translate="yes" xml:space="preserve">
          <source>The Unicode characters need to be processed by the Erlang program, which is why library functions must be able to handle them. In some cases functionality has been added to already existing interfaces (as the &lt;code&gt;string&lt;/code&gt; module now can handle strings with any code points). In some cases new functionality or options have been added (as in the &lt;code&gt;io&lt;/code&gt; module, the file handling, the &lt;code&gt;unicode&lt;/code&gt; module, and the bit syntax). Today most modules in Kernel and STDLIB, as well as the VM are Unicode-aware.</source>
          <target state="translated">유니 코드 문자는 Erlang 프로그램에 의해 처리되어야하므로 라이브러리 함수가이를 처리 할 수 ​​있어야합니다. 경우에 따라 기존 인터페이스에 기능이 추가되었습니다 ( &lt;code&gt;string&lt;/code&gt; 모듈은 이제 모든 코드 포인트로 문자열을 처리 할 수 ​​있음). 경우에 따라 새로운 기능 또는 옵션이 추가되었습니다 ( &lt;code&gt;io&lt;/code&gt; 모듈, 파일 처리, &lt;code&gt;unicode&lt;/code&gt; 모듈 및 비트 구문). 오늘날 커널과 STDLIB의 대부분의 모듈과 VM은 유니 코드를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d8a64b00a37fa70a62423e7afa68917e078e3bbf" translate="yes" xml:space="preserve">
          <source>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM operating in Unicode filename translation mode can work with files having names in any language or character set (as long as it is supported by the underlying operating system and file system). The Unicode character list is used to denote filenames or directory names. If the file system content is listed, you also get Unicode lists as return value. The support lies in the Kernel and STDLIB modules, which is why most applications (that do not explicitly require the filenames to be in the ISO Latin-1 range) benefit from the Unicode support without change.</source>
          <target state="translated">유니 코드 파일 명명 지원은 Erlang / OTP R14B01에서 도입되었습니다. 유니 코드 파일 이름 변환 모드로 작동하는 VM은 기본 운영 체제 및 파일 시스템에서 지원하는 한 모든 언어 또는 문자 집합의 이름을 가진 파일을 사용할 수 있습니다. 유니 코드 문자 목록은 파일 이름 또는 디렉토리 이름을 나타내는 데 사용됩니다. 파일 시스템 내용이 나열되면 유니 코드 목록도 반환 값으로 가져옵니다. 지원은 커널 및 STDLIB 모듈에 있으며, 따라서 파일 이름이 ISO Latin-1 범위에 있지 않아도되는 대부분의 응용 프로그램은 변경없이 유니 코드 지원을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e08532eda1cbb1ea06bfac649530b3d005afb89" translate="yes" xml:space="preserve">
          <source>The Unicode string is returned as a Unicode list, which is recognized as such, as the Erlang shell uses the Unicode encoding (and is started with all Unicode characters considered printable). The Unicode list is valid input to function &lt;code&gt;io:put_chars/2&lt;/code&gt;, so data can be output on any Unicode-capable device. If the device is a terminal, characters are output in format &lt;code&gt;\x{&lt;/code&gt;H...&lt;code&gt;}&lt;/code&gt; if encoding is &lt;code&gt;latin1&lt;/code&gt;. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or &quot;noshell&quot;) or whatever is suitable to show the character properly (for an interactive terminal: the regular shell).</source>
          <target state="translated">Erlang 쉘이 유니 코드 인코딩을 사용하고 인쇄 가능한 것으로 간주되는 모든 유니 코드 문자로 시작되므로 유니 코드 문자열은 유니 코드 목록으로 리턴됩니다. 유니 코드 목록은 &lt;code&gt;io:put_chars/2&lt;/code&gt; 기능에 유효한 입력 이므로 모든 유니 코드 가능 장치에서 데이터를 출력 할 수 있습니다. 장치가 단말기 인 경우 인코딩이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 문자는 &lt;code&gt;\x{&lt;/code&gt; H ... &lt;code&gt;}&lt;/code&gt; 형식으로 출력됩니다 . 그렇지 않으면 UTF-8 (비 대화식 터미널의 경우 : &quot;oldshell&quot;또는 &quot;noshell&quot;) 또는 문자를 올바르게 표시하기에 적합한 모든 것 (대화식 터미널의 경우 : 일반 쉘).</target>
        </trans-unit>
        <trans-unit id="917f1b5ccc007e44df82f5ad9e8e418e0762f6b0" translate="yes" xml:space="preserve">
          <source>The Unicode support is controlled by both command-line switches, some standard environment variables, and the OTP version you are using. Most options affect mainly how Unicode data is displayed, not the functionality of the APIs in the standard libraries. This means that Erlang programs usually do not need to concern themselves with these options, they are more for the development environment. An Erlang program can be written so that it works well regardless of the type of system or the Unicode options that are in effect.</source>
          <target state="translated">유니 코드 지원은 명령 줄 스위치, 일부 표준 환경 변수 및 사용중인 OTP 버전에 의해 제어됩니다. 대부분의 옵션은 표준 라이브러리의 API 기능이 아니라 주로 유니 코드 데이터가 표시되는 방식에 영향을줍니다. 즉, Erlang 프로그램은 일반적으로 이러한 옵션에 신경 쓸 필요가 없으며 개발 환경에 더 적합합니다. Erlang 프로그램은 시스템의 유형이나 유효한 유니 코드 옵션에 관계없이 잘 작동하도록 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4f13026f64ec5f7cdd6285c03d5258bacc1cd2" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier &lt;code&gt;t&lt;/code&gt; specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &amp;gt; 255:</source>
          <target state="translated">유니 코드 변환 수정 자 &lt;code&gt;t&lt;/code&gt; 는 라틴 -1 범위의 코드 포인트 외부, 원자, 문자열 및 이진에서 문자를 처리하는 방법을 지정합니다. 예를 들어,&amp;gt; 255자를 포함하는 원자 인쇄 :</target>
        </trans-unit>
        <trans-unit id="e24a7d795c65b90caaa133aaf71048aad49fb98e" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier works as with &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">유니 코드 번역 수정자는 &lt;code&gt;s&lt;/code&gt; 와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b61b21ce88bdc4622a6b58534472bd97a7d6b6d9" translate="yes" xml:space="preserve">
          <source>The Unix &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is to be set to the display of the master node.</source>
          <target state="translated">Unix &lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수는 마스터 노드의 표시로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7580a1c9657bbaca0bea72d41a48c1a2c9f178ef" translate="yes" xml:space="preserve">
          <source>The VM performs tail call optimization, which does not add new entries to the stacktrace, and also limits stacktraces to a certain depth. Furthermore, compiler options, optimizations and future changes may add or remove stacktrace entries, causing any code that expects the stacktrace to be in a certain order or contain specific items to fail.</source>
          <target state="translated">VM은 꼬리 추적 최적화를 수행하여 스택 추적에 새 항목을 추가하지 않으며 스택 추적을 특정 깊이로 제한합니다. 또한 컴파일러 옵션, 최적화 및 향후 변경으로 인해 스택 추적 항목이 추가되거나 제거되어 스택 추적이 특정 순서로 있거나 특정 항목이 포함되어있을 것으로 예상되는 코드가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36921b8c054120393af51df837412dde5ebe77c2" translate="yes" xml:space="preserve">
          <source>The VM with SMP support makes quite a heavy use of atomic memory operations. An implementation providing native atomic memory operations is therefore very important when building Erlang/OTP. By default the VM will refuse to build if native atomic memory operations are not available.</source>
          <target state="translated">SMP를 지원하는 VM은 원자 메모리 작업을 상당히 많이 사용합니다. 따라서 Erlang / OTP를 빌드 할 때 기본 원자 메모리 작업을 제공하는 구현이 매우 중요합니다. 기본 원자 메모리 작업을 사용할 수없는 경우 VM은 기본적으로 빌드를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="883c00fb93b6833f40d7fa937a519315da18d85d" translate="yes" xml:space="preserve">
          <source>The View Module window displays the contents of an interpreted module and makes it possible to set breakpoints.</source>
          <target state="translated">모듈보기 창에는 해석 된 모듈의 내용이 표시되며 중단 점을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818a2a38b6d37966404b0037603dc28865b80d3d" translate="yes" xml:space="preserve">
          <source>The Windows messages are retrieved from the eventlog file.</source>
          <target state="translated">Windows 메시지는 eventlog 파일에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef81693a27626a4d31fec58f2301060476cd06b" translate="yes" xml:space="preserve">
          <source>The Windows system is rebooted whenever the emulator stops (a more simple form of watchdog). This can be useful for less critical systems, otherwise use the heart functionality to accomplish this.</source>
          <target state="translated">에뮬레이터가 중지 될 때마다 Windows 시스템이 재부팅됩니다 (보다 간단한 형태의 워치 독). 이것은 덜 중요한 시스템에 유용 할 수 있습니다. 그렇지 않으면 심장 기능을 사용하여이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66afd9d96a38a37c4f7f94ff1bd05dfee703afea" translate="yes" xml:space="preserve">
          <source>The XML version shown earlier can also be used, but it is to be explicitly specified that the &lt;code&gt;ct_config_xml&lt;/code&gt; callback module is to be used by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">앞에서 설명한 XML 버전도 사용할 수 있지만 &lt;code&gt;Common Test&lt;/code&gt; 가 &lt;code&gt;ct_config_xml&lt;/code&gt; 콜백 모듈 을 사용하도록 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="252a4b864e9fb6b863b0c8c232185b5a96bbfa1c" translate="yes" xml:space="preserve">
          <source>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options &lt;code&gt;notbol&lt;/code&gt; or &lt;code&gt;noteol&lt;/code&gt;, which affect only the behavior of the circumflex and dollar metacharacters. However, if argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \A can never match. The difference between \Z and \z is that \Z matches before a newline at the end of the string and at the very end, while \z matches only at the end.</source>
          <target state="translated">\ A, \ Z 및 \ z 주장은 옵션 설정에 관계없이 주제 문자열의 맨 처음과 끝에서만 일치한다는 점에서 전통적인 곡절 곡사 및 달러 (다음 섹션에서 설명)와 다릅니다. 따라서 여러 줄 모드와 독립적입니다. 이 세 가지 주장은 곡절 및 달러 메타 문자의 동작에만 영향을주는 &lt;code&gt;notbol&lt;/code&gt; 또는 &lt;code&gt;noteol&lt;/code&gt; 옵션의 영향을받지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 인수 &lt;code&gt;startoffset&lt;/code&gt; 이 0이 아닌 경우 일치가 주제의 시작 이외의 지점에서 시작됨을 표시하면 \ A는 절대 일치 할 수 없습니다. \ Z와 \ z의 차이점은 \ Z는 문자열의 끝과 끝에서 개행 이전과 일치하지만 \ z는 끝에서만 일치한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="943d4453f30bb5749d0c52004563365b21bda38a" translate="yes" xml:space="preserve">
          <source>The \C escape sequence</source>
          <target state="translated">\ C 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="4f34ba1108b5cb6716129944fbf4f4329a0a6235" translate="yes" xml:space="preserve">
          <source>The \C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):</source>
          <target state="translated">\ C 이스케이프 시퀀스는 피하는 것이 가장 좋습니다. 그러나 잘못된 UTF 문자의 문제점을 피하는 그것을 사용하는 한 가지 방법은 다음 패턴에서와 같이 lookahead를 사용하여 다음 문자의 길이를 확인하는 것입니다. 휴식) :</target>
        </trans-unit>
        <trans-unit id="c3ea67e0b67cb019dc5aaa8e95c03b5cb7572754" translate="yes" xml:space="preserve">
          <source>The \G assertion is true only when the current matching position is at the start point of the match, as specified by argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;run/3&lt;/code&gt;. It differs from \A when the value of &lt;code&gt;startoffset&lt;/code&gt; is non-zero. By calling &lt;code&gt;run/3&lt;/code&gt; multiple times with appropriate arguments, you can mimic the Perl option &lt;code&gt;/g&lt;/code&gt;, and it is in this kind of implementation where \G can be useful.</source>
          <target state="translated">현재 매칭 위치가 인수로 지정된, 경기의 시작 지점 인 경우에만 \ G의 주장은 사실이다 &lt;code&gt;startoffset&lt;/code&gt; 의 &lt;code&gt;run/3&lt;/code&gt; . &lt;code&gt;startoffset&lt;/code&gt; 값이 0이 아닌 경우 \ A와 다릅니다 . 적절한 인수로 &lt;code&gt;run/3&lt;/code&gt; 을 여러 번 호출 하면 Perl 옵션 &lt;code&gt;/g&lt;/code&gt; 를 모방 할 수 있으며 이는 \ G가 유용 할 수있는 이런 종류의 구현에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7f1b350c6833ef257bc14bd5940d6dff8095f3" translate="yes" xml:space="preserve">
          <source>The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.</source>
          <target state="translated">\ Q ... \ E 시퀀스는 내부 및 외부 문자 클래스 모두에서 인식됩니다. 앞에 \ Q가없는 격리 된 \ E는 무시됩니다. \ Q 다음에 패턴에서 나중에 \ E가 없으면 리터럴 해석은 패턴의 끝까지 계속됩니다 (즉, \ E는 끝에서 가정 됨). 분리 된 \ Q가 문자 클래스 안에 있으면 문자 클래스가 종료되지 않으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14658b1c2056da1457d1137feae50fbf03cef97b" translate="yes" xml:space="preserve">
          <source>The \R escape sequence</source>
          <target state="translated">\ R 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="4253fcd6879a11eec01b435167179d5e15f76711" translate="yes" xml:space="preserve">
          <source>The \X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt;. That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character.</source>
          <target state="translated">\ X 이스케이프는 &quot;확장 grapheme 클러스터&quot;를 형성하는 임의의 유니 코드 문자와 일치하며 시퀀스를 원자 그룹으로 취급합니다 (아래 참조). 릴리스 8.31까지 PCRE는 &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt; 와 동일한 이전의 더 단순한 정의와 일치했습니다 . 즉, &quot;mark&quot;속성이없는 문자와 &quot;mark&quot;속성이있는 문자가 0 개 이상 일치합니다. &quot;mark&quot;속성을 가진 문자는 일반적으로 앞의 문자에 영향을주는 비 간격 악센트입니다.</target>
        </trans-unit>
        <trans-unit id="fe0ff3b7597c9ca177e61f2b7394c84224900254" translate="yes" xml:space="preserve">
          <source>The \X escape sequence</source>
          <target state="translated">\ X 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="1a667df5d1564a7cf0ddb2cbecc475bdb5eb483f" translate="yes" xml:space="preserve">
          <source>The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.</source>
          <target state="translated">\ c 기능은 ASCII 문자와 함께 사용하도록 설계되었지만 유니 코드로 확장하면 그 어느 때보 다 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="269d02430fd6e138cda2800d0af71fa652dd1cf5" translate="yes" xml:space="preserve">
          <source>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the &lt;code&gt;register/2&lt;/code&gt; and &lt;code&gt;whereis/1&lt;/code&gt; BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</source>
          <target state="translated">전역 적으로 이름을 등록하는 기능은 분산 Erlang 시스템 프로그래밍의 핵심 개념입니다. 이 모듈에서는 Erlang 노드 네트워크를 위해 &lt;code&gt;register/2&lt;/code&gt; 및 &lt;code&gt;whereis/1&lt;/code&gt; BIF (로컬 이름 등록 용)가 제공됩니다. 등록 된 이름은 프로세스 식별자 (pid)의 별칭입니다. 글로벌 이름 서버는 글로벌로 등록 된 pid를 모니터링합니다. 프로세스가 종료되면 이름도 전체적으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc8577a293410d9b2b2308f91ef8c7aeb7972a3" translate="yes" xml:space="preserve">
          <source>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate &lt;code&gt;Mnesia&lt;/code&gt; tables.</source>
          <target state="translated">최상위 트랜잭션과 동일한 의미로 중첩 된 트랜잭션을 가질 수 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 조작하는 라이브러리 함수를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a04008ab968f22c43827dcb1f3ef8218af459a" translate="yes" xml:space="preserve">
          <source>The ability to reconfigure the system without stopping or suspending it.</source>
          <target state="translated">시스템을 중지하거나 일시 중단하지 않고 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="129e9c30a42ceaac73e62bd0dcc82cdd40af7c03" translate="yes" xml:space="preserve">
          <source>The above commands give a bit more information than the exact answers, but adequate information when manually searching for answers to these questions.</source>
          <target state="translated">위의 명령은 정확한 답변보다 약간 더 많은 정보를 제공하지만 이러한 질문에 대한 답변을 수동으로 검색 할 때는 적절한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45b0784fdfa3b2b86ccd9506530ebe25156cc75c" translate="yes" xml:space="preserve">
          <source>The above domains are used for logs originating from Erlang/OTP. D1 specifies that the log event comes from Erlang/OTP in general, and D2 indicates that the log event is a so called &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 도메인은 Erlang / OTP에서 생성 된 로그에 사용됩니다. D1은 로그 이벤트가 일반적으로 Erlang / OTP에서 발생하도록 지정하고 D2는 로그 이벤트가 이른바 &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt; 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4ad528c9654cb6b91e6a15396b85e360c22694a9" translate="yes" xml:space="preserve">
          <source>The above function specification uses multiple occurrences of the same type variable. That provides more type information than the following function specification, where the type variables are missing:</source>
          <target state="translated">위의 함수 스펙은 동일한 유형 변수가 여러 번 사용됩니다. 유형 변수가없는 다음 함수 스펙보다 많은 유형 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b3999c12af345ea4567453a651d6ad765544220" translate="yes" xml:space="preserve">
          <source>The above line will create a &lt;code&gt;TAGS&lt;/code&gt; file covering all the Erlang source files in the current directory, and in the subdirectories below.</source>
          <target state="translated">위의 행은 현재 디렉토리와 아래의 서브 디렉토리에있는 모든 Erlang 소스 파일을 포함 하는 &lt;code&gt;TAGS&lt;/code&gt; 파일을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e341eaf056f6757aa8744bf39e8ccfa82e2460c2" translate="yes" xml:space="preserve">
          <source>The above problem can also be solved as follows:</source>
          <target state="translated">위의 문제는 다음과 같이 해결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="492aee09cf585dc36dd1c47f1f73ebd941b86f64" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 간행물은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="425de3e4a3c3f31918aace8062226e8cca18ed8a" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release_handler:install_release/1&lt;/code&gt; 에 대한 호출 후 위의 리턴 값 및 출력 은 &lt;code&gt;release_handler&lt;/code&gt; 가 &lt;code&gt;heart&lt;/code&gt; 를 사용하여 노드를 다시 시작 했음을 의미합니다 . 업그레이드에는 응용 프로그램 ERTS, 커널, STDLIB 또는 SASL의 변경이 포함되는 경우 항상 수행됩니다. 자세한 정보 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="782b35684c4c327f6b3806c4707f7ff71cfb9ed8" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of mmeory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">위의 슬로건은 Erlang이 종료하는 가장 일반적인 이유 중 하나입니다. 알 수없는 이유로 Erlang 런타임 시스템이 사용할 메모리를 할당하지 못했습니다. 이러한 상황이 발생하면 시스템 메모리가 부족한 상태에 대한 정보가 포함 된 크래시 덤프가 생성됩니다. &lt;code&gt;crashdump_viewer&lt;/code&gt; 를 사용하여 사용 중인 메모리를 확인하십시오. 큰 힙 또는 많은 메시지, 큰 ets 테이블 등이있는 프로세스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a934d4536371eb6354c38319c0a6fa99eadfdfc1" translate="yes" xml:space="preserve">
          <source>The absence of warnings does not mean that there are no remaining errors in the code.</source>
          <target state="translated">경고가 없다고해서 코드에 남아있는 오류가 없음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="52e22f3960de9276ce93c1885ad7150854270f91" translate="yes" xml:space="preserve">
          <source>The absolute path of directory &lt;code&gt;chat_server/ebin&lt;/code&gt; is here passed to the code server. This is essential because relative paths are stored by the code server as relative, and &lt;code&gt;Common Test&lt;/code&gt; changes the current working directory of ERTS during the test run.</source>
          <target state="translated">&lt;code&gt;chat_server/ebin&lt;/code&gt; 디렉토리의 절대 경로 는 여기서 코드 서버로 전달됩니다. 상대 경로는 코드 서버에 의해 상대 경로로 저장되므로 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 실행 중에 ERTS의 현재 작업 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5539aa6980c3b1d4dc664f3e80f8e7768512fe3a" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">타이머가 만료되도록 설정된 절대 시간은 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 간격에 있어야합니다 . 상대 시간이 지정되면 &lt;code&gt;Time&lt;/code&gt; 값은 음수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e18029dc4fbc0a03d56e79bb7184953e3744a063" translate="yes" xml:space="preserve">
          <source>The abstract layer (defined in &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;) is nicely structured and the node types are context-independent. The layer makes it possible to transparently attach source-code comments and user annotations to nodes of the tree. Using the abstract layer makes applications less sensitive to changes in the &lt;code&gt;erl_parse(3)&lt;/code&gt; data structures, only requiring the &lt;code&gt;erl_syntax&lt;/code&gt; module to be up-to-date.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 에 정의 된 추상 계층 은 훌륭하게 구조화되어 있으며 노드 유형은 컨텍스트 독립적입니다. 이 계층을 통해 소스 코드 주석과 사용자 주석을 트리의 노드에 투명하게 연결할 수 있습니다. 추상 계층을 사용하면 응용 프로그램이 &lt;code&gt;erl_parse(3)&lt;/code&gt; 데이터 구조의 변경에 덜 민감 &lt;code&gt;erl_syntax&lt;/code&gt; 모듈 만 최신 상태로 유지하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebbf813506aec9cb5b7febd24547c187a92185e" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">허용 된 소켓 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;ListenSocket&lt;/code&gt; 에 설정된 옵션을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c1f48a70d3a03fcd08b9ecaf840df566c82062" translate="yes" xml:space="preserve">
          <source>The ack_action() is either:</source>
          <target state="translated">ack_action ()은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4df5499b046a3caa5c00b3bf34cda3b59c95dee6" translate="yes" xml:space="preserve">
          <source>The ack_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">이 함수에 대한 ack_data () 인수는 handle_trans_request / 3에 의해 리턴 된 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="573fc48700bb83712fa26ae3db5f4a997f5bdf7a" translate="yes" xml:space="preserve">
          <source>The action to take when the Erlang emulator stops unexpectedly. Default is to ignore.</source>
          <target state="translated">Erlang 에뮬레이터가 예기치 않게 중지 될 때 수행 할 조치입니다. 기본값은 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40fdcbc6206b95ef9655638b626a5128e3d5dc2c" translate="yes" xml:space="preserve">
          <source>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</source>
          <target state="translated">실제 인코딩 된 메시지는 인코딩 된 메시지 당 하나의 파일을 포함하여 인코딩 유형 당 하나의 디렉토리에 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="bbf119f15e4a3e4c9e43ba3da03845ee142277be" translate="yes" xml:space="preserve">
          <source>The actual message returned by the RPC server is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you use &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code, this is the message you will need to parse. If you use &lt;code&gt;erl_rpc()&lt;/code&gt;, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies to RPC requests are always &lt;code&gt;ERL_SEND&lt;/code&gt; messages.</source>
          <target state="translated">RPC 서버가 리턴 한 실제 메시지는 2- 튜플 &lt;code&gt;{rex,Reply}&lt;/code&gt; 입니다. 코드에서 &lt;code&gt;erl_rpc_from()&lt;/code&gt; 을 사용 하면 구문 분석해야 할 메시지입니다. &lt;code&gt;erl_rpc()&lt;/code&gt; 를 사용 하면 튜플 자체가 구문 분석되며 프로그램으로 리턴되는 메시지는 &lt;code&gt;Reply&lt;/code&gt; 만 포함하는 Erlang 용어 입니다. RPC 요청에 대한 회신은 항상 &lt;code&gt;ERL_SEND&lt;/code&gt; 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="3f712073d78ceb80ba4691c57506456b575aeca2" translate="yes" xml:space="preserve">
          <source>The actual number of fragments</source>
          <target state="translated">실제 조각 수</target>
        </trans-unit>
        <trans-unit id="4322cef184ec5aecf9faa18423df4ee550bc1ca0" translate="yes" xml:space="preserve">
          <source>The actual supervision of execution times is in itself a CPU intensive activity. A message is written on the trace file for every function call that is made by the profiled code.</source>
          <target state="translated">실행 시간의 실제 감독 자체는 CPU를 많이 사용하는 활동입니다. 프로파일 된 코드로 작성된 모든 함수 호출에 대해 추적 파일에 메시지가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3571545f798bc55c8050de98e521a38384a9d2" translate="yes" xml:space="preserve">
          <source>The actual timer time.</source>
          <target state="translated">실제 타이머 시간</target>
        </trans-unit>
        <trans-unit id="27345ee3cabb8f446fd8fd55e223fda324b5bab0" translate="yes" xml:space="preserve">
          <source>The actual value is the quoted atom &lt;code&gt;'NULL'&lt;/code&gt;.</source>
          <target state="translated">실제 값은 인용 된 원자 &lt;code&gt;'NULL'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c72f4263f7e8c1e5785af3ae16a212b694d638c6" translate="yes" xml:space="preserve">
          <source>The address and port of the other end of the connection.</source>
          <target state="translated">연결의 다른 쪽 끝의 주소와 포트</target>
        </trans-unit>
        <trans-unit id="5ae3afdabf8d69b7f030903f34729a4d0a97bc17" translate="yes" xml:space="preserve">
          <source>The address must be the IP address and cannot be the hostname.</source>
          <target state="translated">주소는 IP 주소 여야하며 호스트 이름이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="45c66a6604fd97ae44d5625424f5836d3c3179c8" translate="yes" xml:space="preserve">
          <source>The address of the fun's code when HiPE is enabled.</source>
          <target state="translated">HiPE가 활성화 된 경우 펀 코드의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7ddf5f9487a859a28b6ed4d37dd3d9bebe9f2f6a" translate="yes" xml:space="preserve">
          <source>The address of the fun's code.</source>
          <target state="translated">재미있는 코드의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7e8bf572fd0f0bc243c5923805f5fb20ef2fe37e" translate="yes" xml:space="preserve">
          <source>The address specified in &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; overwrites the primary peer address</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 에 지정된 주소 가 기본 피어 주소를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ba449fc5f30a23d575fa4c4396e275fa504dce46" translate="yes" xml:space="preserve">
          <source>The adjustment of system time could have been made smother than using a time warp approach, but we think that would be a bad choice. As we can express and measure time that is not connected to calendar time by the use of Erlang monotonic time, it is better to expose the change in Erlang system time immediately. This as the Erlang applications executing on the system can react on the change in system time as soon as possible. This is also more or less exactly how most operating systems handle this (OS monotonic time and OS system time). By adjusting system time smoothly, we would just hide the fact that system time changed and make it harder for the Erlang applications to react to the change in a sensible way.</source>
          <target state="translated">시스템 시간 조정은 타임 워프 방식을 사용하는 것보다 질식 할 수 있었지만 우리는 이것이 잘못된 선택이라고 생각합니다. Erlang 단조 시간을 사용하여 달력 시간에 연결되지 않은 시간을 표현하고 측정 할 수 있으므로 Erlang 시스템 시간의 변경 사항을 즉시 노출하는 것이 좋습니다. 이는 시스템에서 실행되는 Erlang 애플리케이션이 시스템 시간의 변화에 ​​최대한 빨리 반응 할 수 있기 때문입니다. 이는 대부분의 운영 체제에서이를 처리하는 방식 (OS 단조 시간 및 OS 시스템 시간)과 거의 비슷합니다. 시스템 시간을 매끄럽게 조정하면 시스템 시간이 변경되었다는 사실을 숨기고 Erlang 애플리케이션이 합리적인 방식으로 변경에 반응하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="5f9472dc1436a5862ca0454404828318f9e56d1f" translate="yes" xml:space="preserve">
          <source>The advantage of using an extensible (agent/manager) toolkit is to remove details such as type-checking, access rights, Protocol Data Unit (PDU), encoding, decoding, and trap distribution from the programmer, who only has to write the instrumentation functions, which implement the MIBs. The &lt;code&gt;get-next&lt;/code&gt; function only has to be implemented for tables, and not for every variable in the global naming tree. This information can be deduced from the ASN.1 file.</source>
          <target state="translated">확장 가능한 (에이전트 / 관리자) 툴킷을 사용하면 유형 검사, 액세스 권한, PDU (Protocol Data Unit), 인코딩, 디코딩 및 트랩 배포와 같은 세부 정보를 계측기에서 작성해야하는 프로그래머에서 제거 할 수 있습니다. MIB를 구현하는 함수. &lt;code&gt;get-next&lt;/code&gt; 기능은 테이블, 그리고 글로벌 명명 트리에서 모든 변수에 대해 구현되어야한다. 이 정보는 ASN.1 파일에서 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe8e4ddaca688413966f57d082a8c9a7e076fe3" translate="yes" xml:space="preserve">
          <source>The advantages of separating the table coordinator from the SNMP tool are:</source>
          <target state="translated">테이블 코디네이터를 SNMP 도구에서 분리하면 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3ed41d7fd39c63d6b7f432ea91d01107779b41" translate="yes" xml:space="preserve">
          <source>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</source>
          <target state="translated">영향을받는 테이블은 복원 중에 쓰기 잠금됩니다. 그러나 이로 인한 잠금 충돌에 관계없이 복원이 수행되는 동안 응용 프로그램이 계속 작업을 수행 할 수 있습니다. 복원은 하나의 단일 트랜잭션으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb577e64047dee54287b4297431d9c8f5676c03" translate="yes" xml:space="preserve">
          <source>The age is defined in milliseconds.</source>
          <target state="translated">나이는 밀리 초로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e7020aa85de45cdbfd0f6571b7cc03a6fded1bbd" translate="yes" xml:space="preserve">
          <source>The agent and manager uses (application) configuration parameters to find out where these directories are located. The parameters should be defined in an Erlang system configuration file. The following configuration parameters are defined for the SNMP application:</source>
          <target state="translated">에이전트 및 관리자는 (응용 프로그램) 구성 매개 변수를 사용하여 이러한 디렉토리의 위치를 ​​찾습니다. 매개 변수는 Erlang 시스템 구성 파일에서 정의해야합니다. SNMP 응용 프로그램에 대해 다음 구성 매개 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="532498afa1ab407c6e18b6c76c06f1a8f9021335" translate="yes" xml:space="preserve">
          <source>The agent can be configured to be multi-threaded, to process one incoming request at a time, or to have a request limit enabled (this can be used for load control or to limit the effect of DoS attacks). If it is multi-threaded, read requests (&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and &lt;code&gt;get-bulk&lt;/code&gt;) and traps are processed in parallel with each other and &lt;code&gt;set&lt;/code&gt; requests. However, all &lt;code&gt;set&lt;/code&gt; requests are serialized, which means that if the agent is waiting for the application to complete a complicated write operation, it will not process any new write requests until this operation is finished. It processes read requests and sends traps, concurrently. The reason for not handle write requests in parallel is that a complex locking mechanism would be needed even in the simplest cases. Even with the scheme described above, the user must be careful not to violate that the &lt;code&gt;set&lt;/code&gt; requests are atoms. If this is hard to do, do not use the multi-threaded feature.</source>
          <target state="translated">에이전트는 다중 스레드로 구성하거나 한 번에 하나의 들어오는 요청을 처리하거나 요청 제한을 활성화하도록 구성 할 수 있습니다 (로드 제어에 사용되거나 DoS 공격의 영향을 제한하는 데 사용될 수 있음). 다중 스레드 인 경우 읽기 요청 ( &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; 및 &lt;code&gt;get-bulk&lt;/code&gt; ) 및 트랩은 서로 병렬로 처리되고 요청을 &lt;code&gt;set&lt;/code&gt; 합니다. 그러나 모든 &lt;code&gt;set&lt;/code&gt; 요청이 직렬화됩니다. 즉, 에이전트가 애플리케이션이 복잡한 쓰기 조작을 완료하기를 기다리는 경우이 조작이 완료 될 때까지 새 쓰기 요청을 처리하지 않습니다. 읽기 요청을 처리하고 동시에 트랩을 보냅니다. 쓰기 요청을 병렬로 처리하지 않는 이유는 가장 간단한 경우에도 복잡한 잠금 메커니즘이 필요하기 때문입니다. 위에서 설명한 체계를 사용하더라도 사용자는 &lt;code&gt;set&lt;/code&gt; 요청이 원자 임을 위반하지 않도록주의해야합니다 . 이것이 어려운 경우에는 멀티 스레드 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1765275ae72c3c73846eb96f701861af075a2ade" translate="yes" xml:space="preserve">
          <source>The agent can both perform and respond to discovery.</source>
          <target state="translated">에이전트는 감지를 수행하고 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fab26e9897ff23218adb34fca8afc8ac6df806b" translate="yes" xml:space="preserve">
          <source>The agent can spontaneously send a notification, for example, an alarm, to the manager.</source>
          <target state="translated">상담원은 자발적으로 경보와 같은 알림을 관리자에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e6c01b1d22bf1009d4f112f5ef241f146f87bc" translate="yes" xml:space="preserve">
          <source>The agent does not check complex ranges specified for INTEGER objects. In these cases it just checks that the value lies within the minimum and maximum values specified. For example, if the range is specified as &lt;code&gt;1..10 | 12..20&lt;/code&gt; the agent would let 11 through, but not 0 or 21. The instrumentation functions must check the complex ranges itself.</source>
          <target state="translated">에이전트는 INTEGER 오브젝트에 지정된 복합 범위를 확인하지 않습니다. 이 경우 값이 지정된 최소값과 최대 값 내에 있는지 확인합니다. 예를 들어, 범위가 1로 지정된 경우 &lt;code&gt;1..10 | 12..20&lt;/code&gt; 상담원은 11 또는 11을 통과 시키지만 계측 기능은 복소수 범위 자체를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="821394aba5a85ee9b738eccc0b641e5e87f98f1d" translate="yes" xml:space="preserve">
          <source>The agent information should be stored in a file called &lt;code&gt;agent.conf&lt;/code&gt;.</source>
          <target state="translated">에이전트 정보는 &lt;code&gt;agent.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d5c2b0ecab378b92db71d78b459615c0be2b937" translate="yes" xml:space="preserve">
          <source>The agent is an entity that executes within a &lt;strong&gt;Network Element (NE)&lt;/strong&gt;. In OTP, the NE can be a distributed system, meaning that the distributed system is managed as one entity. Of course, the agent can be configured to be able to run on one of several nodes, making it a distributed OTP application.</source>
          <target state="translated">에이전트는 &lt;strong&gt;네트워크 요소 (NE)&lt;/strong&gt; 내에서 실행되는 엔티티입니다 . OTP에서 NE는 분산 시스템 일 수 있으며 이는 분산 시스템이 하나의 엔티티로 관리됨을 의미합니다. 물론 에이전트는 여러 노드 중 하나에서 실행될 수 있도록 구성하여 분산 OTP 응용 프로그램으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3d395baa2a805befd96447c7ba7e7fb38c483ae" translate="yes" xml:space="preserve">
          <source>The agent is configured with the configuration tool, using default suggestions for everything but the manager node.</source>
          <target state="translated">에이전트는 관리자 노드 이외의 모든 것에 대한 기본 제안을 사용하여 구성 도구로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bafc8c1a76725000dfff5c337a6c7efd569cd586" translate="yes" xml:space="preserve">
          <source>The agent is highly fault tolerant. If the manager gets an unexpected response from the agent, it is possible that some instrumentation function has returned an erroneous value. The agent will not crash even if the instrumentation does. It should be noted that if an instrumentation function enters an infinite loop, the agent will also be blocked forever. The supervisor ,or the application, specifies how to restart the agent.</source>
          <target state="translated">에이전트는 내결함성이 있습니다. 관리자가 에이전트로부터 예기치 않은 응답을받는 경우 일부 계측 기능이 잘못된 값을 반환했을 수 있습니다. 계측이 수행 되더라도 에이전트가 중단되지 않습니다. 인스 트루먼 테이션 기능이 무한 루프에 들어가면 에이전트도 영원히 차단됩니다. 수퍼바이저 또는 응용 프로그램은 에이전트를 다시 시작하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2c7ad18cc20a9d278d188273b0ceb93f154abb8c" translate="yes" xml:space="preserve">
          <source>The agent receives a request and maps it to calls to one or more instrumentation functions. These functions perform operations on the resources to implement the semantics associated with the MO.</source>
          <target state="translated">에이전트는 요청을 받아서 하나 이상의 계측 기능에 대한 호출에 매핑합니다. 이 함수는 리소스에 대한 작업을 수행하여 MO와 관련된 의미를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5394a28e8aa26b89d2b8f393dd3cca2d7c380d89" translate="yes" xml:space="preserve">
          <source>The agent responds to discovery autonomously, without interaction by the user.</source>
          <target state="translated">에이전트는 사용자의 상호 작용없이 자동으로 검색에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="ebd412ca77c13dc418b2ee47def2c221adc4c0fa" translate="yes" xml:space="preserve">
          <source>The agent started is called &lt;code&gt;snmp_master_agent&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; to load MIBs into the agent.</source>
          <target state="translated">시작된 에이전트는 &lt;code&gt;snmp_master_agent&lt;/code&gt; 입니다. 사용 &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; 에이전트에 MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="35fefa07539d964d08302d135b6a045a731feaec" translate="yes" xml:space="preserve">
          <source>The agent stores the values in an internal volatile database, which is based on the standard module &lt;code&gt;ets&lt;/code&gt;. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for more information.</source>
          <target state="translated">에이전트는 표준 &lt;code&gt;ets&lt;/code&gt; 기반의 휘발성 데이터베이스에 값을 저장합니다 . 그러나 MIB 컴파일러가 내부, 영구 데이터베이스 또는 Mnesia DBMS를 사용하는 함수를 생성하도록 할 수 있습니다. 자세한 내용은 Mnesia 사용 설명서 및 참조 설명서 섹션 SNMP, &lt;code&gt;snmp_generic&lt;/code&gt; 모듈 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88cd9d752952f90596dc3746023ba01fb085191a" translate="yes" xml:space="preserve">
          <source>The agent will never generate the &lt;code&gt;wrongEncoding&lt;/code&gt; error. If a variable binding is erroneous encoded, the &lt;code&gt;asn1ParseError&lt;/code&gt; counter will be incremented.</source>
          <target state="translated">에이전트는 &lt;code&gt;wrongEncoding&lt;/code&gt; 오류를 생성하지 않습니다 . 변수 바인딩이 잘못 인코딩 된 경우 &lt;code&gt;asn1ParseError&lt;/code&gt; 카운터가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="31dc2849b5514caeb8ae4f58e7cc8579c0d02b0d" translate="yes" xml:space="preserve">
          <source>The alarm handler is part of the SASL application.</source>
          <target state="translated">알람 처리기는 SASL 응용 프로그램의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="f225b02b835111c249a55da204c91a4c1ca4bd60" translate="yes" xml:space="preserve">
          <source>The alarm handler process is a &lt;code&gt;gen_event&lt;/code&gt; event manager process that receives alarms in the system. This process is not intended to be a complete alarm handler. It defines a place to which alarms can be sent. One simple event handler is installed in the alarm handler at startup, but users are encouraged to write and install their own handlers.</source>
          <target state="translated">알람 핸들러 프로세스는 시스템에서 알람을 수신 하는 &lt;code&gt;gen_event&lt;/code&gt; 이벤트 관리자 프로세스입니다. 이 프로세스는 완전한 알람 핸들러가 아닙니다. 알람을 보낼 수있는 장소를 정의합니다. 시작시 하나의 간단한 이벤트 핸들러가 알람 핸들러에 설치되지만 사용자는 자체 핸들러를 작성하고 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9a1c34ac82f222f7bf20fdb60c9c70070554269a" translate="yes" xml:space="preserve">
          <source>The alarms are cleared automatically when the alarm cause is no longer valid.</source>
          <target state="translated">알람 원인이 더 이상 유효하지 않으면 알람이 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="986d3b30b24eb7709dfdc0693fd6abc2a7ec4e8c" translate="yes" xml:space="preserve">
          <source>The algorithm for updating &lt;code&gt;Serial&lt;/code&gt; can be described as follows:</source>
          <target state="translated">&lt;code&gt;Serial&lt;/code&gt; 업데이트 알고리즘은 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd9a185b05bfc6c5aca5b3488aeb8d588a949ea" translate="yes" xml:space="preserve">
          <source>The algorithm for wich the fun should implement the special matching rules</source>
          <target state="translated">재미를위한 알고리즘은 특별한 매칭 규칙을 구현해야합니다</target>
        </trans-unit>
        <trans-unit id="7bb19b504df5c1a9303c7a6f511b1fc2dc8c9766" translate="yes" xml:space="preserve">
          <source>The algorithm in &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</source>
          <target state="translated">&lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; 의 알고리즘 은 md5이며 이전 ssh-keygen 명령과 호환됩니다. 두 번째 변형의 문자열 앞에는 최신 ssh-keygen 명령에서와 같이 알고리즘 이름이 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f989a67b5ca0281a96030c126b7a3d77ef6b31" translate="yes" xml:space="preserve">
          <source>The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library.</source>
          <target state="translated">이 알고리즘은 표준 프롤로그 라이브러리에서 Richard A. O'Keefe의 버전을 수정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7f680b0d6e8d6f4e75e82db44978468dc45a6e99" translate="yes" xml:space="preserve">
          <source>The algorithm is the same as for send above.</source>
          <target state="translated">알고리즘은 위의 보내기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="230091aa46aa0a9b37e9fd8c10519ddfe76dd814" translate="yes" xml:space="preserve">
          <source>The algorithm that is used to draw a graph with as few crossed links as possible is called force graph. A force graph consists of nodes and directed links between nodes. Each node is associated with a repulsive force that pushes nodes away from each other. This force can be adjusted with the left slider or with the mouse wheel. Each link is associated with an attractive force that pulls the nodes nearer to each other. This force can be adjusted with the right slider. If this force becomes too strong, the graph will be unstable. The third parameter that can be adjusted is the length of the links. It is adjusted with the middle slider.</source>
          <target state="translated">교차 링크가 가능한 적은 그래프를 그리는 데 사용되는 알고리즘을 힘 그래프라고합니다. 힘 그래프는 노드와 노드 간 직접 링크로 구성됩니다. 각 노드는 노드를 서로 멀어지게하는 반발력과 관련이 있습니다. 이 힘은 왼쪽 슬라이더 나 마우스 휠로 조정할 수 있습니다. 각 링크는 노드를 서로 더 가까이 끌어 당기는 인력과 관련이 있습니다. 이 힘은 오른쪽 슬라이더로 조정할 수 있습니다. 이 힘이 너무 강해지면 그래프가 불안정 해집니다. 조정할 수있는 세 번째 매개 변수는 링크 길이입니다. 중간 슬라이더로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="e0be3089ed3cdab42290e47bafffab640f5507bb" translate="yes" xml:space="preserve">
          <source>The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0</source>
          <target state="translated">알고리즘은 선호하는 순서로되어 있어야합니다. 선택된 서명 알고리즘은 선택할 수있는 해시 함수를 제한 할 수 있습니다. SSL-8.0에서 {md5, rsa}에 대한 기본 지원이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="51bb3389ce8effbbb1e7082b3ae1de9569a30494" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션으로 지정된 알고리즘은 TLS-1.2에 도입 된 서명 알고리즘 협상에서 서버가 승인 한 알고리즘입니다. 클라이언트 인증서가 요청되면 알고리즘도 클라이언트에 제공됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b2fe8210e9b69a3cc07735de1a6330b93954baa" translate="yes" xml:space="preserve">
          <source>The algoritm for modifications works like this:</source>
          <target state="translated">수정 알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="10574335a609a1059aa012db0f86b9ea475e61d4" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Defaults to all &lt;code&gt;alloc_util&lt;/code&gt; allocators.</source>
          <target state="translated">검색 할 할당 자 유형 기본값은 모든 &lt;code&gt;alloc_util&lt;/code&gt; 할당 자입니다.</target>
        </trans-unit>
        <trans-unit id="f7ed9195c9091feda9cc03849f91a3d0e1313381" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">테이블 의 허용 된 &lt;code&gt;AccessMode&lt;/code&gt; 는 &lt;code&gt;read_only&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 로 정의 될 수 있습니다 . 런타임시 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; 함수로 전환 할 수 있습니다 . &lt;code&gt;read_only&lt;/code&gt; 테이블 및 &lt;code&gt;local_content&lt;/code&gt; 테이블은 다른 노드에서 테이블을 복사 할 필요가 없으므로 항상 로컬로로드됩니다. 테이블이 이미로드되어 있거나 실행중인 &lt;code&gt;Mnesia&lt;/code&gt; 가 이미 테이블을로드하기로 결정한 경우 다른 테이블은 주로 다른 노드의 활성 복제본에서 원격으로로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="c9cd2b75bdb0d580c661ccb5efbc7ebe47d4aa8f" translate="yes" xml:space="preserve">
          <source>The allowed range is 1..256. Defaults to 1 for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt;, and to 8 for &lt;code&gt;binary&lt;/code&gt;. No unit specifier must be given for the types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;.</source>
          <target state="translated">허용되는 범위는 1..256입니다. &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;bitstring&lt;/code&gt; 의 경우 기본값은 1 이고 &lt;code&gt;binary&lt;/code&gt; 의 경우 8입니다 . &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형에는 단위 지정자를 지정하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad89fe4bac55bef5e612143241645e3f39f837c7" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;Operation&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 에 허용되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91eabbe1745620d58dbabfc6b149c475cb3f775e" translate="yes" xml:space="preserve">
          <source>The amount of dirty CPU schedulers is limited by the amount of normal schedulers in order to limit the effect on processes executing on ordinary schedulers. If the amount of dirty CPU schedulers was allowed to be unlimited, dirty CPU bound jobs would potentially starve normal jobs.</source>
          <target state="translated">더티 CPU 스케줄러의 양은 일반 스케줄러에서 실행되는 프로세스에 대한 영향을 제한하기 위해 일반 스케줄러의 양에 의해 제한됩니다. 더티 CPU 스케줄러의 수가 무제한으로 허용되면 더티 CPU 바운드 작업이 잠재적으로 일반 작업에 굶주리게됩니다.</target>
        </trans-unit>
        <trans-unit id="27a9761aa8b41fe03707985ac819ffa2294674b4" translate="yes" xml:space="preserve">
          <source>The amount of dirty IO schedulers is not limited by the amount of normal schedulers &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt;. This since only I/O bound work is expected to execute on dirty I/O schedulers. If the user should schedule CPU bound jobs on dirty I/O schedulers, these jobs might starve ordinary jobs executing on ordinary schedulers.</source>
          <target state="translated">더티 IO 스케줄러 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt; 일반 스케줄러의 양에 의해 제한되지 않습니다 . 이는 I / O 바운드 작업 만 더티 I / O 스케줄러에서 실행될 것으로 예상되기 때문입니다. 사용자가 더티 I / O 스케줄러에서 CPU 바운드 작업을 예약해야하는 경우 이러한 작업은 일반 스케줄러에서 실행중인 일반 작업에 굶주릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="664e7e56a2225929620ef872c0ebcd0c6fb9c4c1" translate="yes" xml:space="preserve">
          <source>The amount of free memory available to the Erlang emulator for allocation.</source>
          <target state="translated">Erlang 에뮬레이터가 할당 할 수있는 사용 가능한 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="856f5380158f6d7ba56eebb6ae41011bd9432d40" translate="yes" xml:space="preserve">
          <source>The amount of memory available to the whole operating system. This may well be equal to &lt;code&gt;total_memory&lt;/code&gt; but not necessarily.</source>
          <target state="translated">전체 운영 체제에서 사용할 수있는 메모리 양 이것은 &lt;code&gt;total_memory&lt;/code&gt; 와 같을 수도 있지만 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="177a7f5e407b489cea8a1c26cd218274ba08f36c" translate="yes" xml:space="preserve">
          <source>The amount of memory the system has available for disk swap.</source>
          <target state="translated">시스템이 디스크 스왑에 사용할 수있는 메모리 양.</target>
        </trans-unit>
        <trans-unit id="7656a9402d240df34705d7b544f4dff29a5abe83" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for cached files read from disk.</source>
          <target state="translated">시스템이 디스크에서 읽은 캐시 된 파일에 사용하는 메모리의 양입니다.</target>
        </trans-unit>
        <trans-unit id="eee7cda7742ee86ae7d191faad9371151f0ebd25" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for temporary storing raw disk blocks.</source>
          <target state="translated">원시 디스크 블록을 임시 저장하기 위해 시스템이 사용하는 메모리의 양입니다.</target>
        </trans-unit>
        <trans-unit id="1082b666267c1d0a05f9d3fc735ec44903b5cce2" translate="yes" xml:space="preserve">
          <source>The amount of time that passes between a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a link signal sent to a non-existing process triggers an exit signal, which is sent back to where the link signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down.</source>
          <target state="translated">신호 사이를 통과하는 시간이 전송되고 목적지에 신호가 도착하는 것은 지정되지 않았지만 양수입니다. 수신기가 종료되면 신호가 도착하지 않지만 다른 신호를 트리거 할 수 있습니다. 예를 들어, 존재하지 않는 프로세스로 전송 된 링크 신호는 종료 신호를 트리거하며,이 신호는 링크 신호가 발생한 위치로 다시 전송됩니다. 분배를 통해 통신 할 때 분배 채널이 중단되면 신호가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4519c04c3df5357f9581cfbf162358aa5fec4d97" translate="yes" xml:space="preserve">
          <source>The amount of total amount of memory the system has available for disk swap.</source>
          <target state="translated">시스템이 디스크 스왑에 사용할 수있는 총 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="784b5a2e886a3960b27831ea309171f77ba1c2b8" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap. This information is usually useless.</source>
          <target state="translated">각 힙에서 사용되지 않은 메모리의 양입니다. 이 정보는 일반적으로 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaa8449008b96acfc6b47fd80ac7ade7e1100e51" translate="yes" xml:space="preserve">
          <source>The analysis result can either be for all modules, or for one module. In either case a call count limit can be given to filter out the functions with a call count below the limit. The all modules analysis does &lt;strong&gt;not&lt;/strong&gt; contain the module &lt;code&gt;cprof&lt;/code&gt; itself, it can only be analysed by specifying it as a single module to analyse.</source>
          <target state="translated">분석 결과는 모든 모듈 또는 하나의 모듈 일 수 있습니다. 두 경우 모두 호출 수 제한을 지정하여 호출 수를 제한 아래로 사용하여 기능을 필터링 할 수 있습니다. 모든 모듈 분석 에는 모듈 &lt;code&gt;cprof&lt;/code&gt; 자체가 포함되어 있지 &lt;strong&gt;않으며&lt;/strong&gt; 분석 할 단일 모듈로 지정해야만 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="665b53498dfc4b5081b2898303b46c4e6c1e3b19" translate="yes" xml:space="preserve">
          <source>The analysis starts from an empty PLT and creates a new one from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. This option only works for BEAM files. To override the default PLT location, use &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">빈 PLT에서 분석이 시작되고 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일에서 새로운 PLT가 작성 됩니다. 이 옵션은 BEAM 파일에만 작동합니다. 기본 PLT 위치를 재정의하려면 &lt;code&gt;--plt&lt;/code&gt; 또는 &lt;code&gt;--output_plt&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdcf511f2d0831631f6fdd22a140605914418760" translate="yes" xml:space="preserve">
          <source>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</source>
          <target state="translated">요청에 대한 답변은 UDP 프로토콜 데이터 유닛 (PDU)으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf1e9025d3f661f3470ed7afc4906eb1f7fc756" translate="yes" xml:space="preserve">
          <source>The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns &lt;code&gt;false&lt;/code&gt;, or collecting the template when all filters return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">한정자는 왼쪽에서 오른쪽으로 한정자를 평가 하거나 일부 필터가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 역 추적 하거나 모든 필터가 &lt;code&gt;true&lt;/code&gt; 를 반환하면 템플릿을 수집하여 답을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f318a6ba118898a63239c22ec72006a08d5ca687" translate="yes" xml:space="preserve">
          <source>The application can be specified by its name &lt;code&gt;Application&lt;/code&gt;. In this case, the application controller searches the code path for the application resource file &lt;code&gt;Application.app&lt;/code&gt; and loads the specification it contains.</source>
          <target state="translated">응용 프로그램은 이름 &lt;code&gt;Application&lt;/code&gt; 으로 지정할 수 있습니다 . 이 경우 응용 프로그램 컨트롤러는 응용 프로그램 리소스 파일 &lt;code&gt;Application.app&lt;/code&gt; 에 대한 코드 경로를 검색하고 포함 된 사양을로드합니다.</target>
        </trans-unit>
        <trans-unit id="620c94d66204ee923841db86e6b7d75bbdd11ef8" translate="yes" xml:space="preserve">
          <source>The application concept applies both to program structure (processes) and directory structure (modules).</source>
          <target state="translated">응용 프로그램 개념은 프로그램 구조 (프로세스) 및 디렉토리 구조 (모듈)에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f58d25a7007e6f3798c0b59bdfac842192b77950" translate="yes" xml:space="preserve">
          <source>The application controller automatically loads any included applications when loading a primary application, but does not start them. Instead, the top supervisor of the included application must be started by a supervisor in the including application.</source>
          <target state="translated">응용 프로그램 제어기는 기본 응용 프로그램을로드 할 때 포함 된 응용 프로그램을 자동으로로드하지만 시작하지는 않습니다. 대신 포함 된 응용 프로그램의 최고 감독자는 포함하는 응용 프로그램의 감독자가 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="98f6f34774d04811ed29ee462b6732dccb9d0043" translate="yes" xml:space="preserve">
          <source>The application controller checks the value of the application specification key &lt;code&gt;applications&lt;/code&gt;, to ensure that all applications needed to be started before this application are running. Otherwise, &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; is returned, where &lt;code&gt;App&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">응용 프로그램 제어기는 응용 프로그램 스펙 키 &lt;code&gt;applications&lt;/code&gt; 프로그램의 값을 검사 하여이 응용 프로그램을 실행하기 전에 시작해야하는 모든 응용 프로그램을 확인합니다. 그렇지 않으면 &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; 가 리턴되며 여기서 &lt;code&gt;App&lt;/code&gt; 은 누락 된 애플리케이션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f3a71b2d510c249b1ef4dc36fecf08094449baa7" translate="yes" xml:space="preserve">
          <source>The application controller creates an application master for the application</source>
          <target state="translated">응용 프로그램 컨트롤러는 응용 프로그램의 응용 프로그램 마스터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="83a95923e1f732ae145bb3e38ddb63679bc6a37a" translate="yes" xml:space="preserve">
          <source>The application controller then creates an &lt;strong&gt;application master&lt;/strong&gt; for the application. The application master becomes the group leader of all the processes in the application. I/O is forwarded to the previous group leader, though, this is just a way to identify processes that belong to the application. Used for example to find itself from any process, or, reciprocally, to kill them all when it terminates.</source>
          <target state="translated">그런 다음 응용 프로그램 컨트롤러는 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 의 &lt;strong&gt;응용 프로그램 마스터&lt;/strong&gt; 를 만듭니다 . 응용 프로그램 마스터는 응용 프로그램의 모든 프로세스의 그룹 리더가됩니다. I / O는 이전 그룹 리더에게 전달되지만 이는 응용 프로그램에 속하는 프로세스를 식별하는 방법 일뿐입니다. 예를 들어 모든 프로세스에서 자신을 찾거나 상호 적으로 종료 될 때 프로세스를 모두 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0f6ae5fb0c8a7581cb9e8e067ef2f56d1995bb" translate="yes" xml:space="preserve">
          <source>The application dependencies can be checked using the Erlang shell. Application dependencies are verified among installed applications by &lt;code&gt;otp_patch_apply&lt;/code&gt;, but these are not necessarily those actually loaded. By calling &lt;code&gt;system_information:sanity_check()&lt;/code&gt; one can validate dependencies among applications actually loaded.</source>
          <target state="translated">응용 프로그램 종속성은 Erlang 셸을 사용하여 확인할 수 있습니다. &lt;code&gt;otp_patch_apply&lt;/code&gt; 에 의해 설치된 응용 프로그램간에 응용 프로그램 종속성이 확인 되지만 실제로로드 된 것은 아닙니다. &lt;code&gt;system_information:sanity_check()&lt;/code&gt; 를 호출하면 실제로로드 된 응용 프로그램 간의 종속성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb62df0e58b18cc0a3dd6823066bbe7bee60e95d" translate="yes" xml:space="preserve">
          <source>The application is started at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. The application is started as usual. That is, an application master is created and calls the application callback function:</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;distributed&lt;/code&gt; 구성 매개 변수 의 노드 목록에 나열된 첫 번째 운영 노드에서 시작됩니다 . 응용 프로그램은 평소와 같이 시작됩니다. 즉, 응용 프로그램 마스터가 만들어지고 응용 프로그램 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="89049fedc72f84958aace187301d7f02b79550e8" translate="yes" xml:space="preserve">
          <source>The application is started by the application master calling:</source>
          <target state="translated">응용 프로그램은 응용 프로그램 마스터 호출에 의해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bfedb4900bc06eb3b379ebe1429d3cb0e9392954" translate="yes" xml:space="preserve">
          <source>The application is started the normal way at the new node, that is, by the application master calling:</source>
          <target state="translated">응용 프로그램은 새 노드에서 정상적으로 시작됩니다. 즉, 응용 프로그램 마스터 호출에 의해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="10822e972b13555d1eff4f5137f6287954df0861" translate="yes" xml:space="preserve">
          <source>The application master calls &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; to start the top supervisor.</source>
          <target state="translated">응용 프로그램 마스터 는 최상위 감독자를 시작하기 위해 &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e29776b842b696055e58002f88fb65232061b2ab" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;Module:start/2&lt;/code&gt; as defined by the application specification key &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 마스터 는 응용 프로그램 사양 키 &lt;code&gt;mod&lt;/code&gt; 로 정의 된 응용 프로그램 콜백 함수 &lt;code&gt;Module:start/2&lt;/code&gt; 를 호출하여 응용 프로그램을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="8cabb4f62fd98a4ff2c6678b3ed5fdfd959999a1" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;start/2&lt;/code&gt; in the module, and with the start argument, defined by the &lt;code&gt;mod&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">응용 프로그램 마스터는 모듈에서 응용 프로그램 콜백 함수 &lt;code&gt;start/2&lt;/code&gt; 를 시작 하고 &lt;code&gt;.app&lt;/code&gt; 파일 의 &lt;code&gt;mod&lt;/code&gt; 키로 정의 된 start 인수를 사용 하여 응용 프로그램을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="13734b250f5eb9d546b03086cf7b41b4dea34d6f" translate="yes" xml:space="preserve">
          <source>The application master stops the application by telling the top supervisor to shut down. The top supervisor tells all its child processes to shut down, and so on; the entire tree is terminated in reversed start order. The application master then calls the application callback function &lt;code&gt;stop/1&lt;/code&gt; in the module defined by the &lt;code&gt;mod&lt;/code&gt; key.</source>
          <target state="translated">응용 프로그램 마스터는 최고 감독자에게 시스템 종료를 지시하여 응용 프로그램을 중지합니다. 최고 감독자는 모든 하위 프로세스에 종료 등을 지시합니다. 전체 트리는 시작 순서가 반대로 종료됩니다. 그런 다음 응용 프로그램 마스터 는 &lt;code&gt;mod&lt;/code&gt; 키로 정의 된 모듈에서 응용 프로그램 콜백 함수 &lt;code&gt;stop/1&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b526c8807809b1d1a78677dccccf183dc7531782" translate="yes" xml:space="preserve">
          <source>The application master then calls &lt;code&gt;Module:start/2&lt;/code&gt; for the primary application, followed by calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; for each start phase (as defined for the primary application), both for the primary application and for each of its included applications, for which the start phase is defined.</source>
          <target state="translated">그런 다음 응용 프로그램 마스터 는 기본 응용 프로그램에 대해 &lt;code&gt;Module:start/2&lt;/code&gt; 를 호출 한 다음 기본 응용 프로그램 및 포함 된 각 응용 프로그램에 대해 기본 응용 프로그램에 대해 정의 된대로 각 시작 단계에 대해 &lt;code&gt;Module:start_phase/3&lt;/code&gt; 를 호출합니다 . 시작 단계가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a163c20a5a18b97757a743989413cf19c582f80f" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R10B or later.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R10B 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47de7b9f1554880fd51a51ad6a1c134e4bb1c43b" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13B02 or later.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R13B02 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="04c072f323859be092a04c77c0d3a8f3932431a9" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13BB or later. If you use the old &lt;code&gt;GS&lt;/code&gt; based GUI it does suffice with R7B.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R13BB 이상이 필요합니다. 이전 &lt;code&gt;GS&lt;/code&gt; 기반 GUI 를 사용하는 경우 R7B로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="705f938ebc82f5cfe9e917670d636ce442e4f982" translate="yes" xml:space="preserve">
          <source>The application resource file is to be called &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in directory &lt;code&gt;ebin&lt;/code&gt; for the application.</source>
          <target state="translated">응용 프로그램 자원 파일의 이름은 &lt;code&gt;Application.app&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름입니다. 파일은 응용 프로그램의 디렉토리 &lt;code&gt;ebin&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8095bda3db4836c710654adeb79de3919a1733c3" translate="yes" xml:space="preserve">
          <source>The application settings page is rather incomplete.</source>
          <target state="translated">응용 프로그램 설정 페이지가 다소 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="a30b190dbffeb37d7579aa94007cbfaeb029e782" translate="yes" xml:space="preserve">
          <source>The application specification can also be specified directly as a tuple &lt;code&gt;AppSpec&lt;/code&gt;, having the format and contents as described in &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 사양은 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 설명 된 형식과 내용을 가진 튜플 &lt;code&gt;AppSpec&lt;/code&gt; 으로 직접 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae0f5edbfbc9e079896bc2aadb1ec402b1e46966" translate="yes" xml:space="preserve">
          <source>The application upgrade file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in the &lt;code&gt;ebin&lt;/code&gt; directory for the application.</source>
          <target state="translated">애플리케이션 업그레이드 파일의 이름은 &lt;code&gt;Application.appup&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 애플리케이션 이름입니다. 파일은 응용 프로그램 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="01be2b299856c125d638a3713ccfbcb4f60476f7" translate="yes" xml:space="preserve">
          <source>The application version of the SSL application.</source>
          <target state="translated">SSL 애플리케이션의 애플리케이션 버전입니다.</target>
        </trans-unit>
        <trans-unit id="73e6b27f7140dc43719697a589e7dc915f9cffa1" translate="yes" xml:space="preserve">
          <source>The application window is started by double clicking on an application name. The application window consists of four pages (tabs):</source>
          <target state="translated">응용 프로그램 이름은 응용 프로그램 이름을 두 번 클릭하여 시작됩니다. 응용 프로그램 창은 4 개의 페이지 (탭)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c8077f9793de81202aa1676c65a0451a20a5cbbb" translate="yes" xml:space="preserve">
          <source>The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">AVP의 응용 프로그램 중립적 표현. 기본적으로 임의의 직경 응용 프로그램을 처리해야하는 릴레이 응용 프로그램에 사용됩니다. 사전을 구성하는 특정 직경 응용 프로그램을 구현하는 서비스는 대신 &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; 유형의 값을 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e81712f8fd17dfa5b0951414305dbd11e0bfbc67" translate="yes" xml:space="preserve">
          <source>The applications are sorted according to the dependencies between the applications. Where there are no dependencies, the order in the &lt;code&gt;.rel&lt;/code&gt; file is kept.</source>
          <target state="translated">응용 프로그램은 응용 프로그램 간의 종속성에 따라 정렬됩니다. 종속성이없는 경우 &lt;code&gt;.rel&lt;/code&gt; 파일 의 순서 가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="85353072338b2dbf168feea1aabc66961c7a142d" translate="yes" xml:space="preserve">
          <source>The archive must be closed with &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">아카이브는 &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt; 로 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd634904a6b19656df55ba94518706b87469aeb9" translate="yes" xml:space="preserve">
          <source>The archive size is limited to 2 GB (32 bits).</source>
          <target state="translated">아카이브 크기는 2GB (32 비트)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="cd12ca75aaea91ed2a310f36dcea8f4976e41af5" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;DefaultAgentConfig&lt;/code&gt; is used as default values when this user register agents.</source>
          <target state="translated">이 사용자가 에이전트를 등록 할 때 &lt;code&gt;DefaultAgentConfig&lt;/code&gt; 인수 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69004e83d19b67fea82f2e443fe9acacd301728c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Extra&lt;/code&gt; is just an opaque data structure passed to the user via the callback functions in the &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt;. Note however that if &lt;code&gt;Extra&lt;/code&gt; has the value &lt;code&gt;extra_undefined&lt;/code&gt; the argument will be ignored (same as if &lt;code&gt;process_received_message/4&lt;/code&gt; had been called). See the documentation for the behaviour of the callback module, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt;, for more info.</source>
          <target state="translated">&lt;code&gt;Extra&lt;/code&gt; 인수 는 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt; 의 콜백 함수를 통해 사용자에게 전달되는 불투명 한 데이터 구조 입니다. 그러나 &lt;code&gt;Extra&lt;/code&gt; 에 &lt;code&gt;extra_undefined&lt;/code&gt; 값이 있으면 인수는 무시됩니다 ( &lt;code&gt;process_received_message/4&lt;/code&gt; 가 호출 된 것과 동일 ). 자세한 내용은 콜백 모듈 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt; 의 동작에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f459c21deb16ca0d8a2238ea1bb013af1aa40900" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to read for future connections.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; 인수 는 원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 핸들 입니다. 인수 &lt;code&gt;Opts&lt;/code&gt; 는 향후 연결을 위해 읽을 수있는 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="debf3f82b456b10623118b0f8614068c9ab5fae7" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to set on future connections.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; 인수 는 원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 핸들 입니다. 인수 &lt;code&gt;Opts&lt;/code&gt; 는 향후 연결에서 설정할 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6f649282c95c4ff27efd3a1061e1c2bdcdf508eb" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. It returns &lt;code&gt;{atomic, TabList}&lt;/code&gt; if successful, or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt; if there is an error. &lt;code&gt;TabList&lt;/code&gt; is a list of the restored tables. Tables that are restored are write-locked during the restore operation. However, regardless of any lock conflict caused by this, applications can continue to do their work during the restore operation.</source>
          <target state="translated">&lt;code&gt;Opaque&lt;/code&gt; 인수 는 백업 모듈로 전달됩니다. 성공하면 &lt;code&gt;{atomic, TabList}&lt;/code&gt; 를, 오류가 있으면 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 리턴합니다 . &lt;code&gt;TabList&lt;/code&gt; 는 복원 된 테이블의 목록입니다. 복원 된 테이블은 복원 작업 중에 쓰기 잠금 상태입니다. 그러나 이로 인한 잠금 충돌에 관계없이 응용 프로그램은 복원 조작 중에 계속 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfff5e2db73b8f539cd9908f48d194bda191ddfc" translate="yes" xml:space="preserve">
          <source>The argument can also be a list of modules or filenames, in which case the function tries to interpret each module as specified earlier. The function then always returns &lt;code&gt;ok&lt;/code&gt;, but prints some information to &lt;code&gt;stdout&lt;/code&gt; if a module cannot be interpreted.</source>
          <target state="translated">인수는 모듈 또는 파일 이름 목록 일 수도 있습니다.이 경우 함수는 이전에 지정된대로 각 모듈을 해석하려고합니다. 그런 다음이 함수는 항상 &lt;code&gt;ok&lt;/code&gt; 를 반환 하지만 모듈을 해석 할 수없는 경우 일부 정보를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f72a488906a1bc4231e746b4ff7b4a8e45eb6fc3" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt;, where the precision is the number of digits written. The default precision is 6 and it cannot be &amp;lt; 2.</source>
          <target state="translated">인수는 &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt; 로 작성된 부동 소수점입니다 . 여기서 정밀도는 기록 된 자릿수입니다. 기본 정밀도는 6이며 &amp;lt;2는 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93d3f166ed7f071a0cf8c5e27837f3a0c6681247" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]ddd.ddd&lt;/code&gt;, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &amp;lt; 1.</source>
          <target state="translated">인수는 &lt;code&gt;[-]ddd.ddd&lt;/code&gt; 로 작성된 부동 소수점입니다 . 여기서 정밀도는 소수점 뒤의 자릿수입니다. 기본 정밀도는 6이며 &amp;lt;1 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="049df39b974433b181b76b3894315e239a3ad777" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;f&lt;/code&gt;, if it is &amp;gt;= 0.1 and &amp;lt; 10000.0. Otherwise, it is written in the &lt;code&gt;e&lt;/code&gt; format. The precision is the number of significant digits. It defaults to 6 and is not to be &amp;lt; 2. If the absolute value of the float does not allow it to be written in the &lt;code&gt;f&lt;/code&gt; format with the desired number of significant digits, it is also written in the &lt;code&gt;e&lt;/code&gt; format.</source>
          <target state="translated">인수는 &amp;gt; = 0.1이고 &amp;lt;10000.0 인 경우 &lt;code&gt;f&lt;/code&gt; 로 작성된 부동 소수점입니다 . 그렇지 않으면 &lt;code&gt;e&lt;/code&gt; 형식으로 작성 됩니다. 정밀도는 유효 자릿수입니다. 기본값은 6이며 &amp;lt;2는 아닙니다. float의 절대 값으로 원하는 수의 유효 자릿수 를 사용하여 &lt;code&gt;f&lt;/code&gt; 형식으로 쓸 수없는 경우 &lt;code&gt;e&lt;/code&gt; 형식으로도 씁니다.</target>
        </trans-unit>
        <trans-unit id="fd2ce2991cd1ed1c5544565d4bc9f56a7a9da522" translate="yes" xml:space="preserve">
          <source>The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:</source>
          <target state="translated">인수는 ASCII 코드로 해석되는 숫자입니다. 정밀도는 문자가 인쇄되는 횟수이며 기본값은 필드 너비이며 기본값은 1입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="41417c1b36d7d073dd070139b59528225284b877" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;init_per_suite&lt;/code&gt; is &lt;code&gt;Config&lt;/code&gt;, that is, the same key-value list of runtime configuration data that each test case takes as input argument. &lt;code&gt;init_per_suite&lt;/code&gt; can modify this parameter with information that the test cases need. The possibly modified &lt;code&gt;Config&lt;/code&gt; list is the return value of the function.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 의 인수 는 &lt;code&gt;Config&lt;/code&gt; 입니다 . 즉, 각 테스트 케이스가 입력 인수로 취하는 동일한 런타임 구성 데이터의 키-값 목록입니다. &lt;code&gt;init_per_suite&lt;/code&gt; 는 테스트 케이스에 필요한 정보로이 매개 변수를 수정할 수 있습니다. 수정 가능한 &lt;code&gt;Config&lt;/code&gt; 목록은 함수의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="19116289e2a06f46f52b99e7a354d07e181d8263" translate="yes" xml:space="preserve">
          <source>The argument type change is from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">인수 유형 변경은 부호에서 부호없는 것으로 변경됩니다. 예를 들어, 장소 전체에서 유형 만 변경하면 루프 종료 조건이나 오류 조건에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518f1110847b76edf7686b0d43ca29a942986a62" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;{local, error_man}&lt;/code&gt; specifies the name. The event manager is then locally registered as &lt;code&gt;error_man&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{local, error_man}&lt;/code&gt; 인수 는 이름을 지정합니다. 그런 다음 이벤트 관리자는 로컬로 &lt;code&gt;error_man&lt;/code&gt; 으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="0afbf43c606253c8ecf1c39998b54bbb8fa67440" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;FormatArgs&lt;/code&gt; in &lt;code&gt;ct:log/print/pal&lt;/code&gt; are always passed on to the STDLIB function &lt;code&gt;io:format/3&lt;/code&gt; (For details, see the &lt;code&gt;io&lt;/code&gt; manual page).</source>
          <target state="translated">인수의 &lt;code&gt;Format&lt;/code&gt; 과 &lt;code&gt;FormatArgs&lt;/code&gt; 에서 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 항상 STDLIB 함수에 전달되는 &lt;code&gt;io:format/3&lt;/code&gt; (자세한 내용은 참조 &lt;code&gt;io&lt;/code&gt; 매뉴얼 페이지를).</target>
        </trans-unit>
        <trans-unit id="ad2c02ade68b15ea95b904a33d006adc1b1cf304" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SnmpInfo&lt;/code&gt; relates in the following way:</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;SnmpInfo&lt;/code&gt; 인수 는 다음과 같은 방식으로 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="6b287b1ceba326e901144e95b8db2f9f2999be1d" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt;filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">인수는 실행 파일에 제공되기 전에 쉘에 의해 확장되지 않습니다. 특히 이것은 파일 와일드 카드 확장이 발생하지 않음을 의미합니다. 인수의 와일드 카드를 확장하려면 &lt;code&gt;filelib:wildcard/1&lt;/code&gt; 을 사용하십시오 . 프로그램이 Unix 쉘 스크립트 인 경우에도 쉘이 궁극적으로 호출되고 와일드 카드 확장이 발생하지 않으며 스크립트는 수정되지 않은 인수와 함께 제공됩니다. Windows에서 와일드 카드 확장은 항상 프로그램 자체에 달려 있으므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="522ee4260f97c142662210e82bcb713e534c2aad" translate="yes" xml:space="preserve">
          <source>The arguments can be divided into &lt;strong&gt;emulator flags&lt;/strong&gt;, &lt;strong&gt;flags&lt;/strong&gt;, and &lt;strong&gt;plain arguments&lt;/strong&gt;:</source>
          <target state="translated">인수는 &lt;strong&gt;에뮬레이터 플래그&lt;/strong&gt; , &lt;strong&gt;플래그&lt;/strong&gt; 및 &lt;strong&gt;일반 인수&lt;/strong&gt; 로 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ed9ef38109b234ba45603e287f33458c0a6ac4" translate="yes" xml:space="preserve">
          <source>The arguments can be of different data types. The following order is defined:</source>
          <target state="translated">인수는 다른 데이터 유형이 될 수 있습니다. 다음 순서가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ffa892e870535324db1c0ec38851cc864f132069" translate="yes" xml:space="preserve">
          <source>The arguments:</source>
          <target state="translated">인수 :</target>
        </trans-unit>
        <trans-unit id="a8a87576167815553ae803598fc43fec00d99fc0" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) for the current function.</source>
          <target state="translated">현재 함수의 arity (인수).</target>
        </trans-unit>
        <trans-unit id="f4a92fd68167fdb3dffdde93bfe14f1434196818" translate="yes" xml:space="preserve">
          <source>The arity of the function implementing the fun.</source>
          <target state="translated">재미를 구현하는 기능의 arity.</target>
        </trans-unit>
        <trans-unit id="2e0c7ead6f817b15595de5c93baf2426dbf01b86" translate="yes" xml:space="preserve">
          <source>The arity of the function must match the number of arguments, else a compilation error occurs.</source>
          <target state="translated">함수의 arity는 인수의 수와 일치해야합니다. 그렇지 않으면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a567fbfc0f0119591979c89645ce71555342bc2e" translate="yes" xml:space="preserve">
          <source>The array length, that is, the function arity. &lt;code&gt;argv[N-1]&lt;/code&gt; thus denotes the Nth argument to the NIF. Notice that the argument &lt;code&gt;argc&lt;/code&gt; allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</source>
          <target state="translated">배열 길이, 즉 함수 arity &lt;code&gt;argv[N-1]&lt;/code&gt; 은 NIF에 대한 N 번째 인수를 나타냅니다. 인수 &lt;code&gt;argc&lt;/code&gt; 를 사용하면 동일한 C 함수가 다른 arity (그러나 아마도 이름이 같은)를 가진 여러 Erlang 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415f03b07c8ba3c8c05edaadd6e77c05a2cd0868" translate="yes" xml:space="preserve">
          <source>The array never shrinks automatically. If an index &lt;code&gt;I&lt;/code&gt; has been used to set an entry successfully, all indices in the range [0,&lt;code&gt;I&lt;/code&gt;] stay accessible unless the array size is explicitly changed by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열은 자동으로 축소되지 않습니다. 인덱스 &lt;code&gt;I&lt;/code&gt; 을 사용하여 항목을 성공적으로 설정 한 경우 &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 배열 크기를 명시 적으로 변경하지 않으면 [0, &lt;code&gt;I&lt;/code&gt; ] 범위의 모든 인덱스에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41821fc2a208b561d81f20833df1e2cf397cd22d" translate="yes" xml:space="preserve">
          <source>The associated code contains &lt;code&gt;pseudo variables&lt;/code&gt;&lt;code&gt;'$1'&lt;/code&gt;, &lt;code&gt;'$2'&lt;/code&gt;, &lt;code&gt;'$3'&lt;/code&gt;, etc. which refer to (are bound to) the values associated previously by the parser with the symbols of the right hand side of the rule. When these symbols are terminal categories, the values are token tuples of the input string (see above).</source>
          <target state="translated">연관된 코드에는 &lt;code&gt;pseudo variables&lt;/code&gt; &lt;code&gt;'$1'&lt;/code&gt; , &lt;code&gt;'$2'&lt;/code&gt; , &lt;code&gt;'$3'&lt;/code&gt; 등이 포함되며, 이는 규칙의 오른쪽 기호로 구문 분석기가 이전에 연관시킨 값을 참조합니다. 이러한 기호가 터미널 범주 인 경우 값은 입력 문자열의 토큰 튜플입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="3898cfb8a11a62ffe2fdba8be9357512d68bb196" translate="yes" xml:space="preserve">
          <source>The associated code may not only be used to build structures associated with phrases, but may also be used for syntactic and semantic tests, printout actions (for example for tracing), etc. during the parsing process. Since tokens contain positional (line number) information, it is possible to produce error messages which contain line numbers. If there is no associated code after the right hand side of the rule, the value &lt;code&gt;'$undefined'&lt;/code&gt; is associated with the phrase.</source>
          <target state="translated">연관된 코드는 구문과 연관된 구조를 빌드하는 데 사용될뿐만 아니라 구문 분석 프로세스 동안 구문 및 의미 론적 테스트, 인쇄 조치 (예 : 추적) 등에도 사용될 수 있습니다. 토큰은 위치 (행 번호) 정보를 포함하므로 행 번호를 포함하는 오류 메시지를 생성 할 수 있습니다. 규칙의 오른쪽 뒤에 연결된 코드가 없으면 &lt;code&gt;'$undefined'&lt;/code&gt; 값 이 문구와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="6b6e33dc105b7762f1d530b48ab29c546fd13258" translate="yes" xml:space="preserve">
          <source>The association cannot be established (&lt;code&gt;connect/*&lt;/code&gt; failure).</source>
          <target state="translated">연결을 설정할 수 없습니다 ( &lt;code&gt;connect/*&lt;/code&gt; failure).</target>
        </trans-unit>
        <trans-unit id="ef9716ac7174f55cae16eacb1845e6a71402ef24" translate="yes" xml:space="preserve">
          <source>The association file &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; for the real implementation looks as follows:</source>
          <target state="translated">실제 구현을위한 연관 파일 &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81d1ef649b0dc2cac7a3f4619510067970a6fd77" translate="yes" xml:space="preserve">
          <source>The association file, which contains the names of instrumentation functions for the MIB, should have the suffix &lt;code&gt;.funcs&lt;/code&gt;. If the compiler does not find the association file, it gives a warning message and uses default instrumentation functions. (See &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; for more details).</source>
          <target state="translated">MIB의 인스 트루먼 테이션 함수 이름이 포함 된 연관 파일은 접미 부 &lt;code&gt;.funcs&lt;/code&gt; 를 가져야 합니다. 컴파일러가 연결 파일을 찾지 못하면 경고 메시지가 표시되고 기본 계측 기능을 사용합니다. (자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; 을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="9e61865049f08d1e62a4b88bd1b23185c90eb9da" translate="yes" xml:space="preserve">
          <source>The asymetric encryption algorithm used in the server's private-public host key pair. Examples include the well-known RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; and elliptic curve &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt;.</source>
          <target state="translated">서버의 개인-공용 호스트 키 쌍에서 사용되는 비대칭 암호화 알고리즘. 그 예로는 잘 알려진 RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; 와 타원 곡선 &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b06000d023218a0553695852ada6423beef957" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비동기 스레드 풀 크기는 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 에서 명령 행 인수 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; 를 사용 하여 설정할 수 있습니다 . 비동기 스레드 풀을 사용할 수없는 경우 &lt;code&gt;driver_async&lt;/code&gt; 를 호출하는 스레드에서 동 기적으로 호출 됩니다. 비동기 스레드 풀의 현재 비동기 스레드 수는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d949b17e0550064c4ba8e06402f035e12b3129f" translate="yes" xml:space="preserve">
          <source>The asynchronous API for drivers is complicated. First, the work must be prepared. In the example, this is done in &lt;code&gt;output&lt;/code&gt;. We could have used &lt;code&gt;control&lt;/code&gt;, but we want some variation in the examples. In our driver, we allocate a structure that contains anything that is needed for the asynchronous task to do the work. This is done in the main emulator thread. Then the asynchronous function is called from a driver thread, separate from the main emulator thread. Notice that the driver functions are not re-entrant, so they are not to be used. Finally, after the function is completed, the driver callback &lt;code&gt;ready_async&lt;/code&gt; is called from the main emulator thread, this is where we return the result to Erlang. (We cannot return the result from within the asynchronous function, as we cannot call the driver functions.)</source>
          <target state="translated">드라이버의 비동기 API는 복잡합니다. 먼저 작업을 준비해야합니다. 이 예에서는 &lt;code&gt;output&lt;/code&gt; 에서 수행됩니다 . 우리는 &lt;code&gt;control&lt;/code&gt; 을 사용할 수 있었지만 예제에서 약간의 변형을 원합니다. 드라이버에서 비동기 작업이 작업을 수행하는 데 필요한 모든 것을 포함하는 구조를 할당합니다. 이것은 메인 에뮬레이터 스레드에서 수행됩니다. 그런 다음 비동기 함수는 기본 에뮬레이터 스레드와 별도로 드라이버 스레드에서 호출됩니다. 드라이버 기능은 다시 입력 할 수 없으므로 사용하지 마십시오. 마지막으로 함수가 완료된 후 드라이버 콜백 &lt;code&gt;ready_async&lt;/code&gt; 메인 에뮬레이터 스레드에서 호출되며, 여기서 결과를 Erlang으로 반환합니다. 드라이버 함수를 호출 할 수 없으므로 비동기 함수 내에서 결과를 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb8f8a1d61eec151d7bbdbad482f3278e892dcab" translate="yes" xml:space="preserve">
          <source>The asynchronous request &lt;code&gt;free(Ch)&lt;/code&gt; is implemented using &lt;code&gt;gen_server:cast/2&lt;/code&gt;:</source>
          <target state="translated">비동기 요청 &lt;code&gt;free(Ch)&lt;/code&gt; 는 &lt;code&gt;gen_server:cast/2&lt;/code&gt; 를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="13cb8db4869505cfe3b89f4b66cbde4b8e730e2a" translate="yes" xml:space="preserve">
          <source>The asynchronous version of the driver is in the sample files &lt;code&gt;pg_async.c&lt;/code&gt; and &lt;code&gt;pg_asyng.erl&lt;/code&gt;.</source>
          <target state="translated">드라이버의 비동기 버전은 샘플 파일 &lt;code&gt;pg_async.c&lt;/code&gt; 및 &lt;code&gt;pg_asyng.erl&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ad31c862f53147c29592fd7356527c9ffced30" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Behaviour&lt;/code&gt; gives the name of the behaviour, which can be a user-defined behaviour or one of the following OTP standard behaviours:</source>
          <target state="translated">Atom &lt;code&gt;Behaviour&lt;/code&gt; 는 사용자 정의 동작 또는 다음 OTP 표준 동작 중 하나 일 수있는 동작의 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b6c48f50dc1798aeaec7a743fffe7be10b28e3a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Name&lt;/code&gt; is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table.</source>
          <target state="translated">아톰 &lt;code&gt;Name&lt;/code&gt; 은 테이블 이름입니다. 테이블의 모든 후속 작업에서 테이블 이름을 제공해야합니다. 이름은 다른 프로세스에서도 사용할 수 있으며 많은 프로세스가 하나의 테이블을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c510ba5b1215726673e2f72d3059e72c9e136b36" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;activity&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;activity&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9710032c39f79ee3070e26173f96829389498bd7" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;finished&lt;/code&gt; is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;ping finished&quot; is written to the output. &quot;Ping&quot; then terminates as it has nothing left to do.</source>
          <target state="translated">&lt;code&gt;finished&lt;/code&gt; 원자 는 &quot;퐁&quot;으로 보내지고 (위에서 설명한대로 종료 됨) &quot;핑 완료&quot;가 출력에 기록됩니다. &quot;Ping&quot;은 남은 작업이 없기 때문에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d82cb2c455d0963906d4919213af14bc97a0dc7e" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;hibernate&lt;/code&gt; in the action list on the last line when entering the &lt;code&gt;{open,_}&lt;/code&gt; state is the only change. If any event arrives in the &lt;code&gt;{open,_},&lt;/code&gt; state, we do not bother to rehibernate, so the server stays awake after any event.</source>
          <target state="translated">원자 &lt;code&gt;hibernate&lt;/code&gt; 유입 마지막 행의 작업리스트 &lt;code&gt;{open,_}&lt;/code&gt; 상태는 단지 변화이다. 어떤 이벤트가 &lt;code&gt;{open,_},&lt;/code&gt; 상태에 도달하면 , 우리는 재개를 귀찮게하지 않으므로 서버는 이벤트 후에 깨어 있습니다.</target>
        </trans-unit>
        <trans-unit id="356f9715c2aad0ed355593e69081e1f8b8476d8f" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending&lt;/code&gt;, which means that a monitor is to be created whenever a load operation is delayed,</source>
          <target state="translated">atom &lt;code&gt;pending&lt;/code&gt; 은로드 조작이 지연 될 때마다 모니터가 작성됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="161e6641a902cec6d4ca9159bb2b569a7ff90c0a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending_driver&lt;/code&gt;, in which a monitor is created whenever the operation is delayed because of open ports to an otherwise unused driver.</source>
          <target state="translated">atom &lt;code&gt;pending_driver&lt;/code&gt; . 사용되지 않는 드라이버에 대한 열린 포트로 인해 조작이 지연 될 때마다 모니터가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d60a51c643f2a02e17349df9085c521ad7bd0aa" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;system&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;system&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42969bfd0b03becb2a706b91287d2fd18b7a8038" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c920e9113121f0b04e27b3e131485fc54743c" translate="yes" xml:space="preserve">
          <source>The atomicity and the isolation properties of &lt;code&gt;Mnesia&lt;/code&gt; are lost.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 원자 성과 분리 특성 이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8c1bd67e98ea142e16fbd8328c31a4abe8ce1c" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">원자 &lt;code&gt;big&lt;/code&gt; 및 &lt;code&gt;little&lt;/code&gt; 나타낸다 BIG-또는 리틀 엔디안 인코딩.</target>
        </trans-unit>
        <trans-unit id="eec0aca30bfb32af191c5b7f63bda050342a54ff" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;send&lt;/code&gt;, &lt;code&gt;'receive'&lt;/code&gt;, and &lt;code&gt;timeout&lt;/code&gt; for sends and receives (&lt;code&gt;'receive'&lt;/code&gt; when a message is received and &lt;code&gt;timeout&lt;/code&gt; when a receive times out)</source>
          <target state="translated">원자들은 &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;'receive'&lt;/code&gt; , 및 &lt;code&gt;timeout&lt;/code&gt; 에 대한 송신하고 (수신 &lt;code&gt;'receive'&lt;/code&gt; 메시지가 수신 될 때 &lt;code&gt;timeout&lt;/code&gt; A가 시간을 수신 할 때)</target>
        </trans-unit>
        <trans-unit id="d6808e92018a30d64fa086f0dfa84d2f8448d1ef" translate="yes" xml:space="preserve">
          <source>The attribute OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">속성 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f3b18eb4341c86b8c0684826dff3c42219fcc2" translate="yes" xml:space="preserve">
          <source>The author can choose to put many or few tests into each test case. Some things to keep in mind follows:</source>
          <target state="translated">작성자는 각 테스트 사례에 여러 테스트를 수행하도록 선택할 수 있습니다. 명심해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="badc70f1a60a87b4c3438b8a7de6f4c78b5a65bc" translate="yes" xml:space="preserve">
          <source>The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.</source>
          <target state="translated">자동 저장 간격. 이 시간 동안 테이블에 액세스하지 않으면 테이블이 디스크로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="c039d5fb00e0ef90ed0ae37b0f2d061a360a486a" translate="yes" xml:space="preserve">
          <source>The autostart feature requires more data to be stored on traced nodes. By default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot; in the currect working directory (cwd) of the traced node. Users can change this behaviour (that is, on diskless nodes) by specifying their own module to handle autostart data storage and retrieval (&lt;code&gt;ttb_autostart_module&lt;/code&gt; environment variable of &lt;code&gt;runtime_tools&lt;/code&gt;). For information about the API, see module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;. The following example shows the default handler:</source>
          <target state="translated">자동 시작 기능을 사용하려면 추적 된 노드에 더 많은 데이터를 저장해야합니다. 기본적으로 데이터는 추적 된 노드의 정확한 작업 디렉토리 (cwd)에있는 &quot;ttb_autostart.bin&quot;파일에 자동으로 저장됩니다. 사용자는 자동 시작 데이터 저장 및 검색을 처리하기 위해 자체 모듈을 지정하여 (디스크가없는 노드에서)이 동작을 변경할 수 있습니다 ( &lt;code&gt;runtime_tools&lt;/code&gt; 의 &lt;code&gt;ttb_autostart_module&lt;/code&gt; 환경 변수 ). API에 대한 정보는 모듈 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 다음 예제는 기본 핸들러를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ec0674516ee9bb18698545632ddcef7eb77a1e62" translate="yes" xml:space="preserve">
          <source>The available OID names are as follows:</source>
          <target state="translated">사용 가능한 OID 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270053ab9a2cdd71b431ca1b29230d0131168ac8" translate="yes" xml:space="preserve">
          <source>The available configuration options are as follows:</source>
          <target state="translated">사용 가능한 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd517ca47007c093bb8a7cefdb756ebfdced63" translate="yes" xml:space="preserve">
          <source>The available configuration properties are as follows:</source>
          <target state="translated">사용 가능한 구성 특성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d5fbe85b0c98fe746cb7e16c8187e2dfc18521e" translate="yes" xml:space="preserve">
          <source>The average run-time for the schedulers. This is the average amount of time the schedulers did not sleep.</source>
          <target state="translated">스케줄러의 평균 런타임 스케줄러가 휴면하지 않은 평균 시간입니다.</target>
        </trans-unit>
        <trans-unit id="aaf853276797e4d431ffd98c86f3b72f5161ab87" translate="yes" xml:space="preserve">
          <source>The average time spent collecting data in the threads. This should be close to the time which data was collected.</source>
          <target state="translated">스레드에서 데이터를 수집하는 데 소요 된 평균 시간입니다. 이것은 데이터가 수집 된 시간에 근접해야합니다.</target>
        </trans-unit>
        <trans-unit id="70cab81b62df4bb768ae5b9f87b1769a35f91166" translate="yes" xml:space="preserve">
          <source>The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">백 슬래시 문자는 여러 용도로 사용됩니다. 첫째, 숫자 나 문자가 아닌 문자가 뒤에 오는 경우 문자가 가질 수있는 특별한 의미를 제거합니다. 이스케이프 문자로 백 슬래시를 사용하면 내부 및 외부 문자 클래스에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbe5fe5807b426b9440606cd7c73c539d1bcdeff" translate="yes" xml:space="preserve">
          <source>The backup data is divided into two sections. The first section contains information related to the schema. All schema-related items are tuples where the first field equals the atom schema. The second section is the record section. Schema records cannot be mixed with other records and all schema records must be located first in the backup.</source>
          <target state="translated">백업 데이터는 두 섹션으로 나뉩니다. 첫 번째 섹션에는 스키마와 관련된 정보가 포함되어 있습니다. 모든 스키마 관련 항목은 첫 번째 필드가 원자 스키마와 동일한 튜플입니다. 두 번째 섹션은 레코드 섹션입니다. 스키마 레코드는 다른 레코드와 혼합 할 수 없으며 백업에서 모든 스키마 레코드를 먼저 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="5cb61dbbe8949ce8224db389cdf36c3f301c26b1" translate="yes" xml:space="preserve">
          <source>The base AVPs are defined in the common dictionary provided by diameter. There are common dictionaries for both RFC 3588 and RFC 6733 since the latter made changes to both syntax and semantics.</source>
          <target state="translated">기본 AVP는 직경으로 제공되는 공통 사전에 정의되어 있습니다. RFC 3588과 RFC 6733에 대한 공통 사전이 있는데, 후자는 구문과 의미를 모두 변경했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="37b6dd9b192c11e194c06eb99987679081a97762" translate="yes" xml:space="preserve">
          <source>The base name of the compiled file</source>
          <target state="translated">컴파일 된 파일의 기본 이름</target>
        </trans-unit>
        <trans-unit id="13db919a8612a7a4080781ff054af866565ed391" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">윈도우 크기의 기본 2 로그 (이력 버퍼 크기). 값은 8에서 15 사이 여야합니다. 값이 클수록 메모리 사용량을 희생하여 압축 성능이 향상됩니다. &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; 가 사용되는 경우 기본값은 15 입니다. 음수의 &lt;code&gt;WindowBits&lt;/code&gt; 값은 스트림에서 zlib 헤더 및 체크섬을 억제합니다. zlib 소스는이를 문서화되지 않은 기능으로 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="8818564f19c5c56bd354986044623c1ba1d3d72f" translate="yes" xml:space="preserve">
          <source>The basic concept is that of a &lt;strong&gt;MIB view&lt;/strong&gt;. An MIB view is a subset of all the objects implemented by an agent. A manager has access to a certain MIB view, depending on which security parameters are used, in which context the request is made, and which type of request is made.</source>
          <target state="translated">기본 개념은 &lt;strong&gt;MIB보기&lt;/strong&gt; 의 개념입니다 . MIB보기는 에이전트가 구현 한 모든 개체의 하위 집합입니다. 관리자는 사용되는 보안 매개 변수, 요청 된 컨텍스트 및 요청 유형에 따라 특정 MIB보기에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4956ca9b4e8f3cd207abf9624e243d3cdb794f4d" translate="yes" xml:space="preserve">
          <source>The basic idea of syntax highlighting is to make the structure of a program clearer. For example, the highlighting will make it easier to spot simple bugs. Have not you ever written a variable in lower-case only? With syntax highlighting a variable will colored while atoms will be shown with the normal text color.</source>
          <target state="translated">구문 강조의 기본 개념은 프로그램의 구조를 더 명확하게하는 것입니다. 예를 들어, 강조 표시를 사용하면 간단한 버그를 쉽게 찾을 수 있습니다. 소문자로만 변수를 쓰지 않았습니까? 구문 강조 표시를 사용하면 변수에 색상이 표시되고 원자는 일반 텍스트 색상으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad538ab434ab340ba09c1c90fc3a4a6dea30af6" translate="yes" xml:space="preserve">
          <source>The basic idea with exclusive decode is to specify which parts of the message you want to exclude from being decoded. These parts remain encoded and are returned in the value structure as binaries. They can be decoded in turn by passing them to a certain &lt;code&gt;decode_part/2&lt;/code&gt; function. The performance gain is high for large messages. You can do an exclusive decode and later one or more decodes of the parts, or a second complete decode instead of two or more complete decodes.</source>
          <target state="translated">독점적 인 디코딩의 기본 아이디어는 디코딩 할 메시지에서 제외 할 메시지 부분을 지정하는 것입니다. 이러한 부분은 인코딩 된 상태로 유지되며 값 구조에서 이진으로 반환됩니다. 그것들은 그것들을 특정한 &lt;code&gt;decode_part/2&lt;/code&gt; 함수 에 전달함으로써 차례로 해독 될 수 있습니다 . 큰 메시지의 경우 성능이 향상됩니다. 배타적 디코딩과 나중에 파트의 하나 이상의 디코드 또는 두 개 이상의 완전한 디코드 대신 두 번째 완전한 디코드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34b055b96b341faab090f12091572854579bc39" translate="yes" xml:space="preserve">
          <source>The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with.</source>
          <target state="translated">원래 프로토콜의 기본 아이디어는 여전히 유효합니다. I / O 서버 및 클라이언트는 하나의 단순한 프로토콜과 통신하며 클라이언트에 서버 상태가 없습니다. 모든 I / O 서버는 모든 클라이언트 코드와 함께 사용될 수 있으며 클라이언트 코드는 I / O 서버가 통신하는 I / O 장치를 인식 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06f35fc40ac6c0c6f620803908f2d0ce6893c711" translate="yes" xml:space="preserve">
          <source>The basic message file</source>
          <target state="translated">기본 메시지 파일</target>
        </trans-unit>
        <trans-unit id="7b96cdbd69bdcaed6a11b07691044f3fc504705b" translate="yes" xml:space="preserve">
          <source>The behavior if a file specified in &lt;code&gt;sys.config&lt;/code&gt; does not exist, or is erroneous, is backwards compatible. Starting the runtime system will fail. Installing a new release version will not fail, but an error message is returned and the erroneous file is ignored.</source>
          <target state="translated">&lt;code&gt;sys.config&lt;/code&gt; 에 지정된 파일 이 없거나 오류가있는 경우 동작이 이전 버전과 호환됩니다. 런타임 시스템 시작에 실패합니다. 새 릴리스 버전을 설치해도 실패하지 않지만 오류 메시지가 반환되고 잘못된 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a86acb8a0f20fdc979242a6b86b6e670d328548d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; This is because &lt;code&gt;write&lt;/code&gt; operations on a &lt;code&gt;Mnesia&lt;/code&gt; table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 테이블을 순회하는 동안 프로세스가 테이블에서 쓰기 작업을 수행하는 경우 동작이 정의되지 않습니다. 이는 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에 대한 &lt;code&gt;write&lt;/code&gt; 작업으로 인해 테이블 자체의 내부 재구성이 발생할 수 있기 때문 입니다. 이것은 구현 세부 사항이지만 더티 함수는 저수준 함수라는 것을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="1a796a85b7d7280f632e4dcbf6b4a44abe35956e" translate="yes" xml:space="preserve">
          <source>The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(* PRUNE : NAME)의 동작은 (* MARK : NAME) (* PRUNE)과 다릅니다. 이름이 호출자에게 다시 전달 된 것으로 기억된다는 점에서 (* MARK : NAME)과 같습니다. 그러나 (* SKIP : NAME)은 (* MARK)로 설정된 이름 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="47227c0747ba0b82f4e36ef4aee5b965307890ad" translate="yes" xml:space="preserve">
          <source>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(* THEN : NAME)의 동작은 (* MARK : NAME) (* THEN)과 다릅니다. 이름이 호출자에게 다시 전달 된 것으로 기억된다는 점에서 (* MARK : NAME)과 같습니다. 그러나 (* SKIP : NAME)은 (* MARK)로 설정된 이름 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e44b071bcc39a063eb56d16dfbf4c6bb36987d8b" translate="yes" xml:space="preserve">
          <source>The behavior of a socket with this option set to &lt;code&gt;true&lt;/code&gt; is the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of &lt;code&gt;false&lt;/code&gt;. This policy shift among operating systems to separate IPv6 from IPv4 traffic has evolved, as it gradually proved hard and complicated to get a dual stack implementation correct and secure.</source>
          <target state="translated">이 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 소켓의 동작은 유일한 이식성입니다. IPv6가 모든 트래픽에 IPv6을 처음 사용했을 때의 원래 아이디어는 FreeBSD에서 권장하지 않으며 ( &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; 를 사용하여 권장 시스템 기본값을 무시할 수 있음) OpenBSD (지원되는 GENERIC 커널)에서 금지하며 불가능합니다. Windows (별도의 IPv4 및 IPv6 프로토콜 스택이 있음). 대부분의 Linux 배포판에는 여전히 시스템 기본값이 &lt;code&gt;false&lt;/code&gt; 입니다. IPv6 트래픽을 IPv4 트래픽과 분리하기위한 운영 체제 간의 이러한 정책 전환은 점차적으로 이중 스택 구현을 정확하고 안전하게 얻는 것이 어렵고 복잡 해짐에 따라 발전했습니다.</target>
        </trans-unit>
        <trans-unit id="1a4c4b510c91839af2b2d840f0dd22a548ca7548" translate="yes" xml:space="preserve">
          <source>The behavior of dot regarding newlines can be changed. If option &lt;code&gt;dotall&lt;/code&gt; is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it.</source>
          <target state="translated">개행에 관한 도트의 동작을 변경할 수 있습니다. &lt;code&gt;dotall&lt;/code&gt; 옵션 이 설정되면 점은 예외없이 모든 문자와 일치합니다. 두 문자 시퀀스 CRLF가 제목 문자열에 있으면 두 점이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7965ee081ee817356aeac4f791276c29588e7325" translate="yes" xml:space="preserve">
          <source>The behavior of shell escape can be changed by the STDLIB application variable &lt;code&gt;shell_esc&lt;/code&gt;. The value of the variable can be either &lt;code&gt;jcl&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt;) or &lt;code&gt;abort&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt;). The first option sets &lt;code&gt;^G&lt;/code&gt; to activate &lt;code&gt;JCL&lt;/code&gt; mode (which is also default behavior). The latter sets &lt;code&gt;^G&lt;/code&gt; to terminate the current shell and start a new one. &lt;code&gt;JCL&lt;/code&gt; mode cannot be invoked when &lt;code&gt;shell_esc&lt;/code&gt; is set to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">쉘 이스케이프 동작은 STDLIB 애플리케이션 변수 &lt;code&gt;shell_esc&lt;/code&gt; 에 의해 변경 될 수 있습니다 . 변수 값은 &lt;code&gt;jcl&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt; ) 또는 &lt;code&gt;abort&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt; ) 일 수 있습니다. 첫 번째 옵션은 &lt;code&gt;^G&lt;/code&gt; 를 설정 하여 &lt;code&gt;JCL&lt;/code&gt; 모드 를 활성화 합니다 (기본 동작이기도 함). 후자는 &lt;code&gt;^G&lt;/code&gt; 를 설정 하여 현재 쉘을 종료하고 새로운 쉘을 시작합니다. &lt;code&gt;shell_esc&lt;/code&gt; 가 &lt;code&gt;abort&lt;/code&gt; 로 설정 되면 &lt;code&gt;JCL&lt;/code&gt; 모드를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f28c17be27978977c1d4772358e7a511e0dfa71" translate="yes" xml:space="preserve">
          <source>The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.</source>
          <target state="translated">반복 그룹, 어설 션 및 서브 루틴이라고하는 서브 패턴 (재귀 적이든 아니든)에서이 동사의 동작은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f409290159e0122d24e0b32bc792ec356f3f9c" translate="yes" xml:space="preserve">
          <source>The behavior of this function changed radically in &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. To keep some backwards compatability, it is still possible to do:</source>
          <target state="translated">이 기능의 동작은 &lt;code&gt;Common Test&lt;/code&gt; 1.6.2 에서 급격히 변했습니다 . 이전 버전과의 호환성을 유지하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cecdaf7589f62bdef0c740b1516c756288d9c79" translate="yes" xml:space="preserve">
          <source>The behavior of this function is undefined if the table is written on while being traversed. The function &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to ensure that no transaction-protected writes are performed during the iteration.</source>
          <target state="translated">이송 중에 테이블을 쓰면이 기능의 동작이 정의되지 않습니다. &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; 함수 는 반복 동안 트랜잭션으로 보호 된 쓰기가 수행되지 않도록하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad444f7fffcddf3e1072340ed21b0cb1ac9f4b6" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of posponed messages and other metadata. It receives all process messages, handles the system messages, and calls the callback module with machine specific events.</source>
          <target state="translated">동작 엔진은 상태 머신 상태, 서버 데이터, 타이머 참조, 대기중인 메시지 큐 및 기타 메타 데이터를 보유합니다. 모든 프로세스 메시지를 수신하고 시스템 메시지를 처리하며 기계 별 이벤트로 콜백 모듈을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0880fce4c0b15834624e11a3dadca1d45ea29226" translate="yes" xml:space="preserve">
          <source>The behaviour module is part of Erlang/OTP. To implement a process such as a supervisor, the user only has to implement the callback module which is to export a pre-defined set of functions, the &lt;strong&gt;callback functions&lt;/strong&gt;.</source>
          <target state="translated">행동 모듈은 Erlang / OTP의 일부입니다. 수퍼바이저와 같은 프로세스를 구현하려면 사용자는 사전 정의 된 함수 세트 인 &lt;strong&gt;콜백 함수&lt;/strong&gt; 를 내보내는 콜백 모듈 만 구현하면 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="59e8c63ca2b59778b1c251bfe4d9af4a1c121cce" translate="yes" xml:space="preserve">
          <source>The benefit of this is that Megaco handles the starting, holding and the supervision of the driver and port.</source>
          <target state="translated">이것의 이점은 Megaco가 드라이버와 포트의 시작, 유지 및 감독을 처리한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1929daa6d9f07ef87baa0d2108c05731636b180d" translate="yes" xml:space="preserve">
          <source>The best place is in the &lt;code&gt;sys.config&lt;/code&gt; system configuration file of the release.</source>
          <target state="translated">가장 좋은 장소는 릴리스 의 &lt;code&gt;sys.config&lt;/code&gt; 시스템 구성 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72c83f4147d145bc84c3d37b05a70b520d273ab" translate="yes" xml:space="preserve">
          <source>The binaries do not contain whole bytes (bit strings).</source>
          <target state="translated">이진은 전체 바이트 (비트 문자열)를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c99eedcea168087b25493bcc8656037a8c03177" translate="yes" xml:space="preserve">
          <source>The binary boot script file &lt;code&gt;Name.boot&lt;/code&gt; is generated from the boot script file &lt;code&gt;Name.script&lt;/code&gt;, using the function &lt;code&gt;systools:script2boot(File)&lt;/code&gt;.</source>
          <target state="translated">바이너리 부팅 스크립트 파일 인 &lt;code&gt;Name.boot&lt;/code&gt; 는 &lt;code&gt;systools:script2boot(File)&lt;/code&gt; 함수를 사용하여 부팅 스크립트 파일 인 &lt;code&gt;Name.script&lt;/code&gt; 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c63a3b170852a27feb1e79f6999b69d62a7625a7" translate="yes" xml:space="preserve">
          <source>The binary boot script renamed to &lt;code&gt;start.boot&lt;/code&gt;</source>
          <target state="translated">이진 부팅 스크립트의 이름이 &lt;code&gt;start.boot&lt;/code&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaeab197086e91b2d818626cc54633ed2fa6700" translate="yes" xml:space="preserve">
          <source>The binary executable file must be owned by root, have &lt;code&gt;rwsr-xr-x&lt;/code&gt; file privileges, in particular the &lt;code&gt;setuid&lt;/code&gt; bit of the user must be set.</source>
          <target state="translated">이진 실행 파일은 root가 소유하고 &lt;code&gt;rwsr-xr-x&lt;/code&gt; 파일 권한을 가져야 하며 , 특히 사용자 의 &lt;code&gt;setuid&lt;/code&gt; 비트를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00fa7003833fa581d83179258571e8a367f39ad2" translate="yes" xml:space="preserve">
          <source>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</source>
          <target state="translated">이진 개체는 여러 프로세스의 여러 ProcBins에서 참조 할 수 있습니다. 이 개체에는 참조 수를 추적하는 참조 카운터가 포함되어 있으므로 마지막 참조가 사라질 때 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127151f66b51ac3efe997eb464906c3d0948c0d1" translate="yes" xml:space="preserve">
          <source>The binary object itself, stored outside all process heaps</source>
          <target state="translated">모든 프로세스 힙 외부에 저장된 이진 객체 자체</target>
        </trans-unit>
        <trans-unit id="4cf0fde8a2120eccfe9fdc8a249b8de5265ff4ee" translate="yes" xml:space="preserve">
          <source>The binary output file produced by the compiler is read by the agent at MIB load time (see the figure &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt;). The instrumentation is ordinary Erlang code which is loaded explicitly or automatically the first time it is called.</source>
          <target state="translated">컴파일러가 생성 한 이진 출력 파일은 MIB로드 시간에 에이전트가 읽습니다 ( &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt; 그림 참조 ). 계측은 일반 Erlang 코드이며 처음 호출 될 때 명시 적 또는 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d082c75a002a09432e39d447b940479e08b9f5e4" translate="yes" xml:space="preserve">
          <source>The bit syntax contains types for handling binary data in the three main encodings. The types are named &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;. The &lt;code&gt;utf16&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; types can be in a big-endian or a little-endian variant:</source>
          <target state="translated">비트 구문에는 세 가지 주요 인코딩에서 이진 데이터를 처리하기위한 유형이 포함되어 있습니다. 유형의 이름은 &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 입니다. &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형은 빅 엔디안 또는 리틀 엔디안 변형 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7305cb0adee2541b623171c05bf3f3d1ecacd9f6" translate="yes" xml:space="preserve">
          <source>The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;bindings&lt;/code&gt; (see further down), which returns the whole matched object and all known variable bindings, respectively.</source>
          <target state="translated">재미의 몸은 결과 값을 구성하는 데 사용됩니다. 테이블에서 선택할 때 일반적으로 튜플 괄호, 목록 괄호 및 머리에서 일치하는 변수와 같은 일반적인 Erlang 용어 구성을 사용하여 적합한 용어를 여기에 적합하게 구성합니다. 가드에서 허용되는 표현식도 여기에서 허용되지만 &lt;code&gt;object&lt;/code&gt; 와 &lt;code&gt;bindings&lt;/code&gt; 제외한 특별한 함수는 존재하지 않습니다 (아래 참조). 일치하는 객체와 알려진 모든 변수 바인딩을 각각 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4ca0de7223fe258efb581336c1e0197d5d0edd2" translate="yes" xml:space="preserve">
          <source>The boot script included in a release package must be generated from the same &lt;code&gt;.rel&lt;/code&gt; file as the release package itself.</source>
          <target state="translated">릴리스 패키지에 포함 된 부팅 스크립트 는 릴리스 패키지 자체 와 동일한 &lt;code&gt;.rel&lt;/code&gt; 파일 에서 생성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ddcf162c693f295280c787fbd8290adee7c45ca3" translate="yes" xml:space="preserve">
          <source>The boot script is stored in a file with extension &lt;code&gt;.script&lt;/code&gt;. The file has the following syntax:</source>
          <target state="translated">부팅 스크립트는 확장명이 &lt;code&gt;.script&lt;/code&gt; 인 파일에 저장됩니다 . 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a09207a22769c0574e34261e0d72dca94a1cd1" translate="yes" xml:space="preserve">
          <source>The branches of an &lt;code&gt;if&lt;/code&gt;-expression are scanned sequentially until a guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; that evaluates to true is found. Then the corresponding &lt;code&gt;Body&lt;/code&gt; (sequence of expressions separated by ',') is evaluated.</source>
          <target state="translated">의 가지 &lt;code&gt;if&lt;/code&gt; -expression는 가드 시퀀스까지 순차적으로 스캔 &lt;code&gt;GuardSeq&lt;/code&gt; true로 평가가 발견된다. 그런 다음 해당 &lt;code&gt;Body&lt;/code&gt; ( ','으로 구분 된 표현식 순서)이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c635f7fb465fc59e43a777e3d06741481d050b03" translate="yes" xml:space="preserve">
          <source>The browser must run as a separate OS process, otherwise VTS hangs.</source>
          <target state="translated">브라우저는 별도의 OS 프로세스로 실행해야합니다. 그렇지 않으면 VTS가 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="1acf68389c692a738d63487b4a06a4e7162935c1" translate="yes" xml:space="preserve">
          <source>The buffer pointed to by &lt;code&gt;v&lt;/code&gt; must be large enough to hold the return data, that is, it must be a pointer to one of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt;, or &lt;code&gt;void*&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 가 가리키는 버퍼는 리턴 데이터를 보유 할만큼 충분히 커야합니다 . 즉, 각각 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;char*&lt;/code&gt; 또는 &lt;code&gt;void*&lt;/code&gt; 중 하나에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="eaa6a3f621852e6e7b5c05f1f4dfe807f43eee5b" translate="yes" xml:space="preserve">
          <source>The build system, including cross compilation configuration variables used, may be subject to non backward compatible changes without prior notice. Current cross build system has been tested when cross compiling some Linux/GNU systems, but has only been partly tested for more esoteric platforms. The VxWorks example file is highly dependent on our environment and is here more or less only for internal use.</source>
          <target state="translated">사용 된 크로스 컴파일 구성 변수를 포함한 빌드 시스템은 사전 통지없이 이전 버전과 호환되지 않는 변경 사항이 적용될 수 있습니다. 현재의 크로스 빌드 시스템은 일부 Linux / GNU 시스템을 크로스 컴파일 할 때 테스트되었지만 좀 더 난해한 플랫폼에 대해서만 부분적으로 테스트되었습니다. VxWorks 예제 파일은 환경에 따라 크게 달라지며 내부 용으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6fef17f4398287d703d6c8738ea77d284a4abce3" translate="yes" xml:space="preserve">
          <source>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like &lt;code&gt;crypto:rand_seed/0&lt;/code&gt;.</source>
          <target state="translated">내장 난수 생성기 알고리즘은 암호화 적으로 강력하지 않습니다. 암호화 적으로 강력한 난수 생성기가 필요한 경우 &lt;code&gt;crypto:rand_seed/0&lt;/code&gt; 과 같은 것을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="067acc920ec0fee7fa628aac8051ca95ed671e0c" translate="yes" xml:space="preserve">
          <source>The busy message queue feature can be disabled either by setting the &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver, or by calling this function with &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; as a limit (either low or high). When this feature has been disabled, it cannot be enabled again. When reading the limits, both are &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; if this feature has been disabled.</source>
          <target state="translated">통화 중 메시지 대기열 기능은 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 사용 하는 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt; 드라이버 플래그 를 설정 하거나 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 를 제한 (낮음 또는 높음) 으로이 기능을 호출 하여 비활성화 할 수 있습니다 . 이 기능이 비활성화되면 다시 활성화 할 수 없습니다. 이 기능을 사용하지 않으면 한계를 읽을 때 둘 다 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33650cf8255f90c21ac81005064a8fbf5483e732" translate="yes" xml:space="preserve">
          <source>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</source>
          <target state="translated">이 버튼으로 코드 적용 범위 개요 페이지로 이동합니다. 세부 범위 분석을 성공적으로 수행 한 경우 각 개별 모듈 범위 페이지에 대한 링크가 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="709ea736382b67af3f9c144683016c97550b6e99" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a code point in the invalid Unicode range.</source>
          <target state="translated">바이트가 유효하지 않은 유니 코드 범위의 코드 포인트로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="276396b4a984d3ef578929de68a65d7f15a4afbf" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a too large number.</source>
          <target state="translated">바이트가 너무 큰 숫자로 디코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="953ab7ba3d595c2a841438d3ab4f4c182fb2eff6" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt;crypto app's&lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">캐시 크기는 &lt;code&gt;crypto app's&lt;/code&gt; 구성 매개 변수 &lt;code&gt;rand_cache_size&lt;/code&gt; 를 사용하여 기본값에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e019f9fcd17a687470aea637478863f5e134cb3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;module_info(Key)&lt;/code&gt;, where &lt;code&gt;Key&lt;/code&gt; is an atom, returns a single piece of information about the module.</source>
          <target state="translated">&lt;code&gt;module_info(Key)&lt;/code&gt; 호출 ( 여기서 &lt;code&gt;Key&lt;/code&gt; 는 원 자임)은 모듈에 대한 단일 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a72f41bd0ef1a660b71b19854f4a2f611d367c22" translate="yes" xml:space="preserve">
          <source>The call can also fail, for example, if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">예를 들어 &lt;code&gt;gen_statem&lt;/code&gt; 이이 함수 호출 전이나 도중에 죽으면 호출도 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8367b12b1eaff6fc40fd96b320d7987c710ba242" translate="yes" xml:space="preserve">
          <source>The call can fail for many reasons, including time-out and the called &lt;code&gt;gen_server&lt;/code&gt; process dying before or during the call.</source>
          <target state="translated">시간 초과 및 호출 전 또는 호출 중에 호출 된 &lt;code&gt;gen_server&lt;/code&gt; 프로세스를 포함하여 여러 가지 이유로 호출에 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4739e34ca18c32d95d687955ecad4a46982e910c" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are paused at their current count.</source>
          <target state="translated">통화 횟수 중단 점이있는 모든 일치하는 기능에 대한 통화 카운터는 현재 카운트에서 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="52c5d88794b3b9c10b033bc03376b7dc1bc55692" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are set to zero and running.</source>
          <target state="translated">호출 횟수 중단 점을 가진 일치하는 모든 기능에 대한 호출 카운터가 0으로 설정되어 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="fcd429bca91d28345133d5ddfc12f2039568c7e0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;Map1&lt;/code&gt; 지도없는, 또는 함께 &lt;code&gt;{badkey,Key}&lt;/code&gt; 값이 연결되지 않은 경우 예외 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a765e0cc7b8afeedc4b406e029455c41a2e05717" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 이 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="3bcc437b0d2af2e5401d95afab2b22b04d0cd309" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; or &lt;code&gt;Map2&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 또는 &lt;code&gt;Map2&lt;/code&gt; 가 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f8317a62b38be81b80524eaf41aa4ccce539a0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;Map&lt;/code&gt; 지도없는, 또는 함께 &lt;code&gt;{badkey,Key}&lt;/code&gt; 값이 연결되지 않은 경우 예외 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3d448e3253ce8fb6ba525c95cf4c520a4dd69a" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 이 맵 이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="16f4ecacaaaef2b7ebc1761887fc6a38ffe0b906" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">&lt;code&gt;MapOrIter&lt;/code&gt; 가 맵 또는 유효한 반복자 가 아닌 경우 또는 &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;Fun&lt;/code&gt; 이 arity 2의 함수가 아닌 경우 badarg 가있는 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="12f759a8b6547e05c46e411430a759d92783001f" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 3.</source>
          <target state="translated">&lt;code&gt;MapOrIter&lt;/code&gt; 가 맵 또는 유효한 반복자 가 아닌 경우 또는 &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;Fun&lt;/code&gt; 이 arity 3의 함수가 아닌 경우 badarg 가있는 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="ac940292242acb2f76654b1a0d7f61a1dafc1f65" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pred&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;MapOrIter&lt;/code&gt; 은 지도 나 유효 반복자, 또는하지입니다 &lt;code&gt;badarg&lt;/code&gt; 경우 &lt;code&gt;Pred&lt;/code&gt; 를 가산이 인수에 대응 2의 기능이 아니다.</target>
        </trans-unit>
        <trans-unit id="2892cf3454075f0053d7bd91a8d8a1dd21669320" translate="yes" xml:space="preserve">
          <source>The call format may be different if a customized prologue file has been included when generating the parser instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt;.</source>
          <target state="translated">기본 파일 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; 대신 파서를 생성 할 때 사용자 정의 된 프롤로그 파일이 포함 된 경우 호출 형식이 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e8198892cee32a7b8526bf6bc65cdd83e83fc69" translate="yes" xml:space="preserve">
          <source>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</source>
          <target state="translated">호출은 첫 번째 명시 적으로 캡처 된 하위 패턴이 &quot;(abcd)&quot;이고, 길이가 4 인 (0부터 시작) 위치 3의 주제에서 &quot;abcd&quot;와 일치하는 다음 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="daf666a091f35efff4124fee9f5b0c58cdf83623" translate="yes" xml:space="preserve">
          <source>The call is wrapped in a case statement and will be evaluated only if &lt;code&gt;Level&lt;/code&gt; is equal to or below the configured log level.</source>
          <target state="translated">호출은 케이스 문으로 랩핑되며 &lt;code&gt;Level&lt;/code&gt; 이 구성된 로그 레벨 이하인 경우에만 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="de78c6fd6e7546e57186f359788dd6c58cc04ff8" translate="yes" xml:space="preserve">
          <source>The call of this function will trigger the callback function UserMod:handle_connect/2 to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">이 함수를 호출하면 콜백 함수 UserMod : handle_connect / 2가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6eff7cd52eb9afdfc9d628f7416b2b3d981918c" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;io:format/2&lt;/code&gt; will never be executed, but a return address will still be pushed to the stack each time &lt;code&gt;loop/0&lt;/code&gt; is called recursively. The correct tail-recursive version of the function looks as follows:</source>
          <target state="translated">&lt;code&gt;io:format/2&lt;/code&gt; 에 대한 호출 은 절대 실행되지 않지만 &lt;code&gt;loop/0&lt;/code&gt; 이 재귀 적으로 호출 될 때마다 반환 주소가 여전히 스택으로 푸시됩니다 . 올바른 꼬리 재귀 버전의 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69e4234e48da562de4b3fe66e96e15cc38ad9a57" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; must be made &lt;strong&gt;directly&lt;/strong&gt; from the Erlang code of the module that the NIF library belongs to. It returns either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; if loading fails. &lt;code&gt;Reason&lt;/code&gt; is one of the following atoms while &lt;code&gt;Text&lt;/code&gt; is a human readable string that can give more information about the failure:</source>
          <target state="translated">NIF 라이브러리가 속하는 모듈의 Erlang 코드에서 &lt;strong&gt;직접 &lt;/strong&gt; &lt;code&gt;load_nif/2&lt;/code&gt; 를 호출 해야합니다 . 로드에 실패하면 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; 를 리턴 합니다. &lt;code&gt;Reason&lt;/code&gt; 는 다음 원자 중 하나이며 &lt;code&gt;Text&lt;/code&gt; 는 사람이 읽을 수있는 문자열로 실패에 대한 자세한 정보를 제공 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65c74848bb8184c1160ce5aeb1b1f12389a01cd3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; was made from the old code of a module that has been upgraded; this is not allowed.</source>
          <target state="translated">&lt;code&gt;load_nif/2&lt;/code&gt; 에 대한 호출 은 업그레이드 된 모듈의 이전 코드에서 작성되었습니다. 이것은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9645f8ce41967acca4649554ceab30271d3386df" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;return_trace&lt;/code&gt; results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a &lt;code&gt;dbg&lt;/code&gt; match specification.</source>
          <target state="translated">&lt;code&gt;return_trace&lt;/code&gt; 를 호출 하면 함수가 리턴 될 때 추적 메시지가 생성됩니다. 일치 사양을 트리거하고 일치 사양의 헤드 / 가드를 일치시키는 특정 함수 호출에만 적용됩니다. 이것은 &lt;code&gt;dbg&lt;/code&gt; 일치 스펙 본문에서 가장 일반적인 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="92d19c83ca0b80ba803b67a868b3108e7fb7711b" translate="yes" xml:space="preserve">
          <source>The call to the analyze function must be as follows:</source>
          <target state="translated">분석 함수에 대한 호출은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="55e6d7779dabe02d283cfb249b485592e929b71e" translate="yes" xml:space="preserve">
          <source>The call will fail with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 이 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1f952e3b1c0797c615bedda4b65ed54a10a69e" translate="yes" xml:space="preserve">
          <source>The call will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the check. The caller do not need to handle the matching rules in the rfc. The matching will proceed as:</source>
          <target state="translated">확인에 따라 호출이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 호출자는 rfc에서 일치 규칙을 처리 할 필요가 없습니다. 일치는 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="104de9fe47518d4f0de85d87c6a5c1db2f88d084" translate="yes" xml:space="preserve">
          <source>The call:</source>
          <target state="translated">호출:</target>
        </trans-unit>
        <trans-unit id="1514747db293879c8ce291ed88a8dae74c64014f" translate="yes" xml:space="preserve">
          <source>The callback function UserMod:handle_trans_reply/4 is invoked when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">콜백 함수 UserMod : handle_trans_reply / 4는 응답이 도착할 때, 요청 타이머가 결국 시간 초과되거나 미해결 요청이 명시 적으로 취소 될 때 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e40447571e80d72283361f5ca0d8dcdb93fefaa2" translate="yes" xml:space="preserve">
          <source>The callback function handling the &lt;code&gt;stop&lt;/code&gt; request returns a tuple &lt;code&gt;{stop,normal,State1}&lt;/code&gt;, where &lt;code&gt;normal&lt;/code&gt; specifies that it is a normal termination and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;. This causes the &lt;code&gt;gen_server&lt;/code&gt; to call &lt;code&gt;terminate(normal, State1)&lt;/code&gt; and then it terminates gracefully.</source>
          <target state="translated">취급 콜백 함수 &lt;code&gt;stop&lt;/code&gt; 요청이 반환 튜플 &lt;code&gt;{stop,normal,State1}&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; 지정 그것이 정상 종료라고하고 &lt;code&gt;State1&lt;/code&gt; 정는 의 상태에 대한 새로운 값 &lt;code&gt;gen_server&lt;/code&gt; . 이로 인해 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;terminate(normal, State1)&lt;/code&gt; 를 호출 한 다음 정상적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="728b1d3be49a797310af6aa94681789dfdda4be1" translate="yes" xml:space="preserve">
          <source>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</source>
          <target state="translated">콜백 함수는 열린 파일 디스크립터 닫기 등과 같이 파일 전송이 중단 된 후 사용 된 자원을 정리합니다. 다른 콜백 함수 중 하나가 이미 필요한 리소스를 정리했을 것으로 예상되므로 오류를 반환하면 함수가 호출되지 않습니다. 그러나 함수가 실패하면 (충돌) 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="109919e956ac7fc9c9c7ca8c3328e95855910a87" translate="yes" xml:space="preserve">
          <source>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</source>
          <target state="translated">콜백 함수는 마지막 파일 청크가 발생할 때 파일을 닫을 것으로 예상됩니다. 오류가 발생하면 열린 파일 디스크립터 닫기와 같은 파일 전송 중단 후 콜백 함수가 정리됩니다. 두 경우 모두 더 이상 콜백 함수에 대한 호출이 없습니다.</target>
        </trans-unit>
        <trans-unit id="84bacd9fc6215821a0c57cf0a99b64819b895b8b" translate="yes" xml:space="preserve">
          <source>The callback function is to be defined as follows:</source>
          <target state="translated">콜백 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="898a8e55f83f4732a3d9a1c55861f5556e256a82" translate="yes" xml:space="preserve">
          <source>The callback function itself did the updates.</source>
          <target state="translated">콜백 함수 자체가 업데이트를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="1d90b6e19e5f31bc52641082a2d815396c2a8af1" translate="yes" xml:space="preserve">
          <source>The callback function to use. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms and &lt;code&gt;Args&lt;/code&gt; is a list of terms. When an OS message &lt;code&gt;Msg&lt;/code&gt; is received, this function is called as &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt;.</source>
          <target state="translated">사용할 콜백 함수 &lt;code&gt;Module&lt;/code&gt; 과 &lt;code&gt;Function&lt;/code&gt; 은 원자이고 &lt;code&gt;Args&lt;/code&gt; 는 용어 목록입니다. OS 메시지 &lt;code&gt;Msg&lt;/code&gt; 가 수신되면이 함수를 &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt; 로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bf66fa0dd7df5d0912660af5ccc84e8028f914a6" translate="yes" xml:space="preserve">
          <source>The callback function works as described in &lt;code&gt;os_sup(3)&lt;/code&gt;.</source>
          <target state="translated">콜백 함수는 &lt;code&gt;os_sup(3)&lt;/code&gt; 설명 된대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea45999ad4acd01ff35ccee071d905b456a15b2" translate="yes" xml:space="preserve">
          <source>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</source>
          <target state="translated">콜백 함수는 컴파일 된 코드에서 호출 된 함수의 실행을 허용하거나 거부하는 데 사용할 수 없습니다 (쉘 프롬프트에서 입력 된 표현식에서 호출 된 함수 만).</target>
        </trans-unit>
        <trans-unit id="96dd8e426598dea1368d28980aebceed3f1b20a0" translate="yes" xml:space="preserve">
          <source>The callback functions of the module can be specified either directly by the exported function &lt;code&gt;behaviour_info/1&lt;/code&gt;:</source>
          <target state="translated">내 보낸 함수 &lt;code&gt;behaviour_info/1&lt;/code&gt; 에 의해 모듈의 콜백 함수를 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54dd23c9ceb4245139e54c85cd25b72ecec0fba9" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">테스트 스위트가 구현할 콜백 함수는 모두 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 모듈에 나열됩니다 . 또한이 사용자 안내서의 뒷부분에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85791b6dc548416b6612b724000cfadda018f22a" translate="yes" xml:space="preserve">
          <source>The callback interface is based on that the user sends a fun with the correct signature to the parser.</source>
          <target state="translated">콜백 인터페이스는 사용자가 올바른 서명으로 재미를 파서에 보낸다는 것을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="59e965f4c45d1fd48637f0634a7fe7cb62c0c3bd" translate="yes" xml:space="preserve">
          <source>The callback interface of the transport module contains several functions. Some of which are mandatory while others are only optional:</source>
          <target state="translated">전송 모듈의 콜백 인터페이스에는 몇 가지 기능이 있습니다. 일부는 필수이지만 다른 일부는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="cd251fb009bc0977864cd404e86e72a74db2ce5c" translate="yes" xml:space="preserve">
          <source>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">콜백은 중개자 프로세스에 의해 이루어 지므로 파일 전송은 진행 콜백 함수의 코드에 영향을받지 않습니다. 콜백이 충돌하면 FTP 연결 프로세스에서이를 감지하여 정보 보고서를 인쇄하고 진행률 옵션이 &lt;code&gt;ignore&lt;/code&gt; 로 설정된 것처럼 진행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e4051d9662c60ffac0c38b92a0a52ef07de6ce" translate="yes" xml:space="preserve">
          <source>The callback mode &lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">콜백 모드 &lt;code&gt;handle_event_function&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 원자가 아닌 상태 ( 예 : 튜플과 같은 복잡한 상태 용어)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9074f752748f19027b380bf6c6083917557b4d1" translate="yes" xml:space="preserve">
          <source>The callback mode is selected at server start and may be changed with a code upgrade/downgrade.</source>
          <target state="translated">콜백 모드는 서버 시작시 선택되며 코드 업그레이드 / 다운 그레이드로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b667b206213a5b84a8db86f75c2c72599f104c" translate="yes" xml:space="preserve">
          <source>The callback mode is selected by implementing a mandatory callback function &lt;code&gt;Module:callback_mode()&lt;/code&gt; that returns one of the callback modes.</source>
          <target state="translated">콜백 모드는 콜백 모드 중 하나를 반환 하는 필수 콜백 함수 &lt;code&gt;Module:callback_mode()&lt;/code&gt; 를 구현하여 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="ead6e2ff311fd428d1dc6968b3919ecff631ec58" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">콜백 모델 (들) &lt;code&gt;gen_statem&lt;/code&gt; 에 대한 것과 다른 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; , 그러나 그것은 매우 쉽게하기 여전히 &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; 하는 &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd40cbe96a6a7878da940a8badb97c6c9caeb25" translate="yes" xml:space="preserve">
          <source>The callback module contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the callback module with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">콜백 모듈은 상태 머신을 구현하는 함수를 포함합니다. 이벤트가 발생하면 &lt;code&gt;gen_statem&lt;/code&gt; 비헤이비어 엔진은 이벤트, 현재 상태 및 서버 데이터와 함께 콜백 모듈의 함수를 호출합니다. 이 함수는이 이벤트에 대한 조치를 수행하고 새 상태 및 서버 데이터와 동작 엔진이 수행 할 조치를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="abbecd682f4918a42592a94b71742e36915e1bab" translate="yes" xml:space="preserve">
          <source>The callback module does not have to access real &lt;code&gt;Mnesia&lt;/code&gt; tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</source>
          <target state="translated">콜백 모듈은 실제 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에 액세스 할 필요가 없으며 콜백 인터페이스가 충족되는 한 원하는대로 자유롭게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb2d562d838a71a4ba446f4da81f7701d757f5f" translate="yes" xml:space="preserve">
          <source>The callback module for a supervisor starting the server from &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; can look as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; 에서 서버를 시작하는 수퍼바이저의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="517a681e26aeb83ed7549fbd52cdab0059ff31b1" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to a file can look as follows:</source>
          <target state="translated">오류 메시지를 파일에 쓰는 이벤트 핸들러의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7722a0fd22c0aced7aea92994c66dc97a4d0fdd" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to the terminal can look as follows:</source>
          <target state="translated">터미널에 오류 메시지를 쓰는 이벤트 핸들러의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="344a5e28ddcbac85a390899bb7eafc0bb7e415bf" translate="yes" xml:space="preserve">
          <source>The callback module implementing the handler is responsible for checking the correctness of configuration strings.</source>
          <target state="translated">핸들러를 구현하는 콜백 모듈은 구성 문자열의 정확성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0b0838bae2efd3e8ec52bba36939ac5379dcb0f2" translate="yes" xml:space="preserve">
          <source>The callback module must implement the &lt;code&gt;tftp&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈은 &lt;code&gt;tftp&lt;/code&gt; 동작을 구현해야합니다 ( &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7c16c7638772ec54a79c0e6462748feea41441fe" translate="yes" xml:space="preserve">
          <source>The callback module of the socket.</source>
          <target state="translated">소켓의 콜백 모듈</target>
        </trans-unit>
        <trans-unit id="8b2bd7c81f3fa7abf6044482ee91de57b2f57d61" translate="yes" xml:space="preserve">
          <source>The callback will be removed if the system reboots.</source>
          <target state="translated">시스템이 재부팅되면 콜백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="55cc105f61cd981bcf32511925e36d658bc51fff" translate="yes" xml:space="preserve">
          <source>The called hook function is to return a (possibly deep) list of characters. Function &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; is useful in a hook.</source>
          <target state="translated">호출 된 후크 함수는 문자 목록을 리턴하는 것입니다. &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; 함수 는 후크에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd19dd71cdd2bc7e1309239a2dc9ab10df17269d" translate="yes" xml:space="preserve">
          <source>The caller (of the discovery function) will make the needed updates later.</source>
          <target state="translated">발견 기능의 호출자는 나중에 필요한 업데이트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9ead89ef805808ff104ff5c388ca47931019854a" translate="yes" xml:space="preserve">
          <source>The caller can use own extraction and matching rules. This is done with the two options &lt;code&gt;fqdn_fun&lt;/code&gt; and &lt;code&gt;match_fun&lt;/code&gt;.</source>
          <target state="translated">발신자는 자체 추출 및 일치 규칙을 사용할 수 있습니다. 이것은 두 가지 옵션 &lt;code&gt;fqdn_fun&lt;/code&gt; 및 &lt;code&gt;match_fun&lt;/code&gt; 로 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="a7fc9c78e44578fd025d978ee708e79b0fa261e4" translate="yes" xml:space="preserve">
          <source>The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while:</source>
          <target state="translated">이제 발신자가 추적 출력의 &quot;추가 메시지&quot;부분에 표시되고 잠시 후 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c55c238696091394e0bd56b82b698a5c47bb3d12" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, &lt;code&gt;pcre_exec()&lt;/code&gt; gives an error return. The limits can also be set by items at the start of the pattern of the following forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 호출자는 내부 match () 함수가 호출되는 횟수와 최대 재귀 호출 깊이에 대한 제한을 설정할 수 있습니다. 이러한 기능은 거대한 일치하는 트리가있는 패턴 (일반적인 예는 중첩 된 무제한 반복이있는 패턴)에 의해 유발되는 런 어웨이 일치를 포착하고 너무 많은 재귀에 의해 시스템 스택이 부족하지 않도록하기 위해 제공됩니다. 이러한 제한 중 하나에 도달하면 &lt;code&gt;pcre_exec()&lt;/code&gt; 는 오류를 반환합니다. 다음 양식의 패턴 시작시 항목별로 제한을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03c64f9f710de5955e68843c690db2e8c0fc8ca" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;driver_create_port&lt;/code&gt; is allowed to manipulate the newly created port when &lt;code&gt;driver_create_port&lt;/code&gt; has returned. When &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; is used, the creating port is only allowed to manipulate the newly created port until the current driver callback, which was called by the emulator, returns.</source>
          <target state="translated">의 호출 &lt;code&gt;driver_create_port&lt;/code&gt; 이 때 새로 생성 된 포트를 조작 할 수있다 &lt;code&gt;driver_create_port&lt;/code&gt; 이 돌아왔다. 때 &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; 사용하는 경우, 생성 포트는 에뮬레이터, 반환에 의해 호출 된 현재 드라이버 콜백 할 때까지 새로 만든 포트를 조작 할 수있다.</target>
        </trans-unit>
        <trans-unit id="621fc2d91134d4db21b3517ae8ac3625fde2ce09" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">이 함수의 호출자는 &lt;code&gt;net_kernel&lt;/code&gt; 의 대표자 ( &lt;code&gt;net_kernel&lt;/code&gt; 로 등록 된 프로세스 일 수도 있고 아닐 수도 있음 ) 이며이 문서에서 &lt;code&gt;Kernel&lt;/code&gt; 로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="80825902e9ea39352717e07e7e143bd52944e894" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;. When a connection has been accepted by the acceptor process, it needs to inform &lt;code&gt;Kernel&lt;/code&gt; about the accepted connection. This is done by passing a message on the form:</source>
          <target state="translated">이 함수의 호출자는 &lt;code&gt;net_kernel&lt;/code&gt; 의 대표자 ( &lt;code&gt;net_kernel&lt;/code&gt; 로 등록 된 프로세스 일 수도 있고 아닐 수도 있음 ) 이며이 문서에서 &lt;code&gt;Kernel&lt;/code&gt; 로 식별됩니다 . 수락 자 프로세스가 연결을 수락하면 수락 된 연결에 대해 &lt;code&gt;Kernel&lt;/code&gt; 에 알려야 합니다. 이것은 양식에 메시지를 전달하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="17dc5e2470f7e3eb401d50cfc358de49382160b2" translate="yes" xml:space="preserve">
          <source>The calling NIF must use the return value of &lt;code&gt;enif_schedule_nif&lt;/code&gt; as its own return value.</source>
          <target state="translated">호출 NIF는 리턴 값 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 를 고유 한 리턴 값으로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b39ce61a3bf5f9ff14b9a7cd2356d7e2ed9376ab" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is aborted and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">포트가 사용 중이면 호출 프로세스가 일시 중단되지 않고 대신 포트 명령이 중단되고 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="629c5b3b630ae0172907db307b7e38fd8b753106" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 사용 중이면 호출 프로세스가 일시 중단되지 않고 포트 명령이 강제 실행됩니다. 포트 드라이버가이를 지원하지 않으면 &lt;code&gt;notsup&lt;/code&gt; 예외 와 함께 호출이 실패 합니다. 자세한 정보는 드라이버 플래그 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a1251fc069f821f07a282196dbe91995966e598" translate="yes" xml:space="preserve">
          <source>The calling process subscribes or unsubscribes to node status change messages. A &lt;code&gt;nodeup&lt;/code&gt; message is delivered to all subscribing processes when a new node is connected, and a &lt;code&gt;nodedown&lt;/code&gt; message is delivered when a node is disconnected.</source>
          <target state="translated">호출 프로세스는 노드 상태 변경 메시지를 구독하거나 구독 취소합니다. &lt;code&gt;nodeup&lt;/code&gt; 된 새 노드가 연결되었을 때 메시지가 모든 등록 프로세스로 전달되고, &lt;code&gt;nodedown&lt;/code&gt; 노드가 해제 될 때 메시지가 전달된다.</target>
        </trans-unit>
        <trans-unit id="3fd0eba81e7afeb40af7403b8df7ac0d5fe56351" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, &lt;code&gt;application&lt;/code&gt; configuration must be matched by corresponding &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; configuration, of *-Application-Id AVPs in particular.</source>
          <target state="translated">노드가 보급 한 기능은 구성된 응용 프로그램과 일치해야합니다. 특히 &lt;code&gt;application&lt;/code&gt; 구성은 특히 * -Application-Id AVP의 해당 &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; 구성 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f7b2ec0f22afdbc01fa422caed0e98c532f9b08" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, setting &lt;code&gt;applications&lt;/code&gt; on a transport typically implies having to set matching *-Application-Id AVPs in a &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; tuple.</source>
          <target state="translated">노드가 보급 한 기능은 구성된 응용 프로그램과 일치해야합니다. 특히, 전송에서 &lt;code&gt;applications&lt;/code&gt; 을 설정하는 것은 일반적으로 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; 튜플 에서 일치하는 * -Application-Id AVP를 설정해야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="172ff57f871dcdd5d0b54942cc29dbee89bb8d9d" translate="yes" xml:space="preserve">
          <source>The capture tuple is built up as follows:</source>
          <target state="translated">캡처 튜플은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="734624d49a0e505e194d0a3e203f3707e0a9ce89" translate="yes" xml:space="preserve">
          <source>The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below.</source>
          <target state="translated">잘린 UTF의 경우 특수하게 처리됩니다. 불완전한 이진에 대한 단락을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf787b1c131df12f5b5608740bbea97ec8c5c67e" translate="yes" xml:space="preserve">
          <source>The cases are executed in a sequence as described in section &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; in section Dependencies Between Test Cases and Suites.</source>
          <target state="translated">섹션에 설명 된대로의 경우는 순서대로 실행되는 &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; 테스트 케이스 및 스위트 사이 섹션 종속성에.</target>
        </trans-unit>
        <trans-unit id="a67cf4e28458acef6485593f3479b26ebbee2e4f" translate="yes" xml:space="preserve">
          <source>The cases in the group are executed in random order.</source>
          <target state="translated">그룹의 사례는 무작위 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="79326758fa4216db5c43f358f0c9d48cf3066915" translate="yes" xml:space="preserve">
          <source>The center area of the main window contains the information tabs. Each tab displays information about a specific item or a list of items. Select a tab by clicking the tab title.</source>
          <target state="translated">기본 창의 중앙 영역에는 정보 탭이 있습니다. 각 탭에는 특정 항목 또는 항목 목록에 대한 정보가 표시됩니다. 탭 제목을 클릭하여 탭을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4592ee81cac18e24ff040ed72913569d66a68da6" translate="yes" xml:space="preserve">
          <source>The certificates attributes are valid.</source>
          <target state="translated">인증서 속성이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7eaa8135e803f2fb327a77633a52bb48c129b5b" translate="yes" xml:space="preserve">
          <source>The chain consisted only of one self-signed certificate.</source>
          <target state="translated">체인은 하나의 자체 서명 된 인증서로만 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e0a9851e387d6b9bd8489d5d8385b78fdd1efbf" translate="yes" xml:space="preserve">
          <source>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</source>
          <target state="translated">로그가 삭제되지 않는 한 변경은 영구적입니다. 즉, 로그 크기는 재부팅시 기억됩니다.</target>
        </trans-unit>
        <trans-unit id="209a620344bc5ac686ada38b14f368934eb2469b" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 디스크 공간 확인 후 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7324d42150f9730491b8b6dcf07acbe2a4287488" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 메모리 검사 후에 적용되며 비 영구적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8308604a253081056bdf717b82fcf33a719c92f1" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 디스크 공간 확인 중에 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9ee001de4f9c2acc5f959f9da7fbe9021fe19db" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next periodic memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음주기 메모리 점검 중에 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48592559cdd27064407e93ea03790b5d39d21da9" translate="yes" xml:space="preserve">
          <source>The change will take effect for the next memory check and is non-persistent. That is, in the case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 메모리 검사에 적용되며 비 영구적입니다. 즉, 프로세스 재시작의 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a55eac8fba728a49ba83a1ba16426f587e19122" translate="yes" xml:space="preserve">
          <source>The changes do not affect existing child processes. For example, changing the start function only specifies how the child process is to be restarted, if needed later on.</source>
          <target state="translated">변경 사항은 기존 자식 프로세스에 영향을 미치지 않습니다. 예를 들어, 시작 기능을 변경하면 나중에 필요할 경우 하위 프로세스를 다시 시작하는 방법 만 지정합니다.</target>
        </trans-unit>
        <trans-unit id="17ef826dd60e0b23be9ebb72e959e4616f5a6f10" translate="yes" xml:space="preserve">
          <source>The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">해당 메시지가 아직 전송되지 않은 경우 채널 비헤이비어는 상대방에게 닫기 메시지를 보냅니다. 그런 다음 reason &lt;code&gt;normal&lt;/code&gt; 채널을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0641d9544e5c0fe01329a75590e893fef99690" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Advanced Agent Topics&lt;/strong&gt; describes the more advanced agent related features of the SNMP development tool. The following topics are covered:</source>
          <target state="translated">&lt;strong&gt;고급 에이전트 주제&lt;/strong&gt; 장에서는 SNMP 개발 도구의 고급 에이전트 관련 기능에 대해 설명합니다. 다음과 같은 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="2e272ab9ddbed68131c16ba5014e291dc03d4f2d" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Audit Trail Log&lt;/strong&gt; describes the audit trail logging.</source>
          <target state="translated">&lt;strong&gt;감사 추적 로그&lt;/strong&gt; 장에서는 &lt;strong&gt;감사&lt;/strong&gt; 추적 로깅에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3f08decf0e83874ab43a9d84e18e36f372618712" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Running the application&lt;/strong&gt; describes how the application is configured and started. The topics include:</source>
          <target state="translated">&lt;strong&gt;응용 프로그램 실행&lt;/strong&gt; 장에서는 응용 프로그램의 구성 및 시작 방법에 대해 설명합니다. 주제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72b08f124553e2dc5540039b611421ca2a1cb7f5" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;The MIB Compiler&lt;/strong&gt; describes the MIB compiler and contains the following topics:</source>
          <target state="translated">&lt;strong&gt;MIB 컴파일러&lt;/strong&gt; 장에서는 &lt;strong&gt;MIB 컴파일러에&lt;/strong&gt; 대해 설명하고 다음 주제를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ddb91809478ddb72a376ffa2ae9889076265397b" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;C&lt;/code&gt; determines the type of control sequence to be used. It is the only required field. All of &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Pad&lt;/code&gt;, and &lt;code&gt;Mod&lt;/code&gt; are optional. For example, to use a &lt;code&gt;#&lt;/code&gt; for &lt;code&gt;Pad&lt;/code&gt; but use the default values for &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;, you can write &lt;code&gt;~..#C&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;C&lt;/code&gt; 는 사용될 제어 순서의 유형을 결정합니다. 유일한 필수 필드입니다. 모든 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; , &lt;code&gt;Pad&lt;/code&gt; , 그리고 &lt;code&gt;Mod&lt;/code&gt; 선택 사항입니다. 예를 들어, &lt;code&gt;Pad&lt;/code&gt; 에는 &lt;code&gt;#&lt;/code&gt; 을 사용하고 &lt;code&gt;F&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 에는 기본값을 사용하려면 &lt;code&gt;~..#C&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d64a4036522ec8f78050362f7b7c36c9cac056c3" translate="yes" xml:space="preserve">
          <source>The character encoding used in strings and atoms. The only supported encoding is &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; for ISO Latin-1 (8-bit ASCII).</source>
          <target state="translated">문자열과 원자에 사용되는 문자 인코딩. 지원되는 유일한 인코딩은 ISO Latin-1 (8 비트 ASCII)의 경우 &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d193b1def3415cd7c10a5af19c4d201098e3350" translate="yes" xml:space="preserve">
          <source>The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</source>
          <target state="translated">원자에 사용되는 문자 인코딩. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; 는 7 비트 ASCII를 나타냅니다. 라틴 -1과 UTF-8은 7 비트 ASCII의 다른 확장입니다. 모든 7 비트 ASCII 문자는 유효한 Latin-1 및 UTF-8 문자입니다. ASCII와 Latin-1은 모두 각 문자를 1 바이트로 나타냅니다. UTF-8 문자는 1-4 바이트로 구성 될 수 있습니다. 이 상수는 비트 플래그이며 비트 OR과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bce2007ce7233de084f6c74cc17834bdadef1f7" translate="yes" xml:space="preserve">
          <source>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, \w, and \W can appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit. In UTF modes, option &lt;code&gt;ucp&lt;/code&gt; affects the meanings of \d, \s, \w and their uppercase partners, just as it does when they appear outside a character class, as described in section &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; earlier. The escape sequence \b has a different meaning inside a character class; it matches the backspace character. The sequences \B, \N, \R, and \X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</source>
          <target state="translated">문자 이스케이프 시퀀스 \ d, \ D, \ h, \ H, \ p, \ P, \ s, \ S, \ v, \ V, \ w 및 \ W는 문자 클래스에 나타날 수 있으며 클래스와 일치하는 문자 예를 들어, [\ dABCDEF]는 16 진수와 일치합니다. UTF 모드에서 &lt;code&gt;ucp&lt;/code&gt; 옵션 은 \ d, \ s, \ w 및 대문자 파트너의 의미에 영향을 미칩니다 ( 이전의 &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; 섹션에서 설명한대로 문자 클래스 외부에 나타날 때와 동일 함) . 이스케이프 시퀀스 \ b는 문자 클래스 내에서 다른 의미를 갖습니다. 백 스페이스 문자와 일치합니다. \ B, \ N, \ R 및 \ X 시퀀스는 문자 클래스 내에서 특별하지 않습니다. 인식 할 수없는 다른 이스케이프 시퀀스와 마찬가지로 리터럴 문자 &quot;B&quot;, &quot;N&quot;, &quot;R&quot;및 &quot;X&quot;로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="89f86657075f7d2532ecb276650adc58a9119d7f" translate="yes" xml:space="preserve">
          <source>The character used as time designator, that is, the date and time separator. The default is &lt;code&gt;$T&lt;/code&gt;.</source>
          <target state="translated">시간 지정자로 사용되는 문자, 즉 날짜 및 시간 구분 기호입니다. 기본값은 &lt;code&gt;$T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7d9d6c64abc51b03bd1675467e660789635b1bd" translate="yes" xml:space="preserve">
          <source>The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode).</source>
          <target state="translated">줄의 문자는 줄 바꿈 (또는 파일 끝)으로 끝납니다. I / O 장치가 유니 코드를 지원하는 경우 데이터는&amp;gt; 255 ( &lt;code&gt;latin1&lt;/code&gt; 범위)를 나타낼 수 있습니다 . I / O 서버가 바이너리를 전달하도록 설정된 경우, I / O 장치가 유니 코드를 지원하는지 여부에 관계없이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="56bc68334532732a987644276bf7e27ba2ed6340" translate="yes" xml:space="preserve">
          <source>The characters in the name (if specified as a list) can only be &amp;gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</source>
          <target state="translated">Erlang 가상 머신이 유니 코드 파일 이름 변환 모드에서 시작된 경우 이름의 문자 (목록으로 지정된 경우)는 255보다 클 수 있습니다. 그렇지 않으면 실행 파일 이름이 ISO Latin-1 문자 세트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4c340bb094927d6516a270b8c7260c59f1b0e9ac" translate="yes" xml:space="preserve">
          <source>The check for calls to undefined functions is an example of a predefined analysis, probably the most useful one. Other examples are the analyses that find unused local functions, or functions that call some given functions. See the &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; functions for a complete list of predefined analyses.</source>
          <target state="translated">정의되지 않은 함수 호출 확인은 사전 정의 된 분석의 예이며 아마도 가장 유용한 분석 일 것입니다. 다른 예로는 사용하지 않는 로컬 함수 또는 특정 함수를 호출하는 함수를 찾는 분석이 있습니다. 사전 정의 된 분석의 전체 목록은 &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e1916c5d50a9c907628d5b592b7e3e35726d5e" translate="yes" xml:space="preserve">
          <source>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint.</source>
          <target state="translated">체크 포인트는 관련된 테이블 중 일부에 보유자가없는 경우 자동으로 비활성화됩니다. 노드가 중단되거나 복제본이 삭제 될 때 발생할 수 있습니다. 이 기능으로 체크 포인트도 비활성화됩니다. &lt;code&gt;Name&lt;/code&gt; 은 활성화 된 체크 포인트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d9393d9861ac13bac497a84046277f971838af74" translate="yes" xml:space="preserve">
          <source>The checks performed before the boot script is generated can be extended with some cross reference checks by specifying option &lt;code&gt;exref&lt;/code&gt;. These checks are performed with the Xref tool. All applications, or the applications specified with &lt;code&gt;{exref,[App]}&lt;/code&gt;, are checked by Xref and warnings are issued for calls to undefined functions.</source>
          <target state="translated">부트 스크립트가 생성되기 전에 수행 된 검사는 &lt;code&gt;exref&lt;/code&gt; 옵션을 지정하여 일부 상호 참조 검사로 확장 될 수 있습니다 . 이러한 검사는 외부 참조 도구를 사용하여 수행됩니다. 모든 애플리케이션 또는 &lt;code&gt;{exref,[App]}&lt;/code&gt; 로 지정된 애플리케이션 은 외부 참조에 의해 검사되며 정의되지 않은 함수에 대한 호출에 대한 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b71574456dfb07437b35ad062527dd44aa7aea5a" translate="yes" xml:space="preserve">
          <source>The child specification for a stopped child process is deleted with the following call:</source>
          <target state="translated">중지 된 하위 프로세스의 하위 스펙은 다음 호출로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="67c92024750696ea3d3e50b512e7251afc6c23fc" translate="yes" xml:space="preserve">
          <source>The children of a supervisor are defined as a list of &lt;strong&gt;child specifications&lt;/strong&gt;. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</source>
          <target state="translated">감독자의 &lt;strong&gt;자녀&lt;/strong&gt; 는 &lt;strong&gt;자녀 규격&lt;/strong&gt; 목록으로 정의됩니다 . 감독자가 시작되면이 목록에 따라 하위 프로세스가 왼쪽에서 오른쪽으로 순서대로 시작됩니다. 수퍼바이저가 종료되면 먼저 오른쪽에서 왼쪽으로 하위 프로세스를 시작 순서가 반대로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="814de93894ad7aadf116db8d46dcb0a1a2f6a6fc" translate="yes" xml:space="preserve">
          <source>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</source>
          <target state="translated">구성을 선택하면 테이블의 위치와로드 순서가 변경됩니다. 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92e209681f18120979ec8cf62515a80ebbdd5369" translate="yes" xml:space="preserve">
          <source>The chunk size used by the Erlang fallback to send data. If using the fallback, set this to a value that comfortably fits in the systems memory. Default is 20 MB.</source>
          <target state="translated">Erlang 폴 백이 데이터를 전송하는 데 사용하는 청크 크기입니다. 폴백을 사용하는 경우 시스템 메모리에 편안한 값으로 설정하십시오. 기본값은 20MB입니다.</target>
        </trans-unit>
        <trans-unit id="b290d8f7cbf9ebc957458f968fe0fad53d55bb94" translate="yes" xml:space="preserve">
          <source>The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.</source>
          <target state="translated">곡절 및 달러 메타 문자는 너비가 0 인 어설 션입니다. 즉, 주제 문자열에서 문자를 소비하지 않고 특정 조건이 참인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5669e2ea35917008527e37b5ca4d88fc5112fe65" translate="yes" xml:space="preserve">
          <source>The classic edit-compile-bugfix cycle for Erlang is to edit the source file in an editor, save it to a file and switch to an Erlang shell. In the shell the compilation command is given. Should the compilation fail you have to bring out the editor and locate the correct line.</source>
          <target state="translated">Erlang의 고전적인 편집-컴파일-버그 수정주기는 ​​편집기에서 소스 파일을 편집하고 파일로 저장 한 다음 Erlang 쉘로 전환하는 것입니다. 쉘에는 컴파일 명령이 제공됩니다. 컴파일이 실패하면 편집기를 꺼내고 올바른 줄을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="b037a6b9c798a6a67eb72fefb14eec4bbb6f1f1d" translate="yes" xml:space="preserve">
          <source>The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code.</source>
          <target state="translated">클라이언트는 자동으로 새 URI에서 정보를 검색하여 결과로 30X 결과 코드 대신 해당 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fbe84685ac1a559531b7c36291fb36841fab94a" translate="yes" xml:space="preserve">
          <source>The client can be stopped using &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; or &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; 또는 &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt; 사용하여 클라이언트를 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="569ccd940c4f6a817b12bba1b1067ae1a9656ffb" translate="yes" xml:space="preserve">
          <source>The client can choose to accept some path evaluation errors, for example, a web browser can ask the user whether to accept an unknown CA root certificate. The server, if it requests a certificate, does however not accept any path validation errors. It is configurable if the server is to accept or reject an &quot;empty&quot; certificate as response to a certificate request.</source>
          <target state="translated">클라이언트는 경로 평가 오류를 허용하도록 선택할 수 있습니다. 예를 들어, 웹 브라우저는 사용자에게 알 수없는 CA 루트 인증서를 수락할지 여부를 묻습니다. 그러나 서버가 인증서를 요청하면 경로 유효성 검사 오류를 허용하지 않습니다. 서버가 인증서 요청에 대한 응답으로 &quot;빈&quot;인증서를 수락하거나 거부하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1b412fb6f7f703ee2ef8dff66ba99951cf7089b" translate="yes" xml:space="preserve">
          <source>The client is any Erlang process wishing to read or write data from/to the I/O device.</source>
          <target state="translated">클라이언트는 I / O 장치에서 데이터를 읽거나 쓰는 Erlang 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="c1f2e8007b5292b585147076187f8ae466cd3c94" translate="yes" xml:space="preserve">
          <source>The client processes has done some illegal operation.</source>
          <target state="translated">클라이언트 프로세스가 잘못된 작업을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="9a26517024410b148cd294e33b877a64e550bcc2" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트 원격 사용자 이름 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41327174b5c9bc729859a7f6bf3b5c175db7b9d0" translate="yes" xml:space="preserve">
          <source>The client sends an &lt;code&gt;io_request&lt;/code&gt; tuple to the I/O server and the server eventually sends a corresponding &lt;code&gt;io_reply&lt;/code&gt; tuple.</source>
          <target state="translated">클라이언트는 &lt;code&gt;io_request&lt;/code&gt; 튜플을 I / O 서버로 보내고 서버는 결국 해당 &lt;code&gt;io_reply&lt;/code&gt; 튜플을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f8f061d93662344f07374622d9a9f5570dc6915" translate="yes" xml:space="preserve">
          <source>The client sends the message to the server by:</source>
          <target state="translated">클라이언트는 다음을 통해 서버에 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="072bdecf1b9485830f32e0b9aaa2f2cd201b4643" translate="yes" xml:space="preserve">
          <source>The client supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">기본 메커니즘도 지원하는 한 클라이언트는 IPv6을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5795d28810329b4419d272a646663a21aa527543" translate="yes" xml:space="preserve">
          <source>The client-server model is characterized by a central server and an arbitrary number of clients. The client-server model is used for resource management operations, where several different clients want to share a common resource. The server is responsible for managing this resource.</source>
          <target state="translated">클라이언트-서버 모델은 중앙 서버와 임의의 수의 클라이언트로 구성됩니다. 클라이언트-서버 모델은 여러 다른 클라이언트가 공통 리소스를 공유하려는 리소스 관리 작업에 사용됩니다. 서버는이 자원을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="b8d268ee82b336a5c95688dda8482335e48cf69d" translate="yes" xml:space="preserve">
          <source>The clients ip address.</source>
          <target state="translated">클라이언트 IP 주소.</target>
        </trans-unit>
        <trans-unit id="a98219544eb3eff51a663b1a744e3bf13062abc6" translate="yes" xml:space="preserve">
          <source>The clock starts ticking when the request is sent.</source>
          <target state="translated">요청이 전송되면 시계가 똑딱 거리기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="be435ecc0cf1fa1a9c98c5cd0695f7dfa36eec57" translate="yes" xml:space="preserve">
          <source>The clone of the SSL application must enable the use of the SSL code in such an early bootstage as needed to set up the distribution. However, this makes it impossible to soft upgrade the SSL application.</source>
          <target state="translated">SSL 응용 프로그램의 복제본은 배포를 설정하는 데 필요한 초기 부팅 단계에서 SSL 코드를 사용할 수 있도록해야합니다. 그러나 이로 인해 SSL 응용 프로그램을 소프트 업그레이드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d756129312a76f266001381d64eeed8865f4919a" translate="yes" xml:space="preserve">
          <source>The code for a module can exist in two variants in a system: &lt;strong&gt;current code&lt;/strong&gt; and &lt;strong&gt;old code&lt;/strong&gt;. When a module is loaded into the system for the first time, the module code becomes 'current' and the global &lt;strong&gt;export table&lt;/strong&gt; is updated with references to all functions exported from the module.</source>
          <target state="translated">모듈의 코드는 시스템에서 &lt;strong&gt;현재 코드&lt;/strong&gt; 와 &lt;strong&gt;이전 코드의&lt;/strong&gt; 두 가지 변형으로 존재할 수 있습니다 . 모듈이 시스템에 처음으로로드되면 모듈 코드는 '현재'가되고 전역 &lt;strong&gt;내보내기 테이블&lt;/strong&gt; 은 모듈에서 내 보낸 모든 함수에 대한 참조로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e2397fc7367abe891aaddea1acfb84a0e33bbb71" translate="yes" xml:space="preserve">
          <source>The code for the server can be rewritten into a generic part &lt;code&gt;server.erl&lt;/code&gt;:</source>
          <target state="translated">서버 코드는 일반적인 부분 &lt;code&gt;server.erl&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e4cf743be10d1f78796a8520fbbc62b88613fb4" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;error_handler&lt;/code&gt; is complex. Do not change it without fully understanding the interaction between the error handler, the &lt;code&gt;init&lt;/code&gt; process of the code server, and the I/O mechanism of the code.</source>
          <target state="translated">&lt;code&gt;error_handler&lt;/code&gt; 의 코드 는 복잡합니다. 오류 처리기, 코드 서버 의 &lt;code&gt;init&lt;/code&gt; 프로세스 및 코드의 I / O 메커니즘 간의 상호 작용을 완전히 이해하지 않고 변경하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="90cb7656e2a78a30cae10868a6acccf8aa88d091" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;server&lt;/code&gt; can be reused to build many different servers.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 의 코드는 많은 다른 서버를 구축하기 위해 재사용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04225ffb5d1e2cd3c54d5a022ccc010d6c271db5" translate="yes" xml:space="preserve">
          <source>The code is available in &lt;code&gt;pg_sync.c&lt;/code&gt; in the &lt;code&gt;sample&lt;/code&gt; directory of &lt;code&gt;erts&lt;/code&gt;.</source>
          <target state="translated">코드에서 사용할 수 &lt;code&gt;pg_sync.c&lt;/code&gt; 에서 &lt;code&gt;sample&lt;/code&gt; 디렉토리 &lt;code&gt;erts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9264957f8945993653ce298e5c1234e15d08f23" translate="yes" xml:space="preserve">
          <source>The code is explained in the next sections.</source>
          <target state="translated">코드는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e3333c77c7ae219d3009900b602e3b49e21c916" translate="yes" xml:space="preserve">
          <source>The code is straightforward: all communication between Erlang and the driver is done with &lt;code&gt;port_control/3&lt;/code&gt;, and the driver returns data back using the &lt;code&gt;rbuf&lt;/code&gt;.</source>
          <target state="translated">얼랑와 드라이버 사이의 모든 통신이 이루어집니다 : 코드는 간단하다 &lt;code&gt;port_control/3&lt;/code&gt; 및 드라이버를 반환 데이터를 사용하여 백업 &lt;code&gt;rbuf&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f043529a1b5d337526e7bf30093ae19b9989356b" translate="yes" xml:space="preserve">
          <source>The code must return:</source>
          <target state="translated">코드는 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="507745f725c946f3bb38fa59ee9580fa6d304cd3" translate="yes" xml:space="preserve">
          <source>The code of a module can exist in two variants in a system: &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;. When a module is loaded into the system for the first time, the code becomes 'current'. If then a new instance of the module is loaded, the code of the previous instance becomes 'old' and the new instance becomes 'current'.</source>
          <target state="translated">모듈의 코드는 시스템에서 &lt;strong&gt;current&lt;/strong&gt; 와 &lt;strong&gt;old의&lt;/strong&gt; 두 가지 변형으로 존재할 수 있습니다 . 모듈이 시스템에 처음으로로드되면 코드는 '현재'가됩니다. 그런 다음 모듈의 새 인스턴스가로드되면 이전 인스턴스의 코드가 '이전'이되고 새 인스턴스가 '현재'가됩니다.</target>
        </trans-unit>
        <trans-unit id="922b2eb4a931c1204aa3e51a063d0b9c833303d1" translate="yes" xml:space="preserve">
          <source>The code path can be extended by using the command-line flags &lt;code&gt;-pa Directories&lt;/code&gt; and &lt;code&gt;-pz Directories&lt;/code&gt;. These add &lt;code&gt;Directories&lt;/code&gt; to the head or the end of the code path, respectively. Example:</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-pa Directories&lt;/code&gt; 및 &lt;code&gt;-pz Directories&lt;/code&gt; 를 사용하여 코드 경로를 확장 할 수 있습니다 . 이들은 각각 코드 경로의 헤드 또는 끝에 &lt;code&gt;Directories&lt;/code&gt; 를 추가 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="e7f2de033652fb4852b04d98599da41645cd5418" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt;System Principles&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 코드로드 전략에 따라 코드를로드하며, 이는 &lt;strong&gt;대화 형&lt;/strong&gt; (기본값) 또는 &lt;strong&gt;임베디드&lt;/strong&gt; 입니다. 대화식 모드에서 코드는 &lt;strong&gt;코드 경로&lt;/strong&gt; 에서 검색되어 처음 참조 될 때로드됩니다. 내장 모드에서는 &lt;strong&gt;부팅 스크립트&lt;/strong&gt; 에 따라 시작시 코드가로드됩니다 . 이것은 &lt;code&gt;System Principles&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c79fc2d0738d58b971f65c1fecd5a663cbf7ff9" translate="yes" xml:space="preserve">
          <source>The code server module &lt;code&gt;code&lt;/code&gt; contains a number of functions for modifying and checking the search path, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">코드 서버 모듈 &lt;code&gt;code&lt;/code&gt; 에는 검색 경로를 수정하고 확인하기위한 여러 기능이 포함되어 있습니다 . 커널 의 &lt;code&gt;code(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="33c6dc6ea8623b6f6923c8e2b31c4332f8ba122e" translate="yes" xml:space="preserve">
          <source>The code server uses &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; to find the directory of the current (latest) version of Kernel, and then the subdirectory &lt;code&gt;include&lt;/code&gt; is searched for the file &lt;code&gt;file.hrl&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; 을 사용하여 현재 (최신) 커널 버전의 디렉토리 를 찾은 다음, 서브 디렉토리 &lt;code&gt;include&lt;/code&gt; 에서 &lt;code&gt;file.hrl&lt;/code&gt; 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="705518a26a45215c147f7cfa28bbb3c76f850d6e" translate="yes" xml:space="preserve">
          <source>The code server uses module &lt;code&gt;erl_prim_loader&lt;/code&gt; in ERTS (possibly through &lt;code&gt;erl_boot_server&lt;/code&gt;) to read code files from archives. However, the functions in &lt;code&gt;erl_prim_loader&lt;/code&gt; can also be used by other applications to read files from archives. For example, the call &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; would list the contents of a directory inside an archive. See &lt;code&gt;erl_prim_loader(3)&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 ERTS의 &lt;code&gt;erl_prim_loader&lt;/code&gt; 모듈 ( erl_boot_server 를 통해 &lt;code&gt;erl_boot_server&lt;/code&gt; )을 사용하여 아카이브에서 코드 파일을 읽습니다. 그러나 &lt;code&gt;erl_prim_loader&lt;/code&gt; 의 기능 을 다른 응용 프로그램에서 사용하여 아카이브에서 파일을 읽을 수도 있습니다. 예를 들어, &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; 호출 은 아카이브 내의 디렉토리 내용을 나열합니다. &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b81d555b71a144677a82f4345434092ac25f42ef" translate="yes" xml:space="preserve">
          <source>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</source>
          <target state="translated">이 추적 프로그램 기능을 실행하는 프로세스를 작성하고 해당 프로세스를 시스템 추적 프로그램으로 설정하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01443bf8a10ddd3106bef27d3577d522575836f5" translate="yes" xml:space="preserve">
          <source>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an &lt;code&gt;AccessContext&lt;/code&gt;. Currently, the following access contexts are supported:</source>
          <target state="translated">활동 내에서 실행되는 코드는 &lt;code&gt;AccessContext&lt;/code&gt; 에서 수행되는 일련의 테이블 조작 함수로 구성 될 수 있습니다 . 현재 다음과 같은 액세스 컨텍스트가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="84b1eccbd4506c4d8f052231d9e0606cf91a8b80" translate="yes" xml:space="preserve">
          <source>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function &lt;code&gt;transaction/1&lt;/code&gt; returns the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;.</source>
          <target state="translated">트랜잭션 내에서 실행되는 코드는 일련의 테이블 조작 함수로 구성 될 수 있습니다. 사용자 오류 또는 특정 테이블을 사용할 수 없어서 트랜잭션 내부에 문제가 발생하면 전체 트랜잭션이 종료되고 &lt;code&gt;transaction/1&lt;/code&gt; 함수는 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0cdd80f24fdd34e8443becb251df980268f8ee4" translate="yes" xml:space="preserve">
          <source>The code uses the &lt;code&gt;OTP_RELEASE&lt;/code&gt; macro to conditionally select code depending on release.</source>
          <target state="translated">이 코드는 &lt;code&gt;OTP_RELEASE&lt;/code&gt; 매크로를 사용하여 릴리스에 따라 조건부로 코드를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0b9b7b5c18b986e4dcb6724716523fe3e0859402" translate="yes" xml:space="preserve">
          <source>The codec name is the name of the codec with which all messages in the &lt;code&gt;message_list()&lt;/code&gt; has been encoded.</source>
          <target state="translated">코덱 이름은 &lt;code&gt;message_list()&lt;/code&gt; 의 모든 메시지 가 인코딩 된 코덱의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="95a66f00b0729fc83f03c227254f16b97fe36011" translate="yes" xml:space="preserve">
          <source>The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">코드 이름 은 별표의 소문자로 변환되는 &lt;code&gt;SSH_FX_*&lt;/code&gt; 로 지정됩니다 . 예를 들어 오류 코드 &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; 은 &lt;code&gt;reason()&lt;/code&gt; 이 &lt;code&gt;no_such_file&lt;/code&gt; 이 되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="17206be2c27dcf13c38e698754daddf2e853496a" translate="yes" xml:space="preserve">
          <source>The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts.</source>
          <target state="translated">수집기는 추적 이벤트를 수집하여 타임 스탬프별로 정렬합니다. 타임 스탬프는 실제 추적 데이터가 생성 된 시간 (trace_ts) 또는 추적 데이터가 이벤트 레코드 (event_ts)로 변환 된 시간을 반영 할 수 있습니다. 추적 데이터에서 타임 스탬프가 누락 된 경우 (타임 스탬프 옵션이 erlang : trace / 4로 누락 됨) trace_ts가 event_ts로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="351503ceae71d258dda945d06961ceabf3006742" translate="yes" xml:space="preserve">
          <source>The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid().</source>
          <target state="translated">수집기에는 기본 제공 사전 서비스가 있습니다. 모든 용어는 사전에 값으로 저장되어 고유 키에 바인딩 될 수 있습니다. 기존 키로 새 값을 삽입하면 새 값이 기존 값을 덮어 씁니다. 프로세스는 {subscriber, pid ()}를 사전 키로 사용하여 사전 업데이트를 구독 할 수 있습니다. 모든 사전 업데이트는 {{구독자, '_'}, '_'} 패턴과 일치하는 구독자 프로세스로 전파되며 여기서 첫 번째 '_'는 pid ()로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="aa24630865ec2d27852697992e86dceb8f652e0b" translate="yes" xml:space="preserve">
          <source>The column where the token begins.</source>
          <target state="translated">토큰이 시작되는 열입니다.</target>
        </trans-unit>
        <trans-unit id="630fd19e25bb44d0c633fc41e9f2c893976f1cf6" translate="yes" xml:space="preserve">
          <source>The columns are: CNT - the number of times the function has been called, ACC - the time spent in the function including called functions, and OWN - the time spent in the function not including called functions.</source>
          <target state="translated">CNT-함수가 호출 된 횟수, ACC-호출 된 함수를 포함한 함수에 소요 된 시간 및 OWN-호출 된 함수를 포함하지 않는 함수에 소비 된 시간.</target>
        </trans-unit>
        <trans-unit id="dba186e396734b41173da2352f4bdf8aa2299d12" translate="yes" xml:space="preserve">
          <source>The combined size of message buffers associated with the process.</source>
          <target state="translated">프로세스와 연관된 메시지 버퍼의 결합 된 크기입니다.</target>
        </trans-unit>
        <trans-unit id="cd9eaf4fbf041c4980649b3adc6f08d99e41387b" translate="yes" xml:space="preserve">
          <source>The command for starting the emulator. Defaults to &lt;code&gt;erl&lt;/code&gt; in the same directory as the &lt;code&gt;erlc&lt;/code&gt; program itself, or, if it does not exist, &lt;code&gt;erl&lt;/code&gt; in any of the directories specified in environment variable &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터를 시작하는 명령입니다. 기본값 은 &lt;code&gt;erlc&lt;/code&gt; 프로그램 자체 와 동일한 디렉토리에서 &lt;code&gt;erl&lt;/code&gt; 로 설정 되거나 존재하지 않는 경우 환경 변수 &lt;code&gt;PATH&lt;/code&gt; 에 지정된 디렉토리에서 &lt;code&gt;erl&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb6501b3dc9f9f189fcbf95012d0127834e2f9cf" translate="yes" xml:space="preserve">
          <source>The command routine takes three parameters; the handle returned for the port by &lt;code&gt;uds_start&lt;/code&gt;, which is a pointer to the internal port structure, the data buffer, and the length of the data buffer. The buffer is the data sent from Erlang (a list of bytes) converted to an C array (of bytes).</source>
          <target state="translated">명령 루틴에는 세 가지 매개 변수가 있습니다. 내부 포트 구조, 데이터 버퍼 및 데이터 버퍼 길이에 대한 포인터 인 &lt;code&gt;uds_start&lt;/code&gt; 가 포트에 대해 리턴 한 핸들 버퍼는 Erlang (바이트 목록)에서 C 배열 (바이트)로 변환 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="aefc7b65db056c9f7f1b6802b3b0d8045a51356b" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the SSL/TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">SSL / TLS 옵션을 지정하기위한 명령 행 인수의 이름은 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 이며 그 뒤에 SSL 옵션 쌍과 값 이옵니다 . 인수 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef15ee0f0b965418b78c604ce208be1ebb9ac987" translate="yes" xml:space="preserve">
          <source>The command-line flag &lt;code&gt;-init_debug&lt;/code&gt; makes the &lt;code&gt;init&lt;/code&gt; process write some debug information while interpreting the boot script:</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-init_debug&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 프로세스가 부트 스크립트를 해석하는 동안 디버그 정보를 작성하게합니다.</target>
        </trans-unit>
        <trans-unit id="06c50b8e09545158899f6b79057dc3ebb405cca8" translate="yes" xml:space="preserve">
          <source>The comment for &lt;code&gt;driver_output_binary&lt;/code&gt; also applies for &lt;code&gt;driver_outputv&lt;/code&gt;.</source>
          <target state="translated">에 대한 의견 &lt;code&gt;driver_output_binary&lt;/code&gt; 는 또한 적용 &lt;code&gt;driver_outputv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1280084aa272a9d5d8e48fb9a3f8a4bc2a35a205" translate="yes" xml:space="preserve">
          <source>The comment for the file in the zip archive</source>
          <target state="translated">zip 아카이브에있는 파일에 대한 주석</target>
        </trans-unit>
        <trans-unit id="576cdebf96e8a6e4c9f5687b31e5fae369f7ae54" translate="yes" xml:space="preserve">
          <source>The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.</source>
          <target state="translated">일반적인 I / O 프로토콜은 처음부터 OTP에 존재했지만 문서화되지 않았으며 수년에 걸쳐 발전해 왔습니다. Robert Virding의 이론적 근거에 대한 부록에서 원래 I / O 프로토콜이 설명됩니다. 이 섹션에서는 현재 I / O 프로토콜에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="615ef8c10dad53dc0e37ab3cc2865c03f16fe578" translate="yes" xml:space="preserve">
          <source>The communication protocol between sub-agents is the normal message passing which is used in distributed Erlang systems. This implies that sub-agent communication is very efficient compared to SMUX, DPI, AgentX, and similar protocols.</source>
          <target state="translated">하위 에이전트 간의 통신 프로토콜은 분산 Erlang 시스템에서 사용되는 일반적인 메시지 전달입니다. 이는 하위 에이전트 통신이 SMUX, DPI, AgentX 및 유사한 프로토콜에 비해 매우 효율적이라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95e038ffe06742bd9a3eacaa7f1ab1768afde277" translate="yes" xml:space="preserve">
          <source>The community information should be stored in a file called &lt;code&gt;community.conf&lt;/code&gt;. It must be present if the agent is configured for SNMPv1 or SNMPv2c.</source>
          <target state="translated">커뮤니티 정보라는 파일에 저장해야 &lt;code&gt;community.conf&lt;/code&gt; . 에이전트가 SNMPv1 또는 SNMPv2c에 대해 구성된 경우 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae1b5318f7be646ee745ed8d6cfbf8aaace9d57c" translate="yes" xml:space="preserve">
          <source>The compilation option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the compiler to have the abstract code stored in the &lt;code&gt;abstract_code&lt;/code&gt; chunk in the Beam file (for debugging purposes).</source>
          <target state="translated">컴파일 옵션 &lt;code&gt;debug_info&lt;/code&gt; 는 컴파일러에 지정되어 추상 코드 가 Beam 파일 의 &lt;code&gt;abstract_code&lt;/code&gt; 청크에 저장 되도록 할 수 있습니다 (디버깅 목적으로).</target>
        </trans-unit>
        <trans-unit id="992839cad735d18aaa4ef05287e210db80780266" translate="yes" xml:space="preserve">
          <source>The compile time of the emulator running the originating node</source>
          <target state="translated">시작 노드를 실행하는 에뮬레이터의 컴파일 시간</target>
        </trans-unit>
        <trans-unit id="77923285d15f6d1638ca1085b0ea9ec5d8971d25" translate="yes" xml:space="preserve">
          <source>The compiled files of the imported MIBs must be present in the current directory, or a directory in the current path. The path is supplied with the &lt;code&gt;{i, Path}&lt;/code&gt; option, for example:</source>
          <target state="translated">가져온 MIB의 컴파일 된 파일은 현재 디렉토리 또는 현재 경로의 디렉토리에 있어야합니다. 경로는 &lt;code&gt;{i, Path}&lt;/code&gt; 옵션 과 함께 제공됩니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="6fb2caaa7af06a5fa0ebe6a620c35148002139db" translate="yes" xml:space="preserve">
          <source>The compiler also understands that assigning to '_' means that the value will not used. Therefore, the code in the following example will also be optimized:</source>
          <target state="translated">또한 컴파일러는 '_'에 할당하면 값이 사용되지 않음을 이해합니다. 따라서 다음 예제의 코드도 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="a0aa4f7feea676dc9f8b66e36fffc1af3c1c40f5" translate="yes" xml:space="preserve">
          <source>The compiler and other compile-time functions can also be started from the Erlang shell. Here follows a brief description of the primary functions. For a complete description of each function, see module &lt;code&gt;asn1ct&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일러 및 기타 컴파일 타임 함수는 Erlang 쉘에서 시작할 수도 있습니다. 다음은 주요 기능에 대한 간략한 설명입니다. 각 기능에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt; 의 모듈 &lt;code&gt;asn1ct&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd83f86086df5c8234f8a9ae71fc626e0a86c59a" translate="yes" xml:space="preserve">
          <source>The compiler automatically inserts the two special, exported functions into each module:</source>
          <target state="translated">컴파일러는 자동으로 내 보낸 두 가지 특수 함수를 각 모듈에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0aa023f79e7e9fc3b1f355a1f8fb5632ee1a7886" translate="yes" xml:space="preserve">
          <source>The compiler can also be accessed from the OS prompt, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">컴파일러는 OS 프롬프트에서 액세스 할 수도 있습니다 &lt;code&gt;erl(1)&lt;/code&gt; ERTS 의 erl (1) 매뉴얼 페이지 참조 ) .</target>
        </trans-unit>
        <trans-unit id="dcd47ca4ce5f90e9af16a0a668c0506b2926c5f4" translate="yes" xml:space="preserve">
          <source>The compiler can also inline various list manipulation functions from the module &lt;code&gt;list&lt;/code&gt; in STDLIB.</source>
          <target state="translated">컴파일러는 STDLIB 의 모듈 &lt;code&gt;list&lt;/code&gt; 에서 다양한 목록 조작 함수를 인라인 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="246aeec2b67ad60a1d79d7bfcb202381eb810d23" translate="yes" xml:space="preserve">
          <source>The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, &lt;code&gt;function_clause&lt;/code&gt; exceptions are converted to similar &lt;code&gt;case_clause&lt;/code&gt; exceptions.</source>
          <target state="translated">컴파일러는 Erlang 모듈 내에서 함수 인라인을 수행 할 수 있습니다. 인라인은 함수 호출이 함수 본문으로 바뀌고 인수가 실제 값으로 바뀐 것을 의미합니다. 인라인 코드에서 예외가 생성되는 경우를 제외하고 시맨틱은 유지됩니다. 본문이 인라인 된 함수에서 예외가보고됩니다. 또한 &lt;code&gt;function_clause&lt;/code&gt; 예외는 유사한 &lt;code&gt;case_clause&lt;/code&gt; 예외 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba61e82e2483a5192ba41d5a737c2246810798a9" translate="yes" xml:space="preserve">
          <source>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</source>
          <target state="translated">일치 컨텍스트가 공유되지 않음을 알고있는 경우 컴파일러는이 최적화 만 수행 할 수 있습니다. 공유 할 경우 Erlang의 기능적 속성 (참조 투명성이라고도 함)이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="df9982300695d7d925cce5cf1cdd61f21ef202d8" translate="yes" xml:space="preserve">
          <source>The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler tries to evaluate &lt;code&gt;1/0&lt;/code&gt;, detects that it will cause an exception, and emits a warning. However, the compiler is silent about the similar expression, &lt;code&gt;X/0&lt;/code&gt;, because of the variable in it. Thus, the compiler does not even try to evaluate and therefore it emits no warnings.</source>
          <target state="translated">컴파일러는 최적화를 시도하지 않는 표현식에 대해 경고하지 않습니다. 예를 들어, 컴파일러는 &lt;code&gt;1/0&lt;/code&gt; 을 평가하려고 시도 하고 예외가 발생 함을 감지하고 경고를 표시합니다. 그러나 컴파일러는 변수로 인해 유사한 표현식 &lt;code&gt;X/0&lt;/code&gt; 에 대해 침묵 합니다. 따라서 컴파일러는 평가조차하지 않으므로 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326ce5bdd2edeffbb0eff29680c2a35b2a0c7613" translate="yes" xml:space="preserve">
          <source>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</source>
          <target state="translated">컴파일러는 변수가 사용되지 않는지 알아냅니다. 다음 기능 각각에 대해 동일한 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="736c83a9c909e8b6995b93aa5a592a8cfd21644b" translate="yes" xml:space="preserve">
          <source>The compiler generates a &lt;code&gt;decode_part/2&lt;/code&gt; function when exclusive decode is chosen. This function decodes the parts that were left undecoded during the exclusive decode.</source>
          <target state="translated">배타적 디코딩을 선택하면 컴파일러에서 &lt;code&gt;decode_part/2&lt;/code&gt; 함수를 생성합니다 . 이 기능은 배타적 디코딩 동안 디코딩되지 않은 상태로 남은 부분을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="e4f37f01f0c640d21fe0c086a15f5624a101666e" translate="yes" xml:space="preserve">
          <source>The compiler generates the following files:</source>
          <target state="translated">컴파일러는 다음 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ae89eb6c8e241efda8fbeedb553bd086502de6d" translate="yes" xml:space="preserve">
          <source>The compiler handles the &lt;code&gt;IMPORT&lt;/code&gt; statement. It is important to import the compiled file and not the ASN.1 (source) file. A MIB must be recompiled to make changes visible to other MIBs importing it.</source>
          <target state="translated">컴파일러는 &lt;code&gt;IMPORT&lt;/code&gt; 문을 처리합니다 . ASN.1 (소스) 파일이 아닌 컴파일 된 파일을 가져 오는 것이 중요합니다. MIB를 가져 오는 다른 MIB에 변경 사항을 표시하려면 MIB를 재 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef890ca9c7e8253725d98c0071846009690a22a4" translate="yes" xml:space="preserve">
          <source>The compiler internally rewrites the latter code into the former.</source>
          <target state="translated">컴파일러는 내부적으로 후자의 코드를 전자로 재 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1f2b065f3c16869915d5310d49119f53343cacb9" translate="yes" xml:space="preserve">
          <source>The compiler is located in the module &lt;code&gt;compile&lt;/code&gt; (see the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler).</source>
          <target state="translated">컴파일러는 모듈 &lt;code&gt;compile&lt;/code&gt; ( 컴파일러 의 &lt;code&gt;compile(3)&lt;/code&gt; 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="a6b51b2ed2bc7f46e25bc64dda5c32ec191ce10a" translate="yes" xml:space="preserve">
          <source>The compiler is started by &lt;code&gt;asn1ct:compile/1&lt;/code&gt; with default options, or &lt;code&gt;asn1ct:compile/2&lt;/code&gt; if explicit options are given.</source>
          <target state="translated">컴파일러는 기본 옵션 으로 &lt;code&gt;asn1ct:compile/1&lt;/code&gt; 로 시작 하거나 명시 적 옵션이 제공되면 &lt;code&gt;asn1ct:compile/2&lt;/code&gt; 로 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="7898d48c7095ef7080834ae1df25bb02756bfa73" translate="yes" xml:space="preserve">
          <source>The compiler parses the SMI file and associates each table or variable with an instrumentation function (see the figure &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt;). The actual instrumentation functions are not needed at MIB compile time, only their names.</source>
          <target state="translated">컴파일러는 SMI 파일을 구문 분석하고 각 테이블 또는 변수를 인스 트루먼 테이션 함수와 연관시킵니다 (그림 &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt; ). 실제 계측 기능은 MIB 컴파일시 필요하지 않으며 이름 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29ced82347a929ec3d64773bda03ab575e2ebdf7" translate="yes" xml:space="preserve">
          <source>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts &lt;code&gt;Buffer&lt;/code&gt; from a match context to a sub binary (or do nothing if &lt;code&gt;Buffer&lt;/code&gt; is a binary already).</source>
          <target state="translated">컴파일러는 두 번째 및 세 번째 절에서 하위 이진 빌드를 제거하고 첫 번째 절에 &lt;code&gt;Buffer&lt;/code&gt; 를 일치 컨텍스트에서 하위 이진으로 변환하는 명령을 추가합니다 (또는 &lt;code&gt;Buffer&lt;/code&gt; 가 이미 이진 인 경우 아무 것도 수행하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="3e19fdc6630343c3d28603ee64052ea9f7070d01" translate="yes" xml:space="preserve">
          <source>The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 객체 파일을 생성하는 대신 객체 코드를 바이너리로 반환합니다. 성공하면 컴파일러는 &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c32c93e25c9ed677dd8b2dc76e27b04c3f91ef2" translate="yes" xml:space="preserve">
          <source>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</source>
          <target state="translated">컴파일러는 하위 바이너리를 생성하는 코드 생성을 피하려고 시도하고 얼마 지나지 않아 새로운 일치 컨텍스트를 생성하고 하위 바이너리를 폐기합니다. 하위 바이너리를 만드는 대신 일치 컨텍스트가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="93271cc943214ad52c731246bc1c6f5f502dc5df" translate="yes" xml:space="preserve">
          <source>The compiler understands the module attribute &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; and issues warnings about missing callback functions, for example:</source>
          <target state="translated">컴파일러는 모듈 속성 &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; 이해하고 누락 된 콜백 함수에 대한 경고를 발행합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4e5de69deb63fd9f8e518572799240cd4dbb515" translate="yes" xml:space="preserve">
          <source>The compiler will compress the generated object code, which can be useful for embedded systems.</source>
          <target state="translated">컴파일러는 생성 된 객체 코드를 압축하여 임베디드 시스템에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6ca4a1bcb2bb18eb6fa6ea91946375fe8b63fd" translate="yes" xml:space="preserve">
          <source>The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about &lt;code&gt;bin_opt_info&lt;/code&gt; in the Efficiency Guide.</source>
          <target state="translated">컴파일러는 이진 일치 최적화에 대한 정보 경고를 표시합니다 (성공 및 실패). 자세한 내용 은 효율성 안내서에서 &lt;code&gt;bin_opt_info&lt;/code&gt; 에 대한 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="272c69253881a0e58a00b19dd140c32886a5264d" translate="yes" xml:space="preserve">
          <source>The compiler will generate code similar to this:</source>
          <target state="translated">컴파일러는 다음과 유사한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f22d63ebef153d116952bd4b9cdc3d70b1deac48" translate="yes" xml:space="preserve">
          <source>The complete build environment is required while running &lt;code&gt;otp_patch_apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 를 실행하는 동안 완전한 빌드 환경이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="991eb99483640f8d2cb258dac8893f15f032e622" translate="yes" xml:space="preserve">
          <source>The complete content of the history buffer can be written to a configuration file by calling &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt;. Selected entries from the history can be written by calling &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt;, where &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the history entries to write. Moreover, the history buffer is always dumped to &lt;code&gt;ttb_last_config&lt;/code&gt; when &lt;code&gt;ttb:stop/0,1&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt; 를 호출하여 히스토리 버퍼의 전체 컨텐츠를 구성 파일에 쓸 수 있습니다 . 히스토리에서 선택된 항목은 &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt; 를 호출하여 작성할 수 있습니다 . 여기서 &lt;code&gt;NumList&lt;/code&gt; 는 쓸 히스토리 항목을 가리키는 정수 목록입니다. 또한 &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 이 호출 될 때 히스토리 버퍼는 항상 &lt;code&gt;ttb_last_config&lt;/code&gt; 에 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="06275c17581f810fa4579c2f0ccfc4b29d12ac2f" translate="yes" xml:space="preserve">
          <source>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</source>
          <target state="translated">완전한 일치 패턴은 항상 목록의 첫 번째 반환 값을 제공하고 나머지 하위 패턴은 정규식에서 발생한 순서대로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3a13431e36ebb44eb9fa84700a106f85f4b1ac47" translate="yes" xml:space="preserve">
          <source>The complete path to the Erlang emulator. Never use the &lt;code&gt;werl&lt;/code&gt; program for this. Defaults to the &lt;code&gt;erl.exe&lt;/code&gt; in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. When release handling is used, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Erlang 에뮬레이터의 전체 경로입니다. 이를 위해 &lt;code&gt;werl&lt;/code&gt; 프로그램을 사용하지 마십시오 . 받는 기본 &lt;code&gt;erl.exe&lt;/code&gt; 과 같은 디렉토리에 &lt;code&gt;erlsrv.exe&lt;/code&gt; . 릴리스 처리를 사용하는 경우 &lt;code&gt;start_erl.exe&lt;/code&gt; 와 유사한 프로그램으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b9e994208ced53dcfba8c8850e25b0dd795cc2c" translate="yes" xml:space="preserve">
          <source>The complete specification for the bit syntax appears in the &lt;code&gt;Reference Manual&lt;/code&gt;.</source>
          <target state="translated">비트 구문에 대한 전체 사양은 &lt;code&gt;Reference Manual&lt;/code&gt; 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="4b9f520763856efe6e5a044f5a2e1ee496c05b06" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;A -- B&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;. That is, it becomes very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists.</source>
          <target state="translated">&lt;code&gt;A -- B&lt;/code&gt; 의 복잡도는 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 비례합니다 . 즉, &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 모두 긴 목록 이면 속도가 매우 느려집니다 .</target>
        </trans-unit>
        <trans-unit id="fab2bbfeb9763c6bdcd0f510a645aceccf277fc7" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;, meaning that it is very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists. (If both lists are long, it is a much better choice to use ordered lists and &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lists:subtract(A, B)&lt;/code&gt; 의 복잡도는 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 비례합니다 . 이는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 모두 긴 목록 인 경우 매우 느리다는 것을 의미 합니다. 두 목록이 모두 길면 정렬 된 목록과 &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6fc7384b856b0bd8d7f49596a4fe364f88395e2b" translate="yes" xml:space="preserve">
          <source>The complexity on set operations is bounded by either &lt;strong&gt;O(|S|)&lt;/strong&gt; or &lt;strong&gt;O(|T| * log(|S|))&lt;/strong&gt;, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&amp;gt; 100-200 elements), and repeatedly testing for membership in the current set.</source>
          <target state="translated">세트 연산의 복잡성은 &lt;strong&gt;O (| S |)&lt;/strong&gt; 또는 &lt;strong&gt;O (| T | * log (| S |))로 제한됩니다&lt;/strong&gt; . 여기서 S는 특정 함수 호출에 가장 빠른 것에 따라 주어진 최대 세트입니다. 거의 동일한 크기의 세트에서 작동하는 경우이 구현은 정렬 된 목록 세트를 직접 사용하는 것보다 약 3 배 느립니다. 그러나 크기가 매우 다른 세트의 경우이 솔루션은 임의로 훨씬 빠릅니다. 실제 경우에는 종종 10 ~ 100 배. 이 구현은 특히 한 번에 몇 개의 요소를 누적하고 큰 세트 (&amp;gt; 100-200 요소)를 작성하고 현재 세트의 멤버쉽을 반복적으로 테스트하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1f0db048fd959939f98a5ab5ffcb76b17f2161e3" translate="yes" xml:space="preserve">
          <source>The component &lt;code&gt;b&lt;/code&gt; is treated as an original component when encoding a message. In this case, as it is not an optional element, it must be encoded.</source>
          <target state="translated">메시지 &lt;code&gt;b&lt;/code&gt; 를 인코딩 할 때 구성 요소 b 는 원래 구성 요소로 취급됩니다. 이 경우 선택적 요소가 아니므로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="95df5a7aa19b0879416444bcc5ff1ff82e16895f" translate="yes" xml:space="preserve">
          <source>The compressed term format is as follows:</source>
          <target state="translated">압축 용어 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b034a8ca7cf564d2716f7d145e9bf7ce76cd7cc" translate="yes" xml:space="preserve">
          <source>The compression algorithm none (= no compression) is removed so compression is enforced</source>
          <target state="translated">압축 알고리즘 없음 (= 압축 없음)이 제거되어 압축이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20f5418f59d5bf2e56046767d3d15b2e506ac3c4" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( inflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="0c9ba98b827fef9b660205799a125d38d037fa2c" translate="yes" xml:space="preserve">
          <source>The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is &lt;code&gt;DBL_MIN&lt;/code&gt;, which is 2.0^(-1022).</source>
          <target state="translated">이 개념은 정확히 0을 얻을 확률이 매우 낮다는 것을 의미합니다. 이 함수는 실제로 0을 반환하지 않을 정도로 낮습니다. 리턴 할 수있는 가장 작은 숫자는 &lt;code&gt;DBL_MIN&lt;/code&gt; 이며 2.0 ^ (-1022)입니다.</target>
        </trans-unit>
        <trans-unit id="943911384cb6e7518951f5974b91a80146819bfa" translate="yes" xml:space="preserve">
          <source>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames if one enables Unicode filename translation (&lt;code&gt;+fnu&lt;/code&gt;) on platforms where this is not the default.</source>
          <target state="translated">&quot;raw filenames&quot;개념은 이것이 기본값이 아닌 플랫폼에서 유니 코드 파일 이름 변환 ( &lt;code&gt;+fnu&lt;/code&gt; )을 사용하는 경우 잘못 인코딩 된 파일 이름을 처리하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5e9df0f0bca9d8678a66d1bcb07dea7aeeb1bd0" translate="yes" xml:space="preserve">
          <source>The concept of subtyping can be applied to integers and to other ASN.1 types. The details of subtyping are not explained here; for more information, see X.680. Various syntaxes are allowed when defining a type as an integer:</source>
          <target state="translated">서브 타이핑 개념은 정수 및 기타 ASN.1 유형에 적용될 수 있습니다. 하위 유형에 대한 자세한 내용은 여기에 설명되어 있지 않습니다. 자세한 내용은 X.680을 참조하십시오. 유형을 정수로 정의 할 때 다양한 구문이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ea91819bf64e3ece43df4e073d660a0ac1fb62c" translate="yes" xml:space="preserve">
          <source>The conceptual repository for management information is called the Management Information Base (MIB). It does not hold any data, merely a definition of what data can be accessed. A definition of an MIB is a description of a collection of managed objects.</source>
          <target state="translated">관리 정보의 개념적 저장소를 MIB (Management Information Base)라고합니다. 어떤 데이터도 보유하지 않으며 단지 어떤 데이터에 액세스 할 수 있는지에 대한 정의입니다. MIB의 정의는 관리 객체 모음에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="1f0f7f9a82dfed01500e86c2a2936e52983cbea0" translate="yes" xml:space="preserve">
          <source>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</source>
          <target state="translated">조건은 문자가 아닌 선택적 순서의 비 문자와 일치하는 긍정적 인 미리보기 어설 션입니다. 즉, 주제에 하나 이상의 문자가 있는지 테스트합니다. 문자가 발견되면 주제는 첫 번째 대안과 일치하고, 그렇지 않으면 두 번째 대안과 일치합니다. 이 패턴은 dd-aaa-dd 또는 dd-dd-dd 두 가지 형식 중 하나의 문자열과 일치합니다. 여기서 aaa는 문자이고 dd는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="2bb2d4ddfb9fd4340f3bf62302b4368f672d1819" translate="yes" xml:space="preserve">
          <source>The condition is specified by the user as a module name &lt;code&gt;CModule&lt;/code&gt; and a function name &lt;code&gt;CFunction&lt;/code&gt;. When a process reaches the breakpoint, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; is evaluated. If and only if this function call returns &lt;code&gt;true&lt;/code&gt;, the process stops. If the function call returns &lt;code&gt;false&lt;/code&gt;, the breakpoint is silently ignored.</source>
          <target state="translated">조건은 사용자가 모듈 이름 &lt;code&gt;CModule&lt;/code&gt; 및 함수 이름 &lt;code&gt;CFunction&lt;/code&gt; 으로 지정 합니다. 프로세스가 중단 점에 도달하면 &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; 이 평가됩니다. 이 함수 호출이 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우에만 프로세스가 중지됩니다. 함수 호출이 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 중단 점이 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f7986bbea85397da9d57d44bc07228d7fb46c1a2" translate="yes" xml:space="preserve">
          <source>The conditional test is performed by calling &lt;code&gt;Module:Name(Bindings)&lt;/code&gt;, where &lt;code&gt;Bindings&lt;/code&gt; is the current variable bindings. The function must return &lt;code&gt;true&lt;/code&gt; (break) or &lt;code&gt;false&lt;/code&gt; (do not break). To retrieve the value of a variable &lt;code&gt;Var&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">조건부 테스트는 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 를 호출하여 수행됩니다 . 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 현재 변수 바인딩입니다. 함수는 &lt;code&gt;true&lt;/code&gt; (중단) 또는 &lt;code&gt;false&lt;/code&gt; ( 중단 안 함)를 반환해야합니다 . 변수의 값을 검색하려면 &lt;code&gt;Var&lt;/code&gt; , 사용 &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e22cdbb695181f6db56e9e8f9255cb87d1e5c71" translate="yes" xml:space="preserve">
          <source>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</source>
          <target state="translated">범위 요청 조건이 충족되지 않았습니다. 응답은 범위 요청으로 취급되어서는 안되며 대신 일반 요청으로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c7d9b54f9813dcda9a518f9cbb3355ce28a2103" translate="yes" xml:space="preserve">
          <source>The config file directives stored as key-value tuples in an ETS table. Depicted &lt;code&gt;config_db()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">구성 파일 지시문은 ETS 테이블에 키-값 튜플로 저장됩니다. 함수 타입 선언에서 &lt;code&gt;config_db()&lt;/code&gt; 를 묘사했습니다 .</target>
        </trans-unit>
        <trans-unit id="1c180f4dced667f5747360888d336f97b780f3ef" translate="yes" xml:space="preserve">
          <source>The configuration can be changed during runtime. This is done with the functions &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">런타임 중에 구성을 변경할 수 있습니다. 이것은 &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt; 기능으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c0742cfd72a2d898508fa85616b5365c6647a68" translate="yes" xml:space="preserve">
          <source>The configuration created by &lt;code&gt;erts_alloc_config&lt;/code&gt; may perform bad, ever horrible, for runtime scenarios that are very different from the ones saved when creating the configuration. You are, therefore, advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the applications run when the configuration was made are changed, or if the load on the applications have changed since the configuration was made. You are also advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the Erlang runtime system used is changed.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성은 구성을 생성 할 때 저장된 것과 매우 다른 런타임 시나리오에 대해 좋지 않은 성능 을 발휘할 수 있습니다. 따라서 구성을 변경할 때 응용 프로그램을 실행하거나 구성을 수행 한 후 응용 프로그램의로드가 변경된 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행하는 것이 좋습니다 . 사용 된 Erlang 런타임 시스템이 변경된 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="85fc09c0359e30e0ac0453b4dd29606f3be0cecc" translate="yes" xml:space="preserve">
          <source>The configuration file is to be called &lt;code&gt;Name.config&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is any name.</source>
          <target state="translated">구성 파일은 &lt;code&gt;Name.config&lt;/code&gt; 이며 여기서 &lt;code&gt;Name&lt;/code&gt; 은 임의의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2e343dc41431506d1bab7a8f1ff51c6eab8fb28a" translate="yes" xml:space="preserve">
          <source>The configuration file must be as for &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 파일은 &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt; 과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="dea2779e1cbd9f4e936b9d22bec123fd3a929a25" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;community.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;community.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c155b3574ab962c920c1adb90ff1fbf8e4d0be7" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;context.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;context.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f94cc61e31a7b0de35c335106254d680dc12d2e8" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;notify.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a287de08efb6a6960170e4a56df71f4fd0b681e" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;standard.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edf952b8d588b0a93a4ac1f9d47f9ec65e928fc4" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;usm.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac382ba3d28511c043e21b8f905a371edc5d62a" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;vacm.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3706f3f0276351526850c287f3491578e144daa" translate="yes" xml:space="preserve">
          <source>The configuration files are described in the SNMP User's Manual.</source>
          <target state="translated">구성 파일은 SNMP 사용자 매뉴얼에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6aaee960bcbac0afc5716e7f7102e83e8360020" translate="yes" xml:space="preserve">
          <source>The configuration files is to have &lt;code&gt;rw-r--r--&lt;/code&gt; file privileges and be owned by root.</source>
          <target state="translated">구성 파일은 &lt;code&gt;rw-r--r--&lt;/code&gt; 파일 권한을 가지며 루트가 소유합니다.</target>
        </trans-unit>
        <trans-unit id="7d385331a206f67eef31fa2a51c3328ec0a6039b" translate="yes" xml:space="preserve">
          <source>The configuration files read are: &lt;code&gt;target_addr.conf&lt;/code&gt; and &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;target_addr.conf&lt;/code&gt; 및 &lt;code&gt;target_params.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="042a7891933367b39b8962f8cd2c79595dff050a" translate="yes" xml:space="preserve">
          <source>The configuration for a handler is a map with the following keys:</source>
          <target state="translated">핸들러의 구성은 다음 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="8c1a1fcfff199b6a1287871c07c285d5f0e37425" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">내장 핸들러의 구성은 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bec465458a3428115fd8e864e0c74437e5202fb" translate="yes" xml:space="preserve">
          <source>The configuration functions &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; execute, like test cases, on dedicated Erlang processes.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 및 &lt;code&gt;end_per_suite&lt;/code&gt; 구성 기능 은 테스트 사례처럼 전용 Erlang 프로세스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ca028bc56c7a5d8a6feb5fb00bb7ad713784158b" translate="yes" xml:space="preserve">
          <source>The configuration functions are optional. The following example is a test suite without configuration functions, including one simple test case, to check that module &lt;code&gt;mymod&lt;/code&gt; exists (that is, can be successfully loaded by the code server):</source>
          <target state="translated">구성 기능은 선택 사항입니다. 다음 예제는 모듈 &lt;code&gt;mymod&lt;/code&gt; 가 존재 하는지 (즉, 코드 서버에 의해 성공적으로로드 될 수 있는지) 확인하기위한 간단한 테스트 케이스를 포함하여 구성 기능이없는 테스트 스위트입니다 .</target>
        </trans-unit>
        <trans-unit id="b7ecabb96142aae8632b3c398a0652fea4462151" translate="yes" xml:space="preserve">
          <source>The configuration is created based on information about a number of runtime scenarios. It is obviously impossible to foresee every runtime scenario that can occur. The important scenarios are those that cause maximum or minimum load on specific memory allocators. Load in this context is total size of memory blocks allocated.</source>
          <target state="translated">여러 런타임 시나리오에 대한 정보를 기반으로 구성이 작성됩니다. 발생할 수있는 모든 런타임 시나리오를 예측하는 것은 분명히 불가능합니다. 중요한 시나리오는 특정 메모리 할당 자에서 최대 또는 최소로드를 발생시키는 시나리오입니다. 이 컨텍스트에서로드는 할당 된 총 메모리 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="a090830d0bfa6e8b71055c052afa6781c7336637" translate="yes" xml:space="preserve">
          <source>The configuration of a &lt;code&gt;Mnesia&lt;/code&gt; system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 시스템 의 구성은 스키마에 설명되어 있습니다. 스키마는 테이블 이름 및 각 테이블의 스토리지 유형과 같은 정보를 포함하는 특수 테이블입니다 (즉, 테이블을 RAM에 저장해야하는지 디스크에 저장해야하는지 여부와 위치에 관계없이).</target>
        </trans-unit>
        <trans-unit id="50fec7a20842abcc0261e4b0c9e02b04cf3308e0" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list. For backwards compatibility, a configuration file using apache-style configuration directives is supported.</source>
          <target state="translated">서버 구성은 Erlang 등록 정보 목록으로 제공됩니다. 이전 버전과의 호환성을 위해 아파치 스타일 구성 지시문을 사용하는 구성 파일이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="42a81cb11873a89bc4dc7fee0b14edc95426ecba" translate="yes" xml:space="preserve">
          <source>The configuration option &lt;code&gt;filter_default&lt;/code&gt; specifies the behaviour if all filter functions return &lt;code&gt;ignore&lt;/code&gt;, or if no filters exist. &lt;code&gt;filter_default&lt;/code&gt; is by default set to &lt;code&gt;log&lt;/code&gt;, meaning that if all existing filters ignore a log event, Logger forwards the event to the handler callback. If &lt;code&gt;filter_default&lt;/code&gt; is set to &lt;code&gt;stop&lt;/code&gt;, Logger discards such events.</source>
          <target state="translated">구성 옵션 &lt;code&gt;filter_default&lt;/code&gt; 는 모든 필터 함수가 &lt;code&gt;ignore&lt;/code&gt; 를 반환 하거나 필터가없는 경우 동작을 지정 합니다. &lt;code&gt;filter_default&lt;/code&gt; 는 기본적으로 &lt;code&gt;log&lt;/code&gt; 로 설정됩니다 . 즉, 기존의 모든 필터가 로그 이벤트를 무시하면 Logger가 이벤트를 핸들러 콜백으로 전달합니다. 경우 &lt;code&gt;filter_default&lt;/code&gt; 가 설정되어 &lt;code&gt;stop&lt;/code&gt; , 로거는 이벤트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="7cbcc3590c5b004952bd57c5ea409bb2cbc75510" translate="yes" xml:space="preserve">
          <source>The configuration parameter does not exist.</source>
          <target state="translated">구성 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="81a4addb98ae9327dd483e9ad9426add086cb215" translate="yes" xml:space="preserve">
          <source>The configuration produced by &lt;code&gt;erts_alloc_config&lt;/code&gt; may need to be manually adjusted as already stated. Do not modify the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;; instead, put your modifications in another file and load this file after the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. That is, put the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads your modification file later on the command-line than the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. If a memory allocation parameter appear multiple times, the last version of will be used, i.e., you can override parameters in the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. Doing it this way simplifies things when you want to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성 은 이미 언급 한대로 수동으로 조정해야합니다. &lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 파일을 수정하지 마십시오 . 대신, 수정 사항을 다른 파일에 &lt;code&gt;erts_alloc_config&lt;/code&gt; 생성 한 파일 뒤에이 파일을로드하십시오 . 즉, 넣어 &lt;code&gt;-args_file FileName&lt;/code&gt; 댄 명령 줄에 나중에 수정 파일을 읽고 인수 &lt;code&gt;-args_file FileName&lt;/code&gt; 의해 생성 된 구성 파일을 읽고 인수 &lt;code&gt;erts_alloc_config&lt;/code&gt; 을 . 메모리 할당 매개 변수가 여러 번 나타나는 경우 마지막 버전이 사용됩니다. 즉, &lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성 파일의 매개 변수를 대체 할 수 있습니다.. 이 방법을 사용하면 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행할 때 작업이 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="213a1cc6b8684b6f32c379587c37729fd6c0d583" translate="yes" xml:space="preserve">
          <source>The configuration string for this driver can be &lt;code&gt;config_server&lt;/code&gt;, if the &lt;code&gt;config_server.erl&lt;/code&gt; module that follows is compiled and exists in the code path during test execution:</source>
          <target state="translated">다음 의 &lt;code&gt;config_server.erl&lt;/code&gt; 모듈이 컴파일되어 테스트 실행 중 코드 경로에 존재하는 경우이 드라이버의 구성 문자열은 &lt;code&gt;config_server&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d419157999767488a1c56645c3a2365b2bbbcd93" translate="yes" xml:space="preserve">
          <source>The configuration term for &lt;code&gt;logger_formatter&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt;, and the following keys can be set as configuration parameters:</source>
          <target state="translated">&lt;code&gt;logger_formatter&lt;/code&gt; 의 구성 용어 는 &lt;code&gt;map&lt;/code&gt; 이며 다음 키를 구성 매개 변수로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712ad0cc82e1a88f726b7f711e243ab197e28193" translate="yes" xml:space="preserve">
          <source>The configure script allows you to customize a number of parameters; type &lt;code&gt;./configure --help&lt;/code&gt; or &lt;code&gt;./configure --help=recursive&lt;/code&gt; for details. &lt;code&gt;./configure --help=recursive&lt;/code&gt; will give help for all &lt;code&gt;configure&lt;/code&gt; scripts in all applications.</source>
          <target state="translated">configure 스크립트를 사용하면 여러 매개 변수를 사용자 정의 할 수 있습니다. 입력 &lt;code&gt;./configure --help&lt;/code&gt; 또는 &lt;code&gt;./configure --help=recursive&lt;/code&gt; 자세한 내용은. &lt;code&gt;./configure --help=recursive&lt;/code&gt; 는 모든 응용 프로그램의 모든 &lt;code&gt;configure&lt;/code&gt; 스크립트에 대한 도움말을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f871702162e9fe05aae1c9e32504517869931c15" translate="yes" xml:space="preserve">
          <source>The configure script is created by the GNU autoconf utility, which checks for system specific features and then creates a number of makefiles.</source>
          <target state="translated">configure 스크립트는 GNU autoconf 유틸리티에 의해 만들어지며 시스템 별 기능을 확인한 다음 여러 makefile을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d4bba926aeb3883bfbd6d00a31923bc874078ac" translate="yes" xml:space="preserve">
          <source>The configure should be skipped and all tests should hopefully pass. For more details about how to use ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</source>
          <target state="translated">구성을 건너 뛰고 모든 테스트를 통과해야합니다. ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt; 사용 방법에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="3f6521bf4e434f67b356b39a99c1ade02b2e892c" translate="yes" xml:space="preserve">
          <source>The connect is done in two steps: first an internal &lt;code&gt;connection setup&lt;/code&gt; and then by calling the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function. The first step could result in an error with &lt;code&gt;Reason = connect_reason()&lt;/code&gt; and the second an error with &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt;:</source>
          <target state="translated">연결은 먼저 내부 &lt;code&gt;connection setup&lt;/code&gt; 후 사용자 &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; 콜백 함수를 호출하여 두 단계로 수행됩니다 . 첫 번째 단계는 &lt;code&gt;Reason = connect_reason()&lt;/code&gt; 오류이고 두 번째 단계는 &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt; 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="371ea327d46ab20111d8dd7bba591b3794f31f48" translate="yes" xml:space="preserve">
          <source>The connection attempt can be traced by setting a trace level by either using &lt;code&gt;ei_set_tracelevel&lt;/code&gt; or by setting environment variable &lt;code&gt;EI_TRACELEVEL&lt;/code&gt;. The trace levels have the following messages:</source>
          <target state="translated">&lt;code&gt;ei_set_tracelevel&lt;/code&gt; 을 사용 하거나 환경 변수 &lt;code&gt;EI_TRACELEVEL&lt;/code&gt; 을 설정 하여 추적 레벨을 설정하여 연결 시도를 추적 할 수 있습니다 . 추적 레벨에는 다음 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef16d7f5ec818bdeac2287eb2c52b738775d9e3" translate="yes" xml:space="preserve">
          <source>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</source>
          <target state="translated">노드가 분산 노드 인 한 EPMD에 생성 된 연결은 유지해야합니다. 연결이 닫히면 노드가 EPMD에서 자동으로 등록 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5cbfa81fe3ccd8a5c63ea407c66f04845f8cea33" translate="yes" xml:space="preserve">
          <source>The connection is already encrypted. The connection is not affected.</source>
          <target state="translated">연결이 이미 암호화되었습니다. 연결에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="759c06525846f46120048a080c3029be1ff31bcc" translate="yes" xml:space="preserve">
          <source>The connection is associated with the process that created it and can only be accessed through it. The reason for this is to preserve the semantics of result sets and transactions when select_count/[2,3] is called or auto_commit is turned off. Attempts to use the connection from another process will fail. This will not effect the connection. On the other hand, if the client process dies the connection will be terminated.</source>
          <target state="translated">연결은 연결을 만든 프로세스와 연결되며 연결을 통해서만 액세스 할 수 있습니다. 그 이유는 select_count / [2,3]이 호출되거나 auto_commit이 해제되어있을 때 결과 집합 및 트랜잭션의 의미를 유지하기 위함입니다. 다른 프로세스에서 연결을 사용하려고하면 실패합니다. 연결에는 영향을 미치지 않습니다. 반면에 클라이언트 프로세스가 종료되면 연결이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd0a40ef6e388c1101ec314a27b945374892947" translate="yes" xml:space="preserve">
          <source>The connection is disallowed for some (unspecified) security reason.</source>
          <target state="translated">일부 지정되지 않은 보안상의 이유로 연결이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f988842124188a5fc24f10cf75663bb95aaa98aa" translate="yes" xml:space="preserve">
          <source>The connection setup failed (after &lt;code&gt;nodeup&lt;/code&gt; messages were sent).</source>
          <target state="translated">연결 설정에 실패했습니다 ( &lt;code&gt;nodeup&lt;/code&gt; 메시지가 전송 된 후 ).</target>
        </trans-unit>
        <trans-unit id="2c2c09cbaff852e46a92c401a3052832960adf16" translate="yes" xml:space="preserve">
          <source>The connection state.</source>
          <target state="translated">연결 상태</target>
        </trans-unit>
        <trans-unit id="21a557db3cf2f1855e12dfec5d40959655ffd926" translate="yes" xml:space="preserve">
          <source>The connection string is to be a connection string for postgres.</source>
          <target state="translated">연결 문자열은 postgres의 연결 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="577ebba31469c1b19a854e051f7d7bcd77b95482" translate="yes" xml:space="preserve">
          <source>The connection was closed.</source>
          <target state="translated">연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="f85b0a947aa3ee4eeec0e9164d045d949bc237ff" translate="yes" xml:space="preserve">
          <source>The connection was disconnected (forced from the current node).</source>
          <target state="translated">연결이 끊어졌습니다 (현재 노드에서 강제 됨).</target>
        </trans-unit>
        <trans-unit id="faa62673d542db68465d9b4076b4c1a13a9c2ef7" translate="yes" xml:space="preserve">
          <source>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, &lt;code&gt;Mnesia&lt;/code&gt; ensures that no inconsistencies occur if Erlang, &lt;code&gt;Mnesia&lt;/code&gt;, or the computer crashes while a write operation is in progress.</source>
          <target state="translated">일관성 속성은 트랜잭션이 항상 DBMS를 일관된 상태로 유지하도록합니다. 예를 들어, &lt;code&gt;Mnesia&lt;/code&gt; 는 쓰기 작업이 진행되는 동안 Erlang, &lt;code&gt;Mnesia&lt;/code&gt; 또는 컴퓨터가 충돌하는 경우 불일치가 발생하지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddfddbb8f225dd73ee75750b50447169433b54f" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; has value 50 (see &lt;code&gt;ct.hrl&lt;/code&gt;). At this level, all standard I/O gets printed. If a lower verbosity level is set, standard I/O printouts are ignored. Verbosity level 0 effectively turns all logging off (except from printouts made by &lt;code&gt;Common Test&lt;/code&gt; itself).</source>
          <target state="translated">상수 &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; 값은 50입니다 ( &lt;code&gt;ct.hrl&lt;/code&gt; 참조 ). 이 수준에서 모든 표준 I / O가 인쇄됩니다. 낮은 상세 수준을 설정하면 표준 I / O 출력이 무시됩니다. 상세 레벨 0은 모든 로깅을 효과적으로 해제합니다 ( &lt;code&gt;Common Test&lt;/code&gt; 자체 에서 작성된 출력물 제외 ).</target>
        </trans-unit>
        <trans-unit id="41f1224d66b802b926b2e31ecb1f284682edfb00" translate="yes" xml:space="preserve">
          <source>The construction &lt;code&gt;??Arg&lt;/code&gt;, where &lt;code&gt;Arg&lt;/code&gt; is a macro argument, is expanded to a string containing the tokens of the argument. This is similar to the &lt;code&gt;#arg&lt;/code&gt; stringifying construction in C.</source>
          <target state="translated">건설 &lt;code&gt;??Arg&lt;/code&gt; , &lt;code&gt;Arg&lt;/code&gt; 매크로 인자이고는 인수의 토큰을 포함하는 문자열로 확장된다. 이것은 C 의 &lt;code&gt;#arg&lt;/code&gt; stringifying 구성 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e122203f3d8b9817a2ea30ffb99c064337701c17" translate="yes" xml:space="preserve">
          <source>The content and meaning of these messages do not need to be interpreted by the process. Instead the following function is to be called:</source>
          <target state="translated">이러한 메시지의 내용과 의미는 프로세스에서 해석 할 필요가 없습니다. 대신 다음 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="968fd451ababe1d06f33d9607e5b522cbdd869a3" translate="yes" xml:space="preserve">
          <source>The content of these variables are added to the end of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">이 변수의 내용은 &lt;code&gt;erl&lt;/code&gt; 의 명령 행 끝에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="16b69fb0bdc6287d140f1bf18649d3746425bdf1" translate="yes" xml:space="preserve">
          <source>The content of this variable is added to the beginning of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">이 변수의 내용은 &lt;code&gt;erl&lt;/code&gt; 의 명령 행 시작 부분에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a245ccccd6f901e15ebc8675d831502211bf76e" translate="yes" xml:space="preserve">
          <source>The content-length of the document transferred.</source>
          <target state="translated">전송 된 문서의 내용 길이</target>
        </trans-unit>
        <trans-unit id="a88162e7d9c808763714e1548a612b2fffddbc1c" translate="yes" xml:space="preserve">
          <source>The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred.</source>
          <target state="translated">내용은 임의의 용어 일 수 있지만 추적 된 이벤트의 사후 처리를 단순화하기 위해 {Key, Value} 튜플의 일반 목록이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="40ce0e904e227f1f1d80e3e97a8e2fc6da1aa9d8" translate="yes" xml:space="preserve">
          <source>The contents of a &lt;code&gt;Mnesia&lt;/code&gt; table are read into the registry.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 테이블 의 내용은 레지스트리로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="63f1bf049157e992729a0f1938f590c49c434454" translate="yes" xml:space="preserve">
          <source>The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:</source>
          <target state="translated">lookbehind 어설 션의 내용은 일치하는 모든 문자열의 길이가 고정되도록 제한됩니다. 그러나 최상위 레벨 대안이 많은 경우 모두 동일한 고정 길이를 가질 필요는 없습니다. 따라서 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b15d542467bd5d0c49c3d5fddfb0a1dc700a2884" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file &lt;code&gt;ch_app.app&lt;/code&gt; for a supervision tree application like &lt;code&gt;ch_app&lt;/code&gt; looks as follows:</source>
          <target state="translated">최소한의 내용 &lt;code&gt;.app&lt;/code&gt; 파일 &lt;code&gt;ch_app.app&lt;/code&gt; 같은 감독 트리 응용 프로그램에 대한 &lt;code&gt;ch_app&lt;/code&gt; 의 모습은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="639b540a4a0d636d1f2615d8325b2b0b321bfb43" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file for a library application &lt;code&gt;libapp&lt;/code&gt; looks as follows:</source>
          <target state="translated">라이브러리 애플리케이션 &lt;code&gt;libapp&lt;/code&gt; 에 대한 최소 &lt;code&gt;.app&lt;/code&gt; 파일 의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d3ce5ee568b5e2c08421124a730a9db183b8eb2" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">레지스트리의 내용은 &quot;가까운&quot;Erlang 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 할 수 있습니다 . Erlang 노드에 대한 열린 연결을 제공해야합니다 ( &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 참조 ). 또한 백업이 시작되기 전에 &lt;code&gt;Mnesia&lt;/code&gt; 노드 에서 Mnesia 3.0 이상이 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3123b00654d44c25109223170c4027e9b8ae5329" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; 의 내용은 호출 된 nif 함수가 리턴 될 때까지 유효합니다. nif 호출이 리턴 된 후 &lt;code&gt;iovec&lt;/code&gt; 가 유효해야하는 경우 &lt;code&gt;NULL&lt;/code&gt; 환경 에서이 함수를 호출 할 수 있습니다. 환경이 주어지지 않으면 &lt;code&gt;iovec&lt;/code&gt; 는 벡터의 데이터를 소유하며 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt; 를 사용하여 명시 적으로 해제 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="da4fbdeab301fdc5a2057978a62de987cbe0d76f" translate="yes" xml:space="preserve">
          <source>The contents of the configuration file can either be fetched from the history or specified directly as a list of &lt;code&gt;{Mod,Func,Args}&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 컨텐츠는 히스토리에서 가져 오거나 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; 목록으로 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edda41fc99de03ce1cd51669b6fb86e783cb0c4" translate="yes" xml:space="preserve">
          <source>The contents of the source file is displayed in the &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소스 파일의 내용이 &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b8b2dc86a62154fcfa0997ece50bee44a97b77c" translate="yes" xml:space="preserve">
          <source>The context information should be stored in a file called &lt;code&gt;context.conf&lt;/code&gt;. The default context &lt;code&gt;&quot;&quot;&lt;/code&gt; need not be present.</source>
          <target state="translated">컨텍스트 정보는 &lt;code&gt;context.conf&lt;/code&gt; 파일에 저장해야합니다 . 기본 컨텍스트 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 없어도됩니다.</target>
        </trans-unit>
        <trans-unit id="b66a3e2b8c6b44620e15f4c494d018a17436828d" translate="yes" xml:space="preserve">
          <source>The continuation of the first call to the re-entrant input functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">재진입 입력 기능에 대한 첫 번째 호출의 연속은 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . 재진입 입력 체계의 작동 방식에 대한 자세한 설명은 암스트롱, 비디오 및 윌리엄스 : 'Erlang의 동시 프로그래밍', 13 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd08931a87a0bff5df1d5b202657eaee82a9ec50" translate="yes" xml:space="preserve">
          <source>The continuation pointer, that is, the return address for the current call. Usually useless for other than runtime system developers. This can be followed by the function into which the CP points, which is the function calling the current function.</source>
          <target state="translated">연속 포인터, 즉 현재 통화의 반환 주소입니다. 일반적으로 런타임 시스템 개발자 이외의 사용자에게는 쓸모가 없습니다. 그 다음에 CP가 가리키는 기능, 즉 현재 기능을 호출하는 기능이 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea909336d43c335fbcba40445c38198c897e80b9" translate="yes" xml:space="preserve">
          <source>The contracts specified with &lt;code&gt;-callback&lt;/code&gt; attributes in behaviour modules can be further refined by adding &lt;code&gt;-spec&lt;/code&gt; attributes in callback modules. This can be useful as &lt;code&gt;-callback&lt;/code&gt; contracts are usually generic. The same callback module with contracts for the callbacks:</source>
          <target state="translated">동작 모듈에서 &lt;code&gt;-callback&lt;/code&gt; 속성으로 지정된 계약 은 콜백 모듈에서 &lt;code&gt;-spec&lt;/code&gt; 속성 을 추가하여 세분화 할 수 있습니다 . &lt;code&gt;-callback&lt;/code&gt; 계약이 일반적 이므로 일반적으로 유용합니다 . 콜백 계약이있는 동일한 콜백 모듈 :</target>
        </trans-unit>
        <trans-unit id="3e6798c48093d78537c9e8593283bd4708fcad75" translate="yes" xml:space="preserve">
          <source>The control codes that we have defined are as follows:</source>
          <target state="translated">우리가 정의한 제어 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7099cc27d42d7b0589281942854b91087bea547b" translate="yes" xml:space="preserve">
          <source>The control interface gets a buffer to return its value in, but is free to allocate its own buffer if the provided one is too small. The &lt;code&gt;uds_control&lt;/code&gt; code is as follows:</source>
          <target state="translated">제어 인터페이스는 값을 리턴하기 위해 버퍼를 가져 오지만 제공된 버퍼가 너무 작 으면 자체 버퍼를 자유롭게 할당 할 수 있습니다. &lt;code&gt;uds_control&lt;/code&gt; 에 다음과 같이 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="8a434b940ea607f47b9b9c9664fa9c1e4002f5da" translate="yes" xml:space="preserve">
          <source>The convention is that all modules implementing some web server functionality has the name &lt;code&gt;mod_*&lt;/code&gt;. When configuring the web server, an appropriate selection of these modules is to be present in the module directive. Notice that there are some interaction dependencies to take into account, so the order of the modules cannot be random.</source>
          <target state="translated">일부 웹 서버 기능을 구현하는 모든 모듈의 이름은 &lt;code&gt;mod_*&lt;/code&gt; 입니다. 웹 서버를 구성 할 때 모듈 지시문에 이러한 모듈을 적절히 선택해야합니다. 고려해야 할 일부 상호 작용 종속성이 있으므로 모듈의 순서는 임의로 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcdf44cdd25837172eef411728f5162a4d169998" translate="yes" xml:space="preserve">
          <source>The cookie can also be specified as a list with a single atom element.</source>
          <target state="translated">쿠키는 단일 원자 요소가있는 목록으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a59a7d0400e25bda45d94942c1696b67b821c833" translate="yes" xml:space="preserve">
          <source>The cookie on the client node is set to &lt;code&gt;Cookie&lt;/code&gt; for this &lt;code&gt;rpc&lt;/code&gt; operation (used to match the server node cookie).</source>
          <target state="translated">클라이언트 노드의 &lt;code&gt;Cookie&lt;/code&gt; 는이 &lt;code&gt;rpc&lt;/code&gt; 조작에 대해 쿠키 로 설정됩니다 (서버 노드 쿠키와 일치시키기 위해 사용됨).</target>
        </trans-unit>
        <trans-unit id="6205a4b626543ee584a8b3de17a0bb2edfe3da9f" translate="yes" xml:space="preserve">
          <source>The cookies are never sent in cleartext and the handshake procedure expects the client (called &lt;code&gt;A&lt;/code&gt;) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</source>
          <target state="translated">쿠키는 절대로 일반 텍스트로 전송되지 않으며 핸드 셰이크 절차에서는 클라이언트 ( &lt;code&gt;A&lt;/code&gt; )가 충분한 다이제스트를 생성 할 수 있음을 증명하는 첫 번째 클라이언트가 될 것으로 예상합니다 . 다이제스트는 MD5 메시지 다이제스트 알고리즘으로 생성되며 문제는 난수 일 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="2ecaa6909338c5156841fd64226c00c498a1c90e" translate="yes" xml:space="preserve">
          <source>The cookies are text strings that can be viewed as passwords.</source>
          <target state="translated">쿠키는 비밀번호로 볼 수있는 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1a8ed05dd2354fe2176cfcf5ee50be7c3c648bcb" translate="yes" xml:space="preserve">
          <source>The core applications ERTS, Kernel, STDLIB, and SASL never allow real soft upgrade, but require the Erlang emulator to be restarted. This is indicated to the &lt;code&gt;release_handler&lt;/code&gt; by the upgrade instruction &lt;code&gt;restart_new_emulator&lt;/code&gt;. This instruction is always the very first instruction executed, and it restarts the emulator with the new versions of the above mentioned core applications and the old versions of all other applications. When the node is back up, all other upgrade instructions are executed, making sure each application is finally running its new version.</source>
          <target state="translated">핵심 응용 프로그램 ERTS, Kernel, STDLIB 및 SASL은 실제 소프트 업그레이드를 허용하지 않지만 Erlang 에뮬레이터를 다시 시작해야합니다. 업그레이드 명령 &lt;code&gt;restart_new_emulator&lt;/code&gt; 에 의해 &lt;code&gt;release_handler&lt;/code&gt; 에 표시됩니다 . 이 명령어는 항상 가장 먼저 실행되는 명령어이며 위에 언급 된 핵심 응용 프로그램의 새 버전과 다른 모든 응용 프로그램의 이전 버전으로 에뮬레이터를 다시 시작합니다. 노드가 백업되면 다른 모든 업그레이드 지침이 실행되어 각 응용 프로그램이 최종적으로 새 버전을 실행하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0fa547ec967437cac7e726eba19268112eb4cac1" translate="yes" xml:space="preserve">
          <source>The correct way to write this example is as follows:</source>
          <target state="translated">이 예제를 작성하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff048cb1599c9ae21644f42bc221284ba85f60d6" translate="yes" xml:space="preserve">
          <source>The correctness of each application is checked as follows:</source>
          <target state="translated">각 응용 프로그램의 정확성은 다음과 같이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="551bede0ac40e7793c4662c9c5f268e49a7cfe5a" translate="yes" xml:space="preserve">
          <source>The correctness of time values.</source>
          <target state="translated">시간 값의 정확성</target>
        </trans-unit>
        <trans-unit id="b2a787c3a6b18144a9dd01cea8e8539d0c49480c" translate="yes" xml:space="preserve">
          <source>The corresponding Erlang assignments:</source>
          <target state="translated">해당 Erlang 과제 :</target>
        </trans-unit>
        <trans-unit id="f464085c70da2d1c15ec4fc3d649680a6fc01752" translate="yes" xml:space="preserve">
          <source>The corresponding Mnesia table is specified as follows:</source>
          <target state="translated">해당 Mnesia 테이블은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="355cfe7dcddd0f236158f7c90d39becfb4d1ea88" translate="yes" xml:space="preserve">
          <source>The corresponding SNMP table would have three columns: &lt;code&gt;department&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;telno&lt;/code&gt;.</source>
          <target state="translated">해당 SNMP 테이블에는 &lt;code&gt;department&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;telno&lt;/code&gt; 의 세 열이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ba81bc06294c512d15b4e936f20c56b7b7af738" translate="yes" xml:space="preserve">
          <source>The corresponding library callback was unsuccessful.</source>
          <target state="translated">해당 라이브러리 콜백이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="3ed401667a17ba645dc4af42fafc330362e9b09e" translate="yes" xml:space="preserve">
          <source>The corresponding process or port is traced. The process or port may be a remote process or port (on another Erlang node). The node must be in the list of traced nodes (see &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">해당 프로세스 또는 포트가 추적됩니다. 프로세스 또는 포트는 원격 프로세스 또는 포트 일 수 있습니다 (다른 Erlang 노드에 있음). 노드는 추적 된 노드 목록에 있어야합니다 ( &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7fb4487b624fe2c0e433c8d91bb58ba0e2b99b60" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpCommunityTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-COMMUNITY-MIB의 &lt;code&gt;snmpCommunityTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="536e0673fdce81c6dcbd3b335e2956e57d01fa8e" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpNotifyTable&lt;/code&gt; in the SNMP-NOTIFICATION-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-NOTIFICATION-MIB에서 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6418aba8dde22da1e13b2bb9b3980fe5619feec0" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; in the SNMP-TARGET-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-TARGET-MIB의 &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffadaae2726db08a3b84abd6faf037b185f11f98" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;usmUserTable&lt;/code&gt; in the SNMP-USER-BASED-SM-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-USER-BASED-SM-MIB의 &lt;code&gt;usmUserTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dfdea70a637914fff122f7c22e23e4ca4a56c8f" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; in the SNMP-TARGET-MIB and &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">해당 테이블은 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 는 SNMP-TARGET-MIB 및 예약 &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; 는 SNMP-COMMUNITY-MIB있다.</target>
        </trans-unit>
        <trans-unit id="12ecd355d2a9f8a115a05cf588ffb85e072514b8" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;, &lt;code&gt;vacmAccessTable&lt;/code&gt; and &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-VIEW-BASED-ACM-MIB의 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; , &lt;code&gt;vacmAccessTable&lt;/code&gt; 및 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09299475ac2ec70dc802979c73301c27a76fa68a" translate="yes" xml:space="preserve">
          <source>The corresponding values were as follows:</source>
          <target state="translated">해당 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270bee1ebec250d3d9f95f9db65ee55f7e7e584a" translate="yes" xml:space="preserve">
          <source>The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the &lt;code&gt;unique&lt;/code&gt; option, all answers to &lt;code&gt;QH1&lt;/code&gt; would be returned followed by all answers to &lt;code&gt;QH2&lt;/code&gt;. The &lt;code&gt;unique&lt;/code&gt; option keeps the order between the remaining answers.</source>
          <target state="translated">비용은 상당합니다. 반환 된 모든 답변은 ETS 테이블에 저장됩니다. 답변을 반환하기 전에 ETS 테이블에서 검색되어 이미 반환되었는지 확인합니다. &lt;code&gt;unique&lt;/code&gt; 옵션이 없으면 &lt;code&gt;QH1&lt;/code&gt; 에 대한 모든 답변과 &lt;code&gt;QH2&lt;/code&gt; 에 대한 모든 답변이 반환됩니다 . &lt;code&gt;unique&lt;/code&gt; 옵션은 남아있는 답변의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="949377933f7f31ae27260e61d2614522203d38cb" translate="yes" xml:space="preserve">
          <source>The counter is per listening port. Thus, if two daemons are started, one with &lt;code&gt;{max_sessions,N}&lt;/code&gt; and the other with &lt;code&gt;{max_sessions,M}&lt;/code&gt;, in total &lt;code&gt;N+M&lt;/code&gt; connections are accepted for the whole &lt;code&gt;ssh&lt;/code&gt; application.</source>
          <target state="translated">카운터는 수신 포트 당입니다. 따라서 두 개의 데몬 (하나는 &lt;code&gt;{max_sessions,N}&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;{max_sessions,M}&lt;/code&gt; ) 을 시작하면 전체 &lt;code&gt;ssh&lt;/code&gt; 애플리케이션에 대해 총 &lt;code&gt;N+M&lt;/code&gt; 연결이 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="672049e9dcd3a0014488ab809e18dd017dc67fc3" translate="yes" xml:space="preserve">
          <source>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</source>
          <target state="translated">충돌 보고서에는 조상 및 초기 기능, 종료 이유 및이 프로세스 종료의 결과로 종료되는 다른 프로세스에 대한 정보와 같은 이전에 저장된 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e9528cde8205383b9d47742f84a963524c2a4c48" translate="yes" xml:space="preserve">
          <source>The crashed node is distributed but has no references to other nodes.</source>
          <target state="translated">충돌 한 노드가 분배되었지만 다른 노드에 대한 참조는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7beaf4ed3a100b4464262b486f549894f0ca1c0e" translate="yes" xml:space="preserve">
          <source>The crashed node is not distributed.</source>
          <target state="translated">충돌 한 노드가 분배되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ce14bb9518e3053298709463f31e4be173e33cd1" translate="yes" xml:space="preserve">
          <source>The created digraph has the same type as &lt;code&gt;Digraph&lt;/code&gt;. All vertices and edges have the default &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">작성된 digraph의 유형은 &lt;code&gt;Digraph&lt;/code&gt; 와 동일합니다 . 모든 정점과 모서리에는 기본 &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c87493c7d1e0ec2480a156b7c0c0a9bef2ce5f3" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">작성된 프로세스는 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 에서 핸드 셰이크에 필요한 콜백 및 기타 정보를 제공 하고이 레코드로 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e43aa2bf5d37514d385457e53e7dee018f509f4d" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">생성 된 프로세스는 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 에서 핸드 셰이크에 필요한 콜백 및 기타 정보를 제공 하고이 레코드로 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c10988c8597611573efffc7c6d796d8de4ec9158" translate="yes" xml:space="preserve">
          <source>The created supervisor process calls &lt;code&gt;Module:init/1&lt;/code&gt; to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned and all child processes have been started.</source>
          <target state="translated">생성 된 수퍼바이저 프로세스는 &lt;code&gt;Module:init/1&lt;/code&gt; 을 호출 하여 재시작 전략, 최대 재시작 강도 및 하위 프로세스를 찾습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/2,3&lt;/code&gt; 은 &lt;code&gt;Module:init/1&lt;/code&gt; 이 리턴되고 모든 하위 프로세스가 시작될 때까지 리턴되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="39edf1d66d588998727b714263ec502579dd9e7b" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">작성된 스레드 는 &lt;code&gt;func&lt;/code&gt; 가 리턴되거나 스레드가 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 를 호출 하면 종료됩니다 . 스레드의 종료 값은 &lt;code&gt;func&lt;/code&gt; 에서 리턴 되거나 인수로 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 에 전달됩니다 . 스레드를 작성 하는 드라이버는 드라이버가 언로드되기 전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 스레드를 결합 해야합니다. &quot;분리 된&quot;스레드, 즉 결합 할 필요가없는 스레드를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2caf2e3a9d3cd22055ea221541023c0a7f9e5f06" translate="yes" xml:space="preserve">
          <source>The creation number for a listen socket, which is calculated as (the value found in the lock-file + 1) rem 4. This creation value is also written back into the lock file, so that the next invocation of the emulator finds our value in the file.</source>
          <target state="translated">청취 소켓의 작성 번호는 (lock-file + 1에서 찾은 값) rem 4로 계산됩니다.이 작성 값은 잠금 파일에 다시 쓰여 지므로 다음 에뮬레이터 호출이 값을 찾습니다. 파일에서.</target>
        </trans-unit>
        <trans-unit id="adcdb05ae9295c817de82d7381820b023af67f91" translate="yes" xml:space="preserve">
          <source>The creation number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">PID의 번호 생성 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f64ba9b5d10763eb9a59dc112c16b79857dd73" translate="yes" xml:space="preserve">
          <source>The creation number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">포트의 생성 번호 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c7d8a3f3ea2d88f57c174b641c9f8441bf8c61" translate="yes" xml:space="preserve">
          <source>The creation number in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 의 생성 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="1597c6b33ee04607a4ecaec944fa0178d3d2dc29" translate="yes" xml:space="preserve">
          <source>The creation of the specification for a target system is performed in two steps. In the first step a complete specification is generated. It will likely contain much more files than you are interested in in your customized target system. In the second step the specification will be filtered according to your filters. There you have the ability to specify filters per application as well as system wide filters. You can also select a &lt;code&gt;profile&lt;/code&gt; for your system. Depending on the &lt;code&gt;profile&lt;/code&gt;, different default filters will be used. There are three different profiles to choose from: &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;standalone&lt;/code&gt;. &lt;code&gt;development&lt;/code&gt; is default. The parameters that are affected by the &lt;code&gt;profile&lt;/code&gt; are: &lt;code&gt;incl_sys_filters&lt;/code&gt;, &lt;code&gt;excl_sys_filters&lt;/code&gt;, &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;.</source>
          <target state="translated">대상 시스템에 대한 스펙 작성은 두 단계로 수행됩니다. 첫 번째 단계에서 완전한 사양이 생성됩니다. 사용자 정의 된 대상 시스템에 원하는 것보다 훨씬 많은 파일이 포함되어있을 것입니다. 두 번째 단계에서는 사양이 필터에 따라 필터링됩니다. 시스템 전체 필터뿐만 아니라 응용 프로그램 당 필터를 지정할 수 있습니다. 시스템에 대한 &lt;code&gt;profile&lt;/code&gt; 을 선택할 수도 있습니다. &lt;code&gt;profile&lt;/code&gt; 에 따라 다른 기본 필터가 사용됩니다. &lt;code&gt;development&lt;/code&gt; , &lt;code&gt;embedded&lt;/code&gt; 및 &lt;code&gt;standalone&lt;/code&gt; 세 가지 프로파일 중에서 선택할 수 있습니다 . &lt;code&gt;development&lt;/code&gt; 이 기본값입니다. 에 의해 영향을받는 매개 변수 &lt;code&gt;profile&lt;/code&gt; 은 &lt;code&gt;incl_sys_filters&lt;/code&gt; , &lt;code&gt;excl_sys_filters&lt;/code&gt; , &lt;code&gt;incl_app_filters&lt;/code&gt; 및 &lt;code&gt;excl_app_filters&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0455f1d04df5058ea9aa40b1a076812ef2243c2" translate="yes" xml:space="preserve">
          <source>The creation time for the dump</source>
          <target state="translated">덤프 작성 시간</target>
        </trans-unit>
        <trans-unit id="65280108d9a3568933bcafdbf482cccdf0bd7634" translate="yes" xml:space="preserve">
          <source>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</source>
          <target state="translated">크로스 커버 메커니즘을 사용하면 여러 테스트에서 모듈을 커버 분석 할 수 있습니다. 라이브러리 모듈과 같은 일부 코드를 여러 가지 다른 테스트에서 사용하고 누적 된 표지 결과가 바람직한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b20f15741df0176d3ffd68b64d6a68cc69323d01" translate="yes" xml:space="preserve">
          <source>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</source>
          <target state="translated">암호화 응용 프로그램은 FIPS 모드에서 OpenSSL 사용을 지원합니다. 이 시나리오에서는 Object Module에서 제공하는 검증 된 알고리즘 만 액세스 할 수 있으며 일반적으로 OpenSSL (md5와 같은)에서 사용 가능하거나 Erlang 코드 (SRP와 같은)에서 구현되는 다른 알고리즘은 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="67aa64b8718cdca92f0e4f9624ec881b790bb44a" translate="yes" xml:space="preserve">
          <source>The cryptolib OTP is linked with, usally the one the OS uses, probably OpenSSL,</source>
          <target state="translated">cryptolib OTP는 일반적으로 OS가 사용하는 것과 연결되며 아마도 OpenSSL과</target>
        </trans-unit>
        <trans-unit id="0f0da38521cbe8e331fa3581916f1bfca4dc26d7" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send a &quot;demonitor signal&quot; to the monitored entity and ignore any future results of the monitor.</source>
          <target state="translated">현재 동작은 두 가지 결합 된 작업으로 볼 수 있습니다. &quot;모니터링 신호&quot;를 모니터링 된 엔터티에 비동기 적으로 전송하고 향후 모니터 결과를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3c2e4d473b72e94c41373ad9e09ba22c294ebb64" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send an &quot;unlink signal&quot; to the linked entity and ignore any future results of the link.</source>
          <target state="translated">현재 동작은 두 가지 결합 된 작업으로 볼 수 있습니다. 링크 된 엔터티에 &quot;링크 해제 신호&quot;를 비동기 적으로 보내고 링크의 향후 결과는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d5b1d2a40e48d00196c6b21b7ac5dc93cf3228c9" translate="yes" xml:space="preserve">
          <source>The current function of the process. These fields do not always exist.</source>
          <target state="translated">프로세스의 현재 기능. 이 필드가 항상 존재하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="976f361d5fa6f84f4966eb0b28babd0491898a1f" translate="yes" xml:space="preserve">
          <source>The current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">현재 구현에서는 동일한 호스트에 대한 요청을 가정하고 포트 조합은 동일한 소켓 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01444d008abb77ac03ebfb5697a017f621eb7172" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;erts_alloc_config&lt;/code&gt; concentrate on configuration of multi-block carriers. Information gathered when a runtime scenario is saved is mainly current and maximum use of multi-block carriers. If a parameter that change the use of multi-block carriers is changed, a previously generated configuration is invalid and &lt;code&gt;erts_alloc_config&lt;/code&gt; needs to be run again. It is mainly the single block carrier threshold that effects the use of multi-block carriers, but other single-block carrier parameters might as well. If another value of a single block carrier parameter than the default is desired, use the desired value when running &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 의 현재 구현은 다중 블록 반송파 구성에 중점을 둡니다 . 런타임 시나리오가 저장 될 때 수집되는 정보는 주로 현재 및 최대 멀티 블록 캐리어 사용입니다. 다중 블록 반송파 사용을 변경하는 매개 변수가 변경되면 이전에 생성 된 구성이 유효하지 않으며 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행해야합니다. 다중 블록 반송파의 사용에 영향을 미치는 것은 주로 단일 블록 반송파 임계 값이지만 다른 단일 블록 반송파 매개 변수도 가능합니다. 기본값 이외의 단일 블록 캐리어 매개 변수의 다른 값이 필요한 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 실행할 때 원하는 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b881e02c8b7eb97ec891648e528239530b927d31" translate="yes" xml:space="preserve">
          <source>The current implementation of Erlang does not care if the connection to the EPMD is broken.</source>
          <target state="translated">Erlang의 현재 구현은 EPMD에 대한 연결이 끊어 졌는지 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="906db1d57b72f269a5be2b6efa0e34d3a4f40e71" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port programm written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">현재 구현은 실제 ODBC 드라이버를 사용하는 C로 작성된 포트 프로그램을 생성합니다. 이 포트 프로그램이 Erlang ODBC 응용 프로그램에 연결하기위한 기본 시간 종료는 5000msec입니다. ODBC 응용 프로그램에 대해 응용 프로그램 특정 환경 변수 'port_timeout'을 밀리 초 수로 설정하여이 시간 종료를 변경할 수 있습니다. 예 : [{odbc, [{port_timeout, 60000}]}]을 (를) 60 초로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4d365424f69367126413adcf57829b464b5f9add" translate="yes" xml:space="preserve">
          <source>The current instruction pointer. This is only of interest for runtime system developers. The function into which the program counter points is the current function of the process.</source>
          <target state="translated">현재 명령어 포인터. 이것은 런타임 시스템 개발자에게만 해당됩니다. 프로그램 카운터가 가리키는 기능은 프로세스의 현재 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">현재 줄 번호</target>
        </trans-unit>
        <trans-unit id="67653b4ba83e7d00b28af91f8d3fe0dae7dfae29" translate="yes" xml:space="preserve">
          <source>The current local working directory (compare &lt;code&gt;lpwd/1&lt;/code&gt;) is set to the value reported by &lt;code&gt;file:get_cwd/1&lt;/code&gt;, the wanted local directory.</source>
          <target state="translated">현재 로컬 작업 디렉토리 ( &lt;code&gt;lpwd/1&lt;/code&gt; 비교 )는 원하는 로컬 디렉토리 인 &lt;code&gt;file:get_cwd/1&lt;/code&gt; 에 의해보고 된 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bd1444e43ba871d9585120022333d4590131f8a" translate="yes" xml:space="preserve">
          <source>The current options are:</source>
          <target state="translated">현재 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51b93308e4fc131191ae4908faed86620396f4d9" translate="yes" xml:space="preserve">
          <source>The current position of the file is undefined after the operation.</source>
          <target state="translated">조작 후 파일의 현재 위치는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a23e8329113f0ad4178af5cd91d27561b0a29cbd" translate="yes" xml:space="preserve">
          <source>The current reference count after the decrement has been performed is returned.</source>
          <target state="translated">감소가 수행 된 후 현재 참조 카운트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="24502690d2f3bb086d825806372b93e14c48a509" translate="yes" xml:space="preserve">
          <source>The current reference count after the increment has been performed is returned.</source>
          <target state="translated">증분이 수행 된 후 현재 참조 카운트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd7feb388311de9e1a9de0daaa94dc63a945932" translate="yes" xml:space="preserve">
          <source>The current status of the &lt;code&gt;init&lt;/code&gt; process can be inspected. During system startup (initialization), &lt;code&gt;InternalStatus&lt;/code&gt; is &lt;code&gt;starting&lt;/code&gt;, and &lt;code&gt;ProvidedStatus&lt;/code&gt; indicates how far the boot script has been interpreted. Each &lt;code&gt;{progress, Info}&lt;/code&gt; term interpreted in the boot script affects &lt;code&gt;ProvidedStatus&lt;/code&gt;, that is, &lt;code&gt;ProvidedStatus&lt;/code&gt; gets the value of &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 프로세스 의 현재 상태를 검사 할 수 있습니다. 시스템 시작 (초기화) 동안 &lt;code&gt;InternalStatus&lt;/code&gt; 가 &lt;code&gt;starting&lt;/code&gt; 되고 &lt;code&gt;ProvidedStatus&lt;/code&gt; 는 부팅 스크립트가 해석 된 정도를 나타냅니다. 부팅 스크립트에서 해석 된 각 &lt;code&gt;{progress, Info}&lt;/code&gt; 용어는 &lt;code&gt;ProvidedStatus&lt;/code&gt; 에 영향을줍니다 . 즉 &lt;code&gt;ProvidedStatus&lt;/code&gt; 는 &lt;code&gt;Info&lt;/code&gt; 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b80e18839956d4be32e5bd88643c826f791ac807" translate="yes" xml:space="preserve">
          <source>The current status, one of the following:</source>
          <target state="translated">다음 중 하나의 현재 상태 :</target>
        </trans-unit>
        <trans-unit id="c7113183a7426c44fe409b00b899d8a41fc5814b" translate="yes" xml:space="preserve">
          <source>The current system access to the file.</source>
          <target state="translated">파일에 대한 현재 시스템 액세스</target>
        </trans-unit>
        <trans-unit id="8ada96b90a0d9236a710ef755016c1b7cca9e74d" translate="yes" xml:space="preserve">
          <source>The current token of a process is set in one of the following two ways:</source>
          <target state="translated">프로세스의 현재 토큰은 다음 두 가지 방법 중 하나로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="283b878d1d463389e9688a4d3aa6791beee18572" translate="yes" xml:space="preserve">
          <source>The current type/state of the port, which can be one of the values declared above.</source>
          <target state="translated">포트의 현재 유형 / 상태. 위에서 선언 된 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d59825d9fb6ddec0b7e1b9ca60e8a4611098dbe2" translate="yes" xml:space="preserve">
          <source>The current version of &lt;code&gt;Mnesia&lt;/code&gt; does not require that the name of the table is the same as the record name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 현재 버전 에서는 테이블 이름이 레코드 이름과 동일하지 않아도됩니다 ( &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c67d44d5188c140bb3bee7f987dfb33d7ef9f83" translate="yes" xml:space="preserve">
          <source>The current working directory</source>
          <target state="translated">현재 작업 디렉토리</target>
        </trans-unit>
        <trans-unit id="61d4a882ed6c30c03ae65ca2d8cd5ad27f2a5741" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">현재 작업 디렉토리 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 는 컴파일러를 실행할 때 코드 경로에 포함되지 않습니다. 이것은 현재 작업 디렉토리에서 컴파일러 또는 컴파일러가 사용하는 Erlang / OTP 시스템과 충돌 할 수있는 Beam 파일을로드하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="2fa5b9ac3977e02e3cf7d97b73ce85358c04959d" translate="yes" xml:space="preserve">
          <source>The currently executing process (that is, the sender) is not alive.</source>
          <target state="translated">현재 실행중인 프로세스 (즉, 발신자)가 활성 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="953e09eadeb4be83fa11df49bf70c92f526cc8f1" translate="yes" xml:space="preserve">
          <source>The daemon is started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; if the node is to be distributed and no running instance is present. If automatically launched environment variables must be used to change the behavior of the daemon; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">노드가 분배되고 실행중인 인스턴스가없는 경우 명령 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 의해 디먼이 자동으로 시작됩니다 . 자동으로 시작된 환경 변수를 사용하여 데몬의 동작을 변경해야합니다. &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d21e1220084b94119a9a3ad063df2a21e482723" translate="yes" xml:space="preserve">
          <source>The data bytes of the AVP.</source>
          <target state="translated">AVP의 데이터 바이트.</target>
        </trans-unit>
        <trans-unit id="f18388ef7ec4c10925540637ae1909f34a929370" translate="yes" xml:space="preserve">
          <source>The data contains errors.</source>
          <target state="translated">데이터에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="078b2a841f3b60a68b21c7cb12cdb8e09a9dd362" translate="yes" xml:space="preserve">
          <source>The data delivery order can be relaxed by disabling features that require strict ordering. This is done by passing the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record used when setting up the connection. When relaxed ordering is used, only the order of signals with the same sender/receiver pair has to be preserved. However, note that disabling the features that require strict ordering may have a negative impact on performance, throughput, and/or latency.</source>
          <target state="translated">엄격한 주문이 필요한 기능을 비활성화하여 데이터 전송 주문을 완화 할 수 있습니다. 연결 설정시 사용 된 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 의 &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; 필드 에서 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; 를 전달하면 됩니다. 완화 된 순서를 사용하는 경우 동일한 발신자 / 수신자 쌍을 가진 신호의 순서 만 유지해야합니다. 그러나 엄격한 순서를 요구하는 기능을 비활성화하면 성능, 처리량 및 / 또는 대기 시간에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a26a04ef322bb19505a5c1dc8d45f5e01e5f3f" translate="yes" xml:space="preserve">
          <source>The data formats defined in sections 4.2 (&quot;Basic AVP Data Formats&quot;) and 4.3 (&quot;Derived AVP Data Formats&quot;) of RFC 6733 are encoded as values of the types defined here. Values are passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; in a request record when sending a request, returned in a resulting answer record and passed to a &lt;code&gt;handle_request/3&lt;/code&gt; callback upon reception of an incoming request.</source>
          <target state="translated">RFC 6733의 섹션 4.2 ( &quot;기본 AVP 데이터 형식&quot;) 및 4.3 ( &quot;파생 AVP 데이터 형식&quot;)에 정의 된 데이터 형식은 여기에 정의 된 유형의 값으로 인코딩됩니다. 요청을 보낼 때 요청 레코드에서 값이 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 로 전달되고, 결과 응답 레코드로 리턴되며 수신 요청을 수신 하면 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdf833224017bb981586f311e5704bede95ecd92" translate="yes" xml:space="preserve">
          <source>The data in the boot script, fetched from the new application resource file &lt;code&gt;App.app&lt;/code&gt;</source>
          <target state="translated">새 응용 프로그램 리소스 파일 &lt;code&gt;App.app&lt;/code&gt; 에서 가져온 부팅 스크립트의 데이터</target>
        </trans-unit>
        <trans-unit id="bf8c73b58d26cdb1cd37eb82749dddb7b4d25b8e" translate="yes" xml:space="preserve">
          <source>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</source>
          <target state="translated">헤더의 데이터는 목록으로 전송되고 이진은 목록의 끝에 Erlang 이진으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9e8a427227bcde27fb34708c1f8037df0476db96" translate="yes" xml:space="preserve">
          <source>The data is queued in the port owner process' message queue. Notice that this does not yield to the emulator (as the driver and the emulator run in the same thread).</source>
          <target state="translated">데이터는 포트 소유자 프로세스의 메시지 큐에 대기합니다. 드라이버와 에뮬레이터가 동일한 스레드에서 실행되기 때문에 에뮬레이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5209f4c8cd33cb9b06c7cafb6cfe1d7ba8e19dd5" translate="yes" xml:space="preserve">
          <source>The data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is called.</source>
          <target state="translated">따라서 &lt;code&gt;ei&lt;/code&gt; 함수가 호출 될 때 데이터는 &lt;code&gt;buf[*index]&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0aaa71e50e0fe09624f658b5194caa4fc82ffa" translate="yes" xml:space="preserve">
          <source>The data model employed by &lt;code&gt;Mnesia&lt;/code&gt; is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 에서 사용하는 데이터 모델 은 확장 된 관계형 데이터 모델입니다. 데이터는 테이블 세트로 구성되며 다른 데이터 레코드 간의 관계는 관계를 설명하는 더 많은 테이블로 모델링 될 수 있습니다. 각 테이블에는 Erlang 레코드의 인스턴스가 있습니다. 레코드는 Erlang 튜플로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bcffc5bb38e63b17337f4be90db30aa76b246a80" translate="yes" xml:space="preserve">
          <source>The data produced by the lock counters will give an estimate on how well the runtime system will behave from a parallelizable view point for the scenarios tested. This tool was mainly developed to help Erlang runtime developers iron out potential and generic bottlenecks.</source>
          <target state="translated">잠금 카운터에 의해 생성 된 데이터는 테스트 된 시나리오에 대해 런타임 시스템이 병렬화 가능한 관점에서 얼마나 잘 작동하는지 추정합니다. 이 도구는 주로 Erlang 런타임 개발자가 잠재적이고 일반적인 병목 현상을 해결하도록 돕기 위해 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="2d27f50b0cd05524a7fd478c731d913e31e93736" translate="yes" xml:space="preserve">
          <source>The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice.</source>
          <target state="translated">이 모듈에서 사용되는 대기열을 나타내는 데이터는 다른 모듈에서는 불투명 한 것으로 간주됩니다. 형식에 대한 지식을 전제로 한 모든 코드는 얇은 얼음에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="966785b6ae629e19c8bed0b0d3e6ef6f991ec06e" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; in event &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 과 함께 제공되는 데이터는 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt; 이벤트의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; 과 동일한 형식을 따릅니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb604c10fe966845cdde71367a93dbf6cc929795" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as events &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 와 함께 제공되는 데이터는 이벤트 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; 와 동일한 형식을 따릅니다. 자세한 내용 은 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ae9537a2b782dfe6dcee8743658b21ed9b0301d" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt;, is represented as the following erlang record:</source>
          <target state="translated">&lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt; 데이터 유형 은 다음 erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="feae33cf3d811c301bdaf1550728e179af863677" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;'Validity'&lt;/code&gt;, &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, and &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; are represented as the following Erlang records:</source>
          <target state="translated">&lt;code&gt;'Validity'&lt;/code&gt; , &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 및 &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; 데이터 유형 은 다음 Erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="93bf041facbb4e82a9e8c285ac8447b2c8201746" translate="yes" xml:space="preserve">
          <source>The database can also become inconsistent if configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; is used or if &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; is used.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;max_wait_for_decision&lt;/code&gt; 이 사용되거나 &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; 이 사용되는 경우에도 데이터베이스가 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="264b842db8bf0ed81b261f12d4ee28f9ed7af246" translate="yes" xml:space="preserve">
          <source>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs.</source>
          <target state="translated">데이터베이스를 재구성하고 노드간에 테이블을 이동할 수 있습니다. 이러한 작업은 사용자 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c3e27d69c9e2bbfe084964b4ba1a3ee0b761dd5" translate="yes" xml:space="preserve">
          <source>The database model is as follows:</source>
          <target state="translated">데이터베이스 모델은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b5b0c5d2b259e474f8fd1130e7a9869d03ac6fb" translate="yes" xml:space="preserve">
          <source>The date and time when the process was started.</source>
          <target state="translated">프로세스가 시작된 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="fe8362a1d9af54200a42df54d2c52d6145175ad5" translate="yes" xml:space="preserve">
          <source>The debug enabled runtime system features lock violation checking, assert checking and various sanity checks to help a developer ensure correctness. Some of these features can be enabled on a normal beam using appropriate configure options.</source>
          <target state="translated">디버그 가능 런타임 시스템은 잠금 위반 검사, 어설트 검사 및 다양한 온 전성 검사를 통해 개발자가 정확성을 보장 할 수 있습니다. 이러한 기능 중 일부는 적절한 구성 옵션을 사용하여 일반 빔에서 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6dd12423efe39c011d13a41f3ecdda00e9c96f5" translate="yes" xml:space="preserve">
          <source>The debug information can also be removed from BEAM files using &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt;, and/or &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 디버그 정보를 BEAM 파일에서 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcf3b68d8f8e511e6ff9331d892546d1029cbf5" translate="yes" xml:space="preserve">
          <source>The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref.</source>
          <target state="translated">디버그 정보는 소스 코드를 비밀로 유지하기 위해 암호화 될 수 있지만 여전히 디버거 또는 외부 참조와 같은 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcc7761d46f20ec162261ce0e8d0b6a28d90fe6" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; is set by calling the function &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Level&lt;/code&gt;is one of the following:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 디버그 레벨은 mnesia &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 설정됩니다 . 여기서 &lt;code&gt;Level&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="8f1bdc53b01108885cce2234b4e2d9b39baa8b28" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; itself is also an application parameter, making it possible to start an Erlang system to turn on &lt;code&gt;Mnesia&lt;/code&gt; debug in the initial startup phase by using the following code:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 자체 의 디버그 수준은 응용 프로그램 매개 변수이기도하며 다음 코드를 사용하여 Erlang 시스템을 시작하여 초기 시작 단계에서 &lt;code&gt;Mnesia&lt;/code&gt; 디버그 를 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f3b5f9fa804bcf46e507eb72dd7777e9dc6ab9" translate="yes" xml:space="preserve">
          <source>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</source>
          <target state="translated">디코드 및 인코딩 함수는 버퍼에 대한 인덱스와 인덱스를 사용하며,이 인덱스는 인코딩 및 디코딩 할 지점을 가리 킵니다. 색인은 인코딩 / 디코딩 된 용어 바로 다음을 가리 키도록 업데이트됩니다. 용어가 버퍼에 맞는지 여부는 확인되지 않습니다. 인코딩이 버퍼를 벗어나면 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb7a0f41f8f9cd301571e70dc3544c6857e6778d" translate="yes" xml:space="preserve">
          <source>The decode functions return a record as result when decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; or a &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">디코딩 함수는 &lt;code&gt;SEQUENCE&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 디코딩시 결과로 레코드를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cef0dcfb934889d6cf431e5ebf6fd74edf18c281" translate="yes" xml:space="preserve">
          <source>The decoded value of an AVP. Will be &lt;code&gt;undefined&lt;/code&gt; on decode if the data bytes could not be decoded, the AVP is unknown, or if the &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;. The type of a decoded value is as document in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AVP의 디코딩 된 값. 됩니까 &lt;code&gt;undefined&lt;/code&gt; 데이터 바이트를 디코딩 할 수없는 경우 디코드에서 AVP를 알 수 없거나 경우 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 없는 &lt;code&gt;none&lt;/code&gt; . 디코딩 된 값의 유형은 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9dd25b2c0dae34a4ccb0be97da547058ad3ae8fb" translate="yes" xml:space="preserve">
          <source>The decoder returns an atom if the value corresponds to a symbol in the &lt;code&gt;Named Number List&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;Named Number List&lt;/code&gt; 의 기호에 해당하면 디코더는 원자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c388aad8aed6c9f2fdd03a9ff95a76e605fea9f6" translate="yes" xml:space="preserve">
          <source>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \s now match the same set of characters.</source>
          <target state="translated">기본 &quot;공백&quot;문자는 HT (9), LF (10), VT (11), FF (12), CR (13) 및 공백 (32)입니다. 로케일 별 일치가 발생하면 공백 문자 목록이 다를 수 있습니다. 더 적거나 더있을 수 있습니다. &quot;공간&quot;은 Perl 호환성을 위해 VT를 포함하지 않은 \ s와 다릅니다. 그러나 Perl은 릴리스 5.18에서 변경되었으며 PCRE는 릴리스 8.34에서 변경되었습니다. &quot;Space&quot;와 \ s는 이제 같은 문자 집합과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c59d65c8568f18df7ae19973d7555f547a715db3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Collector Filter&lt;/code&gt; converts the raw Erlang trace data format into &lt;code&gt;Event Records&lt;/code&gt;. If you want to perform this differently you can of course write your own &lt;code&gt;Collector Filter&lt;/code&gt; from scratch. But it may probably save you some efforts if you first apply the default filter in &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; before you apply your own conversions of its output.</source>
          <target state="translated">기본 &lt;code&gt;Collector Filter&lt;/code&gt; 는 원시 Erlang 추적 데이터 형식을 &lt;code&gt;Event Records&lt;/code&gt; 로 변환합니다 . 이 작업을 다르게 수행하려면 자신의 &lt;code&gt;Collector Filter&lt;/code&gt; 를 처음부터 새로 작성할 수 있습니다 . 그러나 자체 출력 변환을 적용하기 전에 &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; 에서 기본 필터를 먼저 적용하면 약간의 노력을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57652a6dee935467cebeeed4f3fb7d6f7116fee" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Size&lt;/code&gt; depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</source>
          <target state="translated">기본 &lt;code&gt;Size&lt;/code&gt; 는 유형에 따라 다릅니다. 정수의 경우 8입니다. float의 경우 64입니다. binary의 경우 모든 2 진입니다. 일치하는 경우이 기본값은 마지막 요소에만 유효합니다. 일치하는 다른 모든 이진 요소에는 크기 사양이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f1c0b4c022d0f07743e56c51911904bc53375f9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;message_queue_data&lt;/code&gt; 프로세스 플래그는 &lt;code&gt;erl(1)&lt;/code&gt; 명령 행 인수 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="572022a6b410479721a7992c7362b7aaff7907d4" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used and the result is returned to the client.</source>
          <target state="translated">기본 Erlang 평가 기가 사용되며 결과가 클라이언트로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="88fd0465cd657366b4590ae0f113c518fee5324c" translate="yes" xml:space="preserve">
          <source>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character.</source>
          <target state="translated">Erlang의 기본 유니 코드 인코딩은 바이너리 UTF-8로되어 있으며, OTP의 내장 함수 및 라이브러리가 바이너리 유니 코드 데이터를 찾는 형식이기도합니다. 목록에서 유니 코드 데이터는 정수로 인코딩되며, 각 정수는 하나의 문자를 나타내며 문자의 유니 코드 코드 포인트로 간단하게 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="49cebb251d6b0aa1500584bc73027335bd0baea3" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">기본 알고리즘은 &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116 +)입니다. 특정 알고리즘이 필요한 경우, 항상 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 상태를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3eb49c55e11d37a2c7f97be97bd91839e01e102b" translate="yes" xml:space="preserve">
          <source>The default behaviour in the two other cases (that is, abnormal exit) above is to:</source>
          <target state="translated">위의 두 가지 다른 경우 (즉, 비정상 종료)의 기본 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aad933f8a23be0b8f60b2f0009c014495bcab97" translate="yes" xml:space="preserve">
          <source>The default behaviour is ignore the message. To get a printout for each message with &lt;code&gt;AlwaysDisplay = true&lt;/code&gt;, use for example &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</source>
          <target state="translated">기본 동작은 메시지를 무시하는 것입니다. &lt;code&gt;AlwaysDisplay = true&lt;/code&gt; 인 각 메시지에 대한 출력물을 얻으려면 &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cc443fe9633fb1a0335c43045efe1e002d6805e" translate="yes" xml:space="preserve">
          <source>The default behaviour is to create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">기본 동작은 현재 디렉토리에 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="26ca635941f675c5f6767b6598533eaee0bb0c9a" translate="yes" xml:space="preserve">
          <source>The default behaviour of a process that receives a normal exit is to ignore the signal.</source>
          <target state="translated">정상 종료를 수신하는 프로세스의 기본 동작은 신호를 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47755f34cfe7e278db6d7efc977a211082ce5135" translate="yes" xml:space="preserve">
          <source>The default behaviour when a process receives an exit signal with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, is to terminate and in turn emit exit signals with the same exit reason to its linked processes. An exit signal with reason &lt;code&gt;normal&lt;/code&gt; is ignored.</source>
          <target state="translated">프로세스가 &lt;code&gt;normal&lt;/code&gt; 이외의 종료 이유가있는 종료 신호를 수신 할 때의 기본 동작 은 링크 된 프로세스에 대해 동일한 종료 이유가있는 종료 신호를 종료 한 다음 방출하는 것입니다. 이유가 &lt;code&gt;normal&lt;/code&gt; 종료 신호 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d70ec5c7098a4e4d6ce579440d90f6d0f1a9b44" translate="yes" xml:space="preserve">
          <source>The default boot file is &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt;, but in this case we need to specify a boot file from our target structure, typically &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt;. This is done with the &lt;code&gt;-boot&lt;/code&gt; command line option to &lt;code&gt;erl&lt;/code&gt;</source>
          <target state="translated">기본 부팅 파일은 &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt; 이지만이 경우 대상 구조에서 부팅 파일을 지정해야합니다 (일반적으로 &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt; ) . 이것은 &lt;code&gt;-boot&lt;/code&gt; 명령 행 옵션을 사용하여 &lt;code&gt;erl&lt;/code&gt; 에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8deb6cfc40b154f0f3bc4c292fe3c4c01bead83c" translate="yes" xml:space="preserve">
          <source>The default callback module &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt;, has the following features:</source>
          <target state="translated">기본 콜백 모듈 &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt; 에는 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1389307405e87741972dcfbd8f36d70ed4c7e741" translate="yes" xml:space="preserve">
          <source>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then &lt;code&gt;noAuthNoPriv&lt;/code&gt;.</source>
          <target state="translated">기본 감지 핸들러는 호출자의 추가 조치가 필요하며 보안 레벨이 &lt;code&gt;noAuthNoPriv&lt;/code&gt; 보다 높으면 감지가 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d22df62b6d0da804bdfcd33682ee76feb0f23fda" translate="yes" xml:space="preserve">
          <source>The default encoding for Erlang source files is changed from Latin-1 to UTF-8 since Erlang/OTP 17.0.</source>
          <target state="translated">Erlang / OTP 17.0 이후 Erlang 소스 파일의 기본 인코딩이 Latin-1에서 UTF-8로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3e3252c03a4fb54a27bf1c1fdc312100673449d" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt;Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">스크립트가 STDLIB 사용자 안내서 의 비 대화식 터미널 ( &lt;code&gt;Summary of Options&lt;/code&gt; 참조 )에서 실행되므로 &lt;code&gt;standard_io&lt;/code&gt; 에 대한 I / O 서버의 기본 인코딩 은 &lt;code&gt;latin1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fc4ad3abb12599963d8f41201b9099f8a6fadc8" translate="yes" xml:space="preserve">
          <source>The default encoding. Bytes supplied to the file, that is, &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; are written &quot;as is&quot; on the file. Likewise, bytes read from the file, that is, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; are returned &quot;as is&quot;. If module &lt;code&gt;io(3)&lt;/code&gt; is used for writing, the file can only cope with Unicode characters up to code point 255 (the ISO Latin-1 range).</source>
          <target state="translated">기본 인코딩입니다. 파일에 제공된 바이트, 즉 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 는 파일에 &quot;있는 그대로&quot;기록됩니다. 마찬가지로 파일에서 읽은 바이트, 즉 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 는 &quot;있는 그대로&quot;반환됩니다. 모듈 &lt;code&gt;io(3)&lt;/code&gt; 을 사용하여 쓰는 경우 파일은 코드 포인트 255 (ISO Latin-1 범위)까지의 유니 코드 문자 만 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c8c72f780ad73f25b213fdc25585528f17513b" translate="yes" xml:space="preserve">
          <source>The default endianness is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">기본 엔디안은 &lt;code&gt;big&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d83550f92d20198e2acab3ad30ef01b3a3ff2580" translate="yes" xml:space="preserve">
          <source>The default fallback behaviour. Template funs should end with:</source>
          <target state="translated">기본 폴백 동작입니다. 템플릿 재미는 다음과 같이 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="c9d9ffa8dde369b6838c3b5a3754294ebeb88aaa" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; cannot handle an object of type &lt;code&gt;NetworkAddress&lt;/code&gt; as INDEX (SNMPv1 only!). Use &lt;code&gt;IpAddress&lt;/code&gt; instead.</source>
          <target state="translated">기본 함수 및 &lt;code&gt;snmp_generic&lt;/code&gt; 은 &lt;code&gt;NetworkAddress&lt;/code&gt; 유형의 객체 를 INDEX (SNMPv1 만 해당)로 처리 할 수 ​​없습니다 . 대신 &lt;code&gt;IpAddress&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cd3d1fa535e347fbd4b38228c48e00bf23af7b2" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. &lt;code&gt;DisplayString&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. This must be checked in an overloaded &lt;code&gt;is_set_ok&lt;/code&gt; function.</source>
          <target state="translated">기본 함수 및 &lt;code&gt;snmp_generic&lt;/code&gt; 은 OCTET STRING에서 파생 된 텍스트 규칙 (예 : &lt;code&gt;DisplayString&lt;/code&gt; 및 &lt;code&gt;DateAndTime&lt;/code&gt; ) 에서 각 OCTET의 범위를 확인하지 않습니다 . 과부하 된 &lt;code&gt;is_set_ok&lt;/code&gt; 함수 에서 점검해야합니다 .</target>
        </trans-unit>
        <trans-unit id="93ec2b0bf3246052db6872a9a89f490a6940711d" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">기본 처리기 인 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 에는 과부하 보호 메커니즘이있어로드가 많은 기간 동안 (수 많은 수신 로그 요청을 처리해야하는 경우) 처리기가 생존하고 응답 상태를 유지할 수 있습니다. 이 메커니즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fef3702dc90f570ebd9028951e47041a3eec62af" translate="yes" xml:space="preserve">
          <source>The default initial heap size of 233 words is quite conservative to support Erlang systems with hundreds of thousands or even millions of processes. The garbage collector grows and shrinks the heap as needed.</source>
          <target state="translated">기본 초기 힙 크기 233 워드는 수십만 또는 수백만 개의 프로세스가있는 Erlang 시스템을 지원하는 데 상당히 보수적입니다. 가비지 수집기는 필요에 따라 힙을 늘리고 줄입니다.</target>
        </trans-unit>
        <trans-unit id="028f1e913dc597e5f47465aa0038982d46d84b7c" translate="yes" xml:space="preserve">
          <source>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this.</source>
          <target state="translated">기본 계측을 통해 관리자 측의 응용 프로그램을 에이전트와 동시에 개발하고 테스트 할 수 있습니다. ASN.1 파일이 완료 되 자마자 MIB 컴파일러가 기본 구현을 생성하고 이로부터 관리 응용 프로그램을 개발하게하십시오.</target>
        </trans-unit>
        <trans-unit id="2bcdc2b092cf0144876d346105d3638a289ddc47" translate="yes" xml:space="preserve">
          <source>The default instrumentation functions are defined in the module &lt;code&gt;snmp_generic&lt;/code&gt;. Refer to the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for details.</source>
          <target state="translated">기본 계측 기능은 &lt;code&gt;snmp_generic&lt;/code&gt; 모듈에 정의되어 있습니다. 자세한 내용은 참조 설명서의 SNMP 섹션 &lt;code&gt;snmp_generic&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f9d2c2e9dd957fcc3258b4a7c7be3758f84afc" translate="yes" xml:space="preserve">
          <source>The default is 30 seconds.</source>
          <target state="translated">기본값은 30 초입니다.</target>
        </trans-unit>
        <trans-unit id="697dc028cf7853b692477e62b3b0ccd825e45fa0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;integer&lt;/code&gt;. &lt;code&gt;bytes&lt;/code&gt; is a shorthand for &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bits&lt;/code&gt; is a shorthand for &lt;code&gt;bitstring&lt;/code&gt;. See below for more information about the &lt;code&gt;utf&lt;/code&gt; types.</source>
          <target state="translated">기본값은 &lt;code&gt;integer&lt;/code&gt; 입니다. &lt;code&gt;bytes&lt;/code&gt; 는 &lt;code&gt;binary&lt;/code&gt; 의 약자 이고 &lt;code&gt;bits&lt;/code&gt; 는 &lt;code&gt;bitstring&lt;/code&gt; 의 약자입니다 . &lt;code&gt;utf&lt;/code&gt; 유형 에 대한 자세한 내용은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f0b6dd22860df8373214ee0633cf82a9776e5cd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;binary_alloc&lt;/code&gt; and &lt;code&gt;driver_alloc&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; for the other allocator types.</source>
          <target state="translated">기본값은 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;binary_alloc&lt;/code&gt; 및 &lt;code&gt;driver_alloc&lt;/code&gt; , 그리고 &lt;code&gt;false&lt;/code&gt; 다른 할당 유형.</target>
        </trans-unit>
        <trans-unit id="f6c6037b1efc7d6b42e5368b46d0f3b99b3ee991" translate="yes" xml:space="preserve">
          <source>The default is to return a sequence of QLCs in a block, but if option &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; is specified, one single QLC is returned.</source>
          <target state="translated">디폴트는 블록에 일련의 QLC를 리턴하는 것이지만, &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; 옵션 이 지정되면 하나의 단일 QLC가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b873bd22585e6e628d3df8c1732fa1e4731a1722" translate="yes" xml:space="preserve">
          <source>The default is to return a string, but if option &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings.</source>
          <target state="translated">디폴트는 문자열을 리턴하는 것이지만 옵션 &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; 가 지정되면 추상 코드가 대신 리턴됩니다. 추상 코드에서 포트 식별자, 참조 및 pid는 문자열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6b16165d91c06ae4aeb2706afc9b7a0ac50cd9da" translate="yes" xml:space="preserve">
          <source>The default is to return all elements in lists, but if option &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; is specified, only a limited number of elements are returned.</source>
          <target state="translated">디폴트는리스트의 모든 요소를 ​​리턴하는 것이지만 옵션 &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; 가 지정되면 제한된 수의 요소 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7b0f890d901ebd92c482f0beb121398b160a73" translate="yes" xml:space="preserve">
          <source>The default is to show all parts of objects and match specifications, but if option &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; is specified, parts of terms below a certain depth are replaced by &lt;code&gt;'...'&lt;/code&gt;.</source>
          <target state="translated">기본값은 오브젝트의 모든 부분을 표시하고 스펙을 일치시키는 것이지만 옵션 &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; 가 지정된 경우 특정 깊이 아래의 용어 부분은 &lt;code&gt;'...'&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="d031478aad7c792d83bd41e0b1d60d3346429273" translate="yes" xml:space="preserve">
          <source>The default is to sort terms in ascending order, but that can be changed by value &lt;code&gt;descending&lt;/code&gt; or by specifying an ordering function &lt;code&gt;Fun&lt;/code&gt;. An ordering function is antisymmetric, transitive, and total. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; is to return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; comes before &lt;code&gt;B&lt;/code&gt; in the ordering, otherwise &lt;code&gt;false&lt;/code&gt;. An example of a typical ordering function is less than or equal to, &lt;code&gt;=&amp;lt;/2&lt;/code&gt;. Using an ordering function slows down the sort considerably. Functions &lt;code&gt;keysort&lt;/code&gt;, &lt;code&gt;keymerge&lt;/code&gt; and &lt;code&gt;keycheck&lt;/code&gt; do not accept ordering functions.</source>
          <target state="translated">기본적으로 용어는 오름차순으로 정렬되지만 값은 &lt;code&gt;descending&lt;/code&gt; 또는 정렬 함수 &lt;code&gt;Fun&lt;/code&gt; 을 지정하여 변경할 수 있습니다 . 주문 함수는 비대칭, 전이 및 총계입니다. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; 반환하는 것입니다 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 가 앞에 오는 &lt;code&gt;B&lt;/code&gt; 순서에, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; . 일반적인 순서 함수의 예는 &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 보다 작거나 같습니다 . 정렬 기능을 사용하면 정렬 속도가 상당히 느려집니다. 기능 &lt;code&gt;keysort&lt;/code&gt; , &lt;code&gt;keymerge&lt;/code&gt; 을 하고 &lt;code&gt;keycheck&lt;/code&gt; 는 주문 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="388c1ebba36e81e6d83c9829202075488730e57f" translate="yes" xml:space="preserve">
          <source>The default list is fetched from the &lt;code&gt;public_key&lt;/code&gt; application.</source>
          <target state="translated">기본 목록은 &lt;code&gt;public_key&lt;/code&gt; 애플리케이션 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6b3871f80aaa305c511a84fd9b3f91462dfdba6b" translate="yes" xml:space="preserve">
          <source>The default logging behavior of &lt;code&gt;ct_telnet&lt;/code&gt; is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a &lt;code&gt;ct_telnet&lt;/code&gt; function, such as &lt;code&gt;expect/3&lt;/code&gt;. However, &lt;code&gt;ct_telnet&lt;/code&gt; can be configured to use a special purpose event handler, implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;, for logging &lt;strong&gt;all&lt;/strong&gt; Telnet traffic. To use this handler, install a &lt;code&gt;Common Test&lt;/code&gt; hook named &lt;code&gt;cth_conn_log&lt;/code&gt;. Example (using the test suite information function):</source>
          <target state="translated">&lt;code&gt;ct_telnet&lt;/code&gt; 의 기본 로깅 동작 은 수행 된 작업, 명령 및 해당 결과에 대한 정보를 테스트 케이스 HTML 로그에 인쇄하는 것입니다. 다음은 HTML 로그에 인쇄되지 않습니다. 텔넷 서버에서 보낸 &lt;code&gt;ct_telnet&lt;/code&gt; 함수에 의해 명시 적으로 수신되지 않은 텍스트 문자열 ( 예 : &lt;code&gt;expect/3&lt;/code&gt; ) . 그러나 &lt;code&gt;ct_telnet&lt;/code&gt; 은 &lt;strong&gt;모든&lt;/strong&gt; Telnet 트래픽 을 로깅하기 위해 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 에 구현 된 특수 목적 이벤트 핸들러를 사용하도록 구성 할 수 있습니다 . 이 핸들러를 사용하려면 &lt;code&gt;cth_conn_log&lt;/code&gt; 라는 &lt;code&gt;Common Test&lt;/code&gt; 후크를 설치하십시오 . 예 (테스트 스위트 정보 기능 사용) :&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2de8d81b3d3a2e14473bb755a7b9ea4746cd308a" translate="yes" xml:space="preserve">
          <source>The default matching handles dns_id and uri_id. In an uri_id the value is tested for equality with a value from the &lt;code&gt;Subject Alternate Name&lt;/code&gt;. If som other kind of matching is needed, use the &lt;code&gt;match_fun&lt;/code&gt; option.</source>
          <target state="translated">기본 일치는 dns_id 및 uri_id를 처리합니다. uri_id에서 값은 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 의 값과 동일한 지 테스트됩니다 . 다른 종류의 일치가 필요한 경우 &lt;code&gt;match_fun&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="84111fd78857c9aae8ea5220ba7612eb708e45fa" translate="yes" xml:space="preserve">
          <source>The default matching transformes the ascii values in strings to lowercase before comparing. The &lt;code&gt;match_fun&lt;/code&gt; is however called without any transfomation applied to the strings. The reason is to enable the user to do unforseen handling of the strings where the original format is needed.</source>
          <target state="translated">기본 일치는 비교하기 전에 문자열의 ASCII 값을 소문자로 변환합니다. 그러나 &lt;code&gt;match_fun&lt;/code&gt; 은 문자열에 변형을 적용하지 않고 호출됩니다. 그 이유는 사용자가 원래 형식이 필요한 문자열을 예기치 않게 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="aa2a84cd90225c7ed3bdea62cdca292d4a45b475" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows and MacOS X enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">기본 모드는 운영 체제에 따라 다릅니다. Windows 및 MacOS X는 일관된 파일 이름 인코딩을 시행하므로 VM은 &lt;code&gt;utf8&lt;/code&gt; 모드를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="953f88f92bc1b24efaf4cf45547f40d0e648b131" translate="yes" xml:space="preserve">
          <source>The default object arity is smaller than &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">기본 객체 arity는 &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="4de77215568172d7d29aabd76eae88688d23f0d0" translate="yes" xml:space="preserve">
          <source>The default options of the &lt;code&gt;erlsrv&lt;/code&gt; program are not sufficient for release handling. The machine started by &lt;code&gt;erlsrv&lt;/code&gt; is be specified as the &lt;code&gt;start_erl&lt;/code&gt; program and the arguments are to contain &lt;code&gt;++&lt;/code&gt; followed by the desired options.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; 프로그램 의 기본 옵션은 릴리스 처리에 충분하지 않습니다. &lt;code&gt;erlsrv&lt;/code&gt; 로 시작된 시스템 은 &lt;code&gt;start_erl&lt;/code&gt; 프로그램 으로 지정되며 인수는 &lt;code&gt;++&lt;/code&gt; 다음에 원하는 옵션 을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb1094b520cae2a88d55d90efc05453766135ad7" translate="yes" xml:space="preserve">
          <source>The default set of groups is listed in &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt;. This file may be regenerated like this:</source>
          <target state="translated">기본 그룹 세트는 &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt; 에 나열되어 있습니다. 이 파일은 다음과 같이 재생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c212e9694a3fd892d150f01a66f923860ff2fc9" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">기본 쉘 프롬프트 기능은 노드 이름 (노드가 분산 시스템의 일부일 수있는 경우) 및 현재 명령 번호를 표시합니다. 사용자는 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 STDLIB 애플리케이션에 대한 애플리케이션 구성 매개 변수 &lt;code&gt;shell_prompt_func&lt;/code&gt; 를 설정 하여 프롬프트 기능을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b63ca80d11da692b5651bc33e43d076e3793c3" translate="yes" xml:space="preserve">
          <source>The default signedness is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">기본 서명은 &lt;code&gt;unsigned&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff776579e06c4767b62b9f485e782cd999a09f7a" translate="yes" xml:space="preserve">
          <source>The default simple handler is called &lt;code&gt;alarm_handler&lt;/code&gt; and it can be exchanged by calling &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; as &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt;. &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; is called. For more details, see &lt;code&gt;gen_event(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">기본 단순 핸들러는 &lt;code&gt;alarm_handler&lt;/code&gt; 라고 하며 &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; 를 &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt; 로 호출하여 교환 할 수 있습니다 . &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; 가 호출되었습니다. 자세한 내용은 &lt;code&gt;gen_event(3)&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd4ef6f5a1e3a142885438b41744f5b5b26e5b7" translate="yes" xml:space="preserve">
          <source>The default socket options are &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt;.</source>
          <target state="translated">기본 소켓 옵션은 &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b0a75358d0df669ac13a835e5ee193bd00512b1" translate="yes" xml:space="preserve">
          <source>The default standard handler, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, can be replaced by a disk_log handler at startup of the Kernel application. See an example of this below.</source>
          <target state="translated">기본 표준 핸들러 인 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 는 커널 애플리케이션 시작시 disk_log 핸들러로 대체 될 수 있습니다. 아래의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="56e59dc663ec3168b6b7eec38a9c17da04f70aec" translate="yes" xml:space="preserve">
          <source>The default start option &lt;code&gt;{dir,Cwd}&lt;/code&gt; (to run all suites in the current working directory) is used if the function is called with an empty list of options.</source>
          <target state="translated">함수가 빈 옵션 목록으로 호출되면 기본 시작 옵션 &lt;code&gt;{dir,Cwd}&lt;/code&gt; (현재 작업 디렉토리의 모든 스위트를 실행)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8472d25153570bd73936053aa35b2f0053ff73f8" translate="yes" xml:space="preserve">
          <source>The default time limit for a test case is 30 minutes, unless a &lt;code&gt;timetrap&lt;/code&gt; is specified either by the suite-, group-, or test case information function. The timetrap time-out value defined by &lt;code&gt;suite/0&lt;/code&gt; is the value that is used for each test case in the suite (and for the configuration functions &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, and &lt;code&gt;end_per_group/2&lt;/code&gt;). A timetrap value defined by &lt;code&gt;group(GroupName)&lt;/code&gt; overrides one defined by &lt;code&gt;suite()&lt;/code&gt; and is used for each test case in group &lt;code&gt;GroupName&lt;/code&gt;, and any of its subgroups. If a timetrap value is defined by &lt;code&gt;group/1&lt;/code&gt; for a subgroup, it overrides that of its higher level groups. Timetrap values set by individual test cases (by the test case information function) override both group- and suite- level timetraps.</source>
          <target state="translated">&lt;code&gt;timetrap&lt;/code&gt; , 그룹 또는 테스트 케이스 정보 기능 으로 타임 트랩 을 지정 하지 않으면 테스트 케이스의 기본 시간 제한은 30 분 입니다. &lt;code&gt;suite/0&lt;/code&gt; 에 의해 정의 된 타임 트랩 시간 종료 값은 스위트의 각 테스트 케이스 (및 구성 함수 &lt;code&gt;init_per_suite/1&lt;/code&gt; , &lt;code&gt;end_per_suite/1&lt;/code&gt; , &lt;code&gt;init_per_group/2&lt;/code&gt; 및 &lt;code&gt;end_per_group/2&lt;/code&gt; 에 사용되는 값 )입니다. 에 의해 정의 된 값 timetrap &lt;code&gt;group(GroupName)&lt;/code&gt; 에 의해 정의 된 하나 겹쳐 &lt;code&gt;suite()&lt;/code&gt; 와 그룹의 각각의 테스트 케이스에 사용되는 &lt;code&gt;GroupName&lt;/code&gt; , 그것의 서브 그룹 중 어느. timetrap 값이 &lt;code&gt;group/1&lt;/code&gt; 에 의해 정의 된 경우하위 그룹의 경우 상위 그룹의 하위 그룹보다 우선합니다. 개별 테스트 케이스 (테스트 케이스 정보 기능에 의해)에 의해 설정된 타임 트랩 값은 그룹 및 스위트 레벨 타임 트랩을 모두 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b52b358a5f5402f0ac26ce2f8003f427f7c57d17" translate="yes" xml:space="preserve">
          <source>The default time-out is 5000 ms, unless otherwise specified. &lt;code&gt;timeout&lt;/code&gt; defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt;.</source>
          <target state="translated">달리 지정하지 않는 한 기본 시간 제한은 5000ms입니다. &lt;code&gt;timeout&lt;/code&gt; 은 프로세스가 요청에 응답하기를 기다리는 시간을 정의합니다. 프로세스가 응답하지 않으면 함수는 &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="51ff8e06cc37d3f5fbc8359b214e014cbb5552d4" translate="yes" xml:space="preserve">
          <source>The default timeout is infinity</source>
          <target state="translated">기본 시간 초과는 무한대입니다</target>
        </trans-unit>
        <trans-unit id="517719740380d1d0fe303f5c01cd73d6a4f1b6a9" translate="yes" xml:space="preserve">
          <source>The default type (and currently the only type) of crypto algorithm is &lt;code&gt;des3_cbc&lt;/code&gt;, three rounds of DES. The key string is scrambled using &lt;code&gt;erlang:md5/1&lt;/code&gt; to generate the keys used for &lt;code&gt;des3_cbc&lt;/code&gt;.</source>
          <target state="translated">암호화 알고리즘의 기본 유형 (및 현재 유일한 유형)은 3 라운드의 DES 인 &lt;code&gt;des3_cbc&lt;/code&gt; 입니다. 키 문자열은 &lt;code&gt;des3_cbc&lt;/code&gt; 에 사용되는 키를 생성하기 위해 &lt;code&gt;erlang:md5/1&lt;/code&gt; 을 사용하여 스크램블 됩니다.</target>
        </trans-unit>
        <trans-unit id="545949e03721db9053ce25eb33d2946d85caf9f1" translate="yes" xml:space="preserve">
          <source>The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; is integer, not float.</source>
          <target state="translated">세그먼트의 기본 유형은 정수입니다. 기본 유형은 값이 리터럴 인 경우에도 값에 의존하지 않습니다. 예를 들어, &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; 의 기본 유형은 부동이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="9c04943ccaa1784066dde4b82fadc56a0e22b6e6" translate="yes" xml:space="preserve">
          <source>The default unit depends on the the type. For &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt; it is 1. For binary it is 8.</source>
          <target state="translated">기본 단위는 유형에 따라 다릅니다. 들어 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , 그리고 &lt;code&gt;bitstring&lt;/code&gt; 그것은 8 BINARY 1.이다.</target>
        </trans-unit>
        <trans-unit id="55a938cf0dbdbfb06f3894ab3968c86b760e35c4" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If &lt;code&gt;Timeout&lt;/code&gt; is specified and no connection is accepted within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 의 기본값 은 &lt;code&gt;infinity&lt;/code&gt; 입니다. 경우 &lt;code&gt;Timeout&lt;/code&gt; 지정되고 아무 관련이 주어진 시간 내에 접수되지 않습니다, &lt;code&gt;{error, timeout}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="06729acf2bd67efa6a3b5f8c86f4f2fa259ed112" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 의 기본값 은 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79b49abd7127b03f5d3f046367a7810a9be6e9ef" translate="yes" xml:space="preserve">
          <source>The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.</source>
          <target state="translated">Erlang VM에서 두 제한의 기본값은 10,000,000입니다. Erlang의 PCRE는 match 함수가 C 스택에서 재귀를 수행하지 않는 방식으로 컴파일되므로 재귀 한계는 VM의 스택 깊이에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a019fd353ccc57a4984f8ab73e895be35e2ceca" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;code&gt;template&lt;/code&gt; configuration parameter depends on the value of the &lt;code&gt;single_line&lt;/code&gt; and &lt;code&gt;legacy_header&lt;/code&gt; configuration parameters as follows.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 구성 매개 변수 의 기본값 은 다음과 같이 &lt;code&gt;single_line&lt;/code&gt; 및 &lt;code&gt;legacy_header&lt;/code&gt; 구성 매개 변수 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0bf6d99215a41e23b30022357e71e9041cbda827" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;0&lt;/code&gt;, which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per &lt;code&gt;READDIR&lt;/code&gt; request is limited to at most the given value.</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; 이며, 상한이 없음을 의미합니다. 제공되는 경우, &lt;code&gt;READDIR&lt;/code&gt; 요청 당 SFTP 클라이언트에 리턴 된 파일 이름 수는 최대 값으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8eb871dd540b5e77da06600e181f72827240ed7e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;262144&lt;/code&gt;</source>
          <target state="translated">기본값은 &lt;code&gt;262144&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9199a189c47e6bb7d92e1a9dbf9ee3c0844e971b" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;{0,infinity}&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;{0,infinity}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4282a5ade1b153ec0ef3ef75770c03f967209ae" translate="yes" xml:space="preserve">
          <source>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</source>
          <target state="translated">기본값은 RFC 3539에서 요구하는대로입니다.이를 변경하면 테스트 중 오작동 노드를 시뮬레이션하는 데만 사용되는 비표준 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18ca71fb6a22d28ebdfdacf9ed5fe354e1ec6ffe" translate="yes" xml:space="preserve">
          <source>The default value is the &lt;code&gt;public_key&lt;/code&gt; entry in the list returned by &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 이 리턴 한 목록 의 &lt;code&gt;public_key&lt;/code&gt; 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="2af35d2902848146372b486ac1179095a26eda1a" translate="yes" xml:space="preserve">
          <source>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</source>
          <target state="translated">기본값은 초기화되지 않은 항목의 값으로 사용되며 일단 어레이가 생성되면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b459379a9db26d1ded876c98cb594522408f4fb6" translate="yes" xml:space="preserve">
          <source>The default value is: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</source>
          <target state="translated">기본값은 &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="243fb9da1068fdc22926720a51604f4646125511" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;{ssh_file, []}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d73b09c02067144770d80033f5560b2a2552422" translate="yes" xml:space="preserve">
          <source>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; for the behaviour of that module.</source>
          <target state="translated">기본값은 TCP와 같은 스트림 지향 전송에 대한 전송 모듈이 메시지 길이 오류를 복구하지 못할 수 있다는 사실을 반영합니다. 이러한 전송은 메시지 길이 헤더를 사용하여 수신 바이트 스트림을 개별 직경 메시지로 나누어야하기 때문입니다. 길이가 유효하지 않으면 메시지 경계를 다시 검색 할 수있는 신뢰할 수있는 방법이 없어 후속 메시지가 실패 할 수 있습니다. 해당 모듈의 동작에 대해서는 &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="296cd192efc745b8c34964c030037a92790a5853" translate="yes" xml:space="preserve">
          <source>The default value used is normally &lt;code&gt;65536&lt;/code&gt;. However, if the runtime system is able to determine maximum amount of file descriptors that it is allowed to open and this value is larger than &lt;code&gt;65536&lt;/code&gt;, the chosen value will increased to a value larger or equal to the maximum amount of file descriptors that can be opened.</source>
          <target state="translated">사용되는 기본값은 보통 &lt;code&gt;65536&lt;/code&gt; 입니다. 그러나 런타임 시스템이 열 수있는 최대 파일 디스크립터 양을 판별 할 수 &lt;code&gt;65536&lt;/code&gt; 값이 65536 보다 큰 경우 선택된 값은 최대 파일 디스크립터 양보다 크거나 같은 값으로 증가합니다. 열었다.</target>
        </trans-unit>
        <trans-unit id="5e3d6bd0706de8063989ab67ca84fec01864e172" translate="yes" xml:space="preserve">
          <source>The default values are 1 restart per 5 seconds. This was chosen to be safe for most systems, even with deep supervision hierarchies, but you will probably want to tune the settings for your particular use case.</source>
          <target state="translated">기본값은 5 초당 1 회의 재시작입니다. 이는 심층 감독 계층 구조에서도 대부분의 시스템에서 안전하도록 선택되었지만 특정 사용 사례에 맞게 설정을 조정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e004a8abd563009ef32e5cba1400cabe8dffcb" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;connect&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_connect_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 하도록 지정된 옵션의 기본값 은 커널 구성 매개 변수 &lt;code&gt;inet_default_connect_options&lt;/code&gt; 의 영향을받을 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40a15125494e475b38c160cdf12b36e7e3d1c3f9" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;listen&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_listen_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listen&lt;/code&gt; 하도록 지정된 옵션의 기본값 은 커널 구성 매개 변수 &lt;code&gt;inet_default_listen_options&lt;/code&gt; 의 영향을받을 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50fa0bf131c13c670fdcc5fdce169d626f359cef" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;originating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 발견 옵션 의 기본값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cb324b22317eaf8bd729f045fc4512eed8d2afc" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;terminating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 감지 옵션 의 기본값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b5bd661368c7d8e299861344ca3c98352edac6c" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt;. But the send options above, may explicitly be overridden.</source>
          <target state="translated">보내기 옵션의 기본값은 &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt; 의해 얻습니다 . 그러나 위의 전송 옵션은 명시 적으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa1b655582755f5f4811f0eab7ca8a5d9f4319" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by megaco:conn_info(ConnHandle, Item). But the send options above, may explicitly be overridden.</source>
          <target state="translated">보내기 옵션의 기본값은 megaco : conn_info (ConnHandle, Item)에서 가져옵니다. 그러나 위의 전송 옵션은 명시 적으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ebf5b11205a5dd9778e91c6bfcc585a8fc51478" translate="yes" xml:space="preserve">
          <source>The default verbosity is &lt;code&gt;1&lt;/code&gt;. Verbosity &lt;code&gt;0&lt;/code&gt; can also be selected by option &lt;code&gt;nowarn_format&lt;/code&gt;.</source>
          <target state="translated">기본 상세 정보는 &lt;code&gt;1&lt;/code&gt; 입니다. 상세도 &lt;code&gt;0&lt;/code&gt; 도 옵션으로 선택할 수 있습니다 &lt;code&gt;nowarn_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f7ea1b49fdcb48ab2c2517d37ecba5139e4ff8" translate="yes" xml:space="preserve">
          <source>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate and the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; must be set, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">두 노드 사이에 연결이 설정되면 기본값은 다른 모든 가시적 노드도 즉시 연결하는 것입니다. 이런 식으로 항상 완전히 연결된 네트워크가 있습니다. 쿠키가 다른 노드가있는 경우이 방법이 부적절하고 명령 행 플래그 &lt;code&gt;-connect_all false&lt;/code&gt; 를 설정해야합니다 . ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cf210e7ecc7b461b7955d0d98ee29107a5a6b0b" translate="yes" xml:space="preserve">
          <source>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &amp;gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</source>
          <target state="translated">기본값입니다. ISO Latin-1 범위의 문자 만 인쇄 가능한 것으로 간주 될 수 있습니다. 즉, 코드 포인트가 255보다 큰 문자는 인쇄 할 수없는 것으로 간주되며 이러한 문자가 포함 된 목록은 도구의 텍스트 문자열이 아닌 정수 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="11fa3688f9aa1dc5e88e515adb5d88b7a205fe35" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since earlier versions of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlMessage&lt;/code&gt; 의 정의는 이전 버전의 &lt;code&gt;Erl_Interface&lt;/code&gt; 이후로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6fdae1ac6fb499a05429a1e07e8362960f5b8b56" translate="yes" xml:space="preserve">
          <source>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</source>
          <target state="translated">사용중인 스케줄러의 정의는 유휴 상태가 아니고 프로세스 또는 포트를 스케줄 (선택)하지 않을 때입니다.</target>
        </trans-unit>
        <trans-unit id="82ba3b05846ab652707aa41300a0f8920d31d2e5" translate="yes" xml:space="preserve">
          <source>The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</source>
          <target state="translated">기능 교환시 Origin-Host에 의해 식별 된 서비스가 동일한 피어에 대한 여러 전송 연결을 허용하는 정도.</target>
        </trans-unit>
        <trans-unit id="995215813ca9fa0e2bcd7a40357169c4691820c6" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">추적 메시지 전달 ( &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;seq_trace(3)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; 생성 )은 시스템의 다른 이벤트와 비교하여 타임 라인에서 이동합니다. &lt;code&gt;Tracee&lt;/code&gt; 가 실행에서 특정 지점을 통과 했다는 것을 알고 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 시점까지의 이벤트에 해당하는 모든 추적 메시지가 추적 프로그램에 도달 한 시점을 알고 싶다면 erlang : trace_delivered (Tracee)를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef74e5139b7ce6e4f98a4baef24c6182968b430c" translate="yes" xml:space="preserve">
          <source>The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the &lt;code&gt;makedep&lt;/code&gt; option.</source>
          <target state="translated">의존성은 일반적인 컴파일 프로세스에 대한 부작용으로 생성됩니다. 이것은 오브젝트 파일도 생성됨을 의미합니다. 이 옵션은 &lt;code&gt;makedep&lt;/code&gt; 옵션보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="d1ab3d1ea275bdf26541729c8fac923c58fe1c95" translate="yes" xml:space="preserve">
          <source>The dependency graph windows are launched from the file menu in the system window. The graph depicts all included and derived applications/modules and their dependencies.</source>
          <target state="translated">종속성 그래프 창은 시스템 창의 파일 메뉴에서 시작됩니다. 그래프에는 포함 및 파생 된 모든 응용 프로그램 / 모듈 및 해당 종속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a97d6fbaa7c8cc7934aab7b5d9a9bb87b6b518f" translate="yes" xml:space="preserve">
          <source>The described durability feature does not entirely apply to situations where &lt;code&gt;Mnesia&lt;/code&gt; is configured as a &quot;pure&quot; primary memory database.</source>
          <target state="translated">설명 된 내구성 기능은 &lt;code&gt;Mnesia&lt;/code&gt; 가 &quot;순수한&quot;기본 메모리 데이터베이스로 구성된 상황에는 전적으로 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c5fd3c33ad96d6f9da0b92a6b9de73850c0f031c" translate="yes" xml:space="preserve">
          <source>The described syntax can also be used in test specifications to change group properties at the time of execution, without having to edit the test suite. For more information, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">설명 된 구문은 테스트 스위트를 편집하지 않고도 실행시 그룹 특성을 변경하기 위해 테스트 스펙에서 사용될 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 실행 및 결과 분석 섹션의 테스트 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="086c0b30f28f757ab34cbfdd1e7d1db76083baee" translate="yes" xml:space="preserve">
          <source>The description is based on &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt;, which is not to be further updated.</source>
          <target state="translated">설명은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt; 기반으로 하며 더 이상 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b29537c79e1bc001111fcb298cafeaf2c947455f" translate="yes" xml:space="preserve">
          <source>The descriptions of the options uses the &lt;code&gt;Erlang Type Language&lt;/code&gt; with explaining text.</source>
          <target state="translated">옵션 설명은 설명 텍스트와 함께 &lt;code&gt;Erlang Type Language&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="45a17206933877eeb5bf9c5379a4ed51695a5147" translate="yes" xml:space="preserve">
          <source>The destination of these log events was configured by &lt;code&gt;SASL configuration parameters&lt;/code&gt;.</source>
          <target state="translated">이러한 로그 이벤트의 대상은 &lt;code&gt;SASL configuration parameters&lt;/code&gt; 로 구성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1700577536e62effc25b554cb01dfedd3d5fe8bb" translate="yes" xml:space="preserve">
          <source>The details of finding other nodes (that is, talking to &lt;code&gt;epmd&lt;/code&gt; or something similar)</source>
          <target state="translated">다른 노드 찾기에 대한 세부 사항 (즉, &lt;code&gt;epmd&lt;/code&gt; 또는 이와 유사한 항목과 통신)</target>
        </trans-unit>
        <trans-unit id="8904690d17dfc4476f5a61b68a154f7e139b04e4" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 명령 프로그램 &lt;code&gt;openssl&lt;/code&gt; 뿐만 아니라 헤더 파일을 포함한 OpenSSL 개발 패키지가 필요합니다 . OpenSSL 버전 0.9.8 이상이 필요합니다. &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt; 에서 자세한 내용을 읽고 다운로드 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d180f092b7b3bd940337d54bfa93d4b66eb9f08" translate="yes" xml:space="preserve">
          <source>The diameter application includes five dictionary modules corresponding to applications defined in section 2.4 of RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; and &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; for the Diameter Common Messages application with application identifier 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (for RFC 3588) and &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; for the Diameter Base Accounting application with application identifier 3 and &lt;code&gt;diameter_gen_relay&lt;/code&gt; the Relay application with application identifier 0xFFFFFFFF.</source>
          <target state="translated">직경 애플리케이션 다섯 개 사전 RFC 6733의 섹션 2.4에 정의 된 어플리케이션에 대응하는 모듈을 포함 &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; 및 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 어플리케이션 식별자가 0 인 직경 일반 메시지 애플리케이션을 &lt;code&gt;diameter_gen_accounting&lt;/code&gt; 및 (RFC 3588에 대해) &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; 애플리케이션 식별자 (3)과 함께 직경베이스 회계 애플리케이션 및 &lt;code&gt;diameter_gen_relay&lt;/code&gt; 애플리케이션 식별자 0xFFFFFFFF로 함께 중계 어플리케이션.</target>
        </trans-unit>
        <trans-unit id="55ad411fdd3feccef9ab5e2a70e1c6ecf0dda6f6" translate="yes" xml:space="preserve">
          <source>The diameter application is an implementation of the Diameter protocol as defined by RFC 6733. It supports arbitrary Diameter applications by way of a &lt;strong&gt;dictionary&lt;/strong&gt; interface that allows messages and AVPs to be defined and input into diameter as configuration. It has support for all roles defined in the RFC: client, server and agent. This chapter provides a short overview of the application.</source>
          <target state="translated">직경 응용 프로그램은 RFC 6733에 정의 된대로 직경 프로토콜을 구현 한 것입니다. &lt;strong&gt;사전&lt;/strong&gt; 인터페이스를 통해 메시지 및 AVP를 정의하고 구성으로 직경에 입력 할 수 있는 임의의 직경 응용 프로그램을 지원 합니다. RFC에 정의 된 모든 역할 (클라이언트, 서버 및 에이전트)을 지원합니다. 이 장에서는 응용 프로그램에 대한 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b44b3ae3e6de975127d9868877e61eebf74c5fa6" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before calling most functions in this module.</source>
          <target state="translated">이 모듈에서 대부분의 기능을 호출하기 전에 직경 적용을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="5970544b2f23768c3400e92a3796dc5f84073d7d" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling &lt;code&gt;start/0&lt;/code&gt; explicitly.</source>
          <target state="translated">서비스를 시작하기 전에 직경 적용을 시작해야합니다. 프로덕션 시스템에서 이는 일반적으로 &lt;code&gt;start/0&lt;/code&gt; 을 명시 적으로 호출하지 않고 부트 파일로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d87148c3c9af3d9845486aa30c973c1b2043ba3" translate="yes" xml:space="preserve">
          <source>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's &lt;code&gt;peer_up/3&lt;/code&gt; callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</source>
          <target state="translated">직경 적용은 피어와 CER / CEA를 교환하는 책임이 있습니다. 기능 교환이 성공적으로 완료되면 서비스는 각 관련 애플리케이션 모듈의 &lt;code&gt;peer_up/3&lt;/code&gt; 콜백을 호출 한 후 호출자가 전송을 통해 피어와 직경 메시지를 교환 할 수 있습니다. 이 서비스는 CER / CEA 외에도 DWR / DPA뿐만 아니라 RFC 3539에 의해 요구되고 DWR / DWA의 처리를 책임집니다.</target>
        </trans-unit>
        <trans-unit id="fb2713bf78bad945032228e7d72a8fff3c2317e0" translate="yes" xml:space="preserve">
          <source>The diameter user does not need to call functions here explicitly when sending and receiving messages using &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; and the callback interface documented in &lt;code&gt;diameter_app(3)&lt;/code&gt;: diameter itself provides encode/decode as a consequence of configuration passed to &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, and the results may differ from those returned by the functions documented here, depending on configuration.</source>
          <target state="translated">Diameter 사용자는 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;diameter_app(3)&lt;/code&gt; 설명 된 콜백 인터페이스를 사용하여 메시지를 보내고받을 때 여기에서 명시 적으로 함수를 호출 할 필요가 없습니다 . diameter 자체는 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 전달 된 구성의 결과로 인코딩 / 디코딩을 제공합니다 . 2 , 결과는 구성에 따라 여기에 설명 된 기능에 의해 반환 된 것과 다를 수있다.</target>
        </trans-unit>
        <trans-unit id="2251e3cdeb76f922995ac0b63ebf88f13a0667db" translate="yes" xml:space="preserve">
          <source>The diameterc utility is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter required to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">diameterc 유틸리티는 직경 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 을 Erlang 소스로 컴파일하는 데 사용됩니다 . 결과 소스는 사전의 메시지와 AVP를 인코딩하고 디코딩하는 데 필요한 인터페이스 직경을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a8b611f53150beb161ae68d1baa02e238a69d7fe" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기에 의해 선택된 사전은 팽창 함수 호출에 의해 리턴되거나 발생 된 Adler 값으로부터 결정될 수있다. 압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( deflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="dc7c7b0117c79bf085087df0d9077cbcde71b86c" translate="yes" xml:space="preserve">
          <source>The dictionary interface documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; provides extensibility, allowing the user to defined new AVPs, commands, and applications. Ready dictionaries are provided for the RFC 6733 common message, base accounting, and relay applications, as well as for RFC 7683, Diameter Overload Indicator Conveyance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서화 된 사전 인터페이스 는 확장 성을 제공하여 사용자가 새로운 AVP, 명령 및 응용 프로그램을 정의 할 수 있도록합니다. RFC 6733 공통 메시지, 기본 회계 및 릴레이 응용 프로그램뿐만 아니라 RFC 7683, 직경 과부하 표시기 전송에 대한 준비 사전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="569d4e7fc1379c78daae74de968aa2107c8de266" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; on one hand, and &lt;code&gt;ordered_set&lt;/code&gt; on the other, regarding the fact that &lt;code&gt;ordered_set&lt;/code&gt; view keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt; whereas the other table types regard them equal only when they &lt;strong&gt;match&lt;/strong&gt;, holds for &lt;code&gt;lookup_element/3&lt;/code&gt;.</source>
          <target state="translated">차이 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 및 &lt;code&gt;duplicate_bag&lt;/code&gt; 한편, 및 &lt;code&gt;ordered_set&lt;/code&gt; 사실에 관한 다른 한편, &lt;code&gt;ordered_set&lt;/code&gt; 동일로보기 버튼들이 &lt;strong&gt;동일한 비교&lt;/strong&gt; 다른 테이블 유형들이 언제 그들 만 동일 간주 반면 &lt;strong&gt;일치&lt;/strong&gt; 를 위해 보유 &lt;code&gt;lookup_element/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="623ffdc435a2f724f0836bec7cc8ec30bc41c15a" translate="yes" xml:space="preserve">
          <source>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</source>
          <target state="translated">의미 적 객체 (개별 &quot;cons&quot;및 &quot;nil&quot;용어로 구성됨)로서의 목록과 목록을 표시하기위한 다양한 구문 형태의 차이는 처음에는 어리둥절 할 수 있습니다. 이 모듈은 구문 표현의 정확한 제어뿐만 아니라 단점과 헤드 / 테일 연산의 관점에서 간단한 구성과 해체를위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da1728bb07e837f250209bb055d7409170953dd6" translate="yes" xml:space="preserve">
          <source>The difference between the &lt;code&gt;config&lt;/code&gt; terms above is that with &lt;code&gt;ConfigDir&lt;/code&gt;, &lt;code&gt;ConfigBaseNames&lt;/code&gt; is a list of base names, that is, without directory paths. &lt;code&gt;ConfigFiles&lt;/code&gt; must be full names, including paths. For example, the following two terms have the same meaning:</source>
          <target state="translated">사이의 차이 &lt;code&gt;config&lt;/code&gt; 조건은 상기와이다 &lt;code&gt;ConfigDir&lt;/code&gt; , &lt;code&gt;ConfigBaseNames&lt;/code&gt; 는 디렉토리 경로없이 인베이스 이름들의 목록이다. &lt;code&gt;ConfigFiles&lt;/code&gt; 은 경로를 포함한 전체 이름이어야합니다. 예를 들어 다음 두 용어의 의미는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4f869b97b89ad5b7b934ce2b75aa574db5f22948" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is in how they get the modules to check. &lt;code&gt;versions1&lt;/code&gt; uses the app-file and &lt;code&gt;versions2&lt;/code&gt; uses the function &lt;code&gt;application:get_key&lt;/code&gt;.</source>
          <target state="translated">두 기능의 차이점은 모듈을 확인하는 방법에 있습니다. &lt;code&gt;versions1&lt;/code&gt; 은 app-file을 사용 하고 &lt;code&gt;versions2&lt;/code&gt; 는 &lt;code&gt;application:get_key&lt;/code&gt; 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="633f35639fdb5cc1cb10fd8f4689bf3336703581" translate="yes" xml:space="preserve">
          <source>The difference between these functions is the order the table is accessed for &lt;code&gt;ordered_set&lt;/code&gt; tables. For other table types the functions are equivalent.</source>
          <target state="translated">이 함수의 차이점은 &lt;code&gt;ordered_set&lt;/code&gt; 테이블에 대해 테이블에 액세스하는 순서 입니다. 다른 테이블 유형의 경우 기능이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="293fb4be14373398bacd278126f271ff3f4aab95" translate="yes" xml:space="preserve">
          <source>The difference between using the macros and the exported functions is that macros add location (originator) information to the metadata, and performs lazy evaluation by wrapping the logger call in a case statement, so it is only evaluated if the log level of the event passes the primary log level check.</source>
          <target state="translated">매크로를 사용하는 것과 내 보낸 함수의 차이점은 매크로는 메타 데이터에 위치 (생성자) 정보를 추가하고 로거 호출을 case 문에 랩핑하여 지연 평가를 수행하므로 이벤트의 로그 레벨이 통과하는 경우에만 평가된다는 것입니다 기본 로그 수준 확인</target>
        </trans-unit>
        <trans-unit id="9bd33d3347fbec04e6dd5bced0f65f041be1e03c" translate="yes" xml:space="preserve">
          <source>The difference here is that a check is made for two keys in each map argument. The other keys are ignored.</source>
          <target state="translated">차이점은 각 맵 인수에서 두 개의 키를 검사한다는 것입니다. 다른 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="57afc2a6da2d7ad1a93ff6f446c9b773c487ccf9" translate="yes" xml:space="preserve">
          <source>The difference is the same as between &lt;code&gt;=:=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">차이점은 &lt;code&gt;=:=&lt;/code&gt; 과 &lt;code&gt;==&lt;/code&gt; 의 경우와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="37953effd4c1eb8de7eafd4f2558c81bd077904b" translate="yes" xml:space="preserve">
          <source>The different amounts of memory that are summed are &lt;strong&gt;not&lt;/strong&gt; gathered atomically, which introduces an error in the result.</source>
          <target state="translated">합산 된 다른 메모리 양은 원자 적으로 수집 &lt;strong&gt;되지 않으므로&lt;/strong&gt; 결과에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="63548572b896ecd0cf28068a1070f068efa94f1e" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; to load the MIB, and &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">다른 애플리케이션은 MIB를 에이전트에로드하기 위해 다른 전략을 사용합니다. 일부 MIB 구현은 코드 전용이며 다른 MIB 구현은 서버가 필요합니다. 코드 전용 MIB 구현에서 사용되는 한 가지 방법은 사용자가 &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; 와 같은 함수를 호출 하여 MIB를로드하고 &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; 와 같은 함수를 호출 하여 MIB 를 언로드하는 것입니다. 각 MIB를로드하는 방법에 대한 설명은 각 응용 프로그램의 설명서 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b79b82512ebbf07ebe9d9f10fb15d9e8e743cedd" translate="yes" xml:space="preserve">
          <source>The different options that can be given to &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; 에 부여 할 수있는 다른 옵션 .</target>
        </trans-unit>
        <trans-unit id="c7a06445034a6453f0f6ebe99a200207183eacb6" translate="yes" xml:space="preserve">
          <source>The different queries are described in section &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 쿼리는 &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc4891f4df1692cd0b3f6e8badc0320a795dc5b" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">스레드가있을 수있는 여러 가지 상태. 자세한 내용은 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59070d2c07904f6e20fde995a37ca6d79f115caa" translate="yes" xml:space="preserve">
          <source>The different trace tags that the tracer is called with. Each trace tag is described in detail in &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추적 프로그램이 호출되는 다른 추적 태그 각 추적 태그는 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="26366e48ea2a96c9fc5d9a43d23aaffa5017f9cd" translate="yes" xml:space="preserve">
          <source>The different types are as follows:</source>
          <target state="translated">다른 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33105c1c6606db02bff579f3c5759de25bdebf48" translate="yes" xml:space="preserve">
          <source>The different types of schedulers handle specific types of jobs. Every job is assigned to a specific scheduler type. Jobs can migrate between different schedulers of the same type, but never between schedulers of different types. This fact has to be taken under consideration when evaluating the result returned.</source>
          <target state="translated">다른 유형의 스케줄러는 특정 유형의 작업을 처리합니다. 모든 작업은 특정 스케줄러 유형에 지정됩니다. 작업은 동일한 유형의 다른 스케줄러간에 마이그레이션 할 수 있지만 다른 유형의 스케줄러 간에는 마이그레이션 할 수 없습니다. 반환 된 결과를 평가할 때이 사실을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="1be30a2a4e12fc360bee8dc49ed629e5a73999d2" translate="yes" xml:space="preserve">
          <source>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</source>
          <target state="translated">서로 다른 값은 서로 다음과 같은 관계가 있습니다. 대문자로 시작하는 값은 결과의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="27f3bb8909ba5f23310f5128f455bc5958825585" translate="yes" xml:space="preserve">
          <source>The digraph can be read and modified by the creating process only.</source>
          <target state="translated">이 digraph는 작성 프로세스에 의해서만 읽고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5490f515ffc9d05efae42bd4eb4b5cd4c506605c" translate="yes" xml:space="preserve">
          <source>The digraph is to be kept &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이중 음자는 유지 될 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08c044f6070f82e882ec6b0eabc539f770d3dd32" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-error(Term)&lt;/code&gt; causes a compilation error.</source>
          <target state="translated">&lt;code&gt;-error(Term)&lt;/code&gt; 지시문 은 컴파일 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b3797b9e1d8ee2883c9f63d0a42a95ca4d06540e" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-warning(Term)&lt;/code&gt; causes a compilation warning.</source>
          <target state="translated">&lt;code&gt;-warning(Term)&lt;/code&gt; 지시문 은 컴파일 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="58617ed5f0889f1d1f3277ea479ef4c02a22c0a7" translate="yes" xml:space="preserve">
          <source>The directories given by the &lt;code&gt;include&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 옵션으로 제공된 디렉토리</target>
        </trans-unit>
        <trans-unit id="1f52da4640ac6f1c489638d9eafbfb94f7337064" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;-I&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">&lt;code&gt;-I&lt;/code&gt; 옵션을 사용하여 지정된 디렉토리 ; 마지막으로 지정된 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="071745beb88d646a425661fabb7b2b140020baaf" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;i&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">옵션 &lt;code&gt;i&lt;/code&gt; 를 사용하여 지정된 디렉토리 ; 마지막으로 지정된 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="be6fba73ebc340991bdfb6820c1ebc97ba0e0651" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;Path&lt;/code&gt;does not exist.</source>
          <target state="translated">디렉토리 &lt;code&gt;Path&lt;/code&gt; 가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bccd89dc32dbb0c503ff0753756340f2c3e005e" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 디렉토리를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acc2f12b5fc8219c0bfb75133fa338329e4cc3b0" translate="yes" xml:space="preserve">
          <source>The directory does not exist.</source>
          <target state="translated">디렉토리가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="117b6acef024fb182d6e7698c7419f59fe7b75af" translate="yes" xml:space="preserve">
          <source>The directory for (1) back-up copy and (2) Erlang-specific configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 에 대한 (1) 백업 사본 및 (2) Erlang 특정 구성 파일의 디렉토리</target>
        </trans-unit>
        <trans-unit id="339f3fbc63ee87a760e5d5881f1be19ceac96fd2" translate="yes" xml:space="preserve">
          <source>The directory is not empty.</source>
          <target state="translated">디렉토리가 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7febdc58b57a39ad1e446e02f6b42469827aa2db" translate="yes" xml:space="preserve">
          <source>The directory listing also contains one &lt;code&gt;.DAT&lt;/code&gt; file, which contains the schema itself, contained in the &lt;code&gt;schema.DAT&lt;/code&gt; file. The &lt;code&gt;DAT&lt;/code&gt; files are indexed files, and it is efficient to insert and search for records in these files with a specific key. The &lt;code&gt;.DAT&lt;/code&gt; files are used for the schema and for &lt;code&gt;disc_only_copies&lt;/code&gt; tables. The &lt;code&gt;Mnesia&lt;/code&gt; data files are currently implemented in the standard library module &lt;code&gt;dets&lt;/code&gt; in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">디렉토리 목록에는 &lt;code&gt;schema.DAT&lt;/code&gt; 파일 에 포함 된 스키마 자체를 포함하는 하나의 &lt;code&gt;.DAT&lt;/code&gt; 파일 도 포함되어 있습니다 . &lt;code&gt;DAT&lt;/code&gt; 의 파일은 인덱스 파일이며, 삽입하고 특정 키 이러한 파일의 레코드를 검색 할 효율적입니다. &lt;code&gt;.DAT&lt;/code&gt; 의 파일은 스키마 및 사용되는 &lt;code&gt;disc_only_copies&lt;/code&gt; 의 테이블. &lt;code&gt;Mnesia&lt;/code&gt; 의 데이터 파일은 현재 표준 라이브러리 모듈에서 구현 &lt;code&gt;dets&lt;/code&gt; 에서 &lt;code&gt;STDLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc8511921c9959d184fd92a30bcce8e510e914f" translate="yes" xml:space="preserve">
          <source>The directory structure for the code installed by the release handler from a release package is as follows:</source>
          <target state="translated">릴리스 패키지에서 릴리스 핸들러가 설치 한 코드의 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a42562d2ee99aac69e248e9c1d20b489a29d934f" translate="yes" xml:space="preserve">
          <source>The directory to read the application from. This parameter can be used to point out a specific location to fetch the application from. This is useful for instance if the parent directory for some reason is no good as a library directory on system level.</source>
          <target state="translated">응용 프로그램을 읽을 디렉토리입니다. 이 매개 변수는 응용 프로그램을 가져올 특정 위치를 가리키는 데 사용할 수 있습니다. 이것은 어떤 이유로 상위 디렉토리가 시스템 레벨의 라이브러리 디렉토리로 좋지 않은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d7bfc486e65b60f6f17e8c030cc98aaf1f5887ba" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are put can be chosen explicitly. The default, implied by value &lt;code&gt;&quot;&quot;&lt;/code&gt;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by &lt;code&gt;file:get_cwd()&lt;/code&gt; is used instead. The names of temporary files are derived from the Erlang nodename (&lt;code&gt;node()&lt;/code&gt;), the process identifier of the current Erlang emulator (&lt;code&gt;os:getpid()&lt;/code&gt;), and a unique integer (&lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt;). A typical name is &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt;, where &lt;code&gt;17&lt;/code&gt; is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught &lt;code&gt;EXIT&lt;/code&gt; signal occurs.</source>
          <target state="translated">임시 파일이있는 디렉토리를 명시 적으로 선택할 수 있습니다. &lt;code&gt;&quot;&quot;&lt;/code&gt; 값으로 암시되는 기본값 은 임시 파일을 정렬 된 출력 파일과 동일한 디렉토리에 두는 것입니다. 출력이 함수 인 경우 (아래 참조) &lt;code&gt;file:get_cwd()&lt;/code&gt; 반환 한 디렉토리 가 대신 사용됩니다. 임시 파일 이름은 Erlang 노드 이름 ( &lt;code&gt;node()&lt;/code&gt; ), 현재 Erlang 에뮬레이터의 프로세스 식별자 ( &lt;code&gt;os:getpid()&lt;/code&gt; ) 및 고유 한 정수 ( &lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt; )에서 파생 됩니다. 일반적인 이름은 &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt; 이며 여기서 &lt;code&gt;17&lt;/code&gt; 은 시퀀스 번호입니다. 기존 파일을 덮어 씁니다. 포착되지 않은 &lt;code&gt;EXIT&lt;/code&gt; 가 아니면 임시 파일이 삭제됩니다. 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26b2546fb62728f487df23d7a64fc6038e2f04cd" translate="yes" xml:space="preserve">
          <source>The directory where the compiler is to place the output files. Defaults to the current working directory.</source>
          <target state="translated">컴파일러가 출력 파일을 배치 할 디렉토리입니다. 현재 작업 디렉토리가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="23d4b2c59c247070b6160ec438b2f4a12342bdf0" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the agent.</source>
          <target state="translated">구성 파일이있는 디렉토리는 에이전트에 매개 변수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f35f2fdf2411bb1709c721e727448cb07cb8e62e" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the manager.</source>
          <target state="translated">구성 파일이있는 디렉토리는 관리자에게 매개 변수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="57ac9409f64c817119b2a62c56ec2039ee44af45" translate="yes" xml:space="preserve">
          <source>The directory where the module is being compiled</source>
          <target state="translated">모듈이 컴파일되는 디렉토리</target>
        </trans-unit>
        <trans-unit id="a823ed8e05f4f19f697c128e1d3b1f2bf689cda5" translate="yes" xml:space="preserve">
          <source>The disconnect may either be made explicitly by a call to megaco:disconnect/2 or implicitly when the control process of the connection dies.</source>
          <target state="translated">연결 해제는 megaco : disconnect / 2에 대한 호출에 의해 명시 적으로 작성되거나 연결 제어 프로세스가 종료 될 때 내재적으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ffbc4f5819bc4c210bf785d2c507c9b376119c7" translate="yes" xml:space="preserve">
          <source>The discovery module may implement the following callback:</source>
          <target state="translated">감지 모듈은 다음 콜백을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d184d395f04b053ca8e8de39c92096a4dfaac1" translate="yes" xml:space="preserve">
          <source>The discovery module needs to implement the same API as the regular &lt;code&gt;EPMD module&lt;/code&gt;. However, instead of communicating with EPMD you can connect to any service to find out connection details of other nodes. A discovery module is enabled by setting &lt;code&gt;-epmd_module&lt;/code&gt; when starting erlang. The discovery module must implement the following callbacks:</source>
          <target state="translated">검색 모듈은 일반 &lt;code&gt;EPMD module&lt;/code&gt; 과 동일한 API를 구현해야 합니다 . 그러나 EPMD와 통신하는 대신 모든 서비스에 연결하여 다른 노드의 연결 세부 사항을 찾을 수 있습니다. erlang을 시작할 때 &lt;code&gt;-epmd_module&lt;/code&gt; 을 설정하여 감지 모듈을 사용할 수 있습니다. 감지 모듈은 다음 콜백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="99d7db3ae01fbb644d3dec6e8da4ab75b95c8848" translate="yes" xml:space="preserve">
          <source>The disk log process is not terminated as long as there are owners or users of the log. All owners must close the log, possibly by terminating. Also, any other process, not only the processes that have opened the log anonymously, can decrement the &lt;code&gt;users&lt;/code&gt; counter by closing the log. Attempts to close a log by a process that is not an owner are ignored if there are no users.</source>
          <target state="translated">로그의 소유자 또는 사용자가있는 한 디스크 로그 프로세스는 종료되지 않습니다. 모든 소유자는 종료하여 로그를 닫아야합니다. 또한 익명으로 로그를 연 프로세스뿐만 아니라 다른 프로세스도 로그 를 닫아 &lt;code&gt;users&lt;/code&gt; 카운터를 줄일 수 있습니다 . 사용자가없는 경우 소유자가 아닌 프로세스에서 로그를 닫으려는 시도는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="170e47f1105c3410c9337c315483a1099114bce2" translate="yes" xml:space="preserve">
          <source>The disk space required by Solaris can be minimized by using the Core User support installation. It requires about 80 MB of disk space. This installs only the minimum software required to boot and run Solaris. The disk space can be further reduced by deleting unnecessary individual files. However, unless disk space is a critical resource the effort required and the risks involved cannot be justified.</source>
          <target state="translated">핵심 사용자 지원 설치를 사용하여 Solaris에 필요한 디스크 공간을 최소화 할 수 있습니다. 약 80MB의 디스크 공간이 필요합니다. Solaris를 부트하고 실행하는 데 필요한 최소 소프트웨어 만 설치합니다. 불필요한 개별 파일을 삭제하여 디스크 공간을 더욱 줄일 수 있습니다. 그러나 디스크 공간이 중요한 리소스가 아니라면 필요한 노력과 관련된 위험을 정당화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5252445bcfdf0c4e9a0db2f6abd1c5ab396bbcae" translate="yes" xml:space="preserve">
          <source>The distribution does this implicitly when sending messages across node boundaries.</source>
          <target state="translated">분배는 노드 경계를 통해 메시지를 보낼 때이를 암시 적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="54a389857119d0e949a971f667eeb2bc4135d70c" translate="yes" xml:space="preserve">
          <source>The distribution header format is as follows:</source>
          <target state="translated">배포 헤더 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7207d53f2df6dd951040b5a96c6e6f572abc8fba" translate="yes" xml:space="preserve">
          <source>The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">배포 헤더에는 원자 캐시 참조 섹션 만 포함되어 있지만 나중에 추가 정보를 포함 할 수 있습니다. 배포 헤더는 외부 형식에서 하나 이상의 Erlang 용어 앞에옵니다. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; 설명서 에서 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2379df6378023fbabe88db9769e48826a29d56a" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">분배 메커니즘은 TCP / IP 소켓을 사용하여 구현됩니다. 대체 운송 업체를 구현하는 방법은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62295fb74df53713cac7805be082a69085ad9fa7" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is not backward compatible by default. This flag sets the emulator in compatibility mode with an earlier Erlang/OTP release &lt;code&gt;ReleaseNumber&lt;/code&gt;. The release number must be in the range &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt;. This limits the emulator, making it possible for it to communicate with Erlang nodes (as well as C- and Java nodes) running that earlier release.</source>
          <target state="translated">배포 메커니즘은 기본적으로 이전 버전과 호환되지 않습니다. 이 플래그는 에뮬레이터를 이전 Erlang / OTP 릴리스 &lt;code&gt;ReleaseNumber&lt;/code&gt; 와의 호환성 모드로 설정합니다 . 릴리스 번호는 &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt; 범위에 있어야합니다 . 이로 인해 에뮬레이터가 제한되어 이전 릴리스를 실행하는 Erlang 노드 (C 및 Java 노드)와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cd5b036f8947d038790d0e5bd184b32b79cd32e" translate="yes" xml:space="preserve">
          <source>The distribution module expose an API that &lt;code&gt;net_kernel&lt;/code&gt; call in order to manage connections to other nodes. The module name should have the suffix &lt;code&gt;_dist&lt;/code&gt;.</source>
          <target state="translated">배포 모듈 은 다른 노드에 대한 연결을 관리하기 위해 &lt;code&gt;net_kernel&lt;/code&gt; 이 호출 하는 API를 노출합니다 . 모듈 이름의 접미사 &lt;code&gt;_dist&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9731f94ba0606fc85b916d2adf784a2aceb2f3dc" translate="yes" xml:space="preserve">
          <source>The distribution module for SSL/TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">SSL / TLS 용 분배 모듈의 이름은 &lt;code&gt;inet_tls_dist&lt;/code&gt; 이며 명령 행에서 &lt;code&gt;-proto_dist&lt;/code&gt; 옵션을 사용하여 지정됩니다 . &lt;code&gt;-proto_dist&lt;/code&gt; 의 인수 는 접미 부 &lt;code&gt;_dist&lt;/code&gt; 가 없는 모듈 이름 입니다. 따라서이 분배 모듈은 명령 행에서 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aeea032ca4cef8b317244fbb44d9a32ae5f5898" translate="yes" xml:space="preserve">
          <source>The distribution protocol can be divided into four parts:</source>
          <target state="translated">배포 프로토콜은 다음 네 부분으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1a3d4e65478d9f5f71da059cfc38ed2c96b5ba" translate="yes" xml:space="preserve">
          <source>The distribution starts at boot if all the above is specified and an &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; flag is present at the command line.</source>
          <target state="translated">위의 모든 사항이 지정되고 명령 줄에 &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; 플래그가 있으면 배포시 부팅이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b01c03572e2e4aaafce0356c4411e135ed1f526" translate="yes" xml:space="preserve">
          <source>The document returned by &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; and &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. The type of the returned record depends on the value of the document option passed to the function.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 및 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 에서 리턴 한 문서 . 리턴 된 레코드의 유형은 함수에 전달 된 문서 옵션의 값에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="00d8e9f113e0a458f5df4e4708996df9d6090e13" translate="yes" xml:space="preserve">
          <source>The documentation can be installed either using the &lt;code&gt;install-docs&lt;/code&gt; target, or using the &lt;code&gt;release_docs&lt;/code&gt; target.</source>
          <target state="translated">&lt;code&gt;install-docs&lt;/code&gt; 대상을 사용하거나 &lt;code&gt;release_docs&lt;/code&gt; 대상을 사용하여 문서를 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5149c903e3309937ac98a7bf77705046a7abe19b" translate="yes" xml:space="preserve">
          <source>The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</source>
          <target state="translated">달러 문자는 현재 일치 지점이 제목 문자열의 끝에 있거나 문자열 끝의 줄 바꿈 바로 앞에있는 경우에만 참인 어설 션입니다 (기본적으로). 그러나 개행과 일치하지 않습니다. 일부 대안이 포함 된 경우 달러는 패턴의 마지막 문자 일 필요는 없지만 그것이 나타나는 분기의 마지막 항목이어야합니다. 문자 클래스에서 달러는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0fbbfd153dd0451d5221908c40847d88ba4f1d83" translate="yes" xml:space="preserve">
          <source>The domain of a family is called the &lt;strong&gt;index set&lt;/strong&gt;, and the range is called the &lt;strong&gt;indexed set&lt;/strong&gt;.</source>
          <target state="translated">패밀리의 도메인을 &lt;strong&gt;인덱스 세트&lt;/strong&gt; 라고하며 범위를 &lt;strong&gt;인덱스 세트&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="5952578f1a7b818cc8da70c30b5eb53cf1931cf6" translate="yes" xml:space="preserve">
          <source>The dot metacharacter</source>
          <target state="translated">도트 메타 문자</target>
        </trans-unit>
        <trans-unit id="0c39bb4aef52ace658cb63c48687e207b1ca1ec6" translate="yes" xml:space="preserve">
          <source>The downgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;downgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 다운 그레이드 스크립트를 평가할 수 있습니다 . 대신 &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋지만이 기능 ( &lt;code&gt;downgrade_script&lt;/code&gt; )은 스크립트의 내용을 검사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a9b899e09f583022f6155a633fa34d496d384c3" translate="yes" xml:space="preserve">
          <source>The downside of an enforced transaction recovery decision is that the decision can be incorrect, because of insufficient information about the recovery decisions from the other nodes. This can result in an inconsistent database where &lt;code&gt;Mnesia&lt;/code&gt; has committed the transaction on some nodes but terminated it on others.</source>
          <target state="translated">강제 트랜잭션 복구 결정의 단점은 다른 노드의 복구 결정에 대한 정보가 충분하지 않기 때문에 결정이 잘못 될 수 있다는 것입니다. 이로 &lt;code&gt;Mnesia&lt;/code&gt; 가 일부 노드에서 트랜잭션을 커밋했지만 다른 노드에서 트랜잭션을 종료 한 데이터베이스가 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bcc2bcf2d8764baa874ccaf0e26026a8ea86d10" translate="yes" xml:space="preserve">
          <source>The drive does not exist.</source>
          <target state="translated">드라이브가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a20548a0f73bb216b4b211c372344d02764897f0" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is not present in the system.</source>
          <target state="translated">시스템에 드라이버 &lt;code&gt;Name&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="822e4982aaf8b56398bd1a181c2b6889e1c63b93" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">드라이버 &lt;code&gt;Name&lt;/code&gt; 이 시스템에 있지만 이 프로세스 에는 해당 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1b210ce4bf131d4b12dbe57304824a0514f38f51" translate="yes" xml:space="preserve">
          <source>The driver binary has a field, &lt;code&gt;orig_bytes&lt;/code&gt;, which marks the start of the data in the binary.</source>
          <target state="translated">드라이버 이진에는 &lt;code&gt;orig_bytes&lt;/code&gt; 필드가 있으며 이진 에서 데이터의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="790a2c01c39cd01e89b6ba7ec3e95447572133e7" translate="yes" xml:space="preserve">
          <source>The driver callback functions are called synchronously from the Erlang emulator. If they take too long before completing, they can cause time-outs in the emulator. Use the queue or asynchronous calls if necessary, as the emulator must be responsive.</source>
          <target state="translated">드라이버 콜백 함수는 Erlang 에뮬레이터에서 동 기적으로 호출됩니다. 완료하기까지 너무 오래 걸리면 에뮬레이터에서 시간 초과가 발생할 수 있습니다. 에뮬레이터가 응답해야하므로 필요한 경우 큐 또는 비동기 호출을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="157c45a036de0fa3ddd4ea0c8781ead7513f314e" translate="yes" xml:space="preserve">
          <source>The driver calls back to the emulator, using the API functions declared in &lt;code&gt;erl_driver.h&lt;/code&gt;. They are used for outputting data from the driver, using timers, and so on.</source>
          <target state="translated">드라이버는 &lt;code&gt;erl_driver.h&lt;/code&gt; 에 선언 된 API 함수를 사용하여 에뮬레이터를 다시 호출합니다 . 드라이버에서 데이터를 출력하거나 타이머 등을 사용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc789bf203b3722793ad6336ed379ee48dc982f5" translate="yes" xml:space="preserve">
          <source>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver cannot possibly keep open.</source>
          <target state="translated">드라이버는 Erlang까지 종료하고 오류를 표시 할 수 있습니다. 드라이버가 계속 열려있을 수없는 심각한 오류에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="6e77324ef81504134fd1f1323beb52a29f3e3f65" translate="yes" xml:space="preserve">
          <source>The driver can only be unloaded when there are no open ports using it and no more &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; require it to be loaded.</source>
          <target state="translated">드라이버는 사용중인 열린 포트가없고 더 이상 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가로드 할 필요 가없는 경우에만 언로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d2238ddb29e9e347e288bd01312cba05b7f070" translate="yes" xml:space="preserve">
          <source>The driver data types and the functions available to the driver writer are defined in header file &lt;code&gt;erl_driver.h&lt;/code&gt; seated in Erlang's include directory. See the &lt;code&gt;erl_driver&lt;/code&gt; documentation for details of which functions are available.</source>
          <target state="translated">드라이버 라이터가 사용할 수있는 드라이버 데이터 유형 및 기능 은 Erlang의 include 디렉토리에 있는 헤더 파일 &lt;code&gt;erl_driver.h&lt;/code&gt; 에 정의되어 있습니다. 사용 가능한 기능에 대한 자세한 내용은 &lt;code&gt;erl_driver&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f6b3a5e6e8b698b73cc7423736b57c1fc18515" translate="yes" xml:space="preserve">
          <source>The driver entry contains the functions that will be called by the emulator. In this example, only &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;control&lt;/code&gt; are provided:</source>
          <target state="translated">드라이버 항목에는 에뮬레이터에서 호출 할 함수가 포함되어 있습니다. 이 예제에서는 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;control&lt;/code&gt; 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb368d133889289794fdcfad4ea08d3c6807b8d" translate="yes" xml:space="preserve">
          <source>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked-in driver).</source>
          <target state="translated">드라이버 자체는 영구적으로 만들어졌으며이 경우 더 이상이 인터페이스에서 더 이상 조작 할 수 없습니다 (정적으로 링크 된 드라이버와 유사 함).</target>
        </trans-unit>
        <trans-unit id="66000da869d699cedf77816fe5c89cc8b497a778" translate="yes" xml:space="preserve">
          <source>The driver has requested itself to be permanent, making it behave like an Erlang linked-in driver and can no longer be manipulated with this API.</source>
          <target state="translated">드라이버는 영구적으로 요청하여 Erlang 링크 된 드라이버처럼 작동하며 더 이상이 API로 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb99a228136eba922ef8092328ac0928261c0a09" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">드라이버는 제어 인터페이스를 구현합니다. 제어 인터페이스는 Erlang이 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 호출되는 동기식 인터페이스 입니다. 이 인터페이스 만 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 드라이버를 제어 할 수 있습니다 . 다음 opcode를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb42a7455c90c66663b33eefe7d7a842a5468cbc" translate="yes" xml:space="preserve">
          <source>The driver initialization routine is (usually) declared with a macro to make the driver easier to port between different operating systems (and flavors of systems). This is the only routine that must have a well-defined name. All other callbacks are reached through the driver structure. The macro to use is named &lt;code&gt;DRIVER_INIT&lt;/code&gt; and takes the driver name as parameter:</source>
          <target state="translated">드라이버 초기화 루틴은 일반적으로 매크로를 사용하여 선언되어 드라이버가 다른 운영 체제 (및 다양한 시스템)간에 쉽게 이식 할 수 있도록합니다. 이것은 잘 정의 된 이름을 가져야하는 유일한 루틴입니다. 다른 모든 콜백은 드라이버 구조를 통해 도달합니다. 사용할 매크로의 이름은 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 이며 드라이버 이름을 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df5c267a32b3ddcfaa0938eb24b89bd6abfd4b02" translate="yes" xml:space="preserve">
          <source>The driver is already loaded with other &lt;code&gt;DriverOptionList&lt;/code&gt; or a different &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; argument.</source>
          <target state="translated">드라이버에는 다른 &lt;code&gt;DriverOptionList&lt;/code&gt; 또는 다른 &lt;strong&gt;리터럴 &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 인수 가 이미로드되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="123d2435bbdf7446863fb98cf76173c154e93eaf" translate="yes" xml:space="preserve">
          <source>The driver is loaded by other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, pending_driver}&lt;/code&gt; was specified.</source>
          <target state="translated">옵션 &lt;code&gt;{reload, pending_driver}&lt;/code&gt; 가 지정 되면 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="de8f98e94d0922e6ef27e0959b36602f7f443810" translate="yes" xml:space="preserve">
          <source>The driver is loaded with &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt;. If this is successful, or if it is already loaded, it is opened. This will call the &lt;code&gt;start&lt;/code&gt; function in the driver.</source>
          <target state="translated">드라이버는 &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 로 로드됩니다 . 이것이 성공하거나 이미로드 된 경우 열립니다. 드라이버에서 &lt;code&gt;start&lt;/code&gt; 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebdfd6fd6dc142da610d573bd0e04e4e99b405d" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">&lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt; 을 호출 한 결과 또는 에뮬레이터가 중지 된 경우 에만 드라이버가 언로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa4be31a9519f969227f921236d7d6aa51f75a8a" translate="yes" xml:space="preserve">
          <source>The driver is synchronous, it uses the synchronous calls of the client library. This is only for simplicity, but not good, as it halts the emulator while waiting for the database. This is improved below with an asynchronous sample driver.</source>
          <target state="translated">드라이버는 동기식이며 클라이언트 라이브러리의 동기식 호출을 사용합니다. 이것은 데이터베이스를 기다리는 동안 에뮬레이터를 정지시키기 때문에 단순성을 위해서만 좋지는 않습니다. 이것은 비동기 샘플 드라이버로 아래에서 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2846f7d13f5d6eeed6af66056f38ff13c49aabc" translate="yes" xml:space="preserve">
          <source>The driver is to be compiled and linked to a shared library (DLL on Windows). With gcc, this is done with link flags &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fpic&lt;/code&gt;. As we use the &lt;code&gt;ei&lt;/code&gt; library, we should include it too. There are several versions of &lt;code&gt;ei&lt;/code&gt;, compiled for debug or non-debug and multi-threaded or single-threaded. In the makefile for the samples, the &lt;code&gt;obj&lt;/code&gt; directory is used for the &lt;code&gt;ei&lt;/code&gt; library, meaning that we use the non-debug, single-threaded version.</source>
          <target state="translated">드라이버는 컴파일되어 공유 라이브러리 (Windows의 DLL)에 연결됩니다. gcc를 사용하면 링크 플래그 &lt;code&gt;-shared&lt;/code&gt; 및 &lt;code&gt;-fpic&lt;/code&gt; 로 수행 됩니다. 우리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리를 사용할 때 그것을 포함시켜야합니다. &lt;code&gt;ei&lt;/code&gt; 의 여러 버전이 있으며 디버그 또는 비디 버그 용으로 컴파일되고 멀티 스레드 또는 단일 스레드입니다. 샘플의 makefile에서 &lt;code&gt;obj&lt;/code&gt; 디렉토리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리에 사용됩니다 . 즉, 디버그가 아닌 단일 스레드 버전을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8352df0d68d66243c84331cdb4bc76e073f0f8fd" translate="yes" xml:space="preserve">
          <source>The driver is to be provided as a dynamically linked library in an object code format specific for the platform in use, that is, &lt;code&gt;.so&lt;/code&gt; files on most Unix systems and &lt;code&gt;.ddl&lt;/code&gt; files on Windows. An Erlang linked-in driver must provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For more information about Erlang drivers, see &lt;code&gt;erts:erl_driver&lt;/code&gt; .</source>
          <target state="translated">드라이버는 사용중인 플랫폼에 맞는 객체 코드 형식, 즉 대부분의 Unix 시스템의 &lt;code&gt;.so&lt;/code&gt; 파일과 Windows의 &lt;code&gt;.ddl&lt;/code&gt; 파일 로 동적으로 링크 된 라이브러리로 제공됩니다 . Erlang 링크드 드라이버는 에뮬레이터에 특정 인터페이스를 제공해야하므로이 모듈은 임의의 동적 라이브러리를로드하도록 설계되지 않았습니다. Erlang 드라이버에 대한 자세한 정보는 &lt;code&gt;erts:erl_driver&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f7d0670a21cf6663ffe1e7be79926c35deca09" translate="yes" xml:space="preserve">
          <source>The driver is to fail only when in severe error situations, when the driver cannot possibly keep open, for example, buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버는 심각한 오류 상황에서 드라이버를 계속 열어 둘 수없는 경우에만 실패해야합니다 (예 : 버퍼 할당이 메모리 부족). 일반적인 오류의 경우 &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; 과 함께 오류 코드를 보내는 것이 더 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="fc198aad17d226134b089c46b5d58abebda6515e" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">드라이버 이름 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 에 사용 된 아톰 및 드라이버 라이브러리 파일 이름 (확장자 제외)에 해당해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
