<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="3e20fcd0dc8894a575034d1d37150331fce67f9a" translate="yes" xml:space="preserve">
          <source>List all notification filters in an agent.</source>
          <target state="translated">에이전트의 모든 알림 필터를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="433e9558c472f250dda9655b9de01d8c5b1cbc95" translate="yes" xml:space="preserve">
          <source>List comprehensions are analogous to set comprehensions in Zermelo-Frankel set theory and are called ZF expressions in Miranda. They are analogous to the &lt;code&gt;setof&lt;/code&gt; and &lt;code&gt;findall&lt;/code&gt; predicates in Prolog.</source>
          <target state="translated">리스트 이해는 Zermelo-Frankel 세트 이론에서 이해를 설정하는 것과 유사하며 미란다에서 ZF 표현이라고 불립니다. 이들은 Prolog 의 &lt;code&gt;setof&lt;/code&gt; 및 &lt;code&gt;findall&lt;/code&gt; 술어 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="493415e452a1ca58d7ab0e55c11450201b1caf07" translate="yes" xml:space="preserve">
          <source>List comprehensions are written with the following syntax:</source>
          <target state="translated">목록 이해는 다음 구문으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f643c07aa2da6eaa1122e1bfdb07a56a6d60470e" translate="yes" xml:space="preserve">
          <source>List comprehensions is a feature of many modern functional programming languages. Subject to certain rules, they provide a succinct notation for generating elements in a list.</source>
          <target state="translated">리스트 이해는 많은 현대 기능 프로그래밍 언어의 기능입니다. 특정 규칙에 따라 목록에서 요소를 생성하기위한 간결한 표기법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0adcf806e6c6cb4dd52f21d37c6386d7fc26ec4" translate="yes" xml:space="preserve">
          <source>List comprehensions used to be implemented using funs, and in the old days funs were indeed slow.</source>
          <target state="translated">재미를 사용하여 구현되던 목록 이해력은 옛날에는 재미가 실제로 느 렸습니다.</target>
        </trans-unit>
        <trans-unit id="6a97adf09881d30899eb88074972670e34c92836" translate="yes" xml:space="preserve">
          <source>List comprehensions with low-level &lt;code&gt;Mnesia&lt;/code&gt; functions can be combined in the same transaction. To raise the salary of all female employees, execute the following:</source>
          <target state="translated">낮은 수준의 &lt;code&gt;Mnesia&lt;/code&gt; 기능을 갖춘 목록 이해 는 동일한 트랜잭션에서 결합 될 수 있습니다. 모든 여성 직원의 급여를 인상하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="49eee1559f1ee0d2b82c81d4f588a2ed770857f0" translate="yes" xml:space="preserve">
          <source>List comprehensions.</source>
          <target state="translated">이해력을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="05e97a2b6e38fea3735726e5819ee8ba95e83bc5" translate="yes" xml:space="preserve">
          <source>List elements are the UTF-8 encodings of the individual characters in the string. Invalid codepoints will result in encode/decode failure. On encode, a UTF8String() can be specified as a binary, or as a nested list of binaries and codepoints.</source>
          <target state="translated">목록 요소는 문자열에서 개별 문자의 UTF-8 인코딩입니다. 유효하지 않은 코드 포인트는 인코딩 / 디코딩 실패를 초래합니다. 인코딩시 UTF8String ()을 이진 또는 중첩 된 이진 및 코드 포인트 목록으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278d3b4f4ee0740a1de4cdf1bd2bf93be61d3954" translate="yes" xml:space="preserve">
          <source>List of algorithms to use in the algorithm negotiation. The default &lt;code&gt;algs_list()&lt;/code&gt; can be obtained from &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">알고리즘 협상에 사용할 알고리즘 목록입니다. 기본 &lt;code&gt;algs_list()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9db4243408e7145f00857f4260325dcb24458c15" translate="yes" xml:space="preserve">
          <source>List of extra arguments to the user callback functions. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">사용자 콜백 함수에 대한 추가 인수 목록 자세한 내용은 megaco_user의 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46ea5ca4efb80ab899337d420e90c90285a406b1" translate="yes" xml:space="preserve">
          <source>List of protocols to send to the client if the client indicates that it supports the Next Protocol extension. The client can select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol, it can be accessed using the &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; method.</source>
          <target state="translated">클라이언트가 다음 프로토콜 확장을 지원함을 나타내는 경우 클라이언트에 보낼 프로토콜 목록. 클라이언트는이 목록에없는 프로토콜을 선택할 수 있습니다. 프로토콜 목록에는 빈 바이너리가 포함되어서는 안됩니다. 서버가 다음 프로토콜을 협상하는 경우 &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; 메소드를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e5b6b3bdd287b5c011c0b0403e09b9164fe07d" translate="yes" xml:space="preserve">
          <source>List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant URI (&lt;strong&gt;percent-encoded form&lt;/strong&gt;). A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 호환 URI ( &lt;strong&gt;백분율로 인코딩 된 형식&lt;/strong&gt; )를 나타내는 유니 코드 코드 포인트, UTF-8 인코딩 바이너리 또는이 둘의 혼합 목록입니다 . URI는 기본 라틴 알파벳 문자, 숫자 및 몇 가지 특수 문자와 같이 매우 제한된 세트의 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="d93d5d53babf56ebe1e390ba9a950fbf91d0cb2b" translate="yes" xml:space="preserve">
          <source>List of user (client) public key algorithms to try to use.</source>
          <target state="translated">사용하려는 사용자 (클라이언트) 공개 키 알고리즘 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cc9f7cb6591bec743e823fe706dead283d4905b5" translate="yes" xml:space="preserve">
          <source>List of variable bindings in the shell environment.</source>
          <target state="translated">쉘 환경의 변수 바인딩 목록.</target>
        </trans-unit>
        <trans-unit id="f80b12db0f84fe26ec9bd3ed10dcbee12e085184" translate="yes" xml:space="preserve">
          <source>List processing</source>
          <target state="translated">리스트 처리</target>
        </trans-unit>
        <trans-unit id="8b3923bc8621a43a87bb226f3d90850a4f20ee30" translate="yes" xml:space="preserve">
          <source>List processing functions.</source>
          <target state="translated">목록 처리 기능.</target>
        </trans-unit>
        <trans-unit id="53479af7c4b258e47635cf3f831bd457573f3848" translate="yes" xml:space="preserve">
          <source>List the id's of all engines in OpenSSL's internal list.</source>
          <target state="translated">OpenSSL의 내부 목록에 모든 엔진의 ID를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="a2cf5c534cf79a3ef7abbfc9f78dcce0140e6482" translate="yes" xml:space="preserve">
          <source>Listing without class combiner.</source>
          <target state="translated">클래스 컴 바이 너가없는 리스팅.</target>
        </trans-unit>
        <trans-unit id="9d1f72a30a3a6c56319d5de301e7dcd8d4ea9184" translate="yes" xml:space="preserve">
          <source>Lists all TCP, UDP and SCTP sockets, including those that the Erlang runtime system uses as well as those created by the application.</source>
          <target state="translated">Erlang 런타임 시스템에서 사용하는 소켓과 응용 프로그램에서 작성된 소켓을 포함하여 모든 TCP, UDP 및 SCTP 소켓을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4337868b9d860ba3caf101beb26d92ab8c3abdd4" translate="yes" xml:space="preserve">
          <source>Lists all active connections for this user. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">이 사용자에 대한 모든 활성 연결을 나열합니다. megaco_conn_handle 레코드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2714b113edcc2a65636a1ec94ae0d858a92ee520" translate="yes" xml:space="preserve">
          <source>Lists all active connections. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">모든 활성 연결을 나열합니다. megaco_conn_handle 레코드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c14044ad12ace6bccaea0455b877c42c13dc64aa" translate="yes" xml:space="preserve">
          <source>Lists all active users. Returns a list of megaco_mid()'s.</source>
          <target state="translated">모든 활성 사용자를 나열합니다. megaco_mid ()의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09883357a748a23703460bb6b31f36dc6eb24786" translate="yes" xml:space="preserve">
          <source>Lists all available start flags.</source>
          <target state="translated">사용 가능한 모든 시작 플래그를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4edfc25b8c7646b4111ec287d11e328fd05b2ca3" translate="yes" xml:space="preserve">
          <source>Lists all entries in the specified configuration file.</source>
          <target state="translated">지정된 구성 파일의 모든 항목을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2c53d0f7e8e7f87d95870b0e5dd392fdbd1aed3a" translate="yes" xml:space="preserve">
          <source>Lists all files in a directory, &lt;strong&gt;except&lt;/strong&gt; files with raw filenames. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">원시 파일 이름을 가진 파일을 &lt;strong&gt;제외한&lt;/strong&gt; 디렉토리의 모든 파일을 나열합니다 . 반환 &lt;code&gt;{ok, Filenames}&lt;/code&gt; 그렇지 않으면 성공하면, &lt;code&gt;{error, Reason}&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e14a213355b4d17f65990a6133f694eb009717fd" translate="yes" xml:space="preserve">
          <source>Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.</source>
          <target state="translated">모든 작업을 나열합니다. 알려진 모든 작업 목록이 인쇄됩니다. 현재 작업 이름 앞에 '*'가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d449a2e13ab08f8d884a484f2a845df785c5c0f1" translate="yes" xml:space="preserve">
          <source>Lists all modified modules. Shorthand for &lt;code&gt;code:modified_modules/0&lt;/code&gt;.</source>
          <target state="translated">수정 된 모든 모듈을 나열합니다. &lt;code&gt;code:modified_modules/0&lt;/code&gt; 의 약자 .</target>
        </trans-unit>
        <trans-unit id="9e08270ad4d1c057bd6013ee9f18877c27d91e14" translate="yes" xml:space="preserve">
          <source>Lists all reports loaded in &lt;code&gt;rb_server&lt;/code&gt;. Each report is given a unique number that can be used as a reference to the report in function &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rb_server&lt;/code&gt; 에 로드 된 모든 보고서를 나열합니다 . 각 보고서에는 &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt; 함수의 보고서에 대한 참조로 사용할 수있는 고유 번호가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d585b5f080c2320d84337d311297ce3312051fb" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory, including files with raw filenames. Returns &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">원시 파일 이름을 가진 파일을 포함하여 디렉토리의 모든 파일을 나열합니다. 반환 &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; 그렇지 않으면 성공하면, &lt;code&gt;{error, Reason}&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="02f72b758a50a88ea9e456ce7bb76a0ffe8cb08d" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">디렉토리의 모든 파일을 나열합니다. 반환 &lt;code&gt;{ok, Filenames}&lt;/code&gt; 성공하면, 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4410d2b8ea4abd8b562807aff638f01d51fdbe5b" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element. Tuples are ordered by size, two tuples with the same size are compared element by element.</source>
          <target state="translated">목록은 요소별로 비교됩니다. 튜플은 크기별로 정렬되며 동일한 크기의 두 튜플은 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaad5080a7d5e7990259ba71c1c2a741010f595" translate="yes" xml:space="preserve">
          <source>Lists can only be built starting from the end and attaching list elements at the beginning. If you use the &quot;&lt;code&gt;++&lt;/code&gt;&quot; operator as follows, a new list is created that is a copy of the elements in &lt;code&gt;List1&lt;/code&gt;, followed by &lt;code&gt;List2&lt;/code&gt;:</source>
          <target state="translated">목록은 끝에서 시작하여 처음에 목록 요소를 첨부하는 경우에만 빌드 할 수 있습니다. 다음과 같이 &quot; &lt;code&gt;++&lt;/code&gt; &quot;연산자 를 사용하는 경우 &lt;code&gt;List1&lt;/code&gt; 의 요소 사본 인 &lt;code&gt;List2&lt;/code&gt; 와 함께 새 목록이 작성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4926eced8ea62bd521cb340059a74702d8b7f96d" translate="yes" xml:space="preserve">
          <source>Lists comprehensions still have a reputation for being slow. They used to be implemented using funs, which used to be slow.</source>
          <target state="translated">목록 이해력은 여전히 ​​느리다는 명성을 가지고 있습니다. 예전에는 재미를 사용하여 구현했지만 느려졌습니다.</target>
        </trans-unit>
        <trans-unit id="813529648a19db76d9b2436854b7d6cbfd832327" translate="yes" xml:space="preserve">
          <source>Lists directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리를 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ad6d844316d235b7276ea8fedc7b6ce5feb6d2" translate="yes" xml:space="preserve">
          <source>Lists files in directory &lt;code&gt;Dir&lt;/code&gt; or, if &lt;code&gt;Dir&lt;/code&gt; is a file, only lists it.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리에 파일을 나열 하거나 &lt;code&gt;Dir&lt;/code&gt; 이 파일 인 경우에만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="89af84891678e7a6adbb862fe15a05f7928921ee" translate="yes" xml:space="preserve">
          <source>Lists files in the current directory.</source>
          <target state="translated">현재 디렉토리의 파일을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="c58c2a350f07347551b9f3634b864bd30234359c" translate="yes" xml:space="preserve">
          <source>Lists names registered with the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">현재 실행중인 &lt;code&gt;epmd&lt;/code&gt; 에 등록 된 이름을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="6d04787e574b0b36059101cd1aba185b5fe294f5" translate="yes" xml:space="preserve">
          <source>Lists the given directory on the server, returning the filenames as a list of strings.</source>
          <target state="translated">서버에서 지정된 디렉토리를 나열하고 파일 이름을 문자열 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="4dca4b373f502fbb16dccc9e0b7237d86410b372" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;Mibs&lt;/code&gt; into an agent. If the agent cannot load all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where loading was aborted. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">에이전트에 &lt;code&gt;Mibs&lt;/code&gt; 를 로드 하십시오 . 에이전트가 모든 MIB를로드 할 수없는 경우 ( &lt;code&gt;Force&lt;/code&gt; 인수 의 기본값 은 &lt;code&gt;false&lt;/code&gt; )로드가 중단 된 위치를 나타냅니다. &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c4d7f412fb063f70b02868e384179ef9d1b1a087" translate="yes" xml:space="preserve">
          <source>Load a &lt;code&gt;Mib&lt;/code&gt; into the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">관리자 에게 &lt;code&gt;Mib&lt;/code&gt; 를 로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b3e3360ea19707f02f4a020e3f19c3e4bc8449f2" translate="yes" xml:space="preserve">
          <source>Load a crypto engine, should be done once per engine used. For example dynamically load the engine called &lt;code&gt;MyEngine&lt;/code&gt;:</source>
          <target state="translated">암호화 엔진을로드하십시오. 사용되는 엔진마다 한 번씩 수행해야합니다. 예를 들어 &lt;code&gt;MyEngine&lt;/code&gt; 이라는 엔진을 동적으로로드합니다 .</target>
        </trans-unit>
        <trans-unit id="8a579cb5ea4d299e98f6e3305e729a2e2691eb3c" translate="yes" xml:space="preserve">
          <source>Load a single &lt;code&gt;Mib&lt;/code&gt; into an agent. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example:</source>
          <target state="translated">단일 &lt;code&gt;Mib&lt;/code&gt; 를 에이전트에 로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c51c159c86fd747d2e5230014dcc8e2ec41e6224" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine and just replace some engine methods.</source>
          <target state="translated">동적 엔진을 사용하여 엔진을로드하고 일부 엔진 방법 만 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="4c42d226cb6d70b946e6d5b82bc4c3543f9c44ef" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine by giving the path to the library.</source>
          <target state="translated">라이브러리에 대한 경로를 제공하여 동적 엔진의 도움으로 엔진을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="32bc843d0b756c56e85673fa55374b9397575f9a" translate="yes" xml:space="preserve">
          <source>Load distribution facility.</source>
          <target state="translated">하중 분배 시설.</target>
        </trans-unit>
        <trans-unit id="76bad6da55b53cc690e8073bcd70b2d51d7df367" translate="yes" xml:space="preserve">
          <source>Load mode. Loads all recompiled modules.</source>
          <target state="translated">로드 모드. 재 컴파일 된 모든 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="2cccf6ad0728e7b357295554e6d28b49c3a4a67a" translate="yes" xml:space="preserve">
          <source>Load raw Erlang trace from a file, port or process.</source>
          <target state="translated">파일, 포트 또는 프로세스에서 원시 Erlang 추적을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="9270554fc2af7c0fd3400f7998148c1961fce683" translate="yes" xml:space="preserve">
          <source>Load the &lt;code&gt;dyntrace&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;dyntrace&lt;/code&gt; 모듈을 로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="c237f6e4c5365a30ac145a8b509d8e8b9dd96a4d" translate="yes" xml:space="preserve">
          <source>Load the compiled MIB into the agent.</source>
          <target state="translated">컴파일 된 MIB를 에이전트에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="20c1d6dc95e25c92e1610b1211f7233c890d0b64" translate="yes" xml:space="preserve">
          <source>Load the event table from a file.</source>
          <target state="translated">파일에서 이벤트 테이블을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="a92787cc36930707fbb75a6d9a3de46ba71425a8" translate="yes" xml:space="preserve">
          <source>Load the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument into the mib-server. The &lt;code&gt;MeOverride&lt;/code&gt; and &lt;code&gt;TeOverride&lt;/code&gt; arguments specifies how the mib-server shall handle duplicate mib- and trap- entries.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 인수로 지정된 mib를 mib 서버로 로드하십시오 . &lt;code&gt;MeOverride&lt;/code&gt; 및 &lt;code&gt;TeOverride&lt;/code&gt; 은 MIB-서버가 중복 mib- 및 trap- 항목을 처리해야하는 방법을 인수 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ffabdc1b0aada0df09c6b33e94264210e3036668" translate="yes" xml:space="preserve">
          <source>Loading and Unloading of OTP-OS-MON-MIB</source>
          <target state="translated">OTP-OS-MON-MIB의 로딩 및 언 로딩</target>
        </trans-unit>
        <trans-unit id="59f753c4a89d6cb4b2fbf224764ebcc567bab7f3" translate="yes" xml:space="preserve">
          <source>Loading and unloading of MIBs are quite cheap operations. However, if the application does this very often, perhaps several times per minute, it should load the MIBs once and for all in a sub-agent. This sub-agent only registers and unregisters itself under another agent instead of loading the MIBs each time. This is cheaper than loading an MIB.</source>
          <target state="translated">MIB로드 및 언로드는 매우 저렴한 작업입니다. 그러나 응용 프로그램에서이 작업을 매우 자주 (분당 몇 번) 수행하는 경우 MIB를 한 번에 하위 에이전트에로드해야합니다. 이 서브 에이전트는 매번 MIB를로드하는 대신 다른 에이전트에서 자신을 등록 및 등록 취소합니다. MIB를로드하는 것보다 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="4bbdf176626164bdc51fe89c8ab7ac24003faec2" translate="yes" xml:space="preserve">
          <source>Loading can fail for one the following reasons:</source>
          <target state="translated">다음과 같은 이유로 로딩이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b4c7383cbd28718a91c4b0a187d7de34640193" translate="yes" xml:space="preserve">
          <source>Loading on previous releases is &lt;strong&gt;not&lt;/strong&gt; supported.</source>
          <target state="translated">이전 릴리스에서는로드가 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b3ddb8527fe2c15b0846a1df5469d7936b6ac994" translate="yes" xml:space="preserve">
          <source>Loading tables at startup</source>
          <target state="translated">시작시 테이블로드</target>
        </trans-unit>
        <trans-unit id="262bab97e2113ec92485a2a01d5cabfcd110e445" translate="yes" xml:space="preserve">
          <source>Loading the NIF library overrides the stub implementations and cause calls to &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; to be dispatched to the NIF implementations instead.</source>
          <target state="translated">NIF 라이브러리를로드하면 스텁 구현이 대체되고 대신 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 에 대한 호출 이 NIF 구현으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="766009fe24c4fa886de18bd755755efdbd37a7b5" translate="yes" xml:space="preserve">
          <source>Loading/unloading an application does not load/unload the code used by the application. Code loading is done the usual way.</source>
          <target state="translated">응용 프로그램을로드 / 언로드해도 응용 프로그램이 사용하는 코드가로드 / 언로드되지 않습니다. 코드 로딩은 일반적인 방법으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="595a176aa31ecdb076d6a4fbcfdce5bb9c525cbc" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;Module&lt;/code&gt; on all nodes.</source>
          <target state="translated">모든 노드에 &lt;code&gt;Module&lt;/code&gt; 을 로드 합니다.</target>
        </trans-unit>
        <trans-unit id="4ffc53d4569575bdb25ef1541658266ca11f4420" translate="yes" xml:space="preserve">
          <source>Loads a new module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">새 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="663b889f55fd7cc7ec3d743d418d4fed670a69b0" translate="yes" xml:space="preserve">
          <source>Loads a series of definitions and data found in the text file (generated with &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt;) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</source>
          <target state="translated">텍스트 파일 ( &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt; 로 생성)에서 찾은 일련의 정의 및 데이터 를 Mnesia로로드합니다. 이 함수는 또한 Mnesia를 시작하고 새로운 스키마를 생성 할 수 있습니다. 이 기능은 교육 목적으로 만 사용됩니다. 실제 백업을 처리하기 위해 다른 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b69f0a046ca1124c0aebf63391cf8345c5a3dd5" translate="yes" xml:space="preserve">
          <source>Loads and links a dynamic library containing native implemented functions (NIFs) for a module. &lt;code&gt;Path&lt;/code&gt; is a file path to the shareable object/dynamic library file minus the OS-dependent file extension (&lt;code&gt;.so&lt;/code&gt; for Unix and &lt;code&gt;.dll&lt;/code&gt; for Windows). Notice that on most OSs the library has to have a different name on disc when an upgrade of the nif is done. If the name is the same, but the contents differ, the old library may be loaded instead. For information on how to implement a NIF library, see &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈의 기본 구현 함수 (NIF)를 포함하는 동적 라이브러리를로드하고 링크합니다. &lt;code&gt;Path&lt;/code&gt; 는 공유 가능한 객체 / 동적 라이브러리 파일에서 OS 종속 파일 확장자 ( UNIX의 경우 &lt;code&gt;.so&lt;/code&gt; , Windows의 경우 &lt;code&gt;.dll&lt;/code&gt; ) 를 뺀 파일 경로 입니다. 대부분의 OS에서 nif 업그레이드가 완료되면 라이브러리의 디스크 이름이 달라야합니다. 이름은 동일하지만 내용이 다른 경우 이전 라이브러리가 대신로드 될 수 있습니다. NIF 라이브러리를 구현하는 방법에 대한 정보는 &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82f1623ae8a87546c7dd248aabd05fecaf6a3b4a" translate="yes" xml:space="preserve">
          <source>Loads and links the dynamic driver &lt;code&gt;Name&lt;/code&gt;. &lt;code&gt;Path&lt;/code&gt; is a file path to the directory containing the driver. &lt;code&gt;Name&lt;/code&gt; must be a sharable object/dynamic library. Two drivers with different &lt;code&gt;Path&lt;/code&gt; parameters cannot be loaded under the same name. &lt;code&gt;Name&lt;/code&gt; is a string or atom containing at least one character.</source>
          <target state="translated">동적 드라이버 &lt;code&gt;Name&lt;/code&gt; 을 로드하고 연결합니다 . &lt;code&gt;Path&lt;/code&gt; 는 드라이버가 포함 된 디렉토리의 파일 경로입니다. &lt;code&gt;Name&lt;/code&gt; 은 공유 가능한 객체 / 동적 라이브러리 여야합니다. 다른 &lt;code&gt;Path&lt;/code&gt; 매개 변수를 가진 두 개의 드라이버 는 동일한 이름으로로드 할 수 없습니다. &lt;code&gt;Name&lt;/code&gt; 은 하나 이상의 문자를 포함하는 문자열 또는 원자입니다.</target>
        </trans-unit>
        <trans-unit id="a9103067a9d66d079fdfa3978fe03390b072c888" translate="yes" xml:space="preserve">
          <source>Loads configuration variables using the specified callback module and configuration string. The callback module is to be either loaded or present in the code part. Loaded configuration variables can later be removed using function &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 콜백 모듈 및 구성 문자열을 사용하여 구성 변수를로드합니다. 콜백 모듈은 코드 부분에로드되거나 존재해야합니다. 로드 된 구성 변수는 나중에 &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92030378678e8bb7a8c82cb9b51ba59dd5bd9509" translate="yes" xml:space="preserve">
          <source>Loads the MIBs into agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">MIB를 에이전트 &lt;code&gt;snmp_master_agent&lt;/code&gt; 로로드합니다 .</target>
        </trans-unit>
        <trans-unit id="4dbafa4e360e2579c05082b7f407c76430fb3b56" translate="yes" xml:space="preserve">
          <source>Loads the OTP-MIB.</source>
          <target state="translated">OTP-MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="309db15774fbe5a771972504b9f3ef690359b4c3" translate="yes" xml:space="preserve">
          <source>Loads the OTP-OS-MON-MIB.</source>
          <target state="translated">OTP-OS-MON-MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="294bfed427ce1e4aaf41a120556a07d884c20438" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;EngineId&lt;/code&gt; 에서 제공 한 OpenSSL 엔진을로드 한 다음 ok 및 엔진 핸들을 리턴합니다. 엔진을로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19c49f3d4456a895329c5795a2a2e050a1652c20" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. This function is the same as calling &lt;code&gt;engine_load/4&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;EngineId&lt;/code&gt; 에서 제공 한 OpenSSL 엔진을로드 한 다음 ok 및 엔진 핸들을 리턴합니다. 이 함수는 &lt;code&gt;EngineMethods&lt;/code&gt; 가 가능한 모든 메소드 목록으로 설정된 &lt;code&gt;engine_load/4&lt;/code&gt; 를 호출하는 것과 같습니다 . 엔진을로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="40397b451950fbe4fa114fa0103e62e80e7fa347" translate="yes" xml:space="preserve">
          <source>Loads the application specification for an application into the application controller. It also loads the application specifications for any included applications. Notice that the function does not load the Erlang object code.</source>
          <target state="translated">응용 프로그램의 응용 프로그램 사양을 응용 프로그램 컨트롤러에로드합니다. 또한 포함 된 모든 응용 프로그램의 응용 프로그램 사양을로드합니다. 이 함수는 Erlang 객체 코드를로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca0882de707c0d281667a21347a4ebcd6453edd4" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 에 지정된 디렉토리에서 모듈 &lt;code&gt;[Mod]&lt;/code&gt; 를 로드합니다 . 스크립트 인터프리터는 &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt; 호출하여 적절한 모듈을 가져옵니다 . 모듈을 찾을 수없는 경우 시스템을 종료시키는 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b222c6a3c319314c492cf0438513476921b1937e" translate="yes" xml:space="preserve">
          <source>Local Calls (*).</source>
          <target state="translated">시내 전화 (*).</target>
        </trans-unit>
        <trans-unit id="036d28f25e340f821fe07d1de47fc1a75ea76b56" translate="yes" xml:space="preserve">
          <source>Local Functions (*). All local functions of analyzed modules.</source>
          <target state="translated">로컬 기능 (*). 분석 된 모듈의 모든 로컬 기능.</target>
        </trans-unit>
        <trans-unit id="fc554992a28c61639d93b552c374a6c7640f6fd7" translate="yes" xml:space="preserve">
          <source>Local and universal time, day of the week, date and time conversions.</source>
          <target state="translated">현지 및 표준시, 요일, 날짜 및 시간 변환</target>
        </trans-unit>
        <trans-unit id="3a24185719639d033f0e83cfef0d2ecbbd64ed33" translate="yes" xml:space="preserve">
          <source>Local content tables</source>
          <target state="translated">로컬 컨텐츠 테이블</target>
        </trans-unit>
        <trans-unit id="eec0b138b64b9281f5ecd12aa0d772831301eadf" translate="yes" xml:space="preserve">
          <source>Local error handling (catch/throw).</source>
          <target state="translated">로컬 오류 처리 (캐치 / 투척)</target>
        </trans-unit>
        <trans-unit id="90de80d54249d1e2b8e04f06115d77bf6522dcbe" translate="yes" xml:space="preserve">
          <source>Local or remote process is monitored by name.</source>
          <target state="translated">로컬 또는 원격 프로세스는 이름으로 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7734a4ec06d4dd200eb7b25986d4166f45276c" translate="yes" xml:space="preserve">
          <source>Local port is monitored by name. Please note, that remote port monitors are not supported, so &lt;code&gt;Node&lt;/code&gt; will always be the local node name.</source>
          <target state="translated">로컬 포트는 이름으로 모니터링됩니다. 원격 포트 모니터는 지원되지 않으므로 &lt;code&gt;Node&lt;/code&gt; 는 항상 로컬 노드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e7d3e02be42f1c184b6a3c3c525e75c5179c0a77" translate="yes" xml:space="preserve">
          <source>Local port is monitored by port id.</source>
          <target state="translated">로컬 포트는 포트 ID로 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6dd59b11d0e4520b4498e658eed0dbf5af795c" translate="yes" xml:space="preserve">
          <source>Local time is obtained from the Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt;. Universal time is computed from the BIF &lt;code&gt;universaltime/0&lt;/code&gt;.</source>
          <target state="translated">현지 시간은 Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt; 에서 얻습니다 . 표준시는 BIF &lt;code&gt;universaltime/0&lt;/code&gt; 에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bbadc0e66c71769347f5cbcfb7c145c283ad8fd" translate="yes" xml:space="preserve">
          <source>LocalFunctionHandler,</source>
          <target state="translated">LocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="fa3ca264b4b0fef6182372f6a2a3773355ef8380" translate="yes" xml:space="preserve">
          <source>Locally Used Functions (*). Functions of all modules that have been used in some local call.</source>
          <target state="translated">로컬로 사용되는 기능 (*). 일부 로컬 호출에 사용 된 모든 모듈의 기능.</target>
        </trans-unit>
        <trans-unit id="5b09785286488bac8a487ce328cb324b03ce2288" translate="yes" xml:space="preserve">
          <source>Location data produced by the log macros, and/or metadata given as argument to the log call (API function or macro), are merged with the process metadata. If the same keys occur, values from the metadata argument to the log call overwrite values from the process metadata, which in turn overwrite values from the location data.</source>
          <target state="translated">로그 매크로에 의해 생성 된 위치 데이터 및 / 또는 로그 호출에 대한 인수로 제공된 메타 데이터 (API 함수 또는 매크로)는 프로세스 메타 데이터와 병합됩니다. 동일한 키가 발생하면 메타 데이터 인수에서 로그 호출까지의 값이 프로세스 메타 데이터의 값을 덮어 쓰고 위치 데이터의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="98d3b1967c02fdc780f97715c22bad74f36e5d2c" translate="yes" xml:space="preserve">
          <source>Location transparency. Programs can be written without knowledge of the actual data location.</source>
          <target state="translated">위치 투명성. 실제 데이터 위치에 대한 지식 없이도 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7786377791ba3a21918764c28fc12553cbbcfa4e" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS에서 BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; 의 위치 투명 버전 .</target>
        </trans-unit>
        <trans-unit id="ee8a078095b685bbe1aa5a8273ed6ba602b4e833" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS에서 BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; 의 위치 투명 버전 .</target>
        </trans-unit>
        <trans-unit id="7890346208b55e9f0de8ac7ad2436d80c5f1ce98" translate="yes" xml:space="preserve">
          <source>Lock &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; for ports and processes are interchangeable with the use of &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; and is the reason why &lt;code&gt;pid()&lt;/code&gt; and &lt;code&gt;port()&lt;/code&gt; options can be used in both &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space. Both pids and ports are special identifiers with stripped creation and can be recreated with &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 및 프로세스의 잠금 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Id&lt;/code&gt; 는 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 을 사용하여 서로 바꿔 사용할 수 있으며 &lt;code&gt;pid()&lt;/code&gt; 및 &lt;code&gt;port()&lt;/code&gt; 옵션을 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Id&lt;/code&gt; 공간 모두에서 사용할 수있는 이유 입니다. pid와 포트는 모두 생성이 제거 된 특수 식별자이며 &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a1f5f8eab7c8604bc5fd5406eb1dc291955e813" translate="yes" xml:space="preserve">
          <source>Lock physical memory. Defaults to &lt;code&gt;no&lt;/code&gt;, that is, no physical memory is locked. If set to &lt;code&gt;all&lt;/code&gt;, all memory mappings made by the runtime system are locked into physical memory. If set to &lt;code&gt;all&lt;/code&gt;, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</source>
          <target state="translated">실제 메모리를 잠급니다. 기본값은 &lt;code&gt;no&lt;/code&gt; 로 , 즉 물리적 메모리가 잠기지 않은 것입니다. &lt;code&gt;all&lt;/code&gt; 로 설정 하면 런타임 시스템에서 작성된 모든 메모리 맵핑이 실제 메모리에 잠 깁니다. &lt;code&gt;all&lt;/code&gt; 로 설정 하면이 기능이 지원되지 않거나 사용자에게 충분한 권한이 없거나 사용자가 충분한 실제 메모리를 잠글 수없는 경우 런타임 시스템이 시작되지 않습니다. 잠긴 메모리의 양에 대한 사용자 한계에 도달하면 런타임 시스템은 메모리 부족 상태로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="45057a24787103ff08cc02cd027e2fddb757a403" translate="yes" xml:space="preserve">
          <source>Locks a mutex. The calling thread is blocked until the mutex has been locked. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; lock the same mutex again.</source>
          <target state="translated">뮤텍스를 잠급니다. 뮤텍스가 잠길 때까지 호출 스레드가 차단됩니다. 현재 뮤텍스를 잠근 스레드 는 동일한 뮤텍스를 다시 잠글 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="07893be798653c5847566c8be8dbfc1f8e339a9a" translate="yes" xml:space="preserve">
          <source>Locks are released when the outermost transaction ends.</source>
          <target state="translated">가장 바깥 쪽 트랜잭션이 끝나면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="94c151cf6fbb179cda9bff3f3d73d852d7a92582" translate="yes" xml:space="preserve">
          <source>Locks have an inherent cost in execution time and memory space. It takes time initialize, destroy, aquiring or releasing locks. To decrease lock contention it some times necessary to use finer grained locking strategies. This will usually also increase the locking overhead and hence there is a tradeoff between lock contention and overhead. In general, lock contention increases with the number of threads running concurrently. The &lt;code&gt;lcnt&lt;/code&gt; tool does not measure locking overhead.</source>
          <target state="translated">잠금은 실행 시간과 메모리 공간에 고유 한 비용이 있습니다. 잠금을 초기화, 파괴, 획득 또는 해제하는 데 시간이 걸립니다. 잠금 경합을 줄이려면 더 세밀한 잠금 전략을 사용해야합니다. 이것은 일반적으로 잠금 오버 헤드를 증가 시키므로 잠금 경합과 오버 헤드 사이에 상충 관계가 있습니다. 일반적으로 잠금 경합은 동시에 실행중인 스레드 수에 따라 증가합니다. &lt;code&gt;lcnt&lt;/code&gt; 의 도구는 오버 헤드 잠금 측정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97e3b2745352de6be776b6b063835147719fb8df" translate="yes" xml:space="preserve">
          <source>Locks in the emulator are named after what type of resource they protect and where in the emulator they are initialized, those are lock 'classes'. Most of those locks are also instantiated several times, and given unique identifiers, to increase locking granularity. Typically an instantiated lock protects a disjunct set of the resource, for example ets tables, processes or ports. In other cases it protects a specific range of a resource, for example &lt;code&gt;pix_lock&lt;/code&gt; which protects index to process mappings, and is given a unique number within the class. A unique lock in &lt;code&gt;lcnt&lt;/code&gt; is referenced by a name (class) and an identifier: &lt;code&gt;{Name, Id}&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터의 잠금은 보호하는 리소스 유형과 에뮬레이터의 초기화 위치, 잠금 '클래스'에 따라 이름이 지정됩니다. 이러한 잠금의 대부분은 잠금 세분성을 높이기 위해 여러 번 인스턴스화되고 고유 식별자가 제공됩니다. 일반적으로 인스턴스화 된 잠금은 ets 테이블, 프로세스 또는 포트와 같은 분리 된 리소스 세트를 보호합니다. 다른 경우에는 특정 범위의 리소스 (예 : &lt;code&gt;pix_lock&lt;/code&gt; ) 를 보호하여 인덱스와 프로세스 매핑을 보호하고 클래스 내에서 고유 한 번호를 부여합니다. &lt;code&gt;lcnt&lt;/code&gt; 의 고유 잠금은 이름 (클래스) 및 식별자 &lt;code&gt;{Name, Id}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8dbe53a83645d1cc991331113f81f0a7faf9914" translate="yes" xml:space="preserve">
          <source>Locks the configuration target.</source>
          <target state="translated">구성 대상을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="278c995aa0e75b2b9c086639c4daf158ccfe0917" translate="yes" xml:space="preserve">
          <source>Locks the driver used by the port &lt;code&gt;port&lt;/code&gt; in memory for the rest of the emulator process' lifetime. After this call, the driver behaves as one of Erlang's statically linked-in drivers.</source>
          <target state="translated">나머지 에뮬레이터 프로세스 수명 동안 포트 &lt;code&gt;port&lt;/code&gt; 가 사용하는 드라이버 를 메모리에 잠급니다 . 이 호출 후 드라이버는 Erlang의 정적으로 링크 된 드라이버 중 하나로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="877522e39f7783d66d9b87789ee2ec4ff4bf44e6" translate="yes" xml:space="preserve">
          <source>Locks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="38f84854507a1065ca8c9cdcabd8f6b4e1e78700" translate="yes" xml:space="preserve">
          <source>Log a standard error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 오류 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d0480874641874b7e8e0be1a60fc5834def2580a" translate="yes" xml:space="preserve">
          <source>Log a standard error event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 오류 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="ad4ad09e24cbfd4d5d21372873fb510f9def4cc0" translate="yes" xml:space="preserve">
          <source>Log a standard information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 정보 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b41037da94e8aee3e126b299e92f7fe2e27f3503" translate="yes" xml:space="preserve">
          <source>Log a standard information event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 정보 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="3fa6e0baa5d187967c02dcd11af5efcea6dd94e2" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 경고 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0d4fed3a8c3034253fd45573f68ab458ca57cd12" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 경고 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="1844b1c7ae49d978743ba14c4e6a6dc7c218a27d" translate="yes" xml:space="preserve">
          <source>Log a user-defined error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 오류 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="887d25b1b376c5062e3b1b29ffe4bc683a9b4867" translate="yes" xml:space="preserve">
          <source>Log a user-defined information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 정보 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6d52584bb8ee44c32d0e928afa86be59daa75386" translate="yes" xml:space="preserve">
          <source>Log a user-defined warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 경고 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="068d9dbd5d7dcab97d0cf593a32eb92cca768c9e" translate="yes" xml:space="preserve">
          <source>Log events that do not contain any domain field, match only when &lt;code&gt;Compare&lt;/code&gt; is equal to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;not_equal&lt;/code&gt;.</source>
          <target state="translated">도메인 필드를 포함하지 않는 로그 이벤트는 &lt;code&gt;Compare&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;not_equal&lt;/code&gt; 인 경우에만 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="420705b9279101c5f7f8c29e1095fd25e0bd28a6" translate="yes" xml:space="preserve">
          <source>Log files are written in &lt;code&gt;log_dir&lt;/code&gt;. Each log file has a name of the form &lt;code&gt;erlang.log.N&lt;/code&gt;, where N is a generation number, ranging from 1 to 5. Each log file holds up to 100 kB text. As time goes by, the following log files are found in the log file directory:</source>
          <target state="translated">로그 파일은 &lt;code&gt;log_dir&lt;/code&gt; 에 작성됩니다 . 각 로그 파일의 이름은 &lt;code&gt;erlang.log.N&lt;/code&gt; 형식 이며 여기서 N은 1에서 5까지의 생성 번호입니다. 각 로그 파일은 최대 100kB 텍스트를 보유합니다. 시간이 지남에 따라 다음 로그 파일이 로그 파일 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a923af4f09938b28def56fc57c9c20863233189b" translate="yes" xml:space="preserve">
          <source>Log files from every repeated test run is saved in normal &lt;code&gt;Common Test&lt;/code&gt; fashion (described earlier).</source>
          <target state="translated">반복되는 모든 테스트 실행의 로그 파일은 일반적인 &lt;code&gt;Common Test&lt;/code&gt; 방식으로 저장됩니다 (앞서 설명).</target>
        </trans-unit>
        <trans-unit id="2578374749dfd011e3a5cbfbf27037022ad25cd6" translate="yes" xml:space="preserve">
          <source>Log files grow very large, very quickly.</source>
          <target state="translated">로그 파일은 매우 빠르게 커집니다.</target>
        </trans-unit>
        <trans-unit id="e92387004c6d91ee27198a23307e44f60b2be4d5" translate="yes" xml:space="preserve">
          <source>Log levels are expressed as atoms. Internally in Logger, the atoms are mapped to integer values, and a log event passes the log level check if the integer value of its log level is less than or equal to the currently configured log level. That is, the check passes if the event is equally or more severe than the configured level. See section &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; for a listing and description of all log levels.</source>
          <target state="translated">로그 수준은 원자로 표현됩니다. 내부적으로 로거에서 원자는 정수 값에 매핑되며 로그 이벤트의 로그 값이 현재 구성된 로그 수준보다 작거나 같은 경우 로그 이벤트가 로그 수준 확인을 통과합니다. 즉, 이벤트가 구성된 수준과 같거나 더 심각한 경우 확인이 통과됩니다. 섹션을 참조 &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; 모든 로그 수준의 목록 및 설명.</target>
        </trans-unit>
        <trans-unit id="e3d6b530f7c8342006e1b77a12ea94bab500b544" translate="yes" xml:space="preserve">
          <source>Log size.</source>
          <target state="translated">로그 크기.</target>
        </trans-unit>
        <trans-unit id="2b4dcd80a65565039360cb58b9873fb3744a25eb" translate="yes" xml:space="preserve">
          <source>Log the given message.</source>
          <target state="translated">주어진 메시지를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="257f9074dd9a3273e0ecc0bf2277c09f48d1ab6f" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to handler configuration are:</source>
          <target state="translated">핸들러 구성에 적용되는 로거 API 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5304ec3e6860fd753d440e00b333f7b7952e2873" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to the primary Logger configuration are:</source>
          <target state="translated">기본 로거 구성에 적용되는 로거 API 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="459822e04b58487fbab71512de0c13bbcb5802d9" translate="yes" xml:space="preserve">
          <source>Logger adds the following metadata to each log event:</source>
          <target state="translated">로거는 각 로그 이벤트에 다음 메타 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="37165244e9071117a04c3897531cff43e65233d3" translate="yes" xml:space="preserve">
          <source>Logger allows adding multiple instances of a handler callback. That is, if a callback module implementation allows it, you can add multiple handler instances using the same callback module. The different instances are identified by unique handler identities.</source>
          <target state="translated">로거를 사용하면 핸들러 콜백의 여러 인스턴스를 추가 할 수 있습니다. 즉, 콜백 모듈 구현에서 허용하는 경우 동일한 콜백 모듈을 사용하여 여러 핸들러 인스턴스를 추가 할 수 있습니다. 다른 인스턴스는 고유 한 핸들러 ID로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="32814cbaff4ab32f839a5572bf470491707d186f" translate="yes" xml:space="preserve">
          <source>Logger does, to a certain extent, check its input data before forwarding a log event to filters and handlers. It does, however, not evaluate report callbacks, or check the validity of format strings and arguments. This means that all filters and handlers must be careful when formatting the data of a log event, making sure that it does not crash due to bad input data or faulty callbacks.</source>
          <target state="translated">로거는 로그 이벤트를 필터 및 핸들러에 전달하기 전에 입력 데이터를 어느 정도 점검합니다. 그러나 보고서 콜백을 평가하거나 형식 문자열 및 인수의 유효성을 검사하지는 않습니다. 즉, 로그 이벤트의 데이터를 형식화 할 때 모든 필터와 핸들러가주의를 기울여야하며 입력 데이터가 잘못되거나 콜백이 잘못되어 충돌이 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a30a202ff6e7537109cfe3ce75b8beb4047b16f" translate="yes" xml:space="preserve">
          <source>Logger merges all the metadata maps before forwarding the log event to the handlers. If the same keys occur, values from the log call overwrite process metadata, which in turn overwrite values set by Logger.</source>
          <target state="translated">로거는 로그 이벤트를 핸들러로 전달하기 전에 모든 메타 데이터 맵을 병합합니다. 동일한 키가 발생하면 로그 호출의 값이 프로세스 메타 데이터를 덮어 쓰고 로거가 설정 한 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="12780a5781ba0da418e4440c2f80cf58b1993381" translate="yes" xml:space="preserve">
          <source>Logger provides backwards compatibility with &lt;code&gt;error_logger&lt;/code&gt; in the following ways:</source>
          <target state="translated">로거는 다음과 같은 방법으로 &lt;code&gt;error_logger&lt;/code&gt; 와의 호환성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="a4cf2d82c9d86421275e3d731c6c1f28619eb2da" translate="yes" xml:space="preserve">
          <source>Logging of events during execution</source>
          <target state="translated">실행 중 이벤트 로깅</target>
        </trans-unit>
        <trans-unit id="70d888e147aabaf8fa1dfb2483f315253b5163ed" translate="yes" xml:space="preserve">
          <source>Logging to file with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; or &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; only works when &lt;code&gt;Common Test&lt;/code&gt; is running. Printouts with &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; are however always displayed on screen.</source>
          <target state="translated">&lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 또는 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 를 사용하여 파일에 로깅 하면 &lt;code&gt;Common Test&lt;/code&gt; 가 실행중인 경우에만 작동 합니다. 그러나 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 인 출력물 은 항상 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2e14633e86adb02560262087e31589175004916" translate="yes" xml:space="preserve">
          <source>Logging.</source>
          <target state="translated">Logging.</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93425a1fb1ee61afdd5c8bde53ad3e437fa5c378" translate="yes" xml:space="preserve">
          <source>Logical XOR</source>
          <target state="translated">논리 XOR</target>
        </trans-unit>
        <trans-unit id="189c88af11bff23eaa5470818ba782219adfeb6c" translate="yes" xml:space="preserve">
          <source>Logical errors</source>
          <target state="translated">논리적 오류</target>
        </trans-unit>
        <trans-unit id="b639be33714dfa7d1e5de7c8923f3afaa6ea2eb2" translate="yes" xml:space="preserve">
          <source>Logs a warning message. See &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">경고 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c7284beba7b87f4db66029f580195bdcb14e18a" translate="yes" xml:space="preserve">
          <source>Logs an error message. See &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">오류 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="181bd8b6829579eef29a5e97835c83f4d8736de3" translate="yes" xml:space="preserve">
          <source>Logs an info message. See &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">정보 메시지를 기록합니다. 자세한 내용은 &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="631539dc5343898549c85b01b6e598967f305bce" translate="yes" xml:space="preserve">
          <source>Logs can be found in &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt;. This directory is specified as an argument to &lt;code&gt;run_erl&lt;/code&gt;in the start script listed above.</source>
          <target state="translated">로그는 &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt; 에 있습니다. 이 디렉토리는 위에 나열된 시작 스크립트에서 &lt;code&gt;run_erl&lt;/code&gt; 의 인수로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d394eaa2c896b383401e9868f1f1c7fd394042f0" translate="yes" xml:space="preserve">
          <source>Look up all current Logger configuration, including primary and handler configuration, and module level settings.</source>
          <target state="translated">기본 및 처리기 구성, 모듈 수준 설정을 포함한 모든 현재 로거 구성을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="467add5a91389ace0fffa89049ee83d9c088b039" translate="yes" xml:space="preserve">
          <source>Look up all current module levels. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each module for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 현재 모듈 레벨을 찾으십시오. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 모듈마다 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ed68e7f8cb77748b3410c3da1ddc86795dc0c780" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for all handlers.</source>
          <target state="translated">모든 핸들러의 현재 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="67650debe1e8550cab53ba9b912a888f4830fbd0" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for the given handler.</source>
          <target state="translated">주어진 핸들러에 대한 현재 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="5b7fd66f8792b2995650ec41a426440bdc8c6525" translate="yes" xml:space="preserve">
          <source>Look up the current level for the given modules. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each of the given modules for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 모듈의 현재 레벨을 찾으십시오. 모듈 레벨이 이전에 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 로 설정된 모듈 각각에 대해 하나의 &lt;code&gt;{Module,Level}&lt;/code&gt; 요소를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="28a2ce6edf729b5984078bb368a73e647f062c59" translate="yes" xml:space="preserve">
          <source>Look up the current primary configuration for Logger.</source>
          <target state="translated">로거의 현재 기본 구성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="48789371fd54ac83d13e3db9cfce2e95be6bb545" translate="yes" xml:space="preserve">
          <source>Look up the identities for all installed handlers.</source>
          <target state="translated">설치된 모든 핸들러의 ID를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9eafe480d9cb3d8a690b9224bbee0ac5a9549b6e" translate="yes" xml:space="preserve">
          <source>Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, the following matches a word followed by a semicolon, but does not include the semicolon in the match:</source>
          <target state="translated">Lookahead 어설 션은 (? = 긍정 어설 션의 경우 (?!)로 시작하고, 음수 어설 션의 경우 (?!)로 시작합니다. 예를 들어, 다음은 단어 뒤에 세미콜론이 있지만 일치하는 데 세미콜론은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c07ff987e22dccf5863c21c8249616b8a6ed83fb" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions start with (?&amp;lt;= for positive assertions and (?&amp;lt;! for negative assertions. For example, the following finds an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;:</source>
          <target state="translated">Lookbehind 어설 션은 (? &amp;lt;= 긍정 어설 션의 경우 (? &amp;lt;!)로 시작합니다. 예를 들어 다음은 &quot;foo&quot;앞에 오지 않는 &quot;bar&quot;를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0b4292b6dd1e4f4ea19e5757b522cc47b1f50858" translate="yes" xml:space="preserve">
          <source>Looking at how &lt;code&gt;lists:append/1&lt;/code&gt; or &lt;code&gt;++&lt;/code&gt; would be implemented in plain Erlang, clearly the first list is copied:</source>
          <target state="translated">&lt;code&gt;lists:append/1&lt;/code&gt; 또는 &lt;code&gt;++&lt;/code&gt; 가 일반 Erlang으로 구현되는 방법을 살펴보면 첫 번째 목록이 분명히 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="ae8011d7d2dbc5d36c38aa015da2647371e61405" translate="yes" xml:space="preserve">
          <source>Looking at the &lt;code&gt;tut17&lt;/code&gt; code, you see that the &lt;code&gt;pong&lt;/code&gt; function itself is unchanged, the following lines work in the same way irrespective of on which node the &quot;ping&quot; process is executes:</source>
          <target state="translated">상기 찾고 &lt;code&gt;tut17&lt;/code&gt; 의 코드, 당신은 볼 &lt;code&gt;pong&lt;/code&gt; 함수 자체가 다음 줄에 상관없이 어떤에서 동일한 방식으로 작동은 &quot;핑&quot;프로세스가 실행입니다 노드, 변경되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="dc4ea395786cdf2a9b882e1323bffb04f3d43ded" translate="yes" xml:space="preserve">
          <source>Looking at the function &lt;code&gt;ping/2&lt;/code&gt;, the second clause of &lt;code&gt;ping/2&lt;/code&gt; is executed since the value of the first argument is 3 (not 0) (first clause head is &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt;, second clause head is &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; becomes 3).</source>
          <target state="translated">&lt;code&gt;ping/2&lt;/code&gt; 함수를 보면 첫 번째 인수의 값이 3이 아니기 때문에 &lt;code&gt;ping/2&lt;/code&gt; 의 두 번째 절이 실행됩니다 (0이 아님) (첫 번째 절 머리글은 &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt; 이고 두 번째 절 머리글은 &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt; 이므로 &lt;code&gt;N&lt;/code&gt; 은 3)이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb76af27b840c114115effd83744ad34a439d0c6" translate="yes" xml:space="preserve">
          <source>Looking up only &lt;code&gt;{2,2}&lt;/code&gt; would not return &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{2,2}&lt;/code&gt; 만 찾으면 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 가 리턴되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79cecfb0f48fcf27b9c36092d68f350e007736e3" translate="yes" xml:space="preserve">
          <source>Looks for a file of the given name by applying suffix rules to the given directory path. For example, a rule &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; means that if the directory path ends with &lt;code&gt;&quot;ebin&quot;&lt;/code&gt;, the corresponding path ending in &lt;code&gt;&quot;src&quot;&lt;/code&gt; should be searched.</source>
          <target state="translated">주어진 디렉토리 경로에 접미사 규칙을 적용하여 주어진 이름의 파일을 찾습니다. 예를 들어 규칙 &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; 은 디렉토리 경로가 &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; 으로 끝나는 경우 &lt;code&gt;&quot;src&quot;&lt;/code&gt; 로 끝나는 해당 경로를 검색해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="572250e9df056859af227d0dcd9f4fa92b7ecd08" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;Key&lt;/code&gt; in &lt;code&gt;Tree&lt;/code&gt;. Returns &lt;code&gt;{value, Value}&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; if &lt;code&gt;Key&lt;/code&gt; is not present.</source>
          <target state="translated">조회 &lt;code&gt;Key&lt;/code&gt; 의 &lt;code&gt;Tree&lt;/code&gt; . 반환 &lt;code&gt;{value, Value}&lt;/code&gt; , 또는 &lt;code&gt;none&lt;/code&gt; 경우 &lt;code&gt;Key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb9dfef148e9ec6b8cf8c2740447332c851aec8e" translate="yes" xml:space="preserve">
          <source>Looks up a cache entry. Is to be callable from any process.</source>
          <target state="translated">캐시 항목을 찾습니다. 모든 프로세스에서 호출 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a52acb767c4795552ad229633861bc31c72674b" translate="yes" xml:space="preserve">
          <source>Looks up a name in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 에서 이름을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="78101c6cc3d27d2ba6e58fe21274768cb0746cd8" translate="yes" xml:space="preserve">
          <source>Looks up a port by its registered name.</source>
          <target state="translated">등록 된 이름으로 포트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="30d78191ce5ffb897b0972e9eb8f6d616fa60717" translate="yes" xml:space="preserve">
          <source>Looks up a process by its registered name.</source>
          <target state="translated">등록 된 이름으로 프로세스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1d157b4e78c7c3e66517498884591593ccc59f89" translate="yes" xml:space="preserve">
          <source>Looks up the OBJECT IDENTIFIER of a MIB object, given the symbolic name. Note, the OBJECT IDENTIFIER is given for the object, not for an instance.</source>
          <target state="translated">심볼 이름이 지정된 MIB 객체의 객체 식별자를 찾습니다. OBJECT IDENTIFIER는 인스턴스가 아닌 객체에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5bf56fd6ef4f1df6829e5e6bfa87397c2baa95" translate="yes" xml:space="preserve">
          <source>Looks up the symbolic name of a MIB object, given OBJECT IDENTIFIER.</source>
          <target state="translated">OBJECT IDENTIFIER가 주어지면 MIB 객체의 기호 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="08b0f2af44d0672e5833994d490452fc72a7fb05" translate="yes" xml:space="preserve">
          <source>Lookup a dictionary entry and return zero or one value.</source>
          <target state="translated">사전 항목을 찾아 0 또는 하나의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae6f5a731780983b4856c7c170673fb5330edbc2" translate="yes" xml:space="preserve">
          <source>Lookup information about an active connection</source>
          <target state="translated">활성 연결에 대한 조회 정보</target>
        </trans-unit>
        <trans-unit id="045c842e1d6e6cd467265d71631ecd62a55e3333" translate="yes" xml:space="preserve">
          <source>Lookup join is handled analogously to lookup of constants in a table: if the join operator is &lt;code&gt;==/2&lt;/code&gt;, and the table where constants are to be looked up uses &lt;code&gt;=:=/2&lt;/code&gt; when testing keys for equality, then the &lt;code&gt;qlc&lt;/code&gt; module does not consider lookup join for that table.</source>
          <target state="translated">조회 조인은 테이블에서 상수를 조회하는 것과 유사하게 처리됩니다. 조인 연산자가 &lt;code&gt;==/2&lt;/code&gt; 이고 상수를 조회 할 테이블이 키를 테스트 할 때 &lt;code&gt;=:=/2&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;qlc&lt;/code&gt; 모듈은 해당 테이블에 대한 조회 조인을 고려하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="35bb462b9b5d0daab8ea39fbe0dc5389a6f8b9fe" translate="yes" xml:space="preserve">
          <source>Lookup method</source>
          <target state="translated">조회 방법</target>
        </trans-unit>
        <trans-unit id="067bc036849c0ea9f3a88839506df146bbb74c53" translate="yes" xml:space="preserve">
          <source>Lookup system information</source>
          <target state="translated">조회 시스템 정보</target>
        </trans-unit>
        <trans-unit id="95287f575a0e7411367945df70317705255f8115" translate="yes" xml:space="preserve">
          <source>Lookup the CRLs belonging to the distribution point &lt;code&gt;Distributionpoint&lt;/code&gt;. This function may choose to only look in the cache or to follow distribution point links depending on how the cache is administrated.</source>
          <target state="translated">배포 지점 &lt;code&gt;Distributionpoint&lt;/code&gt; 에 속하는 CRL을 조회하십시오 . 이 기능은 캐시 관리 방법에 따라 캐시 만 보거나 배포 지점 링크를 따르도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6fa78d0fd70423aadd6b451927544578762dd1d" translate="yes" xml:space="preserve">
          <source>Lookup user information</source>
          <target state="translated">조회 사용자 정보</target>
        </trans-unit>
        <trans-unit id="19942bda356f106b651a5a8f34c9a238875451dc" translate="yes" xml:space="preserve">
          <source>Loops are detected by diameter when the return value of a request callback asks that a request be forwarded. Loop detection in other cases is the responsibility of the user.</source>
          <target state="translated">요청 콜백의 반환 값이 요청을 전달하도록 요청할 때 직경으로 루프가 감지됩니다. 다른 경우 루프 감지는 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3dd4c3b37165b69206ec0c19aa805a2a0483a821" translate="yes" xml:space="preserve">
          <source>Low-Level Instructions</source>
          <target state="translated">저수준 지침</target>
        </trans-unit>
        <trans-unit id="3ac7f763ea9e07bb988a045d46a8d40a6820054e" translate="yes" xml:space="preserve">
          <source>Low-level Erlang loader.</source>
          <target state="translated">저수준 Erlang 로더.</target>
        </trans-unit>
        <trans-unit id="5b779e63c115b7d4a7dfed98a4b6ed54c59b2bcc" translate="yes" xml:space="preserve">
          <source>Low-level socket connection (1)</source>
          <target state="translated">저수준 소켓 연결 (1)</target>
        </trans-unit>
        <trans-unit id="72c1e1d78aed59b6fe1fe5b89bf5d964d2c9be82" translate="yes" xml:space="preserve">
          <source>Lowercase letter</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="26e7bfca24fa187e97eeb696c1c3b5c2e4216480" translate="yes" xml:space="preserve">
          <source>Lowercase letters</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="71a644cdf0cedda6a1fe30c2848ffe7f7691a9bf" translate="yes" xml:space="preserve">
          <source>Luckily there is a simplified way to start tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The idea is that you should instrument your code with calls to &lt;code&gt;et:trace_me/5&lt;/code&gt; in strategic places where you have interesting information available in your program. Then you just start the &lt;code&gt;Collector&lt;/code&gt; with global tracing enabled:</source>
          <target state="translated">다행히 &lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 호출을 추적하는 간단한 방법이 있습니다. 아이디어는 프로그램에서 유용한 정보를 얻을 수있는 전략적인 장소에서 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 호출하여 코드를 계측해야한다는 것 입니다. 그런 다음 전역 추적을 사용 하여 &lt;code&gt;Collector&lt;/code&gt; 를 시작 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f9156a05ab3755f6c7a6aab965a12bc73fd9cc2c" translate="yes" xml:space="preserve">
          <source>Lycian</source>
          <target state="translated">Lycian</target>
        </trans-unit>
        <trans-unit id="253fa34d4b816ad16ebad60a0945ef037709d0b8" translate="yes" xml:space="preserve">
          <source>Lydian</source>
          <target state="translated">Lydian</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="a213eb1de2d97fd8ab6c0c8486e553f7cdc3e521" translate="yes" xml:space="preserve">
          <source>M-d</source>
          <target state="translated">M-d</target>
        </trans-unit>
        <trans-unit id="add69bf7aa5e86e6ac1a17b8047a626986b67564" translate="yes" xml:space="preserve">
          <source>M-f</source>
          <target state="translated">M-f</target>
        </trans-unit>
        <trans-unit id="d6a7c28d96631e7edde69c8cc5ffb71acda67d91" translate="yes" xml:space="preserve">
          <source>MANDATORY</source>
          <target state="translated">MANDATORY</target>
        </trans-unit>
        <trans-unit id="2a10b6977b13d4b417a565ad4f26126926a4a59b" translate="yes" xml:space="preserve">
          <source>MFA ::= &lt;code&gt;{&lt;/code&gt;Module&lt;code&gt;,&lt;/code&gt; Function&lt;code&gt;,&lt;/code&gt; Arity&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">MFA :: = &lt;code&gt;{&lt;/code&gt; 모듈 &lt;code&gt;,&lt;/code&gt; 기능 &lt;code&gt;,&lt;/code&gt; Arity &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d945d68cd16cd86023529b0ae4e4b00d3131a1f" translate="yes" xml:space="preserve">
          <source>MIB View Semantics</source>
          <target state="translated">MIB 뷰 의미론</target>
        </trans-unit>
        <trans-unit id="04c6a062dba8d860ecd8d08014fad091eaa98372" translate="yes" xml:space="preserve">
          <source>MIB for SNMP. It generates a &lt;code&gt;.bin&lt;/code&gt; file.</source>
          <target state="translated">SNMP 용 MIB. &lt;code&gt;.bin&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c4de5d52a9bb8b810300afe15b33e4b1a582332d" translate="yes" xml:space="preserve">
          <source>MIBs for agent configuration are defined.</source>
          <target state="translated">에이전트 구성을위한 MIB가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="490ac4f548272126971fbad865a9e5c77d3dd621" translate="yes" xml:space="preserve">
          <source>MacOS X reorganizes the filenames so that the representation of accents, and so on, uses the &quot;combining characters&quot;. For example, character &lt;code&gt;&amp;ouml;&lt;/code&gt; is represented as code points &lt;code&gt;[111,776]&lt;/code&gt;, where &lt;code&gt;111&lt;/code&gt; is character &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;776&lt;/code&gt; is the special accent character &quot;Combining Diaeresis&quot;. This way of normalizing Unicode is otherwise very seldom used. Erlang normalizes those filenames in the opposite way upon retrieval, so that filenames using combining accents are not passed up to the Erlang application. In Erlang, filename &quot;bj&amp;ouml;rn&quot; is retrieved as &lt;code&gt;[98,106,246,114,110]&lt;/code&gt;, not as &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt;, although the file system can think differently. The normalization into combining accents is redone when accessing files, so this can usually be ignored by the Erlang programmer.</source>
          <target state="translated">MacOS X은 파일 이름을 재구성하여 악센트 등을 표현할 때 &quot;조합 문자&quot;를 사용합니다. 예를 들어, 문자 &lt;code&gt;&amp;ouml;&lt;/code&gt; 는 코드 포인트 &lt;code&gt;[111,776]&lt;/code&gt; 로 표시됩니다 . 여기서 &lt;code&gt;111&lt;/code&gt; 은 문자 &lt;code&gt;o&lt;/code&gt; 이고 &lt;code&gt;776&lt;/code&gt; 은 특수 악센트 문자 &quot;Combining Diaeresis&quot;입니다. 유니 코드를 정규화하는이 방법은 매우 드물게 사용됩니다. Erlang은 검색시 반대 방향으로 해당 파일 이름을 정규화하여 결합 악센트를 사용하는 파일 이름이 Erlang 응용 프로그램으로 전달되지 않도록합니다. 얼랑에서, 파일명이 &quot;비욘이&quot;로 검색된다 &lt;code&gt;[98,106,246,114,110]&lt;/code&gt; 않기, &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt; 파일 시스템은 다르게 생각할 수 있지만. 악센트 결합에 대한 정규화는 파일에 액세스 할 때 다시 수행되므로 일반적으로 Erlang 프로그래머는이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="768e486d6aa5224dfa45f14bc7b92f9b71384261" translate="yes" xml:space="preserve">
          <source>Macro definitions have the following format:</source>
          <target state="translated">매크로 정의의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c21df95bcab5149fd0542e1989e579553cef5ea9" translate="yes" xml:space="preserve">
          <source>Macros are expanded during compilation. A simple macro &lt;code&gt;?Const&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">컴파일 중에 매크로가 확장됩니다. 간단한 매크로 &lt;code&gt;?Const&lt;/code&gt; 가 &lt;code&gt;Replacement&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="bafb56f75026725c63578890f318e2634ca3f79f" translate="yes" xml:space="preserve">
          <source>Magically notice traces of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function and make appropriate &lt;code&gt;Events&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;et:trace_me/5&lt;/code&gt; 함수의 흔적을 마술 처럼 보고 적절한 &lt;code&gt;Events&lt;/code&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="607c4f3f1fc132b892e746284e6f6a2a7788ff50" translate="yes" xml:space="preserve">
          <source>Mahajani</source>
          <target state="translated">Mahajani</target>
        </trans-unit>
        <trans-unit id="ce03a922df1904d63b3c52366acd1e4d5dfa8f72" translate="yes" xml:space="preserve">
          <source>Main API of the Event Trace (ET) application</source>
          <target state="translated">ET (Event Trace) 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="c9a8168cc646feb22f71f8973ad3e9998dbfe20e" translate="yes" xml:space="preserve">
          <source>Main API of the Megaco application</source>
          <target state="translated">Megaco 애플리케이션의 주요 API</target>
        </trans-unit>
        <trans-unit id="7290931f77376ec9118ea4cf32caad5589c36ebf" translate="yes" xml:space="preserve">
          <source>Main API of the Reltool application</source>
          <target state="translated">Reltool 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="014771aa765bee2f30af23c70717253cfb96da9f" translate="yes" xml:space="preserve">
          <source>Main API of the diameter application.</source>
          <target state="translated">직경 적용의 주요 API.</target>
        </trans-unit>
        <trans-unit id="4fcfcea0b000eea06fc6d4ed4be0088adbe04013" translate="yes" xml:space="preserve">
          <source>Main API of the ssh application</source>
          <target state="translated">ssh 애플리케이션의 기본 API</target>
        </trans-unit>
        <trans-unit id="4140ba76dde001a1b5b6d82503aaee2fca05b0aa" translate="yes" xml:space="preserve">
          <source>Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. The main multiblock carrier is allocated through &lt;code&gt;sys_alloc&lt;/code&gt; and is never deallocated.</source>
          <target state="translated">메인 멀티 블록 캐리어 크기. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 의 기본 멀티 블록 캐리어 크기를 설정합니다 . 기본 &lt;code&gt;sys_alloc&lt;/code&gt; 블록 캐리어는 sys_alloc을 통해 할당되며 할당 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98d070980c8de15123661b75681a9415be24bed3" translate="yes" xml:space="preserve">
          <source>Main user interface for the &lt;code&gt;Common Test&lt;/code&gt; framework.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 의 기본 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="34c6a81f8a68bddb86631e45d9f0b3b6bd8f93e5" translate="yes" xml:space="preserve">
          <source>Main user interface for the Common Test framework.</source>
          <target state="translated">공통 테스트 프레임 워크의 기본 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="caf95b7396f0360a962cd9ce06b569c833ad967e" translate="yes" xml:space="preserve">
          <source>Maintenance of the fully connected network</source>
          <target state="translated">완전히 연결된 네트워크의 유지 관리</target>
        </trans-unit>
        <trans-unit id="683ba771dba7958f68fbac6a0cabbea4e324174e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Deferred&lt;/code&gt; suites become the least preferred suites, that is put them at the end of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Deferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the Deferred cipher list.</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; 스위트를 가장 선호하지 않는 스위트로 만드십시오. 스위트 스위트가있는 경우 &lt;code&gt;Suites&lt;/code&gt; 에서 스위트 &lt;code&gt;Suites&lt;/code&gt; 를 제거한 후 스위트 스위트 목록 끝에 배치합니다 . &lt;code&gt;Deferred&lt;/code&gt; 암호 목록 또는 필터 목록 일 수 있으며이 경우 필터는 &lt;code&gt;Suites&lt;/code&gt; 에서 연기 된 암호 목록을 추출하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d09c0a2ffb9d90565c340512a769d32848189c99" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Preferred&lt;/code&gt; suites become the most preferred suites that is put them at the head of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Preferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the preferred cipher list.</source>
          <target state="translated">확인 &lt;code&gt;Preferred&lt;/code&gt; 스위트 룸은 암호 스위트 목록의 머리를 넣어 가장 선호하는 제품군이 될 &lt;code&gt;Suites&lt;/code&gt; 에서 그들을 제거한 후 &lt;code&gt;Suites&lt;/code&gt; 있는 경우. &lt;code&gt;Preferred&lt;/code&gt; 는 암호 슈트 (cipher suit)의 목록 또는 필터가 선호하는 암호 목록을 추출하기 위해 &lt;code&gt;Suites&lt;/code&gt; 에서 필터를 사용하는 필터의 목록 일 수있다.</target>
        </trans-unit>
        <trans-unit id="b9ea499659acd96747d610ef617848faf8002c00" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more quiet.</source>
          <target state="translated">Dialyzer를 좀 더 조용하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="ee2cafda4f9116a303a421f649a4f70f2f925a8d" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more verbose.</source>
          <target state="translated">Dialyzer를 좀 더 장황하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="10ba2efeabebf0489b4847ad8643fcdf0992e15a" translate="yes" xml:space="preserve">
          <source>Make Dialyzer emit warnings even when manipulating the PLT. Warnings are only emitted for files that are analyzed.</source>
          <target state="translated">PLT를 조작 할 때도 Dialyzer에서 경고를 표시합니다. 경고는 분석 된 파일에 대해서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7715175917b7a7d605296680b1ca41edb30157cf" translate="yes" xml:space="preserve">
          <source>Make Dialyzer print information about the PLT and then quit. The PLT can be specified with &lt;code&gt;--plt(s)&lt;/code&gt;.</source>
          <target state="translated">Dialyzer가 PLT에 대한 정보를 인쇄 한 다음 종료하십시오. PLT는 &lt;code&gt;--plt(s)&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f5adb962b2fbef3d7acd737ca5f836fe51e4afa" translate="yes" xml:space="preserve">
          <source>Make a copy of the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;. This file is usually named &lt;code&gt;syslog.conf&lt;/code&gt; and found in directory &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 용 Solaris 표준 구성 파일의 사본을 작성하십시오 . 이 파일의 이름은 일반적으로 &lt;code&gt;syslog.conf&lt;/code&gt; 이며 &lt;code&gt;/etc&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e586a8c6ff263d0afce189a56818cee918e1347" translate="yes" xml:space="preserve">
          <source>Make a key out of an event record or an old key.</source>
          <target state="translated">이벤트 레코드 또는 이전 키에서 키를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="1415885484de34303a471ea6db61c1acc9cb54f8" translate="yes" xml:space="preserve">
          <source>Make a simple hello world and try to compile it with the &lt;code&gt;cl&lt;/code&gt; command from within bash. If that does not work, your environment needs fixing. Remember, there should be no backslashes in your path environment variable in Cygwin bash, but LIB and INCLUDE should contain Windows style paths with semicolon, drive letters and backslashes.</source>
          <target state="translated">간단한 hello world를 만들고 bash 내 에서 &lt;code&gt;cl&lt;/code&gt; 명령 으로 컴파일하십시오 . 그래도 작동하지 않으면 환경을 수정해야합니다. Cygwin bash의 경로 환경 변수에는 백 슬래시가 없어야하지만 LIB 및 INCLUDE에는 세미콜론, 드라이브 문자 및 백 슬래시가있는 Windows 스타일 경로가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1dcb4e238263c7a5afbedf884d34e60decef3679" translate="yes" xml:space="preserve">
          <source>Make an edited copy of the backup copy previously made.</source>
          <target state="translated">이전에 작성된 백업 사본의 편집 사본을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bfc8145db5663246acf8191e3d36605eb676990d" translate="yes" xml:space="preserve">
          <source>Make process &lt;code&gt;Pid&lt;/code&gt; the new owner of table &lt;code&gt;Tab&lt;/code&gt;. If successful, message &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; is sent to the new owner.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 새 소유자로 설정하십시오 . 성공하면 &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; 메시지 가 새 소유자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7b44f78041d63c29886fd3ab915b1c7a217bbe5f" translate="yes" xml:space="preserve">
          <source>Make some particular suites the most preferred, or least preferred by changing prepend to append.</source>
          <target state="translated">prepend를 append로 변경하여 특정 스위트를 가장 선호하거나 가장 선호하는 스위트로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c2ba192403adbb128258a263d55b31ddd0872ee8" translate="yes" xml:space="preserve">
          <source>Make sure that the command &lt;code&gt;hostname&lt;/code&gt; returns a valid fully qualified host name (this is configured in &lt;code&gt;/etc/hostconfig&lt;/code&gt;). Otherwise you might experience problems when running distributed systems.</source>
          <target state="translated">&lt;code&gt;hostname&lt;/code&gt; 명령 이 유효한 완전한 호스트 이름을 리턴 하는지 확인하십시오 (이 이름은 &lt;code&gt;/etc/hostconfig&lt;/code&gt; 에 구성됨 ). 그렇지 않으면 분산 시스템을 실행할 때 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605b087786603fea0d76e7acb85a392c7a2ca554" translate="yes" xml:space="preserve">
          <source>Make sure to install the basic dev tools, but avoid the MinGW autoconf and install the msys one instead.</source>
          <target state="translated">기본 개발 도구를 설치해야하지만 MinGW autoconf를 피하고 대신 msys 도구를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f71b08b9686f12317202560047739ba3b1216b0e" translate="yes" xml:space="preserve">
          <source>Make sure to set the PATH so that NSIS and Microsoft SDK is found before the MSYS/Cygwin tools and that Java is last in the PATH.</source>
          <target state="translated">MSIS / Cygwin 도구 이전에 NSIS 및 Microsoft SDK가 있고 PATH에서 Java가 마지막이되도록 PATH를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bf36bcf4ace9356a062d8090033e2ca09b36f682" translate="yes" xml:space="preserve">
          <source>Make sure you're in the top directory in the source tree.</source>
          <target state="translated">소스 트리의 최상위 디렉토리에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c7432411584b2a6828a2cfe381ef427f482a9a7d" translate="yes" xml:space="preserve">
          <source>Make that series of NIF calls from the Erlang level.</source>
          <target state="translated">Erlang 레벨에서 일련의 NIF 호출을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1f5db744ecb6a5d733780b21850a0e20203a81db" translate="yes" xml:space="preserve">
          <source>Make the client tell the server that the client accepts extension negotiation, that is, include &lt;code&gt;ext-info-c&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">클라이언트가 클라이언트에게 확장 협상을 수락 함을 알리도록합니다. 즉, 보낸 kexinit 메시지에 &lt;code&gt;ext-info-c&lt;/code&gt; 를 포함시킵니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; 을 참조하고 현재 구현 된 확장 목록은 &lt;code&gt;ssh(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5035cf3f169978e011505d0d2efbb3700dc36cf" translate="yes" xml:space="preserve">
          <source>Make the server (daemon) tell the client that the server accepts extension negotiation, that is, include &lt;code&gt;ext-info-s&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">서버 (데몬)가 클라이언트에게 서버가 확장 협상을 수락 함을 알려줍니다 (즉, 보낸 kexinit 메시지에 &lt;code&gt;ext-info-s&lt;/code&gt; 포함) . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; 을 참조하고 현재 구현 된 확장 목록은 &lt;code&gt;ssh(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93aa92102b400ac9f00b97c87885b225d1e6c53c" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as atoms. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 원자로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc491ef04c29a912ad13bb0dab3aa78550c1a0b0" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as strings. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 지정된 함수를 호출합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 문자열로 전달됩니다. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="effbaf150909b5681b041c7c93ee8c1dd9234e3b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; evaluate the expression &lt;code&gt;Expr&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만듭니다 &lt;code&gt;init&lt;/code&gt; 식 평가 &lt;code&gt;Expr&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f6e437de83ae71822d270a49d45206d77f45c59" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; write some debug information while interpreting the boot script.</source>
          <target state="translated">차종은 &lt;code&gt;init&lt;/code&gt; 부트 스크립트를 해석하면서 일부 디버그 정보를 기록.</target>
        </trans-unit>
        <trans-unit id="1c12aa164fb9326a07158879ddf33e08ec2da65e" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;badarg&lt;/code&gt; exception to be returned from a NIF, and associates it with environment &lt;code&gt;env&lt;/code&gt;. Once a NIF or any function it calls invokes &lt;code&gt;enif_make_badarg&lt;/code&gt;, the runtime ensures that a &lt;code&gt;badarg&lt;/code&gt; exception is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.</source>
          <target state="translated">만든다 &lt;code&gt;badarg&lt;/code&gt; 의 NIF로부터 반환되는 예외 및 환경과 관련 짓 &lt;code&gt;env&lt;/code&gt; . NIF 또는 호출하는 함수가 &lt;code&gt;enif_make_badarg&lt;/code&gt; 를 호출하면 런타임은 NIF가 예외가 아닌 용어를 대신 리턴하려고 시도하더라도 NIF가 리턴 될 때 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="237c55ef12224693f0ea9298c5b4012406e52202" translate="yes" xml:space="preserve">
          <source>Makes a binary term from &lt;code&gt;bin&lt;/code&gt;. Any ownership of the binary data is transferred to the created term and &lt;code&gt;bin&lt;/code&gt; is to be considered read-only for the rest of the NIF call and then as released.</source>
          <target state="translated">&lt;code&gt;bin&lt;/code&gt; 에서 이진 용어를 만듭니다 . 이진 데이터의 소유권은 생성 된 용어로 이전되며 나머지 NIF 호출에 대해서는 &lt;code&gt;bin&lt;/code&gt; 이 읽기 전용으로 간주되어 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b692874a74db2c05c40ad42ce60cf8791216d646" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and inserts &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map_in&lt;/code&gt;, the old associated value is replaced by &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 맵의 복사본을 만들고 &lt;code&gt;value&lt;/code&gt; 를 가진 &lt;code&gt;key&lt;/code&gt; 를 삽입 합니다 . 경우 &lt;code&gt;key&lt;/code&gt; 이미 존재 &lt;code&gt;map_in&lt;/code&gt; 이전 관련 값으로 대체 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdd484fa8278609492e238310d156b1e791c1d1" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and replace the old associated value for &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;new_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 맵의 사본을 작성 하고 &lt;code&gt;key&lt;/code&gt; 에 대한 이전 연관된 값을 &lt;code&gt;new_value&lt;/code&gt; 로바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="ca6b1dc8e5e0672574d5436088c1dcb75a32cecf" translate="yes" xml:space="preserve">
          <source>Makes a copy of term &lt;code&gt;src_term&lt;/code&gt;. The copy is created in environment &lt;code&gt;dst_env&lt;/code&gt;. The source term can be located in any environment.</source>
          <target state="translated">용어 &lt;code&gt;src_term&lt;/code&gt; 의 사본을 작성 합니다. 사본은 환경 &lt;code&gt;dst_env&lt;/code&gt; 에 작성됩니다 . 소스 용어는 모든 환경에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f47a6753bc06d4318555d47c144bd14353686e3" translate="yes" xml:space="preserve">
          <source>Makes a hard link from &lt;code&gt;Existing&lt;/code&gt; to &lt;code&gt;New&lt;/code&gt; on platforms supporting links (Unix and Windows). This function returns &lt;code&gt;ok&lt;/code&gt; if the link was successfully created, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. On platforms not supporting links, &lt;code&gt;{error,enotsup}&lt;/code&gt; is returned.</source>
          <target state="translated">링크를 지원하는 플랫폼 (Unix 및 Windows) 에서 &lt;code&gt;Existing&lt;/code&gt; 에서 &lt;code&gt;New&lt;/code&gt; 로 하드 링크를 만듭니다 . 링크가 성공적으로 작성되면 이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고, 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 리턴합니다 . 링크를 지원하지 않는 플랫폼에서는 &lt;code&gt;{error,enotsup}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="31595caf2c636a46957c7deabbd5e7359493a864" translate="yes" xml:space="preserve">
          <source>Makes a map term from the given keys and values.</source>
          <target state="translated">주어진 키와 값으로 맵 용어를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5faa6d950f146c4cea5b655391ad27bfb6046562" translate="yes" xml:space="preserve">
          <source>Makes a node into a hidden node.</source>
          <target state="translated">노드를 숨겨진 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bff410db84d22381d23b1c5efa073c2289972394" translate="yes" xml:space="preserve">
          <source>Makes a pid term from &lt;code&gt;*pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; 에서 pid 용어를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7dd7181219d969635c334047d9c09a9edcb4c4b1" translate="yes" xml:space="preserve">
          <source>Makes a printout of all interpreted modules. Modules are printed together with the full path name of the corresponding source code file.</source>
          <target state="translated">해석 된 모든 모듈을 인쇄합니다. 모듈은 해당 소스 코드 파일의 전체 경로 이름과 함께 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="401f2043961677427104b10d6d8254a7b9499556" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using long node names.</source>
          <target state="translated">긴 노드 이름을 사용하여 런타임 시스템을 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bcf8732784b73fa9047c7ff22861f746856adbaa" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using short node names.</source>
          <target state="translated">짧은 노드 이름을 사용하여 런타임 시스템을 노드로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dd9eb421a3c6821005298718ecb81d1924332eb6" translate="yes" xml:space="preserve">
          <source>Makes a subbinary of binary &lt;code&gt;bin_term&lt;/code&gt;, starting at zero-based position &lt;code&gt;pos&lt;/code&gt; with a length of &lt;code&gt;size&lt;/code&gt; bytes. &lt;code&gt;bin_term&lt;/code&gt; must be a binary or bitstring. &lt;code&gt;pos+size&lt;/code&gt; must be less or equal to the number of whole bytes in &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">이진의 subbinary 만든다 &lt;code&gt;bin_term&lt;/code&gt; 제로 위치에서 시작하여, &lt;code&gt;pos&lt;/code&gt; 의 길이와 &lt;code&gt;size&lt;/code&gt; 바이트. &lt;code&gt;bin_term&lt;/code&gt; 은 이진 또는 비트 열 이어야합니다. &lt;code&gt;pos+size&lt;/code&gt; 는 &lt;code&gt;bin_term&lt;/code&gt; 의 전체 바이트 수보다 작거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1da6e2cfd5a96004af2990791a93360f29c745d3" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to all &lt;code&gt;gen_server&lt;/code&gt; processes locally registered as &lt;code&gt;Name&lt;/code&gt; at the specified nodes by first sending a request to every node and then waits for the replies. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">먼저 모든 노드에 요청을 보낸 후 지정된 노드에서 로컬로 &lt;code&gt;Name&lt;/code&gt; 으로 등록 된 모든 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 를 동기 호출 하여 응답을 기다립니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea1c1ab573f83f8ab3377d2d58aa5424f46f4767" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to event handler &lt;code&gt;Handler&lt;/code&gt; installed in event manager &lt;code&gt;EventMgrRef&lt;/code&gt; by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 종료가 발생할 때까지 대기하여 이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에 설치된 이벤트 핸들러 &lt;code&gt;Handler&lt;/code&gt; 대한 동기 호출을 작성 합니다. 이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 를 호출 하여 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f82c270c0090923069cb76b8c5ac5d301204fbd0" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;ServerRef&lt;/code&gt; of the &lt;code&gt;gen_server&lt;/code&gt; process by sending a request and waiting until a reply arrives or a time-out occurs. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">요청을 보내고 응답이 도착하거나 시간 종료가 발생할 때까지 대기 하여 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 &lt;code&gt;ServerRef&lt;/code&gt; 에 대한 동기 호출을 작성 합니다. &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e047abadcd4125bf1a47c5e3a18f5763c2f66409" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; by sending a request and waiting until its reply arrives. The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">요청을 보내고 응답이 도착할 때까지 대기 하여 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 에 대한 동기 호출을 작성합니다 . &lt;code&gt;gen_statem&lt;/code&gt; 가 부르는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 및 이벤트 콘텐츠 &lt;code&gt;Request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e97befb3fc0e650a9c087f592d9705da519e48" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the channel process by sending a message and waiting until a reply arrives, or a time-out occurs. The channel calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the message. If the channel process does not exist, &lt;code&gt;{error, closed}&lt;/code&gt; is returned.</source>
          <target state="translated">메시지를 전송하고 응답이 도착할 때까지 또는 시간 종료가 발생할 때까지 대기하여 채널 프로세스에 대한 동기 호출을 작성합니다. 채널 은 메시지를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 호출 합니다. 채널 프로세스가 존재하지 않으면 &lt;code&gt;{error, closed}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb060cc8d8a3df5d96be3f4fcf2d8f7d2bded14f" translate="yes" xml:space="preserve">
          <source>Makes a trace pattern suitable to feed change_pattern/1</source>
          <target state="translated">트레이스 패턴을 change_pattern / 1에 공급하기에 적합하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ea447adb75c049935be0ade2d24d0e02a46cb4ff" translate="yes" xml:space="preserve">
          <source>Makes all the preprocessor macros of EUnit available, to help writing tests</source>
          <target state="translated">테스트 작성을 돕기 위해 EUnit의 모든 전 처리기 매크로를 사용 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="97e3039873bad96bb14bae33094fcd93e52bc160" translate="yes" xml:space="preserve">
          <source>Makes all warnings into errors.</source>
          <target state="translated">모든 경고를 오류로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="247956d646f73c5083d686557419faaf07611729" translate="yes" xml:space="preserve">
          <source>Makes an empty map term.</source>
          <target state="translated">빈 맵 용어를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48107dc847232e089a1763920ba9c6eb752826f4" translate="yes" xml:space="preserve">
          <source>Makes an existing process an &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process. Does not return, instead the calling process enters the &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process receive loop and become an &lt;code&gt;ssh_client_channel&lt;/code&gt; process. The process must have been started using one of the start functions in &lt;code&gt;proc_lib&lt;/code&gt;, see the &lt;code&gt;proc_lib(3)&lt;/code&gt; manual page in STDLIB. The user is responsible for any initialization of the process and must call &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 프로세스를 &lt;code&gt;ssh_client_channel&lt;/code&gt; (ssh_channel 대체) 프로세스로 만듭니다. 리턴하지 않고 대신 호출 프로세스는 &lt;code&gt;ssh_client_channel&lt;/code&gt; (ssh_channel을 대체 함) 프로세스 수신 루프로 &lt;code&gt;ssh_client_channel&lt;/code&gt; 프로세스가됩니다. 프로세스는 &lt;code&gt;proc_lib&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작해야합니다 . &lt;code&gt;proc_lib(3)&lt;/code&gt; 의 proc_lib (3) 매뉴얼 페이지를 참조하십시오. 사용자는 프로세스 초기화에 대한 책임이 있으며 &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22bc96ed22188f42e5c515e5da6efb8258670300" translate="yes" xml:space="preserve">
          <source>Makes an existing process into a &lt;code&gt;gen_server&lt;/code&gt; process. Does not return, instead the calling process enters the &lt;code&gt;gen_server&lt;/code&gt; process receive loop and becomes a &lt;code&gt;gen_server&lt;/code&gt; process. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">기존 프로세스를 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 로 만듭니다 . 리턴하지 않고 대신 호출 프로세스는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 수신 루프로 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가됩니다. 프로세스 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작 &lt;strong&gt;해야합니다&lt;/strong&gt; . 사용자는 프로세스의 이름 등록을 포함하여 프로세스의 초기화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca23188a55ed798e178a8cdc711ee096dc651317" translate="yes" xml:space="preserve">
          <source>Makes another copy of a table at the node &lt;code&gt;Node&lt;/code&gt;. Argument &lt;code&gt;Type&lt;/code&gt; must be either of the atoms &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, or &lt;code&gt;disc_only_copies&lt;/code&gt;. For example, the following call ensures that a disc replica of the &lt;code&gt;person&lt;/code&gt; table also exists at node &lt;code&gt;Node&lt;/code&gt;:</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에 테이블의 다른 사본을 만듭니다 . 인수 &lt;code&gt;Type&lt;/code&gt; 은 원자 &lt;code&gt;ram_copies&lt;/code&gt; , &lt;code&gt;disc_copies&lt;/code&gt; 또는 &lt;code&gt;disc_only_copies&lt;/code&gt; 중 하나 여야합니다 . 예를 들어, 다음 호출은 &lt;code&gt;person&lt;/code&gt; 테이블 의 디스크 복제본이 노드 &lt;code&gt;Node&lt;/code&gt; 에도 존재 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="aa974f84878c85c9522eb437dfa9236890e3b59a" translate="yes" xml:space="preserve">
          <source>Makes any process created by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_spawn&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 작성된 프로세스가 플래그 &lt;code&gt;set_on_spawn&lt;/code&gt; 을 포함하여 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="d6fe67417b1a2349e7be32124ba5fe55fba98791" translate="yes" xml:space="preserve">
          <source>Makes any process linked by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_link&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 링크 된 프로세스가 플래그 &lt;code&gt;set_on_link&lt;/code&gt; 를 포함하여 해당 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="81962eacd7a836ddf3c4da74a5b02410645fe00a" translate="yes" xml:space="preserve">
          <source>Makes copies of the source file for the given modules, where it for each executable line is specified how many times it has been executed.</source>
          <target state="translated">주어진 모듈에 대한 소스 파일의 사본을 작성합니다. 여기서 각 실행 파일 라인에 대해 실행 횟수가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="91fe360029900348adebe5c87f81ee0c4d1d7bfa" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle removal of releases outside the release handler. Tells the release handler that the release is removed from the system. This function does not delete any files.</source>
          <target state="translated">릴리스 핸들러 외부에서 릴리스 제거를 처리 할 수 ​​있습니다. 릴리스 핸들러가 릴리스가 시스템에서 제거되었음을 알려줍니다. 이 기능은 파일을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8d3cd6f1fa13ad3388a331a2a27038c3db886f4" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle unpacking of releases outside the release handler. Tells the release handler that the release is unpacked. &lt;code&gt;Vsn&lt;/code&gt; is extracted from the release resource file &lt;code&gt;RelFile&lt;/code&gt;.</source>
          <target state="translated">릴리스 핸들러 외부에서 릴리스 풀기를 처리 할 수 ​​있습니다. 릴리스 처리기에 릴리스가 압축 해제되었음을 알립니다. 릴리스 자원 파일 &lt;code&gt;RelFile&lt;/code&gt; 에서 &lt;code&gt;Vsn&lt;/code&gt; 이 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="550cc3842fa85cd7551150ef1a3ffbb8ecf08f4e" translate="yes" xml:space="preserve">
          <source>Makes it possible to read or write gzip compressed files. Option &lt;code&gt;compressed&lt;/code&gt; must be combined with &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;, but not both. Notice that the file size obtained with &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; does probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">gzip 압축 파일을 읽거나 쓸 수 있습니다. &lt;code&gt;compressed&lt;/code&gt; 옵션 은 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 와 결합해야 하지만 둘다는 아닙니다. &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; 로 얻은 파일 크기 는 압축 파일에서 읽을 수있는 바이트 수와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c408fbb745313fb815eff80dafd2c1c61a239e" translate="yes" xml:space="preserve">
          <source>Makes necessary initializations and returns the initial channel state if the initializations succeed.</source>
          <target state="translated">초기화가 성공하면 필요한 초기화를 수행하고 초기 채널 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa89cf81f10044b652f143f54fcc25e4b34fd715" translate="yes" xml:space="preserve">
          <source>Makes the &lt;code&gt;efile&lt;/code&gt; loader write some debug information, such as the reason for failures, while it handles files.</source>
          <target state="translated">차종 &lt;code&gt;efile&lt;/code&gt; 이 파일을 처리하는 동안, 이러한 실패에 대한 이유와 같은 일부 디버그 정보를 작성 로더.</target>
        </trans-unit>
        <trans-unit id="d304b67681b86e2abd50ebc5b49fc156fedec9bb" translate="yes" xml:space="preserve">
          <source>Makes the Erlang emulator be restarted (with whatever parameters are registered for the service at the occasion) when it stops. If the emulator stops again within 10 seconds, it is not restarted to avoid an infinite loop, which could hang the Windows system.</source>
          <target state="translated">Erlang 에뮬레이터가 중지 될 때 서비스에 등록 된 매개 변수를 사용하여 다시 시작합니다. 에뮬레이터가 10 초 내에 다시 중지되면 무한 루프를 피하기 위해 다시 시작되지 않아 Windows 시스템이 정지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a7e58acd1b6273937af4828973ccfe2aa9acaf" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node, similar to &lt;code&gt;-name&lt;/code&gt;, but the host name portion of the node name &lt;code&gt;Name@Host&lt;/code&gt; will be the short name, not fully qualified.</source>
          <target state="translated">Erlang 런타임 시스템을 &lt;code&gt;-name&lt;/code&gt; 과 유사한 분산 노드로 만들지 만 노드 이름 &lt;code&gt;Name@Host&lt;/code&gt; 의 호스트 이름 부분은 완전한 이름이 아닌 짧은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f7aa031d2e4d7c3b20a440dd107fb282795ac6f0" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node. This flag invokes all network servers necessary for a node to become distributed; see &lt;code&gt;net_kernel(3)&lt;/code&gt;. It is also ensured that &lt;code&gt;epmd&lt;/code&gt; runs on the current host before Erlang is started; see &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt;.and the &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">Erlang 런타임 시스템을 분산 노드로 만듭니다. 이 플래그는 노드가 분배되는 데 필요한 모든 네트워크 서버를 호출합니다. &lt;code&gt;net_kernel(3)&lt;/code&gt; 참조하십시오 . Erlang이 시작되기 전에 &lt;code&gt;epmd&lt;/code&gt; 가 현재 호스트에서 실행 되도록 보장합니다 . &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8a750500054d695ef79dc67c8e3f89388948a20" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system invoke &lt;code&gt;make:all()&lt;/code&gt; in the current working directory and then terminate; see &lt;code&gt;make(3)&lt;/code&gt;. Implies &lt;code&gt;-noinput&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템 이 현재 작업 디렉토리에서 &lt;code&gt;make:all()&lt;/code&gt; 을 호출 한 다음 종료합니다. &lt;code&gt;make(3)&lt;/code&gt; 참조하십시오 . &lt;code&gt;-noinput&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="c606e85ac2aed92be8eb1ce19cdcab5a15e4f9b9" translate="yes" xml:space="preserve">
          <source>Makes the array resizable. (Reverses the effects of &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">배열 크기를 조정할 수 있습니다. ( &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt; 의 효과를 되돌 립니다.)</target>
        </trans-unit>
        <trans-unit id="ab845853493a2c837853fd6b3e8f0aaa392fd64f" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; active.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Line&lt;/code&gt; 에서 중단 점을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="66efe312d73a33922588677a593f505e5441c8f3" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; inactive.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Line&lt;/code&gt; 에서 중단 점을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4197e2c90774db9c9ce91b8b094791dfa882c29c" translate="yes" xml:space="preserve">
          <source>Makes the calling process become a &lt;code&gt;gen_statem&lt;/code&gt;. Does not return, instead the calling process enters the &lt;code&gt;gen_statem&lt;/code&gt; receive loop and becomes a &lt;code&gt;gen_statem&lt;/code&gt; server. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;gen_statem&lt;/code&gt; 이되도록합니다 . 리턴하지 않고 호출 프로세스는 &lt;code&gt;gen_statem&lt;/code&gt; 수신 루프로 &lt;code&gt;gen_statem&lt;/code&gt; 서버가됩니다. 프로세스 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 의 시작 함수 중 하나를 사용하여 시작 &lt;strong&gt;해야합니다&lt;/strong&gt; . 사용자는 프로세스의 이름 등록을 포함하여 프로세스의 초기화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7816dd7bfd9f71c9801ecdf559eb8559d1fd39dd" translate="yes" xml:space="preserve">
          <source>Makes the current code for &lt;code&gt;Module&lt;/code&gt; become old code and deletes all references for this module from the export table. Returns &lt;code&gt;undefined&lt;/code&gt; if the module does not exist, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 현재 코드를 오래된 코드로 만들고 내보내기 모듈에서이 모듈에 대한 모든 참조를 삭제합니다. 모듈이 존재하지 않으면 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하고, 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffc4bee79fb8820e1fdd4f31e40972ffd12cfcd" translate="yes" xml:space="preserve">
          <source>Makes the current version of &lt;code&gt;Mod&lt;/code&gt; old. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">&lt;code&gt;Mod&lt;/code&gt; 의 현재 버전을 이전 버전으로 만듭니다 . &lt;code&gt;PrePurge&lt;/code&gt; 가 무시됩니다. &lt;code&gt;PostPurge&lt;/code&gt; 에 대한 설명은 앞서 고급 명령 &lt;code&gt;update&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ccf5b40e3c580610c11910676d267ac96338b9" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number.</source>
          <target state="translated">에뮬레이터의 버전 번호를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="03fcc3406838240ad7e71ecfcf6e7cb062a03c52" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number. The same as &lt;code&gt;erl +V&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터의 버전 번호를 인쇄합니다. &lt;code&gt;erl +V&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0c6eda41af82625c188e23faff139b871d0dc271" translate="yes" xml:space="preserve">
          <source>Makes the file perform automatic translation of characters to and from a specific (Unicode) encoding. Notice that the data supplied to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; or returned by &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; still is byte-oriented; this option denotes only how data is stored in the disk file.</source>
          <target state="translated">파일이 특정 (유니 코드) 인코딩과의 문자 자동 변환을 수행하도록합니다. &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 에 제공 되거나 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 데이터 는 바이트 지향입니다. 이 옵션은 디스크 파일에 데이터가 저장되는 방법 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce1b5535c27729e37b24da5577a1e2edda190797" translate="yes" xml:space="preserve">
          <source>Makes the first process created by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스로 작성된 첫 번째 프로세스가 플래그 &lt;code&gt;set_on_first_spawn&lt;/code&gt; 을 제외한 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="51a7e91b712508eac0b349f8e399224c503bf1a3" translate="yes" xml:space="preserve">
          <source>Makes the first process linked to by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_link&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스에 의해 링크 된 첫 번째 프로세스가 플래그 &lt;code&gt;set_on_first_link&lt;/code&gt; 를 제외하고 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="699e692edb812c99776e6de21b71da2e27456acb" translate="yes" xml:space="preserve">
          <source>Makes the function &lt;code&gt;F/A&lt;/code&gt; no longer being auto-imported from the &lt;code&gt;erlang&lt;/code&gt; module, which resolves BIF name clashes. This option must be used to resolve name clashes with BIFs auto-imported before R14A, if it is needed to call the local function with the same name as an auto-imported BIF without module prefix.</source>
          <target state="translated">&lt;code&gt;erlang&lt;/code&gt; 모듈 에서 &lt;code&gt;F/A&lt;/code&gt; 기능을 더 이상 자동으로 가져 오지 않게하여 BIF 이름 충돌을 해결합니다. 모듈 접두어없이 자동 가져온 BIF와 동일한 이름의 로컬 함수를 호출해야하는 경우이 옵션을 사용하여 R14A 이전에 자동으로 가져온 BIF와 이름 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ad0c7129eb3658b1728b9b552dafdedadbc94c1" translate="yes" xml:space="preserve">
          <source>Makes the process &lt;code&gt;Pid&lt;/code&gt; leave the group &lt;code&gt;Name&lt;/code&gt;. If the process is not a member of the group, &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 가 그룹 &lt;code&gt;Name&lt;/code&gt; 을 떠나도록합니다 . 프로세스가 그룹의 구성원이 아닌 경우 &lt;code&gt;ok&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="45ad2871084bc4b367921bd684d396b4d847881d" translate="yes" xml:space="preserve">
          <source>Makes the specified release version &lt;code&gt;Vsn&lt;/code&gt; permanent.</source>
          <target state="translated">지정된 릴리스 버전 &lt;code&gt;Vsn&lt;/code&gt; 을 영구적으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2f4cd63c2b38297a9b1944489ca49b98d5502133" translate="yes" xml:space="preserve">
          <source>Makes the transaction silently return the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;. Termination of a Mnesia transaction means that an exception is thrown to an enclosing &lt;code&gt;catch&lt;/code&gt;. Thus, the expression &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; does not terminate the transaction.</source>
          <target state="translated">트랜잭션이 자동으로 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 리턴하도록합니다 . Mnesia 트랜잭션이 종료되면 예외를 둘러싼 &lt;code&gt;catch&lt;/code&gt; 던집니다 . 따라서 &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; 표현식 은 트랜잭션을 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3c361414f40468ac17c2fe68754d480ca1bcf62" translate="yes" xml:space="preserve">
          <source>Making a hardware watchdog available</source>
          <target state="translated">하드웨어 워치 독 사용 가능</target>
        </trans-unit>
        <trans-unit id="a6b950fad26bf1993d43209bd38ff1959147aa83" translate="yes" xml:space="preserve">
          <source>Making calls from a &lt;code&gt;high&lt;/code&gt; priority process into code that you has no control over can cause the &lt;code&gt;high&lt;/code&gt; priority process to wait for a process with lower priority. That is, effectively decreasing the priority of the &lt;code&gt;high&lt;/code&gt; priority process during the call. Even if this is not the case with one version of the code that you have no control over, it can be the case in a future version of it. This can, for example, occur if a &lt;code&gt;high&lt;/code&gt; priority process triggers code loading, as the code server runs on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스에서 사용자가 제어 할 수없는 코드로 호출 하면 우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스가 우선 순위가 낮은 프로세스를 기다릴 수 있습니다 . 즉 , 통화 중 우선 순위 가 &lt;code&gt;high&lt;/code&gt; 프로세스 의 우선 순위를 효과적으로 낮추는 것 입니다. 제어 할 수없는 코드의 한 버전에서는 그렇지 않은 경우에도 다음 버전에서는 해당 될 수 있습니다. 예를 들어, 코드 서버가 우선 순위 &lt;code&gt;normal&lt;/code&gt; 로 실행될 때 &lt;code&gt;high&lt;/code&gt; 우선 순위 프로세스가 코드로드를 트리거 하는 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31c6d1769fe27f5b364867a2ba03a8a0ce740773" translate="yes" xml:space="preserve">
          <source>Making requests without checking that the return value indicates success can be OK if the test case fails later, but it is never acceptable just to print an error message (into the log file) and return successfully. Such test cases do harm, as they create a false sense of security when overviewing the test results.</source>
          <target state="translated">테스트 케이스가 나중에 실패하면 리턴 값이 성공을 나타내는 지 확인하지 않고 요청하는 것이 좋지만, 오류 메시지를 로그 파일에 인쇄하여 성공적으로 리턴하는 것은 결코 허용되지 않습니다. 이러한 테스트 사례는 테스트 결과를 개괄 할 때 잘못된 보안 감각을 생성하므로 피해를줍니다.</target>
        </trans-unit>
        <trans-unit id="2d4f453eee7e2dd34a8e386a2b75375fa105539c" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor/2&lt;/code&gt; for the same &lt;code&gt;Item&lt;/code&gt; and/or &lt;code&gt;Type&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">동일한 &lt;code&gt;Item&lt;/code&gt; 및 / 또는 &lt;code&gt;Type&lt;/code&gt; 대해 &lt;code&gt;monitor/2&lt;/code&gt; 를 여러 번 호출하는 것은 오류가 아닙니다. 독립적 인 모니터링 인스턴스가 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="466c358751442005c7e7d386e4d7e639cbf1ac39" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; for the same &lt;code&gt;Node&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">동일한 &lt;code&gt;Node&lt;/code&gt; 대해 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 를 여러 번 호출 해도 오류가 아닙니다. 독립적 인 모니터링 인스턴스가 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c730df3afaaac142f305e8f798eca241f12abf9f" translate="yes" xml:space="preserve">
          <source>Malayalam</source>
          <target state="translated">Malayalam</target>
        </trans-unit>
        <trans-unit id="eef68d8ca2c02e4bd3d5725888ca18ccdc7ca252" translate="yes" xml:space="preserve">
          <source>Manage a &lt;code&gt;Trace Pattern&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Trace Pattern&lt;/code&gt; 관리</target>
        </trans-unit>
        <trans-unit id="ff5123b141ff090ff835a7f30332c3740b2707e5" translate="yes" xml:space="preserve">
          <source>Manager configuration:</source>
          <target state="translated">관리자 구성 :</target>
        </trans-unit>
        <trans-unit id="65a4a223a80dcdb4faa701bab0904a7145c7139e" translate="yes" xml:space="preserve">
          <source>Manager specific config options and types:</source>
          <target state="translated">관리자 별 구성 옵션 및 유형 :</target>
        </trans-unit>
        <trans-unit id="63617cfe427854e42387ca5fb2dd42a8d02042c4" translate="yes" xml:space="preserve">
          <source>Mandaic</source>
          <target state="translated">Mandaic</target>
        </trans-unit>
        <trans-unit id="4c2ea2d10dc0ede0423eff4ee1aac7300cd7cc28" translate="yes" xml:space="preserve">
          <source>Mandatory</source>
          <target state="translated">Mandatory</target>
        </trans-unit>
        <trans-unit id="55779720bd078b43fecc03c38a4dee19d2f0260c" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema contains only the definition of the schema table and resides on the local node only. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes. (Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc-full nodes.)</source>
          <target state="translated">필수 RAM. 스키마는 RAM에만 있습니다. 시작할 때 작은 새 스키마가 생성됩니다. 이 기본 스키마는 스키마 테이블의 정의 만 포함하며 로컬 노드에만 상주합니다. 기본 스키마에 다른 노드가 없으므로 구성 매개 변수 &lt;code&gt;extra_db_nodes&lt;/code&gt; 를 사용하여 노드가 테이블 정의를 다른 노드와 공유 할 수 있도록해야합니다. 디스크 &lt;code&gt;extra_db_nodes&lt;/code&gt; 노드에서 extra_db_nodes 매개 변수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7f5fd2af32ce149c0ca960148e8bf3bd0f1d1a" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema only contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes.</source>
          <target state="translated">필수 RAM. 스키마는 RAM에만 있습니다. 시작할 때 작은 새 스키마가 생성됩니다. 이 기본 스키마는 스키마 테이블의 정의 만 포함하며 로컬 노드에만 상주합니다. 기본 스키마에 다른 노드가 없으므로 구성 매개 변수 &lt;code&gt;extra_db_nodes&lt;/code&gt; 를 사용하여 노드가 테이블 정의를 다른 노드와 공유 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd245892c4cf7481ff0b76736f06f016f9538140" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the &lt;code&gt;Mnesia&lt;/code&gt; directory. If the schema cannot be found, &lt;code&gt;Mnesia&lt;/code&gt; refuses to start.</source>
          <target state="translated">필수 디스크. 스키마는 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리 에 있다고 가정합니다 . 스키마를 찾을 수 없으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 시작을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="056c789bb6261a61e562f98c5294a028b2c27e2a" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the Mnesia directory. If the schema cannot be found, Mnesia refuses to start. This is the old behavior.</source>
          <target state="translated">필수 디스크. 스키마는 Mnesia 디렉토리에 있다고 가정합니다. 스키마를 찾을 수 없으면 Mnesia는 시작을 거부합니다. 이것은 오래된 행동입니다.</target>
        </trans-unit>
        <trans-unit id="9bf3e3f7107080f2dd0decda36be42d7dcd887d3" translate="yes" xml:space="preserve">
          <source>Mandatory if &lt;code&gt;-reldir&lt;/code&gt; is not specified and no &lt;code&gt;RELDIR&lt;/code&gt; exists in the environment. This specifies the Erlang installation root directory (under which the &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt;, and &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; directories are located). If only &lt;code&gt;-reldir&lt;/code&gt; (or environment variable &lt;code&gt;RELDIR&lt;/code&gt;) is specified, the Erlang root is assumed to be the directory exactly one level above the release directory.</source>
          <target state="translated">필수 경우 &lt;code&gt;-reldir&lt;/code&gt; 가 지정되지 않고 &lt;code&gt;RELDIR&lt;/code&gt; 이 환경에 존재하지 않습니다. 이는 Erlang 설치 루트 디렉토리 ( &lt;code&gt;lib&lt;/code&gt; , &lt;code&gt;releases&lt;/code&gt; 및 &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; 디렉토리가있는 디렉토리)를 지정합니다. 경우에만 &lt;code&gt;-reldir&lt;/code&gt; (또는 환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 가 ) 지정, 얼랭 루트는 디렉토리 릴리즈 디렉토리 위 정확히 하나 개의 레벨로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="27228686f00efd9069abdd5d3e934b51d59f64a9" translate="yes" xml:space="preserve">
          <source>Mandatory if environment variable &lt;code&gt;RELDIR&lt;/code&gt; is not specified and no &lt;code&gt;-rootdir&lt;/code&gt; option is specified. Tells &lt;code&gt;start_erl&lt;/code&gt; where the root of the release tree is located in the file system (typically &amp;lt;Erlang root&amp;gt;\\releases). The &lt;code&gt;start_erl.data&lt;/code&gt; file is expected to be located in this directory (unless otherwise specified). If only option &lt;code&gt;-rootdir&lt;/code&gt; is specified, the directory is assumed to be &amp;lt;Erlang root&amp;gt;\\releases.</source>
          <target state="translated">환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 이 지정되지 않고 &lt;code&gt;-rootdir&lt;/code&gt; 옵션이 지정 되지 않은 경우 필수 입니다. 릴리스 트리의 루트가 파일 시스템에서 어디에 있는지 (일반적으로 &amp;lt;Erlang root&amp;gt; \\ releases) &lt;code&gt;start_erl&lt;/code&gt; 에 알려줍니다 . &lt;code&gt;start_erl.data&lt;/code&gt; 파일 (달리 명시되지 않는 한)이 디렉토리에 위치 할 것으로 예상된다. &lt;code&gt;-rootdir&lt;/code&gt; 옵션 만 지정하면 디렉토리는 &amp;lt;Erlang root&amp;gt; \\ releases로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d51f3b74b92dcfdb5b928a635f84a5f51200457c" translate="yes" xml:space="preserve">
          <source>Mandatory. Delimits &lt;code&gt;start_erl&lt;/code&gt; options from normal Erlang options. Everything on the command line &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to be sent to the &lt;code&gt;erl&lt;/code&gt; program. Everything &lt;strong&gt;after&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to &lt;code&gt;start_erl&lt;/code&gt; itself.</source>
          <target state="translated">필수. 구분합니다은 &lt;code&gt;start_erl&lt;/code&gt; 정상 얼랑 옵션에서 옵션을. &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;이전&lt;/strong&gt; 의 명령 행에있는 모든 것은 &lt;code&gt;erl&lt;/code&gt; 프로그램에 전송되는 옵션으로 해석됩니다 . &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;이후의&lt;/strong&gt; 모든 것은 &lt;code&gt;start_erl&lt;/code&gt; 자체에 대한 옵션으로 해석 됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc48591fe7588ae910f82a8e32e5898f8b677543" translate="yes" xml:space="preserve">
          <source>Mandatory: one or more</source>
          <target state="translated">필수 : 하나 이상</target>
        </trans-unit>
        <trans-unit id="40331ec2ec252f48c8769280f8a9d0addf85621c" translate="yes" xml:space="preserve">
          <source>Manichaean</source>
          <target state="translated">Manichaean</target>
        </trans-unit>
        <trans-unit id="1a83f62a1c9d2ea7c7b76528168eeb1027e1c303" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls and by extension the result of the test themselves.</source>
          <target state="translated">모든 스위트 구성 호출의 리턴 및 확장하여 테스트 결과를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="a70642b028568014a36d3c8b54782719d4573d07" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls, and in extension, the result of the tests themselves.</source>
          <target state="translated">모든 스위트 구성 호출의 리턴 및 확장 된 테스트 결과를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="28533b136858ffce59b77b52f8bc0d5d5c92201b" translate="yes" xml:space="preserve">
          <source>Manipulate the runtime configuration before each suite configuration call.</source>
          <target state="translated">각 스위트 구성 호출 전에 런타임 구성을 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="a777446b5191e48dad7cad24722806c79d3f271e" translate="yes" xml:space="preserve">
          <source>Manipulation of data represented as Erlang data types</source>
          <target state="translated">Erlang 데이터 유형으로 표시되는 데이터 조작</target>
        </trans-unit>
        <trans-unit id="8d09db94e4c55d4786f4570130a4d22ac51744f7" translate="yes" xml:space="preserve">
          <source>Manner in which incoming answer messages containing decode errors are handled.</source>
          <target state="translated">디코드 오류가 포함 된 수신 응답 메시지가 처리되는 방식.</target>
        </trans-unit>
        <trans-unit id="6284d04575c3819f39fde9f65fd471b9435e0ad1" translate="yes" xml:space="preserve">
          <source>Manner in which incoming requests are handled when an error other than 3007 (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module), is detected.</source>
          <target state="translated">3007 이외의 오류 (DIAMETER_APPLICATION_UNSUPPORTED, 응용 프로그램 콜백 모듈과 연관 될 수 없음)가 감지 될 때 들어오는 요청이 처리되는 방식.</target>
        </trans-unit>
        <trans-unit id="5351cf3c5581dd875efa06c896ad751d99613d56" translate="yes" xml:space="preserve">
          <source>Manually performs a mib server cache gc. This can be done regardless of the value of the &lt;code&gt;autogc&lt;/code&gt; option. The &lt;code&gt;NumElementsGCed&lt;/code&gt; value indicates how many elements where actually removed from the cache.</source>
          <target state="translated">mib 서버 캐시 gc를 수동으로 수행합니다. &lt;code&gt;autogc&lt;/code&gt; 옵션 의 값에 관계없이 수행 할 수 있습니다 . &lt;code&gt;NumElementsGCed&lt;/code&gt; 의 값은 실제로 캐시에서 제거 얼마나 많은 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5c7ebf32bd378c4ba16c49e6124169115f258a7" translate="yes" xml:space="preserve">
          <source>Many assertions (of any sort) can occur in succession. For example, the following matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;:</source>
          <target state="translated">많은 종류의 주장이 연속적으로 발생할 수 있습니다. 예를 들어, 다음은 &quot;foo&quot;앞에 &quot;999&quot;가 아닌 세 자리 숫자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7f887661a9b51d0d5237dac908440eb7b836be70" translate="yes" xml:space="preserve">
          <source>Many driver API functions have changed argument type and/or return value to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from mostly &lt;code&gt;int&lt;/code&gt;. Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">많은 드라이버 API 함수가 인수 유형 및 / 또는 반환 값을 대부분 &lt;code&gt;int&lt;/code&gt; 에서 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 로 변경했습니다 . 자동 유형 캐스팅은 크기가 32 비트보다 큰 드라이버에만 이러한 변경이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56029af12913d9bc7ea74d4914ee32e80f6707df" translate="yes" xml:space="preserve">
          <source>Many list comprehension expressions can be evaluated by the &lt;code&gt;qlc&lt;/code&gt; module. Exceptions are expressions, such that variables introduced in patterns (or filters) are used in some generator later in the list comprehension. As an example, consider an implementation of &lt;code&gt;lists:append(L)&lt;/code&gt;: &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt;. &lt;code&gt;Y&lt;/code&gt; is introduced in the first generator and used in the second. The ordinary list comprehension is normally to be preferred when there is a choice as to which to use. One difference is that &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; collects answers in a list that is finally reversed, while list comprehensions collect answers on the stack that is finally unwound.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈 은 많은 목록 이해 표현식을 평가할 수 있습니다 . 예외는 패턴 (또는 필터)에 도입 된 변수가 나중에 목록 이해의 일부 생성기에서 사용되도록하는 표현식입니다. 예를 들어, &lt;code&gt;lists:append(L)&lt;/code&gt; : &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt; 구현을 고려하십시오 . &lt;code&gt;Y&lt;/code&gt; 는 첫 번째 발전기에 도입되어 두 번째 발전기에 사용됩니다. 일반적인 목록 이해는 일반적으로 사용할 선택이있을 때 선호됩니다. 한 가지 차이점은 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; 는 최종적으로 뒤집힌 목록에서 답변을 수집하고 목록 이해력은 최종적으로 풀린 스택에서 답변을 수집한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a3eae152029d738a0ebe7e23d689a8ac8f03946" translate="yes" xml:space="preserve">
          <source>Many nice things can be done with the iterator functions but take some caution about performance and memory use for large tables.</source>
          <target state="translated">반복자 함수를 사용하여 많은 유용한 작업을 수행 할 수 있지만 큰 테이블의 성능 및 메모리 사용에주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="9fdf7f9f32446c75f533a26900329aea292fc48d" translate="yes" xml:space="preserve">
          <source>Many of the operators can only be applied to arguments of a certain type. For example, arithmetic operators can only be applied to numbers. An argument of the wrong type causes a &lt;code&gt;badarg&lt;/code&gt; runtime error.</source>
          <target state="translated">많은 연산자는 특정 유형의 인수에만 적용될 수 있습니다. 예를 들어, 산술 연산자는 숫자에만 적용 할 수 있습니다. 잘못된 유형의 인수는 원인 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="f2f1df17f07587c5055c0ce8c9221879d8708726" translate="yes" xml:space="preserve">
          <source>Many of the output functions have a &quot;header buffer&quot;, with &lt;code&gt;hbuf&lt;/code&gt; and &lt;code&gt;hlen&lt;/code&gt; parameters. This buffer is sent as a list before the binary (or list, depending on port mode) that is sent. This is convenient when matching on messages received from the port. (Although in the latest Erlang versions there is the binary syntax, which enables you to match on the beginning of a binary.)</source>
          <target state="translated">많은 출력 함수에는 &lt;code&gt;hbuf&lt;/code&gt; 및 &lt;code&gt;hlen&lt;/code&gt; 매개 변수 와 함께 &quot;헤더 버퍼&quot;가 있습니다. 이 버퍼는 전송 된 바이너리 (또는 포트 모드에 따라 목록) 이전에 목록으로 전송됩니다. 포트에서받은 메시지를 일치시킬 때 편리합니다. (최신 Erlang 버전에는 바이너리 구문이있어 바이너리의 시작 부분과 일치시킬 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="21b179b8985ad61d572fc99ea80a2e913e1d0bdd" translate="yes" xml:space="preserve">
          <source>Many operations communicating with a process executing a dirty NIF can, however, complete while it executes the dirty NIF. For example, retrieving information about it through &lt;code&gt;erlang:process_info&lt;/code&gt;, setting its group leader, register/unregister its name, and so on.</source>
          <target state="translated">그러나 더티 NIF를 실행하는 프로세스와 통신하는 많은 작업은 더티 NIF를 실행하는 동안 완료 될 수 있습니다. 예를 들어, &lt;code&gt;erlang:process_info&lt;/code&gt; 를 통해 정보를 검색 하고 그룹 리더를 설정하고 이름을 등록 / 등록 취소하는 등의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f86703eb2414253099183ba096ef8f59d855dec4" translate="yes" xml:space="preserve">
          <source>Many restrictions apply to the fun that is translated into a match specification. To put it simple: you cannot use anything in the fun that you cannot use in a match specification. This means that, among others, the following restrictions apply to the fun itself:</source>
          <target state="translated">일치 사양으로 변환되는 재미에는 많은 제한이 적용됩니다. 간단히 말하면 : 일치 사양에서 사용할 수없는 재미로는 아무것도 사용할 수 없습니다. 이는 특히 재미 자체에 다음과 같은 제한 사항이 적용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b3277af475a535b5e15ac96f9ce422da3543b8bc" translate="yes" xml:space="preserve">
          <source>Many small test cases tend to result in extra, and possibly duplicated code, as well as slow test execution because of large overhead for initializations and cleanups. Avoid duplicated code, for example, by using common help functions. Otherwise, the resulting suite becomes difficult to read and understand, and expensive to maintain.</source>
          <target state="translated">많은 작은 테스트 사례는 초기화 및 정리에 대한 오버 헤드가 커서 테스트 실행 속도가 느릴뿐만 아니라 추가 코드 및 중복 코드를 생성하는 경향이 있습니다. 예를 들어 일반적인 도움말 기능을 사용하여 중복 코드를 피하십시오. 그렇지 않으면 결과 제품군은 읽고 이해하기 어렵고 유지 관리 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="f4757731a17b024e345545fcb6d59364979c23d4" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications have unique requirements on lookup times for certain types of records. If the &lt;code&gt;Company&lt;/code&gt; database had been a part of a telecommunications system, it could be to minimize the lookup time of an employee &lt;strong&gt;together&lt;/strong&gt; with a list of the projects the employee is working on. If this is the case, a drastically different data model without direct relationships can be chosen. You would then have only the records themselves, and different records could contain either direct references to other records, or contain other records that are not part of the &lt;code&gt;Mnesia&lt;/code&gt; schema.</source>
          <target state="translated">많은 통신 응용 프로그램에는 특정 유형의 레코드에 대한 조회 시간에 대한 고유 한 요구 사항이 있습니다. 경우 &lt;code&gt;Company&lt;/code&gt; 데이터베이스가 통신 시스템의 한 부분이었다, 그것은 직원의 조회 시간을 최소화 할 수 있었다 &lt;strong&gt;함께&lt;/strong&gt; 직원이 작업하는 프로젝트의 목록. 이 경우 직접적인 관계가없는 매우 다른 데이터 모델을 선택할 수 있습니다. 그러면 레코드 자체 만 있고 다른 레코드에 다른 레코드에 대한 직접 참조가 포함되거나 &lt;code&gt;Mnesia&lt;/code&gt; 스키마 에 속하지 않은 다른 레코드가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68017d6821eb323d2063e3ce0fd2add46797e7ea" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications must be controlled and reconfigured remotely. It is sometimes an advantage to perform this remote control with an open protocol such as the Simple Network Management Protocol (SNMP). The alternatives to this would be the following:</source>
          <target state="translated">많은 통신 응용 프로그램을 원격으로 제어하고 재구성해야합니다. SNMP (Simple Network Management Protocol)와 같은 개방형 프로토콜로이 원격 제어를 수행하는 것이 때로는 유리합니다. 이에 대한 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7b004a583d02bc15f8db5aaa5239ed752c86ac6" translate="yes" xml:space="preserve">
          <source>Map holding the main components of a URI.</source>
          <target state="translated">URI의 주요 컴포넌트를 보유한 맵.</target>
        </trans-unit>
        <trans-unit id="f9636957ea9c74ef69d5b705de848b9cde84373e" translate="yes" xml:space="preserve">
          <source>Mapping of SNMPv2 error message to SNMPv1:</source>
          <target state="translated">SNMPv2 오류 메시지를 SNMPv1에 매핑 :</target>
        </trans-unit>
        <trans-unit id="c286942228a25588025573f075da4c09d52b9607" translate="yes" xml:space="preserve">
          <source>Maps are a set of key to value associations. These associations are encapsulated with &quot;#{&quot; and &quot;}&quot;. To create an association from &quot;key&quot; to value 42:</source>
          <target state="translated">지도는 가치 연관의 핵심입니다. 이러한 연결은 &quot;# {&quot;및 &quot;}&quot;로 캡슐화됩니다. &quot;키&quot;에서 값 42 로의 연관을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04b5c5dbf8eab96a0231ea5b92737fd2b0a1ce74" translate="yes" xml:space="preserve">
          <source>Maps are allowed in guards as long as all subexpressions are valid guard expressions.</source>
          <target state="translated">모든 하위 표현식이 유효한 가드 표현식 인 한 가드에서 맵이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="363ad38891c14a93a51e759557264fd84b9d27cc" translate="yes" xml:space="preserve">
          <source>Maps are considered to be experimental during Erlang/OTP R17.</source>
          <target state="translated">Erlang / OTP R17에서 맵은 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d13027fd4ebe765466d95071c641f5db67b026f6" translate="yes" xml:space="preserve">
          <source>Maps are ordered by size, two maps with the same size are compared by keys in ascending term order and then by values in key order. In maps key order integers types are considered less than floats types.</source>
          <target state="translated">맵은 크기별로 정렬되며 크기가 같은 두 맵은 키를 기준으로 오름차순으로 키를 기준으로 키순으로 값을 비교합니다. 맵에서 키 순서 정수 유형은 부동 유형보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d3761b3f052ddea8579fdb64072c5ede6d3ff627" translate="yes" xml:space="preserve">
          <source>Maps function F(K, V1) -&amp;gt; V2 to all key-value pairs of tree &lt;code&gt;Tree1&lt;/code&gt;. Returns a new tree &lt;code&gt;Tree2&lt;/code&gt; with the same set of keys as &lt;code&gt;Tree1&lt;/code&gt; and the new set of values &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">함수 F (K, V1)-&amp;gt; V2를 &lt;code&gt;Tree1&lt;/code&gt; 트리의 모든 키-값 쌍에 매핑 합니다. 새로운 트리를 돌려 &lt;code&gt;Tree2&lt;/code&gt; 은 같은 키의 동일한 세트 &lt;code&gt;Tree1&lt;/code&gt; 과 값의 새로운 &lt;code&gt;V2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729cd71fbff021f36308a64f8ae94d9a49e5da1b" translate="yes" xml:space="preserve">
          <source>Maps processing</source>
          <target state="translated">지도 처리</target>
        </trans-unit>
        <trans-unit id="7ea86ddec10f80bb2c7782afe4921fda0718970f" translate="yes" xml:space="preserve">
          <source>Maps processing functions.</source>
          <target state="translated">지도 처리 기능.</target>
        </trans-unit>
        <trans-unit id="6501b098152b10c2d1fd7868786d299194e00b4a" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수를 각 배열 요소에 매핑하고 기본값이 지정된 항목을 건너 뜁니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="7d1791268d9973c2080f7cdeef13debd8dce8751" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수를 각 배열 요소에 매핑합니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="31e9697d43a1a66f2e45db652019fb9a6216df22" translate="yes" xml:space="preserve">
          <source>Mark</source>
          <target state="translated">Mark</target>
        </trans-unit>
        <trans-unit id="10a075120eb484727a09f2f3701ac80c559eec39" translate="yes" xml:space="preserve">
          <source>Mark the directories/modules you want to analyze for discrepancies and click &lt;strong&gt;Add&lt;/strong&gt;. You can either add the &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files directly, or add directories that contain these kind of files. Notice that you are only allowed to add the type of files that can be analyzed in the current mode of operation (see below), and that you cannot mix &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files.</source>
          <target state="translated">불일치에 대해 분석하려는 디렉토리 / 모듈을 표시하고 &lt;strong&gt;추가를&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; . 당신이 중 하나를 추가 할 수 있습니다 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.erl&lt;/code&gt; 파일을 직접, 또는 파일의 이러한 종류를 포함하는 디렉토리를 추가합니다. 현재 작동 모드 (아래 참조)에서 분석 할 수있는 파일 유형 만 추가 할 수 있으며 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.erl&lt;/code&gt; 파일을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="197dfa50ea4b8649cb35689f0decbb6c374c77b7" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;Dir&lt;/code&gt; as sticky.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 를 끈적 거리는 것으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7b5406131a661f19f4b14f972097e09771980111" translate="yes" xml:space="preserve">
          <source>Marks a registry object as dirty. This ensures that it is included in the next backup to &lt;code&gt;Mnesia&lt;/code&gt;. Normally this operation is not necessary, as all of the normal registry 'set' functions do this automatically. However, if you have retrieved the value of a string or binary object from the registry and modified the contents, then the change is invisible to the registry and the object is assumed to be unmodified. This function allows you to make such modifications and then let the registry know about them.</source>
          <target state="translated">레지스트리 객체를 더티로 표시합니다. 이를 통해 다음 번 &lt;code&gt;Mnesia&lt;/code&gt; 백업에 포함됩니다 . 모든 일반 레지스트리 'set'기능이 자동으로 수행하므로 일반적으로이 작업은 필요하지 않습니다. 그러나 레지스트리에서 문자열 또는 이진 오브젝트의 값을 검색하고 컨텐츠를 수정 한 경우 레지스트리에 변경 사항이 표시되지 않고 오브젝트가 수정되지 않은 것으로 간주됩니다. 이 기능을 사용하면 이러한 수정을 수행 한 다음 레지스트리에이를 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcbfc3c88f06b01ad7c3cccfab1c852094317788" translate="yes" xml:space="preserve">
          <source>Marks that driver instances can handle being called in the &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; callbacks although a driver instance has marked itself as busy (see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt;). As from ERTS 5.7.4 this flag is required for drivers used by the Erlang distribution (the behavior has always been required by drivers used by the distribution).</source>
          <target state="translated">드라이버 인스턴스가 사용 중으로 표시되었지만 드라이버 인스턴스가 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 콜백 에서 호출되는 것을 처리 할 수 ​​있음 을 표시합니다 ( &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt; 참조 ). ERTS 5.7.4부터이 플래그는 Erlang 배포에 사용되는 드라이버에 필요합니다 (배포에 사용되는 드라이버에 의해 동작이 항상 필요했습니다).</target>
        </trans-unit>
        <trans-unit id="44a77f06fe20eb0136352abea280e4ae8f164595" translate="yes" xml:space="preserve">
          <source>Marshall T. Rose (1991), &quot;The Simple Book - An Introduction to Internet Management&quot;, Prentice-Hall</source>
          <target state="translated">Marshall T. Rose (1991), &quot;간단한 책-인터넷 관리 소개&quot;, Prentice-Hall</target>
        </trans-unit>
        <trans-unit id="ff171d7e2ec66d8d77776b728f30299bf8e3e6c9" translate="yes" xml:space="preserve">
          <source>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys. Note that multiple occurrences of metavariables in the pattern is not allowed, but is not checked.</source>
          <target state="translated">환경 맵핑 변수 이름을 서브 트리에 리턴하는 구문 트리에 대한 패턴 (또는 구문 트리에 대한 패턴)을 일치시킵니다. 환경은 항상 키로 정렬됩니다. 패턴에서 복수의 메타 변수가 발생하는 것은 허용되지 않지만 확인되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2de4afa174487d24d4a58ea206ea53aeb3c9f62" translate="yes" xml:space="preserve">
          <source>Match against one or more clauses with patterns and optional guards.</source>
          <target state="translated">패턴과 옵션 가드가있는 하나 이상의 절과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="509635766fe25fda0e8fcb1e73a1a4900a524a90" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table with arity &amp;gt; 1 and the first element is 'gandalf', and return element 2:</source>
          <target state="translated">ETS 테이블의 모든 오브젝트를 arity&amp;gt; 1로 일치시키고 첫 번째 요소는 'gandalf'이고 요소 2를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb24c4903ed09ea4659ce737242ec2cae99a47b" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table, where the first element is the atom &lt;code&gt;'strider'&lt;/code&gt; and the tuple arity is 3, and return the whole object:</source>
          <target state="translated">첫 번째 요소가 원자 &lt;code&gt;'strider'&lt;/code&gt; 이고 튜플 arity가 3 인 ETS 테이블의 모든 오브젝트를 일치 시키고 전체 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="7edee42de18d23f1dd88981c1e38214f04375e1b" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the first and third arguments are equal:</source>
          <target state="translated">첫 번째와 세 번째 인수가 동일한 세 개의 인수 목록을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="007b6fe417206569cf211bcff5829b2fb375ff62" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the second argument is a number &amp;gt; 3:</source>
          <target state="translated">세 번째 인수가 3보다 큰 인수 목록과 일치합니다. 두 번째 인수는 3보다 큰 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="aaa654601a0768fd3a5ea8e1f4e632cb6ef820a5" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the third argument is either a tuple containing argument one and two, &lt;strong&gt;or&lt;/strong&gt; a list beginning with argument one and two (that is, &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; or &lt;code&gt;[a,b,{a,b}]&lt;/code&gt;):</source>
          <target state="translated">세 번째 인수는 인수 중 하나와 두 포함하는 튜플 셋의 인수리스트 일치 &lt;strong&gt;또는&lt;/strong&gt; 인수 한 두 (인로 시작 목록 &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; 또는 &lt;code&gt;[a,b,{a,b}]&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="92514756645fe7077028fc14821601f7e85836da" translate="yes" xml:space="preserve">
          <source>Match any character except newline (by default)</source>
          <target state="translated">줄 바꿈을 제외한 모든 문자와 일치 (기본적으로)</target>
        </trans-unit>
        <trans-unit id="62e56bea29683834bf7ec08fb1eb30aa1828744a" translate="yes" xml:space="preserve">
          <source>Match some dictionary entries</source>
          <target state="translated">일부 사전 항목과 일치</target>
        </trans-unit>
        <trans-unit id="311fb719c2d9cb64132a0b11b661fb396a3a0223" translate="yes" xml:space="preserve">
          <source>Match specification, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the ERTS User's Guide and &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일치 사양 은 ERTS 사용 설명서 및 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c08d65581b61fabe23402aa00e8ab9a94f3ae9ef" translate="yes" xml:space="preserve">
          <source>Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt;, and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable.</source>
          <target state="translated">일치 사양은 필터로 사용됩니다. 그것들은리스트 이해 나리스트와 함께 사용되는 재미에서 일반적인 Erlang 매칭과 비슷 &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt; 등. 그러나 순수 일치 스펙의 구문은 Erlang 용어로 순수하게 구성되므로 일치 스펙을 더 읽기 쉽게하기위한 구문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="28103d4192f64923a9e433e5c840bc4e8b567bda" translate="yes" xml:space="preserve">
          <source>Match specifications used can be saved in a file (if a read-write file system is present) for use in later debugging sessions, see &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">사용 된 일치 스펙은 나중에 디버깅 세션에서 사용하기 위해 파일 (읽기-쓰기 파일 시스템이있는 경우)에 저장할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1229fff8a073694fbfc1092526ee8748365e4bdf" translate="yes" xml:space="preserve">
          <source>Match specifications, see section &lt;code&gt;Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide and the &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">일치 사양 은 ERTS 사용 설명서의 &lt;code&gt;Match Specification in Erlang&lt;/code&gt; 섹션 과 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c45c41f60cedeecdd4b1c366db7e307e66a6a606" translate="yes" xml:space="preserve">
          <source>Match target</source>
          <target state="translated">경기 대상</target>
        </trans-unit>
        <trans-unit id="58de7407dcefed17ecbb0f0f0caecc0925acc26e" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;MatchHead&lt;/code&gt; part against the match target term, binding the &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; variables (much like in &lt;code&gt;ets:match/2&lt;/code&gt;). If the &lt;code&gt;MatchHead&lt;/code&gt; part cannot match the arguments, the match fails.</source>
          <target state="translated">&lt;code&gt;ets:match/2&lt;/code&gt; 와 유사하게 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 변수를 바인딩 하여 &lt;code&gt;MatchHead&lt;/code&gt; 부분을 ​​일치 대상 용어 와 일치 시킵니다. 는 IF &lt;code&gt;MatchHead&lt;/code&gt; 의 일부가 인수와 일치 할 수없는, 경기가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d0bb026735ab1b1a560327096ea49590520df5c7" translate="yes" xml:space="preserve">
          <source>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, otherwise let the trace message be &quot;as is&quot;, but set the sequential trace token label to 4711:</source>
          <target state="translated">세 가지 주장을 일치시킵니다. 세 개가 모두 같고 숫자 인 경우 프로세스 덤프를 추적 메시지에 추가하고, 그렇지 않으면 추적 메시지를 &quot;있는 그대로&quot;두고 순차 추적 토큰 레이블을 4711로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="50d2b574a0b4bf14c816284735e4a32f6738492f" translate="yes" xml:space="preserve">
          <source>Match tuples of three elements, where the second element is either &lt;code&gt;'merry'&lt;/code&gt; or &lt;code&gt;'pippin'&lt;/code&gt;, and return the whole objects:</source>
          <target state="translated">두 번째 요소가 &lt;code&gt;'merry'&lt;/code&gt; 또는 &lt;code&gt;'pippin'&lt;/code&gt; 인 세 요소의 튜플을 일치 시키고 전체 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b52bb892dfc03f66052c156357fd98f06f6d6ad0" translate="yes" xml:space="preserve">
          <source>Match two arguments, where the first is a tuple beginning with a list that in turn begins with the second argument times two (that is, &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; or &lt;code&gt;[{[8], y, z},4])&lt;/code&gt;:</source>
          <target state="translated">두 개의 인수를 일치 시키십시오. 첫 번째는 두 번째 인수 &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; 두 번 시작하는리스트 (즉, [{[4, x], y}, 2] 또는 &lt;code&gt;[{[8], y, z},4])&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da3931950dd632f760d810b04a1dfee915ca645d" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ActionTerm ]</source>
          <target state="translated">MatchBody :: = [액션 용어]</target>
        </trans-unit>
        <trans-unit id="49eed79dc355081fc78c915df6e6741691fad326" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ConditionExpression, ... ]</source>
          <target state="translated">MatchBody :: = [ConditionExpression, ...]</target>
        </trans-unit>
        <trans-unit id="e7543ce8b4424850514899929477fd3fd4bc7586" translate="yes" xml:space="preserve">
          <source>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... }</source>
          <target state="translated">MatchCondition :: = {GuardFunction} | {GuardFunction, ConditionExpression, ...}</target>
        </trans-unit>
        <trans-unit id="7a1238f4170ab727b947ac14efc193f8277c9e1a" translate="yes" xml:space="preserve">
          <source>MatchConditions ::= [ MatchCondition, ...] | &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">MatchConditions :: = [MatchCondition, ...] | &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95bf5fe6015be79d0f9353ed2e6ebd9f6f5c1aaf" translate="yes" xml:space="preserve">
          <source>MatchExpression ::= [ MatchFunction, ... ]</source>
          <target state="translated">MatchExpression :: = [MatchFunction, ...]</target>
        </trans-unit>
        <trans-unit id="4362346f5ab9c3e849d7a732cb6f7149b013ecea" translate="yes" xml:space="preserve">
          <source>MatchFunction ::= { MatchHead, MatchConditions, MatchBody }</source>
          <target state="translated">MatchFunction :: = {MatchHead, MatchConditions, MatchBody}</target>
        </trans-unit>
        <trans-unit id="62fe68ac64e3f31f3bc26fda2674c9914f299bee" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [ MatchHeadPart, ... ]</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [MatchHeadPart, ...]</target>
        </trans-unit>
        <trans-unit id="8d11a2590b00416cc7fd21aa567f9dc7dcd1e80a" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | { MatchHeadPart, ... }</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | {MatchHeadPart, ...}</target>
        </trans-unit>
        <trans-unit id="4c3dc5459e996623b4e979c498a0b4c1d7e9b686" translate="yes" xml:space="preserve">
          <source>MatchHeadPart ::= term() | MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</source>
          <target state="translated">MatchHeadPart :: = 용어 () | MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5c57568dca7b0bd330575231a9b4b598aa5de7d" translate="yes" xml:space="preserve">
          <source>MatchVariable ::= '$&amp;lt;number&amp;gt;'</source>
          <target state="translated">MatchVariable :: = '$ &amp;lt;숫자&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="0086ec33bc64b94a17c1488954c54ae1f0850ff5" translate="yes" xml:space="preserve">
          <source>Matches any character.</source>
          <target state="translated">모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b0bce32c5a3c3fc3ed0e703a29ce005a9a59c17b" translate="yes" xml:space="preserve">
          <source>Matches any number of characters up to the end of the filename, the next dot, or the next slash.</source>
          <target state="translated">파일 이름 끝, 다음 점 또는 다음 슬래시까지 문자 수를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="f115e2cfefeef7ee50e81931c874414b0559f037" translate="yes" xml:space="preserve">
          <source>Matches any of the characters listed. Two characters separated by a hyphen match a range of characters. Example: &lt;code&gt;[A-Z]&lt;/code&gt; matches any uppercase letter.</source>
          <target state="translated">나열된 문자와 일치합니다. 하이픈으로 구분 된 두 문자는 문자 범위와 일치합니다. 예 : &lt;code&gt;[A-Z]&lt;/code&gt; 는 대문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="50795a0a08132b80e78d1e76523a0677ba80c9ba" translate="yes" xml:space="preserve">
          <source>Matches any peer. This is a convenience that provides a filter equivalent to no filter.</source>
          <target state="translated">모든 피어와 일치합니다. 이것은 필터가없는 것과 동등한 필터를 제공하는 편의성입니다.</target>
        </trans-unit>
        <trans-unit id="45303a6504cacc79e7d23b3bbb52fa9c500e5dd8" translate="yes" xml:space="preserve">
          <source>Matches at a word boundary.</source>
          <target state="translated">단어 경계에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ac95a7b57dc892c5cbccecec503375cd8b75457" translate="yes" xml:space="preserve">
          <source>Matches at the end of the subject, and before a newline at the end of the subject.</source>
          <target state="translated">주제의 끝에 그리고 주제의 끝에 개행 전에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dfe97d17ef60dfa95587204790b8e7a03401165c" translate="yes" xml:space="preserve">
          <source>Matches at the first matching position in the subject.</source>
          <target state="translated">주제의 첫 번째 일치 위치에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="30957d7eb006582b971d8e18207879a7a2e62a2f" translate="yes" xml:space="preserve">
          <source>Matches at the start of the subject.</source>
          <target state="translated">주제의 시작 부분과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c20e2cfc85fd5962f00bfd1aab37748d15201d74" translate="yes" xml:space="preserve">
          <source>Matches one character.</source>
          <target state="translated">한 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bf384d7f3f9dc4a8d07f9032759bd099ac99af1e" translate="yes" xml:space="preserve">
          <source>Matches one or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="95b0a058c78027f9b36554648c7e31c06df213b3" translate="yes" xml:space="preserve">
          <source>Matches only at the end of the subject.</source>
          <target state="translated">주제의 끝에서만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bce02edb2750c6f7e1edccc714e57113b0b26a46" translate="yes" xml:space="preserve">
          <source>Matches only those peers for which the specified &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when applied to the connection's &lt;code&gt;diameter_caps&lt;/code&gt; record. Any other return value or exception is equivalent to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이 연결의 &lt;code&gt;diameter_caps&lt;/code&gt; 레코드에 적용될 때 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 피어와 만 일치합니다 . 다른 반환 값 또는 예외는 &lt;code&gt;false&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c84c071e773e0343110738922ba722b0e2af3f2c" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by at least one filter in the specified list. The resulting list will be in match order, peers matching the first filter of the list sorting before those matched by the second, and so on.</source>
          <target state="translated">지정된 목록에서 하나 이상의 필터와 일치하는 피어 만 일치시킵니다. 결과 목록은 일치 순서이며, 목록 정렬의 첫 번째 필터와 일치하는 피어는 두 번째 필터와 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f2592920b5282895068215ce350574baf645c52" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by each filter in the specified list.</source>
          <target state="translated">지정된 목록의 각 필터와 일치하는 피어 만 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="589f2d5ff54077f4e7ded5e562f61c1d207b2d40" translate="yes" xml:space="preserve">
          <source>Matches only those peers not matched by the specified filter.</source>
          <target state="translated">지정된 필터와 일치하지 않는 피어 만 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a63639f69671438d06e3a88ceb05c2fd6d45b827" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the same value as Destination-Host in the outgoing request in question, or any peer if the request does not contain a Destination-Host AVP.</source>
          <target state="translated">발신 요청에서 Origin-Host 값이 대상 호스트와 동일한 피어 또는 요청에 대상 호스트 AVP가 포함되지 않은 피어와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7246e14a8a2a6df71afafbd3a74a8b44cdfbd531" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Origin-Host가 지정된 값을 갖는 피어 또는 원자가 &lt;code&gt;any&lt;/code&gt; 인 경우 모든 피어와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="95597417bac7dc49af239c255741702c0c22bdaf" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing request in question, or any peer if the request does not contain a Destination-Realm AVP.</source>
          <target state="translated">발신 요청에서 Origin-Realm이 Destination-Realm과 동일한 값을 갖는 피어 또는 요청에 Destination-Realm AVP가 포함되지 않은 피어와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4616ccf0ec60315c7670131e4744903a3aa36484" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Origin-Realm이 지정된 값을 갖는 피어 또는 원자가 &lt;code&gt;any&lt;/code&gt; 인 모든 피어와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a4e16b1f64f5c039f506ff58b839fd8686c547b" translate="yes" xml:space="preserve">
          <source>Matches some objects stored in a table and returns a non-empty list of the bindings matching a specified pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by &lt;code&gt;Continuation&lt;/code&gt;, which has been returned by a previous call to &lt;code&gt;match/1&lt;/code&gt; or &lt;code&gt;match/3&lt;/code&gt;.</source>
          <target state="translated">테이블에 저장된 일부 오브젝트를 일치시키고 지정되지 않은 순서로 지정된 패턴과 일치하는 비어 있지 않은 바인딩 목록을 리턴합니다. 일치하는 테이블, 패턴 및 오브젝트 수는 모두 &lt;code&gt;Continuation&lt;/code&gt; 에 의해 정의되며 , 이는 &lt;code&gt;match/1&lt;/code&gt; 또는 &lt;code&gt;match/3&lt;/code&gt; 에 대한 이전 호출에 의해 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fd0109e8c46b7b74ad55d61eaa83a0d60c1cd8f8" translate="yes" xml:space="preserve">
          <source>Matches some or all objects of table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the bindings that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 테이블의 일부 또는 모든 개체 를 일치시키고 &lt;code&gt;Pattern&lt;/code&gt; 과 일치하는 바인딩의 비어 있지 않은 목록을 지정되지 않은 순서로 반환합니다 . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7450adfcb4b169def8a4607352e723d68bd86b34" translate="yes" xml:space="preserve">
          <source>Matches some or all objects stored in table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the objects that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 테이블에 저장된 일부 또는 모든 오브젝트 를 일치시키고 지정되지 않은 순서로 &lt;code&gt;Pattern&lt;/code&gt; 과 일치하는 비어 있지 않은 오브젝트 목록을 리턴합니다 . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adb3e1824193dafdae7a5fd33b8ea49f66c2c1dd" translate="yes" xml:space="preserve">
          <source>Matches the beginning of a string.</source>
          <target state="translated">문자열의 시작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4c548c831bb16f2a3bc17e5430fb0fb7ff876eb6" translate="yes" xml:space="preserve">
          <source>Matches the end of a string.</source>
          <target state="translated">문자열의 끝과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cdef85f0928e6e8b1028572e8dc40e0e560c24e" translate="yes" xml:space="preserve">
          <source>Matches the escape sequence or literal character c.</source>
          <target state="translated">이스케이프 시퀀스 또는 리터럴 문자와 일치합니다. c.</target>
        </trans-unit>
        <trans-unit id="0435b1eedb79970f4013fe9211b9ebe7da670511" translate="yes" xml:space="preserve">
          <source>Matches the non-metacharacter c.</source>
          <target state="translated">메타 문자가 아닌 문자와 일치합니다. c.</target>
        </trans-unit>
        <trans-unit id="e28e6ed212ebaee585530d5991166a71f8b48a86" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;.</source>
          <target state="translated">테이블의 개체 일치 &lt;code&gt;Tab&lt;/code&gt; 패턴에 대한 &lt;code&gt;Pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d29aca058cbf8d1d0f58db77974d455fcaada07" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The function returns a list of all objects that match the pattern.</source>
          <target state="translated">테이블의 개체 일치 &lt;code&gt;Tab&lt;/code&gt; 패턴에 대한 &lt;code&gt;Pattern&lt;/code&gt; . 패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이 함수는 패턴과 일치하는 모든 객체의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db735a0007cc043e4574b21e24e3a6e8e46b90e2" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object considered a match and is counted. For any other result from the match specification the object is not considered a match and is therefore not counted.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치 스펙 이 오브젝트에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 해당 오브젝트는 일치로 간주되어 계산됩니다. 일치 사양의 다른 결과에 대해서는 개체가 일치하는 것으로 간주되지 않으므로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b012b167808e61a37f3f13edeb00bcf37acbcee" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치 스펙 이 오브젝트에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 해당 오브젝트가 테이블에서 제거됩니다. 일치 사양의 다른 결과에 대해서는 개체가 유지됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 호출 보다 더 일반적인 호출입니다.</target>
        </trans-unit>
        <trans-unit id="f314d3d7e1fd748578a641bfbf6311159aed1316" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. This is a more general call than &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; calls. In its simplest form, the match specification is as follows:</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 이것은 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; 호출 보다 일반적인 호출입니다. 가장 간단한 형식으로 일치 사양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dfac617898b79dd2741468d1513c14a6c53d233" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ERTS&lt;/code&gt; User's Guide, and returns a chunk of terms and a continuation. The wanted number of returned terms is specified by argument &lt;code&gt;NObjects&lt;/code&gt;. The lock argument can be &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;. The continuation is to be used as argument to &lt;code&gt;mnesia:select/1&lt;/code&gt;, if more or all answers are needed.</source>
          <target state="translated">&lt;code&gt;ERTS&lt;/code&gt; 사용 설명서에 설명 된대로 &lt;code&gt;match_spec&lt;/code&gt; 을 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시키고 용어와 연속을 반환합니다. 원하는 개수의 반환되는 용어는 인수 &lt;code&gt;NObjects&lt;/code&gt; 에 의해 지정됩니다 . 잠금 인수는 &lt;code&gt;read&lt;/code&gt; 거나 &lt;code&gt;write&lt;/code&gt; 수 있습니다 . 더 많은 또는 모든 답변이 필요한 경우 연속은 &lt;code&gt;mnesia:select/1&lt;/code&gt; 의 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e64640be20ca493c8fc40edf41b5b9186f3b2197" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ets:select/3&lt;/code&gt;. Optionally a lock &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; can be given as the third argument. Default is &lt;code&gt;read&lt;/code&gt;. The return value depends on &lt;code&gt;MatchSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ets:select/3&lt;/code&gt; 에 설명 된대로 &lt;code&gt;match_spec&lt;/code&gt; 을 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 객체를 일치시킵니다 . 선택적으로 잠금 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 가 세 번째 인수로 제공 될 수 있습니다. 기본값은 &lt;code&gt;read&lt;/code&gt; 입니다. 반환 값은 &lt;code&gt;MatchSpec&lt;/code&gt; 에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f9639126fbeb35a28a58c64b5cdf217294a65f" translate="yes" xml:space="preserve">
          <source>Matches the objects in the table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. For each matched object, the existing object is replaced with the match specification result.</source>
          <target state="translated">일치 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 사용하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 개체를 일치시킵니다 . 일치하는 각 개체에 대해 기존 개체는 일치 사양 결과로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="473b51b88af255ce39d9fa5d375d31e69528b449" translate="yes" xml:space="preserve">
          <source>Matches when not at a word boundary.</source>
          <target state="translated">단어 경계에 없을 때 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ff59d4c3d244f3cad2fc9a4df684903b72e3fa73" translate="yes" xml:space="preserve">
          <source>Matches zero or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">0 개 이상의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="bf4e77ebb7ccf37afab91a38875933929de61e50" translate="yes" xml:space="preserve">
          <source>Matches zero or one &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">0 또는 1 개의 &lt;code&gt;rs&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b60d1249c4c758556a1d227c9f807ee709be4c34" translate="yes" xml:space="preserve">
          <source>Matching Syntax</source>
          <target state="translated">일치 구문</target>
        </trans-unit>
        <trans-unit id="71e571ae9130ba825368a44ee875bfb358022107" translate="yes" xml:space="preserve">
          <source>Matching a binary will also cause it to shrink and the next append operation will copy the binary data:</source>
          <target state="translated">이진을 일치 시키면 축소되고 다음 추가 작업으로 이진 데이터가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="36481aa97a951a1dcf7d8486d523f317dc45f5dc" translate="yes" xml:space="preserve">
          <source>Matching an expression against an empty map literal, matches its type but no variables are bound:</source>
          <target state="translated">빈 맵 리터럴에 대해 표현식을 일치 시키면 해당 유형과 일치하지만 변수는 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d117b8c447d4889a004e4beb80ae87b3b9f61b4" translate="yes" xml:space="preserve">
          <source>Matching can be used in combination with records, as shown in the following example:</source>
          <target state="translated">다음 예와 같이 일치는 레코드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21db0315aaeea4915646c1ba5a3af148311bbc82" translate="yes" xml:space="preserve">
          <source>Matching characters by Unicode property is not fast, as PCRE must do a multistage table lookup to find a character property. That is why the traditional escape sequences such as \d and \w do not use Unicode properties in PCRE by default. However, you can make them do so by setting option &lt;code&gt;ucp&lt;/code&gt; or by starting the pattern with (*UCP).</source>
          <target state="translated">PCRE가 문자 특성을 찾기 위해 다단계 테이블 검색을 수행해야하므로 유니 코드 특성으로 문자를 일치시키는 것은 빠르지 않습니다. 따라서 \ d 및 \ w와 같은 기존 이스케이프 시퀀스는 기본적으로 PCRE에서 유니 코드 속성을 사용하지 않습니다. 그러나 옵션 &lt;code&gt;ucp&lt;/code&gt; 를 설정 하거나 (* UCP)로 패턴을 시작하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daa0e37dc758ae15a4e0e7ac7d8a0c3a7422c8e2" translate="yes" xml:space="preserve">
          <source>Matching in maps only allows for &lt;code&gt;:=&lt;/code&gt; as delimiters of associations.</source>
          <target state="translated">맵에서 일치하면 연관 구분 기호로 &lt;code&gt;:=&lt;/code&gt; 만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0b3439d7561cb2dee16bc2f99dd957cfc474df0" translate="yes" xml:space="preserve">
          <source>Matching of key-value associations from maps is done as follows:</source>
          <target state="translated">맵에서 키-값 연관의 일치는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9cba95bb8e1514e71368d11f0995ae0398f3886" translate="yes" xml:space="preserve">
          <source>Matching of literals as keys are allowed in function heads:</source>
          <target state="translated">함수 헤드에서 키로 리터럴 일치가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="74c212bf6fa09d18e1ec277db201559eabf9e7c0" translate="yes" xml:space="preserve">
          <source>Matching on the top-level of the fun head can be a more natural way to access &lt;code&gt;'$_'&lt;/code&gt;, see above.</source>
          <target state="translated">펀 헤드의 최상위 레벨에 일치하는 것은 &lt;code&gt;'$_'&lt;/code&gt; 에 액세스하는보다 자연스러운 방법이 될 수 있습니다 ( 위 참조).</target>
        </trans-unit>
        <trans-unit id="565f0418bb5db88e5d8e94d04658199d8610d3a3" translate="yes" xml:space="preserve">
          <source>Matching with &lt;code&gt;=&lt;/code&gt; cannot be used in the body. It can only be used on the top-level in the head of the fun. Example from the shell again:</source>
          <target state="translated">본문에서 &lt;code&gt;=&lt;/code&gt; 와 일치하는 것은 사용할 수 없습니다. 그것은 재미의 머리에서 최상위 수준에서만 사용할 수 있습니다. 쉘의 예 :</target>
        </trans-unit>
        <trans-unit id="a3b81034e705bd05b97727252f92caaa6d4b0b26" translate="yes" xml:space="preserve">
          <source>Mathematical functions.</source>
          <target state="translated">수학 함수.</target>
        </trans-unit>
        <trans-unit id="a06a77cda1f0fe480299649af647924142a54fb7" translate="yes" xml:space="preserve">
          <source>Mathematical symbol</source>
          <target state="translated">수학 기호</target>
        </trans-unit>
        <trans-unit id="c58ea4f87745ada36a92fb71c082ea8bc73755ba" translate="yes" xml:space="preserve">
          <source>Max detail level activates tracing of all calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">최대 세부 수준은 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 모든 호출 추적을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="11d44674eb08f7f43d0a32b42fd60d63d0160c36" translate="yes" xml:space="preserve">
          <source>Max message size. If the encoded message (PDU) exceeds this size, the message should be segmented, and then encoded.</source>
          <target state="translated">최대 메시지 크기 인코딩 된 메시지 (PDU)가이 크기를 초과하면 메시지를 분할 한 다음 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d97f56b8e291a3ee3880e81646a3d47ce560d1f" translate="yes" xml:space="preserve">
          <source>Max number of reconnection attempts = 3</source>
          <target state="translated">최대 재 연결 시도 횟수 = 3</target>
        </trans-unit>
        <trans-unit id="8f6fcbc1873209046a71e4646a7bf770c375c7d7" translate="yes" xml:space="preserve">
          <source>Max number of simultaneous requests handled by the agent.</source>
          <target state="translated">에이전트가 처리 한 최대 동시 요청 수</target>
        </trans-unit>
        <trans-unit id="134ec94ac95c6d28341162fd550979562d4d3df9" translate="yes" xml:space="preserve">
          <source>MaxHeapSize :: max_heap_size()}</source>
          <target state="translated">MaxHeapSize :: max_heap_size ()}</target>
        </trans-unit>
        <trans-unit id="7fb79c4fc5ed76bf0ff64ddd38b1f62fc36d71a2" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; carriers. Maximum number of carriers placed in separate memory segments. When this limit is reached, new carriers are placed in memory retrieved from &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 캐리어. 별도의 메모리 세그먼트에 배치 된 최대 캐리어 수. 이 한계에 도달하면 &lt;code&gt;sys_alloc&lt;/code&gt; 에서 검색된 메모리에 새 캐리어가 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6eacd663f585efc475070891fcbc20a37ca64c6" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers. Maximum number of multiblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new multiblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 멀티 블록 캐리어. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 에 의해 &lt;code&gt;mseg_alloc&lt;/code&gt; 을 통해 할당 된 최대 멀티 블록 캐리어 수 . 이 한계에 도달하면 새 &lt;code&gt;sys_alloc&lt;/code&gt; 블록 캐리어가 sys_alloc을 통해 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd2141dfa85073c5d5d798b526c7807965d10406" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carriers. Maximum number of singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new singleblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;mseg_alloc&lt;/code&gt; 단일 블록 반송파. 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 가 &lt;code&gt;mseg_alloc&lt;/code&gt; 을 통해 할당 한 최대 단일 블록 캐리어 수입니다 . 이 한계에 도달하면 새로운 singleblock 캐리어를 통해 할당 &lt;code&gt;sys_alloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2560b86e3ae10f6289deb0fb563e661e33d86418" translate="yes" xml:space="preserve">
          <source>Maximum block search depth. This flag has effect only if the good fit strategy is selected for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free-list contains blocks of sizes in a specific range. The maxiumum block search depth sets a limit on the maximum number of blocks to inspect in a free-list during a search for suitable block satisfying the request.</source>
          <target state="translated">최대 블록 검색 깊이. 이 플래그는 할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 에 대해 적합 전략을 선택한 경우에만 적용됩니다 . 적합 전략을 사용하면 자유 블록이 분리 된 자유 목록에 배치됩니다. 각 자유 목록에는 특정 범위의 크기 블록이 포함됩니다. 최대 블록 탐색 깊이는 요청을 만족시키는 적합한 블록을 탐색하는 동안 자유 목록에서 검사 할 최대 블록 수의 한계를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d51cca9df00fb6d2d33b5042e7197395c4a8e7ed" translate="yes" xml:space="preserve">
          <source>Maximum cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is &lt;code&gt;[0, 30]&lt;/code&gt;. Defaults to &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">캐시 된 최대 세그먼트. 메모리 세그먼트 캐시에 저장된 최대 메모리 세그먼트 수입니다. 유효한 범위는 &lt;code&gt;[0, 30]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3aacd33489c919c3259f3def36a32db78de3dce1" translate="yes" xml:space="preserve">
          <source>Maximum content-length in an incoming request, in bytes. Requests with content larger than this are answered with status 413. Default is &lt;code&gt;100000000&lt;/code&gt; (100 MB).</source>
          <target state="translated">수신 요청의 최대 컨텐츠 길이 (바이트). 이보다 큰 내용의 요청은 상태 413으로 응답됩니다. 기본값은 &lt;code&gt;100000000&lt;/code&gt; (100MB)입니다.</target>
        </trans-unit>
        <trans-unit id="3d28b59ad57e9489a6f4dacef960badc6138d55c" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated ack's. At most this many ack's will be accumulated by the transaction sender (if started and configured to accumulate ack's).</source>
          <target state="translated">누적 된 최대 ack 수입니다. 기껏해야이 ack가 많은 수의 트랜잭션 발신자가 누적됩니다 (시작하고 ack을 축적하도록 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="3fd6bff2681eda77c96a1c420386709c1976443f" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated requests. At most this many requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">누적 된 최대 요청 수 기껏해야이 많은 요청이 트랜잭션 전송자에 의해 누적됩니다 (시작되고 요청을 누적하도록 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="266851f73fafaca0bf2a7c683bc5bb3b6087f7f7" translate="yes" xml:space="preserve">
          <source>Maximum number of inbound streams</source>
          <target state="translated">최대 인바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="8e8430ded43149745cb3e173c59fd623e6e072ee" translate="yes" xml:space="preserve">
          <source>Maximum number of locks printed or no limit with &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">최대 인쇄 잠금 번호 나에 제한이 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32bf44bb5328eccf585529f07558abf83b7b8e84" translate="yes" xml:space="preserve">
          <source>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 1.</source>
          <target state="translated">유효한 인증 경로에서 피어 인증서를 따를 수있는 자체 발급되지 않은 중간 인증서의 최대 수 따라서 깊이가 0이면 신뢰할 수있는 ROOT-CA가 PEER에 직접 서명해야합니다. 1 인 경우 경로는 PEER, CA, ROOT-CA 일 수 있습니다. 2 인 경우 경로는 PEER, CA, CA, ROOT-CA 등일 수 있습니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="99fff8db195ccd6c7a048657d30498c73cc01e79" translate="yes" xml:space="preserve">
          <source>Maximum number of processes allowed in the application.</source>
          <target state="translated">응용 프로그램에서 허용되는 최대 프로세스 수.</target>
        </trans-unit>
        <trans-unit id="2aaab3dedee65069b116c73b83377fb65720dd78" translate="yes" xml:space="preserve">
          <source>Maximum number of retransmissions before this address is considered unreachable (and an alternative address is selected)</source>
          <target state="translated">이 주소 이전에 도달 할 수없는 최대 재전송 횟수 (및 다른 주소가 선택됨)</target>
        </trans-unit>
        <trans-unit id="f9241fef7fbe8fcf32ca009d6ccfebe5481eab50" translate="yes" xml:space="preserve">
          <source>Maximum retransmissions while establishing an association</source>
          <target state="translated">연결을 설정하는 동안 최대 재전송</target>
        </trans-unit>
        <trans-unit id="48fdfa1e1dccf2224acc92084ff1e406b0b85d9e" translate="yes" xml:space="preserve">
          <source>Maximum size of the accumulated requests. At most this much requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">누적 된 요청의 최대 크기 기껏해야이 많은 요청이 트랜잭션 전송자에 의해 누적됩니다 (요청을 누적하도록 시작 및 구성된 경우).</target>
        </trans-unit>
        <trans-unit id="28c7bf59062e8e7b399ad75612dd36c886f2132d" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds for the authentication negotiation. Defaults to 120000 ms (2 minutes). If the client fails to log in within this time, the connection is closed.</source>
          <target state="translated">인증 협상을위한 최대 시간 (밀리 초)입니다. 기본값은 120000ms (2 분)입니다. 이 시간 내에 클라이언트가 로그인에 실패하면 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="5ed8876370f72890efa02c30deff24e537f34e66" translate="yes" xml:space="preserve">
          <source>Maximum time, in milliseconds, that the application is allowed to run. After the specified time, the application terminates automatically.</source>
          <target state="translated">애플리케이션이 실행되는 최대 시간 (밀리 초)입니다. 지정된 시간이 지나면 응용 프로그램이 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d10e5666a4350d3a74dfeb650aa6e788de3d69f" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">안전한 &quot;무작위성&quot;부족으로 인해 랜덤 생성기가 실패한 경우 &lt;code&gt;low_entropy&lt;/code&gt; 예외 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646deba2eac00f7933fd5cbe027cc187e501a16e" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt; is not supported by the underlying OpenSSL implementation.</source>
          <target state="translated">선택한 &lt;code&gt;Type&lt;/code&gt; 이 기본 OpenSSL 구현에서 지원되지 않는 경우 예외를 발생 &lt;code&gt;notsup&lt;/code&gt; 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3eaac3de9e89ba4866a20aae2b339c0035484b" translate="yes" xml:space="preserve">
          <source>May throw exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진이 지원되지 않는 경우 예외를 발생시키지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a5150721719a6283a47c9cfb72e9bc9bff9f71" translate="yes" xml:space="preserve">
          <source>Md5 is a popular choice as a hash function, but it is not secure enough to be validated. Try to use sha instead wherever possible.</source>
          <target state="translated">Md5는 해시 함수로 널리 사용되지만 유효성을 검증 할만큼 안전하지는 않습니다. 가능하면 항상 sha를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d947c601b953e99cf3b99eb1e54ea06bc8cd7368" translate="yes" xml:space="preserve">
          <source>Meaning that you don't care if the reply is acknowledged or not.</source>
          <target state="translated">응답이 승인되었는지 여부는 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c14c209285d898ae15b996256e223eda68f99fc" translate="yes" xml:space="preserve">
          <source>Meaning that you want an acknowledgement &lt;strong&gt;sometime&lt;/strong&gt;. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">당신이 &lt;strong&gt;언젠가&lt;/strong&gt; 인정을 원한다는 것을 의미합니다 . 승인이 결국 수신되면 handle_trans_ack / 4 콜백 함수가 인수 중 하나로 ack_data ()를 사용하여 호출됩니다. ack_data ()는 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6a0ba0223a6ae2bd06adfc210359ea6aab4c09" translate="yes" xml:space="preserve">
          <source>Meaning that you want an immediate acknowledgement when the other part receives this transaction reply. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">다른 부분이이 트랜잭션 응답을 수신하면 즉시 승인을 원한다는 의미입니다. 승인이 최종적으로 수신되면, handle_trans_ack / 4 콜백 함수가 인수 중 하나로 ack_data ()를 사용하여 호출됩니다. ack_data ()는 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f498b784a10213b6d5daff6b5f8c433f00ab391" translate="yes" xml:space="preserve">
          <source>Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">위에 지정되지 않은 의미있는 원자는 ssl 옵션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="04424ff7354672ffdc45258bd640170e14936cbb" translate="yes" xml:space="preserve">
          <source>Measure Elapsed Time</source>
          <target state="translated">경과 시간 측정</target>
        </trans-unit>
        <trans-unit id="f049a7f84606387c1f036369b9d17679bb303ce9" translate="yes" xml:space="preserve">
          <source>Measure scheduler utilization</source>
          <target state="translated">스케줄러 활용도 측정</target>
        </trans-unit>
        <trans-unit id="7f45833b5c1ba2a9c0ab4a66fccfcb8ca4b25b6f" translate="yes" xml:space="preserve">
          <source>Measure utilization for normal and dirty-cpu schedulers during &lt;code&gt;Seconds&lt;/code&gt; seconds, and then return the result.</source>
          <target state="translated">&lt;code&gt;Seconds&lt;/code&gt; 초 동안 정상 및 더티 CPU 스케줄러의 사용률을 측정 한 다음 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abb7023ce648e065965ab27aefcab22defabb76e" translate="yes" xml:space="preserve">
          <source>Measurement tool directory name</source>
          <target state="translated">측정 도구 디렉토리 이름</target>
        </trans-unit>
        <trans-unit id="28e896074d31c2da6938ce8b9dd8662ed8369129" translate="yes" xml:space="preserve">
          <source>Measurement(s)</source>
          <target state="translated">Measurement(s)</target>
        </trans-unit>
        <trans-unit id="d404968ea90b07f16774ce75c7978d6ff60962f2" translate="yes" xml:space="preserve">
          <source>Medium</source>
          <target state="translated">Medium</target>
        </trans-unit>
        <trans-unit id="d4bb05883bb5a243cfcc4f9296f5649fd60af7f8" translate="yes" xml:space="preserve">
          <source>Medium mathematical space</source>
          <target state="translated">중간 수학적 공간</target>
        </trans-unit>
        <trans-unit id="a66ec7d3e2375014d1ffe12adf1704c1f323a128" translate="yes" xml:space="preserve">
          <source>Meetei_Mayek</source>
          <target state="translated">Meetei_Mayek</target>
        </trans-unit>
        <trans-unit id="291fdbd8f605e558c302e6b671f37cb0a11631da" translate="yes" xml:space="preserve">
          <source>Megaco and peer protocols are complementary in nature and entirely compatible within the same system. At a system level, Megaco allows for</source>
          <target state="translated">Megaco 및 피어 프로토콜은 본질적으로 보완 적이며 동일한 시스템 내에서 완전히 호환됩니다. 시스템 수준에서 Megaco는</target>
        </trans-unit>
        <trans-unit id="efb29db4c9a5b8efca98c20c485c0a71a7d66580" translate="yes" xml:space="preserve">
          <source>Megaco encoder behaviour.</source>
          <target state="translated">Megaco 엔코더 동작.</target>
        </trans-unit>
        <trans-unit id="1ab0d5d513da1a6a7bc7432ddbc64c528b364f30" translate="yes" xml:space="preserve">
          <source>Megaco erlang dist compress behaviour.</source>
          <target state="translated">Megaco erlang dist 압축 동작.</target>
        </trans-unit>
        <trans-unit id="220d827864f1e91dd8d479ee473263ef26b35de7" translate="yes" xml:space="preserve">
          <source>Megaco is a (master/slave) protocol for control of gateway functions at the edge of the packet network. Examples of this is IP-PSTN trunking gateways and analog line gateways. The main function of Megaco is to allow gateway decomposition into a call agent (call control) part (known as Media Gateway Controller, MGC) - master, and an gateway interface part (known as Media Gateway, MG) - slave. The MG has no call control knowledge and only handle making the connections and simple configurations.</source>
          <target state="translated">Megaco는 패킷 네트워크의 가장자리에서 게이트웨이 기능을 제어하기위한 (마스터 / 슬레이브) 프로토콜입니다. IP-PSTN 트렁킹 게이트웨이 및 아날로그 회선 게이트웨이가 이에 해당합니다. Megaco의 주요 기능은 게이트웨이 에이전트를 콜 에이전트 (통화 제어) 파트 (MGC라고도 함)-마스터 및 게이트웨이 인터페이스 파트 (매체 게이트웨이, MG)-슬레이브로 분해하는 것입니다. MG는 통화 제어 지식이 없으며 연결 및 간단한 구성 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5bffe747cacf35d066423541d229ecb49cc0807e" translate="yes" xml:space="preserve">
          <source>Megaco message transformation utility.</source>
          <target state="translated">Megaco 메시지 변환 유틸리티.</target>
        </trans-unit>
        <trans-unit id="20993d68c2198a64d2417ac2d87867b327655a8f" translate="yes" xml:space="preserve">
          <source>Megaco transport behaviour.</source>
          <target state="translated">Megaco 운송 행동.</target>
        </trans-unit>
        <trans-unit id="234c693a674eb5d604a026611a56402135865454" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 is a protocol for control of elements in a physically decomposed multimedia gateway, enabling separation of call control from media conversion. A Media Gateway Controller (MGC) controls one or more Media Gateways (MG).</source>
          <target state="translated">Megaco / H.248은 물리적으로 분해 된 멀티미디어 게이트웨이에서 요소를 제어하기위한 프로토콜로, 미디어 제어에서 통화 제어를 분리 할 수 ​​있습니다. MGC (Media Gateway Controller)는 하나 이상의 MG (Media Gateway)를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cda9df8ada294fa5717dc7c1fc6e9914b12f8c01" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 1 (RFC3525) updated according to Implementors Guide version 10-13.</source>
          <target state="translated">구현 자 안내서 버전 10-13에 따라 Megaco / H.248 버전 1 (RFC3525)이 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="8857c1ee6501c5ec79a912365370d5a6a0f747fc" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 2 as defined by draft-ietf-megaco-h248v2-04 updated according to Implementors Guide version 10-13.</source>
          <target state="translated">draft-ietf-megaco-h248v2-04에 의해 정의 된 Megaco / H.248 버전 2는 구현 자 안내서 버전 10-13에 따라 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="56058cc7ccdad804c1b70639153c0e96607997f8" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 3 as defined by ITU H.248.1 (09/2005).</source>
          <target state="translated">ITU H.248.1 (09/2005)에 의해 정의 된 Megaco / H.248 버전 3</target>
        </trans-unit>
        <trans-unit id="88287078a76b16499606b0eda112892d7c56b922" translate="yes" xml:space="preserve">
          <source>Membership of an object instance in an MIB view is determined by the following algorithm:</source>
          <target state="translated">MIB 뷰에서 객체 인스턴스의 멤버 자격은 다음 알고리즘에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="30350d30f29ea3b12a784ca65d59e4a1c44504dd" translate="yes" xml:space="preserve">
          <source>Memory allocated must be explicitly freed with a corresponding call to &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; (unless otherwise stated).</source>
          <target state="translated">별도의 언급이없는 한 , 할당 된 메모리는 &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; 에 대한 해당 호출로 명시 적으로 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e570bc956a4274803362d894f6047828e5106277" translate="yes" xml:space="preserve">
          <source>Memory allocation functions.</source>
          <target state="translated">메모리 할당 기능.</target>
        </trans-unit>
        <trans-unit id="2684c7e649eb37683099bd99b0ac2e74ac12a361" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/0&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 정보. 등가 &lt;code&gt;erlang:memory/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="158a065a76be26284f9a9200a508e6ac49bd3965" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/1&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 정보. 등가 &lt;code&gt;erlang:memory/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="909293f836f9e597ec4a004c609be9b42bb7b1af" translate="yes" xml:space="preserve">
          <source>Memory allocator system flags have the following syntax: &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; is a letter identifying a subsystem, &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; is a parameter, and &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; is the value to use. The flags can be passed to the Erlang emulator (&lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;) as command-line arguments.</source>
          <target state="translated">메모리 할당 자 시스템 플래그의 구문은 &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 는 하위 시스템을 식별하는 문자이고 &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; 는 매개 변수이며 &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; 는 사용할 값입니다. 플래그는 명령 행 인수로 Erlang 에뮬레이터 ( &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; )에 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dd2eade140452aa8bdce3e4ed57281be8adbbab" translate="yes" xml:space="preserve">
          <source>Memory allocator-specific flags. For more information, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메모리 할당 자 특정 플래그. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdb6e5cf15d341e3aa96990976dacd306d089ec3" translate="yes" xml:space="preserve">
          <source>Memory consumption, system limits</source>
          <target state="translated">메모리 소비, 시스템 제한</target>
        </trans-unit>
        <trans-unit id="7527155aa02588eea7da969db8693cc9ca0cf4a9" translate="yes" xml:space="preserve">
          <source>Memory types:</source>
          <target state="translated">메모리 유형 :</target>
        </trans-unit>
        <trans-unit id="1ac17298e965f8785571301bd292200f1c1741e9" translate="yes" xml:space="preserve">
          <source>Memory use for the loaded code, in bytes.</source>
          <target state="translated">로드 된 코드의 메모리 사용 (바이트)</target>
        </trans-unit>
        <trans-unit id="4dd0c06f98123356440797c194d0014596cf4b1f" translate="yes" xml:space="preserve">
          <source>Memory use for the old code, if any.</source>
          <target state="translated">이전 코드에 메모리 사용 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="2bbb76271791ef8b2e5ac70d40f275e4232f3424" translate="yes" xml:space="preserve">
          <source>Mende_Kikakui</source>
          <target state="translated">Mende_Kikakui</target>
        </trans-unit>
        <trans-unit id="119e8b7d23fe6df42b1eaf06cf2b4d696139b05c" translate="yes" xml:space="preserve">
          <source>Merge the specified PLTs to create the initial PLT. This requires that the PLTs are disjoint (that is, do not have any module appearing in more than one PLT). The PLTs are created in the usual way:</source>
          <target state="translated">지정된 PLT를 병합하여 초기 PLT를 작성하십시오. 이를 위해서는 PLT가 분리되어 있어야합니다 (즉, 둘 이상의 PLT에 모듈이 나타나지 않음). PLT는 일반적인 방법으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e3929df6cd4273ec09922ee67ab9ff5aa6b66122" translate="yes" xml:space="preserve">
          <source>Merges source code files and syntax trees to a single syntax tree. This is a file-reading front end to &lt;code&gt;merge_sources/3&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and included. All the input modules must be distinctly named.</source>
          <target state="translated">소스 코드 파일과 구문 트리를 단일 구문 트리로 병합합니다. 이것은 &lt;code&gt;merge_sources/3&lt;/code&gt; 의 파일 읽기 프론트 엔드 입니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 파일의 이름이 아니라 결과 모듈의 이름을 지정합니다. &lt;code&gt;Sources&lt;/code&gt; 는 구문 트리 목록 및 / 또는 &quot;소스 코드 형식&quot;구문 트리 목록으로, 각 항목은 모듈 정의를 나타냅니다. &lt;code&gt;Files&lt;/code&gt; 은 읽고 포함 할 소스 모듈의 파일 이름 및 / 또는 모듈 이름 목록입니다. 모든 입력 모듈의 이름을 분명히 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="914f8309af3ca6cfa2e83d7e921c466e8a40172d" translate="yes" xml:space="preserve">
          <source>Merges source code files to a single file. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and merged (see &lt;code&gt;merge_files/4&lt;/code&gt; for details). All the input modules must be distinctly named.</source>
          <target state="translated">소스 코드 파일을 단일 파일로 병합합니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 파일의 이름이 아니라 결과 모듈의 이름을 지정합니다. &lt;code&gt;Files&lt;/code&gt; 은 읽고 병합 할 소스 모듈의 파일 이름 및 / 또는 모듈 이름 목록입니다 (자세한 내용은 &lt;code&gt;merge_files/4&lt;/code&gt; 참조). 모든 입력 모듈의 이름을 분명히 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="61ef0f26ed0f675da05d869af4a295417123a3d7" translate="yes" xml:space="preserve">
          <source>Merges syntax trees to a single syntax tree. This is the main code merging &quot;engine&quot;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees of type &lt;code&gt;form_list&lt;/code&gt; and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. All the input modules must be distinctly named.</source>
          <target state="translated">구문 트리를 단일 구문 트리로 병합합니다. &quot;엔진&quot;을 병합하는 주요 코드입니다. &lt;code&gt;Name&lt;/code&gt; 은 결과 모듈의 이름을 지정합니다. &lt;code&gt;Sources&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 구문 트리 목록 및 / 또는 &quot;소스 코드 양식&quot;구문 트리 목록으로, 각 항목은 모듈 정의를 나타냅니다. 모든 입력 모듈의 이름을 분명히 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d2a293b058966cf02ea5fa803aede107a277d1e" translate="yes" xml:space="preserve">
          <source>Merges terms on files. Each input file is assumed to be sorted.</source>
          <target state="translated">파일에 용어를 병합합니다. 각 입력 파일은 정렬 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ca627cc38a16c0db5470a1230525775bd4b5efc4" translate="yes" xml:space="preserve">
          <source>Merges tuples on files. Each input file is assumed to be sorted on key(s).</source>
          <target state="translated">파일에서 튜플을 병합합니다. 각 입력 파일은 키별로 정렬되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6351ca1bc7f6afb34d654f76c66afcef185ec40c" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Dict1&lt;/code&gt; and &lt;code&gt;Dict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">&lt;code&gt;Dict1&lt;/code&gt; 과 &lt;code&gt;Dict2&lt;/code&gt; 두 사전을 병합 하여 새 사전을 만듭니다. 두 사전의 모든 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 쌍이 새 사전에 포함됩니다. 두 사전에서 키가 발생 하면 키와 두 값으로 &lt;code&gt;Fun&lt;/code&gt; 을 호출하여 새 값을 반환합니다. &lt;code&gt;merge&lt;/code&gt; 은 다음과 같이 정의 할 수 있지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d26d2ded712b884fedeee08ada284ef051b3b38a" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Orddict1&lt;/code&gt; and &lt;code&gt;Orddict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge/3&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">두 개의 사전 인 &lt;code&gt;Orddict1&lt;/code&gt; 및 &lt;code&gt;Orddict2&lt;/code&gt; 를 병합 하여 새 사전을 작성하십시오. 두 사전의 모든 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 쌍이 새 사전에 포함됩니다. 두 사전에서 키가 발생 하면 키와 두 값으로 &lt;code&gt;Fun&lt;/code&gt; 을 호출하여 새 값을 반환합니다. &lt;code&gt;merge/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ec7e01625093b63d2959063dd1a662a878ea5c0e" translate="yes" xml:space="preserve">
          <source>Merges two maps into a single map &lt;code&gt;Map3&lt;/code&gt;. If two keys exist in both maps, the value in &lt;code&gt;Map1&lt;/code&gt; is superseded by the value in &lt;code&gt;Map2&lt;/code&gt;.</source>
          <target state="translated">두 개의 맵을 단일 맵 &lt;code&gt;Map3&lt;/code&gt; 에 병합합니다 . 두 맵에 두 개의 키가 있으면 &lt;code&gt;Map1&lt;/code&gt; 의 값이 &lt;code&gt;Map2&lt;/code&gt; 의 값으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="6735763c165e3286d74b4273c933f33e3f5ec752" translate="yes" xml:space="preserve">
          <source>Merging different versions of the schema table does not always require the cookies to be the same. If the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;, the cookie is immutable, and all other &lt;code&gt;db_nodes&lt;/code&gt; must have the same cookie. When the schema is stored as type &lt;code&gt;ram_copies&lt;/code&gt;, its cookie can be replaced with a cookie from another node (&lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt;). The cookie replacement (during merge of the schema table definition) is performed each time a RAM node connects to another node.</source>
          <target state="translated">다른 버전의 스키마 테이블을 병합 할 때 항상 쿠키가 동일 할 필요는 없습니다. 스키마 테이블의 스토리지 유형이 &lt;code&gt;disc_copies&lt;/code&gt; 인 경우 쿠키는 변경할 수 &lt;code&gt;db_nodes&lt;/code&gt; 다른 모든 db_node 는 동일한 쿠키를 가져야합니다. 스키마가 &lt;code&gt;ram_copies&lt;/code&gt; 유형으로 저장 되면 해당 쿠키는 다른 노드 ( &lt;code&gt;ram_copies&lt;/code&gt; 또는 &lt;code&gt;disc_copies&lt;/code&gt; ) 의 쿠키로 대체 될 수 있습니다 . RAM 노드가 다른 노드에 연결될 때마다 쿠키 스키마 교체 (스키마 테이블 정의 병합 중)가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="41b5e66fa06088a4b56fe703bb862a285dff3ab5" translate="yes" xml:space="preserve">
          <source>Merl can only parse a fragment of text if it follows the basic syntactical rules of Erlang. In most places, a normal Erlang variable can be used as metavariable, for example:</source>
          <target state="translated">Merl은 Erlang의 기본 구문 규칙을 따르는 경우에만 텍스트 조각을 구문 분석 할 수 있습니다. 대부분의 경우, 일반적인 Erlang 변수를 다음과 같이 메타 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fad43e700acf724fbc03a57e905d1e33999d5a95" translate="yes" xml:space="preserve">
          <source>Meroitic_Cursive</source>
          <target state="translated">Meroitic_Cursive</target>
        </trans-unit>
        <trans-unit id="16256e81ed15ae584494444b4607752969d09a87" translate="yes" xml:space="preserve">
          <source>Meroitic_Hieroglyphs</source>
          <target state="translated">Meroitic_Hieroglyphs</target>
        </trans-unit>
        <trans-unit id="0d77c6f0a440925729997c58732eb390465bad0a" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP agent</source>
          <target state="translated">SNMP 에이전트의 메시지 처리 및 디스패치 모듈</target>
        </trans-unit>
        <trans-unit id="834a3b3a12d9955dd19120adc9ef57807900ee6d" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP manager</source>
          <target state="translated">SNMP 관리자 용 메시지 처리 및 디스패치 모듈</target>
        </trans-unit>
        <trans-unit id="dfb051fb0d4beb2aa1f14d08e0e4d39de55bd026" translate="yes" xml:space="preserve">
          <source>Message Transformation</source>
          <target state="translated">메시지 변환</target>
        </trans-unit>
        <trans-unit id="79df93b3eaeb4cccfb42f6840f1b4d449096cc8e" translate="yes" xml:space="preserve">
          <source>Message authentication code</source>
          <target state="translated">메시지 인증 코드</target>
        </trans-unit>
        <trans-unit id="c6d065b029fde73824807bcb7a4f88522968466d" translate="yes" xml:space="preserve">
          <source>Message errors are detected remotely on the other side of the protocol. And you probably don't want to reply to it, but it may indicate that you have outstanding transactions that not will get any response (request -&amp;gt; reply; reply -&amp;gt; ack).</source>
          <target state="translated">프로토콜의 다른 쪽에서 원격으로 메시지 오류가 감지됩니다. 그리고 답장하고 싶지 않을 수도 있지만 응답이없는 미결 거래가 있음을 나타낼 수 있습니다 (요청-&amp;gt; 답장; 답장-&amp;gt; ack).</target>
        </trans-unit>
        <trans-unit id="19842f503704a8912fdf5969e80cd251a7b79c11" translate="yes" xml:space="preserve">
          <source>Message package file</source>
          <target state="translated">메시지 패키지 파일</target>
        </trans-unit>
        <trans-unit id="03bf9094ba44ce8eb3a756071ecbb6363ddf4c1c" translate="yes" xml:space="preserve">
          <source>Message reception detects 5001, 5004, 5005, 5008, 5009, 5010, 5011, 5014, 5015, and 5017 errors. It ignores 5013 errors at the admonition of sections 3 and 4.1.</source>
          <target state="translated">메시지 수신은 5001, 5004, 5005, 5008, 5009, 5010, 5011, 5014, 5015 및 5017 오류를 감지합니다. 섹션 3과 4.1의 권고에서 5013 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2297ecf9967e2341ba11a1ac6137bfeff96d6f16" translate="yes" xml:space="preserve">
          <source>Message records</source>
          <target state="translated">메시지 기록</target>
        </trans-unit>
        <trans-unit id="31deece58687e26fd50c8809af9d97cfb48aa92a" translate="yes" xml:space="preserve">
          <source>Message sending is asynchronous and safe, the message is guaranteed to eventually reach the recipient, provided that the recipient exists.</source>
          <target state="translated">메시지 전송은 비동기적이고 안전하며, 수신자가 존재하는 경우 메시지는 결국 수신자에게 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c63e918af7eff798c82c0e88aefb50d97f2578" translate="yes" xml:space="preserve">
          <source>Message size at which SCTP fragmentation occurs</source>
          <target state="translated">SCTP 조각화가 발생하는 메시지 크기</target>
        </trans-unit>
        <trans-unit id="7bf49996d9fb115e00764acfda8430d93e84eb42" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac347e4302154cf539a13312237b96cc114cdfa9" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;. Or rather, the absence of.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; . 또는 오히려.</target>
        </trans-unit>
        <trans-unit id="861b1c2d1e66807add82f45f362fb827341c6bc5" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64249446e1241b8f9d4c261cdb93987c31f20de2" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d456b159601bfe4ba88f4b3b670553e61afb6b4d" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="498dd804ab57af76daece1cf044904cff1eb753f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fef22350b8b577df133e3cb6cedbf6dc60aaa87c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d00e4b40aebde71fd90f9fddfebc8612e44ddb8f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef5f53652270bb984920cbfaaa3925022a3b6e1c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7160c31113f5c016d9d063ac1996aecb61589a8a" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff3b1c2d91914176c2ace60ad5ed8c3dbe8dfb0" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 태그 : &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83c1bde9d4d8aa8318863a5d51aa34ce5bfc795" translate="yes" xml:space="preserve">
          <source>Messages are delivered on a per line basis. Each line (delimited by the OS-dependent newline sequence) is delivered in a single message. The message data format is &lt;code&gt;{Flag, Line}&lt;/code&gt;, where &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;eol&lt;/code&gt; or &lt;code&gt;noeol&lt;/code&gt;, and &lt;code&gt;Line&lt;/code&gt; is the data delivered (without the newline sequence).</source>
          <target state="translated">메시지는 라인 단위로 전달됩니다. 각 라인 (OS 종속적 인 개행 시퀀스로 구분)은 단일 메시지로 전달됩니다. 메시지 데이터 형식은 &lt;code&gt;{Flag, Line}&lt;/code&gt; 이며, 여기서 &lt;code&gt;Flag&lt;/code&gt; 는 &lt;code&gt;eol&lt;/code&gt; 또는 &lt;code&gt;noeol&lt;/code&gt; 이며 &lt;code&gt;Line&lt;/code&gt; 은 개행 시퀀스없이 전달 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="4efc9f43ab150329eedfc4f946099f0a5f3094d9" translate="yes" xml:space="preserve">
          <source>Messages are preceded by their length, sent in &lt;code&gt;N&lt;/code&gt; bytes, with the most significant byte first. The valid values for &lt;code&gt;N&lt;/code&gt; are 1, 2, and 4.</source>
          <target state="translated">메시지의 길이는 &lt;code&gt;N&lt;/code&gt; 바이트 단위로 전송되며 가장 중요한 바이트가 먼저 표시됩니다. &lt;code&gt;N&lt;/code&gt; 의 유효한 값 은 1, 2 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="6b07457b9a14b5fa6fa1cbfe7c24fba2d20941a5" translate="yes" xml:space="preserve">
          <source>Messages are sent to this process in the format &lt;code&gt;{http, ReplyInfo}&lt;/code&gt;.</source>
          <target state="translated">메시지는 &lt;code&gt;{http, ReplyInfo}&lt;/code&gt; 형식으로이 프로세스로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="dea0176313f64667ac747bcda6d934ed85bcd005" translate="yes" xml:space="preserve">
          <source>Messages between Erlang processes are simply valid Erlang terms. That is, they can be lists, tuples, integers, atoms, pids, and so on.</source>
          <target state="translated">Erlang 프로세스 간의 메시지는 단순히 유효한 Erlang 용어입니다. 즉, 목록, 튜플, 정수, 원자, pid 등이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba3a1c108d58aee0ff81fd9ec2d1208708c9bdb" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">연결이 설정되기 전에 인코딩 된 메시지는 여전히 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지를 사용할 수 있습니다 . 그러나 &lt;code&gt;SEND_SENDER&lt;/code&gt; 또는 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 제어 메시지가 전송되면 연결에서 동일한 방향으로 더 이상 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지가 전송 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="21f2cc5097a001d22180191c6222e6d580784485" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND_TT&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND_TT&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">연결이 설정되기 전에 인코딩 된 메시지는 여전히 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지를 사용할 수 있습니다 . 그러나 &lt;code&gt;SEND_SENDER&lt;/code&gt; 또는 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 제어 메시지가 전송되면 연결에서 동일한 방향으로 더 이상 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지가 전송 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b450d9a68961ebef8efd8c7dece1b02f8d8dab97" translate="yes" xml:space="preserve">
          <source>Messages received from the operating system results in an user defined callback function being called. This function can do whatever filtering and formatting is necessary and then deploy any type of logging suitable for the user's application.</source>
          <target state="translated">운영 체제에서 수신 한 메시지는 사용자 정의 콜백 함수가 호출됩니다. 이 기능은 필요한 필터링 및 형식 지정을 수행 한 다음 사용자 응용 프로그램에 적합한 모든 유형의 로깅을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a53365e992adfd42db65c7720bf07ff4ac1814b" translate="yes" xml:space="preserve">
          <source>Messing up for subsequent test cases:</source>
          <target state="translated">후속 테스트 사례에 대한 혼란 :</target>
        </trans-unit>
        <trans-unit id="30041e23a0f72a119313b16f9b3d4df540137e77" translate="yes" xml:space="preserve">
          <source>Meta-tracing traces all processes and does not care about the process trace flags set by &lt;code&gt;erlang:trace/3&lt;/code&gt;, the trace flags are instead fixed to &lt;code&gt;[call, timestamp]&lt;/code&gt;.</source>
          <target state="translated">메타 추적은 모든 프로세스를 추적하고 &lt;code&gt;erlang:trace/3&lt;/code&gt; 에 의해 설정된 프로세스 추적 플래그를 신경 쓰지 않고 추적 플래그는 대신 &lt;code&gt;[call, timestamp]&lt;/code&gt; 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d674c23267ff3e893a9e1474fed16ac7f558c49" translate="yes" xml:space="preserve">
          <source>Metadata associated with one specific log event is given as the last parameter to the log macro or Logger API function when the event is issued. For example:</source>
          <target state="translated">하나의 특정 로그 이벤트와 연관된 메타 데이터는 이벤트가 발행 될 때 로그 매크로 또는 로거 API 함수의 마지막 매개 변수로 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="885e65968ef7efdba81656ad741bbd6682841ebf" translate="yes" xml:space="preserve">
          <source>Metadata contains additional data associated with a log message. Logger inserts some metadata fields by default, and the client can add custom metadata in two different ways:</source>
          <target state="translated">메타 데이터에는 로그 메시지와 관련된 추가 데이터가 포함됩니다. 로거는 기본적으로 일부 메타 데이터 필드를 삽입하며 클라이언트는 두 가지 방법으로 사용자 정의 메타 데이터를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e44a13044d8e9cd06618d7ce5207e1fbeec00f" translate="yes" xml:space="preserve">
          <source>Metadata for the log event.</source>
          <target state="translated">로그 이벤트의 메타 데이터.</target>
        </trans-unit>
        <trans-unit id="4342240162e294c2bc03db17fdee5ddbc87876d8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang.</source>
          <target state="translated">Erlang의 메타 프로그래밍.</target>
        </trans-unit>
        <trans-unit id="87ced016c5bb1aba95f8f208a0c630b0abd89fd8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang. Merl is a more user friendly interface to the &lt;code&gt;erl_syntax&lt;/code&gt; module, making it easy both to build new ASTs from scratch and to match and decompose existing ASTs. For details that are outside the scope of Merl itself, please see the documentation of &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang의 메타 프로그래밍. Merl은 &lt;code&gt;erl_syntax&lt;/code&gt; 모듈 에 대한 사용자 친화적 인 인터페이스로, 새로운 AST를 처음부터 새로 작성하고 기존 AST를 일치시키고 분해 할 수 있습니다. Merl 자체의 범위를 벗어난 세부 사항은 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc7e0e02c16756d9acee15cd9d7a7473daeb068d" translate="yes" xml:space="preserve">
          <source>Miao</source>
          <target state="translated">Miao</target>
        </trans-unit>
        <trans-unit id="1ead8ccfae61c22af5dea71102bcf319bd3b337a" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net</source>
          <target state="translated">Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net</target>
        </trans-unit>
        <trans-unit id="e3161feceeebbf2efa94b967c31c3a533e827d4e" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</source>
          <target state="translated">Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</target>
        </trans-unit>
        <trans-unit id="c51b97dfe72702f7a4db88668d6bbc27ffd18957" translate="yes" xml:space="preserve">
          <source>Microseconds</source>
          <target state="translated">Microseconds</target>
        </trans-unit>
        <trans-unit id="ad4d37efa374335ef5074617d100776dbcc4796b" translate="yes" xml:space="preserve">
          <source>Microsofts Windows SDK version 8.1 (corresponding to VC++ 12.0 and Visual Studio 2013). You'll find it here:</source>
          <target state="translated">Microsoft의 Windows SDK 버전 8.1 (VC ++ 12.0 및 Visual Studio 2013에 해당) 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe50fa08740afc3a20f9d3d442ba75955fee423" translate="yes" xml:space="preserve">
          <source>Microstate accounting can be used to measure how much time the Erlang runtime system spends doing various tasks. It is designed to be as lightweight as possible, but some overhead exists when this is enabled. Microstate accounting is meant to be a profiling tool to help finding performance bottlenecks. To &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt;/&lt;code&gt;reset&lt;/code&gt; microstate accounting, use system flag &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마이크로 스테이트 계정은 Erlang 런타임 시스템이 다양한 작업을 수행하는 데 걸리는 시간을 측정하는 데 사용할 수 있습니다. 가능한 한 경량으로 설계되었지만이 기능을 사용하면 약간의 오버 헤드가 있습니다. 마이크로 스테이트 회계는 성능 병목 현상을 찾는 데 도움이되는 프로파일 링 도구입니다. 마이크로 스테이트 계정 을 &lt;code&gt;start&lt;/code&gt; / &lt;code&gt;stop&lt;/code&gt; / &lt;code&gt;reset&lt;/code&gt; 하려면 시스템 플래그 &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bc93878c3ba17340102ebf0f740f8c3302add0b" translate="yes" xml:space="preserve">
          <source>Milliseconds</source>
          <target state="translated">Milliseconds</target>
        </trans-unit>
        <trans-unit id="fb85391c2c8505ba20e51e3d8c6b33571699f58c" translate="yes" xml:space="preserve">
          <source>Min detail level deactivates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">최소 세부 사항 레벨은 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 호출 추적을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="68daf61d5874aaae0cf757e3faf2f324a6515679" translate="yes" xml:space="preserve">
          <source>MinBinVHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinBinVHeapSize :: 정수 ()&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="4fed7661f4d42301d68ec8563e610bd36ddbbfe8" translate="yes" xml:space="preserve">
          <source>MinHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinHeapSize :: 정수 ()&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="f25a88ac3eb732d57dc4ba0d3e990489173fb9aa" translate="yes" xml:space="preserve">
          <source>Minimizes the representation of all entries in the list. This is equivalent to &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt;.</source>
          <target state="translated">목록에있는 모든 항목의 표현을 최소화합니다. 이것은 &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32e23d465d0629b84d76e5f09fb507ede0cb1461" translate="yes" xml:space="preserve">
          <source>Miscellaneous flags:</source>
          <target state="translated">기타 플래그 :</target>
        </trans-unit>
        <trans-unit id="3e70a7515b00e7c226a15edab218fd1f4dd573e0" translate="yes" xml:space="preserve">
          <source>Miscellaneous utility functions to be used when implementing Erlang web server API modules.</source>
          <target state="translated">Erlang 웹 서버 API 모듈을 구현할 때 사용되는 기타 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="e28720b55817fffaed736aa55d8047afa4cf1137" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file or searching one of the parent directories.</source>
          <target state="translated">파일을 읽거나 상위 디렉토리 중 하나를 검색 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7aa38c37efdf79a5acef9cef7e555976f20e2ad9" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file, or for searching one of the parent directories.</source>
          <target state="translated">파일을 읽거나 상위 디렉토리 중 하나를 검색하기위한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9efd7c6d83c7981adb874ec7297e295c58042b1f" translate="yes" xml:space="preserve">
          <source>Missing permission for the directory or one of its parents.</source>
          <target state="translated">디렉토리 또는 상위 디렉토리 중 하나에 대한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3baa40bad1885eea32466c0be3b003163935955e" translate="yes" xml:space="preserve">
          <source>Missing permission for the file or one of its parents.</source>
          <target state="translated">파일 또는 상위 파일 중 하나에 대한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da94f56d96d2d085bea8dd51d423535445ba4d6f" translate="yes" xml:space="preserve">
          <source>Missing permission for writing the file or searching one of the parent directories.</source>
          <target state="translated">파일을 쓰거나 상위 디렉토리 중 하나를 검색 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="061e8bb20890cbf13271d93b5804b980c9a0f90b" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Existing&lt;/code&gt; or &lt;code&gt;New&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Existing&lt;/code&gt; 또는 &lt;code&gt;New&lt;/code&gt; 의 상위 디렉토리에 대한 읽기 또는 쓰기 권한이 누락되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b9b56e3be8c9130a50f7b4b55f58db626553ba0" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt;. On some platforms, this error is given if either &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt; is open.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 또는 &lt;code&gt;Destination&lt;/code&gt; 의 상위 디렉토리에 대한 읽기 또는 쓰기 권한이 없습니다 . 일부 플랫폼에서 &lt;code&gt;Source&lt;/code&gt; 또는 &lt;code&gt;Destination&lt;/code&gt; 이 열려 있으면이 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="28336423496ccaf52c7936f6b41a6f9ad88604eb" translate="yes" xml:space="preserve">
          <source>Missing read permission for one of the parents of the current directory.</source>
          <target state="translated">현재 디렉토리의 부모 중 하나에 대한 읽기 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5005e02795d55eb02a3f6a112157b99bce1e935" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for &lt;code&gt;Dir&lt;/code&gt; or one of its parent directories.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 또는 상위 디렉토리 중 하나에 대한 검색 또는 쓰기 권한이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dc45e80a5b65727123e0ebc0703fe14768293b68" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for the parent directories of &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 의 상위 디렉토리에 대한 검색 또는 쓰기 권한이 누락되었습니다 .</target>
        </trans-unit>
        <trans-unit id="dc1c55c040e5f0948f15231f73c916f3526d9f6e" translate="yes" xml:space="preserve">
          <source>Missing search permission for one of the parent directories of the file.</source>
          <target state="translated">파일의 상위 디렉토리 중 하나에 대한 검색 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3450bbc34d200da9fb5b92b5c6f6571a71324a0a" translate="yes" xml:space="preserve">
          <source>Mnesia As Authentication Database</source>
          <target state="translated">인증 데이터베이스로서의 Mnesia</target>
        </trans-unit>
        <trans-unit id="3e14767dc1dedaea0f193b494b8754d578aec896" translate="yes" xml:space="preserve">
          <source>Mnesia contains the following features that combine to produce a fault-tolerant, distributed DBMS written in Erlang:</source>
          <target state="translated">Mnesia에는 Erlang으로 작성된 내결함성 분산 DBMS를 생성하기 위해 결합 된 다음 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d270fde8f4afa30deacf2e5ac64258dc95380f4" translate="yes" xml:space="preserve">
          <source>Mnesia forwards calls to the following functions:</source>
          <target state="translated">Mnesia는 다음 기능으로 전화를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e89dea5925db30b38ca5a4a01818590924fb2279" translate="yes" xml:space="preserve">
          <source>Mnesia has no special counter records. However, records of the form &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; can be used as (possibly disc-resident) counters when &lt;code&gt;Tab&lt;/code&gt; is a &lt;code&gt;set&lt;/code&gt;. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetics, and then writing the record:</source>
          <target state="translated">Mnesia에는 특별한 카운터 기록이 없습니다. 그러나 형태의 기록 &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; 때와 (아마도 디스크 상주) 카운터를 사용할 수있는 &lt;code&gt;Tab&lt;/code&gt; A는 &lt;code&gt;set&lt;/code&gt; . 이 기능은 양수 또는 음수로 카운터를 업데이트합니다. 그러나 카운터는 절대로 0보다 작아 질 수 없습니다. 이 함수와 먼저 레코드를 읽고, 산술을 수행 한 다음, 레코드를 작성하는 동작에는 두 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2c5988b423c05d899728a690476666f426fc19" translate="yes" xml:space="preserve">
          <source>Mnesia is a multiuser distributed DBMS specially made for industrial telecommunications applications written in Erlang, which is also the intended target language. Mnesia tries to address all the data management issues required for typical telecommunications systems. It has a number of features that are not normally found in traditional databases.</source>
          <target state="translated">Mnesia는 Erlang으로 작성된 산업용 통신 응용 프로그램을 위해 특별히 제작 된 다중 사용자 분산 DBMS이며, 대상 언어이기도합니다. Mnesia는 일반적인 통신 시스템에 필요한 모든 데이터 관리 문제를 해결하려고합니다. 기존 데이터베이스에는 일반적으로 제공되지 않는 많은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0af7e030b61efa3af7bcba4659fb088190690f3" translate="yes" xml:space="preserve">
          <source>Mnesia is also interesting because of its tight coupling to Erlang, thus almost turning Erlang into a database programming language. This has many benefits, the foremost is that the impedance mismatch between the data format used by the DBMS and the data format used by the programming language, which is used to manipulate the data, completely disappears.</source>
          <target state="translated">Mnesia는 Erlang과의 긴밀한 결합으로 인해 Erlang을 데이터베이스 프로그래밍 언어로 거의 바꾸어 놓기 때문에 흥미 롭습니다. 이는 많은 이점이 있으며, 가장 중요한 것은 DBMS에서 사용하는 데이터 형식과 데이터를 조작하는 데 사용되는 프로그래밍 언어에서 사용하는 데이터 형식 사이의 임피던스 불일치가 완전히 사라진다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44aa259738f2f02d017fee9119158e2bcbe7c0c2" translate="yes" xml:space="preserve">
          <source>Mnesia is designed with the typical data management problems of telecommunications applications in mind. This sets Mnesia apart from most other DBMS. Hence Mnesia combines many concepts found in traditional databases such as transactions and queries with concepts found in data management systems for telecommunications applications, for example:</source>
          <target state="translated">Mnesia는 통신 애플리케이션의 일반적인 데이터 관리 문제를 염두에두고 설계되었습니다. 이것은 대부분의 다른 DBMS와는 별도로 Mnesia를 설정합니다. 따라서 Mnesia는 트랜잭션 및 쿼리와 같은 기존 데이터베이스에서 볼 수있는 많은 개념을 통신 응용 프로그램의 데이터 관리 시스템에서 볼 수있는 개념과 결합합니다.</target>
        </trans-unit>
        <trans-unit id="df09d370f13b24dc32d72bd352185aa6d3460032" translate="yes" xml:space="preserve">
          <source>Mnesia is implemented in, and tightly connected to Erlang. It provides the functionality that is necessary for the implementation of fault tolerant telecommunications systems.</source>
          <target state="translated">Mnesia는 Erlang에 구현되어 있으며 Erlang과 밀접하게 연결되어 있습니다. 내결함성 통신 시스템의 구현에 필요한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc6fa382209f2c0fc7fcb32177c787306e164f05" translate="yes" xml:space="preserve">
          <source>Mnesia is not as appropriate with the following types of applications:</source>
          <target state="translated">Mnesia는 다음 유형의 응용 프로그램에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="845e3498f5ba4596f8fba48d33cc6a74bac4d6f0" translate="yes" xml:space="preserve">
          <source>Mnesia is started on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia는 노드에서 시작됩니다. &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3e1fa53e8464658bfcdc7fbdecb69fa1444e78e" translate="yes" xml:space="preserve">
          <source>Mnesia is stopped on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia는 노드에서 중지됩니다. &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1dcaece45ef92fbe42e06c5252abce132af739" translate="yes" xml:space="preserve">
          <source>Mnesia reads the following application configuration parameters:</source>
          <target state="translated">Mnesia는 다음 애플리케이션 구성 매개 변수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6d914dda751476720c28b61ae3bd0ff8b42cfeb7" translate="yes" xml:space="preserve">
          <source>Mode = &lt;code&gt;active | passive&lt;/code&gt;</source>
          <target state="translated">모드 = &lt;code&gt;active | passive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99f50e7814fad5179000cd91fa4e8ee4f72c44ef" translate="yes" xml:space="preserve">
          <source>Mode for running multiple independent test sessions in parallel with central control and configuration</source>
          <target state="translated">중앙 제어 및 구성과 동시에 여러 개의 독립적 인 테스트 세션을 실행하기위한 모드</target>
        </trans-unit>
        <trans-unit id="2620d89dab477718fe6a6ecadb48be52562f1585" translate="yes" xml:space="preserve">
          <source>Modi</source>
          <target state="translated">Modi</target>
        </trans-unit>
        <trans-unit id="347a94d0029aefe56171fcf91033436e5c682c85" translate="yes" xml:space="preserve">
          <source>Modified timing affects the following:</source>
          <target state="translated">수정 된 타이밍은 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="bad23ea5529c0f8c6c8d290e83637676c692c2dd" translate="yes" xml:space="preserve">
          <source>Modifier letter</source>
          <target state="translated">수정 자 편지</target>
        </trans-unit>
        <trans-unit id="253879158d55c56d709e1481da82674291cad63a" translate="yes" xml:space="preserve">
          <source>Modifier symbol</source>
          <target state="translated">수정 자 기호</target>
        </trans-unit>
        <trans-unit id="a0cfb5739548a4dc910c1db16690c1ef42b6dcf6" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree, while at the same time updating an accumulator. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as second argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The modified &lt;code&gt;erl_parse&lt;/code&gt; tree and the final value of the accumulator are returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">수정합니다 &lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 적용하여 &lt;code&gt;Fun&lt;/code&gt; 의 노드의 주석을 각 컬렉션 &lt;code&gt;erl_parse&lt;/code&gt; 를 동시에 어큐뮬레이터를 업데이트하는 동안, 나무. &lt;code&gt;Fun&lt;/code&gt; 에 대한 첫 번째 호출 은 두 번째 인수로 &lt;code&gt;AccIn&lt;/code&gt; 을 가지며 , 반환 된 누산기 &lt;code&gt;AccOut&lt;/code&gt; 은 다음 호출로 전달됩니다. 수정 된 &lt;code&gt;erl_parse&lt;/code&gt; 트리와 누산기의 최종 값이 반환됩니다. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="ada6b07489b4caa86b644d594e210d3d7df73a75" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">수정합니다 &lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 적용하여 &lt;code&gt;Fun&lt;/code&gt; 의 노드의 주석을 각 컬렉션 &lt;code&gt;erl_parse&lt;/code&gt; 의 나무. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="d6767e7b3024caf3c0392eb069c62606173a9f1a" translate="yes" xml:space="preserve">
          <source>Modifies the filename of the annotations Anno.</source>
          <target state="translated">주석 Anno의 파일 이름을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f5817a19c5f89b9a4e372f141f435c1a42a9dd33" translate="yes" xml:space="preserve">
          <source>Modifies the generated marker of the annotations Anno.</source>
          <target state="translated">주석 Anno의 생성 된 마커를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="037defcfe58535f15797aebbd1fbb203e7cd9af8" translate="yes" xml:space="preserve">
          <source>Modifies the line of the annotations Anno.</source>
          <target state="translated">주석 Anno의 행을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="c6cc4351008b5ab2535c804b7cd295d8836544e6" translate="yes" xml:space="preserve">
          <source>Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option &lt;code&gt;preferred_algorithms&lt;/code&gt; (if existing) is applied.</source>
          <target state="translated">알고리즘 협상에 사용할 알고리즘 목록을 수정합니다. &lt;code&gt;preferred_algorithms&lt;/code&gt; (있는 경우) 옵션을 적용한 후에 수정 사항이 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1311f97ce347997edad775a69d938fac98b1ab7" translate="yes" xml:space="preserve">
          <source>Modifies the location of the annotations Anno.</source>
          <target state="translated">주석 Anno의 위치를 ​​수정합니다.</target>
        </trans-unit>
        <trans-unit id="cf1b78ca3bb67cc73d9a5ef2e74df6aa835b463e" translate="yes" xml:space="preserve">
          <source>Modifies the record marker of the annotations Anno.</source>
          <target state="translated">주석 Anno의 레코드 마커를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="7eb7754f43a795536f0ab7aea723cfd8a2dcf954" translate="yes" xml:space="preserve">
          <source>Modifies the text of the annotations Anno.</source>
          <target state="translated">주석 Anno의 텍스트를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="fad6e92bd8f724516530123632d526536ce733e0" translate="yes" xml:space="preserve">
          <source>Modify PATH and other environment variables so that all these tools are runnable from a bash shell. Still standing in &lt;code&gt;$ERL_TOP&lt;/code&gt;, issue the following commands (for 32-bit Windows, remove the x64 from the first row and change &lt;code&gt;otp_win64_21&lt;/code&gt; to &lt;code&gt;otp_win32_21&lt;/code&gt; on the last row):</source>
          <target state="translated">PATH 및 기타 환경 변수를 수정하여 이러한 모든 도구를 bash 쉘에서 실행할 수 있도록하십시오. 여전히 &lt;code&gt;$ERL_TOP&lt;/code&gt; 서서 다음 명령을 실행하십시오 (32 비트 Windows의 경우 첫 번째 행에서 x64를 제거 하고 마지막 행에서 &lt;code&gt;otp_win64_21&lt;/code&gt; 을 &lt;code&gt;otp_win32_21&lt;/code&gt; 로 변경 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="12f926fde51df220b3a44737fd7a8d3f5f5cf650" translate="yes" xml:space="preserve">
          <source>Modify an entry.</source>
          <target state="translated">항목을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="10f726edf41c57d1e88f9e6b3584066a593e9aea" translate="yes" xml:space="preserve">
          <source>Modify the DN of an entry. &lt;code&gt;DeleteOldRDN&lt;/code&gt; indicates whether the current RDN should be removed from the attribute list after the after operation. &lt;code&gt;NewSupDN&lt;/code&gt; is the new parent that the RDN shall be moved to. If the old parent should remain as parent, &lt;code&gt;NewSupDN&lt;/code&gt; shall be &quot;&quot;.</source>
          <target state="translated">항목의 DN을 수정하십시오. &lt;code&gt;DeleteOldRDN&lt;/code&gt; 은 이후 작업 후 속성 목록에서 현재 RDN을 제거 해야하는지 여부를 나타냅니다. &lt;code&gt;NewSupDN&lt;/code&gt; 은 RDN을 옮길 새 부모입니다. 이전 부모를 부모로 유지해야하는 경우 &lt;code&gt;NewSupDN&lt;/code&gt; 은 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="aaa722d609855294fcc06f9f555621df06ec84a5" translate="yes" xml:space="preserve">
          <source>Modify the default handler to only print errors and more severe log events to &quot;log/erlang.log&quot;, and add another handler to print all log events to &quot;log/debug.log&quot;.</source>
          <target state="translated">&quot;log / erlang.log&quot;에 오류 및 더 심각한 로그 이벤트 만 인쇄하도록 기본 핸들러를 수정하고 모든 로그 이벤트를 &quot;log / debug.log&quot;에 인쇄 할 다른 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d3fd275091bd2e943ed17a3e09212992146dc33a" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print each log event as a single line:</source>
          <target state="translated">기본 처리기를 수정하여 각 로그 이벤트를 한 줄로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="dd1a86ac0a2c106289b6452634be890061d7e0ee" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print the pid of the logging process for each log event:</source>
          <target state="translated">각 로그 이벤트에 대한 로깅 프로세스의 pid를 인쇄하도록 기본 핸들러를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="78a2b877311ab0e1542d92e5d0d77e8835127859" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print to a file instead of &lt;code&gt;standard_io&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 대신 파일로 인쇄하도록 기본 핸들러를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="60ff3ee60fb042d23c742fd31feed7fec7ed6a1c" translate="yes" xml:space="preserve">
          <source>Modify the password of a user.</source>
          <target state="translated">사용자의 비밀번호를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="78971b16f8399500c31431d1ca9618f6dee87669" translate="yes" xml:space="preserve">
          <source>Modify the password of a user. See &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자의 비밀번호를 수정하십시오. &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51b459ec8aabe598314683815cd6576876569d8f" translate="yes" xml:space="preserve">
          <source>Modifying answers is the responsibility of the user in callbacks from diameter.</source>
          <target state="translated">응답을 수정하는 것은 직경에서 콜백 할 때 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="e38d402d9b28b267f7bbb774745d5b1326cac05a" translate="yes" xml:space="preserve">
          <source>Module :: module(),</source>
          <target state="translated">모듈 :: module (),</target>
        </trans-unit>
        <trans-unit id="e2422bff0b69502b127f4dbc4235fb67ea1f739d" translate="yes" xml:space="preserve">
          <source>Module ::= Atom</source>
          <target state="translated">모듈 :: = 원자</target>
        </trans-unit>
        <trans-unit id="7da910aa1163387303b43f2f30ab78aed84ec504" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c7672bf31a9ad24405d2c26dfc8c63ce96e2a" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5bda4d30c8d6fa83505f2d8e9d0cca830b01ddf" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;multitrace&lt;/code&gt; in directory &lt;code&gt;src&lt;/code&gt; of the Observer application provides a small tool with three possible trace settings. The trace messages are written to binary files, which can be formatted with function &lt;code&gt;multitrace:format/1,2&lt;/code&gt;:</source>
          <target state="translated">Observer 응용 프로그램의 디렉토리 &lt;code&gt;src&lt;/code&gt; 에있는 모듈 &lt;code&gt;multitrace&lt;/code&gt; 트레이스는 세 가지 가능한 추적 설정을 가진 작은 도구를 제공합니다. 추적 메시지는 바이너리 파일에 기록되며 &lt;code&gt;multitrace:format/1,2&lt;/code&gt; 함수로 형식화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fadc79bb4f4079275ed96cbc52aaafb49fe144c9" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;ttb&lt;/code&gt; is the interface to all functions in Trace Tool Builder.</source>
          <target state="translated">모듈 &lt;code&gt;ttb&lt;/code&gt; 는 Trace Tool Builder의 모든 기능에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b1299646aab374780f3464f47be41a7599458cc8" translate="yes" xml:space="preserve">
          <source>Module Edges. All module calls.</source>
          <target state="translated">모듈 에지. 모든 모듈 호출.</target>
        </trans-unit>
        <trans-unit id="4de0a6a0634d489b9158f70004696bcc4b277613" translate="yes" xml:space="preserve">
          <source>Module and application names are atoms, while file and directory names are strings. For backward compatibility reasons, some functions accept both strings and atoms, but a future release will probably only allow the arguments that are documented.</source>
          <target state="translated">모듈 및 응용 프로그램 이름은 원자 인 반면 파일 및 디렉토리 이름은 문자열입니다. 이전 버전과의 호환성을 위해 일부 함수는 문자열과 원자를 모두 허용하지만 향후 릴리스에서는 아마도 문서화 된 인수 만 허용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="53bcb5e4dbe6774226d92c1d8796a8dd249ddb9a" translate="yes" xml:space="preserve">
          <source>Module attributes for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">현재 코드의 모듈 속성. 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f9e0f5b07f095dde5495f6ff4abc79cb69752f" translate="yes" xml:space="preserve">
          <source>Module attributes for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">이전 코드의 모듈 속성 (있는 경우). 이 필드는 Crashdump Viewer 도구에서 볼 때 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec0fffee38c98db4b9f15f636dd6e2046e7c657" translate="yes" xml:space="preserve">
          <source>Module declaration, defining the name of the module. The name &lt;code&gt;Module&lt;/code&gt;, an atom, is to be same as the file name minus the extension &lt;code&gt;.erl&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; does not work as intended.</source>
          <target state="translated">모듈의 이름을 정의하는 모듈 선언. 원자 이름 인 &lt;code&gt;Module&lt;/code&gt; 이름 은 파일 이름에서 확장자 &lt;code&gt;.erl&lt;/code&gt; 을 뺀 것과 같습니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; 가 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9f410e5b1b65a73903dd4626c286783c1bfbc2a" translate="yes" xml:space="preserve">
          <source>Module dependencies</source>
          <target state="translated">모듈 의존성</target>
        </trans-unit>
        <trans-unit id="29831323c7df8a96814b2f509d3ff6857f030f35" translate="yes" xml:space="preserve">
          <source>Module implementing a transport process as defined in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. Defaults to &lt;code&gt;diameter_tcp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 정의 된 전송 프로세스를 구현하는 모듈 . 기본값은 &lt;code&gt;diameter_tcp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4e38a18f0719919f3c40ded9bbdfc81eabab76a" translate="yes" xml:space="preserve">
          <source>Module implementing the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 . 공개 키 처리를 사용자 정의하는 데 사용할 수 있습니다. 콜백 옵션이 모듈 이름과 함께 제공되면 'key_cb_private'키 아래에 전달 된 옵션을 통해 콜백 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35eeaf69ae679cc6ded3a7a1fc0ebe15bf8b481c" translate="yes" xml:space="preserve">
          <source>Module implementing the callback interface defined in &lt;code&gt;diameter_app(3)&lt;/code&gt;, along with any extra arguments to be appended to those documented. Note that extra arguments specific to an outgoing request can be specified to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, in which case those are appended to any module-specific extra arguments.</source>
          <target state="translated">&lt;code&gt;diameter_app(3)&lt;/code&gt; 정의 된 콜백 인터페이스를 구현하는 모듈 과 문서화 된 추가 인수와 함께 추가 인수입니다. 발신 요청에 특정한 추가 인수는 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 지정할 수 있으며 ,이 경우 인수는 모듈 별 추가 인수에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1e11776366f8fb2d72c2cb79f09bb4fa24e742" translate="yes" xml:space="preserve">
          <source>Module specific configuration. A module has a mandatory name and module level options that are described below.</source>
          <target state="translated">모듈 별 구성. 모듈에는 아래 설명 된 필수 이름 및 모듈 수준 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b60e96ee40b88550cfc1f8c7fcfd25f0c8cd62" translate="yes" xml:space="preserve">
          <source>Module version. &lt;code&gt;Vsn&lt;/code&gt; is any literal term and can be retrieved using &lt;code&gt;beam_lib:version/1&lt;/code&gt;, see the &lt;code&gt;beam_lib(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">모듈 버전. &lt;code&gt;Vsn&lt;/code&gt; 은 리터럴 용어이며 &lt;code&gt;beam_lib:version/1&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 . &lt;code&gt;beam_lib(3)&lt;/code&gt; 의 beam_lib (3) 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="503ebafe676df7f757d99bf2c13d2488fb6ebde6" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 에이전트의 네트워크 인터페이스 필터 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1abddb44834be834e4e4bfa19c743e11a954f223" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP manager. Must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 관리자 용 네트워크 인터페이스 필터 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e44abc149b672de3d2e38a78a614dd0b902536c9" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 에이전트의 네트워크 인터페이스 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e55ad072ead98bed5f6005b9ebdc8c72b3e6734f" translate="yes" xml:space="preserve">
          <source>Module-local type, that is, with a definition that is present in the code of the module</source>
          <target state="translated">모듈-로컬 유형, 즉 모듈의 코드에 존재하는 정의</target>
        </trans-unit>
        <trans-unit id="3bb18ecc75afce04897d2fff035677396581e539" translate="yes" xml:space="preserve">
          <source>ModuleName = atom()</source>
          <target state="translated">ModuleName = atom ()</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="91edcf2737edcc491331e2f8bedfb98b3d292c2d" translate="yes" xml:space="preserve">
          <source>Modules are auto loaded when they are first referenced if the runtime system runs in &lt;code&gt;interactive&lt;/code&gt; mode, which is the default. In &lt;code&gt;embedded&lt;/code&gt; mode modules are not auto loaded. The latter is recommended when the boot script preloads all modules, as conventionally happens in OTP releases. See &lt;code&gt;code(3)&lt;/code&gt;</source>
          <target state="translated">런타임 시스템이 &lt;code&gt;interactive&lt;/code&gt; 모드 (기본값) 에서 실행될 경우 처음 참조 될 때 모듈이 자동으로로드됩니다 . 에 &lt;code&gt;embedded&lt;/code&gt; 모드 모듈로드되지 않습니다 자동. 후자는 OTP 릴리즈에서 일반적으로 발생하는 것처럼 부트 스크립트가 모든 모듈을 미리로드 할 때 권장됩니다. &lt;code&gt;code(3)&lt;/code&gt; 참조 (3)</target>
        </trans-unit>
        <trans-unit id="bb1481c22b555900c17ca93bb499831901e632cf" translate="yes" xml:space="preserve">
          <source>Modules for which these requirements are not fulfilled are not interpretable and are therefore displayed within parentheses.</source>
          <target state="translated">이러한 요구 사항이 충족되지 않은 모듈은 해석 할 수 없으므로 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3655dff16c3acb075f3aa4eb83a55de4222d8dcd" translate="yes" xml:space="preserve">
          <source>Modules handling textual data (such as &lt;code&gt;io_lib&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; are sometimes subject to conversion or extension to be able to handle Unicode characters.</source>
          <target state="translated">텍스트 데이터를 처리하는 모듈 (예 : &lt;code&gt;io_lib&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 은 유니 코드 문자를 처리 할 수 ​​있도록 변환 또는 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2ee43d36d04a016e320f127714934e6c2e4d80" translate="yes" xml:space="preserve">
          <source>Modules that can use match specifications for optimized traversal of tables are to call &lt;code&gt;qlc:table/2&lt;/code&gt; with an unary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블 순회 최적화를 위해 일치 스펙을 사용할 수있는 모듈 은 단항 &lt;code&gt;TraverseFun&lt;/code&gt; 으로 &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출 해야합니다 . 예는 &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="422ffac5358de536fa7258027d227737932e212a" translate="yes" xml:space="preserve">
          <source>Modules to be debugged must include debug information, for example, &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt;.</source>
          <target state="translated">디버깅 할 모듈에는 디버그 정보가 포함되어야합니다 (예 : &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad051bc5d863047321817c8bcfbe0c4f0ad41d7f" translate="yes" xml:space="preserve">
          <source>Modules. All modules: analyzed modules, used library modules, and unknown modules.</source>
          <target state="translated">모듈. 모든 모듈 : 분석 된 모듈, 사용 된 라이브러리 모듈 및 알 수없는 모듈.</target>
        </trans-unit>
        <trans-unit id="c3bdbab40a4be4ac1b8eb1ccb2dbb2eaf8ed480f" translate="yes" xml:space="preserve">
          <source>Mongolian</source>
          <target state="translated">Mongolian</target>
        </trans-unit>
        <trans-unit id="787f0f344756f8edefb0e5d7c62ebb26c5a4a55b" translate="yes" xml:space="preserve">
          <source>Mongolian Vowel Separator</source>
          <target state="translated">몽골어 모음 분리기</target>
        </trans-unit>
        <trans-unit id="600aa04e59197f341b9f4d4f4b67aac5860b9298" translate="yes" xml:space="preserve">
          <source>Mongolian vowel separator</source>
          <target state="translated">몽골어 모음 분리기</target>
        </trans-unit>
        <trans-unit id="01e57fc0fd45173cbed0acd0fdb7a3a5528fd3cf" translate="yes" xml:space="preserve">
          <source>Monitor the SNMP manager. In case of a crash, the calling (monitoring) process will get a 'DOWN' message (see the erlang module for more info).</source>
          <target state="translated">SNMP 관리자를 모니터하십시오. 충돌이 발생하면 호출 (모니터링) 프로세스에 'DOWN'메시지가 표시됩니다 (자세한 내용은 erlang 모듈 참조).</target>
        </trans-unit>
        <trans-unit id="344910a8e2960c1213ce5adc8d4e0d2e7e946399" translate="yes" xml:space="preserve">
          <source>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes.</source>
          <target state="translated">해석 된 모듈에서 코드를 실행하는 모든 프로세스의 현재 상태를 모니터링하고 다른 Erlang 노드의 프로세스도 모니터링하십시오.</target>
        </trans-unit>
        <trans-unit id="861055aa27b6909c706d63bc66a51be73f91acc2" translate="yes" xml:space="preserve">
          <source>Monitor the status of the node &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 의 상태를 모니터하십시오 . 경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 모니터링이 켜집니다. 경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , 모니터가 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="ebcb5e6cac0f295c708f39a3c4a6170117db14de" translate="yes" xml:space="preserve">
          <source>MonitorRef</source>
          <target state="translated">MonitorRef</target>
        </trans-unit>
        <trans-unit id="470c3f4925fdbce53327014ba80ea684bb7bb834" translate="yes" xml:space="preserve">
          <source>Monitoring of the master node by the slaves. A slave node can be stopped if the master node terminates. (Configurable.)</source>
          <target state="translated">슬레이브에 의한 마스터 노드 모니터링. 마스터 노드가 종료되면 슬레이브 노드를 중지 할 수 있습니다. (구성 가능)</target>
        </trans-unit>
        <trans-unit id="0f28429d58b7c5efe00cd63a0b3f938a3c652898" translate="yes" xml:space="preserve">
          <source>Monitors are unidirectional. Repeated calls to &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; creates several independent monitors, and each one sends a 'DOWN' message when &lt;code&gt;Pid&lt;/code&gt; terminates.</source>
          <target state="translated">모니터는 단방향입니다. &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; 를 반복해서 호출 하면 여러 개의 독립적 인 모니터가 생성되며 &lt;code&gt;Pid&lt;/code&gt; 가 종료 되면 각각 'DOWN'메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="cdb09466cb66d0cbd945a8e99ed6c52ea020f0ad" translate="yes" xml:space="preserve">
          <source>Monitors can be created for processes with registered names, also at other nodes.</source>
          <target state="translated">다른 노드에서도 등록 된 이름의 프로세스에 대한 모니터를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01bc156298d3c730abf64a20c2aed5c87c1f305c" translate="yes" xml:space="preserve">
          <source>Monitors changes in &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; between &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;. One valid &lt;code&gt;Item&lt;/code&gt; exists in combination with the &lt;code&gt;time_offset Type&lt;/code&gt;, namely the atom &lt;code&gt;clock_service&lt;/code&gt;. Notice that the atom &lt;code&gt;clock_service&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; the registered name of a process. In this case it serves as an identifier of the runtime system internal clock service at current runtime system instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; 변경을 모니터링 합니다 . &lt;code&gt;time_offset Type&lt;/code&gt; 과 함께 하나의 유효한 &lt;code&gt;Item&lt;/code&gt; , 즉 atom &lt;code&gt;clock_service&lt;/code&gt; 가 존재 합니다. atom &lt;code&gt;clock_service&lt;/code&gt; 는 프로세스의 등록 된 이름 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 이 경우 현재 런타임 시스템 인스턴스에서 런타임 시스템 내부 시계 서비스의 식별자로 사용됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6278940d00dc973b9fac020727e51dbaff5a2934" translate="yes" xml:space="preserve">
          <source>Monitors the new process (like &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; does).</source>
          <target state="translated">새로운 프로세스를 모니터합니다 ( &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 처럼 ).</target>
        </trans-unit>
        <trans-unit id="cad13ed7bd36f4e4080c9a5204dc6f837cb3bfe8" translate="yes" xml:space="preserve">
          <source>Monitors the status of &lt;code&gt;Node&lt;/code&gt;. A message&lt;code&gt;{nodedown, Node}&lt;/code&gt; is received if the connection to it is lost.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 상태를 모니터합니다 . 연결이 끊어지면 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 메시지 가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="c216ef5762c4c0ce5f8e7770265d785983bc6ae3" translate="yes" xml:space="preserve">
          <source>Monitors when a driver gets unloaded. If one monitors a driver that is not present in the system, one immediately gets notified that the driver got unloaded. There is no guarantee that the driver was ever loaded.</source>
          <target state="translated">드라이버가 언로드 될 때 모니터링합니다. 시스템에없는 드라이버를 모니터하면 즉시 드라이버가 언로드되었다는 알림을받습니다. 드라이버가로드되었다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd9b10ee2a0012e1817ee26b4049755fcb0ac1ff" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s can be added in the future.</source>
          <target state="translated">앞으로 더 많은 &lt;code&gt;Option&lt;/code&gt; 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00ed339af89630d658502ba6fa422f63b92791b" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s may be added in the future.</source>
          <target state="translated">앞으로 더 많은 &lt;code&gt;Option&lt;/code&gt; 이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5800ca3d1d23bed63e706fafc9995e33a99a9d14" translate="yes" xml:space="preserve">
          <source>More &lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">더 많은 &lt;strong&gt;예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d583518560cd4a6b87be9bc7d0b5d20f375dd723" translate="yes" xml:space="preserve">
          <source>More about schema management</source>
          <target state="translated">스키마 관리에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="6f6b5d611fb9be7645dc68d59bbad9a1cb5dc15a" translate="yes" xml:space="preserve">
          <source>More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed.</source>
          <target state="translated">더 복잡한 어설 션은 하위 패턴으로 코딩됩니다. 두 가지 종류가 있습니다 : 제목 문자열에서 현재 위치보다 먼저 보이는 것과 뒤에서 보는 것. 어설 션 하위 패턴은 현재 일치 위치가 변경되지 않는 것을 제외하고는 일반적인 방식으로 일치됩니다.</target>
        </trans-unit>
        <trans-unit id="dc0707bf61bc70dcb1ccf38732ab029880726d5a" translate="yes" xml:space="preserve">
          <source>More complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">모든 오브젝트 와 일치하는 일치 스펙이 지정된 경우 &lt;code&gt;select/3&lt;/code&gt; 가 리턴 한 모든 오브젝트에 더 복잡한 필터를 적용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc35fb8a88b65701f3530def0b268e553aeb3acf" translate="yes" xml:space="preserve">
          <source>More data is required for building a term. &lt;code&gt;Continuation1&lt;/code&gt; must be passed in a new call to &lt;code&gt;tokens/3,4&lt;/code&gt; when more data is available.</source>
          <target state="translated">용어를 작성하려면 더 많은 데이터가 필요합니다. 더 많은 데이터를 사용할 수있는 경우 &lt;code&gt;Continuation1&lt;/code&gt; 은 &lt;code&gt;tokens/3,4&lt;/code&gt; 에 대한 새로운 호출로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="61d71bef3701b166a8820075cfe5c6b25a998a5a" translate="yes" xml:space="preserve">
          <source>More data is required to build a term. &lt;code&gt;Continuation&lt;/code&gt; must be passed to &lt;code&gt;fread/3&lt;/code&gt; when more data becomes available.</source>
          <target state="translated">용어를 작성하려면 더 많은 데이터가 필요합니다. 더 많은 데이터를 사용할 수있게되면 &lt;code&gt;Continuation&lt;/code&gt; 을 &lt;code&gt;fread/3&lt;/code&gt; 로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="724f9066e927cf5e78aa33ce4b0b56cdb2c9bad0" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Programming Examples.&lt;/code&gt; 에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ed94e5cafdef76e06a28a02d1fb7d9d847eb489" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Programming Examples&lt;/code&gt; 에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f0c04bd8d50bdec5467c598e0a5b535a66ddbd3" translate="yes" xml:space="preserve">
          <source>More fine-grained &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s can be added through configure (such as &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt;). Enabling these states causes performance degradation when microstate accounting is turned off and increases the overhead when it is turned on.</source>
          <target state="translated">보다 세분화 된 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; 는 &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt; 통해 추가 할 수 있습니다 (예 : ./configure --with-microstate-accounting = extra ). 이러한 상태를 사용하면 마이크로 스테이트 계정이 꺼질 때 성능이 저하되고 켜질 때 오버 헤드가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="2acb3fbd866339988fd39b1c284e6c3b2ab38a8d" translate="yes" xml:space="preserve">
          <source>More identifiers can exist, for example, server-side namespace.</source>
          <target state="translated">서버 측 네임 스페이스와 같은 더 많은 식별자가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1694f778d2be24087b41889858ea210d0111ac2d" translate="yes" xml:space="preserve">
          <source>More information can be found at</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64269325714a31b2baa9a9331c4f44390f41f060" translate="yes" xml:space="preserve">
          <source>More information is provided by the &lt;code&gt;ms_transform&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">자세한 정보는 &lt;code&gt;ms_transform&lt;/code&gt; 의 ms_transform 매뉴얼 페이지에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="88f4919d857f59d8c447803f4828a40dd5c28e81" translate="yes" xml:space="preserve">
          <source>More information, if any. If the process is stopped at a breakpoint, the field contains information about the location &lt;code&gt;{Module,Line}&lt;/code&gt;. If the process has terminated, the field contains the exit reason.</source>
          <target state="translated">더 많은 정보. 프로세스가 중단 점에서 중지되면 필드에 &lt;code&gt;{Module,Line}&lt;/code&gt; 위치에 대한 정보가 포함 됩니다. 프로세스가 종료 된 경우 필드에 종료 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6de05aba35fe8266245c0993bc1f9805274eb9" translate="yes" xml:space="preserve">
          <source>More options can be added in a future release.</source>
          <target state="translated">향후 릴리스에서 더 많은 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="624affd09f46bdb2e3938ac33ddbe38974e12c14" translate="yes" xml:space="preserve">
          <source>More than three parts are not possible with this indata, so</source>
          <target state="translated">이 데이터에는 세 부분 이상이 불가능하므로</target>
        </trans-unit>
        <trans-unit id="b885fb398d558b327a8bb15c26cf1ab822a084fa" translate="yes" xml:space="preserve">
          <source>More tuples in the returned list can be added in a future release.</source>
          <target state="translated">리턴 된리스트에 더 많은 튜플이 다음 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2f77ff3575a46c8961aaa5e120590c63bc009a2" translate="yes" xml:space="preserve">
          <source>Most Unix operating systems have adopted a simpler approach, namely that Unicode file naming is not enforced, but by convention. Those systems usually use UTF-8 encoding for Unicode filenames, but do not enforce it. On such a system, a filename containing characters with code points from 128 through 255 can be named as plain ISO Latin-1 or use UTF-8 encoding. As no consistency is enforced, the Erlang VM cannot do consistent translation of all filenames.</source>
          <target state="translated">대부분의 유닉스 운영 체제는 더 단순한 접근 방식을 채택했습니다. 즉, 유니 코드 파일 이름 지정이 적용되는 것이 아니라 관례입니다. 이러한 시스템은 일반적으로 유니 코드 파일 이름에 UTF-8 인코딩을 사용하지만 적용하지는 않습니다. 이러한 시스템에서 128에서 255 사이의 코드 포인트를 가진 문자를 포함하는 파일 이름은 일반 ISO Latin-1로 명명되거나 UTF-8 인코딩을 사용할 수 있습니다. 일관성이 적용되지 않으므로 Erlang VM은 모든 파일 이름을 일관되게 번역 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0ba27548898cb4c334f12ba233f3dfd33b35de6" translate="yes" xml:space="preserve">
          <source>Most applications only need the Master Agent because an agent can have multiple MIBs loaded at the same time.</source>
          <target state="translated">에이전트는 동시에 여러 MIB를로드 할 수 있으므로 대부분의 응용 프로그램에는 마스터 에이전트 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f4dc046cd951e52d7b06645a8907d9bc64484dc4" translate="yes" xml:space="preserve">
          <source>Most drivers written before the runtime system with SMP support existed can run in the runtime system with SMP support, without being rewritten, if driver level locking is used.</source>
          <target state="translated">SMP를 지원하는 런타임 시스템 이전에 작성된 대부분의 드라이버는 드라이버 레벨 잠금이 사용되는 경우 다시 쓰지 않고 SMP를 지원하는 런타임 시스템에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d595b42429aa7673a2aecb223ad49cf5a73ec5" translate="yes" xml:space="preserve">
          <source>Most functions appear in a version with the suffix &lt;code&gt;_tmo&lt;/code&gt; appended to the function name. Those functions take an extra argument, a time-out in &lt;strong&gt;milliseconds&lt;/strong&gt;. The semantics is this: for each communication primitive involved in the operation, if the primitive does not complete within the time specified, the function returns an error and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;ETIMEDOUT&lt;/code&gt;. With communication primitive is meant an operation on the socket, like &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;send&lt;/code&gt;.</source>
          <target state="translated">대부분의 함수 는 함수 이름에 접미사 &lt;code&gt;_tmo&lt;/code&gt; 가 추가 된 버전으로 나타납니다 . 이러한 함수는 추가 인수 ( &lt;strong&gt;밀리 초 단위&lt;/strong&gt; 의 시간 초과)를 사용 합니다. 시맨틱은 다음과 같습니다. 조작과 관련된 각 통신 기본 요소에 대해 지정된 시간 내에 기본 요소가 완료되지 않으면 함수는 오류를 리턴하고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;ETIMEDOUT&lt;/code&gt; 으로 설정됩니다 . 통신 프리미티브 란 &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;accept&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 또는 &lt;code&gt;send&lt;/code&gt; 와 같은 소켓에서의 조작을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a85fc0308845fa5554e3cce6dc65bbf6089cf9b5" translate="yes" xml:space="preserve">
          <source>Most functions in &lt;code&gt;Erl_Interface&lt;/code&gt; report failures to the caller by returning some otherwise meaningless value (typically &lt;code&gt;NULL&lt;/code&gt; or a negative number). As this only tells you that things did not go well, examine the error code in &lt;code&gt;erl_errno&lt;/code&gt; if you want to find out more about the failure.</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 대부분의 함수는 의미가없는 값 (일반적으로 &lt;code&gt;NULL&lt;/code&gt; 또는 음수) 을 반환하여 호출자에게 실패를보고 합니다. 이것만으로는 문제가 해결되지 않았으므로 실패에 대해 더 자세히 알고 싶다면 &lt;code&gt;erl_errno&lt;/code&gt; 의 오류 코드를 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b9a8701c6eef5e39f2cf96b687e2ad091233f9f" translate="yes" xml:space="preserve">
          <source>Most functions in this API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, that is, they &lt;strong&gt;cannot&lt;/strong&gt; be called from arbitrary threads. Functions that are not documented as thread-safe can only be called from driver callbacks or function calls descending from a driver callback call. Notice that driver callbacks can be called from different threads. This, however, is not a problem for any function in this API, as the emulator has control over these threads.</source>
          <target state="translated">이 API의 대부분의 함수는 스레드로부터 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 즉, 임의의 스레드에서 호출 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; . 스레드 안전으로 문서화되지 않은 함수는 드라이버 콜백 또는 드라이버 콜백 호출에서 내림차순으로 만 호출 할 수 있습니다. 다른 스레드에서 드라이버 콜백을 호출 할 수 있습니다. 그러나 에뮬레이터가 이러한 스레드를 제어하므로이 API의 기능에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66cf9f2e24e97469377d6bb06bc86d3532009574" translate="yes" xml:space="preserve">
          <source>Most importantly, the object must have been created with a single call to &lt;code&gt;malloc()&lt;/code&gt; (or similar), so that it can later be removed by a single call to &lt;code&gt;free()&lt;/code&gt;. Objects are freed by the registry when it is closed, or when you assign a new value to an object that previously contained a string or binary.</source>
          <target state="translated">가장 중요한 것은 객체는 &lt;code&gt;malloc()&lt;/code&gt; (또는 이와 유사한)에 대한 단일 호출로 생성되었으므로 나중에 &lt;code&gt;free()&lt;/code&gt; 에 대한 단일 호출로 제거 할 수 있습니다 . 레지스트리가 닫히거나 이전에 문자열 또는 2 진이 포함 된 오브젝트에 새 값을 지정하면 레지스트리가 오브젝트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="259d848432008a34f52bb0dbba925c35f2c8e9d8" translate="yes" xml:space="preserve">
          <source>Most likely, some type of table coordinator already exists. This process should take care of the instrumentation for the table.</source>
          <target state="translated">대부분의 유형의 테이블 코디네이터가 이미 존재합니다. 이 프로세스는 테이블의 계측을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e2d6f01b9b328d4a5f37c7cbd2074b9468e6ea" translate="yes" xml:space="preserve">
          <source>Most modern operating systems support Unicode filenames in some way. There are many different ways to do this and Erlang by default treats the different approaches differently:</source>
          <target state="translated">대부분의 최신 운영 체제는 어떤 방식 으로든 유니 코드 파일 이름을 지원합니다. 이를 수행하는 방법에는 여러 가지가 있으며 Erlang은 기본적으로 다른 방법을 다르게 취급합니다.</target>
        </trans-unit>
        <trans-unit id="94bf990af8b5bba4715948822b6d909da6a73a07" translate="yes" xml:space="preserve">
          <source>Most of the functions expect all input to be normalized to one form, see for example &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 함수는 모든 입력이 한 형식으로 정규화 될 것으로 예상합니다 (예 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3acc15056b9b45c5a0b8bb83b1ecaadb55f64f07" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module have one variant with a &lt;code&gt;Timeout&lt;/code&gt; parameter, and one without. If nothing else is specified, the default value &lt;code&gt;infinity&lt;/code&gt; is used when the &lt;code&gt;Timeout&lt;/code&gt; parameter is not given.</source>
          <target state="translated">이 모듈의 대부분의 함수에는 &lt;code&gt;Timeout&lt;/code&gt; 매개 변수 가있는 변형과 없는 매개 변수가 있습니다. 다른 것을 지정하지 않으면 &lt;code&gt;Timeout&lt;/code&gt; 매개 변수가 제공되지 않을 때 기본값 &lt;code&gt;infinity&lt;/code&gt; 가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c21332b5de08b2fbd3d7faeca43f33090fab572" translate="yes" xml:space="preserve">
          <source>Most of the modules in Erlang/OTP are Unicode-unaware in the sense that they have no notion of Unicode and should not have. Typically they handle non-textual or byte-oriented data (such as &lt;code&gt;gen_tcp&lt;/code&gt;).</source>
          <target state="translated">Erlang / OTP의 대부분의 모듈은 유니 코드에 대한 개념이없고 가져서는 안된다는 점에서 유니 코드를 인식하지 못합니다. 일반적으로 비 텍스트 또는 바이트 지향 데이터 (예 : &lt;code&gt;gen_tcp&lt;/code&gt; )를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="76641edebd3126877e42070a39301c6bf778343f" translate="yes" xml:space="preserve">
          <source>Most of the options are common for both the client and the server side, but some of them differs a little. The available &lt;code&gt;option()&lt;/code&gt;s are as follows:</source>
          <target state="translated">대부분의 옵션은 클라이언트와 서버 측 모두에 공통적이지만 일부는 약간 다릅니다. 사용 가능한 &lt;code&gt;option()&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e0d4e811a2f740e5d587160a505db4b80acdc72" translate="yes" xml:space="preserve">
          <source>Most of these flags are highly implementation-dependent and can be changed or removed without prior notice.</source>
          <target state="translated">이러한 플래그는 대부분 구현에 따라 다르며 사전 통지없이 변경하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cba0447d8d7195a8296a095d999aca792c4346" translate="yes" xml:space="preserve">
          <source>Most operating systems have a command interpreter or shell, UNIX and Linux have many, Windows has the command prompt. Erlang has its own shell where bits of Erlang code can be written directly, and be evaluated to see what happens (see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">대부분의 운영 체제에는 명령 인터프리터 또는 쉘이 있고 UNIX 및 Linux에는 많은 것이 있으며 Windows에는 명령 프롬프트가 있습니다. Erlang에는 Erlang 코드 비트를 직접 작성할 수있는 자체 쉘이 있으며 어떤 일이 발생하는지 평가합니다 ( STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="39c2fb5ddc35fb498363b9b722fc5915d7d947f6" translate="yes" xml:space="preserve">
          <source>Most programmers also expect time to be reliable, at least until they realize that the wall clock time on their workstation is off by a minute. Then they set it to the correct time, but most probably not in a smooth way.</source>
          <target state="translated">또한 대부분의 프로그래머는 최소한 워크 스테이션의 벽시계 시간이 1 분 정도 지났다는 사실을 깨닫기까지는 시간이 안정적이라고 생각합니다. 그런 다음 그들은 정확한 시간으로 설정했지만 대부분은 매끄럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d49d2009b77de7ac08a0afaec3a6bddcd20dae8e" translate="yes" xml:space="preserve">
          <source>Most programs will be modified during their lifetime: bugs will be fixed, features will be added, optimizations may become necessary, or the code will need to be refactored or cleaned up in other ways to make it easier to work with. But every change to a working program is a risk of introducing new bugs - or reintroducing bugs that had previously been fixed. Having a set of unit tests that you can run with very little effort makes it easy to know that the code still works as it should (this use is called &lt;strong&gt;regression testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;). This goes a long way to reduce the resistance to changing and refactoring code.</source>
          <target state="translated">대부분의 프로그램은 일생 동안 수정됩니다 : 버그가 수정되거나, 기능이 추가되거나, 최적화가 필요할 수 있으며, 다른 방법으로 코드를 리팩토링하거나 정리하여 작업하기가 더 쉬워집니다. 그러나 작동중인 프로그램을 변경할 때마다 새로운 버그가 발생하거나 이전에 수정 된 버그가 다시 발생할 위험이 있습니다. 약간의 노력으로 실행할 수있는 단위 테스트 세트를 사용하면 코드가 여전히 정상적으로 작동하는지 쉽게 알 수 있습니다 (이 용도를 &lt;strong&gt;회귀 테스트&lt;/strong&gt; 라고 합니다. &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 참조 ). 이는 코드 변경 및 리팩토링에 대한 저항을 줄이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="22312ab51d7c6c1f35dbc3ee3223deb0c786bd3e" translate="yes" xml:space="preserve">
          <source>Most role-specific behaviour is implemented by the user. How a node advertises itself at capabilities exchange is determined by user configuration.</source>
          <target state="translated">대부분의 역할 별 동작은 사용자가 구현합니다. 기능 교환시 노드가 자신을 알리는 방법은 사용자 구성에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="86e32c3cb060fb634a619eef0dd5d1eef4747958" translate="yes" xml:space="preserve">
          <source>Most systems handle variable &lt;code&gt;LC_CTYPE&lt;/code&gt; before &lt;code&gt;LANG&lt;/code&gt;, so if that is set, it must be set to &lt;code&gt;UTF-8&lt;/code&gt;:</source>
          <target state="translated">대부분의 시스템은 &lt;code&gt;LANG&lt;/code&gt; 전에 변수 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 처리 하므로 설정되면 &lt;code&gt;UTF-8&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56244bcac54ef39e9d4826088a4c9d7b27054731" translate="yes" xml:space="preserve">
          <source>Moves the copy of table &lt;code&gt;Tab&lt;/code&gt; from node &lt;code&gt;From&lt;/code&gt; to node &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">이동 테이블의 복사본 &lt;code&gt;Tab&lt;/code&gt; 노드 &lt;code&gt;From&lt;/code&gt; 노드 &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b30cc0ae00fc3d8210b07f3cf78930cce84bbd4" translate="yes" xml:space="preserve">
          <source>Mro</source>
          <target state="translated">Mro</target>
        </trans-unit>
        <trans-unit id="b1fee5a1630c4cf74b49738a6b5de770a03930a2" translate="yes" xml:space="preserve">
          <source>Much of the work involved is automated. This includes &lt;code&gt;get-next&lt;/code&gt; processing and &lt;code&gt;RowStatus&lt;/code&gt; handling.</source>
          <target state="translated">관련된 많은 작업이 자동화됩니다. 여기에는 &lt;code&gt;get-next&lt;/code&gt; 처리 및 &lt;code&gt;RowStatus&lt;/code&gt; 처리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="28dd4fba871bafc6251102ec641d8e20bb52017b" translate="yes" xml:space="preserve">
          <source>Multi-Round-Time-Out AVP</source>
          <target state="translated">멀티 라운드 타임 아웃 AVP</target>
        </trans-unit>
        <trans-unit id="e1f017ea475a1c73e4195e0bff09e16cde8df8aa" translate="yes" xml:space="preserve">
          <source>Multi-file error report logging is used to store error messages received by &lt;code&gt;error_logger&lt;/code&gt;. The error messages are stored in several files and each file is smaller than a specified number of kilobytes. No more than a specified number of files exist at the same time. The logging is very fast, as each error message is written as a binary term.</source>
          <target state="translated">다중 파일 오류 보고서 로깅은 &lt;code&gt;error_logger&lt;/code&gt; 가 수신 한 오류 메시지를 저장하는 데 사용됩니다 . 오류 메시지는 여러 파일에 저장되며 각 파일은 지정된 킬로바이트보다 작습니다. 동시에 지정된 수의 파일 만 존재합니다. 각 오류 메시지가 이진 용어로 작성되므로 로깅이 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d5421d352983c0b9fc43e3a80915204a161e3a58" translate="yes" xml:space="preserve">
          <source>Multiblock carriers are used for storage of several blocks.</source>
          <target state="translated">멀티 블록 캐리어는 여러 블록을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fec23604015b2ecb5fcc1e2452ac43e2d5d2bf0" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러- &lt;code&gt;--inherits&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41efb021af75ddc40ae618d768069c0d301604b2" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;-i&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 개의 &lt;code&gt;-i&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf347cf86397485cf04a5bdb8b11bd1e69ffecc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; options can be specified, in which case the corresponding callbacks are applied until one of them returns a value other than &lt;code&gt;ignore&lt;/code&gt;. All callbacks returning &lt;code&gt;ignore&lt;/code&gt; is equivalent to not having configured them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; 옵션을 여러 개 지정할 수 있으며,이 경우 해당 콜백 중 하나가 &lt;code&gt;ignore&lt;/code&gt; 이외의 값을 반환 할 때까지 적용됩니다 . &lt;code&gt;ignore&lt;/code&gt; 를 반환 하는 모든 콜백 은 콜백 을 구성하지 않은 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="204798c1114f47e98e981a537b711d39b1311eda" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;include&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 &lt;code&gt;include&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0d1680057ecce93b665efdb88bfc3e3c1e5449" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">여러 &lt;code&gt;inherits&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8d65e7ae8dec4ab75e8c06bdc2eceb56c1abf6" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;ip&lt;/code&gt; options can be specified for a multihomed peer. If none are specified then the values of &lt;code&gt;Host-IP-Address&lt;/code&gt; in the &lt;code&gt;diameter_service&lt;/code&gt; record are used. Option &lt;code&gt;port&lt;/code&gt; defaults to 3868 for a listening transport and 0 for a connecting transport.</source>
          <target state="translated">멀티 홈 피어에 대해 여러 &lt;code&gt;ip&lt;/code&gt; 옵션을 지정할 수 있습니다. 아무도는 다음의 값을 지정하지 않으면 &lt;code&gt;Host-IP-Address&lt;/code&gt; 에 &lt;code&gt;diameter_service&lt;/code&gt; 의 기록 사용된다. 옵션 전송 &lt;code&gt;port&lt;/code&gt; 는 청취 전송의 경우 3868이고 연결 전송의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="088c280ad46a55ad788090a74438dc30fa9e951f" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;sys&lt;/code&gt; traceable replies</source>
          <target state="translated">여러 &lt;code&gt;sys&lt;/code&gt; 추적 가능 회신</target>
        </trans-unit>
        <trans-unit id="f06b4f8d09b8eaee5c332e885ceba194958a51dc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;transport_module&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; options are allowed. The order of these is significant in this case (and only in this case), a &lt;code&gt;transport_module&lt;/code&gt; being paired with the first &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; following it in the options list, or the default value for trailing modules. Transport starts will be attempted with each of the modules in order until one establishes a connection within the corresponding timeout (see below) or all fail.</source>
          <target state="translated">여러 &lt;code&gt;transport_module&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 옵션이 허용됩니다. 이들의 순서는이 경우 (이 경우에만), &lt;code&gt;transport_module&lt;/code&gt; 이 옵션 목록에서 첫 번째 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 와 쌍을 이루 거나 후행 모듈의 기본값으로 중요합니다. 해당 타임 아웃 (아래 참조) 내에 연결을 설정하거나 모두 실패 할 때까지 각 모듈에서 전송 시작이 순서대로 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="8a333a79ebe5ff34c8d76c9900da678f2524bef2" translate="yes" xml:space="preserve">
          <source>Multiple Erlang nodes implementing the same Diameter node should be configured with different sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop Identifiers for outgoing requests.</source>
          <target state="translated">동일한 지름 노드를 구현하는 여러 Erlang 노드는 서로 다른 시퀀스 마스크로 구성하여 각 노드가 발신 요청에 대해 고유 한 엔드-투-엔드 및 홉별 식별자를 사용하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="918e90f086f758494202e7c1057dc9d090319e70" translate="yes" xml:space="preserve">
          <source>Multiple connections are independent and governed by their own peer and watchdog state machines.</source>
          <target state="translated">여러 연결은 독립적이며 자체 피어 및 워치 독 상태 시스템에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="39c7dc292ea6c4ca667c03d03c78abb261ad3cd3" translate="yes" xml:space="preserve">
          <source>Multiple connections to the same peer is possible. ICMP messages are not interpreted.</source>
          <target state="translated">동일한 피어에 여러 연결이 가능합니다. ICMP 메시지는 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47cd1d5d6231055845e7ad6743d6544e8318516d" translate="yes" xml:space="preserve">
          <source>Multiple entries of this type are allowed.</source>
          <target state="translated">이 유형의 여러 항목이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="38d744a92105856b5a02b866c88de04b40d669df" translate="yes" xml:space="preserve">
          <source>Multiple generic named time-outs</source>
          <target state="translated">여러 일반 명명 된 시간 초과</target>
        </trans-unit>
        <trans-unit id="8b65c69f112a6d8c5b4685ec30e6ffdcf36c27c8" translate="yes" xml:space="preserve">
          <source>Multiple, thread-specific instances of the allocator. This option has only effect on the runtime system with SMP support. Default behavior on the runtime system with SMP support is &lt;code&gt;NoSchedulers+1&lt;/code&gt; instances. Each scheduler uses a lock-free instance of its own and other threads use a common instance.</source>
          <target state="translated">할당 자의 여러 스레드 별 인스턴스. 이 옵션은 SMP를 지원하는 런타임 시스템에만 영향을줍니다. SMP를 지원하는 런타임 시스템의 기본 동작은 &lt;code&gt;NoSchedulers+1&lt;/code&gt; 인스턴스입니다. 각 스케줄러는 자체 잠금없는 인스턴스를 사용하고 다른 스레드는 공통 인스턴스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f6d5d47eb24e552ff49945236f4445a4cf174f2" translate="yes" xml:space="preserve">
          <source>Multiple-line comments as in C, &lt;code&gt;/* ... */&lt;/code&gt;, are supported.</source>
          <target state="translated">C와 같은 여러 줄 주석, &lt;code&gt;/* ... */&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1914a937f0807f0283547ebd09066fb830cf5d9a" translate="yes" xml:space="preserve">
          <source>Must be seconds since or before Unix time epoch, which is 1970-01-01 00:00 UTC.</source>
          <target state="translated">1970 년 1 월 1 일 00:00 UTC 인 유닉스 시간 시대 이후 또는 초 단위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0a004964de291cbe488f9f8bc3e151f3bcd7aa7b" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;0&lt;/code&gt; for a regular NIF. If the emulator was built with dirty scheduler support enabled, &lt;code&gt;flags&lt;/code&gt; can be set to either &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; if the job is expected to be CPU-bound, or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; for jobs that will be I/O-bound. If dirty scheduler threads are not available in the emulator, an attempt to schedule such a job results in a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="translated">일반 NIF의 경우 &lt;code&gt;0&lt;/code&gt; 으로 설정해야합니다 . 에뮬레이터가 더러운 스케줄러 지원이 활성화가 내장되어있는 경우 &lt;code&gt;flags&lt;/code&gt; 로 설정할 수 있습니다 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; 작업이 CPU 바운드, 또는 것으로 예상되는 경우 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; I / O에 바인딩 될 것입니다 작업에. 에뮬레이터에서 더티 스케줄러 스레드를 사용할 수없는 경우 이러한 작업을 예약하려고하면 &lt;code&gt;notsup&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d99a3b8cea5bf9690f0427b0ac08c915ac93008c" translate="yes" xml:space="preserve">
          <source>Must be used with and be later than &lt;code&gt;StartTime&lt;/code&gt;. Values of &lt;code&gt;StopTime&lt;/code&gt; in the future are valid. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">&lt;code&gt;StartTime&lt;/code&gt; 이상과 함께 사용해야 합니다. 향후 &lt;code&gt;StopTime&lt;/code&gt; 값 이 유효합니다. 이 매개 변수는 &lt;code&gt;dateTime&lt;/code&gt; 유형 이며 RFC 3339를 준수합니다. 구현은 시간대를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="343d9e25c8247ada5612875ca81c9f7947f3e480" translate="yes" xml:space="preserve">
          <source>Must denote a valid date and time.</source>
          <target state="translated">유효한 날짜와 시간을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="1fa6f6533bff6aa5b9533df23cf9344981b03f0c" translate="yes" xml:space="preserve">
          <source>Must initiate data for a port. We do not create any sockets here, only initialize data structures.</source>
          <target state="translated">포트에 대한 데이터를 시작해야합니다. 여기서는 소켓을 만들지 않고 데이터 구조 만 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ac5b330f1d3ccf5e6f1d498219f9f2b403798468" translate="yes" xml:space="preserve">
          <source>Must of the functions below has an optional &lt;code&gt;Extra&lt;/code&gt; argument (e.g. &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt;). The functions which takes this argument will be called if and only if one of the functions &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; was called with the &lt;code&gt;Extra&lt;/code&gt; argument different than &lt;code&gt;ignore_extra&lt;/code&gt;.</source>
          <target state="translated">아래 함수 중 선택적인 &lt;code&gt;Extra&lt;/code&gt; 인수 가 있어야합니다 (예 : &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; 함수 중 하나 가 &lt;code&gt;ignore_extra&lt;/code&gt; 와 다른 &lt;code&gt;Extra&lt;/code&gt; 인수 로 호출 된 경우에만이 인수를 사용하는 함수 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ffc4b83d53a4262e348ddeab52e859129df93ad" translate="yes" xml:space="preserve">
          <source>Mutual exclusion lock. Used for synchronizing access to shared data. Only one thread at a time can lock a mutex.</source>
          <target state="translated">상호 배제 잠금. 공유 데이터에 대한 액세스를 동기화하는 데 사용됩니다. 한 번에 하나의 스레드 만 뮤텍스를 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="928b7c48a60ad93b81bc3bee9d274c5f2aed9ad3" translate="yes" xml:space="preserve">
          <source>Myanmar</source>
          <target state="translated">Myanmar</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="19a21faf21159c116d212d930e958b4e48e27561" translate="yes" xml:space="preserve">
          <source>N | 0</source>
          <target state="translated">N | 0</target>
        </trans-unit>
        <trans-unit id="53110edb9232b435b7ecd44976ac1b46ea9cd99d" translate="yes" xml:space="preserve">
          <source>N'</source>
          <target state="translated">N'</target>
        </trans-unit>
        <trans-unit id="5372a9a248f9a06cc2f439c7194a9046904b1126" translate="yes" xml:space="preserve">
          <source>N/A means not accessible.</source>
          <target state="translated">N / A는 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0604b491f5fa41cfffff730fb0a22dcd65418e3f" translate="yes" xml:space="preserve">
          <source>N1</source>
          <target state="translated">N1</target>
        </trans-unit>
        <trans-unit id="65bb4fc755e8bb11ccb0ee8cbfedee5528535446" translate="yes" xml:space="preserve">
          <source>N2</source>
          <target state="translated">N2</target>
        </trans-unit>
        <trans-unit id="70c7d4c52124c93b637e59dd435f7ca991164c3f" translate="yes" xml:space="preserve">
          <source>N3</source>
          <target state="translated">N3</target>
        </trans-unit>
        <trans-unit id="ce71d863e71837e0ee26dc56978e19026728b6e0" translate="yes" xml:space="preserve">
          <source>N4</source>
          <target state="translated">N4</target>
        </trans-unit>
        <trans-unit id="d3406dc507b393378bb88f5316f07b7c31cea1fd" translate="yes" xml:space="preserve">
          <source>N5</source>
          <target state="translated">N5</target>
        </trans-unit>
        <trans-unit id="ee2493b90e1342d0219ace167d7fdfeb9ab6a044" translate="yes" xml:space="preserve">
          <source>NC</source>
          <target state="translated">NC</target>
        </trans-unit>
        <trans-unit id="66bebc7980918515be0940e1250f00a7cdb2a30c" translate="yes" xml:space="preserve">
          <source>NETCONF client module.</source>
          <target state="translated">NETCONF 클라이언트 모듈.</target>
        </trans-unit>
        <trans-unit id="b64c6c7cdb62874f32c03bc2fb48dabf64192bed" translate="yes" xml:space="preserve">
          <source>NETCONF sessions can either be opened by a single call to &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or by a call to &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; followed by one or more calls to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">NETCONF 세션은 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 에 대한 단일 호출 또는 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 에 대한 호출에 이어 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 에 대한 하나 이상의 호출에 의해 열립니다 .</target>
        </trans-unit>
        <trans-unit id="6cc17604486656396f55bda1048a9ca72c9fb9fd" translate="yes" xml:space="preserve">
          <source>NETCONF traffic is not logged.</source>
          <target state="translated">NETCONF 트래픽이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57b93faae8cfee3611b3f0966ad1cb1ad092f30f" translate="yes" xml:space="preserve">
          <source>NIF libraries are loaded by calling &lt;code&gt;erlang:load_nif/2&lt;/code&gt;, with the name of the shared library as argument. The second argument can be any term that will be passed on to the library and used for initialization:</source>
          <target state="translated">NIF 라이브러리는 공유 라이브러리의 이름을 인수로 사용하여 &lt;code&gt;erlang:load_nif/2&lt;/code&gt; 를 호출하여로드됩니다 . 두 번째 인수는 라이브러리로 전달되어 초기화에 사용될 모든 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f5adb8aa2205182a8ae0d0874dfd09d3d15439" translate="yes" xml:space="preserve">
          <source>NIFs were introduced in Erlang/OTP R13B03 as an experimental feature. It is a simpler and more efficient way of calling C-code than using port drivers. NIFs are most suitable for synchronous functions, such as &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; in the example, that do some relatively short calculations without side effects and return the result.</source>
          <target state="translated">실험 기능으로 Erlang / OTP R13B03에 NIF가 도입되었습니다. 포트 드라이버를 사용하는 것보다 C 코드를 호출하는보다 간단하고 효율적인 방법입니다. NIF는 예제에서 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 와 같은 동기 함수에 가장 적합하며 부작용없이 비교적 짧은 계산을 수행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc50c726c2ad84ad90f8b5f7018cdda7d604c92c" translate="yes" xml:space="preserve">
          <source>NPTL glibc is strongly preferred, or a LinuxThreads glibc configured for &quot;floating stacks&quot;. Old non-floating stacks glibcs have a fundamental problem that makes HiPE support and threads support mutually exclusive.</source>
          <target state="translated">NPTL glibc가 강력하게 선호되거나 &quot;부동 스택&quot;을 위해 구성된 LinuxThreads glibc. 오래된 비 부동 스택 glibcs는 HiPE 지원과 스레드 지원이 상호 배타적이라는 근본적인 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707e05e3576a19dcc3c4c0b3a0f37a4d4a79406" translate="yes" xml:space="preserve">
          <source>NUMA node identifiers are system wide. That is, each NUMA node on the system must have a unique identifier. Processor identifiers are also system wide. Core identifiers are processor wide. Thread identifiers are core wide.</source>
          <target state="translated">NUMA 노드 식별자는 시스템 전체입니다. 즉, 시스템의 각 NUMA 노드에는 고유 식별자가 있어야합니다. 프로세서 식별자도 시스템 전체에 적용됩니다. 코어 식별자는 프로세서 전체에 적용됩니다. 스레드 식별자는 코어 전체입니다.</target>
        </trans-unit>
        <trans-unit id="96ca732e61f2bdd45036bc7061a358ac23542609" translate="yes" xml:space="preserve">
          <source>NUMERIC (precision, scale), DECIMAL (precision, scale), DEC (precision, scale ) precision - total number of digits, scale - total number of decimal places</source>
          <target state="translated">NUMERIC (정밀도, 스케일), DECIMAL (정밀도, 스케일), DEC (정밀도, 스케일) 정밀도-총 자릿수, 스케일-총 소수점 자릿수</target>
        </trans-unit>
        <trans-unit id="5c4cdee3ac47988555d2e4826cdf0ce2779c7bcd" translate="yes" xml:space="preserve">
          <source>Nabataean</source>
          <target state="translated">Nabataean</target>
        </trans-unit>
        <trans-unit id="49842eacbc9108e11c13f4f1a82e44c7d5e94e3e" translate="yes" xml:space="preserve">
          <source>Name = atom()</source>
          <target state="translated">이름 = atom ()</target>
        </trans-unit>
        <trans-unit id="09b603578ce92bd3efd6f652e0314619369218a8" translate="yes" xml:space="preserve">
          <source>Name and value of a TFTP option.</source>
          <target state="translated">TFTP 옵션의 이름과 값.</target>
        </trans-unit>
        <trans-unit id="c0f9e377e9e709bae968b8e8e63298cf66b15bba" translate="yes" xml:space="preserve">
          <source>Name collisions is another unwanted effect that can occur in multi file-compilation. The compiler solves this problem in one of two ways:</source>
          <target state="translated">이름 충돌은 다중 파일 컴파일에서 발생할 수있는 다른 원치 않는 효과입니다. 컴파일러는 다음 두 가지 방법 중 하나로이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="8fcf8ecda81b9b18e00c6dd548525fd833fd2355" translate="yes" xml:space="preserve">
          <source>Name identifying a Diameter application in service configuration. Passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending requests defined by the application.</source>
          <target state="translated">서비스 구성에서 직경 애플리케이션을 식별하는 이름입니다. 응용 프로그램에서 정의한 요청을 보낼 때 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="71819df6815dce60c7b749d24399fc212153d954" translate="yes" xml:space="preserve">
          <source>Name listing, that is, gives a list of all names registered on the host</source>
          <target state="translated">이름 목록, 즉 호스트에 등록 된 모든 이름 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8558c62ee07217f1a409e574c1eed556f16d0d5a" translate="yes" xml:space="preserve">
          <source>Name of a configuration parameter.</source>
          <target state="translated">구성 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fdd675b8843afe95f166148e521e9af5572f2c5b" translate="yes" xml:space="preserve">
          <source>Name of a service as passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; and with which the service is identified. There can be at most one service with a given name on a given node. Note that &lt;code&gt;erlang:make_ref/0&lt;/code&gt; can be used to generate a service name that is somewhat unique.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 에 전달되고 서비스가 식별되는 서비스의 이름입니다. 주어진 노드에는 주어진 이름을 가진 서비스가 하나만있을 수 있습니다. 참고 &lt;code&gt;erlang:make_ref/0&lt;/code&gt; 다소 고유 한 서비스 이름을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9e1cf8d6c3186f4d60ebb503a782d0a2af71404" translate="yes" xml:space="preserve">
          <source>Name of an application included in the release.</source>
          <target state="translated">릴리스에 포함 된 응용 프로그램의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8f09bbb27e998d8b4e1d54c80a6e9f9e419ecbbe" translate="yes" xml:space="preserve">
          <source>Name of an encode/decode module for the Diameter messages defined by the application. These modules are generated from files whose format is documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에서 정의한 직경 메시지에 대한 인코딩 / 디코딩 모듈의 이름입니다. 이 모듈은 형식이 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서화 된 파일에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fea55da9488bc6b080a2d195d952706c2922e0f1" translate="yes" xml:space="preserve">
          <source>Name of another &lt;code&gt;.config&lt;/code&gt; file. Extension &lt;code&gt;.config&lt;/code&gt; can be omitted. It is recommended to use absolute paths. If a relative path is used, &lt;code&gt;File&lt;/code&gt; is searched, first, relative from &lt;code&gt;sys.config&lt;/code&gt; directory, then relative to the current working directory of the emulator, for backward compatibility. This allow to use a &lt;code&gt;sys.config&lt;/code&gt; pointing out other &lt;code&gt;.config&lt;/code&gt; files in a release or in a node started manually using &lt;code&gt;-config ...&lt;/code&gt; with same result whatever the current working directory.</source>
          <target state="translated">다른 &lt;code&gt;.config&lt;/code&gt; 파일의 이름 확장자 &lt;code&gt;.config&lt;/code&gt; 는 생략 할 수 있습니다. 절대 경로를 사용하는 것이 좋습니다. 상대 경로가 사용되는 경우, &lt;code&gt;File&lt;/code&gt; 은 먼저 &lt;code&gt;sys.config&lt;/code&gt; 디렉토리를 기준으로 검색 한 후 에뮬레이터의 현재 작업 디렉토리를 기준으로 이전 버전과의 호환성을 위해 검색됩니다. 이를 통해 &lt;code&gt;sys.config&lt;/code&gt; 를 사용하여 릴리스의 다른 &lt;code&gt;.config&lt;/code&gt; 파일을 가리 키 거나 &lt;code&gt;-config ...&lt;/code&gt; 를 사용하여 수동으로 시작한 노드 에서 현재 작업 디렉토리와 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6861f1ccaff61ef5f193977a356660fc3597d944" translate="yes" xml:space="preserve">
          <source>Name of the module implementing the service-specific parts of the channel.</source>
          <target state="translated">채널의 서비스 별 부분을 구현하는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22d1ae1c673a94829dfb8e83a7bb9cf9e8965d80" translate="yes" xml:space="preserve">
          <source>Name of the node that the event originated from (only relevant for &lt;code&gt;Common Test&lt;/code&gt; Master event handlers).</source>
          <target state="translated">이벤트가 시작된 노드의 이름입니다 ( &lt;code&gt;Common Test&lt;/code&gt; 마스터 이벤트 핸들러 에만 해당 ).</target>
        </trans-unit>
        <trans-unit id="b760b08100c634abc56d0ded647804bdc7f195fd" translate="yes" xml:space="preserve">
          <source>Name of the other node. This field is only mandatory when this node initiates the connection. That is, when connection is set up via &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 노드의 이름 이 필드는이 노드가 연결을 시작할 때만 필수입니다. 즉, &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 를 통해 연결이 설정된 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="dc0f0987cfc3071fee54739de9248fcf0b3b84b9" translate="yes" xml:space="preserve">
          <source>Name of the profile, see &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt;. This option is mandatory.</source>
          <target state="translated">프로파일의 이름은 &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이 옵션은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7ca26e64b9064a42da13098416e3e7bb4bf4ed2c" translate="yes" xml:space="preserve">
          <source>Name of the reporting supervisor.</source>
          <target state="translated">보고 감독자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dfdc16cf0a3aafa431b5fbcdc7de5f060dd8e75e" translate="yes" xml:space="preserve">
          <source>Name of the security data file. The filename can either be absolute or relative to the &lt;code&gt;server_root&lt;/code&gt;. This file is used to store persistent data for module &lt;code&gt;mod_security&lt;/code&gt;.</source>
          <target state="translated">보안 데이터 파일의 이름입니다. 파일 이름은 &lt;code&gt;server_root&lt;/code&gt; 에 대해 절대적이거나 상대적 일 수 있습니다 . 이 파일은 &lt;code&gt;mod_security&lt;/code&gt; 모듈의 영구 데이터를 저장하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="815591c3d2946d084be9c0e9370d8e5d2a5e8031" translate="yes" xml:space="preserve">
          <source>Name of the user callback module. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">사용자 콜백 모듈의 이름입니다. 자세한 내용은 megaco_user의 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f29ab265b46a1c65a2110325442c0296db3b5e7b" translate="yes" xml:space="preserve">
          <source>Name specification to use when starting a &lt;code&gt;gen_statem&lt;/code&gt; server. See &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 서버를 시작할 때 사용할 이름 스펙 . 아래의 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8f752f803e242b87f3c03a4082c687998ac3da7" translate="yes" xml:space="preserve">
          <source>Named lock or named set of locks (classes). The same name used for initializing the lock in the VM.</source>
          <target state="translated">명명 된 잠금 또는 명명 된 잠금 세트 (클래스). VM에서 잠금을 초기화하는 데 사용 된 것과 동일한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e9dd77b6e1709773eb7654ae6b320bce9c21508d" translate="yes" xml:space="preserve">
          <source>Names consist of up to 32 alphanumeric characters and underscores, but must start with a non-digit. Named capturing parentheses are still allocated numbers as well as names, exactly as if the names were not present. The &lt;code&gt;capture&lt;/code&gt; specification to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can use named values if they are present in the regular expression.</source>
          <target state="translated">이름은 최대 32 자의 영숫자와 밑줄로 구성되지만 숫자가 아닌 숫자로 시작해야합니다. 명명 된 캡처 괄호에는 이름이없는 것처럼 정확하게 이름뿐만 아니라 숫자도 할당됩니다. &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;capture&lt;/code&gt; 스펙은 명명 된 값이 정규식에있는 경우 명명 된 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7093792812d2bcab51e7c92258df5d9e6b4b018a" translate="yes" xml:space="preserve">
          <source>Names of files needed by the test</source>
          <target state="translated">테스트에 필요한 파일 이름</target>
        </trans-unit>
        <trans-unit id="7257f798528c7c674ee2f8465b8c5680983ef6ca" translate="yes" xml:space="preserve">
          <source>Names of programs to be executed during the test</source>
          <target state="translated">테스트 중에 실행될 프로그램의 이름</target>
        </trans-unit>
        <trans-unit id="8df9c18f0f6605c9864c1c03438f7d9bd20d3dfe" translate="yes" xml:space="preserve">
          <source>Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below.</source>
          <target state="translated">캡처 하위 패턴을 식별하는 데 사용되는 이름은 고유하지 않아도됩니다. 명명 된 하위 패턴의 인스턴스 하나만 일치 할 수있는 것으로 알려진 경우 특정 유형의 패턴에 유용합니다. 명명 된 하위 패턴에 대한 자세한 내용은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="400c3476c738eefb94528ac0d99970ee7cad1461" translate="yes" xml:space="preserve">
          <source>Nameservers</source>
          <target state="translated">Nameservers</target>
        </trans-unit>
        <trans-unit id="d081bf458b12ded79224fc426e9b704fda3eb830" translate="yes" xml:space="preserve">
          <source>Nanoseconds</source>
          <target state="translated">Nanoseconds</target>
        </trans-unit>
        <trans-unit id="69fd8f514808c906504e870b76d0ad25cb1a2810" translate="yes" xml:space="preserve">
          <source>Narrow no-break space</source>
          <target state="translated">좁은 휴식 공간</target>
        </trans-unit>
        <trans-unit id="19cf0fcc0b86f78ec04f6f1388bfa92de80267cc" translate="yes" xml:space="preserve">
          <source>Native atomic implementation in the order preferred:</source>
          <target state="translated">선호 순서대로 기본 원자 구현 :</target>
        </trans-unit>
        <trans-unit id="f4ceb03af949e9762ac45be133b29937865498db" translate="yes" xml:space="preserve">
          <source>Native lookup (system calls) is always the default resolver method. This is true for all platforms, except VxWorks and OSE Delta where &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt; is used (in that priority order).</source>
          <target state="translated">기본 조회 (시스템 호출)는 항상 기본 해결 방법입니다. 이는 &lt;code&gt;'file'&lt;/code&gt; 또는 &lt;code&gt;'dns'&lt;/code&gt; 가 사용되는 VxWorks 및 OSE Delta를 제외한 모든 플랫폼에 적용 됩니다 (우선 순위 순).</target>
        </trans-unit>
        <trans-unit id="2f3e991d2e06301019e7df6974c400874b1e24a9" translate="yes" xml:space="preserve">
          <source>Native-endian means that the endianness is resolved at load time to be either big-endian or little-endian, depending on what is native for the CPU that the Erlang machine is run on. Endianness only matters when the Type is either &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">기본 엔디안은 Erlang 시스템이 실행되는 CPU의 기본 설정에 따라로드시 엔디안이 빅 엔디안 또는 리틀 엔디안으로 해석됨을 의미합니다. 엔디안은 Type이 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; 인 경우에만 중요합니다 . 기본값은 &lt;code&gt;big&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88ec7eb1fe551ab56659dcb328c9e9308618cdd5" translate="yes" xml:space="preserve">
          <source>Need 10 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">10 바이트와 노드 이름에 공백이 필요합니다. 이것은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="dfe1c4e24186450c5c19fcf8debfad6318586391" translate="yes" xml:space="preserve">
          <source>Need 3 bytes, plus 1 byte for each character (the terminating 0 is not encoded). Really long strings (more than 64k characters) are encoded as lists. Atoms cannot contain more than 256 characters.</source>
          <target state="translated">각 문자에 3 바이트와 1 바이트가 필요합니다 (종료 0은 인코딩되지 않음). 실제로 긴 문자열 (64k 문자 이상)은 목록으로 인코딩됩니다. 원자는 256자를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a2629810e6dae5fd2ed18399d49c9f6234b2d75" translate="yes" xml:space="preserve">
          <source>Need 32 bytes.</source>
          <target state="translated">32 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dd1ab6a463a6a8cb3b094e2a5ffe579607280a5c" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element, and 1 more byte for the empty list at the end.</source>
          <target state="translated">5 바이트와 각 요소에 공백이 필요하고 끝에 빈 목록에 1 바이트가 더 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0331bba0a243dd4f934fa2e9828a630bcd871f86" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element.</source>
          <target state="translated">5 바이트와 각 요소에 대한 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c0aabf92511a79ab04e6d0216eff8b4f3d2d00af" translate="yes" xml:space="preserve">
          <source>Need 5 bytes.</source>
          <target state="translated">5 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="175e1f869033a45b5e96e2f6f2ecaeb8e97b007a" translate="yes" xml:space="preserve">
          <source>Need 6 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">6 바이트와 노드 이름을위한 공간 (아톰)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1156c7af2383ba07233854d7dd710d317bc45336" translate="yes" xml:space="preserve">
          <source>Negate a filter.</source>
          <target state="translated">필터를 무효화하십시오.</target>
        </trans-unit>
        <trans-unit id="20692085423110f20958119048a05722032e1bc2" translate="yes" xml:space="preserve">
          <source>Negate the class, but only if the first character</source>
          <target state="translated">첫 번째 캐릭터 인 경우에만 클래스 무효화</target>
        </trans-unit>
        <trans-unit id="f153dc3672bdd71d80e9c27aa57b80cf24f1ae5f" translate="yes" xml:space="preserve">
          <source>Negated character class, which matches any character except &lt;code&gt;abc...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;abc...&lt;/code&gt; 제외한 모든 문자와 일치하는 부정 문자 클래스 .</target>
        </trans-unit>
        <trans-unit id="de3797823858d972e58f40676bf0b9c8044164ac" translate="yes" xml:space="preserve">
          <source>Negated versions, such as [:^alpha:], use \P instead of \p. Three other POSIX classes are handled specially in UCP mode:</source>
          <target state="translated">[: ^ alpha :]와 같은 부정 버전은 \ p 대신 \ P를 사용합니다. 다른 세 가지 POSIX 클래스는 UCP 모드에서 특별히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ea9c2b442d3489fafed30d313fd4bb83f3a5f3ae" translate="yes" xml:space="preserve">
          <source>Negates its single argument (anything other than &lt;code&gt;false&lt;/code&gt; gives &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">그 하나의 인자 (보다 다른 것을 부정 &lt;code&gt;false&lt;/code&gt; 제공 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ed6e5275d882c1d7a3e78254834d37cdc3ae869" translate="yes" xml:space="preserve">
          <source>Negative assertions are, however, different, to ensure that changing a positive assertion into a negative assertion changes its result. Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative assertion to be true, without considering any further alternative branches in the assertion. Backtracking into (*THEN) causes it to skip to the next enclosing alternative within the assertion (the normal behavior), but if the assertion does not have such an alternative, (*THEN) behaves like (*PRUNE).</source>
          <target state="translated">그러나 긍정적 주장이 부정 주장으로 변경되면 결과가 변경되도록 부정 주장이 다릅니다. (* COMMIT), (* SKIP) 또는 (* PRUNE)으로 역 추적하면 어설 션의 추가 대체 분기를 고려하지 않고 부정적인 어설 션이 적용됩니다. (* THEN)으로 역 추적하면 어설 션 내의 다음 둘러싸는 대체 (일반 동작)로 건너 뛰지 만 어설 션에 이러한 대체가없는 경우 (* THEN)은 (* PRUNE)과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebf32ee53eee5495ff25445bebe98e3b2f6d93ca" translate="yes" xml:space="preserve">
          <source>Negative length can be used to extract bytes at the end of a binary, for example:</source>
          <target state="translated">음수 길이는 이진이 끝날 때 바이트를 추출하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5a05483241f86212e46d2efad89e6999eecd1d1" translate="yes" xml:space="preserve">
          <source>Nested test cases:</source>
          <target state="translated">중첩 된 테스트 사례 :</target>
        </trans-unit>
        <trans-unit id="127f49081f658cece5f3811cf0dc1334ffa1512f" translate="yes" xml:space="preserve">
          <source>Nested transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d178bd65e3d29cc6434618a4937bb2f5c582992" translate="yes" xml:space="preserve">
          <source>Net if must send the following message when it receives an SNMP PDU from the network that is aimed for the MasterAgent:</source>
          <target state="translated">MasterAgent를 대상으로하는 네트워크에서 SNMP PDU를 수신 할 때 다음 메시지를 보내야하는 경우 Net :</target>
        </trans-unit>
        <trans-unit id="8f62bf25b466c186d1af5cfde979303cd21e7891" translate="yes" xml:space="preserve">
          <source>Net load mode. Loads all recompiled modules on all known nodes.</source>
          <target state="translated">순 하중 모드. 알려진 모든 노드에서 재 컴파일 된 모든 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="0114e1a690d0d3b69edf39a672c8130542ac6aac" translate="yes" xml:space="preserve">
          <source>Net tick time-out.</source>
          <target state="translated">순 틱 시간 초과.</target>
        </trans-unit>
        <trans-unit id="110548035d847260e8d0a9e8d8ce3832b7e46903" translate="yes" xml:space="preserve">
          <source>Never derefrence aliases, treat aliases as entries.</source>
          <target state="translated">별칭을 무시하지 말고 별칭을 항목으로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="daa1ec0c63bdc175afef3521716bd266db3aa640" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoItem&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoItem&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">새로운 &lt;code&gt;InfoItem&lt;/code&gt; 을 추가 할 수 있고, 문서화되지 않은 오래된 &lt;code&gt;InfoItem&lt;/code&gt; 을 예고없이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a81bf26d684841baa361ac6ddd6963f7889e13" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoKey&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoKey&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">새로운 &lt;code&gt;InfoKey&lt;/code&gt; 를 추가 할 수 있으며, 문서화되지 않은 오래된 &lt;code&gt;InfoKey&lt;/code&gt; 를 예고없이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25dfab9ef64421c944663406fd9382ff81ddcbe8" translate="yes" xml:space="preserve">
          <source>New AVPs can be defined using the dictionary interface. Both RFC data formats and extensions are supported.</source>
          <target state="translated">사전 인터페이스를 사용하여 새로운 AVP를 정의 할 수 있습니다. RFC 데이터 형식 및 확장이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5416773a10d805e30e6f5bc99d1554c94eafc798" translate="yes" xml:space="preserve">
          <source>New applications can be defined using the dictionary interface.</source>
          <target state="translated">사전 인터페이스를 사용하여 새로운 응용 프로그램을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416932539df1b3d2d48bade29a12d73c261c20c5" translate="yes" xml:space="preserve">
          <source>New commands can be defined using the dictionary interface.</source>
          <target state="translated">사전 인터페이스를 사용하여 새 명령을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21bafe5e2b543d12417c1f410bfa49ddc920dfa" translate="yes" xml:space="preserve">
          <source>New maps can include multiple associations at construction by listing every association:</source>
          <target state="translated">새 맵에는 모든 연관을 나열하여 구성시 여러 연관을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6664f56a53edf8b2fadc61d9507782caf98822df" translate="yes" xml:space="preserve">
          <source>New replicas can be added before all other replicas of the table have been loaded, provided that at least one other replica is active.</source>
          <target state="translated">하나 이상의 다른 복제본이 활성화되어 있으면 테이블의 다른 모든 복제본을로드하기 전에 새 복제본을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04bdf4b4e76aa242a32e437a5883cf844d9d4b7" translate="yes" xml:space="preserve">
          <source>New schemas are created explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; or implicitly by starting &lt;code&gt;Mnesia&lt;/code&gt; without a disc resident schema. Whenever a table (including the schema table) is created, it is assigned its own unique cookie. The schema table is not created with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; as normal tables.</source>
          <target state="translated">새 스키마는 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명시 적으로 작성 하거나 디스크 상주 스키마없이 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작하여 내재적으로 작성 합니다. 테이블 (스키마 테이블 포함)을 만들 때마다 고유 한 쿠키가 할당됩니다. 스키마 테이블은 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 함수 를 일반 테이블로 사용하여 작성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b998dd3bf2b993a54515b2681267a6568c0a6475" translate="yes" xml:space="preserve">
          <source>New shell (&lt;code&gt;erlang-shell&lt;/code&gt;) - Starts a new Erlang shell.</source>
          <target state="translated">새 쉘 ( &lt;code&gt;erlang-shell&lt;/code&gt; )-새 Erlang 쉘을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="aa4c2977862e2e3f49c4b7dd716229ca641b9204" translate="yes" xml:space="preserve">
          <source>New warnings may be issued between releases.</source>
          <target state="translated">릴리스간에 새로운 경고가 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47cc38a5f6affc6fd9f8a8683e76dfafa574aed8" translate="yes" xml:space="preserve">
          <source>New_Tai_Lue</source>
          <target state="translated">New_Tai_Lue</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="808b78209485244b8997d57758391c54f156212c" translate="yes" xml:space="preserve">
          <source>Newline (line feed).</source>
          <target state="translated">줄 바꿈 (줄 바꿈).</target>
        </trans-unit>
        <trans-unit id="5afff985ebf32e8270418f54db6417fb06d959ae" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character &lt;code&gt;cr&lt;/code&gt; (ASCII 13).</source>
          <target state="translated">줄 바꿈은 단일 문자 &lt;code&gt;cr&lt;/code&gt; (ASCII 13)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b583b651d9a2285954a06341ac73241bded628" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character CR (ASCII 13).</source>
          <target state="translated">줄 바꿈은 단일 문자 CR (ASCII 13)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9187e5ffa24cd194b0938789b60c4fc382a957ab" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character LF (ASCII 10), the default.</source>
          <target state="translated">줄 바꿈은 기본적으로 단일 문자 LF (ASCII 10)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d601bad3ec62c50f75f6a3ba9573e21733220395" translate="yes" xml:space="preserve">
          <source>Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</source>
          <target state="translated">줄 바꿈은 두 문자 CRLF (ASCII 13 뒤에 ASCII 10) 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="18d8a520a75d3617fd621fe2e386b1424f0b50e7" translate="yes" xml:space="preserve">
          <source>Next come the &lt;code&gt;grammar rules&lt;/code&gt;. Each rule has the general form</source>
          <target state="translated">다음은 &lt;code&gt;grammar rules&lt;/code&gt; 입니다. 각 규칙에는 일반적인 형식이 있습니다</target>
        </trans-unit>
        <trans-unit id="857695141b6b6a959a5e9f08218ec562945d5a77" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;nonterminal categories&lt;/code&gt; to be used in the rules. For example:</source>
          <target state="translated">다음은 규칙에 사용될 &lt;code&gt;nonterminal categories&lt;/code&gt; 의 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e83a4b5708be5e10a3a091382f374fd5808b3211" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;rootsymbol&lt;/code&gt;, or start category of the grammar. For example:</source>
          <target state="translated">다음은 &lt;code&gt;rootsymbol&lt;/code&gt; 또는 문법의 시작 범주에 대한 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fef9750a2a463281a998e47d19f0d0871be00c7d" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;terminal categories&lt;/code&gt;, which are the categories of tokens produced by the scanner. For example:</source>
          <target state="translated">다음은 스캐너가 생성 한 토큰의 범주 인 &lt;code&gt;terminal categories&lt;/code&gt; 의 선언입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9e370493e9e17b4819d6f79d261d079cacde553" translate="yes" xml:space="preserve">
          <source>Next comes one or more declarations of &lt;code&gt;operator precedences&lt;/code&gt;, if needed. These are used to resolve shift/reduce conflicts (see &lt;code&gt;yacc&lt;/code&gt; documentation).</source>
          <target state="translated">다음은 필요한 경우 &lt;code&gt;operator precedences&lt;/code&gt; 선언을 하나 이상 제공 합니다. 이들은 교대 / 감소 충돌을 해결하는 데 사용됩니다 ( &lt;code&gt;yacc&lt;/code&gt; 설명서 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f7553f74bd8b74cc4fcc22ad756157cb5776f2f" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;after&lt;/code&gt;. This closes the file, even in the event of exceptions in &lt;code&gt;file:read/2&lt;/code&gt; or in &lt;code&gt;binary_to_term/1&lt;/code&gt;. The exceptions are the same as without the &lt;code&gt;try&lt;/code&gt;...&lt;code&gt;after&lt;/code&gt;...&lt;code&gt;end&lt;/code&gt; expression:</source>
          <target state="translated">다음은 &lt;code&gt;after&lt;/code&gt; 를 사용하는 예입니다 . &lt;code&gt;file:read/2&lt;/code&gt; 또는 &lt;code&gt;binary_to_term/1&lt;/code&gt; 에서 예외가 발생하더라도 파일을 닫습니다 . 예외는 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;after&lt;/code&gt; ... &lt;code&gt;end&lt;/code&gt; 표현식이 없는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="baf40b5d188d7e3554eac9acbf598ea4267e238b" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;try&lt;/code&gt; to emulate &lt;code&gt;catch Expr&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;catch Expr&lt;/code&gt; 에뮬레이션 &lt;code&gt;try&lt;/code&gt; 를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c4092f0a830b3e6796bef07ac155e4adee4739ca" translate="yes" xml:space="preserve">
          <source>Next line (NEL)</source>
          <target state="translated">다음 줄 (NEL)</target>
        </trans-unit>
        <trans-unit id="49c36c588e423f9755f10724b38b806cab7bb00b" translate="yes" xml:space="preserve">
          <source>Next the system to be analyzed is added to the Xref server. Here the system will be OTP, so no library path will be needed. Otherwise, when analyzing a system that uses OTP, the OTP modules are typically made library modules by setting the library path to the default OTP code path (or to &lt;code&gt;code_path&lt;/code&gt;, see the &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;). By default, the names of read BEAM files and warnings are output when adding analyzed modules, but these messages can be avoided by setting default values of some options:</source>
          <target state="translated">다음으로 분석 할 시스템이 외부 참조 서버에 추가됩니다. 여기서 시스템은 OTP이므로 라이브러리 경로가 필요하지 않습니다. 그렇지 않으면 OTP를 사용하는 시스템을 분석 할 때 일반적으로 라이브러리 경로를 기본 OTP 코드 경로 (또는 &lt;code&gt;code_path&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; ) 로 설정하여 OTP 모듈을 라이브러리 모듈로 만듭니다 . 기본적으로 분석 된 모듈을 추가 할 때 읽은 BEAM 파일 및 경고의 이름이 출력되지만 일부 옵션의 기본값을 설정하면 이러한 메시지를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d521b3788a65371a641f56d5e8d11c4ad08f4b" translate="yes" xml:space="preserve">
          <source>Next transaction id. A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (only in case of error).</source>
          <target state="translated">다음 거래 ID. 양의 정수 또는 원자 &lt;code&gt;undefined_serial&lt;/code&gt; (오류의 경우에만).</target>
        </trans-unit>
        <trans-unit id="0defe52a66513a79940e5ab6dc6388b2167016ac" translate="yes" xml:space="preserve">
          <source>Next we handle the different requests, first the fairly generic multi-request type:</source>
          <target state="translated">다음으로 다른 요청을 처리합니다. 먼저 일반적인 다중 요청 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d2101e96703268b0a370202e8ee193996232f211" translate="yes" xml:space="preserve">
          <source>Next, the two higher order functions &lt;code&gt;pand&lt;/code&gt; and &lt;code&gt;por&lt;/code&gt; are defined. They combine primitive parsers to produce more complex parsers.</source>
          <target state="translated">다음으로, &lt;code&gt;pand&lt;/code&gt; 와 &lt;code&gt;por&lt;/code&gt; 의 두 가지 고차 함수 가 정의됩니다. 이들은 원시 파서를 결합하여 더 복잡한 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="55674258a28777513c3ee8a1247d68d39b7e5128" translate="yes" xml:space="preserve">
          <source>Nko</source>
          <target state="translated">Nko</target>
        </trans-unit>
        <trans-unit id="cf9ccefe9fbda77917b667cca9134ccee3903031" translate="yes" xml:space="preserve">
          <source>Nlen</source>
          <target state="translated">Nlen</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="306df27b0e9baa7048471bce2f90b4c62b83a515" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;CLASSPATH&lt;/code&gt; or anything is needed. Type &lt;code&gt;javac&lt;/code&gt; in the bash prompt and you should get a list of available Java options. Make sure, e.g by typing &lt;code&gt;type java&lt;/code&gt;, that you use the Java you installed. Note however that Cygwin's/MinGW's/MSYS2's &lt;code&gt;jar.exe&lt;/code&gt; is used. That's why the JDK bin-directory should be added last in the &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">아니 &lt;code&gt;CLASSPATH&lt;/code&gt; 또는 아무것도 필요하다. bash 프롬프트에 &lt;code&gt;javac&lt;/code&gt; 를 입력 하면 사용 가능한 Java 옵션 목록이 표시됩니다. 예를 들어 &lt;code&gt;type java&lt;/code&gt; 을 입력하여 설치 한 Java를 사용 하는지 확인하십시오 . 그러나 Cygwin 's / MinGW 's / MSYS2 's &lt;code&gt;jar.exe&lt;/code&gt; 가 사용됩니다. 그렇기 때문에 JDK bin 디렉토리가 &lt;code&gt;PATH&lt;/code&gt; 의 마지막에 추가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="20123f437cbed011ee99b107692f5a0de92f5b78" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;OTP_VERSION&lt;/code&gt; file is placed in a &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; created by OTP tools. This since one easily can create a target system where it is hard to even determine the base OTP version. You can, however, place such a file there if you know the OTP version.</source>
          <target state="translated">OTP 도구로 작성된 &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;OTP_VERSION&lt;/code&gt; 파일이 없습니다 . 이것은 기본 OTP 버전을 결정하기 어려운 대상 시스템을 쉽게 만들 수 있기 때문입니다. 그러나 OTP 버전을 알고있는 경우 이러한 파일을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b26bf8ba2172d52337372f5408c0374da428f07b" translate="yes" xml:space="preserve">
          <source>No available CPU topology. That is, the runtime system was not able to detect the CPU topology automatically, and no &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; was set.</source>
          <target state="translated">사용 가능한 CPU 토폴로지가 없습니다. 즉, 런타임 시스템이 CPU 토폴로지를 자동으로 감지 할 수 없었으며 &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; 가 설정 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="a85ad1a848cbb91f4217ade2f8af6dd92f90a8ce" translate="yes" xml:space="preserve">
          <source>No channel is started. This is done by calling &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">채널이 시작되지 않았습니다. &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="fddf0f31436a33dc7eb65b7e662b0a272aad9fa5" translate="yes" xml:space="preserve">
          <source>No character in the Unicode table has the Cn (unassigned) property. This property is instead assumed for any code point that is not in the Unicode table.</source>
          <target state="translated">유니 코드 테이블에는 Cn (지정되지 않은) 속성이있는 문자가 없습니다. 대신이 속성은 유니 코드 테이블에없는 코드 포인트에 대해 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="dc57d984725306844c55a6e549f5434351f897bb" translate="yes" xml:space="preserve">
          <source>No execution mode. Just prints the name of each module that needs to be compiled.</source>
          <target state="translated">실행 모드가 없습니다. 컴파일해야 할 각 모듈의 이름 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4f359a331e2d8e32338d669077706cc69d91dc7c" translate="yes" xml:space="preserve">
          <source>No file with object code exists.</source>
          <target state="translated">객체 코드가있는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="13241af56c130b238829c77fe317f13857c53de0" translate="yes" xml:space="preserve">
          <source>No file with object code was found.</source>
          <target state="translated">오브젝트 코드가있는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="440071f450e51e9d450fcc9382feef4bf2695f38" translate="yes" xml:space="preserve">
          <source>No files are compressed.</source>
          <target state="translated">압축 된 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dc01295326d7bbe83d6152968ff814da6bb7e65" translate="yes" xml:space="preserve">
          <source>No form of peer discovery is implemented. The user can implement this independently of diameter if required.</source>
          <target state="translated">어떤 형태의 피어 발견도 구현되지 않습니다. 사용자는 필요한 경우 직경과 무관하게이를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c55b9244448dbb0de0232a0eac2de1afdad171" translate="yes" xml:space="preserve">
          <source>No garbage collection was performed, as the process identified by &lt;code&gt;Pid&lt;/code&gt; terminated before the request could be satisfied.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 에 의해 식별 된 프로세스 가 요청을 충족시키기 전에 종료 되었으므로 가비지 콜렉션이 수행되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="2f23a91f9bb422d0761d2bc7e964443f6476d113" translate="yes" xml:space="preserve">
          <source>No locks are released when child transactions terminate. Locks created by a sequence of nested transactions are kept until the topmost transaction terminates. Furthermore, any update performed by a nested transaction is only propagated in such a manner so that the parent of the nested transaction sees the updates. No final commitment is done until the top-level transaction terminates. So, although a nested transaction returns &lt;code&gt;{atomic, Val}&lt;/code&gt;, if the enclosing parent transaction terminates, the entire nested operation terminates.</source>
          <target state="translated">하위 트랜잭션이 종료 될 때 잠금이 해제되지 않습니다. 중첩 된 트랜잭션 시퀀스로 생성 된 잠금은 최상위 트랜잭션이 종료 될 때까지 유지됩니다. 또한 중첩 트랜잭션에 의해 수행 된 모든 업데이트는 중첩 트랜잭션의 부모가 업데이트를 볼 수있는 방식으로 만 전파됩니다. 최상위 트랜잭션이 종료 될 때까지 최종 커밋이 수행되지 않습니다. 따라서 중첩 된 트랜잭션이 &lt;code&gt;{atomic, Val}&lt;/code&gt; 리턴하지만, 상위 상위 트랜잭션이 종료되면 전체 중첩 조작이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f674a37123f0ffc3506454e7b55512d60713fa52" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating a &lt;code&gt;case&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 표현식을 평가할 때 일치하는 분기가 없습니다 . 값 &lt;code&gt;V&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7043cf82452e810d5c16d3e477ed93f700205d66" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating the of-section of a &lt;code&gt;try&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 표현식의 섹션을 평가할 때 일치하는 분기가 없습니다 . 값 &lt;code&gt;V&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bafda3e67a73a9fac5366e727d20ddc61884e3fb" translate="yes" xml:space="preserve">
          <source>No matching function clause is found when evaluating a function call.</source>
          <target state="translated">함수 호출을 평가할 때 일치하는 함수 절이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b154fd09fbcc9049abbeb9b2cae25aa1de56f340" translate="yes" xml:space="preserve">
          <source>No more available OS processes.</source>
          <target state="translated">더 이상 사용 가능한 OS 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="30a54d12705f7304413a1180c01d997ab6369210" translate="yes" xml:space="preserve">
          <source>No more available file descriptors (for the OS process that the Erlang emulator runs in).</source>
          <target state="translated">더 이상 사용 가능한 파일 디스크립터가 없습니다 (Erlang 에뮬레이터가 실행되는 OS 프로세스 용).</target>
        </trans-unit>
        <trans-unit id="a8ffa3b27d199208e567b9f7e6b61c30d8a4fd15" translate="yes" xml:space="preserve">
          <source>No more memory is available.</source>
          <target state="translated">더 이상 사용 가능한 메모리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf3f0d88be368d141ccef5093be9613bf0c9230c" translate="yes" xml:space="preserve">
          <source>No network is available.</source>
          <target state="translated">사용 가능한 네트워크가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c489474600adaec621c887ab5f0e2e6aff78625a" translate="yes" xml:space="preserve">
          <source>No new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">새 옵션을 추가 할 수 없지만 &lt;code&gt;SuggestedOptions&lt;/code&gt; 에 있는 옵션은 생략하거나 &lt;code&gt;AcceptedOptions&lt;/code&gt; 에 새 값으로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cccb01175197e57cc2cc371d3deb57037c621f92" translate="yes" xml:space="preserve">
          <source>No object code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">객체 코드가 없습니다. 소스 코드와 객체 코드는 같은 디렉토리에 있거나 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 위치하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a11ca60fca56c33b2c64441ebd0092b5a2034edf" translate="yes" xml:space="preserve">
          <source>No object with the correct key exists and no default object was supplied.</source>
          <target state="translated">올바른 키를 가진 오브젝트가 없으며 기본 오브젝트가 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="01bb309c51c64719a36ff0535eb3f933818be49b" translate="yes" xml:space="preserve">
          <source>No optimization was found. A match specification matching all objects is used if &lt;code&gt;TraverseFun&lt;/code&gt; is unary.</source>
          <target state="translated">최적화가 없습니다. &lt;code&gt;TraverseFun&lt;/code&gt; 이 단항 인 경우 모든 객체와 일치하는 일치 사양이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd5da193599373a0a6119b861beeeab1a8bf22a1" translate="yes" xml:space="preserve">
          <source>No other support is available within this module that would guarantee consistency between objects. However, function &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; can be used to guarantee that a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls traverse the table without errors and that each existing object in the table is visited exactly once, even if another (or the same) process simultaneously deletes or inserts objects into the table. Nothing else is guaranteed; in particular objects that are inserted or deleted during such a traversal can be visited once or not at all. Functions that internally traverse over a table, like &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, give the same guarantee as &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈 내에서 개체 간 일관성을 보장하는 다른 지원은 없습니다. 그러나 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하면 일련의 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 호출이 오류없이 테이블을 순회하고 다른 (또는 동일한) 프로세스 인 경우에도 테이블에있는 기존의 각 오브젝트를 정확히 한 번 방문 하도록 보장 할 수 있습니다. 동시에 테이블에 객체를 삭제하거나 삽입합니다. 다른 것은 보장되지 않습니다. 특히 이러한 순회 중에 삽입되거나 삭제 된 객체는 한 번 방문하거나 전혀 방문하지 않을 수 있습니다. &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; 와 같이 내부적으로 테이블을 가로 지르는 함수는 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt; 과 동일한 보증을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd17e64205667c500758839414e3602b81b56476" translate="yes" xml:space="preserve">
          <source>No packaging is done.</source>
          <target state="translated">포장이 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ba80c47298de4f4f293a1e5e303c27b3b69db4f4" translate="yes" xml:space="preserve">
          <source>No packet handling is done. The entire binary is returned unless it is empty.</source>
          <target state="translated">패킷 처리가 수행되지 않습니다. 비어 있지 않으면 전체 바이너리가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6f2c7da1bb311124b43ce0e8411af0807caf66" translate="yes" xml:space="preserve">
          <source>No persistent information is updated, so these functions can be used on any Erlang node, embedded or not. Also, using these functions does not affect which code is loaded if there is a reboot.</source>
          <target state="translated">영구 정보는 업데이트되지 않으므로 이러한 기능은 내장 또는 포함되지 않은 Erlang 노드에서 사용할 수 있습니다. 또한이 기능을 사용해도 재부팅이있는 경우로드되는 코드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05eb06aea519cecedac753c3c3fc222e914de94b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis and no warnings were emitted.</source>
          <target state="translated">분석 중에 문제가 발견되지 않았으며 경고가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c647cf715eac6879d4c3134da30ff7c15996866b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis, but warnings were emitted.</source>
          <target state="translated">분석 중에 문제가 발견되지 않았지만 경고가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="bd4d5686ec105c4061bf6d87bd047c5882b61b8e" translate="yes" xml:space="preserve">
          <source>No separate (variable) packages are generated. Applications that are found underneath a variable directory are ignored.</source>
          <target state="translated">별도의 (가변) 패키지가 생성되지 않습니다. 변수 디렉토리 아래에있는 응용 프로그램은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2645af938c8d0d4b9ae8e002cf483a4d95efd04" translate="yes" xml:space="preserve">
          <source>No source code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">소스 코드가 없습니다. 소스 코드와 객체 코드는 같은 디렉토리에 있거나 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 위치하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c80de0efbf261d9e095f902e0f2d665fd88ad9d3" translate="yes" xml:space="preserve">
          <source>No space is left on the device.</source>
          <target state="translated">장치에 공간이 남아 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db50afb4ab4c477aba8edc312545bbe5ac56992b" translate="yes" xml:space="preserve">
          <source>No such file or directory, or directory already exists, or permission denied.</source>
          <target state="translated">해당 파일이나 디렉토리 또는 디렉토리가 이미 없거나 권한이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="861215d646ab11b3c7364a81ae9819205bd22341" translate="yes" xml:space="preserve">
          <source>No such type.</source>
          <target state="translated">그런 유형은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f3f7a13db71f33cfa022de055c35c8dce0c2f17" translate="yes" xml:space="preserve">
          <source>No syntax rule definitions or other declarations may follow this section. To avoid conflicts with internal variables, do not use variable names beginning with two underscore characters ('__') in the Erlang code in this section, or in the code associated with the individual syntax rules.</source>
          <target state="translated">이 섹션 뒤에는 구문 규칙 정의 나 다른 선언이있을 수 없습니다. 내부 변수와의 충돌을 피하려면이 섹션의 Erlang 코드 또는 개별 구문 규칙과 관련된 코드에서 두 개의 밑줄 문자 ( '__')로 시작하는 변수 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="56bd79ad5b51fb7729ca3566ff1b2fd96321741b" translate="yes" xml:space="preserve">
          <source>No trace outputs. This is the default.</source>
          <target state="translated">추적 출력이 없습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1bcae2b67b6703a4dda088ac83adf2fa3c139258" translate="yes" xml:space="preserve">
          <source>No true branch is found when evaluating an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현식을 평가할 때 실제 분기가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eda586f9e6ba047d97471f1bf9867a4ab7b5c6e7" translate="yes" xml:space="preserve">
          <source>No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT CA, which is a self-signed certificate. Trust can be claimed for an intermediate CA (trusted anchor does not have to be self-signed according to X-509) by using option &lt;code&gt;partial_chain&lt;/code&gt;.</source>
          <target state="translated">신뢰할 수있는 저장소에 신뢰할 수있는 CA가 없습니다. 트러스트 된 CA는 일반적으로 자체 서명 된 인증서 인 ROOT CA입니다. &lt;code&gt;partial_chain&lt;/code&gt; 옵션을 사용하여 중간 CA에 대한 신뢰를 청구 할 수 있습니다 (신뢰할 수있는 앵커는 X-509에 따라 자체 서명 할 필요가 없습니다) .</target>
        </trans-unit>
        <trans-unit id="51620f6ec27898e6c0fbd64ab1461dbab02323bd" translate="yes" xml:space="preserve">
          <source>No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt;.</source>
          <target state="translated">키를 조회하여 가능한 모든 답변을 찾을 수있는 방법을 찾지 못했지만 필터를 일치 사양으로 변환 할 수 있습니다. 모든 답변은 &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt; 을 호출하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c13c8fd7aa90de3fb8911bcf7fa43f2889a260" translate="yes" xml:space="preserve">
          <source>Node name of remote node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">원격 노드의 노드 이름. &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="777c88d4603f4203bbb592ad1459cf50c6255ac4" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">이 노드의 노드 이름. &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9eae106cd79565d2506dacd99d934bb27987eb1e" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">이 노드의 노드 이름. &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4609ded8720acb4a14254c4923dd53fe7c48e94" translate="yes" xml:space="preserve">
          <source>Node name, &lt;code&gt;node&lt;/code&gt;</source>
          <target state="translated">노드 이름, &lt;code&gt;node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07577846f355b02783c690185edc121991468e96" translate="yes" xml:space="preserve">
          <source>Node table entries that are not referred linger in the table for at least the amount of time that this parameter determines. The lingering prevents repeated deletions and insertions in the tables from occurring.</source>
          <target state="translated">이 매개 변수가 결정하는 시간 동안 테이블에서 참조되지 않는 노드 테이블 항목. 시간이 오래 걸리면 테이블에서 삭제 및 삽입이 반복되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="609dd2f5616d5def969c38a398d805318ea1a788" translate="yes" xml:space="preserve">
          <source>Nodes can be added to and removed from a &lt;code&gt;Mnesia&lt;/code&gt; system. This can be done by adding a copy of the schema to those nodes.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 시스템에 노드를 추가하거나 제거 할 수 있습니다 . 이는 해당 노드에 스키마 사본을 추가하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6747accaf683f772944ea14fe4c794ccba9b86a1" translate="yes" xml:space="preserve">
          <source>Nodes connected through hidden connections can be monitored as any other nodes.</source>
          <target state="translated">숨겨진 연결을 통해 연결된 노드는 다른 노드로 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e6879915cbf13a3b60e8d7f1f912973f81167b" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through hidden connections.</source>
          <target state="translated">숨겨진 연결을 통해이 노드에 연결된 노드</target>
        </trans-unit>
        <trans-unit id="cc5d70b541f8501e9d01ec3e0e4e3fde1b4be2ae" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through normal connections.</source>
          <target state="translated">정상 연결을 통해이 노드에 연결된 노드</target>
        </trans-unit>
        <trans-unit id="57c1df2289899b41768f671fc1b5ee2f1c0b48d9" translate="yes" xml:space="preserve">
          <source>Nodes from which communicated peers are made available in the remote candidates list of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">&lt;code&gt;pick_peer/4&lt;/code&gt; 콜백 의 원격 후보 목록에서 통신 피어를 사용할 수있는 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="506bf95685aeda7d65c4825675264344d9902300" translate="yes" xml:space="preserve">
          <source>Nodes that are known to this node. That is, connected nodes and nodes referred to by process identifiers, port identifiers, and references located on this node. The set of known nodes is garbage collected. Notice that this garbage collection can be delayed. For more information, see &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 노드에 알려진 노드 즉, 연결된 노드와 노드는이 노드에있는 프로세스 식별자, 포트 식별자 및 참조로 참조됩니다. 알려진 노드 세트는 가비지 수집됩니다. 이 가비지 수집이 지연 될 수 있습니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7afefd4eb39dfd1fda9f65fc8df0dedddd2ab71e" translate="yes" xml:space="preserve">
          <source>Nodes to which peer connections established on the local Erlang node are communicated. Shared peers become available in the remote candidates list passed to &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks on remote nodes whose services are configured to use them: see &lt;code&gt;use_shared_peers&lt;/code&gt; below.</source>
          <target state="translated">로컬 Erlang 노드에서 피어 연결이 설정된 노드가 통신됩니다. 공유 피어 는 서비스를 사용하도록 구성된 원격 노드의 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 전달 된 원격 후보 목록 에서 사용할 수 있습니다 ( 아래의 &lt;code&gt;use_shared_peers&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="9ad3afeccc2c07ec40ffda2f6fe1a23dce971210" translate="yes" xml:space="preserve">
          <source>Nodes with an ERTS version earlier than 5.7.2 does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS 5.7.2 이전 버전의 노드는 분배 헤더를 사용하는 분배 플래그를 전달하지 않습니다. 이 경우 노드간에 전달 된 메시지는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8d28e8cb93663f40b3e02d5f32274b7bcf92428c" translate="yes" xml:space="preserve">
          <source>Nodes with disc database schema must be defined and implemented with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디스크 데이터베이스 스키마가있는 노드는 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 정의하고 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b1284ec6c573e51f2ee9f680fc573581c6be9d1" translate="yes" xml:space="preserve">
          <source>Noise has a high level as opposed to essentials.</source>
          <target state="translated">소음은 기본과는 반대로 높은 수준입니다.</target>
        </trans-unit>
        <trans-unit id="a72b2ae853945e5b8956182bbfb749378e193bfd" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt;. It returns the tuple &lt;code&gt;{value, Val}&lt;/code&gt; when the computation is finished, or &lt;code&gt;timeout&lt;/code&gt; when &lt;code&gt;Timeout&lt;/code&gt; milliseconds has elapsed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전 . 계산이 완료되면 튜플 &lt;code&gt;{value, Val}&lt;/code&gt; 반환 하거나 &lt;code&gt;timeout&lt;/code&gt; &lt;code&gt;Timeout&lt;/code&gt; 밀리 초가 경과 하면 제한 시간을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5f87b67027ba8d1bf675b11281146e26fb2801e6" translate="yes" xml:space="preserve">
          <source>Non-break space</source>
          <target state="translated">휴식 공간</target>
        </trans-unit>
        <trans-unit id="1ea42666026a195787b7284149d9b03550517a0d" translate="yes" xml:space="preserve">
          <source>Non-portable hash function that only guarantees the same hash for the same term within one Erlang VM instance.</source>
          <target state="translated">하나의 Erlang VM 인스턴스 내에서 동일한 용어에 대해 동일한 해시 만 보장하는 이식 불가능한 해시 기능.</target>
        </trans-unit>
        <trans-unit id="234a623f6ba9a7ff287ed003837119c0295841fe" translate="yes" xml:space="preserve">
          <source>Non-spacing mark</source>
          <target state="translated">비 간격 마크</target>
        </trans-unit>
        <trans-unit id="26b2867ce328c59018c79a884756714da802589b" translate="yes" xml:space="preserve">
          <source>NonCompositeTerm ::= term() (not list or tuple or map)</source>
          <target state="translated">NonCompositeTerm :: = term () (목록 또는 튜플 또는 맵이 아님)</target>
        </trans-unit>
        <trans-unit id="4c6ddabca28c82e409457c62e73c0bb7ebc8fa48" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler) -&amp;gt;</source>
          <target state="translated">NonLocalFunctionHandler)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="18ebf28795ec5199819d1e5ac39fe97c6224fefd" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler,</source>
          <target state="translated">NonLocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="d6ae77cee906d18da7aaf78a7c7ab33073d61cbe" translate="yes" xml:space="preserve">
          <source>None, but the version number was increased anyway.</source>
          <target state="translated">그러나 버전 번호는 어쨌든 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="cc969dc2084d0c57d3c3f18672b1cb587110032f" translate="yes" xml:space="preserve">
          <source>Normal Windows NT installation is performed. No additional application programs are needed, such as Internet Explorer or web server. Networking with TCP/IP is required.</source>
          <target state="translated">정상적인 Windows NT 설치가 수행됩니다. Internet Explorer 또는 웹 서버와 같은 추가 응용 프로그램이 필요하지 않습니다. TCP / IP와의 네트워킹이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e00a61616c0ebb576daec9ce3da5c44b01d68c1a" translate="yes" xml:space="preserve">
          <source>Normal locking requires the following:</source>
          <target state="translated">일반 잠금에는 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c968deef42bc269fc435a9f4d346232704145288" translate="yes" xml:space="preserve">
          <source>Normal mode, in which text lines can be edited and sent to the shell.</source>
          <target state="translated">텍스트 모드를 편집하여 쉘로 보낼 수있는 일반 모드.</target>
        </trans-unit>
        <trans-unit id="c72d62413b1b0e473e04d83afe069f0e8f1245a9" translate="yes" xml:space="preserve">
          <source>Normal schedulers will have scheduler identifiers in the range &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;. Dirty CPU schedulers will have scheduler identifiers in the range &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 스케줄러는 &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자를 갖습니다 . 더티 CPU 스케줄러는 &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; 범위의 스케줄러 식별자를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="63856520df5f6e7c2b81ba0324073ec61c706fa4" translate="yes" xml:space="preserve">
          <source>Normal-form XML elements can thus be included in the simple-form representation. Note that content lists must be flat. An &lt;code&gt;IOString&lt;/code&gt; is a (possibly deep) list of characters and/or binaries.</source>
          <target state="translated">따라서 일반 양식 XML 요소는 단순 양식 표현에 포함될 수 있습니다. 컨텐츠 목록은 단순해야합니다. &lt;code&gt;IOString&lt;/code&gt; 는 문자 및 / 또는 바이너리 (아마도 깊이) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a74e793a642e0b2e3ac1ab81016078fc7282ff3d" translate="yes" xml:space="preserve">
          <source>Normalizes an issuer name so that it can be easily compared to another issuer name.</source>
          <target state="translated">다른 발급자 이름과 쉽게 비교할 수 있도록 발급자 이름을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="123bb07c3020981f40b2d515466fa01c393f5d17" translate="yes" xml:space="preserve">
          <source>Normally a Media Gateway (MG) connects explicitly while a Media Gateway Controller (MGC) connects implicitly.</source>
          <target state="translated">일반적으로 MG (Media Gateway)는 명시 적으로 연결되는 반면 MMG (Media Gateway Controller)는 암시 적으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="62b21d6a5acaba334f3b92e5191990bacc474890" translate="yes" xml:space="preserve">
          <source>Normally a driver instance has no port data lock. If the driver instance wants to use a port data lock, it must create the port data lock by calling &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 드라이버 인스턴스에는 포트 데이터 잠금이 없습니다. 드라이버 인스턴스가 포트 데이터 잠금을 사용하려면 &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt; 를 호출하여 포트 데이터 잠금을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c68be6d33361ec0e77716005c64c0f636bd81f1e" translate="yes" xml:space="preserve">
          <source>Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the &lt;code&gt;verify_fun&lt;/code&gt;. Examples are &lt;code&gt;unknown_ca&lt;/code&gt; and &lt;code&gt;selfsigned_peer.&lt;/code&gt;</source>
          <target state="translated">일반적으로 신뢰할 수있는 인증서이지만이 함수에 대한 입력을 구성하는 동안 발견 될 수 있고 &lt;code&gt;verify_fun&lt;/code&gt; 을 통해 실행되는 경로 유효성 검증 오류 일 수도 있습니다 . 예는 &lt;code&gt;unknown_ca&lt;/code&gt; 및 &lt;code&gt;selfsigned_peer.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c1e2b2f12271535c195bd263adbd772fd1b1450" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added</source>
          <target state="translated">일반적으로 RSA, DSA 또는 ECDSA 공개 키이지만 다른 공개 키 처리를 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="32e8583c2f35a0fb6147ddcbc88cc5b16ce06fba" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">일반적으로 RSA, DSA 또는 ECDSA 공개 키이지만 다른 공개 키 처리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a323154df5db7c6023a4765a91c3d178bc3620d" translate="yes" xml:space="preserve">
          <source>Normally an allocator creates a &quot;main multiblock carrier&quot;. Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 할당자는 &quot;주 멀티 블록 캐리어&quot;를 만듭니다. 메인 멀티 블록 캐리어는 할당 해제되지 않습니다. 주 &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt; 블록 캐리어의 크기는 파라미터 mmbcs 의 값에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4c50780b89a61508f82bc073504b8cf437882c" translate="yes" xml:space="preserve">
          <source>Normally in the range &lt;code&gt;-15..-8 | 8..15&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;-15..-8 | 8..15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3591546de23ffebac17f3c960ad1cc664b2e7e" translate="yes" xml:space="preserve">
          <source>Normally it is the programmer's responsibility to free each Erlang term that has been returned from any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions. However, as many of the functions that build new Erlang terms in fact share objects with other existing terms, it can be difficult for the programmer to maintain pointers to all such terms to free them individually.</source>
          <target state="translated">일반적으로 &lt;code&gt;Erl_Interface&lt;/code&gt; 함수 에서 반환 된 각 Erlang 용어를 해제하는 것은 프로그래머의 책임 입니다. 그러나 실제로 새로운 Erlang 용어를 작성하는 많은 함수가 다른 기존 용어와 객체를 공유하므로 프로그래머가 이러한 모든 용어에 대한 포인터를 유지하여 개별적으로 해제하는 것이 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1516500c60371d958d26c4174d5a863989b039fb" translate="yes" xml:space="preserve">
          <source>Normally the compiler treats calls to &lt;code&gt;is_record/2&lt;/code&gt; especially. It emits code to verify that &lt;code&gt;Term&lt;/code&gt; is a tuple, that its first element is &lt;code&gt;RecordTag&lt;/code&gt;, and that the size is correct. However, if &lt;code&gt;RecordTag&lt;/code&gt; is not a literal atom, the BIF &lt;code&gt;is_record/2&lt;/code&gt; is called instead and the size of the tuple is not verified.</source>
          <target state="translated">일반적으로 컴파일러는 특히 &lt;code&gt;is_record/2&lt;/code&gt; 에 대한 호출을 처리합니다 . &lt;code&gt;Term&lt;/code&gt; 이 터플이고 첫 번째 요소가 &lt;code&gt;RecordTag&lt;/code&gt; 이고 크기가 올바른지 확인하는 코드를 생성 합니다. 그러나 &lt;code&gt;RecordTag&lt;/code&gt; 가 리터럴 아톰이 아닌 경우 BIF &lt;code&gt;is_record/2&lt;/code&gt; 가 대신 호출되고 튜플의 크기가 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1a7de4987b858f3cc368eec0c0c2caaad58778" translate="yes" xml:space="preserve">
          <source>Normally the compiler verifies that the module name given in the source code is the same as the base name of the output file and refuses to generate an output file if there is a mismatch. If you have a good reason (or other reason) for having a module name unrelated to the name of the output file, this option disables that verification (there will not even be a warning if there is a mismatch).</source>
          <target state="translated">일반적으로 컴파일러는 소스 코드에 지정된 모듈 이름이 출력 파일의 기본 이름과 동일한 지 확인하고 일치하지 않는 경우 출력 파일 생성을 거부합니다. 출력 파일 이름과 관련이없는 모듈 이름을 갖는 적절한 이유 (또는 다른 이유)가있는 경우이 옵션은 해당 검증을 비활성화합니다 (일치하지 않는 경우 경고도 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="c85cefd516f432dd52d61776ad47ad9e932cefa9" translate="yes" xml:space="preserve">
          <source>Normally the top directory of an application is located in library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt; or in a directory referred to by environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. At startup, when the initial code path is computed, the code server also looks for archive files in these directories and possibly adds &lt;code&gt;ebin&lt;/code&gt; directories in archives to the code path. The code path then contains paths to directories that look like &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; or &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">일반적으로 애플리케이션의 최상위 디렉토리는 라이브러리 디렉토리 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 또는 환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; 에 의해 참조되는 디렉토리에 있습니다 . 시작시 초기 코드 경로가 계산 될 때 코드 서버는 이러한 디렉토리에서 아카이브 파일을 찾고 아카이브의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리를 코드 경로에 추가 할 수도 있습니다 . 그런 다음 코드 경로에는 &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; 또는 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; 과 같은 디렉토리 경로가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="16dc8854601f473350bd4444afad1c3e95d0bfe6" translate="yes" xml:space="preserve">
          <source>Normally these are minimal stub implementations that throw an exception. But they can also be used as fallback implementations for functions that do not have native implemenations on some architectures.</source>
          <target state="translated">일반적으로 이들은 예외를 발생시키는 최소한의 스텁 구현입니다. 그러나 일부 아키텍처에서는 기본 구현이없는 함수에 대한 대체 구현으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e199a9abb107c5708b3c551b3f4ac7d6bc7e25" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Loaded&lt;/code&gt; is the absolute filename &lt;code&gt;Filename&lt;/code&gt; from which the code is obtained. If the module is preloaded (see &lt;code&gt;script(4)&lt;/code&gt;), &lt;code&gt;Loaded==preloaded&lt;/code&gt;. If the module is Cover-compiled (see &lt;code&gt;cover(3)&lt;/code&gt;), &lt;code&gt;Loaded==cover_compiled&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;Loaded&lt;/code&gt; 는 코드를 얻는 절대 파일 &lt;code&gt;Filename&lt;/code&gt; 파일 이름 입니다. 모듈은 프리로드되는 경우 (참조 &lt;code&gt;script(4)&lt;/code&gt; ) &lt;code&gt;Loaded==preloaded&lt;/code&gt; . 모듈이 Cover-compiled ( &lt;code&gt;cover(3)&lt;/code&gt; 참조 )이면 &lt;code&gt;Loaded==cover_compiled&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5203fe540eb93014569c65ea374e32f208fcdb8" translate="yes" xml:space="preserve">
          <source>Normally, after a pending message has been received, the request is not resent (since a pending message is an indication that the request has been received). But since the reply (to the request) can be lost, this behaviour has its values.</source>
          <target state="translated">일반적으로 보류중인 메시지가 수신 된 후에는 요청이 재전송되지 않습니다 (대기중인 메시지는 요청이 수신되었다는 표시이므로). 그러나 (요청에 대한) 응답을 잃을 수 있으므로이 동작에는 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b537284cd04df03d36bf92033e8259f158494ca4" translate="yes" xml:space="preserve">
          <source>Normally, connections are established automatically when another node is referenced. This functionality can be disabled by setting Kernel configuration parameter &lt;code&gt;dist_auto_connect&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt;, see &lt;code&gt;kernel(6)&lt;/code&gt;. In this case, connections must be established explicitly by calling &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 다른 노드를 참조하면 연결이 자동으로 설정됩니다. 이 기능은 커널 구성 매개 변수 &lt;code&gt;dist_auto_connect&lt;/code&gt; 를 &lt;code&gt;never&lt;/code&gt; 로 설정하여 비활성화 할 수 있습니다 &lt;code&gt;kernel(6)&lt;/code&gt; 참조 ) . 이 경우 &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 연결을 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="637694f595e135bf986d734041974495ca2f7d71" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;code&gt;/etc/ssh&lt;/code&gt; directory is only readable by root.</source>
          <target state="translated">일반적으로 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉토리는 루트 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c133a4bf588437e7a024274a632985a8eb26b1b7" translate="yes" xml:space="preserve">
          <source>Normally, the functions described above behave exactly as shown, but they are free to perform other actions. For example, a get-request may have side effects such as setting some other variable, perhaps a global &lt;code&gt;lastAccessed&lt;/code&gt; variable.</source>
          <target state="translated">일반적으로 위에서 설명한 기능은 표시된대로 정확하게 작동하지만 다른 작업을 자유롭게 수행 할 수 있습니다. 예를 들어, get-request는 글로벌 &lt;code&gt;lastAccessed&lt;/code&gt; 변수 와 같은 다른 변수 설정과 같은 부작용이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="544ca2481d30ca25eb88bc4478419d207c6b42f3" translate="yes" xml:space="preserve">
          <source>Normally, there is no need to worry about the speed of &lt;code&gt;length/1&lt;/code&gt;, because it is efficiently implemented in C. In time-critical code, you might want to avoid it if the input list could potentially be very long.</source>
          <target state="translated">일반적으로 &lt;code&gt;length/1&lt;/code&gt; 의 속도는 C로 효율적으로 구현되므로 걱정할 필요가 없습니다 . 시간이 중요한 코드에서는 입력 목록이 매우 길면 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="432c6c8cb64925afd6f974d52af838a844075bba" translate="yes" xml:space="preserve">
          <source>Normally, when an Erlang process sends to a socket, the driver tries to send the data immediately. If that fails, the driver uses any means available to queue up the message to be sent whenever the operating system says it can handle it. Setting &lt;code&gt;{delay_send, true}&lt;/code&gt; makes &lt;strong&gt;all&lt;/strong&gt; messages queue up. The messages sent to the network are then larger but fewer. The option affects the scheduling of send requests versus Erlang processes instead of changing any real property of the socket. The option is implementation-specific. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">일반적으로 Erlang 프로세스가 소켓으로 보내면 드라이버는 즉시 데이터를 보내려고합니다. 실패하면 드라이버는 운영 체제에서 메시지를 처리 ​​할 수 ​​있다고 표시 될 때마다 메시지를 큐에 대기시키는 데 사용할 수있는 수단을 사용합니다. &lt;code&gt;{delay_send, true}&lt;/code&gt; 설정 하면 &lt;strong&gt;모든&lt;/strong&gt; 메시지가 대기열에있게됩니다. 네트워크로 전송 된 메시지는 더 크지 만 더 적습니다. 이 옵션은 소켓의 실제 속성을 변경하는 대신 송신 요청과 Erlang 프로세스의 스케줄링에 영향을줍니다. 옵션은 구현에 따라 다릅니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fad0923dba8395d1d335b96e476819a3a071dc5" translate="yes" xml:space="preserve">
          <source>Normative References</source>
          <target state="translated">규범 참조</target>
        </trans-unit>
        <trans-unit id="4c829414eaf27118bfedf26c7e8237c300423db1" translate="yes" xml:space="preserve">
          <source>Not a &lt;code&gt;pid()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c737921363d7d8bbbfc2bf38000b57e386aed1b1" translate="yes" xml:space="preserve">
          <source>Not all functions are provided on all platforms. In particular, the &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; functions are not provided on Windows.</source>
          <target state="translated">모든 기능이 모든 플랫폼에서 제공되는 것은 아닙니다. 특히, &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; 기능은 Windows에서 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f60564ddfb74e83034e43211b6dc56c962f055f4" translate="yes" xml:space="preserve">
          <source>Not all systems send signals. For details on valid string values, see RFC 4254, Section 6.10</source>
          <target state="translated">모든 시스템이 신호를 보내는 것은 아닙니다. 유효한 문자열 값에 대한 자세한 내용은 RFC 4254, 섹션 6.10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a834a9b315fc2a330e09ba52fb9c66fcf454a31e" translate="yes" xml:space="preserve">
          <source>Not being able to control the application remotely</source>
          <target state="translated">애플리케이션을 원격으로 제어 할 수 없음</target>
        </trans-unit>
        <trans-unit id="1a46fcc227b8efe8fe76d1f3917346701207d128" translate="yes" xml:space="preserve">
          <source>Not built-in</source>
          <target state="translated">내장되지 않음</target>
        </trans-unit>
        <trans-unit id="e5c26cb1806bfcc16aba23e2bcd43b6fab4a7dce" translate="yes" xml:space="preserve">
          <source>Not enough memory to create the port.</source>
          <target state="translated">포트를 생성하기위한 메모리가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="5a93ba71c6009e894f071984d5a041fabb7da94e" translate="yes" xml:space="preserve">
          <source>Not enough space left to write the file.</source>
          <target state="translated">파일을 쓸 공간이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="b498326e15a92ae0d8b8c9b12f4c1b41ff6d4998" translate="yes" xml:space="preserve">
          <source>Not equal to</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="46885249352a064243a6dddeac62ab075a4dd8a5" translate="yes" xml:space="preserve">
          <source>Not recommended, as the machine will possibly be inaccessible to interactive users.</source>
          <target state="translated">대화 형 사용자가 머신에 액세스 할 수 없으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="943fa3c1c3bedd251cb678cfcff592882249becf" translate="yes" xml:space="preserve">
          <source>Not recommended; use &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">권장하지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a35d63cc7db198d75edb76a9f80fbc617cd6daa6" translate="yes" xml:space="preserve">
          <source>Not unexpectedly, we see that &lt;code&gt;file:write/2&lt;/code&gt; was called from &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; and &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. The number of calls in each case as well as the used time are also just confirms the previous results.</source>
          <target state="translated">예기치 않게, &lt;code&gt;file:write/2&lt;/code&gt; 가 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 및 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 에서 호출 된 것을 볼 수 있습니다 . 각 경우의 통화 횟수와 사용 시간도 이전 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fb48271e25bdfecded1918413e5015fa92ec99a7" translate="yes" xml:space="preserve">
          <source>Note again that a successfull decode only returns a partially initiated message.</source>
          <target state="translated">디코딩이 성공하면 부분적으로 시작된 메시지 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb5fcd3ca24d41d35ec2f21eaba5915f96c6ec6" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;Options&lt;/code&gt; argument comes from the &lt;code&gt;options&lt;/code&gt; config option of the mib-storage config option, and is passed on as is.</source>
          <target state="translated">있음을 유의하십시오 &lt;code&gt;Options&lt;/code&gt; 인수가에서 오는 &lt;code&gt;options&lt;/code&gt; 은 MIB 저장 설정 옵션의 옵션을 설정, 그리고 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0627636f71c6f80361b94f0198da347d52ca866f" translate="yes" xml:space="preserve">
          <source>Note also that the shared group leader (&lt;code&gt;SharedGL&lt;/code&gt;) must never be terminated by the user, only by Common Test. Group leader processes for parallel test case groups (&lt;code&gt;OtherGLs&lt;/code&gt;) may however be terminated in post_end_per_group hook functions.</source>
          <target state="translated">또한 공유 그룹 리더 ( &lt;code&gt;SharedGL&lt;/code&gt; )는 사용자가 공통 테스트를 통해서만 종료해서는 안됩니다. 그러나 병렬 테스트 케이스 그룹 ( &lt;code&gt;OtherGLs&lt;/code&gt; )의 그룹 리더 프로세스 는 post_end_per_group 후크 함수에서 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc2e031b8dd55503b20741805cebfb2cf07a730" translate="yes" xml:space="preserve">
          <source>Note cleanup time. When storing a note in the note store, each note is given lifetime. Every &lt;code&gt;timeout&lt;/code&gt; the note_store process performs a GC to remove the expired note's. Time in milli-seconds.</source>
          <target state="translated">정리 시간을 참고하십시오. 메모 저장소에 메모를 저장하면 각 메모에 수명이 주어집니다. 모든 &lt;code&gt;timeout&lt;/code&gt; note_store 프로세스가 행하는 GC가 만료 된 주의를 제거합니다. 밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ec5960d916e9578d7d801b0cab9fba678951306b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;LIMIT_MATCH&lt;/code&gt; and &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; can only reduce the value of the limits set by the caller, not increase them.</source>
          <target state="translated">참고 것을 &lt;code&gt;LIMIT_MATCH&lt;/code&gt; 및 &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; 는 단지 발신자가 설정 한 한계 값을 줄일 수를 증가하지.</target>
        </trans-unit>
        <trans-unit id="d24e50ca0ad0e8aeae5b135428467a7fb92766a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding SSL/TLS option, since funs are not accepted on the command line.</source>
          <target state="translated">참고 &lt;code&gt;verify_fun&lt;/code&gt; 의 funs입니다 명령 행에 허용되지 않기 때문에 요구는, 대응하는 SSL / TLS 옵션과는 다른 형태로 기록 될.</target>
        </trans-unit>
        <trans-unit id="1d1c85c3f2e3a52e04f26f9459fd07fac45960dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;watchdog&lt;/code&gt;, &lt;code&gt;peer&lt;/code&gt;, &lt;code&gt;apps&lt;/code&gt;, &lt;code&gt;caps&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; entries depend on connectivity with the peer and may not be present. Note also that the &lt;code&gt;statistics&lt;/code&gt; entry presents values accumulated during the lifetime of the transport configuration.</source>
          <target state="translated">참고 &lt;code&gt;watchdog&lt;/code&gt; , &lt;code&gt;peer&lt;/code&gt; , &lt;code&gt;apps&lt;/code&gt; , &lt;code&gt;caps&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 항목이 피어와의 연결에 의존되지 않을 수 있습니다. 또한 &lt;code&gt;statistics&lt;/code&gt; 항목은 전송 구성 수명 동안 누적 된 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="336af6e83620751fb885cf9732b59c5d61916d15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{error,encode}&lt;/code&gt; is the only return value which guarantees that the request has &lt;strong&gt;not&lt;/strong&gt; been sent over the transport connection.</source>
          <target state="translated">참고 것을 &lt;code&gt;{error,encode}&lt;/code&gt; 요청이 것을 보장하는 유일한 반환 값이 &lt;strong&gt;없습니다&lt;/strong&gt; 전송 연결을 통해 전송되어가.</target>
        </trans-unit>
        <trans-unit id="d0fdecc142de3ad70dcbabaed28cc8ece32529ae" translate="yes" xml:space="preserve">
          <source>Note that RFC 3588 did not allow 5xxx result codes in answers setting the E-bit, while RFC 6733 does. This is a potential interoperability problem since the Diameter protocol version has not changed.</source>
          <target state="translated">RFC 3588은 E- 비트 설정에 5xxx 결과 코드를 허용하지 않지만 RFC 6733은 응답하지 않습니다. Diameter 프로토콜 버전이 변경되지 않았기 때문에 잠재적 인 상호 운용성 문제입니다.</target>
        </trans-unit>
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">RFC 6733에서는 종단 간 식별자가 최소 4 분 동안 고유하게 유지되어야하며이 값과 호출 속도는 &lt;code&gt;N&lt;/code&gt; 의 적절한 값에 대해 하한을 설정 합니다. 초당 &lt;code&gt;R&lt;/code&gt; 요청 비율 , &lt;code&gt;N&lt;/code&gt; -bit 카운터는 모든 값을 &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; 분으로 통과 하므로 바운드는 &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">\ 0dd는 항상 8 진 코드이며 \ 8과 \ 9는 리터럴 문자 &quot;8&quot;과 &quot;9&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">사전 모듈은 시스템의 기존 모듈과 충돌하지 않도록 고유 한 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outdir&lt;/code&gt; 옵션 과 함께 사전의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 은 &lt;code&gt;return&lt;/code&gt; 옵션이 지정되지 않은 경우 출력 경로를 결정 합니다. 리터럴 입력 사전 의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 은 기본적으로 &lt;code&gt;dictionary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">epmd가 실행되고 있지 않으면 분산 노드가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">지정된 피어에 대한 단일 &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 이벤트는 기능 교환 중에 협상 된 각 Diameter 애플리케이션에 대해 하나씩 여러 개의 &lt;code&gt;peer_up/3&lt;/code&gt; 또는 &lt;code&gt;peer_down/3&lt;/code&gt; 콜백에 해당합니다. 즉,이 이벤트는 전체적으로 피어와의 연결을 통신하는 반면 콜백은 개별 Diameter 응용 프로그램과 관련하여 연결을 통신합니다.</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">공식적으로 상태 변경이 아니더라도 초기 상태로 들어가기 직전에 상태 입력 호출 &lt;strong&gt;이&lt;/strong&gt; 수행됩니다. 이 경우 &lt;code&gt;OldState&lt;/code&gt; 는 &lt;code&gt;State&lt;/code&gt; 와 동일하며 , 이는 후속 상태 변경에는 발생하지 않지만 상태 입력 호출을 반복 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">모든 처리는 호출 프로세스의 컨텍스트에서 수행됩니다. 전송 모듈은 &lt;code&gt;spawn&lt;/code&gt; 함수 (예 : &lt;code&gt;spawn_opt&lt;/code&gt; ) 중 하나를 통해이 함수를 호출 할 수 있습니다. &lt;code&gt;receive_message/4,5&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">SMIv2 MIB는 SMIv1 MIB를 가져올 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">alias-name은 mib 내에서만 고유하므로 여러 mib를 관리자에로드 할 때 동일한 aliasname의 인스턴스가 여러 개있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 에서와 같이 상태 호출이 있거나 알 수없는 이벤트를 처리 하는 경우 이벤트 시간 초과가 제대로 작동하지 않습니다. 모든 종류의 이벤트가 이벤트 시간 초과를 취소하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">V 플래그를 설정하는 상속 된 AVP 는 상속 사전의 &lt;code&gt;@vendor&lt;/code&gt; 또는 상속 된 사전의 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 에서 Vendor-Id를 가져 옵니다 . 특히 상속 된 사전의 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 는 무시됩니다. 필수 &lt;code&gt;@vendor&lt;/code&gt; 를 지정하는 사전에서 상속하는 것은 사전 정의 사본과 함께 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 를 사용하는 것과 동일 하지만 전자는 더 쉽게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cipher&lt;/code&gt; 두 목록 이 제공된 값 ( &lt;code&gt;'aes128-ctr'&lt;/code&gt; ) 으로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">기본 동작 다음에 나오는 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">client_random, server_random 및 master_secret은 연결 보안에 영향을주는 값입니다. 위에 지정되지 않은 의미있는 원자는 ssl 옵션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; 의 결과는 `x \ ny ',`x \ 12y',`x \ 012y '및`x \ ^ Jy \'를 모두 나타냅니다. &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">각 튜플은 하나 이상의 AVP 값을 전달합니다. 중복 튜플을 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">ec_gf2m은 공개 키 알고리즘은 아니지만 ecdsa 및 ecdh에서 지원되는 곡선에 대한 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 함수가 &lt;code&gt;none&lt;/code&gt; 이 아닌 일부 &lt;code&gt;Tail&lt;/code&gt; 을 반환하더라도 꼬리가 명시 적으로 제공되고 목록 골격이 압축되지 않은 경우 &lt;code&gt;Tail&lt;/code&gt; 유형은 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 에 &lt;code&gt;discovery&lt;/code&gt; 값 이 있으면 에이전트는 해당 관리자 와 의 &lt;strong&gt;감지&lt;/strong&gt; 프로세스를 수행 할 때까지 해당 관리자 &lt;code&gt;inform&lt;/code&gt; 메시지를 보낼 수 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">경우 참고 &lt;code&gt;udp&lt;/code&gt; 사용하는 경우, 동일한 전송 프로세스가 여러 연결에 사용될 수 있습니다. 업그레이드가 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">어떤 경우주의 &lt;code&gt;port&lt;/code&gt; 있는 경우 주어지지하고 &lt;code&gt;taddress&lt;/code&gt; 는 포트 번호를 포함하지 않는, 디폴트 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;tdomain&lt;/code&gt; 을 지정 하지 않으면 기본값 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">경우 생성합니다 &lt;code&gt;gen_statem&lt;/code&gt; 를 통해 시작 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; ,이 콜백이 호출되지 않습니다. 이 콜백은 선택 사항이 아니기 때문에 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">Version 인수가 &lt;code&gt;dynamic&lt;/code&gt; 인 경우 디코더는 메시지 자체에서 실제 버전을 파악한 다음 올바른 디코더 (예 : 버전 1)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">본문이 작 으면 모든 데이터가 하나의 청크로만 전달 될 수 있으며 &lt;code&gt;{first, Data::binary()}&lt;/code&gt; 호출되지 않고 {last, Data :: binary (), undefined}로 콜백이 호출됩니다. .</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">중요로 표시된 확장에 대해 fun이 &lt;code&gt;unknown&lt;/code&gt; 을 반환 하면 유효성 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">옵션 &lt;code&gt;warnings&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 옵션 세부 &lt;code&gt;verbosity&lt;/code&gt; 가 &lt;code&gt;silence&lt;/code&gt; 이면 경고 메시지가 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">응답이 분할 된 경우 (여러 개의 작은 메시지, 세그먼트로 분할) 응답의 모든 세그먼트가 수신되었는지 여부에 대한 추가 정보, 세그먼트 번호 및 표시도 &lt;code&gt;UserReply&lt;/code&gt; 에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">Erlang에서 시간 종료 부분이 지정되지 않은 경우 receive-expression에 하나 이상의 절이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">대부분의 TCP 구현에서 &lt;code&gt;close&lt;/code&gt; 수행한다고해서 닫기가 원격 측에서 감지되기 ​​전에 전송 된 모든 데이터가 수신자에게 전달되는 것은 아닙니다. 수신자에게 데이터가 전달되도록하려면 두 가지 일반적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">reltool이 애플리케이션 버전을 정렬하여 최신 버전을 선택할 수 있으려면 애플리케이션의 버전 ID가 정수 및 점 (예 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2.0&lt;/code&gt; 또는 &lt;code&gt;3.17.1&lt;/code&gt; )으로 만 구성되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">목록의 정수는 전달 된 &lt;code&gt;InEncoding&lt;/code&gt; 에 관계없이 항상 코드 포인트를 나타냅니다 . 경우 &lt;code&gt;InEncoding latin1&lt;/code&gt; 전달 만 코드 포인트 &amp;lt;256 사용할 수 있습니다; 그렇지 않으면 유효한 모든 유니 코드 코드 포인트가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">위 의 &lt;code&gt;lazy_gen/1&lt;/code&gt; 함수 와 같은 help 함수를 사용하여 이러한 종류의 재귀 생성기를 작성하는 것이 가장 쉽습니다 . 함수 네임 스페이스를 어지럽히 지 않고 그러한 종류의 코드를 작성하는 데 익숙하다면 재귀 적 인 재미를 사용하여 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">이 타임 아웃은 다른 이벤트에 의해 자동으로 취소되므로이 타임 아웃을 취소 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">이 함수 는 업데이트 된 &lt;code&gt;Targets&lt;/code&gt; 목록 ( &lt;code&gt;NewTargets&lt;/code&gt; ) 을 반환하여 대상을 필터링 할 수 있지만 ( 자체를 추가 하지는 &lt;strong&gt;않음&lt;/strong&gt; ) 가능합니다.</target>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">실행중인 서버가 필요한 기능에 의해 자동으로 시작되므로 명시 적으로 시작하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">백업이 가능한 경우 구현에 따라 (mib-storage에 따라 달라짐) 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;module&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 와 같은 예약 된 속성 이름 인지 여부는 확인되지 않습니다 . 속성이 &quot;wild&quot;인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">이 기능의 영향을받는 전역 추적 패턴은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">구성 기능 또는 테스트 케이스를 실행하는 프로세스는 &lt;code&gt;TestProcs&lt;/code&gt; 에 포함되지 않습니다 . 따라서 사후 구성 후크 기능 (예 : post_end_per_suite, post_end_per_group, post_end_per_testcase)을 사용 하여 현재 그룹 리더 프로세스를 그룹 리더로하는 &lt;code&gt;TestProcs&lt;/code&gt; 의 모든 프로세스를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">원시 파일 이름 은 반드시 OS 수준에서와 같은 방식으로 인코딩 될 필요는 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">텍스트의 특수 문자 (&amp;lt;,&amp;gt; 및 &amp;amp;)는 텍스트가 로그 파일에 인쇄되기 전에 공통 테스트에 의해 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">있습니다 &lt;code&gt;RecordName&lt;/code&gt; 및 &lt;code&gt;Fields&lt;/code&gt; 인수 (그들은 실제로 단지 mnesia 기반 구현에 필요한) 모든 구현에 사용되는 나의.</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 것을 &lt;code&gt;erl_parse&lt;/code&gt; 표현 &quot;에 대한 동일 &lt;code&gt;FunctionType&lt;/code&gt; '과' &lt;code&gt;fun(FunctionType)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;strong&gt;종파&lt;/strong&gt; 곡선 GF2m (특징 2 개)의 곡선이고 단지 기본 OpenSSL에 그들에 대한 지원이 경우 지원된다. &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">문제의 AVP는 다른 사전에 다르게 정의 된 열거에 추가 값을 도입하기 위해 상속 된 사전에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">이 AVP의 CCF는 RFC 3588과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">실제로 지원되는 dss_digest_type은 기본 암호화 라이브러리에 따라 다릅니다. OpenSSL 버전&amp;gt; = 1.0.1에서는 나열된 다이제스트가 지원되는 반면 1.0.0에서는 sha, sha224 및 sha256 만 지원됩니다. 버전 0.9.8에서는 sha 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">추가 된 알고리즘은 원래 위치에서 제거 된 다음 동일한 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">출력물의 중요성 만 지정하기 위해 category 인수는 필요하지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">클라이언트는 순서를 자유롭게 사용하고 메소드를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">컴파일러는 원자를 멀리 최적화 할 수 있습니다. 예를 들어, 컴파일러는 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 을 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 으로 다시 작성 합니다. 해당 표현식이 포함 모듈에서 원자 &lt;code&gt;some_atom&lt;/code&gt; 에 대한 유일한 언급 인 경우, 모듈이로드 될 때 원자가 작성되지 않으며 &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; 대한 후속 호출 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">컴파일러는 원자를 멀리 최적화 할 수 있습니다. 예를 들어, 컴파일러는 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 을 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 으로 다시 작성 합니다. 해당 표현식이 포함 모듈에서 원자 &lt;code&gt;some_atom&lt;/code&gt; 에 대한 유일한 언급 인 경우, 모듈이로드 될 때 원자가 작성되지 않으며, &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; 에 대한 후속 호출 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">가져온 (로드 된) mib에서 추출 된 데이터는 mib-server에 의해 부분적으로 그리고 symbolic-store 서버에 의해 부분적으로 저장됩니다. 자세한 내용은 기본 mib-server 데이터 모듈 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">이벤트 &lt;code&gt;$s | $S&lt;/code&gt; , &lt;code&gt;l | $L&lt;/code&gt; 및 &lt;code&gt;$z | $Z&lt;/code&gt; 는 같은 문자를 사용하는 타이머와 아무 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">기존 &lt;code&gt;.beam&lt;/code&gt; 파일에는 &lt;strong&gt;추상 코드&lt;/strong&gt; 가 포함되어야합니다 . 즉, &lt;code&gt;debug_info&lt;/code&gt; 옵션 으로 컴파일해야합니다 . 그렇지 않으면 오류 이유 &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; 이 리턴됩니다. 추상 코드가 암호화되어 있고이를 해독 할 수있는 키가 없으면 오류 이유 &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">다음이 항상로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">함수는이 항목이 이미 존재하는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">생성 된 인증서 및 키는 공식적으로 올바른 PKIX-trust-chain을 제공하지 않으며 실제 보안을 달성하는 데 사용할 수 없습니다. 이 기능은 테스트 목적으로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">내부 데이터베이스는 컴파일 중에 (재) 시작됩니다. 즉, 모듈에 대해 이전에 수집 된 적용 범위 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">네트워크 인터페이스 필터는 애플리케이션 ( &lt;code&gt;snmpa_net_if&lt;/code&gt; )이 제공하는 네트워크 인터페이스 구현에서 사용되는 필터입니다 . 기본 필터는 모든 메시지를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">네트워크 인터페이스 필터는 애플리케이션에서 제공하는 네트워크 인터페이스 구현 ( &lt;code&gt;snmpm_net_if&lt;/code&gt; 및 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; )에서 사용되는 필터입니다 . 기본 필터는 모든 메시지를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">실제로 이런 방식으로 에이전트를 시작하는 유일한 방법은 응용 프로그램을 시작한 후 에이전트 관련 구성을 추가하는 것입니다 (예 : 일반 응용 프로그램 구성의 일부일 수 없음 : sys.config). &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">실제로 이런 방식으로 관리자를 시작하는 유일한 방법은 응용 프로그램을 시작한 후 관리자 관련 구성을 추가하는 것입니다 (예 : 일반 응용 프로그램 구성의 일부가 될 수 없음 : sys.config). &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">리스트에서 튜플의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">이 함수를 호출하는 프로세스는 영구적 &lt;strong&gt;이어야&lt;/strong&gt; 합니다. 죽으면 포트가 종료되고 드라이버가 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">이 기능을 사용 하면 요청 특정 매개 변수 (예 : &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; )에 인스 트루먼 테이션 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">이 기능을 사용 하면 요청 특정 매개 변수 (예 : &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; ) 에 계측 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">세그먼트는 원래 요청을 발행하는 데 사용되는 기능에 따라 사용자에게 다르게 전달됩니다. &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 요청을 발행 할 때 세그먼트는 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 콜백 함수 를 통해 사용자 에게 도착할 때 한 번에 하나씩 전달됩니다 . 그러나 이것은 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 기능 에는 효과가 없습니다 . 이 경우 세그먼트가 누적 된 다음 함수가 반환 될 때 한 번에 모두 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">SSL 응용 프로그램은 TLS에 필요하며 직경 전송에서 TLS 기능을 구성하기 전에 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">언급되지 않은 목록 ( &lt;code&gt;public_key&lt;/code&gt; , &lt;code&gt;cipher&lt;/code&gt; , &lt;code&gt;mac&lt;/code&gt; 및 &lt;code&gt;compression&lt;/code&gt; )은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">에이전트가 여러 EngineID를 &quot;에뮬레이션&quot;하는 경우 LocalEngineID 인수 사용은 특수한 경우에만 사용됩니다. 기본적으로 에이전트는 &lt;code&gt;SnmpEngineID&lt;/code&gt; 값을 사용합니다 (SNMP-FRAMEWORK-MIB 참조).</target>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">&lt;code&gt;transport&lt;/code&gt; 정보 와 달리 &lt;code&gt;ref&lt;/code&gt; 가 동일한 항목이 여러 개있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">연결 당 정확히 하나의 분배 제어기가 있어야합니다. 프로세스 또는 포트는 하나의 연결에 대해서만 분배 제어기 일 수 있습니다. 배포 컨트롤러로 등록을 취소 할 수 없습니다. 분배 컨트롤러가 종료 될 때까지 고정됩니다. 분배 제어기는 종료 신호를 무시해서는 안됩니다. 엑시트를 트랩 할 수 있지만 엑시트 신호가 수신되면 자발적으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">이 함수는 인스 트루먼 테이션 함수 가 에이전트 프로세스의 컨텍스트에서 실행 된 경우 &lt;strong&gt;에만&lt;/strong&gt; 호출하도록되어 있습니다 (예 : 스폰 된 프로세스에서 호출 된 경우 작동하지 않음).</target>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">이 검사는로드되거나 사용시로드되는 응용 프로그램 버전을 사용합니다. 시스템에 설치된 모든 종속성을 만족시키는 응용 프로그램 버전이있을 수 있지만로드되지 않은 경우이 확인이 실패합니다. 물론 이와 같이 사용하면 시스템이 실패합니다. 시스템에 동일한 응용 프로그램의 여러 &lt;code&gt;branched versions&lt;/code&gt; 이 설치되어 있지만 올바른 응용 프로그램 버전을 나타내는 &lt;code&gt;boot script&lt;/code&gt; 사용하지 않는 경우에 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">이것은 스택에 의해 자발적으로 전송 된 메시지에는 영향을 미치지 않습니다. 연결 정보의 protocol_version을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">이 기능은 master-agent 프로세스의 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">사용자가 설정 한 경우이 함수가 불려가는 것은 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; 의 에 설정 옵션 &lt;code&gt;true&lt;/code&gt; &lt;strong&gt;하고&lt;/strong&gt; 그것을 실제로 메시지 재전송입니다. 이 &lt;strong&gt;두&lt;/strong&gt; 조건이 모두 충족 되지 않으면 &lt;code&gt;send_message&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">이는 보류중인 트랜잭션의 실제 전송에는 영향을 미치지 않습니다. 이는 암시 적이거나 (예 : 처리중인 요청에 대한 재전송 트랜잭션 요청을 수신 할 때) pending_timer에 의해 제어됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">이는 구성 파일에 의해 정의 된 응용 프로그램 구성에 영향을 미치지 않으므로 노드를 다시 시작하면 구성이 해당 파일에있는 구성으로 되돌려집니다.</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">이 식별자는 때때로 &quot;이름&quot;이라고 불립니다. 가능한 한 &quot;식별자&quot;또는 &quot;id&quot;라는 용어가 사용되었지만 이전 버전과의 호환성을 유지하기 위해 오류 메시지에서 &quot;name&quot;이라는 일부 항목이 여전히 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">이는 단일 recv 호출에서 수신 할 수있는 최대 데이터 양이기도합니다. 일반 MTU보다 높은 값을 사용하는 경우 버퍼를 높게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">이것은 유틸리티 함수일뿐입니다. 주어진 문자열을 공백으로 분리 된 단어로 분리하고 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 요소 목록을 포함하는 적절한 들여 쓰기 로 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 를 설정하는 모든 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">업데이트해야 할 불완전한 파일 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">&lt;code&gt;sent_pending_limit&lt;/code&gt; 구성 옵션이 정수 값으로 설정된 경우에만 지정된대로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">이 전체 모듈은 실험적이며 기능뿐만 아니라 사용 된 표현도 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">항상 기본 사용자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">트랜잭션 ID는 (현재) 사용자 단위로 유지되므로 반환 된 값이이 연결을 통해 전송 된 트랜잭션에 실제로 사용되는지 확인할 방법이 없습니다 (사용자가 여러 연결을 가지고있는 경우). 모두 가능하지 않음).</target>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에서이 작업을 사용하면 이 서버 의 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출이 없었기 때문에 마법의 경계에서 이상하게 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">모듈을 컴파일 할 때 가져온 데이터를 포함하여 &lt;strong&gt;기존의 모든 커버리지 데이터가 제거됩니다&lt;/strong&gt; . 데이터를 가져올 때 모듈이 이미 컴파일 된 경우 가져온 데이터는 기존 적용 범위 데이터에 &lt;strong&gt;추가&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">입력 할 데이터의 값이 문자열 인 경우 &lt;code&gt;'&lt;/code&gt; 로 인용해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">에서 문서마다 참고 &lt;code&gt;Docs&lt;/code&gt; 줄 바꿈을 포함, 그것은 별도의 줄에 배치됩니다. 따라서 다음과 같은 레이아웃은</target>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">더티 I / O 스케줄러에서 실행되는 작업은 주로 I / O를 기다릴 것으로 예상됩니다. 즉, 더티 I / O 스케줄러에서 스케줄러 활용도가 높으면이 작업으로 인해 CPU 사용량이 &lt;strong&gt;높지 않을&lt;/strong&gt; 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">크로스 컴파일 구성 파일에는 임의의 변수를 정의 할 수 없습니다. 모든 &lt;code&gt;configure&lt;/code&gt; 스크립트를 전체적으로 실행할 때 아래에 나열된 것만 표시됩니다 . 환경에서 &lt;code&gt;configure&lt;/code&gt; 하거나 내보내 려면 다른 변수를 인수로 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">Windows에서 무언가를 빌드하기 전에 특정 쉘에서 &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; 를 실행해야합니다 . make opt를 수행 한 후 &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; 을 실행하여 결과를 테스트 할 수 있습니다 . 결과를 릴리스 디렉토리 (예 : &lt;code&gt;/tmp/erl_release&lt;/code&gt; ) 에 복사하려면 이 작업을 수행하십시오 (여전히 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">이 작업을 수행 할 때는 경로에 새로운 Erlang이 있어야하며, 이전 단계에서 작성한 일반 21이 바람직합니다. 특정 라이브러리를 다시 빌드하기 전에 &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; 을 &lt;code&gt;PATH&lt;/code&gt; 에 추가 할 수도 있습니다 . 그러면 OTP Erlang 코드를 컴파일하기에 충분한 Erlang 시스템이 제공됩니다. 경로를 올바르게 설정하는 것은 약간 까다 롭습니다. 당신은 여전히이 필요 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; &lt;strong&gt;전에&lt;/strong&gt; 경로의 실제 에뮬레이터. 부트 스트랩 컴파일러를 사용하기위한 일반적인 경로 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">최신 파일을 나타내는 방법으로 &lt;code&gt;run_erl&lt;/code&gt; 은 가장 오래된 로그 파일을 삭제하여 파일 시퀀스에서 &quot;구멍&quot;을 유지합니다. 예를 들어, 로그 파일 # 1, # 2, # 4 및 # 5가 존재하면 # 2가 최신이고 # 4가 가장 오래된 것을 의미합니다. 따라서 &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; 에 의해 설정된 값보다 최대 하나 적은 로그 파일을 얻게 됩니다.</target>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 사용 하여 결과를 반환 할 수 있다는 점에 유의하십시오 . 예를 들어 &lt;code&gt;State&lt;/code&gt; 또는 &lt;code&gt;Data&lt;/code&gt; 가 더 이상 범위에 없기 때문에 &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 를 반환 할 수없는 복잡한 코드 내에서 &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; 를 사용하여 구제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">이 옵션은 일반적인 TLS 사용에는 필요하지 않으며 새 클라이언트를 구현하는 데 사용해서는 안됩니다. 그러나 다음과 같은 방식으로 연결을 재 시도하는 레거시 클라이언트</target>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">참고 : &lt;code&gt;arity_qualifier&lt;/code&gt; 노드가 인식됩니다. 와일드 속성에 관해서는 Erlang Parser를 따르는 것입니다 : {F, A} 및 F / A가 모두 인식되므로 와일드 속성을 인식 된 속성으로 바꾸는 동시에 동시에 파일을 컴파일 할 수 없습니다. 이전 버전의 Erlang Compiler의 새로운 구문.</target>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">참고 : 현재 구체적으로 표현 된 구문 트리 세트는 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 빌드 할 수있는 트리 세트보다 큽니다 . 추상 문자는 정수로 이해되는 반면 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 은 현재 입력에 대한 추상 문자를 생성하지 않습니다. (사용 &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; 명시 적 추상 문자를 작성하는 기능입니다.)</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">참고 : 일부 문서의 경우 &lt;code&gt;Docs&lt;/code&gt; 줄 바꿈을 포함, 수직 레이아웃이 항상 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">참고 : 파일을 병합 할 때 &quot;구문 오류&quot;메시지가 표시되고 해당 파일이 올바른지 알고있는 경우 &lt;code&gt;preprocess&lt;/code&gt; 옵션 을 사용해보십시오 . 일반적으로 코드에 프리 프로세서 확장을 실제로 수행하지 않고 처리하기에는 너무 이상한 매크로가 포함되어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 는 구문 트리이므로 하위 트리에 해당하는 실제 런타임 값을 부분적으로 또는 완전히 알 수없는 경우가 있습니다. 따라서, 경우에 &lt;code&gt;Node&lt;/code&gt; 나타내는 예 : &quot; &lt;code&gt;[... | Ns]&lt;/code&gt; &quot;(여기서 &lt;code&gt;Ns&lt;/code&gt; 를가 변수입니다), 다음 함수가 반환 &lt;code&gt;false&lt;/code&gt; 여부가 알려져 있지 않기 때문에, &lt;code&gt;Ns&lt;/code&gt; 를이 실행시 목록에 바인딩됩니다. 경우 &lt;code&gt;Node&lt;/code&gt; 대신 &quot;예를 나타낸다 &lt;code&gt;[1, 2, 3]&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;[A | []]&lt;/code&gt; &quot;다음 함수는 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">참고 : Erlang 언어에는 고유 한 1- 튜플이 있습니다. 즉 &lt;code&gt;{X}&lt;/code&gt; 는 항상 &lt;code&gt;X&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">참고 : 동적 코드 교체 시맨틱을 깨뜨리지 않으려면 &quot;정적&quot;모듈과 &quot;안전한&quot;모듈을 구분해야합니다. &quot;정적&quot;소스 모듈은 대상 모듈이 아닌 한 교체되지 않습니다. 이제 각 상태에 대한 코드를 별도의 모듈에 배치하여 구현 된 상태 머신을 상상하고 모든 소스 모듈을 정적으로 표시하여 단일 대상 모듈에 병합한다고 가정합니다. 모듈 중 하나에서 다른 모듈로 (즉, 상태 전이) 호출이 이루어지는 원래 코드의 각 지점에서 코드 교체가 감지 될 것으로 예상됩니다. 그런 다음 병합 된 코드에서 &lt;strong&gt;대상&lt;/strong&gt; 이 이러한 지점에서 확인하지 않으면&lt;strong&gt;&lt;/strong&gt;모듈 (병합 결과)이 교체되었으므로 일반적으로 병합 된 상태 머신의 코드 교체를 수행 할 수 있는지 확신 할 수 없습니다. 코드 변경을 감지하지 않고 영원히 실행될 수 있습니다. 따라서 이러한 모든 호출은 원격 호출 (코드 변경 감지)으로 유지되어야하지만 대상 모듈을 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">참고 : 전 처리기 매크로 정의 지시문 &quot; &lt;code&gt;-define(Name, Body).&lt;/code&gt; &quot;는 &lt;code&gt;Body&lt;/code&gt; 의 구문 형식에 대한 요구 사항이 비교적 적습니다 (토큰 순서로 표시). &lt;code&gt;text&lt;/code&gt; 노드 유형은 사용할 수 있습니다 &lt;code&gt;Body&lt;/code&gt; 정상 얼랑 구조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">참고 : 노드 유형의 기본 생성자 함수는 항상 노드 유형 자체와 이름이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이는 &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
