<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d32435d41ff7d589ba94cc7995cb7739a9bc6203" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the agent when the &lt;code&gt;&lt;a href=&quot;snmpa#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="translated">이 함수가 반환 한 &lt;code&gt;&lt;a href=&quot;snmpa#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; 는 info 함수가 호출 될 때 ( &lt;code&gt;net_if&lt;/code&gt; 키로 태그가 지정됨 ) 에이전트가 수집 한 다른 정보와 함께 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fdae2e67074ae99c5bacfc96a607916bd07f0" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the manager when the &lt;code&gt;&lt;a href=&quot;snmpm#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="translated">이 함수가 반환 한 &lt;code&gt;&lt;a href=&quot;snmpm#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; 는 info 함수가 호출 될 때 ( &lt;code&gt;net_if&lt;/code&gt; 키로 태그가 지정됨 ) 관리자가 수집 한 다른 정보와 함께 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4969c27d9e2b93f6c0c9f0dd0ae52939b796209" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. The implementation provided by this application provides info about memory allocation and various socket information.</source>
          <target state="translated">반환 된 정보는 기본적으로 구현자가 결정해야합니다. 이 응용 프로그램에서 제공하는 구현은 메모리 할당 및 다양한 소켓 정보에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b94457081093b8de25115749fb7f0e65291a036f" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. This implementation provided by the application provides info about memory allocation and various socket information.</source>
          <target state="translated">반환 된 정보는 기본적으로 구현자가 결정해야합니다. 응용 프로그램에서 제공하는이 구현은 메모리 할당 및 다양한 소켓 정보에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8953da75c34f8aaee4e44739d4a4db94876e2705" translate="yes" xml:space="preserve">
          <source>The information about MIB Views for VACM should be stored in a file called &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">VACM의 MIB보기에 대한 정보는 &lt;code&gt;vacm.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a593d35263cd423914377045097ffa123820496" translate="yes" xml:space="preserve">
          <source>The information about Notify Definitions should be stored in a file called &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">통지 정의에 대한 정보는 &lt;code&gt;notify.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db26f39dea524ffb501a0d56ccb46e2ba20ceda2" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the agent is configured for SNMPv3.</source>
          <target state="translated">USM의 보안 데이터에 대한 정보는 &lt;code&gt;usm.conf&lt;/code&gt; 파일에 저장 해야하며 에이전트가 SNMPv3에 대해 구성된 경우 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="307e4d8639265e2a32ea9ca56343b6ede5418d77" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the manager wishes to use SNMPv3 when communicating with agents. It is also possible to add usm data in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_usm_user&quot;&gt;register_usm_user&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">USM의 보안 데이터에 대한 정보는 &lt;code&gt;usm.conf&lt;/code&gt; 파일에 저장해야합니다.이 파일 은 관리자가 에이전트와 통신 할 때 SNMPv3을 사용하려는 경우 존재해야합니다. &lt;code&gt;&lt;a href=&quot;snmpm#register_usm_user&quot;&gt;register_usm_user&lt;/a&gt;&lt;/code&gt; 를 호출하여 런타임에 usm 데이터를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba12704a027dbf1ed0fe4c7e9af52e49cba83222" translate="yes" xml:space="preserve">
          <source>The information about Target Address Definitions should be stored in a file called &lt;code&gt;target_addr.conf&lt;/code&gt;.</source>
          <target state="translated">대상 주소 정의에 대한 정보는 &lt;code&gt;target_addr.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a40d6040ee67551c129f61fc60a30d2acba9667f" translate="yes" xml:space="preserve">
          <source>The information about Target Parameters Definitions should be stored in a file called &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">대상 매개 변수 정의에 대한 정보는 &lt;code&gt;target_params.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3aa4d245e100d97d0412e925606bc4810d337eae" translate="yes" xml:space="preserve">
          <source>The information about the new application specifications is fetched from the boot script included in the release package. Thus, it is important that the boot script is generated from the same &lt;code&gt;.rel&lt;/code&gt; file as is used to build the release package itself.</source>
          <target state="translated">새 응용 프로그램 사양에 대한 정보는 릴리스 패키지에 포함 된 부팅 스크립트에서 가져옵니다. 따라서 릴리스 패키지 자체를 빌드하는 데 사용되는 것과 동일한 &lt;code&gt;.rel&lt;/code&gt; 파일 에서 부팅 스크립트를 생성하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="391611f6929211ce72507251e567123fcf0c63db" translate="yes" xml:space="preserve">
          <source>The information from the analysis is displayed in the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window.</source>
          <target state="translated">분석 정보가 &lt;strong&gt;로그&lt;/strong&gt; 창과 &lt;strong&gt;경고&lt;/strong&gt; 창에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="14c6d60f6fb1b8c358808ee0563e8e58bb01c1ed" translate="yes" xml:space="preserve">
          <source>The information from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; is removed from the PLT. Notice that this can cause a reanalysis of the remaining dependent files.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일의 정보 가 PLT에서 제거됩니다. 이로 인해 나머지 종속 파일이 재분석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a417a84c4c7c4decb79621743a9dd3565ee6be" translate="yes" xml:space="preserve">
          <source>The information function &lt;code&gt;init/end_per_suite()&lt;/code&gt; is called for &lt;code&gt;init/end_per_suite(Config)&lt;/code&gt;, and information function &lt;code&gt;init/end_per_group(GroupName)&lt;/code&gt; is called for &lt;code&gt;init/end_per_group(GroupName,Config)&lt;/code&gt;. However, information functions cannot be used with &lt;code&gt;init/end_per_testcase(TestCase, Config)&lt;/code&gt;, as these configuration functions execute on the test case process and use the same properties as the test case (that is, the properties set by the test case information function, &lt;code&gt;TestCase()&lt;/code&gt;). For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정보 함수 &lt;code&gt;init/end_per_suite()&lt;/code&gt; 가 &lt;code&gt;init/end_per_suite(Config)&lt;/code&gt; 대해 호출 되고 정보 함수 &lt;code&gt;init/end_per_group(GroupName)&lt;/code&gt; 이 &lt;code&gt;init/end_per_group(GroupName,Config)&lt;/code&gt; 대해 호출됩니다 . 그러나 정보 기능은 &lt;code&gt;init/end_per_testcase(TestCase, Config)&lt;/code&gt; 와 함께 사용할 수 없습니다. 이러한 구성 함수는 테스트 케이스 프로세스에서 실행되고 테스트 케이스와 동일한 특성 (즉, 테스트 케이스 정보 함수에 의해 설정된 특성, &lt;code&gt;TestCase()&lt;/code&gt; ). 유효한 정보 특성 및보다 일반적인 정보의 목록은 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="580ee4de3515f41920aad05c4796ca8a83145041" translate="yes" xml:space="preserve">
          <source>The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables, it is not certain that the information is absolutely accurate.</source>
          <target state="translated">이 정보는 QLC가 발생할 가능성이 가장 높은 Erlang 표현식 형식입니다. 언급 된 QLC 테이블의 형식 함수에 따라 정보가 절대적으로 정확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="305d9bd7c8803717b9892f1b41b37ab6f87fe9d8" translate="yes" xml:space="preserve">
          <source>The information needed to handle agents should be stored in a file called &lt;code&gt;agents.conf&lt;/code&gt;. It is also possible to add agents in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_agent&quot;&gt;register_agent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에이전트를 처리하는 데 필요한 정보는 &lt;code&gt;agents.conf&lt;/code&gt; 파일에 저장해야합니다 . &lt;code&gt;&lt;a href=&quot;snmpm#register_agent&quot;&gt;register_agent&lt;/a&gt;&lt;/code&gt; 를 호출하여 런타임에 에이전트를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c58f25be105f880c4313e388829ec4c71197bfd3" translate="yes" xml:space="preserve">
          <source>The information presented here is as in the &lt;code&gt;connect&lt;/code&gt; case except that the client connections are grouped under an &lt;code&gt;accept&lt;/code&gt; tuple.</source>
          <target state="translated">여기에 제시된 정보는 클라이언트 연결이 &lt;code&gt;accept&lt;/code&gt; 튜플 아래에 그룹화된다는 점을 제외하고 는 &lt;code&gt;connect&lt;/code&gt; 사례와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3c59dd2aeba1c3a9f59f5d5103b732b653592744" translate="yes" xml:space="preserve">
          <source>The information returned by the current invocation of function &lt;code&gt;info/1&lt;/code&gt; is gathered from the disk log process running on &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;info/1&lt;/code&gt; 함수의 현재 호출에 의해 리턴 된 정보는 &lt;code&gt;Node&lt;/code&gt; 에서 실행중인 디스크 로그 프로세스에서 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="384d84cf094e7d37c004a133a85246195c3cf123" translate="yes" xml:space="preserve">
          <source>The information shown in a detail window can contain links to processes or ports. Clicking one of these links opens the detail window for the process or port in question. If the process or port resides on a remote node, no information is available. Clicking the link then displays a dialog where you can choose to open the detail window for the remote node.</source>
          <target state="translated">세부 사항 창에 표시된 정보에는 프로세스 또는 포트에 대한 링크가 포함될 수 있습니다. 이 링크 중 하나를 클릭하면 해당 프로세스 또는 포트에 대한 세부 사항 창이 열립니다. 프로세스 또는 포트가 원격 노드에 있으면 정보를 사용할 수 없습니다. 링크를 클릭하면 원격 노드의 세부 사항 창을 열 수있는 대화 상자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="49a50cd6647973c69a1bf7b4354e70d711a6ebe4" translate="yes" xml:space="preserve">
          <source>The init process evaluates &lt;code&gt;apply(Mod, Func, Args)&lt;/code&gt;. The system terminates if this results in an error. The boot procedure hangs if this function never returns.</source>
          <target state="translated">초기화 프로세스는 &lt;code&gt;apply(Mod, Func, Args)&lt;/code&gt; 평가 합니다 . 오류가 발생하면 시스템이 종료됩니다. 이 기능이 반환되지 않으면 부팅 절차가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="70767c9929b242def2046198ed888e89eaa4092e" translate="yes" xml:space="preserve">
          <source>The initial Erlang shell does not read user input until the system boot procedure has been completed (Erlang/OTP 5.4 and later). This flag disables the start synchronization feature and lets the shell start in parallel with the rest of the system.</source>
          <target state="translated">초기 Erlang 쉘은 시스템 부팅 절차가 완료 될 때까지 (Erlang / OTP 5.4 이상) 사용자 입력을 읽지 않습니다. 이 플래그는 동기화 시작 기능을 비활성화하고 쉘이 나머지 시스템과 동시에 시작되도록합니다.</target>
        </trans-unit>
        <trans-unit id="736895f627174e578045de3e4408955d43bc90d8" translate="yes" xml:space="preserve">
          <source>The initial configuration of the Megaco should be defined in the Erlang system configuration file. The following configured parameters are defined for the Megaco application:</source>
          <target state="translated">Megaco의 초기 구성은 Erlang 시스템 구성 파일에서 정의해야합니다. 다음 구성 매개 변수가 Megaco 애플리케이션에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d81e5c16ade0725185a698be4a1277d1047896" translate="yes" xml:space="preserve">
          <source>The initial default values are set when creating an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">초기 기본값은 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 만들 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="555d7eb44ef4a30035e00a3ca666e72b873a31f0" translate="yes" xml:space="preserve">
          <source>The initial goal is to trace file I/O operations.</source>
          <target state="translated">초기 목표는 파일 I / O 작업을 추적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f43375679765975926ed43276d2e3e97141d5efc" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt;logger_level&lt;/a&gt;&lt;/code&gt;. It is changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt;logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 초기 값은 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt;logger_level&lt;/a&gt;&lt;/code&gt; 에 의해 설정됩니다 . 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt;logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="be84bb7f590bd193861c25c169900eba0112bb1a" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;. During runtime, primary filters are added and removed with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">이 옵션의 초기 값은 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 에 의해 설정됩니다 . 런타임 동안 기본 필터는 각각 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 추가 및 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b46dedd594f319e350068f1193c873d34aee425" translate="yes" xml:space="preserve">
          <source>The initial values for fields are to be compatible with (that is, a member of) the corresponding types. This is checked by the compiler and results in a compilation error if a violation is detected.</source>
          <target state="translated">필드의 초기 값은 해당 유형과 호환 가능해야합니다 (즉, 멤버). 이는 컴파일러에 의해 확인되며 위반이 감지되면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b8dd5640afe4eb44c50f0dc55a49ff96c25b7ecf" translate="yes" xml:space="preserve">
          <source>The initial values for the managed objects defined in these tables, are read at start-up from a set of configuration files. These are described in &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 테이블에 정의 된 관리 대상 객체의 초기 값은 시작시 구성 파일 세트에서 읽습니다. 이것들은 &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc56027c40e88b952495c29f19f297d464ec0de" translate="yes" xml:space="preserve">
          <source>The initial working directory of the Erlang emulator. Defaults to the system directory.</source>
          <target state="translated">Erlang 에뮬레이터의 초기 작업 디렉토리. 시스템 디렉토리가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bbe26b329d2acb042c7bfd92ae3556c450f2a952" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;State&lt;/code&gt; is the last returned &lt;code&gt;State&lt;/code&gt;, in it the callback can include any data that it needs to keep track of when handling the chunks.</source>
          <target state="translated">입력 &lt;code&gt;State&lt;/code&gt; 는 마지막으로 반환 된 &lt;code&gt;State&lt;/code&gt; 이며, 콜백에는 청크를 처리 할 때 추적해야하는 모든 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab1d9b79595ee9a80512a32c4f00246f558b37e" translate="yes" xml:space="preserve">
          <source>The input argument is passed from &lt;code&gt;Common Test&lt;/code&gt;, as defined in the test specification, or specified as an option to &lt;code&gt;ct_run&lt;/code&gt; or &lt;code&gt;ct:run_test&lt;/code&gt;.</source>
          <target state="translated">입력 인수는 테스트 스펙에 정의 된대로 &lt;code&gt;Common Test&lt;/code&gt; 에서 전달 되거나 &lt;code&gt;ct_run&lt;/code&gt; 또는 &lt;code&gt;ct:run_test&lt;/code&gt; 옵션으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b8a4a85bbd859e117dae9edd6f4ddaeebc656ee" translate="yes" xml:space="preserve">
          <source>The input characters. If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of whether the I/O device supports Unicode).</source>
          <target state="translated">입력 문자 I / O 장치가 유니 코드를 지원하는 경우 데이터는&amp;gt; 255 ( &lt;code&gt;latin1&lt;/code&gt; 범위)를 나타낼 수 있습니다 . I / O 서버가 바이너리를 전달하도록 설정된 경우 I / O 장치가 유니 코드를 지원하는지 여부에 관계없이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9a54dcf56c159353e0ace601f3572dfb662f8a6c" translate="yes" xml:space="preserve">
          <source>The input file is expected to be assembler code (default file suffix &quot;.S&quot;). Notice that the format of assembler files is not documented, and can change between releases.</source>
          <target state="translated">입력 파일은 어셈블러 코드 (기본 파일 접미사 &quot;.S&quot;) 여야합니다. 어셈블러 파일의 형식은 문서화되어 있지 않으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="401c0d476b7d6af409b8af21342fa3b0e4602412" translate="yes" xml:space="preserve">
          <source>The input file is expected to be core code (default file suffix &quot;.core&quot;). Notice that the format of core files is not documented, and can change between releases.</source>
          <target state="translated">입력 파일은 코어 코드 (기본 파일 접미사 &quot;.core&quot;) 여야합니다. 코어 파일의 형식은 문서화되어 있지 않으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f68ee0fd471148681af709e832d148fec4d81211" translate="yes" xml:space="preserve">
          <source>The input is changed into a list of integers and sent to the driver.</source>
          <target state="translated">입력이 정수 목록으로 변경되어 드라이버로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="895f0498a8445706072f6a486a101f535049625a" translate="yes" xml:space="preserve">
          <source>The input is complete. The result is one of the following:</source>
          <target state="translated">입력이 완료되었습니다. 결과는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4ee231fcc37d80538054d899a6aa444060d44d7f" translate="yes" xml:space="preserve">
          <source>The installation directory of Erlang/OTP, &lt;code&gt;$ROOT&lt;/code&gt;:</source>
          <target state="translated">Erlang / OTP, &lt;code&gt;$ROOT&lt;/code&gt; 의 설치 디렉토리 :</target>
        </trans-unit>
        <trans-unit id="b211abaa6268b0cb1eb68387738a79dd87d7b54d" translate="yes" xml:space="preserve">
          <source>The installation of a new release can restart the system. Which program to use is specified by the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, which defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;.</source>
          <target state="translated">새 릴리스를 설치하면 시스템을 다시 시작할 수 있습니다. 사용할 프로그램은 SASL 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 에 의해 지정되며 기본값은 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6426a93a1ac8fd4371599a87da39ac5721577a7" translate="yes" xml:space="preserve">
          <source>The installation procedure is automated. Double-click the &lt;code&gt;.exe&lt;/code&gt; file icon and follow the instructions.</source>
          <target state="translated">설치 절차가 자동화되었습니다. &lt;code&gt;.exe&lt;/code&gt; 파일 아이콘을 두 번 클릭 하고 지시 사항을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="8df4540e0f132ae38a44f67dc8db64d1677a955e" translate="yes" xml:space="preserve">
          <source>The installation will be created in a location prefixed by &lt;code&gt;$DESTDIR&lt;/code&gt;. It can, however, not be run from there. It needs to be moved into the correct location before it can be run. If &lt;code&gt;DESTDIR&lt;/code&gt; have not been set but &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; has been set, &lt;code&gt;DESTDIR&lt;/code&gt; will be set to &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. Note that &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; in pre R13B04 was buggy and behaved as &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; (see below). There are lots of areas of use for an installation procedure using &lt;code&gt;DESTDIR&lt;/code&gt;, e.g. when creating a package, cross compiling, etc. Here is an example where the installation should be located under &lt;code&gt;/opt/local&lt;/code&gt;:</source>
          <target state="translated">설치는 &lt;code&gt;$DESTDIR&lt;/code&gt; 접두사가있는 위치에 작성됩니다 . 그러나 거기에서 실행할 수는 없습니다. 실행하기 전에 올바른 위치로 이동해야합니다. 경우 &lt;code&gt;DESTDIR&lt;/code&gt; 이 설정되어 있지하지만 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 이 설정을하고있다, &lt;code&gt;DESTDIR&lt;/code&gt; 이 설정됩니다 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; . 참고 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 사전에 R13B04은 버이고대로 동작 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; (아래 참조). 패키지 작성, 교차 컴파일 등과 같이 &lt;code&gt;DESTDIR&lt;/code&gt; 을 사용하여 설치 절차에 사용되는 영역이 많이 있습니다 . 다음은 설치가 &lt;code&gt;/opt/local&lt;/code&gt; 아래에 있어야하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fc927e07960f46bc214f273ddf993919105c4192" translate="yes" xml:space="preserve">
          <source>The instruction loads the module and is necessary when running Erlang in embedded mode. It is not strictly required when running Erlang in interactive (default) mode, since the code server then automatically searches for and loads unloaded modules.</source>
          <target state="translated">명령은 모듈을로드하며 내장 모드에서 Erlang을 실행할 때 필요합니다. 코드 서버는 언로드 된 모듈을 자동으로 검색하고로드하기 때문에 대화식 (기본) 모드에서 Erlang을 실행할 때 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ad8974dbde3476a5985cc107445f129c6aef0af" translate="yes" xml:space="preserve">
          <source>The instruction must be a valid Erlang term ended by a dot.</source>
          <target state="translated">명령은 점으로 끝나는 유효한 Erlang 용어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0d51d691ce36ba72ff972c51e18b40a26c5a340a" translate="yes" xml:space="preserve">
          <source>The instruction, and thus the &lt;code&gt;.appup&lt;/code&gt; file, when changing an existing child specification, is the same as when changing properties as described earlier:</source>
          <target state="translated">기존 하위 스펙을 변경할 때 지시 사항 및 &lt;code&gt;.appup&lt;/code&gt; 파일은 앞에서 설명한 특성을 변경할 때와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a5573a2cd0a733b9336e3b438f659165c812e003" translate="yes" xml:space="preserve">
          <source>The instructions apply to versions of Windows supporting the Cygwin emulated gnuish environment or the MSYS or MSYS2 ditto. We&amp;rsquo;ve built on the following platforms: Windows 2012, Windows 7, Windows 8 and Windows 10. It&amp;rsquo;s probably possible to build on older platforms too, but you might not be able to install the appropriate Microsoft SDK, Visual Studio or OpenSSL, in which case you will need to go back to earlier compilers etc.</source>
          <target state="translated">이 지시 사항은 Cygwin 에뮬레이트 된 gnuish 환경 또는 MSYS 또는 MSYS2 ditto를 지원하는 Windows 버전에 적용됩니다. Windows 2012, Windows 7, Windows 8 및 Windows 10 플랫폼을 기반으로 구축되었습니다. 이전 플랫폼에서도 구축 할 수 있지만 적절한 Microsoft SDK, Visual Studio 또는 OpenSSL을 설치하지 못할 수도 있습니다. 어떤 경우에는 이전 컴파일러 등으로 돌아 가야합니다.</target>
        </trans-unit>
        <trans-unit id="3e507f2e1bdeb41dfac8c8cfdf517a26d52c4a6f" translate="yes" xml:space="preserve">
          <source>The integer of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">의 정수 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477d8b618ecfd772da7e539d868fb58baec9416c" translate="yes" xml:space="preserve">
          <source>The integers in all multibyte fields are in big-endian order.</source>
          <target state="translated">모든 멀티 바이트 필드의 정수는 빅 엔디안 순서입니다.</target>
        </trans-unit>
        <trans-unit id="8e32bedc7955d7223fe090b7e55010b6b9e5ac12" translate="yes" xml:space="preserve">
          <source>The intention of Trace Tool Builder is to serve as a base for tailor-made trace tools, but it can also be used directly from the Erlang shell (it can mimic &lt;code&gt;dbg&lt;/code&gt; behaviour while still providing useful additions, such as match specification shortcuts). Trace Tool Builder only allows the use of file port tracer, so to use other types of trace clients it is better to use &lt;code&gt;dbg&lt;/code&gt; directly.</source>
          <target state="translated">Trace Tool Builder의 목적은 맞춤형 추적 도구의 기반이되지만 Erlang 셸에서 직접 사용할 수도 있습니다 ( 일치 지정 바로 가기와 같은 유용한 추가 기능을 제공하면서 &lt;code&gt;dbg&lt;/code&gt; 동작을 모방 할 수 있음 ). Trace Tool Builder는 파일 포트 추적 프로그램 만 사용할 수 있으므로 다른 유형의 추적 클라이언트를 사용하려면 &lt;code&gt;dbg&lt;/code&gt; 를 직접 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cd559a381bf43260a8e8db813fe8999b82c7f1c0" translate="yes" xml:space="preserve">
          <source>The intention of the restart mechanism is to prevent a situation where a process repeatedly dies for the same reason, only to be restarted again.</source>
          <target state="translated">재시작 메커니즘의 목적은 프로세스가 동일한 이유로 반복적으로 종료되는 상황을 방지하고 다시 시작하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f04e21c615bcaa3bab7ffca923abd7b20f74b1c4" translate="yes" xml:space="preserve">
          <source>The interaction of option &lt;code&gt;global&lt;/code&gt; with a regular expression that matches an empty string surprises some users. When option &lt;code&gt;global&lt;/code&gt; is specified, &lt;code&gt;run/3&lt;/code&gt; handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt;. If that search gives a result of length &amp;gt; 0, the result is included. Example:</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 옵션 과 빈 문자열과 일치하는 정규식 의 상호 작용은 일부 사용자를 놀라게합니다. &lt;code&gt;global&lt;/code&gt; 옵션 이 지정되면 &lt;code&gt;run/3&lt;/code&gt; 은 Perl과 동일한 방식으로 빈 일치를 처리합니다. 모든 지점에서 길이가 0 인 일치도 &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; 옵션으로 재 시도됩니다 . 해당 검색 결과 길이가 0보다 큰 경우 결과가 포함됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="645847dee511adf6054272dd5554738165580583" translate="yes" xml:space="preserve">
          <source>The interactive Erlang shell, when started to a terminal or started using command &lt;code&gt;werl&lt;/code&gt; on Windows, can support Unicode input and output.</source>
          <target state="translated">대화식 Erlang 쉘은 터미널에서 시작하거나 Windows에서 &lt;code&gt;werl&lt;/code&gt; 명령을 사용하여 시작할 때 유니 코드 입력 및 출력을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85316f7b39c18cba3ed8c41e6e00aa4508657f73" translate="yes" xml:space="preserve">
          <source>The interface between the &lt;code&gt;Collector&lt;/code&gt; and its &lt;code&gt;Viewers&lt;/code&gt; is public in order to enable other types of &lt;code&gt;Viewers&lt;/code&gt;. However in the following text we will focus on usage of the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 &lt;code&gt;Viewers&lt;/code&gt; 를 사용하기 위해 &lt;code&gt;Collector&lt;/code&gt; 와 &lt;code&gt;Viewers&lt;/code&gt; 간의 인터페이스 는 공용입니다 . 그러나 다음 텍스트에서는 &lt;code&gt;et_viewer&lt;/code&gt; 사용법에 중점을 둘 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0d929ebaedeeb26c076c849c65d6a880fabbe836" translate="yes" xml:space="preserve">
          <source>The interface function &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, corresponding to the &lt;code&gt;ct_run&lt;/code&gt; program, is used for starting &lt;code&gt;Common Test&lt;/code&gt; from the Erlang shell (or an Erlang program). For details, see the &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 프로그램에 해당하는 인터페이스 함수 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 은 Erlang 쉘 (또는 Erlang 프로그램)에서 &lt;code&gt;Common Test&lt;/code&gt; 를 시작하는 데 사용됩니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8d5bf454a2abaa2d99599aa77da439bfb1b0e39" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link/1&lt;/code&gt; and &lt;code&gt;button/1&lt;/code&gt;) are located in the same module as the callback functions (&lt;code&gt;init/1&lt;/code&gt;, &lt;code&gt;locked/3&lt;/code&gt;, and &lt;code&gt;open/3&lt;/code&gt;). It is normally good programming practice to have the client-side code and the server-side code contained in one module.</source>
          <target state="translated">인터페이스 기능 ( &lt;code&gt;start_link/1&lt;/code&gt; 및 &lt;code&gt;button/1&lt;/code&gt; )은 콜백 기능 ( &lt;code&gt;init/1&lt;/code&gt; , &lt;code&gt;locked/3&lt;/code&gt; 및 &lt;code&gt;open/3&lt;/code&gt; ) 과 동일한 모듈에 있습니다. 일반적으로 클라이언트 측 코드와 서버 측 코드를 하나의 모듈에 포함시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3ffe36fe5fb02811ee7cbe99d87ab60dfaf7743" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt;, and &lt;code&gt;free&lt;/code&gt;) are then located in the same module as the callback functions (&lt;code&gt;init&lt;/code&gt;, &lt;code&gt;handle_call&lt;/code&gt;, and &lt;code&gt;handle_cast&lt;/code&gt;). This is normally good programming practice, to have the code corresponding to one process contained in one module.</source>
          <target state="translated">인터페이스 함수 ( &lt;code&gt;start_link&lt;/code&gt; , &lt;code&gt;alloc&lt;/code&gt; 및 &lt;code&gt;free&lt;/code&gt; )는 콜백 함수 ( &lt;code&gt;init&lt;/code&gt; , &lt;code&gt;handle_call&lt;/code&gt; 및 &lt;code&gt;handle_cast&lt;/code&gt; ) 와 동일한 모듈에 있습니다. 이것은 일반적으로 하나의 모듈에 포함 된 하나의 프로세스에 해당하는 코드를 갖는 좋은 프로그래밍 관행입니다.</target>
        </trans-unit>
        <trans-unit id="81df0f8bc6de0b4acea945c7c93ea405daa969a9" translate="yes" xml:space="preserve">
          <source>The interface of the filter function is the same as the the filter functions for the good old &lt;code&gt;lists:filtermap/2&lt;/code&gt;. If the filter returns &lt;code&gt;false&lt;/code&gt; it means that the trace data should silently be dropped. &lt;code&gt;true&lt;/code&gt; means that the trace data data already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;true&lt;/code&gt; means that the &lt;code&gt;TraceData&lt;/code&gt; already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;{true, NewEvent}&lt;/code&gt; means that the original trace data should be replaced with &lt;code&gt;Event&lt;/code&gt;. This provides means to get rid of unwanted &lt;code&gt;Events&lt;/code&gt; as well as enabling alternate views of an &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">필터 함수의 인터페이스는 이전 &lt;code&gt;lists:filtermap/2&lt;/code&gt; 대한 필터 함수와 동일합니다 . 필터가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 추적 데이터를 자동으로 삭제해야 함을 의미합니다. &lt;code&gt;true&lt;/code&gt; 는 추적 데이터 데이터가 이미 &lt;code&gt;Event Record&lt;/code&gt; 이며 그대로 유지되어야 함을 의미합니다. &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;TraceData&lt;/code&gt; 가 이미 &lt;code&gt;Event Record&lt;/code&gt; 이며 그대로 유지해야 함을 의미합니다. &lt;code&gt;{true, NewEvent}&lt;/code&gt; 는 원래 추적 데이터가 &lt;code&gt;Event&lt;/code&gt; 로 대체되어야 함을 의미합니다 . 이를 통해 원하지 않는 &lt;code&gt;Events&lt;/code&gt; 를 제거 하고 &lt;code&gt;Event&lt;/code&gt; 다른보기를 활성화 할 수 있습니다..</target>
        </trans-unit>
        <trans-unit id="631992b55633d87ae608966e2309f0f4727adc29" translate="yes" xml:space="preserve">
          <source>The interface supports two basic scenarios of loading and unloading. Each scenario can also have the option of either killing ports when the driver is unloading, or waiting for the ports to close themselves. The scenarios are as follows:</source>
          <target state="translated">이 인터페이스는로드 및 언로드의 두 가지 기본 시나리오를 지원합니다. 각 시나리오에는 드라이버가 언로드 될 때 포트를 종료하거나 포트가 닫힐 때까지 기다리는 옵션도 있습니다. 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6996c2e840da27c2e132b6627f75acd9d9d5a71" translate="yes" xml:space="preserve">
          <source>The intermediate stage for a connected socket. There is to be no processing of input for this socket.</source>
          <target state="translated">연결된 소켓의 중간 단계. 이 소켓에 대한 입력 처리가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a87821499f533dec180c9e450557e45ce8484c82" translate="yes" xml:space="preserve">
          <source>The internal events are as follows:</source>
          <target state="translated">내부 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c740abc33f39344410422e82491682fb38f4e44d" translate="yes" xml:space="preserve">
          <source>The internal index of the port.</source>
          <target state="translated">포트의 내부 색인</target>
        </trans-unit>
        <trans-unit id="965c55683139a0161e61ded48632af4d225cdd1d" translate="yes" xml:space="preserve">
          <source>The internal service name can be seen in the Windows service manager if viewing &lt;code&gt;Properties&lt;/code&gt; for an Erlang service.</source>
          <target state="translated">Erlang 서비스의 &lt;code&gt;Properties&lt;/code&gt; 을 볼 경우 Windows 서비스 관리자에서 내부 서비스 이름을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41156700bf653a3e0e4298bb097606750ea7e9b5" translate="yes" xml:space="preserve">
          <source>The interpretation in some detail for the three operators:</source>
          <target state="translated">세 연산자에 대한 자세한 해석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebf147e57bc82f05aaff52b7bfcaac8dbd9b6556" translate="yes" xml:space="preserve">
          <source>The interpretation is left as an exercise.</source>
          <target state="translated">해석은 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="1933de0224d21786fb43f077472bddf757fd1f65" translate="yes" xml:space="preserve">
          <source>The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol.</source>
          <target state="translated">URI의 해석은 사용 된 문자에만 의존하며 해당 문자가 네트워크 프로토콜로 표현되는 방식에는 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e3837ab6ca4df148db60d98c6975bec751a92b" translate="yes" xml:space="preserve">
          <source>The interpretation of constants and variables are sets, and those sets can be used as the basis for forming new sets by the application of  &lt;strong id=&quot;set_operator&quot;&gt;set operators&lt;/strong&gt;. The syntax:</source>
          <target state="translated">상수 및 변수의 해석은 세트이며, 이러한 세트는 &lt;strong id=&quot;set_operator&quot;&gt;세트 연산자를&lt;/strong&gt; 적용하여 새 세트를 형성하기위한 기초로 사용할 수 있습니다 . 문법 :</target>
        </trans-unit>
        <trans-unit id="e923c1f615d5158c088a332c75e5ac9dd307ac63" translate="yes" xml:space="preserve">
          <source>The interpretation of some LineOp operator applied to a set of function calls assigns to each call the set of line numbers where the first function calls the second function. Not all calls are assigned line numbers by all operators:</source>
          <target state="translated">함수 호출 세트에 적용된 일부 LineOp 연산자의 해석은 각 호출에 첫 번째 함수가 두 번째 함수를 호출하는 행 번호 세트를 지정합니다. 모든 오퍼레이터가 모든 통화에 회선 번호를 할당하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="aa994c33b9388f94e332b012c066b84d979eb038" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;count&quot;&gt;counting operator&lt;/strong&gt; is the number of elements of a set. The operator is undefined for closures. The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators are interpreted as the obvious arithmetical operators when applied to numbers. The syntax of the counting operator:</source>
          <target state="translated">&lt;strong id=&quot;count&quot;&gt;카운팅 연산자&lt;/strong&gt; 의 해석은 세트의 요소 수입니다. 연산자는 클로저에 대해 정의되지 않았습니다. &lt;code&gt;+&lt;/code&gt; 는 , &lt;code&gt;-&lt;/code&gt; 그리고 &lt;code&gt;*&lt;/code&gt; 숫자에 적용 할 때 사업자는 명백한 산술 연산자로 해석됩니다. 계산 연산자의 구문 :</target>
        </trans-unit>
        <trans-unit id="029af9da1d3b7dfa078a55f2dfafcadb44b815ca" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;restriction&quot;&gt;restriction operators&lt;/strong&gt; is a subset of the first operand, a set of calls. The second operand, a set of vertices, is converted to the type of the first operand. The syntax of the restriction operators:</source>
          <target state="translated">&lt;strong id=&quot;restriction&quot;&gt;제한 연산자&lt;/strong&gt; 의 해석은 첫 번째 피연산자의 하위 집합 인 일련의 호출입니다. 두 번째 피연산자 (정점 집합)는 첫 번째 피연산자의 유형으로 변환됩니다. 제한 연산자의 구문 :</target>
        </trans-unit>
        <trans-unit id="42a357f828f4be5cdec9a066f8f31849364dc8f3" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;Lin&lt;/code&gt; operator applied to a set of functions assigns to each function the line number where the function is defined. Unknown functions and functions of library modules are assigned the number 0.</source>
          <target state="translated">함수 세트에 적용된 &lt;code&gt;Lin&lt;/code&gt; 연산자 의 해석은 각 함수에 함수가 정의 된 행 번호를 지정합니다. 라이브러리 모듈의 알 수없는 기능에는 0이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="79e7f897549e217090e266a6ea8b4df3f84a5e55" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;closure&lt;/code&gt; operator is the transitive closure of the operand.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; 연산자 의 해석은 피연산자의 전이 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="3da3bce7de2dcd2a2e677818a4ae2d0bdc921895" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;of&lt;/code&gt; operator is a chain of calls of the second operand (a set of calls) that passes throw all of the vertices of the first operand (a tuple of constants), in the given order. The second operand is converted to the type of the first operand. For instance, the &lt;code&gt;of&lt;/code&gt; operator can be used for finding out whether a function calls another function indirectly, and the chain of calls demonstrates how. The syntax of the graph analyzing operators:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; 연산자 의 해석은 주어진 순서대로 첫 번째 피연산자 (상수 튜플)의 모든 정점을 전달하는 두 번째 피연산자 (호출 집합)의 호출 체인입니다. 두 번째 피연산자는 첫 번째 피연산자의 유형으로 변환됩니다. 예를 들어, &lt;code&gt;of&lt;/code&gt; 연산자를 사용하여 함수가 다른 함수를 간접적으로 호출하는지 여부를 알아낼 수 있으며 호출 체인이 방법을 보여줍니다. 연산자를 분석하는 그래프의 구문 :</target>
        </trans-unit>
        <trans-unit id="0eda32350bebfe83b0d81b3598e00fc83971c333" translate="yes" xml:space="preserve">
          <source>The interpretation of the cast operator depends on the named type &lt;code&gt;Type&lt;/code&gt;, the type of &lt;code&gt;Expression&lt;/code&gt;, and the structure of the elements of the interpretation of &lt;code&gt;Expression&lt;/code&gt;. If the named type is equal to the expression type, no conversion is done. Otherwise, the conversion is done one step at a time; &lt;code&gt;(Fun)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;, for instance, is equivalent to &lt;code&gt;(Fun)&amp;nbsp;(Mod)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;. Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of constants (functions, modules, applications or releases). If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of modules that have at least one of their functions mentioned in the interpretation of the expression. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all the functions of the modules (in &lt;code&gt;modules&lt;/code&gt; mode, the conversion is partial since the local functions are not known). The conversions to and from applications and releases work analogously. For instance, &lt;code&gt;(App) &quot;xref_.*&quot; : Mod&lt;/code&gt; returns all applications containing at least one module such that &lt;code&gt;xref_&lt;/code&gt; is a prefix of the module name.</source>
          <target state="translated">캐스트 연산자의 해석은 명명 된 형식에 따라 &lt;code&gt;Type&lt;/code&gt; , 유형 &lt;code&gt;Expression&lt;/code&gt; , 그리고 해석의 요소의 구조 &lt;code&gt;Expression&lt;/code&gt; . 명명 된 형식이 식 형식과 같으면 변환이 수행되지 않습니다. 그렇지 않으면 한 번에 한 단계 씩 변환이 수행됩니다. &lt;code&gt;(Fun)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt; 는 &lt;code&gt;(Fun)&amp;nbsp;(Mod)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt; . 이제 &lt;code&gt;Expression&lt;/code&gt; 의 해석이 상수 세트 (함수, 모듈, 응용 프로그램 또는 릴리스)라고 가정하십시오. 명명 된 유형이 표현식 유형보다 일반적인 경우 &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; 각각의 경우, 캐스트 표현식의 해석은 표현식 해석에 언급 된 기능 중 하나 이상을 갖는 모듈 세트입니다. 명명 된 유형이 표현식 유형보다 더 특수한 경우 ( &lt;code&gt;Fun&lt;/code&gt; 및 &lt;code&gt;Mod&lt;/code&gt; ) , 해석은 모듈의 모든 기능 세트입니다 ( &lt;code&gt;modules&lt;/code&gt; 모드에서는 로컬 기능을 알 수 없으므로 변환이 부분적 임). 응용 프로그램과 릴리스 간의 변환은 유사하게 작동합니다. 예를 들어 &lt;code&gt;(App) &quot;xref_.*&quot; : Mod&lt;/code&gt; 는 &lt;code&gt;xref_&lt;/code&gt; 가 모듈 이름의 접두사가되도록 모듈을 하나 이상 포함하는 모든 응용 프로그램을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6993da444161dc204cc03e12d5fc3810b9cd2d1f" translate="yes" xml:space="preserve">
          <source>The interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the &lt;code&gt;inode&lt;/code&gt; was changed. In Windows, it is the create time.</source>
          <target state="translated">이 시간 필드의 해석은 운영 체제에 따라 다릅니다. Unix에서는 파일 또는 &lt;code&gt;inode&lt;/code&gt; 가 마지막 으로 변경된 시간입니다. Windows에서는 생성 시간입니다.</target>
        </trans-unit>
        <trans-unit id="91054e3a873098417a4f5c515e5ee9a48b04d7dd" translate="yes" xml:space="preserve">
          <source>The interpreted function call has returned a value, and the process is no longer executing interpreted code.</source>
          <target state="translated">해석 된 함수 호출이 값을 리턴했으며 프로세스가 해석 된 코드를 더 이상 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cabfaea9757a021ed3e404bb4e938889922f05f" translate="yes" xml:space="preserve">
          <source>The interpreter depends on the Kernel, STDLIB, and GS applications. This means that modules belonging to any of these applications are not allowed to be interpreted, as it could lead to a deadlock or emulator crash. This also applies to modules belonging to the Debugger application.</source>
          <target state="translated">인터프리터는 커널, STDLIB 및 GS 애플리케이션에 따라 다릅니다. 이는 교착 상태 또는 에뮬레이터 충돌로 이어질 수 있으므로 이러한 응용 프로그램에 속하는 모듈을 해석 할 수 없음을 의미합니다. 이것은 디버거 응용 프로그램에 속하는 모듈에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b74c0c5597c96d6ab8e51a9cb5a0af4d7d7773f" translate="yes" xml:space="preserve">
          <source>The interpreter requires both the source code and the object code. The object code &lt;strong&gt;must&lt;/strong&gt; include debug information, that is, only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted.</source>
          <target state="translated">인터프리터에는 소스 코드와 객체 코드가 모두 필요합니다. 오브젝트 코드 에는 디버그 정보 &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되어야합니다&lt;/strong&gt; . 즉, 옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트로 컴파일 된 모듈 만 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87e9cf7deb8f947251ab88b658e53f7027d6b5d" translate="yes" xml:space="preserve">
          <source>The introduction of Erlang monotonic time allows us to adjust the two Erlang times (Erlang monotonic time and Erlang system time) separately. By doing this, the accuracy of elapsed time does not have to suffer just because the system time happened to be wrong at some point in time. Separate adjustments of the two times are only performed in the time warp modes, and only fully separated in the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;. All other modes than the multi-time warp mode are for backward compatibility reasons. When using these modes, the accuracy of Erlang monotonic time suffer, as the adjustments of Erlang monotonic time in these modes are more or less tied to Erlang system time.</source>
          <target state="translated">Erlang 단조 시간을 도입하면 두 개의 Erlang 시간 (Erlang 단조 시간 및 Erlang 시스템 시간)을 개별적으로 조정할 수 있습니다. 이렇게하면 특정 시점에서 시스템 시간이 잘못되었다고해서 경과 시간의 정확도가 저하 될 필요가 없습니다. 두 번의 개별 조정은 시간 왜곡 모드에서만 수행되고 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 에서만 완전히 분리 됩니다 . 다중 시간 왜곡 모드 이외의 다른 모든 모드는 이전 버전과의 호환성을위한 것입니다. 이 모드를 사용하는 경우,이 모드에서 Erlang 단조 시간의 조정이 Erlang 시스템 시간과 거의 연관되어 있기 때문에 Erlang 단조 시간의 정확도가 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa282f4900a445d575232fb66e91f370519721d" translate="yes" xml:space="preserve">
          <source>The inverse case of assertEqual, for convenience.</source>
          <target state="translated">편의를 위해 assertEqual의 역 경우.</target>
        </trans-unit>
        <trans-unit id="6c146628c3a85cf3e58449747def90c476aa8e70" translate="yes" xml:space="preserve">
          <source>The inverse case of assertMatch, for convenience.</source>
          <target state="translated">편의를 위해 assertMatch의 반대 경우.</target>
        </trans-unit>
        <trans-unit id="2bf283e78cc5757549c9cd4cea259895effeb450" translate="yes" xml:space="preserve">
          <source>The ip trace driver has a queue of &lt;code&gt;QueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced by the runtime system, a special message is sent, which indicates how many messages that are dropped. That message will arrive at the handler function specified in &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; as the tuple &lt;code&gt;{drop, N}&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of consecutive messages dropped. In case of heavy tracing, drop's are likely to occur, and they surely occur if no client is reading the trace messages. The default value of &lt;code&gt;QueSize&lt;/code&gt; is 200.</source>
          <target state="translated">ip 추적 드라이버에는 전달 대기중인 &lt;code&gt;QueSize&lt;/code&gt; 메시지 큐 가 있습니다. 드라이버가 런타임 시스템에서 생성 된 속도만큼 메시지를 전달할 수없는 경우 삭제되는 메시지 수를 나타내는 특수 메시지가 전송됩니다. 이 메시지는 &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; 에 튜플 &lt;code&gt;{drop, N}&lt;/code&gt; 으로 지정된 핸들러 함수에 도착합니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 연속 된 메시지 수입니다. 추적 량이 많을 경우 삭제가 발생할 가능성이 높으며 클라이언트가 추적 메시지를 읽지 않으면 반드시 발생합니다. &lt;code&gt;QueSize&lt;/code&gt; 의 기본값 은 200입니다.</target>
        </trans-unit>
        <trans-unit id="1cc4bd29058e4c95bb51a0143db9193819039f9d" translate="yes" xml:space="preserve">
          <source>The isolation property ensures that transactions that execute on different nodes in a network, and access and manipulate the same data records, do not interfere with each other. The isolation property makes it possible to execute the function &lt;code&gt;raise/2&lt;/code&gt; concurrently. A classical problem in concurrency control theory is the &quot;lost update problem&quot;.</source>
          <target state="translated">격리 속성은 네트워크의 서로 다른 노드에서 실행되고 동일한 데이터 레코드에 액세스하고 조작하는 트랜잭션이 서로 간섭하지 않도록합니다. 격리 속성을 사용하면 &lt;code&gt;raise/2&lt;/code&gt; 함수를 동시에 실행할 수 있습니다. 동시성 제어 이론의 고전적인 문제는 &quot;손실 된 업데이트 문제&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2b7ca45a26b149b7bec285f808a539b088d510f6" translate="yes" xml:space="preserve">
          <source>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table.</source>
          <target state="translated">트랜잭션을 사용하여 데이터를 조작하는 다른 Erlang 프로세스는 더티 조작이 동시에 동일한 테이블에서 레코드를 읽고 쓰는 경우 격리의 이점을 얻지 못하므로 격리 특성이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="f15766776f9f8c25cf7a58ac94784f1f3ead7adc" translate="yes" xml:space="preserve">
          <source>The isolation property is in particular useful if the following circumstances occur where an employee (with employee number 123) and two processes (P1 and P2) are concurrently trying to raise the salary for the employee:</source>
          <target state="translated">격리 속성은 직원 (직원 수가 123 인)과 두 프로세스 (P1 및 P2)가 동시에 직원의 급여 인상을 시도하는 경우에 다음과 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="284c773ace5ac2a66861a95faee4480ce7506813" translate="yes" xml:space="preserve">
          <source>The issuer id consists of the serial number and the issuers name.</source>
          <target state="translated">발급자 ID는 일련 번호와 발급자 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="afc376918231468e613617267d35779bd5d5d659" translate="yes" xml:space="preserve">
          <source>The item was not present in the system at the point of failure.</source>
          <target state="translated">실패 시점에 시스템에 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d57c675d8a8485a1824af8a77e5919d6b9669f2e" translate="yes" xml:space="preserve">
          <source>The items in this menu are used to create and delete breakpoints. For details, see section &lt;code&gt;&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메뉴의 항목은 중단 점을 작성하고 삭제하는 데 사용됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="481eae0056ff6c417a15e2d26dc9dfb9c5c8016d" translate="yes" xml:space="preserve">
          <source>The join is to be expressed as a guard filter. The filter must be placed immediately after the two joined generators, possibly after guard filters that use variables from no other generators but the two joined generators. The &lt;code&gt;qlc&lt;/code&gt; module inspects the operands of &lt;code&gt;=:=/2&lt;/code&gt;, &lt;code&gt;==/2&lt;/code&gt;, &lt;code&gt;is_record/2&lt;/code&gt;, &lt;code&gt;element/2&lt;/code&gt;, and logical operators (&lt;code&gt;and/2&lt;/code&gt;, &lt;code&gt;or/2&lt;/code&gt;, &lt;code&gt;andalso/2&lt;/code&gt;, &lt;code&gt;orelse/2&lt;/code&gt;, &lt;code&gt;xor/2&lt;/code&gt;) when determining which joins to consider.</source>
          <target state="translated">결합은 보호 필터로 표현됩니다. 필터는 두 개의 결합 된 생성기 바로 뒤에 배치해야하며, 다른 생성기 이외의 결합 된 생성기 이외의 변수를 사용하는 보호 필터 뒤에 배치해야합니다. &lt;code&gt;qlc&lt;/code&gt; 모듈의 피연산자들을 검사 &lt;code&gt;=:=/2&lt;/code&gt; , &lt;code&gt;==/2&lt;/code&gt; , &lt;code&gt;is_record/2&lt;/code&gt; , &lt;code&gt;element/2&lt;/code&gt; 및 논리 연산자 ( &lt;code&gt;and/2&lt;/code&gt; , &lt;code&gt;or/2&lt;/code&gt; , &lt;code&gt;andalso/2&lt;/code&gt; , &lt;code&gt;orelse/2&lt;/code&gt; , &lt;code&gt;xor/2&lt;/code&gt; ) 고려할 조인을 결정할 때.</target>
        </trans-unit>
        <trans-unit id="90b36f2ace473010b2db9075b6ab6adecda8977a" translate="yes" xml:space="preserve">
          <source>The kernel supervisor has detected a failure, usually that the &lt;code&gt;application_controller&lt;/code&gt; has shut down (&lt;code&gt;Who&lt;/code&gt; = &lt;code&gt;application_controller&lt;/code&gt;, &lt;code&gt;Why&lt;/code&gt; = &lt;code&gt;shutdown&lt;/code&gt;). The application controller can have shut down for many reasons, the most usual is that the node name of the distributed Erlang node is already in use. A complete supervisor tree &quot;crash&quot; (that is, the top supervisors have exited) gives about the same result. This message comes from the Erlang code and not from the virtual machine itself. It is always because of some failure in an application, either within OTP or a &quot;user-written&quot; one. Looking at the error log for your application is probably the first step to take.</source>
          <target state="translated">커널 수퍼바이저가 실패를 감지했습니다. 일반적으로 &lt;code&gt;application_controller&lt;/code&gt; 가 종료되었습니다 ( &lt;code&gt;Who&lt;/code&gt; = &lt;code&gt;application_controller&lt;/code&gt; , &lt;code&gt;Why&lt;/code&gt; = &lt;code&gt;shutdown&lt;/code&gt; ). 응용 프로그램 제어기는 여러 가지 이유로 종료 될 수 있습니다. 가장 일반적인 것은 분산 Erlang 노드의 노드 이름이 이미 사용 중입니다. 완전한 수퍼바이저 트리 &quot;충돌&quot;(즉, 최고 수퍼바이저가 종료)은 거의 동일한 결과를 제공합니다. 이 메시지는 가상 머신 자체가 아니라 Erlang 코드에서 온 것입니다. 항상 OTP 또는 &quot;사용자 작성&quot;응용 프로그램의 일부 오류로 인해 발생합니다. 응용 프로그램의 오류 로그를 보는 것이 아마도 첫 번째 단계 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="87cfd3cdc21e12ece215da1ff3c7bd0778edf3ae" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;mod&lt;/code&gt; defines the callback module and start argument of the application, in this case &lt;code&gt;ch_app&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, respectively. This means that the following is called when the application is to be started:</source>
          <target state="translated">키 &lt;code&gt;mod&lt;/code&gt; 는 애플리케이션의 콜백 모듈 및 시작 인수 (이 경우 &lt;code&gt;ch_app&lt;/code&gt; 및 &lt;code&gt;[]&lt;/code&gt; )를 각각 정의합니다. 즉, 응용 프로그램을 시작할 때 다음이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63c37d9d912063a1a57159881898bac71cffe007" translate="yes" xml:space="preserve">
          <source>The key above can be written as &lt;code&gt;&quot;\\hklm\\software\\ericsson\\erlang\\5.0&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 키는 &lt;code&gt;&quot;\\hklm\\software\\ericsson\\erlang\\5.0&quot;&lt;/code&gt; 으로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4de5a958aeabffb38a49fbf124f00c275f5ea14" translate="yes" xml:space="preserve">
          <source>The key can be provided in the following two ways:</source>
          <target state="translated">키는 다음 두 가지 방법으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e475f564fef24efe7c2edd2e65ff61b8004f591" translate="yes" xml:space="preserve">
          <source>The key position is obtained by calling &lt;code&gt;InfoFun(keypos)&lt;/code&gt; and the indexed positions by calling &lt;code&gt;InfoFun(indices)&lt;/code&gt;. If the key position can be used for lookup, it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions, the one occurring first in the list returned by &lt;code&gt;InfoFun&lt;/code&gt; is chosen. Positions requiring more than &lt;code&gt;&lt;a href=&quot;#max_lookup&quot;&gt;max_lookup&lt;/a&gt;&lt;/code&gt; lookups are ignored.</source>
          <target state="translated">키 위치는 &lt;code&gt;InfoFun(keypos)&lt;/code&gt; 를 호출하여 획득 하고 색인 위치는 &lt;code&gt;InfoFun(indices)&lt;/code&gt; 호출하여 얻습니다 . 키 위치를 조회에 사용할 수있는 경우 항상 키 위치가 선택되고, 그렇지 않으면 가장 적은 수의 조회가 필요한 인덱스 된 위치가 선택됩니다. 두 개의 인덱스 된 위치 사이에 동점이 있으면 &lt;code&gt;InfoFun&lt;/code&gt; 이 반환 한 목록에서 처음 발생하는 것이 선택됩니다. &lt;code&gt;&lt;a href=&quot;#max_lookup&quot;&gt;max_lookup&lt;/a&gt;&lt;/code&gt; 조회 이상을 요구하는 위치 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="06c2324ad19db22f732f87371d50b783de7c2324" translate="yes" xml:space="preserve">
          <source>The key position.</source>
          <target state="translated">핵심 위치.</target>
        </trans-unit>
        <trans-unit id="a8b10ddac8355f7a246ab0ac12d610b134228817" translate="yes" xml:space="preserve">
          <source>The key's password</source>
          <target state="translated">키의 비밀번호</target>
        </trans-unit>
        <trans-unit id="f88e9f9a4e85f1b89fcef9e232ae2c64409d89a5" translate="yes" xml:space="preserve">
          <source>The key-value pairs of a map have no defined iteration order. The only guarantee is that the iteration order of a single map instance is preserved during the lifetime of the environment that the map belongs to.</source>
          <target state="translated">맵의 키-값 쌍에는 정의 된 반복 순서가 없습니다. 유일한 보장은 단일 맵 인스턴스의 반복 순서가 맵이 속한 환경의 수명 동안 유지된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e64b8f95a5f079901b89db2a9fb2daa26e73a227" translate="yes" xml:space="preserve">
          <source>The keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; are optional in the supervisor flags map. If they are not given, they default to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;, respectively.</source>
          <target state="translated">키 &lt;code&gt;intensity&lt;/code&gt; 와 &lt;code&gt;period&lt;/code&gt; 은 수퍼바이저 플래그 맵에서 선택 사항입니다. 지정하지 않으면 각각 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;5&lt;/code&gt; 로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a715eaeca461686c2d011a0989c495c1be24a00f" translate="yes" xml:space="preserve">
          <source>The keys and some other data are by default stored in files in the directory &lt;code&gt;.ssh&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">키와 다른 데이터는 기본적으로 사용자 홈 디렉토리의 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리에있는 파일에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e270d4cb9c5a1f53027b9df8a800abde232726f8" translate="yes" xml:space="preserve">
          <source>The keys are by default stored in files:</source>
          <target state="translated">키는 기본적으로 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="66af8fb8940dc217a32c86c117d958eb57768c52" translate="yes" xml:space="preserve">
          <source>The keys for the symmetric encryption are generated uniquely for each connection and are based on a secret negotiated in the TLS/DTLS handshake.</source>
          <target state="translated">대칭 암호화의 키는 각 연결마다 고유하게 생성되며 TLS / DTLS 핸드 셰이크에서 협상 된 비밀을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="aff18d7af60baca2c26521c99fcf528391bc0c76" translate="yes" xml:space="preserve">
          <source>The label is intended to provide a brief summary of the event. It is preferred to use an atom but a string would also do.</source>
          <target state="translated">이 레이블은 이벤트에 대한 간략한 요약을 제공하기위한 것입니다. 원자를 사용하는 것이 바람직하지만 문자열도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="edeb86123112824d83ee0303c271a4cb682dd647" translate="yes" xml:space="preserve">
          <source>The language setting in the operating system mainly affects the shell. The terminal (that is, the group leader) operates with &lt;code&gt;{encoding, unicode}&lt;/code&gt; only if the environment tells it that UTF-8 is allowed. This setting is to correspond to the terminal you are using.</source>
          <target state="translated">운영 체제의 언어 설정은 주로 셸에 영향을줍니다. 터미널 (즉, 그룹 리더)은 환경에서 UTF-8이 허용된다고 알려주는 경우에만 &lt;code&gt;{encoding, unicode}&lt;/code&gt; 작동합니다 . 이 설정은 사용중인 터미널에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3d5867e4e848137cec6dd146c4e2783ad319840b" translate="yes" xml:space="preserve">
          <source>The last &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; that can be represented internally in the current Erlang runtime system instance. The time between the &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;start time&lt;/a&gt;&lt;/code&gt; and the end time is at least a quarter of a millennium.</source>
          <target state="translated">현재 Erlang 런타임 시스템 인스턴스에서 내부적으로 표시 될 수있는 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 의 마지막 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 입니다 . &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;start time&lt;/a&gt;&lt;/code&gt; 과 종료 시간 사이의 시간은 최소한 천년의 1/4입니다.</target>
        </trans-unit>
        <trans-unit id="cbf7bc8595fbcb78ce027c719bffd4ff1c3073de" translate="yes" xml:space="preserve">
          <source>The last column is the internal column. When performing a &lt;code&gt;set&lt;/code&gt; operation, which creates a row, we must give a value to the internal column. The instrumentation functions will now look as follows:</source>
          <target state="translated">마지막 열은 내부 열입니다. 행을 생성 하는 &lt;code&gt;set&lt;/code&gt; 연산을 수행 할 때 내부 열에 값을 제공해야합니다. 계측 기능은 이제 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="184226eab517900aa5e104f77b408fc4703f673c" translate="yes" xml:space="preserve">
          <source>The last group in the specified path is the terminating group in the test, that is, no subgroups following this group are executed. In the previous example, &lt;code&gt;g4&lt;/code&gt; is the terminating group. Hence, &lt;code&gt;Common Test&lt;/code&gt; executes a test that calls all &lt;code&gt;init&lt;/code&gt; configuration functions in the path to &lt;code&gt;g4&lt;/code&gt;, that is, &lt;code&gt;g1..g3..g4&lt;/code&gt;. It then calls test cases &lt;code&gt;tc1&lt;/code&gt; and &lt;code&gt;tc5&lt;/code&gt; in &lt;code&gt;g4&lt;/code&gt;, and finally all &lt;code&gt;end&lt;/code&gt; configuration functions in order &lt;code&gt;g4..g3..g1&lt;/code&gt;.</source>
          <target state="translated">지정된 경로의 마지막 그룹은 테스트에서 종료 그룹입니다. 즉,이 그룹 다음에 오는 하위 그룹이 실행되지 않습니다. 이전 예에서 &lt;code&gt;g4&lt;/code&gt; 는 종료 그룹입니다. 따라서 &lt;code&gt;Common Test&lt;/code&gt; 는 &lt;code&gt;g4&lt;/code&gt; , 즉 &lt;code&gt;g1..g3..g4&lt;/code&gt; 경로의 모든 &lt;code&gt;init&lt;/code&gt; 구성 함수 를 호출하는 테스트를 실행합니다 . 그런 다음 &lt;code&gt;g4&lt;/code&gt; 에서 테스트 사례 &lt;code&gt;tc1&lt;/code&gt; 및 &lt;code&gt;tc5&lt;/code&gt; 를 호출 하고 마지막으로 모든 &lt;code&gt;end&lt;/code&gt; 구성 기능을 &lt;code&gt;g4..g3..g1&lt;/code&gt; 순서로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8fa1840cc2c30d96ac21156af3e40270a8d80935" translate="yes" xml:space="preserve">
          <source>The last line is generated due to internal message passing in the Erlang shell. The process id's will vary.</source>
          <target state="translated">Erlang 셸에서 내부 메시지가 전달되어 마지막 줄이 생성됩니다. 프로세스 ID는 다양합니다.</target>
        </trans-unit>
        <trans-unit id="e64b76cd01b4823944e2365efd79f7ca4112521f" translate="yes" xml:space="preserve">
          <source>The last part of the grammar file is an optional section with Erlang code (= function definitions) which is included 'as is' in the resulting parser file. This section must start with the pseudo declaration, or key words</source>
          <target state="translated">문법 파일의 마지막 부분은 결과 구문 분석기 파일에 '있는 그대로'포함 된 Erlang 코드 (= 함수 정의)가있는 선택적 섹션입니다. 이 섹션은 의사 선언 또는 키워드로 시작해야합니다</target>
        </trans-unit>
        <trans-unit id="a6f5d3a54465773e89b4c8e688e662aaa9749ae4" translate="yes" xml:space="preserve">
          <source>The last step is to create boot scripts to make the protocol implementation available at boot time. The implementation can be debugged by starting the distribution when all the system is running, but in a real system the distribution is to start very early, why a boot script and some command-line parameters are necessary.</source>
          <target state="translated">마지막 단계는 부팅시 프로토콜 구현을 사용할 수 있도록 부팅 스크립트를 만드는 것입니다. 모든 시스템이 실행 중일 때 배포를 시작하면 구현을 디버깅 할 수 있지만 실제 시스템에서는 배포가 매우 일찍 시작되어 부팅 스크립트와 일부 명령 줄 매개 변수가 필요한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a35c1b9bd211b68b47957d2e49a6e71571d068" translate="yes" xml:space="preserve">
          <source>The last test to run is for system &lt;code&gt;t3&lt;/code&gt;. Here, all suites are skipped and this is explicitly noted in the log files.</source>
          <target state="translated">마지막으로 실행할 테스트는 시스템 &lt;code&gt;t3&lt;/code&gt; 에 대한 것 입니다. 여기서 모든 스위트는 건너 뛰고 로그 파일에 명시 적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8852e7914b224a1a777608407ab41bad01ca2077" translate="yes" xml:space="preserve">
          <source>The last time the file was read.</source>
          <target state="translated">파일을 마지막으로 읽은 시간.</target>
        </trans-unit>
        <trans-unit id="791648c90deaadf98f3326f3b6bcff45e17be84e" translate="yes" xml:space="preserve">
          <source>The last time the file was written.</source>
          <target state="translated">파일이 마지막으로 작성된 시간.</target>
        </trans-unit>
        <trans-unit id="072e3449b89f599c8bc8ba1995b3f4a85ad87776" translate="yes" xml:space="preserve">
          <source>The latter example is equivalent to the former, which can be verified using function &lt;code&gt;qlc:info/1&lt;/code&gt;:</source>
          <target state="translated">후자의 예는 전자와 동일하며 함수 &lt;code&gt;qlc:info/1&lt;/code&gt; 를 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ba708046f3a5ea5ae482709704f7c918ddacbf9" translate="yes" xml:space="preserve">
          <source>The latter functions are needed only when new config directives are to be introduced. For details, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">후자의 기능은 새로운 설정 지시문을 도입 할 때만 필요합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfe702a557aaf2b0af643fec45c2fbcc306adfbd" translate="yes" xml:space="preserve">
          <source>The latter specification says that the function takes some tuple and returns some tuple. The specification with the &lt;code&gt;X&lt;/code&gt; type variable specifies that the function takes a tuple and returns &lt;strong&gt;the same&lt;/strong&gt; tuple.</source>
          <target state="translated">후자의 스펙은 함수가 일부 튜플을 가져 와서 일부 튜플을 반환한다고 말합니다. &lt;code&gt;X&lt;/code&gt; 유형 변수 가있는 스펙 은 함수가 튜플을 가져오고 &lt;strong&gt;동일한&lt;/strong&gt; 튜플을 리턴 &lt;strong&gt;하도록&lt;/strong&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4e60740c974cd4ca31f6898f4c908ec03d194026" translate="yes" xml:space="preserve">
          <source>The least maximum packet size that the daemon will accept in channel open requests from the client. The default value is 0.</source>
          <target state="translated">데몬이 클라이언트의 채널 열기 요청에서 허용하는 최소 최대 패킷 크기입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="0dde3cfeba08df09564d97f09effbfe3c18694c1" translate="yes" xml:space="preserve">
          <source>The least significant bit in that half byte is flag &lt;code&gt;LongAtoms&lt;/code&gt;. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header.</source>
          <target state="translated">그 반 바이트에서 최하위 비트는 플래그 &lt;code&gt;LongAtoms&lt;/code&gt; 입니다. 설정된 경우 분배 헤더에서 1 바이트 대신 원자 길이에 2 바이트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="10c687faf784f36e13b6f57d77f566d81227f644" translate="yes" xml:space="preserve">
          <source>The left associative arithmetic operators are evaluated left to right:</source>
          <target state="translated">왼쪽 연관 산술 연산자는 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="16a5e87b76355a265a2acff30311f789fd728096" translate="yes" xml:space="preserve">
          <source>The left hand side is a non-terminal category. The right hand side is a sequence of one or more non-terminal or terminal symbols with spaces between. The associated code is a sequence of zero or more Erlang expressions (with commas &lt;code&gt;','&lt;/code&gt; as separators). If the associated code is empty, the separating colon &lt;code&gt;':'&lt;/code&gt; is also omitted. A final dot marks the end of the rule.</source>
          <target state="translated">왼쪽은 비 터미널 범주입니다. 오른쪽은 공백이있는 하나 이상의 비 터미널 또는 터미널 기호 시퀀스입니다. 연관된 코드는 0 개 이상의 Erlang 표현식의 시퀀스입니다 (쉼표 &lt;code&gt;','&lt;/code&gt; 를 구분 기호로 사용). 연관된 코드가 비어 있으면 분리 콜론 &lt;code&gt;':'&lt;/code&gt; 도 생략됩니다. 마지막 점은 규칙의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d15c8b505512cf7ef5ed3725e558edb04ee8e3f" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; are still supported so old configurations will work.</source>
          <target state="translated">레거시 및 중간 변수 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;domain&lt;/code&gt; 은 여전히 ​​지원되므로 이전 구성이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0d5b31ada6fd921f21fd7ea3a8c8a6e7b646094e" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;intAgentIpAddress&lt;/code&gt; and &lt;code&gt;intAgentTransportDomain&lt;/code&gt; are still supported so old &lt;code&gt;agent.conf&lt;/code&gt; files will work.</source>
          <target state="translated">레거시 및 중간 변수 &lt;code&gt;intAgentIpAddress&lt;/code&gt; 및 &lt;code&gt;intAgentTransportDomain&lt;/code&gt; 은 여전히 ​​지원되므로 이전 &lt;code&gt;agent.conf&lt;/code&gt; 파일이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4544ea5bcba9a54bca20006006b59bdb9618fafb" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">원자의 바이트 단위의 길이 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7315fe138888586d2580dc24cb36b5eccee73131" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of binary object &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">이진 오브젝트 (바이트)의 길이 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddba0164da7862c7ff2f4f524f8c9cbb1852156f" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of field &lt;code&gt;NodeName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NodeName&lt;/code&gt; 필드의 길이 (바이트) .</target>
        </trans-unit>
        <trans-unit id="31080ac8eb9821d87bfa8097d8cf1b74183eeb9a" translate="yes" xml:space="preserve">
          <source>The length of a list with the first element &lt;code&gt;First&lt;/code&gt; and the remaining elements &lt;code&gt;Rest&lt;/code&gt; is 1 + the length of &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">첫 번째 요소 &lt;code&gt;First&lt;/code&gt; 와 나머지 요소 &lt;code&gt;Rest&lt;/code&gt; 가 있는 목록의 길이 는 1 + &lt;code&gt;Rest&lt;/code&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="f96f13301619a2d2b302b2c22fb4b20b1a059059" translate="yes" xml:space="preserve">
          <source>The length of an empty list is obviously 0.</source>
          <target state="translated">빈 목록의 길이는 분명히 0입니다.</target>
        </trans-unit>
        <trans-unit id="d1de7130de2bc092009b6447a54b5cc56f2e0ac6" translate="yes" xml:space="preserve">
          <source>The length of field &lt;code&gt;Extra&lt;/code&gt;.</source>
          <target state="translated">필드 길이는 &lt;code&gt;Extra&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6031d07abc01be3ec4d2fad520f49b18ab9f57ce" translate="yes" xml:space="preserve">
          <source>The length of the message queue for the process.</source>
          <target state="translated">프로세스의 메시지 큐 길이</target>
        </trans-unit>
        <trans-unit id="15fbacbdc36d9fa85ce6b119e70f9944e34bbef9" translate="yes" xml:space="preserve">
          <source>The library &lt;code&gt;ei&lt;/code&gt; contains macros and functions to encode and decode the Erlang binary term format.</source>
          <target state="translated">라이브러리 &lt;code&gt;ei&lt;/code&gt; 에는 Erlang 이진 용어 형식을 인코딩하고 디코딩하는 매크로와 함수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1a396fcf8bb30c9c4e81871da3298d0c3af7de9" translate="yes" xml:space="preserve">
          <source>The library did not fulfill the requirements as a NIF library of the calling module.</source>
          <target state="translated">라이브러리가 호출 모듈의 NIF 라이브러리로서 요구 사항을 충족시키지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="4000d6b2656172da8f1ebb8bb8da55bc7e83a2fc" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;load&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;load&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if initialization is not needed.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이외의 값을 반환 하면 라이브러리가로드되지 않습니다 . 초기화가 필요하지 않은 경우 &lt;code&gt;load&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7c36356b1ef653f4eb93e620c175a01deae68b6" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;upgrade&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;upgrade&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 라이브러리는 부하에 실패 &lt;code&gt;upgrade&lt;/code&gt; 이외의 반환 아무것도 &lt;code&gt;0&lt;/code&gt; 또는 경우가 &lt;code&gt;upgrade&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="7d68ce185719476197d42f3853f9b5b1affcf038" translate="yes" xml:space="preserve">
          <source>The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a &lt;code&gt;badarg&lt;/code&gt; exception is thrown from any of the functions in this module.</source>
          <target state="translated">라이브러리는 바이트 지향 데이터를 처리합니다. 이진이 아닌 비트 스트링 (비트의 전체 옥텟을 포함하지 않음)의 &lt;code&gt;badarg&lt;/code&gt; 모듈의 함수에서 잘못된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58751b20a63ee8ce5dffe3bf1fdb22852c369253" translate="yes" xml:space="preserve">
          <source>The library initialization callbacks &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;upgrade&lt;/code&gt; are thread-safe even for shared state data.</source>
          <target state="translated">라이브러리 초기화 콜백 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;upgrade&lt;/code&gt; 는 공유 상태 데이터에 대해서도 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="525c752158ef80bf2ab4b174acb04d2294619c57" translate="yes" xml:space="preserve">
          <source>The library path  &lt;code id=&quot;code_path&quot;&gt;code_path&lt;/code&gt; is used by the functions &lt;code&gt;m/1&lt;/code&gt; and &lt;code&gt;d/1&lt;/code&gt;, but can also be set explicitly. Note however that the code path will be traversed once for each used &lt;code&gt;&lt;a href=&quot;#library_module&quot;&gt;library module&lt;/a&gt;&lt;/code&gt; while setting up module data. On the other hand, if there are only a few modules that are used but not analyzed, using &lt;code&gt;code_path&lt;/code&gt; may be faster than setting the library path to &lt;code&gt;code:get_path()&lt;/code&gt;.</source>
          <target state="translated">라이브러리 경로 &lt;code id=&quot;code_path&quot;&gt;code_path&lt;/code&gt; 는 &lt;code&gt;m/1&lt;/code&gt; 및 &lt;code&gt;d/1&lt;/code&gt; 함수에서 사용 되지만 명시 적으로 설정할 수도 있습니다. 그러나 모듈 데이터를 설정하는 동안 사용 된 각 &lt;code&gt;&lt;a href=&quot;#library_module&quot;&gt;library module&lt;/a&gt;&lt;/code&gt; 에 대해 코드 경로가 한 번 순회 됩니다. 반면에 사용되지만 분석되지 않은 모듈이 몇 개만있는 경우 &lt;code&gt;code_path&lt;/code&gt; 를 사용 하면 라이브러리 경로를 &lt;code&gt;code:get_path()&lt;/code&gt; 로 설정하는 것보다 빠를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72d5d28aae4fd1fc9e01fcb3c39ddb230755733d" translate="yes" xml:space="preserve">
          <source>The line and column where the token begins, or just the line if the column is unknown.</source>
          <target state="translated">토큰이 시작되는 행 및 열 또는 열을 알 수없는 경우 행</target>
        </trans-unit>
        <trans-unit id="360684cf560fc66328b23d2a88ed263288ae0193" translate="yes" xml:space="preserve">
          <source>The line number where the token occurred.</source>
          <target state="translated">토큰이 발생한 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="32ef4a94e615116b5f15d93da06b8801c1438276" translate="yes" xml:space="preserve">
          <source>The line where the token begins.</source>
          <target state="translated">토큰이 시작되는 줄입니다.</target>
        </trans-unit>
        <trans-unit id="06982a696a56059b28dcc90e39b170a06c23c36e" translate="yes" xml:space="preserve">
          <source>The lines where functions are defined (more precisely: where the first clause begins) and the lines where functions are used are available in &lt;code&gt;functions&lt;/code&gt; mode. The line numbers refer to the files where the functions are defined. This holds also for files included with the &lt;code&gt;-include&lt;/code&gt; and &lt;code&gt;-include_lib&lt;/code&gt; directives, which may result in functions defined apparently in the same line. The &lt;strong&gt;line operators&lt;/strong&gt; are used for assigning line numbers to functions and for assigning sets of line numbers to function calls. The syntax is similar to the one of the cast operator:</source>
          <target state="translated">함수가 정의 된 행 (보다 정확하게 : 첫 번째 절이 시작되는 위치) 및 함수가 사용되는 행은 &lt;code&gt;functions&lt;/code&gt; 모드 에서 사용할 수 있습니다 . 줄 번호는 함수가 정의 된 파일을 나타냅니다. 이것은 &lt;code&gt;-include&lt;/code&gt; 및 &lt;code&gt;-include_lib&lt;/code&gt; 지시문에 포함 된 파일에도 적용 되므로 동일한 행에 분명히 정의 된 함수가 발생할 수 있습니다. &lt;strong&gt;라인 연산자는&lt;/strong&gt; 함수에 줄 번호를 할당하고 함수 호출에 줄 번호의 집합을 지정하는 데 사용됩니다. 구문은 캐스트 연산자 중 하나와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d24fd42f9853b856c640811e28979dbf854c2b78" translate="yes" xml:space="preserve">
          <source>The lines where the external calls of the example before last are made.</source>
          <target state="translated">마지막 예제 이전의 외부 호출이 이루어진 라인.</target>
        </trans-unit>
        <trans-unit id="d24fdb17e4fea5eb7628e12a6c79e2f53029142b" translate="yes" xml:space="preserve">
          <source>The lines where the local calls of the last example are made.</source>
          <target state="translated">마지막 예의 로컬 호출이 이루어진 회선입니다.</target>
        </trans-unit>
        <trans-unit id="f2e317995e860f4cf19c85bed428103e5fa4c987" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;&lt;a href=&quot;xref#representation&quot;&gt;representation of graphs&lt;/a&gt;&lt;/code&gt; is used analyzing direct calls, while the &lt;code&gt;digraph&lt;/code&gt; representation is suited for analyzing indirect calls. The restriction operators (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;|||&lt;/code&gt;) are the only operators that accept both representations. This means that in order to analyze indirect calls using restriction, the &lt;code&gt;closure&lt;/code&gt; operator (which creates the &lt;code&gt;digraph&lt;/code&gt; representation of graphs) has to be applied explicitly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;xref#representation&quot;&gt;representation of graphs&lt;/a&gt;&lt;/code&gt; 의 목록 표현은 직접 호출을 분석하는 데 사용되는 반면, &lt;code&gt;digraph&lt;/code&gt; 표현은 간접 호출을 분석하는 데 적합합니다. 제한 연산자 ( &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; 및 &lt;code&gt;|||&lt;/code&gt; )는 두 표현을 모두 허용하는 유일한 연산자입니다. 즉, 제한을 사용하여 간접 호출을 분석하려면 그래프 의 &lt;code&gt;digraph&lt;/code&gt; 표현 을 작성하는 &lt;code&gt;closure&lt;/code&gt; 연산자를 명시 적으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffd5b9d0b2da7f031376ce2e3f4de1790dbcb873" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;Args&lt;/code&gt; no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is &lt;code&gt;'Argument__1'&lt;/code&gt;, the second &lt;code&gt;'Argument__2'&lt;/code&gt;, and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module.</source>
          <target state="translated">리스트 &lt;code&gt;Args&lt;/code&gt; 는 더 이상 인수를 포함하지 않지만 인수 수와 동일한 수의 원자를 포함합니다. 제 원자는 &lt;code&gt;'Argument__1'&lt;/code&gt; 번째 &lt;code&gt;'Argument__2'&lt;/code&gt; 등. 그 이유는 인수 목록이 많은 양의 메모리를 낭비 할 수 있고 인수 목록에 fun이 포함되어 있으면 모듈의 코드를 업그레이드하는 것이 불가능할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9fe5976fc2a1ed8cd95c6aebc522dfac26e44839" translate="yes" xml:space="preserve">
          <source>The list can also include any of the flags allowed in &lt;code&gt;erlang:trace/3&lt;/code&gt;</source>
          <target state="translated">이 목록에는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 에서 허용되는 플래그도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da6db7b25a7a041b2bd8a84f4bc3822e1da0eef8" translate="yes" xml:space="preserve">
          <source>The list can be retrieved with &lt;code&gt;&lt;a href=&quot;#env_compiler_options-0&quot;&gt;env_compiler_options/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#env_compiler_options-0&quot;&gt;env_compiler_options/0&lt;/a&gt;&lt;/code&gt; 으로 목록을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f867b0a6e2ade5a232d4c40764e78cd0cbf33e8" translate="yes" xml:space="preserve">
          <source>The list concatenation operator &lt;code&gt;++&lt;/code&gt; appends its second argument to its first and returns the resulting list.</source>
          <target state="translated">목록 연결 연산자 &lt;code&gt;++&lt;/code&gt; 는 두 번째 인수를 첫 번째 인수에 추가하고 결과 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32f8386d87e909841366c0d0ccad694e85e74074" translate="yes" xml:space="preserve">
          <source>The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order if these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">리스트에는 &lt;code&gt;Key&lt;/code&gt; 가 첫 번째 요소이고 &lt;code&gt;Value&lt;/code&gt; 가 두 번째 요소 인 두 개의 튜플이 포함 됩니다. 이 튜플이 정의되지 않은 경우 순서입니다. 다음 튜플이 목록에 포함될 수 있지만 앞으로 더 많은 튜플이 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bdaf0305629367e99487e912564f15660d944d8" translate="yes" xml:space="preserve">
          <source>The list is appended to any options given to &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/2&lt;/a&gt;&lt;/code&gt;. Use the alternative functions &lt;code&gt;&lt;a href=&quot;#noenv_file-2&quot;&gt;noenv_file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#noenv_forms-2&quot;&gt;noenv_forms/2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#noenv_output_generated-1&quot;&gt;noenv_output_generated/2&lt;/a&gt;&lt;/code&gt; if you do not want the environment variable to be consulted, for example, if you are calling the compiler recursively from inside a parse transform.</source>
          <target state="translated">목록은 &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/2&lt;/a&gt;&lt;/code&gt; 에 지정된 모든 옵션에 추가됩니다 . 환경 변수를 참조하지 않으려면 (예 : 구문 분석 변환 내부에서 컴파일러를 재귀 적으로 호출하는 경우) 대체 함수 &lt;code&gt;&lt;a href=&quot;#noenv_file-2&quot;&gt;noenv_file/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#noenv_forms-2&quot;&gt;noenv_forms/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#noenv_output_generated-1&quot;&gt;noenv_output_generated/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c3b32daab7fb1e19913c070d23e0ea4b8468b157" translate="yes" xml:space="preserve">
          <source>The list of (visible) nodes currently connected to is returned by &lt;code&gt;nodes()&lt;/code&gt;.</source>
          <target state="translated">현재 연결된 (보이는) 노드 목록은 &lt;code&gt;nodes()&lt;/code&gt; 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b60dab1d9d95dba89e1bcb54a37f2a68e4f7112c" translate="yes" xml:space="preserve">
          <source>The list of applications must contain the Kernel and STDLIB applications.</source>
          <target state="translated">응용 프로그램 목록에는 커널 및 STDLIB 응용 프로그램이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1993372f86c3ca2fcdaa4d4bdbaa44aa452f9b73" translate="yes" xml:space="preserve">
          <source>The list of arguments to the &lt;code&gt;init&lt;/code&gt; function of the callback module.</source>
          <target state="translated">콜백 모듈 의 &lt;code&gt;init&lt;/code&gt; 함수에 대한 인수 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="4a7dbd6dc14496e939ba002f5d8d58309bf69a66" translate="yes" xml:space="preserve">
          <source>The list of attributes becomes empty if the module is stripped with the &lt;code&gt;beam_lib(3)&lt;/code&gt; module (in STDLIB).</source>
          <target state="translated">&lt;code&gt;beam_lib(3)&lt;/code&gt; 에서 beam_lib (3) 모듈로 모듈을 제거하면 속성 목록이 비게됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e28c0b378c7e30234825e4c28e09987fea8b7d5" translate="yes" xml:space="preserve">
          <source>The list of attributes is sorted on &lt;code&gt;Attribute&lt;/code&gt; (in &lt;code&gt;attrib_entry()&lt;/code&gt;) and each attribute name occurs once in the list. The attribute values occur in the same order as in the file. The lists of functions are also sorted.</source>
          <target state="translated">속성의 목록에 정렬 &lt;code&gt;Attribute&lt;/code&gt; (에 &lt;code&gt;attrib_entry()&lt;/code&gt; )를 각 속성 이름이 목록에 한 번 발생합니다. 속성 값은 파일과 동일한 순서로 발생합니다. 기능 목록도 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="2ab8914ad054b49e90cc2dd0c7617689deb0ec65" translate="yes" xml:space="preserve">
          <source>The list of binaries used for search alternatives must be flat and proper.</source>
          <target state="translated">대체 검색에 사용되는 바이너리 목록은 단순하고 적절해야합니다.</target>
        </trans-unit>
        <trans-unit id="4aa24e9ead310fa857b3ae54bebbc5e4c77a275b" translate="yes" xml:space="preserve">
          <source>The list of column names is ordered in the same way as the list of values of a row, e.g. the first &lt;code&gt;ColName&lt;/code&gt; is associated with the first &lt;code&gt;Value&lt;/code&gt; in a &lt;code&gt;Row&lt;/code&gt;.</source>
          <target state="translated">열 이름 목록은 행 값 목록과 같은 방식으로 정렬됩니다. 예를 들어 첫 번째 &lt;code&gt;ColName&lt;/code&gt; 은 첫 번째 &lt;code&gt;Value&lt;/code&gt; in a &lt;code&gt;Row&lt;/code&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="e441bd917def7eab6debc68f650fc15899ecb1b8" translate="yes" xml:space="preserve">
          <source>The list of examples can be made long. One need a kind of knowledge that was not needed when programs only considered one or two languages. The complexity of human languages and scripts has certainly made this a challenge when constructing a universal standard. Supporting Unicode properly in your program will require effort.</source>
          <target state="translated">예제 목록을 길게 만들 수 있습니다. 프로그램은 하나 또는 두 개의 언어 만 고려할 때 필요하지 않은 일종의 지식이 필요합니다. 인간 언어와 스크립트의 복잡성으로 인해 보편적 인 표준을 구성 할 때이 문제를 해결해야합니다. 프로그램에서 유니 코드를 올바르게 지원하려면 노력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e9263bcdcc9a4162758b1c2d0636a8277b41c8e1" translate="yes" xml:space="preserve">
          <source>The list of protocols is in order of preference. The protocol negotiated will be the first in the list that matches one of the protocols advertised by the client. If no protocol matches, the server will fail the connection with a &quot;no_application_protocol&quot; alert.</source>
          <target state="translated">프로토콜 목록은 기본 설정 순서입니다. 협상 된 프로토콜은 목록에서 클라이언트가 알리는 프로토콜 중 하나와 일치하는 첫 번째 프로토콜입니다. 일치하는 프로토콜이 없으면 서버는 &quot;no_application_protocol&quot;경고로 연결에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4a34fbb4766ea85a1f9d8f22cb9859cc99bb888c" translate="yes" xml:space="preserve">
          <source>The list of protocols must not contain an empty binary.</source>
          <target state="translated">프로토콜 목록에는 빈 바이너리가 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c9fbf59d4843615920d8035868251705ea8faee6" translate="yes" xml:space="preserve">
          <source>The list of protocols supported by the client to be sent to the server to be used for an Application-Layer Protocol Negotiation (ALPN). If the server supports ALPN then it will choose a protocol from this list; otherwise it will fail the connection with a &quot;no_application_protocol&quot; alert. A server that does not support ALPN will ignore this value.</source>
          <target state="translated">ALPN (Application-Layer Protocol Negotiation)에 사용하기 위해 클라이언트가 서버로 전송하도록 지원하는 프로토콜 목록. 서버가 ALPN을 지원하면이 목록에서 프로토콜을 선택합니다. 그렇지 않으면 &quot;no_application_protocol&quot;경고와의 연결에 실패합니다. ALPN을 지원하지 않는 서버는이 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d7ac87c7d4335021ee1fa77bdee81b3d2fc28da7" translate="yes" xml:space="preserve">
          <source>The list of scheduler information is unsorted and can appear in different order between calls.</source>
          <target state="translated">스케줄러 정보 목록이 정렬되지 않았으며 통화간에 다른 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53177127ac53807caaec1a5f4ac0ff7d969ee202" translate="yes" xml:space="preserve">
          <source>The list of thread information is unsorted and can appear in different order between calls.</source>
          <target state="translated">스레드 정보 목록이 정렬되지 않았으며 호출간에 다른 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6ff9051ce3adf391b324c7141d157fd50f0f8f" translate="yes" xml:space="preserve">
          <source>The list structure is invalid (a number as tail).</source>
          <target state="translated">목록 구조가 유효하지 않습니다 (꼬리 번호).</target>
        </trans-unit>
        <trans-unit id="90359ff88196faa6388683deff22b771581b0f36" translate="yes" xml:space="preserve">
          <source>The list subtraction operator &lt;code&gt;--&lt;/code&gt; produces a list that is a copy of the first argument. The procedure is a follows: for each element in the second argument, the first occurrence of this element (if any) is removed.</source>
          <target state="translated">목록 빼기 연산자 &lt;code&gt;--&lt;/code&gt; 첫 번째 인수의 사본 인 목록을 생성합니다. 절차는 다음과 같습니다. 두 번째 인수의 각 요소에 대해이 요소의 첫 번째 항목 (있는 경우)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="015b99d661bab28e17445e0783bc50c17f9fd517" translate="yes" xml:space="preserve">
          <source>The listed applications are not only original Erlang/OTP applications but possibly also new applications that you have written (here exemplified by the application Pea (&lt;code&gt;pea&lt;/code&gt;)).</source>
          <target state="translated">나열된 응용 프로그램은 원래 Erlang / OTP 응용 프로그램 일뿐만 아니라 사용자가 작성한 새 응용 프로그램 일 수도 있습니다 (여기서는 Pea ( &lt;code&gt;pea&lt;/code&gt; 응용 프로그램으로 표시 )).</target>
        </trans-unit>
        <trans-unit id="b1a6d7b7d2505dd4415caa1c747f640e87d05200" translate="yes" xml:space="preserve">
          <source>The listing shows &lt;code&gt;mnesia_locker&lt;/code&gt;, a process, has highly contended locks.</source>
          <target state="translated">목록은 프로세스 인 &lt;code&gt;mnesia_locker&lt;/code&gt; 가 고도로 경합 된 잠금을 가지고 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7824d7fdf06f507845f19aac3e93cad24e62691c" translate="yes" xml:space="preserve">
          <source>The lists are (named as in the SSH application's options):</source>
          <target state="translated">목록은 SSH 응용 프로그램의 옵션에서와 같이 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e47f7860f16d8f455b34192361d141ea74928549" translate="yes" xml:space="preserve">
          <source>The literal character &quot;]&quot; cannot be the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if &quot;]&quot; is escaped with a backslash, it is interpreted as the end of range, so [W-\]46] is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range.</source>
          <target state="translated">리터럴 문자 &quot;]&quot;는 범위의 끝 문자 일 수 없습니다. [W-] 46]과 같은 패턴은 두 문자 클래스 ( &quot;W&quot;및 &quot;-&quot;)와 리터럴 문자열 &quot;46]&quot;으로 해석되므로 &quot;W46]&quot;또는 &quot;-46]과 일치합니다. &quot;. 그러나 &quot;]&quot;가 백 슬래시로 이스케이프되면 범위의 끝으로 해석되므로 [W-\] 46]은 범위와 그 뒤에 다른 두 문자가 포함 된 클래스로 해석됩니다. &quot;]&quot;의 8 진 또는 16 진 표현을 사용하여 범위를 종료 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a151d7c8c495b43d8c9ca28cb4fd22e5563c1c3" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded (open ports use it). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;mostly&lt;/strong&gt; occurs when options &lt;code&gt;{reload,pending_driver}&lt;/code&gt; or &lt;code&gt;{reload,pending}&lt;/code&gt; are used, but &lt;strong&gt;can&lt;/strong&gt; occur when another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is unloading a driver in parallel and driver option &lt;code&gt;kill_ports&lt;/code&gt; is set. In other words, this return value always needs to be handled.</source>
          <target state="translated">로드 요청이 등록되었지만 드라이버의 이전 인스턴스가 여전히 언로드되기를 기다리고 있기 때문에로드가 지연됩니다 (오픈 포트에서 사용). 여전히 드라이버 사용이 끝나면 언로드가 예상됩니다. 이 반환 값은 &lt;strong&gt;대부분&lt;/strong&gt; 옵션이 때 발생하는 &lt;code&gt;{reload,pending_driver}&lt;/code&gt; 또는 &lt;code&gt;{reload,pending}&lt;/code&gt; 사용되지만, &lt;strong&gt;수&lt;/strong&gt; 다른 때 발생하는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 병렬 및 드라이버 옵션에서 드라이버를 언로드 &lt;code&gt;kill_ports&lt;/code&gt; 세트입니다. 즉,이 반환 값은 항상 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="93816305e042fa9b1290121579e7bab7986a2b27" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded by another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (not only by a port, in which case &lt;code&gt;{ok,pending_driver}&lt;/code&gt; would have been returned). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;only&lt;/strong&gt; occurs when option &lt;code&gt;{reload,pending}&lt;/code&gt; is used.</source>
          <target state="translated">로드 요청이 등록되었지만 드라이버의 이전 인스턴스가 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 의해 언로드되기를 기다리고 있기 때문에로드가 지연됩니다 (포트뿐만 아니라 &lt;code&gt;{ok,pending_driver}&lt;/code&gt; 가 리턴 된 경우). 여전히 드라이버 사용이 끝나면 언로드가 예상됩니다. 이 리턴 값 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;{reload,pending}&lt;/code&gt; 옵션 이 사용 된 경우 &lt;strong&gt;에만&lt;/strong&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="82d30f913008685e194b4636bf5269a0b248f283" translate="yes" xml:space="preserve">
          <source>The load values are proportional to how long time a runnable Unix process has to spend in the run queue before it is scheduled. Accordingly, higher values mean more system load. The returned value divided by 256 produces the figure displayed by &lt;code&gt;rup&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt;. What is displayed as 2.00 in &lt;code&gt;rup&lt;/code&gt;, is displayed as load up to the second mark in &lt;code&gt;xload&lt;/code&gt;.</source>
          <target state="translated">로드 값은 실행 가능한 Unix 프로세스가 스케줄되기 전에 실행 큐에서 소요되는 시간에 비례합니다. 따라서 값이 클수록 더 많은 시스템로드를 의미합니다. 반환 값을 256으로 나눈 값은 &lt;code&gt;rup&lt;/code&gt; 과 &lt;code&gt;top&lt;/code&gt; 으로 표시되는 숫자를 생성합니다 . &lt;code&gt;rup&lt;/code&gt; 에 2.00으로 표시되는 것은 &lt;code&gt;xload&lt;/code&gt; 의 두 번째 표시까지로드로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e778b9f1baa2ba78c9a8b99dac7d82d4dd62545a" translate="yes" xml:space="preserve">
          <source>The local address of the socket.</source>
          <target state="translated">소켓의 로컬 주소</target>
        </trans-unit>
        <trans-unit id="2cbe8d9027d2e67a3221c97411a93a55c403aba2" translate="yes" xml:space="preserve">
          <source>The local hostname.</source>
          <target state="translated">로컬 호스트 이름</target>
        </trans-unit>
        <trans-unit id="0d70c0c380895bb03a1a2bbd03acd9232797565f" translate="yes" xml:space="preserve">
          <source>The local mid (of the connection, i.e. the own mid). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="translated">로컬 미드 (연결의 중간 미드) &lt;code&gt;megaco_mid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ca9eb8c2f734b6ef1d76976ee366124ff598fcc" translate="yes" xml:space="preserve">
          <source>The local node is not alive.</source>
          <target state="translated">로컬 노드가 활성 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9da45befb57e0a6e8d60cb2a231a07186dafa5dc" translate="yes" xml:space="preserve">
          <source>The local process was monitoring the remote process at the time of the crash.</source>
          <target state="translated">로컬 프로세스가 충돌 당시 원격 프로세스를 모니터링하고있었습니다.</target>
        </trans-unit>
        <trans-unit id="0faaeec49d245a46502b8c7536db4c7e2f24fafe" translate="yes" xml:space="preserve">
          <source>The location of the Erlang emulator. The default is the &lt;code&gt;erl.exe&lt;/code&gt; located in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. Do not specify &lt;code&gt;werl.exe&lt;/code&gt; as this emulator, it will not work.</source>
          <target state="translated">Erlang 에뮬레이터의 위치입니다. 기본값은 &lt;code&gt;erl.exe&lt;/code&gt; 와 동일한 디렉토리에있는 &lt;code&gt;erlsrv.exe&lt;/code&gt; 입니다. 이 에뮬레이터로 &lt;code&gt;werl.exe&lt;/code&gt; 를 지정하지 않으면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94ca339fcbea0bf957948c562687f39b4e2a7718" translate="yes" xml:space="preserve">
          <source>The location of the file &lt;code&gt;start_erl.data&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;start_erl.data&lt;/code&gt; 파일의 위치</target>
        </trans-unit>
        <trans-unit id="67a812bb246705dde14edb442f878d3a06f58d28" translate="yes" xml:space="preserve">
          <source>The lock is acquired on &lt;code&gt;LockItem&lt;/code&gt; on all nodes in the node list.</source>
          <target state="translated">잠금은 노드 목록의 모든 노드에서 &lt;code&gt;LockItem&lt;/code&gt; 에 대해 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb95c03b38e9e250b3764b1b69a94cf910fd3f1f" translate="yes" xml:space="preserve">
          <source>The log can be either a &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; or a &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">로그는 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8084a2197c0ae9cceee71abbb7d30557e1d027d1" translate="yes" xml:space="preserve">
          <source>The log event used in the examples is:</source>
          <target state="translated">예제에서 사용 된 로그 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33cf2a0cd54fceab0e5adde86b3ea4f3d0186889" translate="yes" xml:space="preserve">
          <source>The log file grows continuously and must be dumped at regular intervals. &quot;Dumping the log file&quot; means that &lt;code&gt;Mnesia&lt;/code&gt; performs all the operations listed in the log and place the records in the corresponding &lt;code&gt;.DAT&lt;/code&gt;, &lt;code&gt;.DCD&lt;/code&gt;, and &lt;code&gt;.DCL&lt;/code&gt; data files. For example, if the operation &quot;write record &lt;code&gt;{foo, 4, elvis, 6}&lt;/code&gt;&quot; is listed in the log, &lt;code&gt;Mnesia&lt;/code&gt; inserts the operation into the file &lt;code&gt;foo.DCL&lt;/code&gt;. Later, when &lt;code&gt;Mnesia&lt;/code&gt; thinks that the &lt;code&gt;.DCL&lt;/code&gt; file is too large, the data is moved to the &lt;code&gt;.DCD&lt;/code&gt; file. The dumping operation can be time consuming if the log is large. Notice that the &lt;code&gt;Mnesia&lt;/code&gt; system continues to operate during log dumps.</source>
          <target state="translated">로그 파일은 지속적으로 커지므로 정기적으로 덤프해야합니다. &quot;로그 파일 덤프&quot;는 &lt;code&gt;Mnesia&lt;/code&gt; 가 로그에 나열된 모든 작업을 수행하고 해당 &lt;code&gt;.DAT&lt;/code&gt; , &lt;code&gt;.DCD&lt;/code&gt; 및 &lt;code&gt;.DCL&lt;/code&gt; 데이터 파일에 레코드를 배치 함을 의미 합니다. 조작 &quot;쓰기 기록 예를 들어, &lt;code&gt;{foo, 4, elvis, 6}&lt;/code&gt; &quot;로그에 나열되어, &lt;code&gt;Mnesia&lt;/code&gt; 는 파일에 작업을 삽입 &lt;code&gt;foo.DCL&lt;/code&gt; 을 . 나중에 &lt;code&gt;Mnesia&lt;/code&gt; 가 &lt;code&gt;.DCL&lt;/code&gt; 파일이 너무 크다고 생각 하면 데이터가 &lt;code&gt;.DCD&lt;/code&gt; 파일 로 이동 됩니다. 로그가 크면 덤프 작업에 시간이 오래 걸릴 수 있습니다. 공지 사항 그 &lt;code&gt;Mnesia&lt;/code&gt; 시스템은 로그 덤프 중에 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="05378e99ad67de335df2edd4587676257847240f" translate="yes" xml:space="preserve">
          <source>The log files are written continuously during a test run and links are always created initially when a test starts. Thevtest progress can therefore be followed simply by refreshing pages in the HTML browser. Statistics totals are not presented until a test is complete however.</source>
          <target state="translated">로그 파일은 테스트 실행 중에 지속적으로 작성되며 테스트 시작시 항상 초기에 링크가 작성됩니다. 따라서 HTML 브라우저에서 페이지를 새로 고치면 가장 쉽게 진행 상황을 확인할 수 있습니다. 그러나 테스트가 완료 될 때까지 통계 총계가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09d8292095f3c463951aa3a38fcb81bdb1a77b22" translate="yes" xml:space="preserve">
          <source>The log files, that is:</source>
          <target state="translated">로그 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdf4f4a2f484ace5b99188170053805f051195" translate="yes" xml:space="preserve">
          <source>The log function takes three arguments, &lt;code&gt;fun(Level, FormatString, [FormatArg]) end&lt;/code&gt;.</source>
          <target state="translated">로그 함수는 &lt;code&gt;fun(Level, FormatString, [FormatArg]) end&lt;/code&gt; 세 가지 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="70e83f6de81bba1e8369d3fb4c74e2e701680bf9" translate="yes" xml:space="preserve">
          <source>The log is also dumped at startup and whenever a schema operation is performed.</source>
          <target state="translated">로그는 시작시와 스키마 작업이 수행 될 때마다 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="3e63f405b602b189c562910f99bbf0f61b97eb9a" translate="yes" xml:space="preserve">
          <source>The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로그 레벨을 error 또는 info로 변경할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="52f3c1c01d0caa39ade0e63e03754a32f5ea8746" translate="yes" xml:space="preserve">
          <source>The log level for a module overrides the primary log level of Logger for log events originating from the module in question. Notice, however, that it does not override the level configuration for any handler.</source>
          <target state="translated">모듈의 로그 레벨은 해당 모듈에서 발생하는 로그 이벤트에 대한 기본 로그 레벨의 로거를 대체합니다. 그러나 핸들러의 레벨 구성을 대체하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ef6ed5dbe5f350a3677cd9b499598f99164de3e" translate="yes" xml:space="preserve">
          <source>The log level indicates the severity of a event. In accordance with the Syslog protocol, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5424.txt&quot;&gt;RFC 5424&lt;/a&gt;&lt;/code&gt;, eight log levels can be specified. The following table lists all possible log levels by name (atom), integer value, and description:</source>
          <target state="translated">로그 수준은 이벤트의 심각도를 나타냅니다. Syslog 프로토콜 인 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5424.txt&quot;&gt;RFC 5424&lt;/a&gt;&lt;/code&gt; 에 따라 8 개의 로그 레벨을 지정할 수 있습니다. 다음 표는 가능한 모든 로그 수준을 이름 (원자), 정수 값 및 설명별로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="1fc6320a2d9c1fb41416707d45873416f2a21be8" translate="yes" xml:space="preserve">
          <source>The log level is specified when adding the handler, or changed during runtime with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로그 레벨은 핸들러를 추가 할 때 지정되거나 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="21c56bbe5854873ac255ff079279c9dff663d1fe" translate="yes" xml:space="preserve">
          <source>The log message can also be provided through a fun for lazy evaluation. The fun is only evaluated if the primary log level check passes, and is therefore recommended if it is expensive to generate the message. The lazy fun must return a string, a report, or a tuple with format string and arguments.</source>
          <target state="translated">게으른 평가를위한 재미를 통해 로그 메시지를 제공 할 수도 있습니다. 재미는 기본 로그 수준 검사가 통과 한 경우에만 평가되므로 메시지를 생성하는 데 비용이 많이 드는 경우 권장됩니다. 게으른 재미는 문자열, 보고서 또는 형식 문자열과 인수가있는 튜플을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="148877212af3299aabd6e2e80464a605727cd9f4" translate="yes" xml:space="preserve">
          <source>The log message contains the information to be logged. The message can consist of a format string and arguments (given as two separate parameters in the Logger API), a string or a report. The latter, which is either a map or a key-value list, can be accompanied by a &lt;strong&gt;report callback&lt;/strong&gt; specified in the log event's &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt;. The report callback is a convenience function that the &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; can use to convert the report to a format string and arguments. The formatter can also use its own conversion function, if no callback is provided, or if a customized formatting is desired.</source>
          <target state="translated">로그 메시지에는 기록 할 정보가 포함됩니다. 메시지는 형식 문자열과 인수 (Logger API에서 두 개의 개별 매개 변수로 제공됨), 문자열 또는 보고서로 구성 될 수 있습니다. 후자는 맵 또는 키-값 목록이며 로그 이벤트의 &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt; 지정된 &lt;strong&gt;보고서 콜백을&lt;/strong&gt; 동반 할 수 있습니다 . 보고서 콜백은 &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; 가 보고서를 형식 문자열 및 인수로 변환하는 데 사용할 수 있는 편리한 기능입니다 . 콜백이 제공되지 않거나 사용자 정의 된 형식이 필요한 경우 포맷터는 자체 변환 기능을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e0c9afffef01563d1e914bbb564b164c5c43598" translate="yes" xml:space="preserve">
          <source>The log type. Defaults to &lt;code&gt;halt&lt;/code&gt;.</source>
          <target state="translated">로그 유형 기본값은 &lt;code&gt;halt&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e28a2d8b5a958d67c48ee8bc4c5069e252d9e6f6" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpa#log_to_txt&quot;&gt;snmpa:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">로그는 로그 메커니즘에 필요한 CPU로드를 최소화하기 위해 원시 데이터 형식 (기본적으로 BER 인코딩 된 메시지)을 사용합니다. 즉, 로그는 사람이 읽을 수 없지만 읽기 전에 오프라인으로 포맷해야합니다. &lt;code&gt;&lt;a href=&quot;snmpa#log_to_txt&quot;&gt;snmpa:log_to_txt&lt;/a&gt;&lt;/code&gt; 위해 snmpa : log_to_txt 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="286976b20277382019a10c4770aeb782c67d3c09" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpm#log_to_txt&quot;&gt;snmpm:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">로그는 로그 메커니즘에 필요한 CPU로드를 최소화하기 위해 원시 데이터 형식 (기본적으로 BER 인코딩 된 메시지)을 사용합니다. 즉, 로그는 사람이 읽을 수 없지만 읽기 전에 오프라인으로 포맷해야합니다. &lt;code&gt;&lt;a href=&quot;snmpm#log_to_txt&quot;&gt;snmpm:log_to_txt&lt;/a&gt;&lt;/code&gt; 위해 snmpm : log_to_txt 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96b3fd02f414c107ec8f4bbb84dfc360fb88eb27" translate="yes" xml:space="preserve">
          <source>The long synonyms for property names supported by Perl (such as \p{Letter}) are not supported by PCRE. It is not permitted to prefix any of these properties with &quot;Is&quot;.</source>
          <target state="translated">Perl에서 지원하는 속성 이름에 대한 긴 동의어 (예 : \ p {Letter})는 PCRE에서 지원되지 않습니다. 이러한 속성 앞에 &quot;Is&quot;를 붙일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf1f5fae62661eca849a838d180479af9bffc0a1" translate="yes" xml:space="preserve">
          <source>The look and feel on an Erlang shell inside Emacs should be the same as in a normal Erlang shell. There is just one major difference, the cursor keys will actually move the cursor around just like in any normal Emacs buffer. The command line history can be accessed by the following commands:</source>
          <target state="translated">Emacs 내부의 Erlang 쉘의 모양과 느낌은 일반적인 Erlang 쉘과 동일해야합니다. 주요 차이점은 한 가지뿐입니다. 커서 키는 실제로 일반 Emacs 버퍼 에서처럼 커서를 움직입니다. 명령 행 히스토리는 다음 명령으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0df7a98e001c7e4a5d47744bc177ec50ac6e7aac" translate="yes" xml:space="preserve">
          <source>The lookup fun is to defined as follows:</source>
          <target state="translated">조회 재미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="026bec80693d2fc446353c2345ce4713bd83e4e1" translate="yes" xml:space="preserve">
          <source>The lookup function is optional. It is assumed that the lookup function always finds values much faster than it would take to traverse the table. The first argument is the position of the key. As &lt;code&gt;qlc_next/1&lt;/code&gt; returns the objects as &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, the position is 1. Notice that the lookup function is to return &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, as the traversal function does.</source>
          <target state="translated">조회 기능은 선택 사항입니다. 찾아보기 기능은 항상 테이블을 탐색하는 데 걸리는 것보다 훨씬 빠르게 값을 찾는 것으로 가정합니다. 첫 번째 인수는 키의 위치입니다. 으로 &lt;code&gt;qlc_next/1&lt;/code&gt; 객체로 반환 &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; 쌍 위치는 검색 기능이 반환하는 것입니다 1. 공지 사항입니다 &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; 순회 함수가 같이 쌍.</target>
        </trans-unit>
        <trans-unit id="fabd07160cb884d874c4f9a6b01df339b79b9bb2" translate="yes" xml:space="preserve">
          <source>The lookup method &lt;code&gt;string&lt;/code&gt; tries to parse the hostname as an IPv4 or IPv6 string and return the resulting IP address. It is automatically tried first when &lt;code&gt;native&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; in the &lt;code&gt;Methods&lt;/code&gt; list. To skip it in this case, the pseudo lookup method &lt;code&gt;nostring&lt;/code&gt; can be inserted anywhere in the &lt;code&gt;Methods&lt;/code&gt; list.</source>
          <target state="translated">조회 메소드 &lt;code&gt;string&lt;/code&gt; 은 호스트 이름을 IPv4 또는 IPv6 문자열로 구문 분석하고 결과 IP 주소를 리턴합니다. 때 자동으로 처음 시도되는 &lt;code&gt;native&lt;/code&gt; 입니다 &lt;strong&gt;하지&lt;/strong&gt; 의 &lt;code&gt;Methods&lt;/code&gt; 목록입니다. 이 경우이를 건너 뛰기 위해 유사 조회 메소드 &lt;code&gt;nostring&lt;/code&gt; 을 &lt;code&gt;Methods&lt;/code&gt; 목록의 아무 곳에 나 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97cdecdfe5db74108a6e54e74406dd0b623db1c5" translate="yes" xml:space="preserve">
          <source>The lowest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="translated">이 노드가 처리 할 수있는 최저 배포 버전입니다. Erlang / OTP R6B 이상의 값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="f0b970e479bf0315a32496d0381fe4d1214762f9" translate="yes" xml:space="preserve">
          <source>The machine name, &lt;code&gt;'BEAM'&lt;/code&gt;.</source>
          <target state="translated">기계 이름, &lt;code&gt;'BEAM'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afb285d4f389b85ea26f3cda19e5a047be514a48" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text)&lt;/code&gt; expands to &lt;code&gt;merl:quote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="translated">매크로 &lt;code&gt;?Q(Text)&lt;/code&gt; 는 &lt;code&gt;merl:quote(?LINE, Text, Env)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="111750be1ff5da23f444d310ece95b7d465283a5" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text, Env)&lt;/code&gt; expands to &lt;code&gt;merl:qquote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="translated">매크로 &lt;code&gt;?Q(Text, Env)&lt;/code&gt; 는 &lt;code&gt;merl:qquote(?LINE, Text, Env)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9e862588129d877f212f0bfde0ba3a46758cc8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;ENSURE&lt;/code&gt; (line 5-10) is used to ensure that the buffer is large enough for the answer. We switch on the command and take actions. We always have read select active on a port in &lt;code&gt;data&lt;/code&gt; mode (achieved by calling &lt;code&gt;do_recv&lt;/code&gt; on line 45), but we turn off read selection in &lt;code&gt;intermediate&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt; modes (line 27 and 36).</source>
          <target state="translated">매크로 &lt;code&gt;ENSURE&lt;/code&gt; (라인 5-10)는 버퍼가 응답하기에 충분히 큰지 확인하는 데 사용됩니다. 명령을 켜고 조치를 취합니다. 우리는 항상 &lt;code&gt;data&lt;/code&gt; 모드 ( 45 행에서 &lt;code&gt;do_recv&lt;/code&gt; 를 호출 하여)의 포트에서 읽기 선택을 활성화 했지만 &lt;code&gt;intermediate&lt;/code&gt; 및 &lt;code&gt;command&lt;/code&gt; 모드 (27 및 36 행) 에서 읽기 선택을 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="dfa60ec98993e6c63f6b1ebab600c7c27efb5263" translate="yes" xml:space="preserve">
          <source>The macro directives cannot be used inside functions.</source>
          <target state="translated">매크로 지시문은 함수 내에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5c84a81d3e29ec48f2e8baa4f7a70afaa858f2c" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;ERL_ATOM_PTR&lt;/code&gt; and &lt;code&gt;ERL_INT_VALUE&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt; can be used to obtain the actual values of the atom and the integer. The atom value is represented as a string. By comparing this value with the strings &quot;foo&quot; and &quot;bar&quot;, it can be decided which function to call:</source>
          <target state="translated">매크로 &lt;code&gt;ERL_ATOM_PTR&lt;/code&gt; 및 &lt;code&gt;ERL_INT_VALUE&lt;/code&gt; 에서 &lt;code&gt;erl_eterm&lt;/code&gt; 는 원자와 정수의 실제 값을 구하는데 사용될 수있다. 원자 값은 문자열로 표시됩니다. 이 값을 문자열 &quot;foo&quot;및 &quot;bar&quot;와 비교하여 호출 할 함수를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6a4c157f57c6d503002b41adbc5bd71b9008ba" translate="yes" xml:space="preserve">
          <source>The magic cookie of the local node is retrieved by calling &lt;code&gt;erlang:get_cookie()&lt;/code&gt;.</source>
          <target state="translated">로컬 노드의 매직 쿠키는 &lt;code&gt;erlang:get_cookie()&lt;/code&gt; 호출하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a05f6bcadc54f796f0b1fd5def2686d750e1700" translate="yes" xml:space="preserve">
          <source>The main (outer) loop for a process &lt;strong&gt;must&lt;/strong&gt; be tail-recursive. Otherwise, the stack grows until the process terminates.</source>
          <target state="translated">프로세스의 기본 (외부) 루프는 테일 재귀 &lt;strong&gt;여야합니다&lt;/strong&gt; . 그렇지 않으면 프로세스가 종료 될 때까지 스택이 커집니다.</target>
        </trans-unit>
        <trans-unit id="255b30701b0f9daa4744f53b6adde340892fc688" translate="yes" xml:space="preserve">
          <source>The main advantage of dividing systems into global groups is that the background load decreases while the number of nodes to be updated is reduced when manipulating globally registered names.</source>
          <target state="translated">시스템을 전역 그룹으로 나누면 얻을 수있는 주요 이점은 전체적으로 등록 된 이름을 조작 할 때 백그라운드로드가 줄어들고 업데이트 할 노드 수가 줄어든다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bac27c9210ec680873a11c4354804a354e76059" translate="yes" xml:space="preserve">
          <source>The main advantage of using records rather than tuples is that fields in a record are accessed by name, whereas fields in a tuple are accessed by position. To illustrate these differences, suppose that you want to represent a person with the tuple &lt;code&gt;{Name, Address, Phone}&lt;/code&gt;.</source>
          <target state="translated">튜플 대신 레코드를 사용하는 주요 이점은 레코드의 필드는 이름으로 액세스하는 반면 튜플의 필드는 위치로 액세스한다는 것입니다. 이러한 차이점을 설명하기 위해 튜플 &lt;code&gt;{Name, Address, Phone}&lt;/code&gt; 인 사람을 나타내려고한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b014077cb1006ff99f29813775f91d4f9609fb7b" translate="yes" xml:space="preserve">
          <source>The main benefit of constants is that they can be used to reduce the size (and avoid repetition) of long strings, such as file paths.</source>
          <target state="translated">상수의 주요 이점은 파일 경로와 같은 긴 문자열의 크기를 줄이고 반복을 피하는 데 사용될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a935bee785d5a929b8af32300cdaed69bbcdc5fe" translate="yes" xml:space="preserve">
          <source>The main execution threads that do most of the work. See &lt;code&gt;erl +S&lt;/code&gt; for more details.</source>
          <target state="translated">대부분의 작업을 수행하는 기본 실행 스레드입니다. 자세한 내용은 &lt;code&gt;erl +S&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44bd22c67eb6433073dc2e343a3a6d7e1322b4de" translate="yes" xml:space="preserve">
          <source>The main features of SNMPv2 compared to SNMPv1 are:</source>
          <target state="translated">SNMPv1과 비교 한 SNMPv2의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f987baf10d1a6cef3c887c260f84f36bcc967860" translate="yes" xml:space="preserve">
          <source>The main idea in the model is that it is not tied to any specific management protocol. An Application Programming Interface (API) is defined, which can be used to write adaptations for specific management protocols.</source>
          <target state="translated">모델의 주요 아이디어는 특정 관리 프로토콜과 관련이 없다는 것입니다. 특정 관리 프로토콜에 대한 적응을 작성하는 데 사용할 수있는 API (Application Programming Interface)가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d206b097b388ff06479821f31341df73bd37fd" translate="yes" xml:space="preserve">
          <source>The main idea is that the resource sends the notifications as Erlang terms to a dedicated &lt;code&gt;gen_event&lt;/code&gt; process. Into this process, handlers for the different management protocols are installed. When an event is received by this process, it is forwarded to each installed handler. The handlers are responsible for translating the event into a notification to be sent over the management protocol. For example, a handler for SNMP translates each event into an SNMP trap.</source>
          <target state="translated">주요 아이디어는 자원이 알림을 Erlang 용어로 전용 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 보냅니다 . 이 프로세스에는 다양한 관리 프로토콜에 대한 처리기가 설치됩니다. 이 프로세스가 이벤트를 수신하면 설치된 각 핸들러로 전달됩니다. 핸들러는 이벤트를 관리 프로토콜을 통해 전송 될 알림으로 변환해야합니다. 예를 들어, SNMP 처리기는 각 이벤트를 SNMP 트랩으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="47a8cc665e1c479e686529aed490a0ed53790936" translate="yes" xml:space="preserve">
          <source>The main idea with the &lt;code&gt;erts_alloc&lt;/code&gt; library is to separate memory blocks that are used differently into different memory areas, to achieve less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</source>
          <target state="translated">&lt;code&gt;erts_alloc&lt;/code&gt; 라이브러리 의 주요 아이디어 는 다른 메모리 영역으로 다르게 사용되는 메모리 블록을 분리하여 메모리 조각화를 줄이는 것입니다. 덜 자주 할당되는 메모리 블록보다 자주 할당되는 메모리 블록에 적합한 것을 찾는 노력을 줄이면 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="68792cbe81e714a76ce3bda5abbbd3fd1ba75cb7" translate="yes" xml:space="preserve">
          <source>The main loop receives messages from the client (which can use the the &lt;code&gt;io&lt;/code&gt; module to send requests). For each request, the function &lt;code&gt;request/2&lt;/code&gt; is called and a reply is eventually sent using function &lt;code&gt;reply/3&lt;/code&gt;.</source>
          <target state="translated">기본 루프는 클라이언트로부터 메시지를받습니다 ( &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 요청을 보낼 수 있음). 각 요청에 대해 함수 &lt;code&gt;request/2&lt;/code&gt; 가 호출되고 결국 &lt;code&gt;reply/3&lt;/code&gt; 함수를 사용하여 응답이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a881d2bf8e074a4ba8b926654caec623f66ddd76" translate="yes" xml:space="preserve">
          <source>The main purpose of benchmarking is to find out which implementation of a given algorithm or function is the fastest. Benchmarking is far from an exact science. Today's operating systems generally run background tasks that are difficult to turn off. Caches and multiple CPU cores does not facilitate benchmarking. It would be best to run UNIX computers in single-user mode when benchmarking, but that is inconvenient to say the least for casual testing.</source>
          <target state="translated">벤치마킹의 주요 목적은 주어진 알고리즘 또는 함수의 구현이 가장 빠른 것을 찾는 것입니다. 벤치마킹은 정확한 과학과는 거리가 멀다. 오늘날의 운영 체제는 일반적으로 해제하기 어려운 백그라운드 작업을 실행합니다. 캐시와 여러 CPU 코어는 벤치마킹을 용이하게하지 않습니다. 벤치마킹 할 때 단일 사용자 모드에서 UNIX 컴퓨터를 실행하는 것이 가장 좋지만, 일반적인 테스트에서는 가장 불편한 것은 불편합니다.</target>
        </trans-unit>
        <trans-unit id="2d7cf0f3407ae9a11f3bfd8fb13ccb306f69fca2" translate="yes" xml:space="preserve">
          <source>The main purpose of the history buffer is the possibility to create configuration files. Any function stored in the history buffer can be written to a configuration file and used for creating a specific configuration at any time with a single function call.</source>
          <target state="translated">히스토리 버퍼의 주요 목적은 구성 파일을 작성하는 것입니다. 히스토리 버퍼에 저장된 모든 함수는 구성 파일에 기록 될 수 있으며 단일 함수 호출로 언제든지 특정 구성을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3a2d3d740cc729d95dfc1aed7685f23aefe5460" translate="yes" xml:space="preserve">
          <source>The main purpose of this verb is to track how a match was arrived at, although it also has a secondary use in with advancing the match starting point (see (*SKIP) below).</source>
          <target state="translated">이 동사의 주요 목적은 경기가 어떻게 도착했는지를 추적하는 것이지만 경기 시작점을 높이는 데 2 ​​차적으로 사용됩니다 (아래 (* SKIP) 참조).</target>
        </trans-unit>
        <trans-unit id="944d5d0eccccb0b12f4b4534569f94fbf95946bc" translate="yes" xml:space="preserve">
          <source>The main reason for using &lt;code&gt;assertMatch&lt;/code&gt; also for simple matches, instead of matching with &lt;code&gt;=&lt;/code&gt;, is that it produces more detailed error messages.</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 와 일치하는 대신 간단한 일치에도 &lt;code&gt;assertMatch&lt;/code&gt; 를 사용하는 주된 이유 는보다 자세한 오류 메시지를 생성하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="36e19f27d5fcd9a14663b0e9dd365354ee344321" translate="yes" xml:space="preserve">
          <source>The main start function is &lt;code&gt;et_viewer:start/1&lt;/code&gt;. By default it will start both an &lt;code&gt;et_collector&lt;/code&gt; and an &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">기본 시작 기능은 &lt;code&gt;et_viewer:start/1&lt;/code&gt; 입니다. 기본적으로는 모두 시작 &lt;code&gt;et_collector&lt;/code&gt; 과 &lt;code&gt;et_viewer&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="1a97901ec3926c3174291fa1e27d3f66bbc8d7ec" translate="yes" xml:space="preserve">
          <source>The main use of the function &lt;code&gt;meta/1&lt;/code&gt; is to transform a data structure &lt;code&gt;Tree&lt;/code&gt;, which represents a piece of program code, into a form that is &lt;strong&gt;representation independent when printed&lt;/strong&gt;. E.g., suppose &lt;code&gt;Tree&lt;/code&gt; represents a variable named &quot;V&quot;. Then (assuming a function &lt;code&gt;print/1&lt;/code&gt; for printing syntax trees), evaluating &lt;code&gt;print(abstract(Tree))&lt;/code&gt; - simply using &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot;&lt;code&gt;{tree, variable, ..., &quot;V&quot;, ...}&lt;/code&gt;&quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using &lt;code&gt;print(meta(Tree))&lt;/code&gt; instead would output a &lt;strong&gt;representation independent&lt;/strong&gt; syntax tree generating expression; in the above case, something like &quot;&lt;code&gt;erl_syntax:variable(&quot;V&quot;)&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;meta/1&lt;/code&gt; 함수의 주된 용도는 프로그램 코드를 나타내는 데이터 구조 &lt;code&gt;Tree&lt;/code&gt; &lt;strong&gt;를 인쇄 할 때 독립적 인 표현&lt;/strong&gt; 형식으로 변환하는 것입니다 . 예를 들어 &lt;code&gt;Tree&lt;/code&gt; 가 &quot;V&quot;라는 변수를 나타냅니다. 그런 다음 ( 구문 트리를 인쇄하기 위해 &lt;code&gt;print/1&lt;/code&gt; 함수를 가정 ), &lt;code&gt;print(abstract(Tree))&lt;/code&gt; 평가 - &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 실제 데이터 구조를 구문 트리 표현에 매핑하면 &quot;와 같은 문자열이 출력됩니다. &lt;code&gt;{tree, variable, ..., &quot;V&quot;, ...}&lt;/code&gt; &quot;는 추상 구문 트리의 구현에 따라 달라집니다. 예를 들어 파일에서 구문 트리를 캐싱하는 데 유용 할 수 있습니다. 그러나 프로그램 생성기 (예 :&quot;생성기 &quot;가 두 개인 경우)와 같은 일부 상황에서는 받아 들일 수없는 사용. &lt;code&gt;print(meta(Tree))&lt;/code&gt; 대신에 출력하고자 &lt;strong&gt;표현 독립적&lt;/strong&gt; 구문 트리를 생성하는 식을, 상기의 경우에서, 같은 &quot; &lt;code&gt;erl_syntax:variable(&quot;V&quot;)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="5cc7ab3d8930133e6c9f32ae9603597733b45c75" translate="yes" xml:space="preserve">
          <source>The main user interface consists of the functions &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename/3&lt;/a&gt;&lt;/code&gt;. See also the function &lt;code&gt;&lt;a href=&quot;#parse_transform-2&quot;&gt;parse_transform/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 사용자 인터페이스는 &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename/3&lt;/a&gt;&lt;/code&gt; 함수로 구성됩니다 . &lt;code&gt;&lt;a href=&quot;#parse_transform-2&quot;&gt;parse_transform/2&lt;/a&gt;&lt;/code&gt; 함수도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf690a3ba48e5ab54f3129fdb73083e8aa1ffc60" translate="yes" xml:space="preserve">
          <source>The major advantage of dirty operations is that they execute much faster than equivalent operations that are processed as functional objects within a transaction.</source>
          <target state="translated">더티 작업의 주요 장점은 트랜잭션 내에서 기능적 개체로 처리되는 해당 작업보다 훨씬 빠르게 실행된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c3f1a7bfd03b2e26984b55900c5f5a003f06a78" translate="yes" xml:space="preserve">
          <source>The major log file shows a detailed report of the test run. It includes test suite and test case names, execution time, the exact reason for failures, and so on. The information is available in both a file with textual and with HTML representation. The HTML file shows a summary that gives a good overview of the test run. It also has links to each individual test case log file for quick viewing with an HTML browser.</source>
          <target state="translated">주요 로그 파일에는 테스트 실행에 대한 자세한 보고서가 표시됩니다. 여기에는 테스트 스위트 및 테스트 케이스 이름, 실행 시간, 정확한 실패 원인 등이 포함됩니다. 이 정보는 텍스트 및 HTML 표현 파일로 제공됩니다. HTML 파일은 테스트 실행에 대한 개요를 제공하는 요약을 보여줍니다. 또한 HTML 브라우저로 빠르게 볼 수 있도록 각 개별 테스트 사례 로그 파일에 대한 링크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ff18089a46d332c47b58a78759522e28ba0f11" translate="yes" xml:space="preserve">
          <source>The management information is defined in a &lt;strong&gt;Management Information Base (MIB)&lt;/strong&gt;. It is a formal definition of which information the agent makes available to the manager. The manager accesses the MIB through a management protocol, such as SNMP, CMIP, HTTP, or CORBA. Each protocol has its own MIB definition language. In SNMP, it is a subset of ASN.1, in CMIP it is GDMO, in HTTP it is implicit, and using CORBA, it is IDL.</source>
          <target state="translated">관리 정보는 &lt;strong&gt;MIB (Management Information Base&lt;/strong&gt; )에 정의되어 있습니다. 에이전트가 관리자에게 제공하는 정보에 대한 공식적인 정의입니다. 관리자는 SNMP, CMIP, HTTP 또는 CORBA와 같은 관리 프로토콜을 통해 MIB에 액세스합니다. 각 프로토콜에는 고유 한 MIB 정의 언어가 있습니다. SNMP에서는 ASN.1의 하위 집합이며 CMIP에서는 GDMO이고 HTTP에서는 암시 적이며 CORBA를 사용하면 IDL입니다.</target>
        </trans-unit>
        <trans-unit id="b3ad91073d713476eff5d4cf8dadc04c76b79f8f" translate="yes" xml:space="preserve">
          <source>The management of data in telecommunications system has many aspects, thereof some, but not all, are addressed by traditional commercial Database Management Systems (DBMSs). In particular the high level of fault tolerance that is required in many nonstop systems, combined with requirements on the DBMS to run in the same address space as the application, have led us to implement a new DBMS, called Mnesia.</source>
          <target state="translated">전기 통신 시스템에서 데이터 관리는 많은 측면을 가지고 있으며, 전부는 아니지만 일부는 전통적인 상업용 데이터베이스 관리 시스템 (DBMS)으로 해결됩니다. 특히 많은 논스톱 시스템에서 요구되는 높은 수준의 내결함성, 응용 프로그램과 동일한 주소 공간에서 실행하기 위해 DBMS의 요구 사항을 결합하여 Mnesia라는 새로운 DBMS를 구현하게되었습니다.</target>
        </trans-unit>
        <trans-unit id="febc54d5d2b9c5b21af431123017ea615fe431a5" translate="yes" xml:space="preserve">
          <source>The manager information should be stored in a file called &lt;code&gt;manager.conf&lt;/code&gt;.</source>
          <target state="translated">관리자 정보는 &lt;code&gt;manager.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1781b487b48a4f52fe09daa2b7145718574c6144" translate="yes" xml:space="preserve">
          <source>The manager is often referred to as the &lt;strong&gt;Network Management System (NMS)&lt;/strong&gt;, to emphasize that it usually is realized as a program that presents data to an operator.</source>
          <target state="translated">관리자는 일반적으로 &lt;strong&gt;네트워크 관리 시스템 (NMS)&lt;/strong&gt; 이라고하며 일반적으로 운영자에게 데이터를 제공하는 프로그램으로 구현된다는 점을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="f2e6c9c5cfab679c1965d0d5bc8b363294a83d30" translate="yes" xml:space="preserve">
          <source>The manager issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="translated">관리자는 다음 &lt;code&gt;getNext&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="dca59b908ffe28e5cc68a3e4e9de1faaa52c370b" translate="yes" xml:space="preserve">
          <source>The manager now issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="translated">관리자는 이제 다음 &lt;code&gt;getNext&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="b8c05d8e33ba91352ab1e91a3f375a5f712ff8b9" translate="yes" xml:space="preserve">
          <source>The manager provided with the tool is a lightweight manager that basically provides a means to communicate with agents.</source>
          <target state="translated">도구와 함께 제공된 관리자는 기본적으로 에이전트와 통신하는 수단을 제공하는 경량 관리자입니다.</target>
        </trans-unit>
        <trans-unit id="5c1c074734e843dc6952bf33ee471b27c50c0033" translate="yes" xml:space="preserve">
          <source>The mapping between an instrumentation function and a resource is not necessarily 1-1. It is also possible to write one instrumentation function for each resource, and use that function from different protocols.</source>
          <target state="translated">계측 기능과 리소스 간의 매핑이 반드시 1-1 일 필요는 없습니다. 각 자원에 대해 하나의 인스 트루먼 테이션 기능을 작성하고 다른 프로토콜에서 해당 기능을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="998850a8c8eb8546e7768e95697db1697df937aa" translate="yes" xml:space="preserve">
          <source>The master node failed to get in contact with the slave node. This can occur in a number of circumstances:</source>
          <target state="translated">마스터 노드가 슬레이브 노드와 접촉하지 못했습니다. 여러 상황에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8a3dc76b35e83a289af92700b545a4ad79beb4" translate="yes" xml:space="preserve">
          <source>The master node must be alive.</source>
          <target state="translated">마스터 노드가 활성 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="14b34e7f97d388e649ae66acf54b7298a330905d" translate="yes" xml:space="preserve">
          <source>The master node setting is always local. It can be changed regardless if Mnesia is started or not.</source>
          <target state="translated">마스터 노드 설정은 항상 로컬입니다. Mnesia의 시작 여부에 관계없이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a3c861dd367c28c4c17a1c39eefe8dd878d733" translate="yes" xml:space="preserve">
          <source>The master nodes &lt;code&gt;Masters&lt;/code&gt; are not alive.</source>
          <target state="translated">마스터 노드 &lt;code&gt;Masters&lt;/code&gt; 가 살아 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58c3b06d8afda9470de94fad6ad989bbb0cc70c8" translate="yes" xml:space="preserve">
          <source>The match function can also be used to check the equality of different attributes. For example, to find all employees with an employee number equal to their room number:</source>
          <target state="translated">일치 기능을 사용하여 다른 속성의 동등성을 확인할 수도 있습니다. 예를 들어, 직원 번호가 직원 번호와 같은 모든 직원을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="01db01bdcf4f0ead878b2024575a51c69acd4f98" translate="yes" xml:space="preserve">
          <source>The match of &lt;code&gt;Dgram&lt;/code&gt; fails if one of the following occurs:</source>
          <target state="translated">다음 중 하나가 발생하면 &lt;code&gt;Dgram&lt;/code&gt; 이 일치 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c78419f0c88d5eda3fb5ff5b511ec776a98797e" translate="yes" xml:space="preserve">
          <source>The match specification function &lt;code&gt;{return_trace}&lt;/code&gt; works with meta-trace and sends its trace message to the same tracer.</source>
          <target state="translated">일치 스펙 함수 &lt;code&gt;{return_trace}&lt;/code&gt; 는 메타 추적과 함께 작동하며 추적 메시지를 동일한 추적 프로그램으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5153c93179a582efee4cbb10c8790c7726a7e986" translate="yes" xml:space="preserve">
          <source>The match specification has to return the atom &lt;code&gt;true&lt;/code&gt; if the object is to be deleted. No other return value gets the object deleted. So one cannot use the same match specification for looking up elements as for deleting them.</source>
          <target state="translated">일치 스펙은 오브젝트를 삭제 하려면 atom을 &lt;code&gt;true&lt;/code&gt; 로 리턴 해야합니다. 다른 리턴 값은 오브젝트를 삭제하지 않습니다. 따라서 요소를 검색 할 때와 동일한 일치 스펙을 사용하여 요소를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98c4807426673ae3f3cbf5adfe4d22a81aa12f6b" translate="yes" xml:space="preserve">
          <source>The match specifications in the file are &lt;strong&gt;merged&lt;/strong&gt; with the current match specifications, so that no duplicates are generated. Use &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; to see what numbers were assigned to the specifications from the file.</source>
          <target state="translated">파일의 일치 스펙 이 현재 일치 스펙과 &lt;strong&gt;병합&lt;/strong&gt; 되므로 중복이 생성되지 않습니다. &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 을 사용 하여 파일에서 스펙에 지정된 숫자를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d55c9805b9483fe33032d7ae9cde54896150634e" translate="yes" xml:space="preserve">
          <source>The match specifiction must be guaranteed to &lt;strong&gt;retain the key&lt;/strong&gt; of any matched object. If not, &lt;code&gt;select_replace&lt;/code&gt; will fail with &lt;code&gt;badarg&lt;/code&gt; without updating any objects.</source>
          <target state="translated">일치 하는 개체 &lt;strong&gt;의 키&lt;/strong&gt; 를 &lt;strong&gt;유지&lt;/strong&gt; 하려면 일치 지정이 보장되어야 합니다. 그렇지 않은 경우 &lt;code&gt;select_replace&lt;/code&gt; 는 객체를 업데이트하지 않고 &lt;code&gt;badarg&lt;/code&gt; 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="ee0a15736607c624569021f76ff9d3298f79570e" translate="yes" xml:space="preserve">
          <source>The match-and-replace operation for each individual object is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;select_replace&lt;/code&gt; table iteration as a whole, like all other select functions, does not give such guarantees.</source>
          <target state="translated">각 개별 객체에 대한 일치 및 교체 작업은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 있습니다. &lt;code&gt;select_replace&lt;/code&gt; 의 전체 테이블의 반복은, 다른 모든 선택 기능처럼, 같은 보장을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ca8026082eee2ad7e64557de104f28a642c57fb" translate="yes" xml:space="preserve">
          <source>The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here.</source>
          <target state="translated">라이브러리의 일치 알고리즘은 PCRE 라이브러리를 기반으로하지만 모든 PCRE 라이브러리가 인터페이스되는 것은 아니며 라이브러리의 일부는 PCRE가 제공하는 것 이상의 기능을합니다. 현재 PCRE 버전 8.40 (릴리스 날짜 2017-01-11)이 사용됩니다. 이 모듈과 관련된 PCRE 문서 섹션이 여기에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd21ba9310055b64610ab1a5c2a142134aa443f" translate="yes" xml:space="preserve">
          <source>The matching is executed on each element in &lt;code&gt;List&lt;/code&gt; and the function returns a list containing all results. If an element in &lt;code&gt;List&lt;/code&gt; does not match, nothing is returned for that element. The length of the result list is therefore equal or less than the length of parameter &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">일치는 &lt;code&gt;List&lt;/code&gt; 의 각 요소에서 실행되며이 함수는 모든 결과가 포함 된 목록을 반환합니다. &lt;code&gt;List&lt;/code&gt; 의 요소 가 일치하지 않으면 해당 요소에 대해 아무것도 반환되지 않습니다. 따라서 결과 목록의 길이는 매개 변수 &lt;code&gt;List&lt;/code&gt; 의 길이보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="198df020548452f3363e4fa559534d8078bfc86b" translate="yes" xml:space="preserve">
          <source>The matching operations in &lt;code&gt;Mnesia&lt;/code&gt; can either lock the entire table or only a single record (when the key is bound in the pattern).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 에서 일치하는 조작 은 전체 테이블을 잠 그거나 단일 레코드 (키가 패턴에 바인드 된 경우) 만 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="334b3e2d6b3a53d5d4f23d6292533ac9fed61406" translate="yes" xml:space="preserve">
          <source>The maximum number of allowed characters in an atom is 255. In the UTF-8 case, each character can need 4 bytes to be encoded.</source>
          <target state="translated">아톰에서 허용되는 최대 문자 수는 255 자입니다. UTF-8의 경우 각 문자를 인코딩하려면 4 바이트가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19294f2a8c14a8b4f31f643e9f2b22734d7e410e" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes that has been allocated during the lifetime of the originating node. This is only shown if the Erlang runtime system is run instrumented.</source>
          <target state="translated">원래 노드의 수명 동안 할당 된 최대 바이트 수입니다. Erlang 런타임 시스템이 인스 트루먼 테이션 된 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="139d6633f301a60c8cd9a458fcbc51c168888bf8" translate="yes" xml:space="preserve">
          <source>The maximum number of capturing subpatterns is 65535.</source>
          <target state="translated">캡처 하위 패턴의 최대 수는 65535입니다.</target>
        </trans-unit>
        <trans-unit id="1bc4329e4ceb57ba9547a9f48f399278acde7346" translate="yes" xml:space="preserve">
          <source>The maximum number of channels with active remote subsystem that are accepted for each connection to this daemon</source>
          <target state="translated">이 데몬에 대한 각 연결에 허용되는 활성 원격 서브 시스템이있는 최대 채널 수</target>
        </trans-unit>
        <trans-unit id="b534caa8ed29360c9c0c9252aae63ac15ba8de99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements in a tuple is 16,777,215 (24-bit unsigned integer).</source>
          <target state="translated">튜플의 최대 요소 수는 16,777,215 (24 비트 부호없는 정수)입니다.</target>
        </trans-unit>
        <trans-unit id="aa82ab7bf0492deb21a60217a14e1da088287537" translate="yes" xml:space="preserve">
          <source>The maximum number of ports that can be open at the same time can be configured by passing command-line flag &lt;code&gt;&lt;a href=&quot;erl#max_ports&quot;&gt;+Q&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">동시에 열 수있는 최대 포트 수는 명령 줄 플래그 &lt;code&gt;&lt;a href=&quot;erl#max_ports&quot;&gt;+Q&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;erl(1)&lt;/code&gt; 에 전달하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="364851e20b3d3baac09ccbd2901df833d89219b3" translate="yes" xml:space="preserve">
          <source>The maximum number of repetitions of the timer.</source>
          <target state="translated">타이머의 최대 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="b52d3e36551290057fbd3fa69d9e51f68308bed8" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. Thus, if set to &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;N&lt;/code&gt; clients have connected but not started the login process, connection attempt &lt;code&gt;N+1&lt;/code&gt; is aborted. If &lt;code&gt;N&lt;/code&gt; connections are authenticated and still logged in, no more logins are accepted until one of the existing ones log out.</source>
          <target state="translated">이 데몬에 대해 언제든지 허용되는 최대 동시 세션 수입니다. 여기에는 권한이 부여 된 세션이 포함됩니다. 따라서 &lt;code&gt;N&lt;/code&gt; 으로 설정 되고 &lt;code&gt;N&lt;/code&gt; 클라이언트가 연결되었지만 로그인 프로세스를 시작하지 않은 경우 연결 시도 &lt;code&gt;N+1&lt;/code&gt; 이 중단됩니다. &lt;code&gt;N&lt;/code&gt; 개의 연결이 인증되고 여전히 로그인되어 있으면 기존 연결 중 하나가 로그 아웃 할 때까지 더 이상 로그인이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33f9e2efd4e8f4d95b154e45a6aa836475444a9a" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously alive Erlang processes is by default 262,144. This limit can be configured at startup. For more information, see the &lt;code&gt;+P&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">동시에 활성화 된 Erlang 프로세스의 최대 수는 기본적으로 262,144입니다. 시작시이 제한을 구성 할 수 있습니다. 자세한 내용 은 ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지에서 &lt;code&gt;+P&lt;/code&gt; 명령 줄 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ea78efb7aa811663d27fe73cd13c0c8fb0d40a3" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously connected nodes is limited by either the maximum number of simultaneously known remote nodes, &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of (Erlang) ports&lt;/a&gt;&lt;/code&gt; available, or &lt;code&gt;&lt;a href=&quot;#files_sockets&quot;&gt;the maximum number of sockets&lt;/a&gt;&lt;/code&gt; available.</source>
          <target state="translated">동시에 연결된 최대 노드 수는 동시에 알려진 &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of (Erlang) ports&lt;/a&gt;&lt;/code&gt; 원격 노드 수, 사용 가능한 최대 (Erlang) 포트 수 또는 사용 가능한 &lt;code&gt;&lt;a href=&quot;#files_sockets&quot;&gt;the maximum number of sockets&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d7d8a949becb40e83e6c856df21937f4d5e2fc4" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open Erlang ports is often by default 16,384. This limit can be configured at startup. For more information, see the &lt;code&gt;+Q&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">동시에 열려있는 Erlang 포트의 최대 수는 종종 기본적으로 16,384입니다. 시작시이 제한을 구성 할 수 있습니다. 자세한 내용 은 ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지에서 &lt;code&gt;+Q&lt;/code&gt; 명령 줄 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dce3aefe9378fbdd7c23ba61275213a9e8f16e3c" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open files and sockets depends on &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of Erlang ports&lt;/a&gt;&lt;/code&gt; available, as well as on operating system-specific settings and limits.</source>
          <target state="translated">동시에 열려있는 최대 파일 및 소켓 &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of Erlang ports&lt;/a&gt;&lt;/code&gt; 사용 가능한 최대 Erlang 포트 수와 운영 체제 별 설정 및 제한에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b9d46ab9b300e30ac3d0d3879401107e372584e8" translate="yes" xml:space="preserve">
          <source>The maximum size in words of the process. If set to zero, the heap size limit is disabled. &lt;code&gt;badarg&lt;/code&gt; is be thrown if the value is smaller than &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt;min_heap_size&lt;/a&gt;&lt;/code&gt;. The size check is only done when a garbage collection is triggered.</source>
          <target state="translated">프로세스 단어의 최대 크기입니다. 0으로 설정하면 힙 크기 제한이 비활성화됩니다. 값이 &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt;min_heap_size&lt;/a&gt;&lt;/code&gt; 보다 작은 경우 &lt;code&gt;badarg&lt;/code&gt; 가 발생합니다 . 크기 검사는 가비지 수집이 트리거 된 경우에만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b6db39ece8aee304cbcf9157b862c4fb5ad3c9" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. See the &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; documentation for more details.</source>
          <target state="translated">&lt;code&gt;os:cmd&lt;/code&gt; 호출에 의해 리턴되는 데이터의 최대 크기입니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ac1dd4626b925c247f9422c7d93ee30b6d58305" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. This option is a safety feature that should be used when the command executed can return a very large, possibly infinite, result.</source>
          <target state="translated">&lt;code&gt;os:cmd&lt;/code&gt; 호출에 의해 리턴되는 데이터의 최대 크기입니다 . 이 옵션은 실행 된 명령이 매우 크거나 무한한 결과를 반환 할 수있을 때 사용해야하는 안전 기능입니다.</target>
        </trans-unit>
        <trans-unit id="585b754a1ab975e434f0ece6fc3dc6117a6bfa95" translate="yes" xml:space="preserve">
          <source>The maximum time that &lt;code&gt;Mnesia&lt;/code&gt; waits for other nodes to respond with a transaction recovery decision can be specified. The configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; defaults to &lt;code&gt;infinity&lt;/code&gt;, which can cause the indefinite hanging as mentioned earlier. However, if the parameter is set to a definite time period (for example, three minutes), &lt;code&gt;Mnesia&lt;/code&gt; then enforces a transaction recovery decision, if needed, to allow &lt;code&gt;Mnesia&lt;/code&gt; to continue with its startup procedure.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 다른 노드가 트랜잭션 복구 결정에 응답하기를 기다리는 최대 시간을 지정할 수 있습니다. 구성 매개 변수 &lt;code&gt;max_wait_for_decision&lt;/code&gt; 의 기본값은 &lt;code&gt;infinity&lt;/code&gt; 로 설정되며 앞에서 언급 한대로 무기한 정지 될 수 있습니다. 그러나 매개 변수가 명확한 시간 (예 : 3 분)으로 &lt;code&gt;Mnesia&lt;/code&gt; 경우 Mnesia 는 필요한 경우 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작 절차를 계속할 수 있도록 트랜잭션 복구 결정을 시행 합니다.</target>
        </trans-unit>
        <trans-unit id="9c5051bd43e740038041f2bf25ed5638f7d0e3f3" translate="yes" xml:space="preserve">
          <source>The maximum total amount of memory allocated since the emulator was started. This tuple is only present when the emulator is run with instrumentation.</source>
          <target state="translated">에뮬레이터가 시작된 이후 할당 된 최대 총 메모리 양입니다. 이 튜플은 에뮬레이터가 계측으로 실행될 때만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="28e274b5f8dfecfd5eae3c1b1cfa72d55e0d6e66" translate="yes" xml:space="preserve">
          <source>The meaning of dollar can be changed so that it matches only at the very end of the string, by setting option &lt;code&gt;dollar_endonly&lt;/code&gt; at compile time. This does not affect the \Z assertion.</source>
          <target state="translated">달러의 의미는 컴파일 타임에 옵션 &lt;code&gt;dollar_endonly&lt;/code&gt; 를 설정하여 문자열의 맨 끝에서만 일치하도록 변경할 수 있습니다 . \ Z 어설 션에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db8e327530c8b9b6b5b186cd76cf404392297a30" translate="yes" xml:space="preserve">
          <source>The meaning of the various quantifiers is not otherwise changed, only the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. As it has two uses, it can sometimes appear doubled, as in</source>
          <target state="translated">다양한 정량 자의 의미는 달리 변경되지 않고 선호하는 일치 수만 변경됩니다. 이 물음표 사용을 자체적으로 수량 자로서 사용하는 것과 혼동하지 마십시오. 두 가지 용도로 사용되기 때문에 때로는 두 배로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1fc58f8c2a19d894912d06c0debf88001c2723f" translate="yes" xml:space="preserve">
          <source>The meanings of the circumflex and dollar characters are changed if option &lt;code&gt;multiline&lt;/code&gt; is set. When this is the case, a circumflex matches immediately after internal newlines and at the start of the subject string. It does not match after a newline that ends the string. A dollar matches before any newlines in the string, and at the very end, when &lt;code&gt;multiline&lt;/code&gt; is set. When newline is specified as the two-character sequence CRLF, isolated CR and LF characters do not indicate newlines.</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt; 옵션 이 설정 되면 곡절 및 달러 문자의 의미가 변경됩니다 . 이 경우, 내부 개행 직후와 제목 문자열의 시작 부분에 곡절이 일치합니다. 문자열을 끝내는 개행 후에는 일치하지 않습니다. 달러 문자열의 모든 줄 바꿈 앞에 일치하고 매우 끝에서 &lt;code&gt;multiline&lt;/code&gt; 설정됩니다. 줄 바꿈이 두 문자 시퀀스 CRLF로 지정된 경우 분리 된 CR 및 LF 문자는 줄 바꿈을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d91b3d8b6609ca598d50d85473759e345b88f58" translate="yes" xml:space="preserve">
          <source>The meanings of the packet types are as follows:</source>
          <target state="translated">패킷 유형의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="978fd2c6d0a38bb48b2e443f83d298392afa53c5" translate="yes" xml:space="preserve">
          <source>The measured node.</source>
          <target state="translated">측정 된 노드</target>
        </trans-unit>
        <trans-unit id="b3fced30f9f09acd4ae489f7a4cde9db12cd9cfb" translate="yes" xml:space="preserve">
          <source>The measurement (meas) module(s)</source>
          <target state="translated">측정 (meas) 모듈</target>
        </trans-unit>
        <trans-unit id="9d1886cf663e0cdc7dac0d21c48bb994286f92d0" translate="yes" xml:space="preserve">
          <source>The measurement is done by iterating over the decode/encode function for approx 2 seconds per message and counting the number of decodes/encodes.</source>
          <target state="translated">메시지 당 약 2 초 동안 디코드 / 인코딩 기능을 반복하고 디코드 / 인코딩 수를 계산하여 측정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="aec8fc6af742975da8742323e5863ba3c2976265" translate="yes" xml:space="preserve">
          <source>The measurements has been performed on a HP xw4600 Workstation with a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. Software versions was open source OTP R13B04 (megaco-3.14).</source>
          <target state="translated">측정은 4GB 메모리 및 Ubuntu 10.04 x86_64 (커널 2.6.32-22- 일반)를 실행하는 Intel (R) Core (TM) 2 쿼드 CPU Q9550 @ 2.83GHz의 HP xw4600 워크 스테이션에서 수행되었습니다. 소프트웨어 버전은 오픈 소스 OTP R13B04 (megaco-3.14)였습니다.</target>
        </trans-unit>
        <trans-unit id="3cc922c4e05bd2a334377ee02802a916cd403417" translate="yes" xml:space="preserve">
          <source>The mechanism for &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; as described in this section is also kept for backwards compatibility. However, the new logging API also introduces &lt;code&gt;logger_disk_log_h(3)&lt;/code&gt;, which is a logger handler that can print to multiple files using &lt;code&gt;disk_log(3)&lt;/code&gt;.</source>
          <target state="translated">이 섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; 메커니즘은 이전 버전과의 호환성을 위해 유지됩니다. 그러나, 새로운 로깅 API도 소개 &lt;code&gt;logger_disk_log_h(3)&lt;/code&gt; 사용하여 여러 파일을 인쇄 할 수있는 로거 핸들러, &lt;code&gt;disk_log(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0f7032a10e00f5b731f6ddebd729a428e75839" translate="yes" xml:space="preserve">
          <source>The mechanism for passing data is called &lt;code&gt;save_config&lt;/code&gt;. The idea is that one test case (or suite) can save the current value of &lt;code&gt;Config&lt;/code&gt;, or any list of key-value tuples, so that the next executing test case (or test suite) can read it. The configuration data is not saved permanently but can only be passed from one case (or suite) to the next.</source>
          <target state="translated">데이터 전달 메커니즘을 &lt;code&gt;save_config&lt;/code&gt; 라고 합니다 . 아이디어는 하나의 테스트 케이스 (또는 스위트)가 &lt;code&gt;Config&lt;/code&gt; 의 현재 값 또는 모든 키 값 튜플 목록을 저장할 수 있으므로 다음 실행 테스트 케이스 (또는 테스트 스위트)가 읽을 수 있다는 것입니다. 구성 데이터는 영구적으로 저장되지 않지만 한 사례 (또는 제품군)에서 다음 사례로만 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a82246982edacf43dfbd803e39adbeb1684356" translate="yes" xml:space="preserve">
          <source>The mechanism is easiest explained by an example:</source>
          <target state="translated">메커니즘은 예제로 가장 쉽게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa97754d61962935bb76075b6dc85939e815dbc" translate="yes" xml:space="preserve">
          <source>The memory allocated by the node in kilobytes.</source>
          <target state="translated">노드에서 할당 한 메모리 (KB)</target>
        </trans-unit>
        <trans-unit id="298ac153c29e1852aa628eb9371283caf21dbef1" translate="yes" xml:space="preserve">
          <source>The memory allocated for code storage.</source>
          <target state="translated">코드 저장을 위해 할당 된 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="59e5363544c056808c214b7d5c9c6474a917a3b4" translate="yes" xml:space="preserve">
          <source>The memory allocation strategy used for multiblock carriers by an allocator can be configured using parameter &lt;code id=&quot;strategy&quot;&gt;&lt;a href=&quot;#M_as&quot;&gt;as&lt;/a&gt;&lt;/code&gt;. The following strategies are available:</source>
          <target state="translated">할당 자에 의해 멀티 블록 반송파에 사용되는 메모리 할당 전략은 파라미터 &lt;code id=&quot;strategy&quot;&gt;&lt;a href=&quot;#M_as&quot;&gt;as&lt;/a&gt;&lt;/code&gt; 를 사용하여 구성 할 수 있습니다 . 다음과 같은 전략을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d175bff5507dd3c92a81b43fddcde2ca548264d" translate="yes" xml:space="preserve">
          <source>The memory use is in bytes.</source>
          <target state="translated">메모리 사용은 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="a3a1ae2cae0473b354552d179be5126c3e3c48c2" translate="yes" xml:space="preserve">
          <source>The menu bar contains a &lt;strong&gt;File&lt;/strong&gt; menu and a &lt;strong&gt;Help&lt;/strong&gt; menu. From the &lt;strong&gt;File&lt;/strong&gt; menu, a new crashdump can be loaded or the tool can be terminated. From the &lt;strong&gt;Help&lt;/strong&gt; menu, this User's Guide and section &quot;How to interpret the Erlang crash dumps&quot; from the ERTS application can be opened. &quot;How to interpret the Erlang crash dumps&quot; describes the raw crashdumps in detail and includes information about each field in the information pages.&quot;How to interpret the Erlang crash dumps&quot; is also available in the OTP online documentation.</source>
          <target state="translated">메뉴 표시 줄에는 &lt;strong&gt;파일&lt;/strong&gt; 메뉴와 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴가 있습니다. 로부터 &lt;strong&gt;파일&lt;/strong&gt; 메뉴에서 새로운 크래시 덤프를로드 할 수 있습니다 또는 도구가 종료 될 수 있습니다. 로부터 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴에서이 사용 설명서 및 섹션 ERTS 응용 프로그램을 열 수 있습니다에서 &quot;얼랭 충돌을 해석하는 방법은 덤프&quot;. &quot;Erlang 크래시 덤프를 해석하는 방법&quot;은 원시 크래시 덤프에 대해 자세히 설명하고 정보 페이지에 각 필드에 대한 정보를 포함합니다. &quot;Erlang 크래시 덤프를 해석하는 방법&quot;도 OTP 온라인 문서에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1da2ec9bc11a5f3d2243b7edb144004648c44860" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is received.</source>
          <target state="translated">메시지 &lt;code&gt;Msg&lt;/code&gt; 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="bef16814b598901c6478a3fbd2f3f7dcb03410e5" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is sent to process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">메시지 &lt;code&gt;Pid&lt;/code&gt; 처리하도록 &lt;code&gt;Msg&lt;/code&gt; 가 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2f87f0f2be084c26692c04f5569df347bc82216" translate="yes" xml:space="preserve">
          <source>The message environment &lt;code&gt;msg_env&lt;/code&gt; with all its terms (including &lt;code&gt;msg&lt;/code&gt;) is invalidated by a successful call to &lt;code&gt;enif_send&lt;/code&gt;. The environment is to either be freed with &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt;enif_free_env&lt;/a&gt;&lt;/code&gt; of cleared for reuse with &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 환경 &lt;code&gt;msg_env&lt;/code&gt; (등을 포함하는 모든 조건에 &lt;code&gt;msg&lt;/code&gt; )에 성공적으로 호출에 의해 무효화 &lt;code&gt;enif_send&lt;/code&gt; . 환경 중 하나에 해제 될 &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt;enif_free_env&lt;/a&gt;&lt;/code&gt; 와 재사용 허가의 &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69095ad9f243cb8ca62108dfb3eb20c26f31c02d" translate="yes" xml:space="preserve">
          <source>The message is delivered as an Erlang binary and is decoded by the encoding module stated in the receive handle together with its encoding config (also in the receive handle). Depending of the outcome of the decoding various callback functions will be invoked. See megaco_user for more info about the callback arguments.</source>
          <target state="translated">메시지는 Erlang 바이너리로 전달되며 수신 핸들에 지정된 인코딩 모듈과 인코딩 구성 (수신 핸들에도 있음)에 의해 디코딩됩니다. 디코딩 결과에 따라 다양한 콜백 함수가 호출됩니다. 콜백 인수에 대한 자세한 내용은 megaco_user를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53e2b8f523369c83642e4048ab82a3185ec3b76f" translate="yes" xml:space="preserve">
          <source>The message is to be sent unordered</source>
          <target state="translated">메시지는 순서대로 보내지지 않습니다</target>
        </trans-unit>
        <trans-unit id="f0a211d0180d304363ef532b16b38c1c8ed96d5c" translate="yes" xml:space="preserve">
          <source>The message provided by the caller is printed. This function is simply a wrapper for &lt;code&gt;fprintf()&lt;/code&gt;.</source>
          <target state="translated">발신자가 제공 한 메시지가 인쇄됩니다. 이 함수는 단순히 &lt;code&gt;fprintf()&lt;/code&gt; 의 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="188062935a333dac8b9cbce97db717469f7ef85a" translate="yes" xml:space="preserve">
          <source>The message queue is on the heap depending on the process flag &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;message_queue_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 큐는 프로세스 플래그 &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;message_queue_data&lt;/a&gt;&lt;/code&gt; 에 따라 힙에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d253006487349bbc06f18a3a3218a8846cc6f2" translate="yes" xml:space="preserve">
          <source>The message sent to another node using the '!' (in external format). Notice that &lt;code&gt;Message&lt;/code&gt; is only passed in combination with a &lt;code&gt;ControlMessage&lt;/code&gt; encoding a send ('!').</source>
          <target state="translated">'!'를 사용하여 다른 노드로 보낸 메시지 (외부 형식). 통지 &lt;code&gt;Message&lt;/code&gt; 단지와 함께 전달되는 &lt;code&gt;ControlMessage&lt;/code&gt; 가 송신를 ( '!') 인코딩.</target>
        </trans-unit>
        <trans-unit id="2508ed4b299c2e2a914cd2e173689088380e01ae" translate="yes" xml:space="preserve">
          <source>The message size is limited according to the values of configuration parameters &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt;chars_limit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지 크기는 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt;chars_limit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt; 의 값에 따라 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aa5e3b5fe2a2c9211425bda03965c4fecd38672" translate="yes" xml:space="preserve">
          <source>The message term to be appended to the trace message</source>
          <target state="translated">추적 메시지에 추가 될 메시지 용어</target>
        </trans-unit>
        <trans-unit id="e0a0e8de3b2b246c6805a721cd7aa635b44ea3ae" translate="yes" xml:space="preserve">
          <source>The message term to send.</source>
          <target state="translated">보낼 메시지 용어입니다.</target>
        </trans-unit>
        <trans-unit id="fb35a1112b2aba4bb7f59c7ef2bd29e811541e66" translate="yes" xml:space="preserve">
          <source>The message term to send. The same limitations apply as on the payload to &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보낼 메시지 용어입니다. &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 에 대한 페이로드와 동일한 제한이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ff1263e12ec9b56844ab9f45da012f6df9fa30" translate="yes" xml:space="preserve">
          <source>The message to be sent.</source>
          <target state="translated">보낼 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="662e1568be87a93705ec3d52e5be7681c3dcae9b" translate="yes" xml:space="preserve">
          <source>The message transformation is done by the transformation module. It is used to transform a set of messages encoded with one codec into the other base codec's.</source>
          <target state="translated">메시지 변환은 변환 모듈에 의해 수행됩니다. 한 코덱으로 인코딩 된 메시지 세트를 다른 기본 코덱으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f330d0749b4288239218bfd8721d9cc50f2048e" translate="yes" xml:space="preserve">
          <source>The messages used by the different tools are contained in single message package file (see below for more info). The messages in this file is encoded with just one codec. During measurement initiation, the messages are read and then transformed to all codec formats used in the measurement.</source>
          <target state="translated">다른 도구에서 사용하는 메시지는 단일 메시지 패키지 파일에 포함되어 있습니다 (자세한 내용은 아래 참조). 이 파일의 메시지는 하나의 코덱으로 인코딩됩니다. 측정을 시작하는 동안 메시지를 읽은 다음 측정에 사용 된 모든 코덱 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="92b306bf0e70c78b5d09e95ccf216abcbe6cd2ba" translate="yes" xml:space="preserve">
          <source>The messenger is set up by allowing &quot;clients&quot; to connect to a central server and say who and where they are. That is, a user does not need to know the name of the Erlang node where another user is located to send a message.</source>
          <target state="translated">메신저는 &quot;클라이언트&quot;가 중앙 서버에 연결하여 누구와 어디에 있는지 말함으로써 설정할 수 있습니다. 즉, 사용자는 메시지를 보내기 위해 다른 사용자가있는 Erlang 노드의 이름을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b08f3d25f362366adcd8ed69b48375b76af1ceb" translate="yes" xml:space="preserve">
          <source>The messenger server traps exits. If it receives an exit signal, &lt;code&gt;{'EXIT',From,Reason}&lt;/code&gt;, this means that a client process has terminated or is unreachable for one of the following reasons:</source>
          <target state="translated">메신저 서버 트랩이 종료됩니다. 종료 신호 &lt;code&gt;{'EXIT',From,Reason}&lt;/code&gt; 을 수신하면 다음 중 하나의 이유로 클라이언트 프로세스가 종료되었거나 도달 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d73c2514c79c3ab7ddf5f518405430d4594740a9" translate="yes" xml:space="preserve">
          <source>The method used to implement distributed tables with this SNMP tool is to implement a table coordinator process responsible for coordinating the processes, which hold the table data and they are called table holders. All table holders must in some way be known by the coordinator; the structure of the table data determines how this is achieved. The coordinator may require that the table holders explicitly register themselves and specify their information. In other cases, the table holders can be determined once at compile time.</source>
          <target state="translated">이 SNMP 도구를 사용하여 분산 테이블을 구현하는 데 사용되는 방법은 테이블 데이터를 보유하는 프로세스 조정을 담당하는 테이블 코디네이터 프로세스를 구현하는 것이며이를 테이블 홀더라고합니다. 모든 테이블 홀더는 코디네이터가 알아야합니다. 테이블 데이터의 구조는 이것이 달성되는 방법을 결정합니다. 코디네이터는 테이블 홀더가 명시 적으로 자신을 등록하고 정보를 지정하도록 요구할 수 있습니다. 다른 경우에는 테이블 홀더를 컴파일 타임에 한 번 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aeb4d59c4a528fedb146161bc65731c3aab1a8a" translate="yes" xml:space="preserve">
          <source>The method used to present a distributed table is strongly application dependent. The use of different masking techniques is only valid for a small subset of problems and registering every row in a distributed table makes it non-distributed.</source>
          <target state="translated">분산 테이블을 표시하는 데 사용되는 방법은 응용 프로그램에 따라 다릅니다. 다른 마스킹 기술을 사용하는 것은 작은 문제의 하위 집합에만 유효하며 분산 테이블의 모든 행을 등록하면 분산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63514a43185163391d03ee090dbfddf650488f7c" translate="yes" xml:space="preserve">
          <source>The mib storage is used by the agent to store internal mib- related information. The mib storage module is used by several entities, not just the mib-server.</source>
          <target state="translated">에이전트는 mib 스토리지를 사용하여 내부 mib 관련 정보를 저장합니다. mib 스토리지 모듈은 mib 서버뿐만 아니라 여러 엔티티에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22c3dd445cc6fc863b70e9b3499332bc0735098f" translate="yes" xml:space="preserve">
          <source>The minimal setup is not the most secure setup of SSL/TLS/DTLS.</source>
          <target state="translated">최소 설정은 SSL / TLS / DTLS의 가장 안전한 설정이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1a717b6f86847b74e42485f2bb9e93125c968160" translate="yes" xml:space="preserve">
          <source>The minimal system based on Erlang/OTP, enabling release handling, thus consists of the Kernel, STDLIB, and SASL applications.</source>
          <target state="translated">Erlang / OTP 기반의 최소 시스템으로 릴리스 처리가 가능하므로 커널, STDLIB 및 SASL 응용 프로그램으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="07c2b5af828a95564e2ccf73c84d39aeac748a78" translate="yes" xml:space="preserve">
          <source>The minimum size of the receive buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to retrieve the size set by your operating system.</source>
          <target state="translated">소켓에 사용할 수신 버퍼의 최소 크기입니다. &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 운영 체제에서 설정 한 크기를 검색하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8abc7d7fd3d2b168dd30ef9b33fd46de95e55a93" translate="yes" xml:space="preserve">
          <source>The minimum size of the send buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;, to retrieve the size set by your operating system.</source>
          <target state="translated">소켓에 사용할 송신 버퍼의 최소 크기입니다. &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 운영 체제에서 설정 한 크기를 검색하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3eddcd151845fa0f558f92cf054830bab732faab" translate="yes" xml:space="preserve">
          <source>The minor log files contain full details of every single test case, each in a separate file. This way, it is straightforward to compare the latest results to that of previous test runs, even if the set of test cases changes. If application SASL is running, its logs are also printed to the current minor log file by the &lt;code&gt;cth_log_redirect built-in hook&lt;/code&gt;.</source>
          <target state="translated">부 로그 파일에는 모든 단일 테스트 사례에 대한 세부 정보가 각각 별도의 파일로 포함되어 있습니다. 이렇게하면 테스트 사례 세트가 변경 되더라도 최신 결과를 이전 테스트 실행의 결과와 비교하는 것이 간단합니다. 애플리케이션 SASL이 실행중인 경우 해당 로그는 &lt;code&gt;cth_log_redirect built-in hook&lt;/code&gt; 의해 현재 부 로그 파일로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="3658d2cb7add73fe309b90a8d098bef38a4ef76d" translate="yes" xml:space="preserve">
          <source>The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class, or immediately after a range. For example, [b-d-z] matches letters in the range b to d, a hyphen character, or z.</source>
          <target state="translated">빼기 (하이픈) 문자를 사용하여 문자 클래스에서 문자 범위를 지정할 수 있습니다. 예를 들어, [dm]은 d와 m 사이의 모든 문자를 포함합니다. 클래스에서 빼기 문자가 필요한 경우 백 슬래시로 이스케이프 처리하거나 범위를 나타내는 것으로 해석 할 수없는 위치, 일반적으로 클래스의 첫 번째 또는 마지막 문자로 또는 범위 바로 뒤에 표시되어야합니다. 예를 들어, [bdz]는 b-d 범위의 문자, 하이픈 문자 또는 z와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9af303642ed501803e879dc12b0614d63b8151b7" translate="yes" xml:space="preserve">
          <source>The missing time can be found in the paragraph for &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; where it is evident that not only &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is called but also a fun:</source>
          <target state="translated">&lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 에 대한 단락에서 누락 된 시간을 찾을 수 있습니다 . 여기서 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 뿐만 아니라 재미도 있습니다.</target>
        </trans-unit>
        <trans-unit id="606631313d3f4e567c75d609d36257f0ff021b82" translate="yes" xml:space="preserve">
          <source>The mode enables the use of non-atom states, for example, complex states or even hierarchical states. See section &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt;. If, for example, a state diagram is largely alike for the client side and the server side of a protocol, you can have a state &lt;code&gt;{StateName,server}&lt;/code&gt; or &lt;code&gt;{StateName,client}&lt;/code&gt;, and make &lt;code&gt;StateName&lt;/code&gt; determine where in the code to handle most events in the state. The second element of the tuple is then used to select whether to handle special client-side or server-side events.</source>
          <target state="translated">이 모드를 사용하면 복잡한 상태 또는 계층 상태와 같은 비 원자 상태를 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 . 예를 들어, 프로토콜의 클라이언트 측과 서버 측에 대한 상태 다이어그램이 대체로 &lt;code&gt;{StateName,server}&lt;/code&gt; 또는 &lt;code&gt;{StateName,client}&lt;/code&gt; 상태를 가질 수 있고 &lt;code&gt;StateName&lt;/code&gt; 이 코드에서 처리 할 위치를 결정 하게 할 수 있습니다 주에서 가장 많은 사건. 그런 다음 튜플의 두 번째 요소를 사용하여 특수한 클라이언트 쪽 또는 서버 쪽 이벤트를 처리할지 여부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b970edef5d2db822eb3139eed01662d797b2d6c5" translate="yes" xml:space="preserve">
          <source>The mode properties are as follows:</source>
          <target state="translated">모드 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c74fbe5e44daec131d6f8bb6c1035938c0451e49" translate="yes" xml:space="preserve">
          <source>The mode where data is pumped through the port and the &lt;code&gt;uds_command&lt;/code&gt; routine regards every call as a call where sending is wanted. In this mode, all input available is read and sent to Erlang when it arrives on the socket, much like in the active mode of a &lt;code&gt;gen_tcp&lt;/code&gt; socket.</source>
          <target state="translated">포트를 통해 데이터가 펌핑되는 모드와 &lt;code&gt;uds_command&lt;/code&gt; 루틴은 모든 호출을 전송이 필요한 호출로 간주합니다. 이 모드에서 사용 가능한 모든 입력은 &lt;code&gt;gen_tcp&lt;/code&gt; 소켓 의 활성 모드에서와 같이 소켓에 도착하면 Erlang으로 읽고 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="881eb04bb7f343c8b06f98508313f6d367c9da3f" translate="yes" xml:space="preserve">
          <source>The modes are as follows:</source>
          <target state="translated">모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22f36ac434028664a5e69ab508016c7df24b7383" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; 모듈 은 대체 컴파일 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d77399e5aec1944b1adc6c9df8b906d840bfd80" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Mod&lt;/code&gt; referred to must be found in the code path and data returned by the function &lt;code&gt;Func&lt;/code&gt; is passed back to the client. Data returned from the function must take the form as specified in the CGI specification. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참조 된 모듈 &lt;code&gt;Mod&lt;/code&gt; 는 코드 경로에서 찾아야하며 &lt;code&gt;Func&lt;/code&gt; 함수에 의해 리턴 된 데이터 는 클라이언트로 다시 전달됩니다. 함수에서 리턴 된 데이터는 CGI 스펙에 지정된 양식을 가져야합니다. ESI 콜백 함수의 구현 세부 사항은 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29ac46e3b904139d6e66b6ec6030181dc36b417e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Module&lt;/code&gt; referred to must be found in the code path, and it must define a function &lt;code&gt;Function&lt;/code&gt; with an arity of two or three. It is preferable to implement a function with arity three, as it permits to send chunks of the web page to the client during the generation phase instead of first generating the whole web page and then sending it to the client. The option to implement a function with arity two is only kept for backwards compatibility reasons. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참조 된 모듈 &lt;code&gt;Module&lt;/code&gt; 은 코드 경로에 있어야하며 2 개 또는 3 개의 arity로 함수 &lt;code&gt;Function&lt;/code&gt; 을 정의해야합니다 . 먼저 전체 웹 페이지를 생성 한 다음 클라이언트로 전송하는 대신 생성 단계에서 웹 페이지 청크를 클라이언트로 전송할 수 있으므로 arity 3으로 기능을 구현하는 것이 좋습니다. arity 2로 함수를 구현하는 옵션은 이전 버전과의 호환성을 위해서만 유지됩니다. ESI 콜백 함수의 구현 세부 사항은 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="982c2295d64987c5a6f9815d8a88586d4220b412" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1ct&lt;/code&gt;, which provides the compile-time functions (including the compiler)</source>
          <target state="translated">컴파일 타임 함수 (컴파일러 포함)를 제공하는 &lt;code&gt;asn1ct&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="a79e4d001488233c5a176bdd084c0905e60ecc9c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1rt_nif&lt;/code&gt;, which provides the runtime functions for the ASN.1 decoder for the BER back end</source>
          <target state="translated">BER 백엔드 용 ASN.1 디코더에 런타임 기능을 제공하는 &lt;code&gt;asn1rt_nif&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="9ef07ceefb72a3876e128fd3d25802cdcc467713" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;code&gt;&lt;a href=&quot;#lines&quot;&gt;executable line&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">모듈 &lt;code&gt;cover&lt;/code&gt; 는 각 &lt;code&gt;&lt;a href=&quot;#lines&quot;&gt;executable line&lt;/a&gt;&lt;/code&gt; 이 몇 번 실행 되는지를 세는 Erlang 프로그램의 커버리지 분석을위한 일련의 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="781caf54426d4fb478a304a7844ea80922cfcec9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;strong&gt;executable line&lt;/strong&gt; of code is executed when a program is run.</source>
          <target state="translated">모듈 &lt;code&gt;cover&lt;/code&gt; 는 Erlang 프로그램의 커버리지 분석을위한 일련의 기능을 제공하며, 프로그램 이 실행될 때 각 &lt;strong&gt;실행&lt;/strong&gt; 코드 &lt;strong&gt;줄&lt;/strong&gt; 이 몇 번 &lt;strong&gt;실행&lt;/strong&gt; 되는지 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="0f91e217601b1dc046c35185750c3cff89af0626" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;eprof&lt;/code&gt; provides a set of functions for time profiling of Erlang programs to find out how the execution time is used. The profiling is done using the Erlang trace BIFs. Tracing of local function calls for a specified set of processes is enabled when profiling is begun, and disabled when profiling is stopped.</source>
          <target state="translated">&lt;code&gt;eprof&lt;/code&gt; 모듈 은 Erlang 프로그램의 시간 프로파일 링을위한 기능 세트를 제공하여 실행 시간이 어떻게 사용되는지 알아냅니다. 프로파일 링은 Erlang 추적 BIF를 사용하여 수행됩니다. 프로파일 링이 시작되면 지정된 프로세스 세트에 대한 로컬 함수 호출 추적이 사용 가능하고 프로파일 링이 중지되면 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c504d09107327f4319315c36b9c3bb90edddcb97" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_display_demo.erl&lt;/code&gt; illustrates how it can be used:</source>
          <target state="translated">&lt;code&gt;et/examples/et_display_demo.erl&lt;/code&gt; 모듈 은 사용 방법을 보여줍니다 :</target>
        </trans-unit>
        <trans-unit id="259f6a111f8e10963d253f6c20a7ce32cd0fbcc2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_trace_demo.erl&lt;/code&gt; achieves this.</source>
          <target state="translated">&lt;code&gt;et/examples/et_trace_demo.erl&lt;/code&gt; 모듈 이이를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="2e6fc57c9903415812e7aa14d0de98a4a3c76906" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;init&lt;/code&gt; contains functions for restarting, rebooting, and stopping the runtime system:</source>
          <target state="translated">모듈 &lt;code&gt;init&lt;/code&gt; 에는 런타임 시스템 재시작, 재부팅 및 중지 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3abc6c505ceadd88e545ffef89881ad4330aca42" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;instrument&lt;/code&gt; contains support for studying the resource usage in an Erlang runtime system. Currently, only the allocation of memory can be studied.</source>
          <target state="translated">모듈 &lt;code&gt;instrument&lt;/code&gt; 에는 Erlang 런타임 시스템에서 자원 사용량을 연구하기위한 지원이 포함되어 있습니다. 현재는 메모리 할당 만 연구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="941709a144919cb9d4879d80ca49d5703f70c432" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;lists&lt;/code&gt; contains many functions for manipulating lists, for example, for reversing them. So before writing a list-manipulating function it is a good idea to check if one not already is written for you (see the &lt;code&gt;lists(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">모듈 &lt;code&gt;lists&lt;/code&gt; 에는 목록 을 조작하는 등의 여러 가지 기능이 포함되어 있습니다. 따라서리스트 조작 함수를 작성하기 전에 아직 작성되지 않았는지 확인하는 것이 좋습니다 ( STDLIB 의 &lt;code&gt;lists(3)&lt;/code&gt; 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="0b557c4c0674c40fdfca518a79b00693470cbb4b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;make&lt;/code&gt; provides a set of functions similar to the UNIX type &lt;code&gt;Make&lt;/code&gt; functions.</source>
          <target state="translated">모듈 &lt;code&gt;make&lt;/code&gt; 는 UNIX 유형 &lt;code&gt;Make&lt;/code&gt; 기능 과 유사한 기능 세트를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="d33a6d96eeffbee10dd02fa8fc1a44592f775997" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;mod_cgi&lt;/code&gt; enables execution of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;CGI scripts&lt;/a&gt;&lt;/code&gt; on the server. A file matching the definition of a ScriptAlias config directive is treated as a CGI script. A CGI script is executed by the server and its output is returned to the client.</source>
          <target state="translated">모듈 &lt;code&gt;mod_cgi&lt;/code&gt; 를 사용 하면 서버에서 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;CGI scripts&lt;/a&gt;&lt;/code&gt; 를 실행할 수 있습니다 . ScriptAlias ​​구성 지시문의 정의와 일치하는 파일은 CGI 스크립트로 처리됩니다. CGI 스크립트는 서버에 의해 실행되며 해당 출력은 클라이언트에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89aebd55be35237517f0292d086307a4abfce4d9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp&lt;/code&gt; contains interface functions to the SNMP toolkit.</source>
          <target state="translated">모듈 &lt;code&gt;snmp&lt;/code&gt; 에는 SNMP 툴킷에 대한 인터페이스 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28864fb1efef12bf7914da0d813b6fa91aa2615" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_community_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-COMMUNITY-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_community_mib&lt;/code&gt; 모듈 은 SNMP-COMMUNITY-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ef3d7428030a1ee96b52a462582efaf9645f114a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_framework_mib&lt;/code&gt; implements instrumentation functions for the SNMP-FRAMEWORK-MIB, and functions for initializing and configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_framework_mib&lt;/code&gt; 모듈 은 SNMP-FRAMEWORK-MIB에 대한 계측 기능과 데이터베이스 초기화 및 구성을위한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="095f5718c68bbc524071ea724e79d3350f41b68e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_generic&lt;/code&gt; contains generic functions for implementing tables (and variables) using the SNMP built-in database or Mnesia. These default functions are used if no instrumentation function is provided for a managed object in a MIB. Sometimes, it might be necessary to customize the behaviour of the default functions. For example, in some situations a trap should be sent if a row is deleted or modified, or some hardware is to be informed, when information is changed.</source>
          <target state="translated">&lt;code&gt;snmp_generic&lt;/code&gt; 모듈 에는 SNMP 내장 데이터베이스 또는 Mnesia를 사용하여 테이블 및 변수를 구현하기위한 일반 함수가 포함되어 있습니다. 이러한 기본 기능은 MIB의 관리 대상 객체에 인스 트루먼 테이션 기능이 제공되지 않은 경우에 사용됩니다. 때로는 기본 기능의 동작을 사용자 정의해야 할 수도 있습니다. 예를 들어, 어떤 상황에서는 정보가 변경 될 때 행이 삭제 또는 수정되거나 일부 하드웨어에 알려야 할 경우 트랩을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="82a890681bf1941535370d5663cafcbba66ae605" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_index&lt;/code&gt; implements an Abstract Data Type (ADT) for an SNMP index structure for SNMP tables. It is implemented as an ets table of the ordered_set data-type, which means that all operations are O(log n). In the table, the key is an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">&lt;code&gt;snmp_index&lt;/code&gt; 모듈 은 SNMP 테이블의 SNMP 인덱스 구조에 대한 ADT (Abstract Data Type)를 구현합니다. ordered_set 데이터 유형의 ets 테이블로 구현되며 이는 모든 작업이 O (log n)임을 의미합니다. 표에서 키는 ASN.1 OBJECT IDENTIFIER입니다.</target>
        </trans-unit>
        <trans-unit id="e2f9fd8895a2ad05f79cba6aa4a560674948ff16" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_notification_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-NOTIFICATION-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_notification_mib&lt;/code&gt; 모듈 은 SNMP-NOTIFICATION-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4f8a67bb8f067e1a717000055707220ab821c05a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_pdus&lt;/code&gt; contains functions for encoding and decoding of SNMP protocol data units (PDUs). In short, this module converts a list of bytes to Erlang record representations and vice versa. The record definitions can be found in the file &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt;. If snmpv3 is used, the module that includes &lt;code&gt;snmp_types.hrl&lt;/code&gt; must define the constant &lt;code&gt;SNMP_USE_V3&lt;/code&gt; before the header file is included. Example:</source>
          <target state="translated">&lt;code&gt;snmp_pdus&lt;/code&gt; 모듈 에는 SNMP 프로토콜 데이터 단위 (PDU)의 인코딩 및 디코딩을위한 기능이 포함되어 있습니다. 간단히 말해서이 모듈은 바이트 목록을 Erlang 레코드 표현으로 변환하거나 그 반대로 변환합니다. 레코드 정의는 &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt; 파일에서 찾을 수 있습니다 . snmpv3을 사용하는 경우 &lt;code&gt;snmp_types.hrl&lt;/code&gt; 을 포함하는 모듈 은 헤더 파일이 포함되기 전에 상수 &lt;code&gt;SNMP_USE_V3&lt;/code&gt; 을 정의해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="5725f0842bc0666fa7d375bd7f8ddd2c680d73f4" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_standard_mib&lt;/code&gt; implements the instrumentation functions for the STANDARD-MIB and SNMPv2-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_standard_mib&lt;/code&gt; 모듈 은 STANDARD-MIB 및 SNMPv2-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9794cfac19d7a807e63c08b3a5fe1b5a39649e0d" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_target_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-TARGET-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_target_mib&lt;/code&gt; 모듈 은 SNMP-TARGET-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3f6c026f9e309eb46ab31fc9b2d89fed73cf8841" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_user_based_sm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-USER-BASED-SM-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_user_based_sm_mib&lt;/code&gt; 모듈 은 SNMP-USER-BASED-SM-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="57a4fcf0421c558f55d4b62d7f4d570a983d47de" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_view_based_acm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-VIEW-BASED-ACM-MIB, and functions for configuring the database.</source>
          <target state="translated">&lt;code&gt;snmp_view_based_acm_mib&lt;/code&gt; 모듈 은 SNMP-VIEW-BASED-ACM-MIB에 대한 계측 기능과 데이터베이스 구성 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="cb84eb23430061b5d0ba52fb1f1dcb8cae6958c3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa&lt;/code&gt; contains interface functions to the SNMP agent.</source>
          <target state="translated">&lt;code&gt;snmpa&lt;/code&gt; 모듈 에는 SNMP 에이전트에 대한 인터페이스 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc8950e817bfb35a3a5269149811e72d9216ab2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP agent.</source>
          <target state="translated">&lt;code&gt;snmpa_conf&lt;/code&gt; 모듈 에는 SNMP 에이전트의 구성 파일을 조작 (쓰기 / 추가 / 읽기)하는 데 사용되는 다양한 유틸리티 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c00aa92168aea59cf4babd7411c60aa30b9bb12" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error&lt;/code&gt; contains two callback functions which are called if an error occurs at different times during agent operation. These functions in turn calls the corresponding function in the configured error report module, which implements the actual report functionality.</source>
          <target state="translated">&lt;code&gt;snmpa_error&lt;/code&gt; 모듈 에는 에이전트 작동 중 서로 다른 시간에 오류가 발생하면 호출되는 두 개의 콜백 함수가 포함되어 있습니다. 이러한 함수는 구성된 오류 보고서 모듈에서 해당 함수를 호출하여 실제 보고서 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7764fca7b7977a857a18cfe1fc6018c7939c753c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_io&lt;/code&gt; implements the &lt;code&gt;snmp_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="translated">&lt;code&gt;snmpa_error_io&lt;/code&gt; 모듈 은 SNMP 오류를보고하기 위해 호출되는 두 개의 콜백 함수를 포함 하는 &lt;code&gt;snmp_error_report&lt;/code&gt; 동작 ( &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt; 참조 )을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5fb427e1b1c2244f167076a6c28620f6bd0ca500" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_logger&lt;/code&gt; implements the &lt;code&gt;snmpa_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="translated">&lt;code&gt;snmpa_error_logger&lt;/code&gt; 모듈 은 SNMP 오류를보고하기 위해 호출되는 두 개의 콜백 함수를 포함 하는 &lt;code&gt;snmpa_error_report&lt;/code&gt; 동작 ( &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt; 참조 )을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="83bb96f4babc6a5eacc014cc415f81b568ec9857" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_local_db&lt;/code&gt; contains functions for implementing tables (and variables) using the SNMP built-in database. The database exists in two instances, one volatile and one persistent. The volatile database is implemented with ets. The persistent database is implemented with dets.</source>
          <target state="translated">&lt;code&gt;snmpa_local_db&lt;/code&gt; 모듈 에는 SNMP 내장 데이터베이스를 사용하여 테이블 (및 변수)을 구현하는 기능이 포함되어 있습니다. 데이터베이스는 휘발성과 영구의 두 가지 인스턴스로 존재합니다. 휘발성 데이터베이스는 ets로 구현됩니다. 영구 데이터베이스는 det로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="55631c2398416971197f57a07cee463eafb2a6d3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the agent. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Definition of Agent Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;snmpa_mpd&lt;/code&gt; 모듈 은 에이전트의 SNMP에서 버전 독립적 메시지 처리 및 디스패치 기능을 구현합니다. 네트워크 인터페이스 프로세스 ( &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Definition of Agent Net if&lt;/a&gt;&lt;/code&gt; )에서 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="124a2b3f4d74eeec626680e394ad1513621980ef" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpc&lt;/code&gt; contains interface functions to the SNMP toolkit MIB compiler.</source>
          <target state="translated">&lt;code&gt;snmpc&lt;/code&gt; 모듈 에는 SNMP 툴킷 MIB 컴파일러에 대한 인터페이스 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53e4bdf4bb95582196719c70dc1fba81cd26c5b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm&lt;/code&gt; contains interface functions to the SNMP manager.</source>
          <target state="translated">&lt;code&gt;snmpm&lt;/code&gt; 모듈 에는 SNMP 관리자에 대한 인터페이스 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9deea834f053c18dad6106ffd7fd172a36d88d96" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP manager.</source>
          <target state="translated">&lt;code&gt;snmpm_conf&lt;/code&gt; 모듈 에는 SNMP 관리자의 구성 파일을 조작 (쓰기 / 추가 / 읽기)하는 데 사용되는 다양한 유틸리티 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f85a168a189fdceec5a2d241d8dfe3e80b2124a7" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the manager. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_manager_netif&quot;&gt;Definition of Manager Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;snmpm_mpd&lt;/code&gt; 모듈 은 버전 독립적 인 메시지 처리 및 발송 기능을 SNMP의 관리자 용으로 구현합니다. 네트워크 인터페이스 프로세스 ( &lt;code&gt;&lt;a href=&quot;snmp_manager_netif&quot;&gt;Definition of Manager Net if&lt;/a&gt;&lt;/code&gt; )에서 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="301e9d486412f01bcf2672b9abce6a87a421abaf" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;unicode&lt;/code&gt; even supports similar mixes with binaries containing other encodings than UTF-8, but that is a special case to allow for conversions to and from external data:</source>
          <target state="translated">모듈 &lt;code&gt;unicode&lt;/code&gt; 는 UTF-8 이외의 다른 인코딩을 포함하는 바이너리와 유사한 믹스를 지원하지만 외부 데이터와의 변환을 허용하는 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="36591fbbad4d0a32aa408280d9af7fb21f38f345" translate="yes" xml:space="preserve">
          <source>The module begins with the usual directives, a function to start the I/O server and a main loop handling the requests:</source>
          <target state="translated">모듈은 일반적인 지시문, I / O 서버를 시작하는 기능 및 요청을 처리하는 기본 루프로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="517094b39f1e8298c34a64523b0a81f6e27a7939" translate="yes" xml:space="preserve">
          <source>The module can be used as follows:</source>
          <target state="translated">이 모듈은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b7dab89c3e12645bda4285fa81fa7ba3e89769" translate="yes" xml:space="preserve">
          <source>The module can now be checked for calls to &lt;code&gt;&lt;a href=&quot;xref#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;xref#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;xref#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 , &lt;code&gt;&lt;a href=&quot;xref#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 및 사용되지 않은 로컬 함수 에 대해 모듈을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b501a9e25197a0d2d4d8c4d153e95197c1dc5515" translate="yes" xml:space="preserve">
          <source>The module check and the predefined analyses are useful, but limited. Sometimes more flexibility is needed, for instance one might not need to apply a graph analysis on all calls, but some subset will do equally well. That flexibility is provided with a simple language. Below are some expressions of the language with comments, focusing on elements of the language rather than providing useful examples. The analyzed system is assumed to be OTP, so in order to run the queries, first evaluate these calls:</source>
          <target state="translated">모듈 확인 및 사전 정의 된 분석은 유용하지만 제한적입니다. 때로는 더 많은 유연성이 필요합니다. 예를 들어 모든 통화에 대해 그래프 분석을 적용 할 필요는 없지만 일부 하위 집합은 동일하게 작동합니다. 이러한 유연성은 간단한 언어로 제공됩니다. 다음은 유용한 예를 제공하기보다는 언어 요소에 중점을 둔 주석이 포함 된 언어의 표현입니다. 분석 된 시스템은 OTP 인 것으로 가정되므로 쿼리를 실행하려면 먼저 다음 호출을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="9f34c93923a124126ae9987ed5ba7d0cd3a880a0" translate="yes" xml:space="preserve">
          <source>The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.</source>
          <target state="translated">이 모듈은 Kernel, STDLIB, GS 또는 Debugger 응용 프로그램에 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df43f32272eb4d398f8b34dc6bda83d31dc742c2" translate="yes" xml:space="preserve">
          <source>The module exports the following functions:</source>
          <target state="translated">모듈은 다음 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a8324f5d5b875808800ad4bfccc10ff9a5ba92ef" translate="yes" xml:space="preserve">
          <source>The module has an &lt;code&gt;-on_load function&lt;/code&gt; that failed when it was called.</source>
          <target state="translated">모듈 에 호출시 실패한 &lt;code&gt;-on_load function&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a549a328785c37eb26a4d0b0876090f69d89f62f" translate="yes" xml:space="preserve">
          <source>The module has been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="translated">모듈은 옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트 로 컴파일되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4009d0d64b6afc399eea7069fcbf0bea4113eca2" translate="yes" xml:space="preserve">
          <source>The module has not been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="translated">모듈이 옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트 로 컴파일되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="61d3758ed9d8815ae40a582326b2d576731c58d3" translate="yes" xml:space="preserve">
          <source>The module implementing the default user. See the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">기본 사용자를 구현하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; 동작을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0b8a7cb2b22e6ad5a3d1b43145f3b8010311a6a" translate="yes" xml:space="preserve">
          <source>The module implementing this behaviour shall be supplied to to the servers configuration with the option &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt;customize&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 동작을 구현하는 모듈은 &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt;customize&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 서버 구성에 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b66eedc6242758f2f48c0f5c1e1f06419d138c4f" translate="yes" xml:space="preserve">
          <source>The module is provided according to Erlang Enhancement Proposal (EEP) 31.</source>
          <target state="translated">이 모듈은 Erlang Enhancement Proposal (EEP) 31에 따라 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e32c3dc9ba3ffd5afe1da65ac5bac03e04a15fd8" translate="yes" xml:space="preserve">
          <source>The module name of the event handler.</source>
          <target state="translated">이벤트 핸들러의 모듈 이름입니다.</target>
        </trans-unit>
        <trans-unit id="329e9b070ed603033e7dd3e45d35cd86f7bb6554" translate="yes" xml:space="preserve">
          <source>The module needs to create some kind of listening entity (process or port) and an acceptor process that accepts incoming connections using the listening entity. For each connection, the module at least needs to create one connection supervisor process, which also is responsible for the handshake when setting up the connection, and a distribution controller (process or port) responsible for transport of data over the connection. The distribution controller and the connection supervisor process should be linked together so both of them are cleaned up when the connection is taken down.</source>
          <target state="translated">모듈은 일종의 청취 엔티티 (프로세스 또는 포트)와 청취 엔티티를 사용하여 들어오는 연결을 수락하는 수락 자 프로세스를 작성해야합니다. 각 연결에 대해 모듈은 연결을 설정할 때 핸드 셰이크를 담당하는 연결 관리자 프로세스와 연결을 통한 데이터 전송을 담당하는 배포 컨트롤러 (프로세스 또는 포트)를 하나 이상 만들어야합니다. 분배 제어기와 연결 감독자 프로세스는 서로 연결되어 연결이 끊어 질 때 둘 다 정리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a0efe94bfa8ce9cd46e5764feb6320f9f30baae" translate="yes" xml:space="preserve">
          <source>The module supports &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; in the way that if a binary is present, or the filename cannot be interpreted according to the return value of &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, a raw filename is also returned. For example, &lt;code&gt;join/1&lt;/code&gt; provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">모듈 지지부 &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; 바이너리가 존재하는 경우, 또는 파일명의 리턴 값에 따라 해석 될 수있는 방식으로 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; , 원시 파일명은 반환된다. 예를 들어 이진 경로 구성 요소 (현재 기본 파일 이름 인코딩으로 해석 할 수 없음)가 제공되는 &lt;code&gt;join/1&lt;/code&gt; 은 원시 파일 이름을 반환합니다 (결합 작업은 물론 수행됨). 원시 파일 이름에 대한 자세한 내용은 &lt;code&gt;file&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69b8aad69f452e4e151ee9bedf58e923325c5f2c" translate="yes" xml:space="preserve">
          <source>The module that implements the channel behaviour.</source>
          <target state="translated">채널 동작을 구현하는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="334303a0b2e03a18e4f74196d147acdf2eda4f6c" translate="yes" xml:space="preserve">
          <source>The module that you specify gets passed down (eventually) into &lt;code&gt;Selector&lt;/code&gt;'s default &lt;code&gt;Filter&lt;/code&gt;. The format of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function call is hardcoded in that &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="translated">지정한 모듈은 결국 &lt;code&gt;Selector&lt;/code&gt; 의 기본 &lt;code&gt;Filter&lt;/code&gt; 로 전달됩니다 . &lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 호출 의 형식은 해당 &lt;code&gt;Filter&lt;/code&gt; 하드 코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9b6419eaf88095b6d469b88c58301f91a2d21d9" translate="yes" xml:space="preserve">
          <source>The module which handles the network interface part for the SNMP manager. It must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">SNMP 관리자의 네트워크 인터페이스 부분을 처리하는 모듈입니다. &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; 동작을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="523418eaa35d035f87ca00b206f2ef37af5e7c87" translate="yes" xml:space="preserve">
          <source>The module window is started by double clicking on an module name. The module window consists initially of two pages (tabs):</source>
          <target state="translated">모듈 이름은 모듈 이름을 두 번 클릭하여 시작됩니다. 모듈 창은 처음에 두 페이지 (탭)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5f14cab5a9810db8644af6de1dc33fee56bf0da0" translate="yes" xml:space="preserve">
          <source>The modules added will not be members of any applications.</source>
          <target state="translated">추가 된 모듈은 응용 프로그램의 구성원이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="49c86e71c1ea6137a22400599bd617796af2cd26" translate="yes" xml:space="preserve">
          <source>The modules found in the given directory are checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 디렉토리에있는 모듈은 &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 , &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 및 사용되지 않은 로컬 함수 에 대해 점검 됩니다. 코드 경로는 &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1e420d1465bd766460e3f9194e1ada5445f2bda" translate="yes" xml:space="preserve">
          <source>The monitor functionality is expected to be extended. That is, other &lt;code&gt;Type&lt;/code&gt;s and &lt;code&gt;Item&lt;/code&gt;s are expected to be supported in a future release.</source>
          <target state="translated">모니터 기능이 확장 될 것으로 예상됩니다. 즉, 다른 &lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;Item&lt;/code&gt; 은 향후 릴리스에서 지원 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="2df469dc538ecc56583353d35b1798e5f963f917" translate="yes" xml:space="preserve">
          <source>The monitor is &lt;strong&gt;not&lt;/strong&gt; automatically removed after it has been triggered. That is, repeated changes of the time offset trigger the monitor repeatedly.</source>
          <target state="translated">모니터는 트리거 된 후에 자동으로 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 즉, 시간 오프셋을 반복해서 변경하면 모니터가 반복적으로 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="15ac3ec7a48d328efe660154448400a11004f42c" translate="yes" xml:space="preserve">
          <source>The monitor is triggered when the time offset is changed. This either if the time offset value is changed, or if the offset is changed from preliminary to final during &lt;code&gt;&lt;a href=&quot;#system_flag_time_offset&quot;&gt;finalization of the time offset&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used. When a change from preliminary to final time offset is made, the monitor is triggered once regardless of whether the time offset value was changed or not.</source>
          <target state="translated">시간 오프셋이 변경되면 모니터가 트리거됩니다. 이는 시간 오프셋 값이 변경되거나 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 가 사용될 때 &lt;code&gt;&lt;a href=&quot;#system_flag_time_offset&quot;&gt;finalization of the time offset&lt;/a&gt;&lt;/code&gt; 동안 오프셋이 예비에서 최종으로 변경 되는 경우입니다. 예비에서 최종 시간 오프셋으로 변경하면 시간 오프셋 값의 변경 여부에 관계없이 모니터가 한 번 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a9034b98321dccce18cf451d8ab9d47b947240ef" translate="yes" xml:space="preserve">
          <source>The monitor message is sent if the sum of the sizes of all memory blocks allocated for all heap generations after a garbage collection is equal to or higher than &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">가비지 콜렉션 후 모든 힙 생성에 할당 된 모든 메모리 블록의 크기 합계가 &lt;code&gt;Size&lt;/code&gt; 이상인 경우 모니터 메시지가 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="280bfd2e726362f1c09866455524beac7cfe5de9" translate="yes" xml:space="preserve">
          <source>The monitor request is an asynchronous signal. That is, it takes time before the signal reaches its destination.</source>
          <target state="translated">모니터 요청은 비동기 신호입니다. 즉, 신호가 목적지에 도달하기까지 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="4b32b393fd0afad77f1403e24066f7c431fc21ce" translate="yes" xml:space="preserve">
          <source>The monitor tag is always &lt;code&gt;driver&lt;/code&gt;, as this function can only be used to create driver monitors. In the future, driver monitors will be integrated with process monitors, why this parameter has to be specified for consistence.</source>
          <target state="translated">이 기능은 드라이버 모니터를 만드는 데만 사용할 수 있으므로 모니터 태그는 항상 &lt;code&gt;driver&lt;/code&gt; 입니다. 앞으로 드라이버 모니터는 프로세스 모니터와 통합 될 것이므로이 매개 변수를 일관성을 위해 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="be29116d55d7dfe82c5e11e2f4acffe31864278e" translate="yes" xml:space="preserve">
          <source>The monitor was found and removed. In this case, no &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor has been delivered and will not be delivered.</source>
          <target state="translated">모니터를 찾아서 제거했습니다. 이 경우이 모니터에 해당하는 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지가 전달되지 않고 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0337b55edbb713b6c9fbbc890aad45af45f21f06" translate="yes" xml:space="preserve">
          <source>The monitor was not found and could not be removed. This probably because someone already has placed a &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor in the caller message queue.</source>
          <target state="translated">모니터를 찾을 수 없어서 제거 할 수 없습니다. 누군가 누군가 이미이 모니터에 해당 하는 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지를 발신자 메시지 큐에 넣었 기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab04c2416f519588a8e783d3297a16514c4e755" translate="yes" xml:space="preserve">
          <source>The monitored driver instance is now unloaded. As the unload can be a result of a &lt;code&gt;reload/2&lt;/code&gt; request, the driver can once again have been loaded when this message arrives.</source>
          <target state="translated">모니터링 된 드라이버 인스턴스가 언로드됩니다. 언로드는 &lt;code&gt;reload/2&lt;/code&gt; 요청 의 결과 일 수 있으므로이 메시지가 도착하면 드라이버가 다시로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d7c84598d002ae7b2cdc74963ff39c11423b77" translate="yes" xml:space="preserve">
          <source>The monitored entity, which triggered the event. When monitoring a local process or port, &lt;code&gt;Object&lt;/code&gt; will be equal to the &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; that was being monitored. When monitoring process or port by name, &lt;code&gt;Object&lt;/code&gt; will have format &lt;code&gt;{RegisteredName, Node}&lt;/code&gt; where &lt;code&gt;RegisteredName&lt;/code&gt; is the name which has been used with &lt;code&gt;monitor/2&lt;/code&gt; call and &lt;code&gt;Node&lt;/code&gt; is local or remote node name (for ports monitored by name, &lt;code&gt;Node&lt;/code&gt; is always local node name).</source>
          <target state="translated">이벤트를 트리거 한 모니터링 된 엔티티. 로컬 프로세스 또는 포트를 모니터링 할 때 &lt;code&gt;Object&lt;/code&gt; 는 모니터링중인 &lt;code&gt;pid()&lt;/code&gt; 또는 &lt;code&gt;port()&lt;/code&gt; 와 같습니다. 이름으로 프로세스 또는 포트를 모니터링 할 때 &lt;code&gt;Object&lt;/code&gt; 의 형식은 &lt;code&gt;{RegisteredName, Node}&lt;/code&gt; 여기서 &lt;code&gt;RegisteredName&lt;/code&gt; 은 &lt;code&gt;monitor/2&lt;/code&gt; 호출 에 사용 된 이름 이고 &lt;code&gt;Node&lt;/code&gt; 는 로컬 또는 원격 노드 이름입니다 (이름으로 모니터링되는 포트의 경우 &lt;code&gt;Node&lt;/code&gt; 는 항상 로컬 임 노드 이름).</target>
        </trans-unit>
        <trans-unit id="6bf06e86189be19acddd04d200927d656e7dd37d" translate="yes" xml:space="preserve">
          <source>The most basic form of a batch is created by semicolons separated SQL queries, for example:</source>
          <target state="translated">배치의 가장 기본적인 형태는 세미콜론으로 구분 된 SQL 쿼리에 의해 생성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a59719eda6e9d01c978b1c0cfa6a96f9fcd184fa" translate="yes" xml:space="preserve">
          <source>The most common application of transaction mechanisms is to keep row operations together. Since our agent sorts row operations, the mechanism implemented in combination with the RowStatus (particularly 'createAndWait' value) solve most problems elegantly.</source>
          <target state="translated">트랜잭션 메커니즘의 가장 일반적인 적용은 행 작업을 함께 유지하는 것입니다. 에이전트가 행 작업을 정렬하므로 RowStatus (특히 'createAndWait'값)와 함께 구현 된 메커니즘은 대부분의 문제를 우아하게 해결합니다.</target>
        </trans-unit>
        <trans-unit id="8a9c06d55eedc6a8d2f902ccf52e01e8b01e26ff" translate="yes" xml:space="preserve">
          <source>The most commonly used BIFs belonging to &lt;code&gt;erlang(3)&lt;/code&gt; are &lt;strong&gt;auto-imported&lt;/strong&gt;. They do not need to be prefixed with the module name. Which BIFs that are auto-imported is specified in the &lt;code&gt;erlang(3)&lt;/code&gt; module in ERTS. For example, standard-type conversion BIFs like &lt;code&gt;atom_to_list&lt;/code&gt; and BIFs allowed in guards can be called without specifying the module name.</source>
          <target state="translated">&lt;code&gt;erlang(3)&lt;/code&gt; 속하는 가장 일반적으로 사용되는 BIF 는 &lt;strong&gt;자동으로 가져 &lt;/strong&gt;옵니다 . 모듈 이름을 접두사로 사용할 필요는 없습니다. 자동 반입되는 BIF 는 ERTS 의 &lt;code&gt;erlang(3)&lt;/code&gt; 모듈에 지정되어 있습니다. 예를 들어, &lt;code&gt;atom_to_list&lt;/code&gt; 및 가드에서 허용되는 BIF와 같은 표준 유형 변환 BIF 는 모듈 이름을 지정하지 않고 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f932fa2c48442351da05c7f82e31aff3efd5a23" translate="yes" xml:space="preserve">
          <source>The most commonly used types are &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;binary&lt;/code&gt;. See &lt;code&gt;Bit Syntax Expressions in the Reference Manual&lt;/code&gt; for a complete description.</source>
          <target state="translated">가장 일반적으로 사용되는 유형은 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;binary&lt;/code&gt; 입니다. 자세한 설명 &lt;code&gt;Bit Syntax Expressions in the Reference Manual&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac9d64e469ef7ced56b3eabcbe1d40968b713a6c" translate="yes" xml:space="preserve">
          <source>The most flexible way to specify what to test, is to use a test specification, which is a sequence of Erlang terms. The terms are normally declared in one or more text files (see &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), but can also be passed to &lt;code&gt;Common Test&lt;/code&gt; on the form of a list (see &lt;code&gt;&lt;a href=&quot;ct#run_testspec-1&quot;&gt;ct:run_testspec/1&lt;/a&gt;&lt;/code&gt;). There are two general types of terms: configuration terms and test specification terms.</source>
          <target state="translated">테스트 대상을 지정하는 가장 유연한 방법은 일련의 Erlang 용어 인 테스트 사양을 사용하는 것입니다. 용어는 일반적으로 하나 개 이상의 텍스트 파일에 선언합니다 ( &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ), 또한 전달 될 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 목록의 양식에 (참조 &lt;code&gt;&lt;a href=&quot;ct#run_testspec-1&quot;&gt;ct:run_testspec/1&lt;/a&gt;&lt;/code&gt; ). 구성 용어와 테스트 사양 용어라는 두 가지 일반 용어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63e88fd2ffaffa754471ae2efc5aaf19cc51d66" translate="yes" xml:space="preserve">
          <source>The most notable difference between a match specification and an Erlang fun is the syntax. Match specifications are Erlang terms, not Erlang code. Also, a match specification has a strange concept of exceptions:</source>
          <target state="translated">일치 사양과 Erlang 재미의 가장 눈에 띄는 차이점은 구문입니다. 일치 사양은 Erlang 코드가 아니라 Erlang 용어입니다. 또한 일치 사양에는 이상한 예외 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a46d708256a890cc8c5bbd317f2b1f19c5bc43" translate="yes" xml:space="preserve">
          <source>The most recent log file is the rightmost in each row. That is, the most recent file is the one with the highest number, or if there are already four files, the one before the skip.</source>
          <target state="translated">가장 최근의 로그 파일은 각 행에서 가장 오른쪽에 있습니다. 즉, 가장 최근의 파일은 가장 높은 번호의 파일이거나 이미 4 개의 파일이있는 경우 건너 뛰기 전에 한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="cd0e7640ef8705dad251d2e736a5efef30cdd300" translate="yes" xml:space="preserve">
          <source>The most significant bit is the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt;. If set, the corresponding cache reference is new. The three least significant bits are the &lt;code&gt;SegmentIndex&lt;/code&gt; of the corresponding atom cache entry. An atom cache consists of 8 segments, each of size 256, that is, an atom cache can contain 2048 entries.</source>
          <target state="translated">가장 중요한 비트는 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 입니다. 설정된 경우 해당 캐시 참조는 새로운 것입니다. 3 개의 최하위 비트는 해당 아톰 캐시 항목 의 &lt;code&gt;SegmentIndex&lt;/code&gt; 입니다. 아톰 캐시는 각각 크기가 256 인 8 개의 세그먼트로 구성됩니다. 즉 아톰 캐시는 2048 개의 항목을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2788a4ce9749d7747a7b2405ff14fe489fb5bd3b" translate="yes" xml:space="preserve">
          <source>The most straightforward representation. Each character is stored in one single 32-bit number. There is no need for escapes or any variable number of entities for one character. All Unicode code points can be stored in one single 32-bit entity. As with UTF-16, there are byte-order issues. UTF-32 can be both big-endian and little-endian.</source>
          <target state="translated">가장 간단한 표현입니다. 각 문자는 하나의 단일 32 비트 숫자로 저장됩니다. 한 문자에 대해 이스케이프 나 다양한 수의 엔티티가 필요하지 않습니다. 모든 유니 코드 코드 포인트는 하나의 단일 32 비트 엔터티에 저장 될 수 있습니다. UTF-16과 마찬가지로 바이트 순서 문제가 있습니다. UTF-32는 빅 엔디안 및 리틀 엔디안 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276f7c971b5e4ce251c40cb717c8adebadd70cf8" translate="yes" xml:space="preserve">
          <source>The most use of this function would be if one for example uses the &lt;code&gt;io&lt;/code&gt; module to communicate with an I/O-server for a regular file, like in the following example:</source>
          <target state="translated">예를 들어 다음 예제와 같이 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 일반 파일의 I / O 서버와 통신하는 경우이 기능을 가장 많이 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="750fc0fe85477bda2150e648c512e34c1afec03c" translate="yes" xml:space="preserve">
          <source>The most versatile way to handle time-outs is to use Erlang Timers; see &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt;. Most time-out tasks can be performed with the time-out features in &lt;code&gt;gen_statem&lt;/code&gt;, but an example of one that can not is if you should need the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;, that is; the remaining time of the timer.</source>
          <target state="translated">시간 초과를 처리하는 가장 다양한 방법은 Erlang Timer를 사용하는 것입니다. &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt; 를 참조하십시오 . 대부분의 시간 초과 작업은 &lt;code&gt;gen_statem&lt;/code&gt; 의 시간 초과 기능을 사용하여 수행 할 수 있지만 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 의 반환 값이 필요한 경우는 아닙니다 . 타이머의 남은 시간</target>
        </trans-unit>
        <trans-unit id="8a0d9d7bcf952de8136817cdd4400566b2d55dbf" translate="yes" xml:space="preserve">
          <source>The motivation for alternate dictionaries is RFC 7683, Diameter Overload Indication Conveyance (DOIC), which defines AVPs to be piggybacked onto existing application messages rather than defining an application of its own. The DOIC dictionary is provided by the diameter application, as module &lt;code&gt;diameter_gen_doic_rfc7683&lt;/code&gt;, but alternate dictionaries can be used to encode/decode any set of AVPs not known to an application dictionary.</source>
          <target state="translated">대체 사전에 대한 동기는 RFC 7683, DOIC (Diameter Overload Indication Conveyance)로, AVP가 자체 애플리케이션을 정의하지 않고 기존 애플리케이션 메시지에 피기 백되도록 정의합니다. DOIC 사전은 모듈로서, 직경 애플리케이션에 의해 제공된다 &lt;code&gt;diameter_gen_doic_rfc7683&lt;/code&gt; 있지만, 다른 사전 인코딩 / 디코딩하기 위해 애플리케이션 사전에 공지되지 AVPs 임의의 세트를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="d91905ede33f8ff195d296077e558f92b868c336" translate="yes" xml:space="preserve">
          <source>The mouse buttons behave as expected. Use left-click to select objects, right-click to get a menu with the most used options, and double-click to display information about the selected object. In most viewers with many columns, you can change the sort order by left-clicking the column header.</source>
          <target state="translated">마우스 버튼이 예상대로 작동합니다. 마우스 왼쪽 버튼을 사용하여 객체를 선택하고 마우스 오른쪽 버튼을 클릭하여 가장 많이 사용하는 옵션이있는 메뉴를 표시 한 다음 두 번 클릭하여 선택한 객체에 대한 정보를 표시합니다. 열이 많은 대부분의 뷰어에서 열 머리글을 마우스 왼쪽 버튼으로 클릭하여 정렬 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d51d529839aa845352125415e30ac1e06dd6c469" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="translated">msg는 바이너리 &quot;cleartext&quot;데이터이거나 &quot;cleartext&quot;의 해시 값, 즉 다이제스트 (일반 텍스트)입니다.</target>
        </trans-unit>
        <trans-unit id="b14b4a3785c5957a50b987dae462b671878b64ca" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data to be signed or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="translated">msg는 서명 될 이진 &quot;cleartext&quot;데이터이거나 &quot;cleartext&quot;의 해시 값, 즉 다이제스트 (일반 텍스트)입니다.</target>
        </trans-unit>
        <trans-unit id="06e39bf8c6d5c07789729bace985f7385be5bc7d" translate="yes" xml:space="preserve">
          <source>The mstone (mstone1 and mstone2) module(s)</source>
          <target state="translated">mstone (mstone1 및 mstone2) 모듈</target>
        </trans-unit>
        <trans-unit id="b37835e9362863cab04224df2d6371e6a0fb053b" translate="yes" xml:space="preserve">
          <source>The multi-request tag (&lt;code&gt;requests&lt;/code&gt;) is handled in a separate loop function applying the requests in the list one after another, returning the last result.</source>
          <target state="translated">다중 요청 태그 ( &lt;code&gt;requests&lt;/code&gt; )는 목록의 요청을 차례로 적용하여 마지막 결과를 반환하는 별도의 루프 함수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="23debd07a945d566a02dcdb32a68d5943648993d" translate="yes" xml:space="preserve">
          <source>The multiblock carrier growth stages (&lt;code&gt;&lt;a href=&quot;#M_mbcgs&quot;&gt;mbcgs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#M_mbcgs&quot;&gt;mbcgs&lt;/a&gt;&lt;/code&gt; 블록 캐리어 성장 단계 ( mbcgs )</target>
        </trans-unit>
        <trans-unit id="ff5eb8ef08d964ccf13b2991de15ea2b46a940f2" translate="yes" xml:space="preserve">
          <source>The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example, the following matches &quot;1&quot;, &quot;2&quot;, or any non-digit:</source>
          <target state="translated">&quot;word&quot;라는 이름은 Perl 확장명이고 &quot;blank&quot;는 Perl 5.8의 GNU 확장명입니다. 또 다른 Perl 확장자는 부정이며 콜론 다음에 ^ 문자로 표시됩니다. 예를 들어, 다음은 &quot;1&quot;, &quot;2&quot;또는 숫자가 아닌 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f414a0fc6680e2dbcfe9f9956aebf12383da1b0d" translate="yes" xml:space="preserve">
          <source>The name (atom) of the group that the local node belongs to.</source>
          <target state="translated">로컬 노드가 속한 그룹의 이름 (원자).</target>
        </trans-unit>
        <trans-unit id="e804732505006dd7c7969c59d1f3efc6e15e1cf1" translate="yes" xml:space="preserve">
          <source>The name (atom) of the module.</source>
          <target state="translated">모듈의 이름 (아톰)</target>
        </trans-unit>
        <trans-unit id="8ea5812b14b364e780d92efa7352e85d9c8094a1" translate="yes" xml:space="preserve">
          <source>The name (string) of the BEAM file, or the binary from which the information was extracted.</source>
          <target state="translated">BEAM 파일의 이름 (문자열) 또는 정보가 추출 된 2 진.</target>
        </trans-unit>
        <trans-unit id="2274c550ae5b13836076f9a7929fd688045c89dd" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;lait/1&lt;/code&gt; is a misspelling - do not use it anymore.</source>
          <target state="translated">&lt;code&gt;lait/1&lt;/code&gt; 이라는 이름 은 철자가 틀리므로 더 이상 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="63f740169c092f330a56a6ac0c5a087138d89aff" translate="yes" xml:space="preserve">
          <source>The name of a generated dictionary module as generated by &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make#codec-2&quot;&gt;diameter_make:codec/2&lt;/a&gt;&lt;/code&gt;. The interface provided by a dictionary module is an implementation detail that may change.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;diameter_make#codec-2&quot;&gt;diameter_make:codec/2&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 생성 된 사전 모듈의 이름입니다 . 사전 모듈에서 제공하는 인터페이스는 변경 될 수있는 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="cdd16490cd1c460a31b904b705bbc01a37d6d356" translate="yes" xml:space="preserve">
          <source>The name of a process group.</source>
          <target state="translated">프로세스 그룹의 이름</target>
        </trans-unit>
        <trans-unit id="fe553f36c37e4dc0b840932349b35c736986e7b9" translate="yes" xml:space="preserve">
          <source>The name of a registered port, as an atom.</source>
          <target state="translated">원자로 등록 된 포트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="068c1e29898954da7dafd70c60c0281782bdf6c5" translate="yes" xml:space="preserve">
          <source>The name of a registered process, as an atom.</source>
          <target state="translated">원자로 등록 된 프로세스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="781b85e865fd06d99312a507847ed2319f617cf1" translate="yes" xml:space="preserve">
          <source>The name of a zip file.</source>
          <target state="translated">zip 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="14a3bc59edd8f43ed0656e84308b952ff50507a2" translate="yes" xml:space="preserve">
          <source>The name of all instrumentation functions must be the same as the corresponding managed object it implements.</source>
          <target state="translated">모든 인스 트루먼 테이션 기능의 이름은 구현하는 해당 관리 오브젝트와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fd2da7d7d7f0930e22b98a6d6e1a55d9b181147" translate="yes" xml:space="preserve">
          <source>The name of an executable program that can be used as an interface for specifying and running tests with &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 로 테스트를 지정하고 실행하기위한 인터페이스로 사용할 수있는 실행 가능 프로그램의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="ceba45d1b18e3dd3cc8da1a11142ef2efd79c65f" translate="yes" xml:space="preserve">
          <source>The name of the ASN.1 specification</source>
          <target state="translated">ASN.1 사양의 이름</target>
        </trans-unit>
        <trans-unit id="017669fbaeb7cca7f42900b9524557094afd427e" translate="yes" xml:space="preserve">
          <source>The name of the AVP as defined in the dictionary file in question, or &lt;code&gt;undefined&lt;/code&gt; if the AVP is unknown to the dictionary file in question.</source>
          <target state="translated">해당 사전 파일에 정의 된 AVP의 이름이거나 해당 사전 파일에 대해 AVP를 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb19f7e4ed9ccee1886a04f755cad374e6bf2833" translate="yes" xml:space="preserve">
          <source>The name of the command set by &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:open_port/2&lt;/code&gt; 에 의해 설정된 명령의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="a69ba7d63607e672a0bddb87dd2b06b8084a0156" translate="yes" xml:space="preserve">
          <source>The name of the current function.</source>
          <target state="translated">현재 기능의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5d5f02fcd54d2c4aea3c80c0f03903502a3ce2db" translate="yes" xml:space="preserve">
          <source>The name of the current module, as a string.</source>
          <target state="translated">현재 모듈의 이름 (문자열)</target>
        </trans-unit>
        <trans-unit id="c44e0c83244028d9b0e30cf7a2d2504d40b0af59" translate="yes" xml:space="preserve">
          <source>The name of the current module.</source>
          <target state="translated">현재 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b706d162247dd36c2c34198513b7054a12041a8e" translate="yes" xml:space="preserve">
          <source>The name of the dumped table. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with &lt;code&gt;&lt;a href=&quot;#file2tab-2&quot;&gt;file2tab/2&lt;/a&gt;&lt;/code&gt;. If the table is not saved as a named table, this field has no significance when loading the table from file.</source>
          <target state="translated">덤프 된 테이블의 이름입니다. 테이블이 명명 된 테이블 인 경우 &lt;code&gt;&lt;a href=&quot;#file2tab-2&quot;&gt;file2tab/2&lt;/a&gt;&lt;/code&gt; 파일에서 테이블을로드 할 때 이름이 같은 테이블이 존재할 수 없습니다 . 테이블이 명명 된 테이블로 저장되지 않은 경우 파일에서 테이블을로드 할 때이 필드는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b173e28eec1dbfe6b6a9acf56060edd59ce91a80" translate="yes" xml:space="preserve">
          <source>The name of the element is found in the &lt;code&gt;name&lt;/code&gt; field. In the &lt;code&gt;parents&lt;/code&gt; field is the names of the parent elements saved. Parents is a list of tuples where the first element in each tuple is the name of the parent element. The list is in reverse order.</source>
          <target state="translated">요소의 &lt;code&gt;name&lt;/code&gt; 은 이름 필드에 있습니다. 에서 &lt;code&gt;parents&lt;/code&gt; 필드 저장 부모 요소의 이름입니다. 부모는 각 튜플의 첫 번째 요소가 부모 요소의 이름 인 튜플 목록입니다. 목록은 역순입니다.</target>
        </trans-unit>
        <trans-unit id="9bdb35ccec0faa5ab435abc22ae894c98451909a" translate="yes" xml:space="preserve">
          <source>The name of the exclusive decode function</source>
          <target state="translated">독점 디코드 기능의 이름</target>
        </trans-unit>
        <trans-unit id="c9cd1cfd2a7c75e9d469f30e6b8aa44633fee5f8" translate="yes" xml:space="preserve">
          <source>The name of the executable as well as the arguments specifed in &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and &lt;code&gt;arg0&lt;/code&gt; are subject to Unicode filename translation if the system is running in Unicode filename mode. To avoid translation or to force, for example UTF-8, supply the executable and/or arguments as a binary in the correct encoding. For details, see the module &lt;code&gt;file(3)&lt;/code&gt;, the function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; in Kernel, and the &lt;code&gt;Using Unicode in Erlang&lt;/code&gt; User's Guide.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; , &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;arg0&lt;/code&gt; 에 지정된 인수뿐만 아니라 실행 파일 이름은 시스템이 유니 코드 파일 이름 모드에서 실행중인 경우 유니 코드 파일 이름 변환의 대상이됩니다. 번역을 피하거나 UTF-8과 같은 강제를 실행하려면 올바른 인코딩에서 실행 파일 및 / 또는 인수를 이진으로 제공하십시오. 자세한 내용은 모듈 &lt;code&gt;file(3)&lt;/code&gt; , 커널 의 함수 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 및 &lt;code&gt;Using Unicode in Erlang&lt;/code&gt; 설명서의 유니 코드 사용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="145bef4824887ac958179d5dc67a74ef7822e376" translate="yes" xml:space="preserve">
          <source>The name of the file (actually a named pipe) that is to receive the information</source>
          <target state="translated">정보를 수신 할 파일 이름 (실제로 명명 된 파이프)</target>
        </trans-unit>
        <trans-unit id="a03ff0e0c54f689b6ef65841c20ee8be07ab00cd" translate="yes" xml:space="preserve">
          <source>The name of the fragmented table</source>
          <target state="translated">조각난 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="e84326facd2f5685ce1620f764c65298c11a51af" translate="yes" xml:space="preserve">
          <source>The name of the module where the fun was defined.</source>
          <target state="translated">재미가 정의 된 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0d9aeed296de66746c856a81bf8f9ded5e43cdf7" translate="yes" xml:space="preserve">
          <source>The name of the program which started Erlang:</source>
          <target state="translated">Erlang을 시작한 프로그램의 이름 :</target>
        </trans-unit>
        <trans-unit id="98a9f43eda81f29bf9d5743946a9ea8fd9286582" translate="yes" xml:space="preserve">
          <source>The name of the remote node.</source>
          <target state="translated">원격 노드의 이름</target>
        </trans-unit>
        <trans-unit id="c050e4fb9fc899bdfcbcbf709859cc750e6a455f" translate="yes" xml:space="preserve">
          <source>The name of the saved file is the same as the name of the schema, but with &lt;code&gt;.xss&lt;/code&gt; extension.</source>
          <target state="translated">저장된 파일의 이름은 스키마의 이름과 동일하지만 확장자 는 &lt;code&gt;.xss&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e86acd0ca5b48cdb98c4c075c4205c3b79b72431" translate="yes" xml:space="preserve">
          <source>The name of the service that started the machine.</source>
          <target state="translated">머신을 시작한 서비스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d1f79a45516e8d9666e0b4109e4162f8073d0a02" translate="yes" xml:space="preserve">
          <source>The name of the socket file (the path prefix removed), which allows for deletion (&lt;code&gt;unlink&lt;/code&gt;) when the socket is closed.</source>
          <target state="translated">소켓 파일의 이름 (경로 접두어가 제거됨)으로, 소켓이 닫힐 때 삭제 ( &lt;code&gt;unlink&lt;/code&gt; ) 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d325a204adba96bb16ee250d72f562304e27637" translate="yes" xml:space="preserve">
          <source>The name of the started node becomes &lt;code&gt;Name@Host&lt;/code&gt;. If no name is provided, the name becomes the same as the node that executes the call (except the host name part of the node name).</source>
          <target state="translated">시작된 노드의 이름은 &lt;code&gt;Name@Host&lt;/code&gt; 됩니다. 이름이 제공되지 않으면 이름은 호출을 실행하는 노드와 동일하게됩니다 (노드 이름의 호스트 이름 부분 제외).</target>
        </trans-unit>
        <trans-unit id="ef518922fd516452499d2abfb02bdb4cf49f94a5" translate="yes" xml:space="preserve">
          <source>The name of the user function</source>
          <target state="translated">사용자 기능의 이름</target>
        </trans-unit>
        <trans-unit id="39f567390152e02d37fe6a831a2b17a677f34378" translate="yes" xml:space="preserve">
          <source>The name of your server, normally a fully qualified domain name.</source>
          <target state="translated">서버 이름, 일반적으로 정규화 된 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c657342b93672825ac56ce5aad93896816b11389" translate="yes" xml:space="preserve">
          <source>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</source>
          <target state="translated">TFTP 데몬이 상주하는 호스트의 이름 또는 IP 주소입니다. 이 옵션은 클라이언트 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="efd3b9bd3feb790c69b6f53e83bb01160208a7e5" translate="yes" xml:space="preserve">
          <source>The name server also maintains a fully connected network. For example, if node &lt;code&gt;N1&lt;/code&gt; connects to node &lt;code&gt;N2&lt;/code&gt; (which is already connected to &lt;code&gt;N3&lt;/code&gt;), the global name servers on the nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; ensure that also &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; are connected. If this is not desired, command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; can be used (see also &lt;code&gt;erl(1)&lt;/code&gt;). In this case, the name registration service cannot be used, but the lock mechanism still works.</source>
          <target state="translated">이름 서버는 또한 완전히 연결된 네트워크를 유지 관리합니다. 예를 들어, 노드 &lt;code&gt;N1&lt;/code&gt; 이 노드 &lt;code&gt;N2&lt;/code&gt; (이미 &lt;code&gt;N3&lt;/code&gt; 에 연결됨 )에 연결 되면 노드 &lt;code&gt;N1&lt;/code&gt; 및 &lt;code&gt;N3&lt;/code&gt; 의 글로벌 이름 서버 는 &lt;code&gt;N1&lt;/code&gt; 및 &lt;code&gt;N3&lt;/code&gt; 도 연결되어 있는지 확인합니다 . 이것이 바람직하지 않은 경우, 명령 행 플래그 &lt;code&gt;-connect_all false&lt;/code&gt; 를 사용할 수 있습니다 ( &lt;code&gt;erl(1)&lt;/code&gt; ). 이 경우 이름 등록 서비스를 사용할 수 없지만 잠금 메커니즘은 여전히 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="70bbd5b825a0e3f16b591b2238348e211ea12fa7" translate="yes" xml:space="preserve">
          <source>The name(s) of the user-defined residence module(s) must be listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification for the special process. Otherwise the release handler cannot find the process.</source>
          <target state="translated">사용자 정의 거주 모듈의 이름 은 특수 프로세스에 대한 하위 사양 의 &lt;code&gt;Modules&lt;/code&gt; 부분에 나열되어야합니다 . 그렇지 않으면 릴리스 핸들러가 프로세스를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="55639d1e8772a94a0b0836a082a724c02665921b" translate="yes" xml:space="preserve">
          <source>The named file is a directory.</source>
          <target state="translated">명명 된 파일은 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="14d72b8811543846930a80f5f7f7859cd2878b00" translate="yes" xml:space="preserve">
          <source>The named pipe, usually &lt;code&gt;/tmp/&lt;/code&gt;. It must be suffixed by a &lt;code&gt;/&lt;/code&gt; (slash), that is, &lt;code&gt;/tmp/epipes/&lt;/code&gt;, not &lt;code&gt;/tmp/epipes&lt;/code&gt;.</source>
          <target state="translated">명명 된 파이프, 보통 &lt;code&gt;/tmp/&lt;/code&gt; . 그것은이 접미사해야 &lt;code&gt;/&lt;/code&gt; 인 (슬래시), &lt;code&gt;/tmp/epipes/&lt;/code&gt; 하지 &lt;code&gt;/tmp/epipes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f0fcca13871e6412c5bb752140a8243dc65e989" translate="yes" xml:space="preserve">
          <source>The names of all fragments</source>
          <target state="translated">모든 조각의 이름</target>
        </trans-unit>
        <trans-unit id="38f3d4f81f2a3fb4b6790bd99cb201c153f2cb7b" translate="yes" xml:space="preserve">
          <source>The naming of the service in a system that uses release handling must follow the convention &lt;strong id=&quot;001&quot;&gt;NodeName&lt;/strong&gt;_&lt;strong&gt;Release&lt;/strong&gt;, where &lt;strong&gt;NodeName&lt;/strong&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;strong&gt;Release&lt;/strong&gt; is the current release of the application.</source>
          <target state="translated">릴리스 처리를 사용하는 시스템에서 서비스 이름은 &lt;strong id=&quot;001&quot;&gt;NodeName&lt;/strong&gt; _ &lt;strong&gt;Release&lt;/strong&gt; 규칙을 따라야합니다 . 여기서 &lt;strong&gt;NodeName&lt;/strong&gt; 은 Erlang 노드 이름의 첫 번째 부분 ( &quot;@&quot;제외)이고 &lt;strong&gt;Release&lt;/strong&gt; 는 현재 릴리스입니다. 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="865ddb889727f82a24bd4d5836d553df871c5cb5" translate="yes" xml:space="preserve">
          <source>The native code will be placed into the beam file and automatically loaded when the beam file is loaded.</source>
          <target state="translated">기본 코드는 빔 파일에 배치되고 빔 파일이로드 될 때 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0d9e387da412c6854e55d2ea6c29168d1cc99c" translate="yes" xml:space="preserve">
          <source>The negotiated protocol can be retrieved using the &lt;code&gt;negotiated_protocol/1&lt;/code&gt; function.</source>
          <target state="translated">협상 된 프로토콜은 &lt;code&gt;negotiated_protocol/1&lt;/code&gt; 함수를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d19b33d4325de1693405141a928c25d4f21b350" translate="yes" xml:space="preserve">
          <source>The negotiation is simple: both peers sends their list of supported alghorithms to the other part. The first algorithm on the client's list that also in on the server's list is selected. So it is the client's orderering of the list that gives the priority for the algorithms.</source>
          <target state="translated">협상은 간단합니다. 두 피어 모두 지원되는 알고리즘 목록을 다른 부분으로 보냅니다. 서버 목록에도있는 클라이언트 목록의 첫 번째 알고리즘이 선택됩니다. 따라서 알고리즘에 우선 순위를 부여하는 것은 클라이언트가 목록을 정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0fb72997ab3557ef82a230bb3682011bf2c48d8" translate="yes" xml:space="preserve">
          <source>The net kernel is a system process, registered as &lt;code&gt;net_kernel&lt;/code&gt;, which must be operational for distributed Erlang to work. The purpose of this process is to implement parts of the BIFs &lt;code&gt;spawn/4&lt;/code&gt; and &lt;code&gt;spawn_link/4&lt;/code&gt;, and to provide monitoring of the network.</source>
          <target state="translated">net 커널은 &lt;code&gt;net_kernel&lt;/code&gt; 로 등록 된 시스템 프로세스이며 분산 Erlang이 작동하려면 작동해야합니다. 이 프로세스의 목적은 BIF &lt;code&gt;spawn/4&lt;/code&gt; 및 &lt;code&gt;spawn_link/4&lt;/code&gt; 의 일부를 구현 하고 네트워크를 모니터링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b9ff73038bb4f2d73ed04274ea6798f021e1bdd" translate="yes" xml:space="preserve">
          <source>The network connection to the client is broken.</source>
          <target state="translated">클라이언트와의 네트워크 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="da852eb6d3cd7c2bee53433293d851328338d462" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a02721e2497fbe700123fb9e3a729f740f43a941" translate="yes" xml:space="preserve">
          <source>The new API also consists of extensions of the following existing BIFs:</source>
          <target state="translated">새로운 API는 또한 다음과 같은 기존 BIF의 확장으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="14ce5a3ea27213da49e5b9bde3bdc06535343fd3" translate="yes" xml:space="preserve">
          <source>The new API consists of the following new BIFs:</source>
          <target state="translated">새로운 API는 다음과 같은 새로운 BIF로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e000cc20f5ca067c8f3696f8838efc3f818b18" translate="yes" xml:space="preserve">
          <source>The new application version &lt;code&gt;ch_app-2&lt;/code&gt; is installed under &lt;code&gt;$ROOT/lib&lt;/code&gt; next to &lt;code&gt;ch_app-1&lt;/code&gt;. The &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt; directories are not affected, as they have not changed.</source>
          <target state="translated">새로운 응용 프로그램 버전 &lt;code&gt;ch_app-2&lt;/code&gt; 는 &lt;code&gt;ch_app-1&lt;/code&gt; 옆의 &lt;code&gt;$ROOT/lib&lt;/code&gt; 설치됩니다 . &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;sasl&lt;/code&gt; 가 변경되지 않은 것처럼 디렉토리는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59032a152ed589ec4feaf1322f673d94f7aaad6d" translate="yes" xml:space="preserve">
          <source>The new configuration is merged with the existing formatter configuration.</source>
          <target state="translated">새로운 구성은 기존 포맷터 구성과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="83d81766969865b40c9a40366463e9a12358c346" translate="yes" xml:space="preserve">
          <source>The new default behaviour is that the SASL application no longer affects which log events that are logged. &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; are logged via the default logger handler which is setup by Kernel. &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;.</source>
          <target state="translated">새로운 기본 동작은 SASL 응용 프로그램이 더 이상 기록되는 로그 이벤트에 영향을 미치지 않는다는 것입니다. &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; 는 커널에서 설정 한 기본 로거 처리기를 통해 기록됩니다. &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; 는 기본적으로 로그되지 않지만 기본 로그 레벨을 &lt;code&gt;info&lt;/code&gt; 로 설정하여 ( 예 : 커널 구성 매개 변수 &lt;code&gt;logger_level&lt;/code&gt; 사용) 사용 가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90289d546aac89c2e80a44e2dc66fc3797c85bff" translate="yes" xml:space="preserve">
          <source>The new handler is added even if the the specified old event handler is not installed, in which case &lt;code&gt;Term=error&lt;/code&gt;, or if &lt;code&gt;Module1:terminate/2&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, in which case &lt;code&gt;Term={'EXIT',Reason}&lt;/code&gt;. The old handler is deleted even if &lt;code&gt;Module2:init/1&lt;/code&gt; fails.</source>
          <target state="translated">지정된 이전 이벤트 핸들러가 설치되지 않은 경우 (이 경우 &lt;code&gt;Term=error&lt;/code&gt; ) 또는 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 가 &lt;code&gt;Reason&lt;/code&gt; 에서 실패한 경우 (여기서 &lt;code&gt;Term={'EXIT',Reason}&lt;/code&gt; ) 새 핸들러가 추가 됩니다 . &lt;code&gt;Module2:init/1&lt;/code&gt; 이 실패 하더라도 이전 핸들러는 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="861a2e8c420a1842a7f2ab5f571c0efd4455430e" translate="yes" xml:space="preserve">
          <source>The new port owner gets linked to the port.</source>
          <target state="translated">새 포트 소유자가 포트에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="902088f9e762def66cfe8ee46deb82a6a7c3b707" translate="yes" xml:space="preserve">
          <source>The new process starts executing in &lt;code&gt;Module:Name(Arg1,...,ArgN)&lt;/code&gt; where the arguments are the elements of the (possible empty) &lt;code&gt;Args&lt;/code&gt; argument list.</source>
          <target state="translated">새 프로세스는 &lt;code&gt;Module:Name(Arg1,...,ArgN)&lt;/code&gt; 에서 실행을 시작합니다 . 여기서 인수는 비어있는 &lt;code&gt;Args&lt;/code&gt; 인수 목록 의 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="01969408fe300767acbbb5a6a95d7a01999fe18a" translate="yes" xml:space="preserve">
          <source>The new profile has no proxy settings, so the connection is refused:</source>
          <target state="translated">새 프로파일에는 프록시 설정이 없으므로 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="272d17b899e78f71208c1a6461cad1aeb1df67f2" translate="yes" xml:space="preserve">
          <source>The new release must still be made permanent after the upgrade is completed, otherwise the old emulator is started if there is an emulator restart.</source>
          <target state="translated">업그레이드가 완료된 후에도 새 릴리스를 영구적으로 유지해야합니다. 그렇지 않으면 에뮬레이터를 다시 시작하면 이전 에뮬레이터가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5848daab5022f7091ecd71b8112f54b552d8ba95" translate="yes" xml:space="preserve">
          <source>The new release package now also contains version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt; and the &lt;code&gt;relup&lt;/code&gt; file:</source>
          <target state="translated">새 릴리스 패키지에는 &lt;code&gt;ch_app&lt;/code&gt; 버전 &quot;2&quot; 와 &lt;code&gt;relup&lt;/code&gt; 파일 도 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="151b13999b32ae6dd1c2edc6085a347c6f775003" translate="yes" xml:space="preserve">
          <source>The new release version must be made permanent when the new emulator is operational. Otherwise, the old version will be used if there is a new system reboot.</source>
          <target state="translated">새 에뮬레이터가 작동 중이면 새 릴리스 버전을 영구적으로 만들어야합니다. 그렇지 않으면 새 시스템 재부팅이있는 경우 이전 버전이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcca389ca88db583caeb0a8f28a9b042cb4dbdc7" translate="yes" xml:space="preserve">
          <source>The new supervisor process calls the callback function &lt;code&gt;ch_sup:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; shall return &lt;code&gt;{ok, {SupFlags, ChildSpecs}}&lt;/code&gt;:</source>
          <target state="translated">새로운 수퍼바이저 프로세스는 콜백 함수 &lt;code&gt;ch_sup:init([])&lt;/code&gt; 호출합니다 . &lt;code&gt;init&lt;/code&gt; 는 &lt;code&gt;{ok, {SupFlags, ChildSpecs}}&lt;/code&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="51319161abd02362f27a398a1fe31b0e9c37ac47" translate="yes" xml:space="preserve">
          <source>The new verbs make use of what was previously invalid syntax: an opening parenthesis followed by an asterisk. They are generally of the form (*VERB) or (*VERB:NAME). Some can take either form, possibly behaving differently depending on whether a name is present. A name is any sequence of characters that does not include a closing parenthesis. The maximum name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that is, if the closing parenthesis immediately follows the colon, the effect is as if the colon was not there. Any number of these verbs can occur in a pattern.</source>
          <target state="translated">새 동사는 이전에 유효하지 않은 구문 인 여는 괄호와 별표로 구성됩니다. 일반적으로 (* VERB) 또는 (* VERB : NAME) 형식입니다. 일부는 이름의 존재 여부에 따라 다르게 작동 할 수 있습니다. 이름은 닫는 괄호를 포함하지 않는 일련의 문자입니다. 최대 이름 길이는 8 비트 라이브러리에서 255이고 16 비트 및 32 비트 라이브러리에서 65535입니다. 이름이 비어있는 경우, 즉 닫는 괄호가 콜론 바로 뒤에 오는 경우 콜론이없는 것처럼 효과가 나타납니다. 이러한 동사의 수는 패턴으로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="215b161818282063f148ff8da610c62e944bf7ef" translate="yes" xml:space="preserve">
          <source>The newline convention affects where the circumflex and dollar assertions are true. It also affects the interpretation of the dot metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set, and the behavior of \N. However, it does not affect what the \R escape sequence matches. By default, this is any Unicode newline sequence, for Perl compatibility. However, this can be changed; see the description of \R in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt;. A change of the \R setting can be combined with a change of the newline convention.</source>
          <target state="translated">개행 규칙은 곡절 및 달러 어설 션이 참인 위치에 영향을줍니다. 또한 &lt;code&gt;dotall&lt;/code&gt; 이 설정되지 않은 경우 도트 메타 문자 해석 및 \ N 동작에 영향을줍니다 . 그러나 \ R 이스케이프 시퀀스가 ​​일치하는 내용에는 영향을 미치지 않습니다. 기본적으로 이것은 Perl 호환성을위한 모든 유니 코드 개행 시퀀스입니다. 그러나 이것은 변경 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; 섹션에서 \ R에 대한 설명을 참조하십시오 . \ R 설정 변경은 줄 바꾸기 규칙 변경과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa9ce37388c079f08c2d34d6dbefdaceaae17a26" translate="yes" xml:space="preserve">
          <source>The next example has both &lt;code&gt;Subject&lt;/code&gt; and &lt;code&gt;Subject Alternate Name&lt;/code&gt; present:</source>
          <target state="translated">다음 예에는 &lt;code&gt;Subject&lt;/code&gt; 과 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 이 모두 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4312b6eb6f9623ee8f0dbf0acd84042778ca8185" translate="yes" xml:space="preserve">
          <source>The next example is the ping pong program, yet again, but this time &quot;ping&quot; is started in another node:</source>
          <target state="translated">다음 예는 핑퐁 프로그램이지만 이번에는 다른 노드에서 &quot;ping&quot;이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7a489b889bb50acfc73253c688e246f84e36bfb1" translate="yes" xml:space="preserve">
          <source>The next few commands assume that &lt;code&gt;test1:demo(X)&lt;/code&gt; is defined as follows:</source>
          <target state="translated">다음 몇 명령은 &lt;code&gt;test1:demo(X)&lt;/code&gt; 가 다음과 같이 정의 되었다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="a78aa43091c6b8ceee531b79859ff361a0c70162" translate="yes" xml:space="preserve">
          <source>The next few commands show some record manipulation. It is assumed that &lt;code&gt;ex.erl&lt;/code&gt; defines a record as follows:</source>
          <target state="translated">다음 몇 명령은 레코드 조작을 보여줍니다. &lt;code&gt;ex.erl&lt;/code&gt; 은 다음과 같이 레코드를 정의 한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="fb2f4c70a5ddd641a7c7cece836164fd20868016" translate="yes" xml:space="preserve">
          <source>The next template matches on the &lt;code&gt;bike&lt;/code&gt; element:</source>
          <target state="translated">다음 템플릿은 &lt;code&gt;bike&lt;/code&gt; 요소 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="95db43fd70e2774066c2eb7f8160a4afc368f658" translate="yes" xml:space="preserve">
          <source>The nif writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored by the runtime system, so &lt;code&gt;ErlNifMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on. To compare two monitors, &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">nif 작성기는 &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 모니터를 저장하기위한 메모리를 제공해야합니다 . 데이터의 주소는 런타임 시스템에 저장되지 않으므로 &lt;code&gt;ErlNifMonitor&lt;/code&gt; 를 다른 데이터로 사용할 수 있으며 복사, 메모리 이동, 잊어 버림 등을 수행 할 수 있습니다. 두 모니터를 비교하려면 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="08409f3c21c53e70ad49f4d51fc6209994cfdfe6" translate="yes" xml:space="preserve">
          <source>The node can handle extended pids and ports. This is required today. If not present, the connection is refused.</source>
          <target state="translated">노드는 확장 된 pid 및 포트를 처리 할 수 ​​있습니다. 오늘 필요합니다. 존재하지 않으면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5a5b212db7cd4390e6199cd85d2036154a00d5" translate="yes" xml:space="preserve">
          <source>The node implements an atom cache (obsolete).</source>
          <target state="translated">노드는 아톰 캐시 (구식)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="281b9f23f7b8d53d42a4c87c8c2ac676439952b2" translate="yes" xml:space="preserve">
          <source>The node implements atom cache in distribution header.</source>
          <target state="translated">노드는 분배 헤더에서 아톰 캐시를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1d081f7d6c9b36af20a121c7eb30cda4b27e3f40" translate="yes" xml:space="preserve">
          <source>The node implements distributed named process monitoring.</source>
          <target state="translated">노드는 분산 명명 된 프로세스 모니터링을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e3fed8a46db41b2b3acc894e988a972c7e551cd4" translate="yes" xml:space="preserve">
          <source>The node implements distributed process monitoring.</source>
          <target state="translated">노드는 분산 프로세스 모니터링을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c290f1695a97d158f0cca645bdaac52154a45a48" translate="yes" xml:space="preserve">
          <source>The node implements extended (3 &amp;times; 32 bits) references. This is required today. If not present, the connection is refused.</source>
          <target state="translated">노드는 확장 된 (3 &amp;times; 32 비트) 참조를 구현합니다. 오늘 필요합니다. 존재하지 않으면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="220f04ba10adb170f6a597676f032142dfa5b439" translate="yes" xml:space="preserve">
          <source>The node in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 의 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="b04ef2a66fbcd0df01a238b3b604c182b6b0fdf3" translate="yes" xml:space="preserve">
          <source>The node in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">포트의 노드 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75176ee78897d13c331b9db88b37a6e3a9d123c3" translate="yes" xml:space="preserve">
          <source>The node is accessible through a new pipe:</source>
          <target state="translated">새 파이프를 통해 노드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28fa0e5cd5fe4594591931d814b0c4ba1e753d94" translate="yes" xml:space="preserve">
          <source>The node is to be published and part of the global namespace.</source>
          <target state="translated">노드가 공개되고 글로벌 네임 스페이스의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="d54e976693fcf1e41748b27bf394174406184e6a" translate="yes" xml:space="preserve">
          <source>The node name &lt;code&gt;Node&lt;/code&gt; is to be the name of the C node. If short node names are used, the plain name of the node is &lt;code&gt;cN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. If long node names are used, there is no such restriction. An example of a C node name using short node names is thus &lt;code&gt;c1@idril&lt;/code&gt;, an example using long node names is &lt;code&gt;cnode@idril.ericsson.se&lt;/code&gt;.</source>
          <target state="translated">노드 이름 &lt;code&gt;Node&lt;/code&gt; 는 C 노드의 이름입니다. 짧은 노드 이름을 사용하는 경우 노드의 일반 이름은 &lt;code&gt;cN&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 정수입니다. 긴 노드 이름을 사용하는 경우 그러한 제한이 없습니다. 짧은 노드 이름을 사용하는 C 노드 이름의 예는 &lt;code&gt;c1@idril&lt;/code&gt; 이고, 긴 노드 이름을 사용하는 예는 &lt;code&gt;cnode@idril.ericsson.se&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec68e7e5a1c1e0362af0ba664dfbe218c891bbb8" translate="yes" xml:space="preserve">
          <source>The node name as an UTF-8 encoded string of &lt;code&gt;Nlen&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;Nlen&lt;/code&gt; 바이트 의 UTF-8 인코딩 문자열로서의 노드 이름 .</target>
        </trans-unit>
        <trans-unit id="54e641481b78d40b7f0d13f44dc8ac44945e2bc1" translate="yes" xml:space="preserve">
          <source>The node name of the Erlang machine. Distribution is mandatory. Defaults to &lt;code&gt;-sname &amp;lt;service name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 시스템의 노드 이름입니다. 배포는 필수입니다. 기본값은 &lt;code&gt;-sname &amp;lt;service name&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7013f821805350971680d8e2b7cebcb41595b7b3" translate="yes" xml:space="preserve">
          <source>The node name of this node.</source>
          <target state="translated">이 노드의 노드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d86c6e1ca2f04c51bd365df74dcf158fdb370851" translate="yes" xml:space="preserve">
          <source>The node name will be &lt;code&gt;Name@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified host name of the current host. For short names, use flag &lt;code&gt;-sname&lt;/code&gt; instead.</source>
          <target state="translated">노드 이름은 &lt;code&gt;Name@Host&lt;/code&gt; . 여기서 &lt;code&gt;Host&lt;/code&gt; 는 현재 호스트의 완전한 호스트 이름입니다. 짧은 이름의 경우 대신 플래그 &lt;code&gt;-sname&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7fca1953bdb5dbf94dcc8389d42b6cefbece8cd" translate="yes" xml:space="preserve">
          <source>The node name.</source>
          <target state="translated">노드 이름</target>
        </trans-unit>
        <trans-unit id="9bcf7d5cb8ed6df1804c572bc6bf038771c7e18c" translate="yes" xml:space="preserve">
          <source>The node on which the client process resides has gone down.</source>
          <target state="translated">클라이언트 프로세스가 상주하는 노드가 다운되었습니다.</target>
        </trans-unit>
        <trans-unit id="41f458450045ddabec1cec2d090c135189e5c611" translate="yes" xml:space="preserve">
          <source>The node pool contains a list of nodes and can explicitly be set at table creation and later be changed with &lt;code&gt;{add_node, Node}&lt;/code&gt; or &lt;code&gt;{del_node, Node}&lt;/code&gt;. At table creation &lt;code&gt;Mnesia&lt;/code&gt; tries to distribute the replicas of each fragment evenly over all the nodes in the node pool. Hopefully all nodes end up with the same number of replicas. &lt;code&gt;node_pool&lt;/code&gt; defaults to the return value from the function &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(db_nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">노드 풀에는 노드 목록이 포함되어 있으며 테이블 작성시 명시 적으로 설정 한 후 나중에 &lt;code&gt;{add_node, Node}&lt;/code&gt; 또는 &lt;code&gt;{del_node, Node}&lt;/code&gt; 로 변경할 수 있습니다 . 테이블 생성시 &lt;code&gt;Mnesia&lt;/code&gt; 는 각 조각의 복제본을 노드 풀의 모든 노드에 균등하게 분배하려고합니다. 모든 노드가 동일한 수의 복제본으로 끝나기를 바랍니다. &lt;code&gt;node_pool&lt;/code&gt; 의 기본값은 &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(db_nodes)&lt;/a&gt;&lt;/code&gt; 함수의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="207f55f45138fa70f0de9e05412ca7fa4d942620" translate="yes" xml:space="preserve">
          <source>The node understand UTF-8 encoded atoms.</source>
          <target state="translated">노드는 UTF-8로 인코딩 된 원자를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="0361bcd66b03f6607ace0b0251db2af07f52cb88" translate="yes" xml:space="preserve">
          <source>The node understand big node creation.</source>
          <target state="translated">노드는 큰 노드 생성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7f509d096720411cce80a4c0204a3408b6f8e" translate="yes" xml:space="preserve">
          <source>The node understand new fun tags.</source>
          <target state="translated">노드는 새로운 재미있는 태그를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="894ceecec4e308228c7ad91a5d1bc07ff9266078" translate="yes" xml:space="preserve">
          <source>The node understand the &lt;code&gt;SMALL_ATOM_EXT&lt;/code&gt; tag.</source>
          <target state="translated">노드는 &lt;code&gt;SMALL_ATOM_EXT&lt;/code&gt; 태그를 이해합니다 .</target>
        </trans-unit>
        <trans-unit id="151f8180c3b312748f09057c417efde3a689457c" translate="yes" xml:space="preserve">
          <source>The node understand the map tag.</source>
          <target state="translated">노드는 맵 태그를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="0e934f26ef40068597701c482448fa6fcf04ed31" translate="yes" xml:space="preserve">
          <source>The node understands new float format.</source>
          <target state="translated">노드는 새로운 부동 형식을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="91629496aa70f12f9dc344d8279c147f91e3a165" translate="yes" xml:space="preserve">
          <source>The node uses separate tag for funs (lambdas) in the distribution protocol.</source>
          <target state="translated">노드는 분배 프로토콜에서 fun (lambdas)에 대해 별도의 태그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f74fa1efb28b655576befa4c9558a73c950b9df2" translate="yes" xml:space="preserve">
          <source>The node where the table is stored. This field is no longer meaningful, as tables cannot be accessed from other nodes.</source>
          <target state="translated">테이블이 저장된 노드입니다. 다른 노드에서 테이블에 액세스 할 수 없으므로이 필드는 더 이상 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ab9dd8f7f54478754ba9f39a29a916791467814" translate="yes" xml:space="preserve">
          <source>The nodes in a distributed Erlang system are loosely connected. The first time the name of another node is used, for example, if &lt;code&gt;spawn(Node,M,F,A)&lt;/code&gt; or &lt;code&gt;net_adm:ping(Node)&lt;/code&gt; is called, a connection attempt to that node is made.</source>
          <target state="translated">분산 Erlang 시스템의 노드가 느슨하게 연결되었습니다. 예를 들어 &lt;code&gt;spawn(Node,M,F,A)&lt;/code&gt; 또는 &lt;code&gt;net_adm:ping(Node)&lt;/code&gt; 가 호출 된 경우 다른 노드의 이름이 처음 사용될 때 해당 노드에 대한 연결 시도가 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2ac2e00494210b4cb8b0c05904a98cf82ca69740" translate="yes" xml:space="preserve">
          <source>The nodes of the syntax tree must contain valid position information. This can be single integers, assumed to represent a line number, or 2- or 3-tuples where the first or second element is an integer, in which case the leftmost integer element is assumed to represent the line number. Line numbers less than one are ignored (usually, the default line number for newly created nodes is zero).</source>
          <target state="translated">구문 트리의 노드는 유효한 위치 정보를 포함해야합니다. 행 번호를 나타내는 것으로 가정되는 단일 정수 또는 첫 번째 또는 두 번째 요소가 정수인 2 또는 3 개의 튜플 일 수 있으며,이 경우 가장 왼쪽의 정수 요소는 행 번호를 나타내는 것으로 간주됩니다. 1보다 작은 행 번호는 무시됩니다 (보통 새로 작성된 노드의 기본 행 번호는 0 임).</target>
        </trans-unit>
        <trans-unit id="3a500c6b344c68f0a4b0eb600d18358a8deed739" translate="yes" xml:space="preserve">
          <source>The non-local function handler &lt;strong&gt;is&lt;/strong&gt; however called with the evaluated arguments of the call to &lt;code&gt;erlang:apply/2,3&lt;/code&gt;: &lt;code&gt;Func(Fun, Args)&lt;/code&gt; or &lt;code&gt;Func({Module, Function}, Args)&lt;/code&gt; (assuming that &lt;code&gt;{Module, Function}&lt;/code&gt; is not &lt;code&gt;{erlang, apply}&lt;/code&gt;).</source>
          <target state="translated">그러나 로컬이 아닌 함수 핸들러 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;erlang:apply/2,3&lt;/code&gt; 에 대한 호출의 평가 된 인수와 함께 호출됩니다 . &lt;code&gt;Func(Fun, Args)&lt;/code&gt; 또는 &lt;code&gt;Func({Module, Function}, Args)&lt;/code&gt; ( &lt;code&gt;{Module, Function}&lt;/code&gt; &lt;code&gt;{erlang, apply}&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2104dfaf943c18e872cc21b511c0366a7ea1b0fb" translate="yes" xml:space="preserve">
          <source>The non-local function handler argument is probably not used as frequently as the local function handler argument. A possible use is to call &lt;code&gt;exit/1&lt;/code&gt; on calls to functions that for some reason are not allowed to be called.</source>
          <target state="translated">로컬이 아닌 함수 핸들러 인수는 로컬 함수 핸들러 인수만큼 자주 사용되지 않을 수 있습니다. 어떤 이유로 든 호출 할 수없는 함수 호출시 &lt;code&gt;exit/1&lt;/code&gt; 을 호출하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f7c221c15b667bea31580924db95e510885f6679" translate="yes" xml:space="preserve">
          <source>The normal use is to call the function without checking the return value, as it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired and &lt;code&gt;ok&lt;/code&gt; if it was a read lock.</source>
          <target state="translated">정상적인 사용은 리턴 값을 확인하지 않고 함수를 호출하는 것입니다. 실패하면 종료되고 트랜잭션이 트랜잭션 관리자에 의해 다시 시작되므로 리턴 값을 확인하지 않습니다. 쓰기 잠금이 취득하는 경우 그것은 모든 잠금 노드를 반환 &lt;code&gt;ok&lt;/code&gt; 이 읽기 잠금 있다면.</target>
        </trans-unit>
        <trans-unit id="80f684e59f18c37c44446b26508979681edb5449" translate="yes" xml:space="preserve">
          <source>The normal way to use the agent in a distributed environment is to use one master agent located at one node, and zero or more sub-agents located on other nodes. However, this configuration makes the master agent node a single point of failure. If that node goes down, the agent will not work.</source>
          <target state="translated">분산 환경에서 에이전트를 사용하는 일반적인 방법은 한 노드에있는 하나의 마스터 에이전트를 사용하고 다른 노드에있는 0 개 이상의 하위 에이전트를 사용하는 것입니다. 그러나이 구성은 마스터 에이전트 노드를 단일 실패 지점으로 만듭니다. 해당 노드가 작동 중지되면 에이전트가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e364c347f33083c7e078a191aa40c2608ebe1b9f" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;X &amp;lt;- [1,2,a,...]&lt;/code&gt; is a generator and the expression &lt;code&gt;X &amp;gt; 3&lt;/code&gt; is a filter.</source>
          <target state="translated">표기법 &lt;code&gt;X &amp;lt;- [1,2,a,...]&lt;/code&gt; 는 생성기이고 표현 &lt;code&gt;X &amp;gt; 3&lt;/code&gt; 은 필터입니다.</target>
        </trans-unit>
        <trans-unit id="81f71b8120e4071fbcebde5e7f6026aa6ec9c5ff" translate="yes" xml:space="preserve">
          <source>The notification is sent as an Inform-Request to each target address in &lt;code&gt;Addresses&lt;/code&gt; and if there are no targets for which an Inform-Request is sent, &lt;code&gt;Addresses&lt;/code&gt; is the empty list &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">통지는 각각의 타겟 어드레스로 알려-요청으로 전송되는 &lt;code&gt;Addresses&lt;/code&gt; 및 알리-요청이 전송되는 어떠한 타겟이없는 경우, &lt;code&gt;Addresses&lt;/code&gt; 빈리스트는 &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6615a13126440b2f301d9feef9169efe1884cd9" translate="yes" xml:space="preserve">
          <source>The notification is sent to all management targets found in the tables. However, make sure that each manager has access to the variables in the notification. If a variable is outside a manager's MIB view, this manager will not receive the notification.</source>
          <target state="translated">알림은 표에있는 모든 관리 대상으로 전송됩니다. 그러나 각 관리자가 알림의 변수에 액세스 할 수 있는지 확인하십시오. 변수가 관리자의 MIB보기 외부에 있으면이 관리자는 알림을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5c8e9a76a11f6a0d3766776061aee6dbbf3388a" translate="yes" xml:space="preserve">
          <source>The notifications are one-shot only. To receive further notifications of the same type (read or write), repeated calls to &lt;code&gt;enif_select&lt;/code&gt; must be made after receiving each notification.</source>
          <target state="translated">알림은 한 번만 가능합니다. 동일한 유형 (읽기 또는 쓰기)의 추가 알림을 받으려면 각 알림을받은 후 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 반복 호출을 수행 해야합니다.</target>
        </trans-unit>
        <trans-unit id="753c93a00c0ec14ac60e9c970f897dd5f7002f80" translate="yes" xml:space="preserve">
          <source>The notion that every fourth year is a leap year is not completely true. By the Gregorian rule, a year Y is a leap year if one of the following rules is valid:</source>
          <target state="translated">4 년마다 윤년이라는 개념은 완전히 사실이 아닙니다. 다음 규칙 중 하나가 유효한 경우 그레고리 규칙에 따라 Y 년은 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="bf37afb1bc5f9dfefc13bbbfc7a24bfd243d1fbf" translate="yes" xml:space="preserve">
          <source>The number (in this case 85) is an integer from 1 to 100 that specifies the &quot;detail level&quot; of the message. The higher the number, the more important it is. This provides a crude form of priority filtering.</source>
          <target state="translated">숫자 (이 경우 85)는 메시지의 &quot;세부 수준&quot;을 지정하는 1에서 100 사이의 정수입니다. 숫자가 클수록 중요합니다. 이는 조잡한 형태의 우선 순위 필터링을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75565d0bbaf52f34d1f2ba494d3d8320058b3d47" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;45&lt;/code&gt; in the example indicates the approximate number of objects that you expect to store in the registry. Internally the registry uses hash tables with collision chaining, so there is no absolute upper limit on the number of objects that the registry can contain, but if performance or memory usage is important, then you are to choose a number accordingly. The registry can be resized later.</source>
          <target state="translated">예제에서 숫자 &lt;code&gt;45&lt;/code&gt; 는 레지스트리에 저장할 것으로 예상되는 대략적인 개체 수를 나타냅니다. 내부적으로 레지스트리는 충돌 체인이있는 해시 테이블을 사용하므로 레지스트리에 포함 할 수있는 객체 수에는 절대적인 상한이 없지만 성능이나 메모리 사용이 중요한 경우 그에 따라 숫자를 선택해야합니다. 레지스트리는 나중에 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79ec78d782f41f740663e090268ce34602ccfb0f" translate="yes" xml:space="preserve">
          <source>The number of ETS tables visible in the dump.</source>
          <target state="translated">덤프에서 볼 수있는 ETS 테이블 수입니다.</target>
        </trans-unit>
        <trans-unit id="ed2f858d504fbf2ee02e66edd9c9a034cd3c8f0e" translate="yes" xml:space="preserve">
          <source>The number of allocated heap fragments.</source>
          <target state="translated">할당 된 힙 조각 수입니다.</target>
        </trans-unit>
        <trans-unit id="511df0ea6957d5c04e1b4408f5d45d7fc95571c7" translate="yes" xml:space="preserve">
          <source>The number of arguments &lt;code&gt;N&lt;/code&gt; is the &lt;strong&gt;arity&lt;/strong&gt; of the function. A function is uniquely defined by the module name, function name, and arity. That is, two functions with the same name and in the same module, but with different arities are two different functions.</source>
          <target state="translated">인수의 개수 &lt;code&gt;N&lt;/code&gt; 은 함수 의 &lt;strong&gt;arity&lt;/strong&gt; 입니다. 기능은 모듈 이름, 기능 이름 및 특성에 의해 고유하게 정의됩니다. 즉, 이름과 모듈이 같은 두 개의 함수이지만 다른 특성을 가진 두 개의 함수는 서로 다른 두 개의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="4219e3c77fe7b6dbf3a9ad6d1ab7b70fa1c036f8" translate="yes" xml:space="preserve">
          <source>The number of async threads in the async thread pool used by &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt;erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; 에서 사용하는 비동기 스레드 풀의 비동기 스레드 수 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt;erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt; 반환 한 것과 동일 )</target>
        </trans-unit>
        <trans-unit id="6aed86243ce3461adf935203775b82c23ba81f19" translate="yes" xml:space="preserve">
          <source>The number of atoms in the atom table</source>
          <target state="translated">원자 표의 원자 수</target>
        </trans-unit>
        <trans-unit id="9f5063a380fd018a365840c2dbb66e83694f1aa7" translate="yes" xml:space="preserve">
          <source>The number of atoms in the system at the time of the crash is shown as &lt;strong&gt;Atoms: &amp;lt;number&amp;gt;&lt;/strong&gt;. Some ten thousands atoms is perfectly normal, but more can indicate that the BIF &lt;code&gt;erlang:list_to_atom/1&lt;/code&gt; is used to generate many &lt;strong&gt;different&lt;/strong&gt; atoms dynamically, which is never a good idea.</source>
          <target state="translated">충돌 당시 시스템의 원자 수는 원자 &lt;strong&gt;: &amp;lt;번호&amp;gt;로 표시&lt;/strong&gt; 됩니다. 수만 개의 원자가 완벽하게 정상이지만, 더 많은 것은 BIF &lt;code&gt;erlang:list_to_atom/1&lt;/code&gt; 이 많은 &lt;strong&gt;다른&lt;/strong&gt; 원자를 동적으로 생성하는 데 사용 된다는 것을 나타낼 수 있습니다 . 이는 결코 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3d9211c3c41f9a0491a5cc3cd3b981543236ed4b" translate="yes" xml:space="preserve">
          <source>The number of bytes written (including terminating &lt;code&gt;NULL&lt;/code&gt; character)</source>
          <target state="translated">쓴 바이트 수 ( &lt;code&gt;NULL&lt;/code&gt; 문자 종료 포함 )</target>
        </trans-unit>
        <trans-unit id="ae7a4579876ef85c9e9b38e1a9a4a8cc0f7ae5cf" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the current wrap log file.</source>
          <target state="translated">현재 랩 로그 파일에 기록 된 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="0001e454297af213d4f16647035ec6c8df13a4c0" translate="yes" xml:space="preserve">
          <source>The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing whitespace characters are not omitted as they are with &lt;code&gt;s&lt;/code&gt;. All characters are returned.</source>
          <target state="translated">필드 너비와 동일한 문자 수를 읽고 (기본값은 1) Erlang 문자열로 반환합니다. 그러나 선행 및 후행 공백 문자는 &lt;code&gt;s&lt;/code&gt; 처럼 생략되지 않습니다 . 모든 문자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1137a738d4cfe43f2175847454d3ab0330b78877" translate="yes" xml:space="preserve">
          <source>The number of characters in the matched token.</source>
          <target state="translated">일치하는 토큰의 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="28d997d875f7f8d0bd44b7c91e3ffe255434909a" translate="yes" xml:space="preserve">
          <source>The number of connections established depends on the user's configuration. Multiple connections per peer is possible.</source>
          <target state="translated">설정된 연결 수는 사용자 구성에 따라 다릅니다. 피어 당 여러 연결이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="843b00b0f1b4bd5efff8041a104dc4a8c1ddc0ce" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads created cannot exceed the number of normal scheduler threads created.</source>
          <target state="translated">작성된 더티 CPU 스케줄러 스레드 수는 작성된 일반 스케줄러 스레드 수를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3138269edadb8dc8d29f17322230f4a4a908849" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads is determined at emulator boot time and cannot be changed after that. However, the number of dirty CPU scheduler threads online can be changed at any time. The number of dirty CPU schedulers can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; or &lt;code&gt;+SDPcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">더티 CPU 스케줄러 스레드 수는 에뮬레이터 부팅시 결정되며 이후에는 변경할 수 없습니다. 그러나 온라인으로 더티 CPU 스케줄러 스레드 수는 언제든지 변경할 수 있습니다. 더티 CPU 스케줄러의 수는 시작시 &lt;code&gt;erl(1)&lt;/code&gt; 명령 행 플래그 &lt;code&gt;+SDcpu&lt;/code&gt; 또는 &lt;code&gt;+SDPcpu&lt;/code&gt; 를 전달하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9da52b4c5d5ed584c408c7a1defe4da48427716" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads online cannot exceed the number of normal scheduler threads online.</source>
          <target state="translated">더티 CPU 스케줄러 스레드 온라인 수는 일반 스케줄러 스레드 온라인 수를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03808e9ad1a5bc412f55e40aed263839ec59bc4d" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">더티 CPU 스케줄러 온라인 수는 시작시 &lt;code&gt;erl(1)&lt;/code&gt; 에서 명령 행 플래그 &lt;code&gt;+SDcpu&lt;/code&gt; 를 전달하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e91fedb2f48921c5c8faa40b4bcc9a3dfcee32c3" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can change if the number of schedulers online changes. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">온라인 스케줄러의 수가 변경되면 더티 CPU 스케줄러의 온라인 수를 변경할 수 있습니다. 예를 들어, 12 개의 스케줄러와 6 개의 더티 CPU 스케줄러가 온라인이고 &lt;code&gt;system_flag/2&lt;/code&gt; 를 사용하여 스케줄러의 온라인 수를 6으로 설정하면 더티 CPU 스케줄러의 온라인 수는 자동으로 절반으로 3으로 줄어 듭니다. 마찬가지로 온라인 더티 CPU 스케줄러 수는 온라인 스케줄러 수 증가에 비례하여 증가합니다.</target>
        </trans-unit>
        <trans-unit id="296f215c8d873bb49890168fa9e88995a8c46221" translate="yes" xml:space="preserve">
          <source>The number of elements in the returned &lt;code&gt;OptionValues&lt;/code&gt; list does not necessarily correspond to the number of options asked for. If the operating system fails to support an option, it is left out in the returned list. An error tuple is returned only when getting options for the socket is impossible (that is, the socket is closed or the buffer size in a raw request is too large). This behavior is kept for backward compatibility reasons.</source>
          <target state="translated">반환 된 &lt;code&gt;OptionValues&lt;/code&gt; 목록 의 요소 수는 요청한 옵션 수와 반드시 일치 할 필요는 없습니다. 운영 체제가 옵션을 지원하지 않으면 반환 된 목록에서 제외됩니다. 소켓에 대한 옵션을 가져올 수없는 경우에만 (즉, 소켓이 닫히거나 원시 요청의 버퍼 크기가 너무 큰 경우) 오류 튜플이 리턴됩니다. 이 동작은 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf38aefd99559296dffb26d07e3e9c61e6e9cb2" translate="yes" xml:space="preserve">
          <source>The number of elements in tuple &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;t&lt;/code&gt; 의 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="26ac4cc854d74b2c6762d35018676306c4817781" translate="yes" xml:space="preserve">
          <source>The number of file descriptors for sockets exceeds 1024 (Unix only). The limit on file descriptors in some Unix flavors can be set to over 1024, but only 1024 sockets/pipes can be used simultaneously by Erlang (because of limitations in the Unix &lt;code&gt;select&lt;/code&gt; call). The number of open regular files is not affected by this.</source>
          <target state="translated">소켓의 파일 디스크립터 수가 1024를 초과합니다 (Unix 전용). 일부 Unix 플레이버에서 파일 디스크립터 제한은 1024 이상으로 설정할 수 있지만 Erlang은 Unix &lt;code&gt;select&lt;/code&gt; 호출 의 제한 때문에 1024 개의 소켓 / 파이프 만 동시에 사용할 수 있습니다 . 열린 일반 파일 수는 이것에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6877de2384845937a41dca03e443b8b2ef2f56b" translate="yes" xml:space="preserve">
          <source>The number of free blocks available to the Erlang runtime system. This gives a fair indication of how fragmented the memory is.</source>
          <target state="translated">Erlang 런타임 시스템에서 사용 가능한 여유 블록 수입니다. 이것은 메모리가 어떻게 조각화되었는지에 대한 공정한 표시를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2302ea4b081c2465e0482782a8cfc33a6b390e01" translate="yes" xml:space="preserve">
          <source>The number of free variables.</source>
          <target state="translated">자유 변수의 수입니다.</target>
        </trans-unit>
        <trans-unit id="520aa8d21c613166906958a988904ef3774762d4" translate="yes" xml:space="preserve">
          <source>The number of funs visible in the dump.</source>
          <target state="translated">덤프에서 볼 수있는 재미의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b2f69372e36a07c28bf944db66a4eb608b5e6496" translate="yes" xml:space="preserve">
          <source>The number of intervals in the allocated block size histograms. Defaults to 18.</source>
          <target state="translated">할당 된 블록 크기 히스토그램의 간격 수입니다. 기본값은 18입니다.</target>
        </trans-unit>
        <trans-unit id="0b9e6ddbdccc43d4ce9130240064e22a9d65b0ef" translate="yes" xml:space="preserve">
          <source>The number of intervals in the free block size histograms. Defaults to 14.</source>
          <target state="translated">사용 가능한 블록 크기 히스토그램의 간격 수입니다. 기본값은 14입니다.</target>
        </trans-unit>
        <trans-unit id="8443d0d1c03c60db5f3a78f878917394a94a0502" translate="yes" xml:space="preserve">
          <source>The number of items written to the current wrap log file, header inclusive.</source>
          <target state="translated">현재 랩 로그 파일에 기록 된 항목 수이며 헤더를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1d7b0fbb13153371168cb8b20a96211640b2aed4" translate="yes" xml:space="preserve">
          <source>The number of live argument registers. The argument registers if any are live will follow. These can contain the arguments of the function if they are not yet moved to the stack.</source>
          <target state="translated">라이브 인수 레지스터의 수 라이브가 존재하면 인수가 등록됩니다. 아직 스택으로 이동하지 않은 경우 함수의 인수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa55c6a7661cbf8bcd105fb5ba2accf528f1e54" translate="yes" xml:space="preserve">
          <source>The number of loads and unloads by different &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; influences the loading and unloading of a driver file. The port killing therefore only occurs when the &lt;strong&gt;last&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads the driver, or when the last process having loaded the driver exits.</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 의한로드 및 언로드 수 는 드라이버 파일 의로드 및 언로드에 영향을줍니다. 따라서 포트 강제 종료는 &lt;strong&gt;마지막 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 드라이버를 언로드하거나 드라이버를로드 한 마지막 프로세스가 종료 될 때만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="24dcf08225a4cd44c2b72687111ada888affaff5" translate="yes" xml:space="preserve">
          <source>The number of messages in the process' message queue.</source>
          <target state="translated">프로세스의 메시지 큐에있는 메시지 수</target>
        </trans-unit>
        <trans-unit id="acf761f566ec0f6165b7b5bd0f0224040aa67d68" translate="yes" xml:space="preserve">
          <source>The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">전체적으로 (모든 프로세스에 대해) 처리 된 메시지 수는 mstone 값입니다.</target>
        </trans-unit>
        <trans-unit id="18ba056ef97bf335e6f0a4c98db5f6d989f8226b" translate="yes" xml:space="preserve">
          <source>The number of messages that the transaction coordinator and its participants need to exchange is few, as the &lt;code&gt;Mnesia&lt;/code&gt; table load mechanism takes care of the transaction recovery if the commit protocol gets interrupted. Since all involved tables are replicated symmetrically, the transaction is automatically recovered by loading the involved tables from the same node at startup of a failing node. It does not matter if the transaction was committed or terminated as long as the ACID properties can be ensured. The lightweight commit protocol is non-blocking, that is, the surviving participants and their coordinator finish the transaction, even if any node crashes in the middle of the commit protocol.</source>
          <target state="translated">커미트 프로토콜이 중단되면 &lt;code&gt;Mnesia&lt;/code&gt; 테이블로드 메커니즘이 트랜잭션 복구를 처리 하므로 트랜잭션 조정자와 참여자가 교환해야하는 메시지 수는 적습니다 . 관련된 모든 테이블이 대칭으로 복제되므로 실패한 노드를 시작할 때 동일한 노드에서 관련 테이블을로드하여 트랜잭션이 자동으로 복구됩니다. ACID 속성을 보장 할 수있는 한 트랜잭션이 커밋 또는 종료되었는지는 중요하지 않습니다. 경량 커밋 프로토콜은 비 블로킹입니다. 즉, 남아있는 참가자와 코디네이터가 커밋 프로토콜의 중간에서 노드가 충돌하더라도 트랜잭션을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="6a9dd2a90b5afbfc3e6021a57e6d176d541df76e" translate="yes" xml:space="preserve">
          <source>The number of objects in the table when the table dump to file started. For a &lt;code&gt;public&lt;/code&gt; table, this number does not need to correspond to the number of objects saved to the file, as objects can have been added or deleted by another process during table dump.</source>
          <target state="translated">파일을 테이블로 덤프 할 때 테이블의 오브젝트 수입니다. A에 대한 &lt;code&gt;public&lt;/code&gt; 객체가 테이블 덤프 동안 다른 프로세스에 의해 추가 또는 삭제 된 수있는 테이블이 번호는 파일에 저장 개체의 수에 대응이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2b7a9263d52e986e0825e5ba3ea4f95ca6e0342" translate="yes" xml:space="preserve">
          <source>The number of objects in the table.</source>
          <target state="translated">테이블의 오브젝트 수</target>
        </trans-unit>
        <trans-unit id="c0d1d535423cfacf2174f955ce39067569b39d55" translate="yes" xml:space="preserve">
          <source>The number of objects inserted in the table.</source>
          <target state="translated">테이블에 삽입 된 개체 수</target>
        </trans-unit>
        <trans-unit id="df0564a1b8506f23aaa82646ab79be6e878922a7" translate="yes" xml:space="preserve">
          <source>The number of objects written to the file is noted in the file footer, so file truncation can be verified even if the file was updated during dump.</source>
          <target state="translated">파일에 쓰여진 객체의 수는 파일 바닥 글에 표시되므로 덤프 중에 파일이 업데이트 된 경우에도 파일 잘림을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85699df12b894cf4882879c296b009b318c0eb18" translate="yes" xml:space="preserve">
          <source>The number of outbound and inbound streams can be set by giving an &lt;code&gt;sctp_initmsg&lt;/code&gt; option to &lt;code&gt;connect&lt;/code&gt; as in:</source>
          <target state="translated">다음과 같이 &lt;code&gt;sctp_initmsg&lt;/code&gt; 옵션을 &lt;code&gt;connect&lt;/code&gt; 하여 아웃 바운드 및 인바운드 스트림 수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edbec7af58e779e6f3839b4b6e2a81fbb1ef2ff" translate="yes" xml:space="preserve">
          <source>The number of parts is to be a positive integer for a specific maximum number of parts, and &lt;code&gt;infinity&lt;/code&gt; for the maximum number of parts possible (the default). Specifying &lt;code&gt;{parts,0}&lt;/code&gt; gives as many parts as possible disregarding empty parts at the end, the same as specifying &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">부품 수는 특정 최대 부품 수에 대한 양의 정수이고 가능한 최대 부품 수에 대한 &lt;code&gt;infinity&lt;/code&gt; 입니다 (기본값). &lt;code&gt;{parts,0}&lt;/code&gt; 을 지정 하면 끝 부분의 빈 부분을 무시하고 가능한 많은 부분을 제공합니다 ( &lt;code&gt;trim&lt;/code&gt; 지정과 동일) .</target>
        </trans-unit>
        <trans-unit id="2afdcddd62f1f4f544b050e244b0fb462484c316" translate="yes" xml:space="preserve">
          <source>The number of problems that arise when you always expect the wall clock time on the system to be correct can be immense. Erlang therefore introduced the &quot;corrected estimate of time&quot;, or the &quot;time correction&quot;, many years ago. The time correction relies on the fact that most operating systems have some kind of monotonic clock, either a real-time extension or some built-in &quot;tick counter&quot; that is independent of the wall clock settings. This counter can have microsecond resolution or much less, but it has a drift that cannot be ignored.</source>
          <target state="translated">시스템의 벽시계 시간이 항상 정확하다고 예상 할 때 발생하는 문제의 수는 엄청납니다. 따라서 Erlang은 몇 년 전에 &quot;정확한 시간 추정&quot;또는 &quot;시간 수정&quot;을 도입했습니다. 시간 수정은 대부분의 운영 체제에 실시간 확장 기능 또는 벽시계 설정과 무관 한 내장 &quot;틱 카운터&quot;와 같은 일종의 모노 토닉 시계가 있다는 사실에 의존합니다. 이 카운터는 마이크로 초 이하의 해상도를 가질 수 있지만, 표류는 무시할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e379e562f068c00ec3666a97b2b72ec4e1ae9a" translate="yes" xml:space="preserve">
          <source>The number of processes on the node.</source>
          <target state="translated">노드의 프로세스 수</target>
        </trans-unit>
        <trans-unit id="216d68b131398c4d5787004436814a5409c5c6b7" translate="yes" xml:space="preserve">
          <source>The number of processes that are ready to run.</source>
          <target state="translated">실행할 준비가 된 프로세스 수</target>
        </trans-unit>
        <trans-unit id="290cb25c487c21d6fb8fcc8db9708b6206bd9cb5" translate="yes" xml:space="preserve">
          <source>The number of processes visible in the dump.</source>
          <target state="translated">덤프에서 볼 수있는 프로세스 수입니다.</target>
        </trans-unit>
        <trans-unit id="83a57a5a9d8d177f4eabd403df33513424ff9d76" translate="yes" xml:space="preserve">
          <source>The number of received messages in this example depends on which OS and which shell that is used on the machine running the &lt;code&gt;ssh&lt;/code&gt; daemon. See also &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 수신 된 메시지 수는 &lt;code&gt;ssh&lt;/code&gt; 디먼을 실행중인 시스템에서 사용되는 OS 및 쉘에 따라 다릅니다 . &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="370052d660e4fe42c32d9343e6dadeb67604481b" translate="yes" xml:space="preserve">
          <source>The number of reductions a process is allowed to use before it is scheduled out is increased or reduced.</source>
          <target state="translated">프로세스가 예약되기 전에 사용할 수있는 축소 수는 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="2bb198ca00ef4fce937de982b13112d9a0c04566" translate="yes" xml:space="preserve">
          <source>The number of reductions consumed by the process.</source>
          <target state="translated">프로세스에서 소비 한 감소 수입니다.</target>
        </trans-unit>
        <trans-unit id="5a35a61b164da1ac8ca925205248deac1f49ddb0" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process.</source>
          <target state="translated">프로세스에서 실행 된 감소 수입니다.</target>
        </trans-unit>
        <trans-unit id="9b6c91666c81709e6916aac4bcc7db2c019f1985" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process. This can be presented as accumulated values or as values since the last update.</source>
          <target state="translated">프로세스에서 실행 된 감소 수입니다. 이는 마지막 업데이트 이후 누적 된 값 또는 값으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0994d6b82eb6222766c0e382dac55ae059c81e" translate="yes" xml:space="preserve">
          <source>The number of reductions performed before checking I/O is increased or reduced.</source>
          <target state="translated">I / O를 확인하기 전에 수행 된 감소 횟수가 증가 또는 감소합니다.</target>
        </trans-unit>
        <trans-unit id="468ae60b67a8e1bd0720dab30af034d085e6396a" translate="yes" xml:space="preserve">
          <source>The number of references to the fun.</source>
          <target state="translated">재미에 대한 참조 수입니다.</target>
        </trans-unit>
        <trans-unit id="407623cffa34482fa1d651acd67eee8403ccbecb" translate="yes" xml:space="preserve">
          <source>The number of replicas with storage type &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, and &lt;code&gt;disc_only_copies&lt;/code&gt;, respectively. The actual values are dynamically derived from the first fragment. The first fragment serves as a protype. When the actual values need to be computed (for example, when adding new fragments) they are determined by counting the number of each replica for each storage type. This means that when the functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; are applied on the first fragment, it affects the settings on &lt;code&gt;n_ram_copies&lt;/code&gt;, &lt;code&gt;n_disc_copies&lt;/code&gt;, and &lt;code&gt;n_disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">스토리지 유형이 &lt;code&gt;ram_copies&lt;/code&gt; , &lt;code&gt;disc_copies&lt;/code&gt; 및 &lt;code&gt;disc_only_copies&lt;/code&gt; 인 복제본의 수입니다 . 실제 값은 첫 번째 조각에서 동적으로 파생됩니다. 첫 번째 조각은 프로토 타입 역할을합니다. 실제 값을 계산해야하는 경우 (예 : 새 조각을 추가 할 때) 각 스토리지 유형에 대한 각 복제본 수를 계산하여 결정됩니다. 이는 &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; 함수 가 첫 번째 조각에 적용되면 &lt;code&gt;n_ram_copies&lt;/code&gt; , &lt;code&gt;n_disc_copies&lt;/code&gt; 및 &lt;code&gt;n_disc_only_copies&lt;/code&gt; 의 설정에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="9a9702435fc48e2cb1af958102326978bfa82700" translate="yes" xml:space="preserve">
          <source>The number of requests that a client can do on one connection. When the server has responded to the number of requests defined by &lt;code&gt;max_keep_alive_requests&lt;/code&gt;, the server closes the connection. The server closes it even if there are queued request. Default is no limit.</source>
          <target state="translated">클라이언트가 하나의 연결에서 수행 할 수있는 요청 수 서버가 &lt;code&gt;max_keep_alive_requests&lt;/code&gt; 에 의해 정의 된 요청 수에 응답하면 서버는 연결을 닫습니다. 대기중인 요청이 있어도 서버는 서버를 닫습니다. 기본값은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e6e68ac95a410c172b5340729e962a534a2dd6f" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads is determined at emulator boot time and cannot be changed later. However, the number of schedulers online can be changed at any time.</source>
          <target state="translated">스케줄러 스레드 수는 에뮬레이터 부팅시 결정되며 나중에 변경할 수 없습니다. 그러나 온라인 스케줄러 수는 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5271e1c80bfa6c1f0d80364c70cd4221fb1fac88" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads used by the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">런타임 시스템에서 사용하는 스케줄러 스레드 수 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 리턴 한 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="32fda466767f8cc6473462d182e187e0d2a3c92f" translate="yes" xml:space="preserve">
          <source>The number of seconds the server waits for a subsequent request from the client before closing the connection. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">연결을 닫기 전에 서버가 클라이언트의 후속 요청을 기다리는 시간 (초)입니다. 기본값은 &lt;code&gt;150&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6cd94e411933b9c1fa677dbde8d5b69166b1c7e8" translate="yes" xml:space="preserve">
          <source>The number of tables stored at one Erlang node &lt;strong&gt;used&lt;/strong&gt; to be limited. This is no longer the case (except by memory usage). The previous default limit was about 1400 tables and could be increased by setting the environment variable &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; or the command line option &lt;code&gt;+e&lt;/code&gt; before starting the Erlang runtime system. This hard limit has been removed, but it is currently useful to set the &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; anyway. It should be set to an approximate of the maximum amount of tables used. This since an internal table for named tables is sized using this value. If large amounts of named tables are used and &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; hasn't been increased, the performance of named table lookup will degrade.</source>
          <target state="translated">하나 개 얼랑 노드에 저장된 테이블의 수는 &lt;strong&gt;이용&lt;/strong&gt; 에 한정된다. 더 이상 해당되지 않습니다 (메모리 사용 제외). 이전의 기본 한계는 약 1400 개의 테이블 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; Erlang 런타임 시스템을 시작하기 전에 환경 변수 ERL_MAX_ETS_TABLES 또는 명령 행 옵션 &lt;code&gt;+e&lt;/code&gt; 를 설정하여 증가시킬 수 있습니다 . 이 하드 한계는 제거되었지만 현재 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; 를 설정하는 것이 유용 합니다. 사용 된 최대 테이블 수의 근사값으로 설정해야합니다. 명명 된 테이블의 내부 테이블 크기가이 값을 사용하므로 크기가 결정됩니다. 많은 양의 명명 된 테이블이 사용되고 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; 가 증가되지 않은 경우 명명 된 테이블 조회 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee6cef5045ecfc684ba415cb4ca61311f9f1874" translate="yes" xml:space="preserve">
          <source>The number of used reference numbers in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 에서 사용 된 참조 번호의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="7b21087ec91e7492fc97a64907aa82ec4cec1d47" translate="yes" xml:space="preserve">
          <source>The number of whole megaseconds elapsed since the arbitrary point in time</source>
          <target state="translated">임의 시점에서 경과 된 전체 메가 초 수</target>
        </trans-unit>
        <trans-unit id="2ac856f3d61651add159fe85d25637849ee12830" translate="yes" xml:space="preserve">
          <source>The number of whole microseconds elapsed since the arbitrary point in time</source>
          <target state="translated">임의 시점에서 경과 한 전체 마이크로 초 수</target>
        </trans-unit>
        <trans-unit id="7fc686361ce6577e49fbdfa1f7f9667a3114c986" translate="yes" xml:space="preserve">
          <source>The number of whole seconds elapsed since the arbitrary point in time</source>
          <target state="translated">임의 시점에서 경과 한 전체 초 수</target>
        </trans-unit>
        <trans-unit id="54d5c18e70c70f565fba6a0087d94cc081284d10" translate="yes" xml:space="preserve">
          <source>The number of words (usually 4 bytes/word) allocated to data in the table.</source>
          <target state="translated">테이블의 데이터에 할당 된 워드 수 (보통 4 바이트 / 워드)입니다.</target>
        </trans-unit>
        <trans-unit id="47eb13f9275d0915b77640cef69cc834d1d7a797" translate="yes" xml:space="preserve">
          <source>The number of words allocated to the table.</source>
          <target state="translated">테이블에 할당 된 단어 수</target>
        </trans-unit>
        <trans-unit id="34f864a2059c77fad570ae2b8b9aa8d55bc831b6" translate="yes" xml:space="preserve">
          <source>The numeric value of option &lt;code&gt;TCP_INFO&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TCP_INFO&lt;/code&gt; 옵션의 숫자 값</target>
        </trans-unit>
        <trans-unit id="fc80d9d15d1bbefd0794c4eb3dc7e83893ef6e5a" translate="yes" xml:space="preserve">
          <source>The numeric value of protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt;</source>
          <target state="translated">프로토콜 수준 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 의 숫자 값</target>
        </trans-unit>
        <trans-unit id="18b84a5716cb0140a4fa23575b7b99dd4e4ad89a" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;object1&lt;/code&gt; is an instance of the class &lt;code&gt;GENERAL-PROCEDURE&lt;/code&gt; and has one type field and one fixed type value field. The object &lt;code&gt;object2&lt;/code&gt; has also an optional field &lt;code&gt;ERROR&lt;/code&gt;, which is a type field. The field &lt;code&gt;ADDRESS&lt;/code&gt; is a &lt;code&gt;UNIQUE&lt;/code&gt; field. Objects in an object set must have unique values in their &lt;code&gt;UNIQUE&lt;/code&gt; field, as in &lt;code&gt;GENERAL-PROCEDURES&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;object1&lt;/code&gt; 오브젝트 는 &lt;code&gt;GENERAL-PROCEDURE&lt;/code&gt; 클래스의 인스턴스이며 하나의 유형 필드와 하나의 고정 유형 값 필드가 있습니다. &lt;code&gt;object2&lt;/code&gt; 객체 에는 선택적 필드 인 &lt;code&gt;ERROR&lt;/code&gt; 필드도 있습니다.이 필드는 유형 필드입니다. &lt;code&gt;ADDRESS&lt;/code&gt; 필드 는 &lt;code&gt;UNIQUE&lt;/code&gt; 필드입니다. 객체 세트의 객체는 자신의 고유 한 값을 가지고 있어야 &lt;code&gt;UNIQUE&lt;/code&gt; 를 같이 필드 &lt;code&gt;GENERAL-PROCEDURES&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbf8ca38a75143807f12207e1626da60e0683472" translate="yes" xml:space="preserve">
          <source>The object code can not be loaded because an old version of the code already exists.</source>
          <target state="translated">이전 버전의 코드가 이미 존재하므로 오브젝트 코드를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e42f92b47527dda301da44c64b3f38f701eebfd" translate="yes" xml:space="preserve">
          <source>The object code could not be loaded because an old version of the code already existed.</source>
          <target state="translated">이전 버전의 코드가 이미 존재하므로 오브젝트 코드를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1c96d58c8d066eedb5b142300fba6386dd9f37a" translate="yes" xml:space="preserve">
          <source>The object code for all applications, structured according to the &lt;code&gt;&lt;a href=&quot;applications#app_dir&quot;&gt;application directory structure&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;applications#app_dir&quot;&gt;application directory structure&lt;/a&gt;&lt;/code&gt; 에 따라 구조화 된 모든 응용 프로그램의 객체 코드</target>
        </trans-unit>
        <trans-unit id="312de602ae6cab5b49378f20db6833b3ebf51e54" translate="yes" xml:space="preserve">
          <source>The object code has an incorrect format or the module name in the object code is not the expected module name.</source>
          <target state="translated">오브젝트 코드의 형식이 올바르지 않거나 오브젝트 코드의 모듈 이름이 예상 된 모듈 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b9f74288a78af8c662bf58b4bfec75119b65998d" translate="yes" xml:space="preserve">
          <source>The object code in &lt;code&gt;Binary&lt;/code&gt; has an incorrect format &lt;strong&gt;or&lt;/strong&gt; the object code contains code for another module than &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">의 목적 코드 &lt;code&gt;Binary&lt;/code&gt; 잘못된 형식을 가지고 &lt;strong&gt;또는&lt;/strong&gt; 오브젝트 코드가 아닌 다른 모듈에 대한 코드를 포함하는 &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86c3849edb93463e5fde8f6001389a8a8a16d72" translate="yes" xml:space="preserve">
          <source>The object code must be &lt;strong&gt;loaded&lt;/strong&gt; into the Erlang runtime system. This is handled by the &lt;strong&gt;code server&lt;/strong&gt;, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">오브젝트 코드는 Erlang 런타임 시스템에 &lt;strong&gt;로드&lt;/strong&gt; 되어야합니다 . 이것은 &lt;strong&gt;코드 서버에&lt;/strong&gt; 의해 처리됩니다 . 커널 의 &lt;code&gt;code(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f7d279e2bf494f71d13acb1a9c0428dae21af2e" translate="yes" xml:space="preserve">
          <source>The object code resides in a sticky directory.</source>
          <target state="translated">오브젝트 코드는 고정 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9034bf7170e48c51bdec7372e69a543233e72148" translate="yes" xml:space="preserve">
          <source>The object has the wrong arity.</source>
          <target state="translated">개체의 특성이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ce289dd810ddc811f5f67ba5e6a9137c550f27b" translate="yes" xml:space="preserve">
          <source>The object is removed from the registry after a call to &lt;code&gt;ei_reg_dump()&lt;/code&gt; or &lt;code&gt;ei_reg_purge()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ei_reg_dump()&lt;/code&gt; 또는 &lt;code&gt;ei_reg_purge()&lt;/code&gt; 호출 후 레지스트리에서 객체가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="50a81e0e0ac3bfcd2994a6155ab70f493367ff09" translate="yes" xml:space="preserve">
          <source>The objects in these MIBs are implemented in the modules &lt;code&gt;snmp_framework_mib&lt;/code&gt; and &lt;code&gt;snmp_standard_mib&lt;/code&gt;, respectively. All objects reside in volatile memory, and the configuration files are always reread at start-up.</source>
          <target state="translated">이 MIB의 오브젝트는 각각 &lt;code&gt;snmp_framework_mib&lt;/code&gt; 및 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 모듈에서 구현됩니다 . 모든 객체는 휘발성 메모리에 상주하며 시작시 항상 구성 파일을 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f1f269a0ce7fdbd2a517508eb670b7eae55c54f4" translate="yes" xml:space="preserve">
          <source>The objects of a table are distributed among slots, starting with slot &lt;code&gt;0&lt;/code&gt; and ending with slot &lt;code&gt;n&lt;/code&gt;. Returns the list of objects associated with slot &lt;code&gt;I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; &amp;gt; &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">테이블의 객체는 슬롯 &lt;code&gt;0&lt;/code&gt; 에서 시작 하여 슬롯 &lt;code&gt;n&lt;/code&gt; 으로 끝나는 슬롯에 분산 됩니다. 슬롯 &lt;code&gt;I&lt;/code&gt; 과 관련된 객체 목록을 반환합니다 . 경우 &lt;code&gt;I&lt;/code&gt; &amp;gt; &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;'$end_of_table'&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a3cf193455ab85acb8426078bfa2d77fba608067" translate="yes" xml:space="preserve">
          <source>The octal value &lt;code&gt;ddd&lt;/code&gt;.</source>
          <target state="translated">진수 값은 &lt;code&gt;ddd&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="10825eec8b9992856eefc5e7184bd2d3d8b5728b" translate="yes" xml:space="preserve">
          <source>The offset, either a string or an integer, to be included in the formatted string. An empty string, which is the default, is interpreted as local time. A non-empty string is included as is. The time unit of the integer is the same as the one of &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">형식화 된 문자열에 포함 할 오프셋 (문자열 또는 정수)입니다. 빈 문자열은 기본값으로 현지 시간으로 해석됩니다. 비어 있지 않은 문자열은 그대로 포함됩니다. 정수의 시간 유닛들 중 하나와 동일한 &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d661922c13a7026a70bf710f1f3e5ff84da384ab" translate="yes" xml:space="preserve">
          <source>The old &lt;code&gt;error_logger&lt;/code&gt; event handlers in STDLIB and SASL still exist, but they are not added by Erlang/OTP 21.0 or later.</source>
          <target state="translated">STDLIB 및 SASL에 이전 &lt;code&gt;error_logger&lt;/code&gt; 이벤트 핸들러가 여전히 존재하지만 Erlang / OTP 21.0 이상에 의해 추가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e02582e73aee9b9d25f8eb0a27c6533b07e2b64" translate="yes" xml:space="preserve">
          <source>The old SASL error logging behaviour can be re-enabled by setting the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">커널 구성 매개 변수 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 이전 SASL 오류 로깅 동작을 다시 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a76e919cb31d567d70f0c1884a6bff75f85a4f4" translate="yes" xml:space="preserve">
          <source>The old event category &lt;code&gt;{table, Tab}&lt;/code&gt; is the same event category as &lt;code&gt;{table, Tab, simple}&lt;/code&gt;.</source>
          <target state="translated">이전 이벤트 카테고리 &lt;code&gt;{table, Tab}&lt;/code&gt; 은 &lt;code&gt;{table, Tab, simple}&lt;/code&gt; 과 동일한 이벤트 카테고리 입니다.</target>
        </trans-unit>
        <trans-unit id="59f7e677b9778b0fb1d66db7316174f828de7a9a" translate="yes" xml:space="preserve">
          <source>The old module is still available for compatibility, but should not be used for new programs. The old module will not be maintained except for some error corrections</source>
          <target state="translated">이전 모듈은 여전히 ​​호환 가능하지만 새 프로그램에는 사용해서는 안됩니다. 일부 오류 수정을 제외하고 이전 모듈은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4311de06755abb4e51609dffbdd9331251a3c42a" translate="yes" xml:space="preserve">
          <source>The old port owner stays linked to the port and must call &lt;code&gt;unlink(Port)&lt;/code&gt; if this is not desired. Any process can set the port owner to be any process with &lt;code&gt;port_connect/2&lt;/code&gt;.</source>
          <target state="translated">이전 포트 소유자는 포트에 연결된 상태로 유지 되며 원하지 않는 경우 &lt;code&gt;unlink(Port)&lt;/code&gt; 호출해야합니다 . 모든 프로세스는 포트 소유자를 &lt;code&gt;port_connect/2&lt;/code&gt; 의 모든 프로세스로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="252509caf54119a65fc2fb237a753881b8ffad79" translate="yes" xml:space="preserve">
          <source>The old time API is based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; was intended to be used for many unrelated things. This tied these unrelated operations together and caused issues with performance, scalability, accuracy, and precision for operations that did not need to have such issues. To improve this, the new API spreads different functionality over multiple functions.</source>
          <target state="translated">기존 API는 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 기반입니다 . &lt;code&gt;erlang:now/0&lt;/code&gt; 은 많은 관련없는 것들을 위해 사용되었습니다. 이는 이러한 관련없는 작업을 하나로 묶어 이러한 문제가 필요하지 않은 작업의 성능, 확장 성, 정확성 및 정밀성 문제를 일으켰습니다. 이를 개선하기 위해 새로운 API는 여러 기능에 서로 다른 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0286a4a48dcade7c3397c916982a12af0309f49f" translate="yes" xml:space="preserve">
          <source>The old tuple format is kept for backwards compatibility, see &lt;code&gt;&lt;a href=&quot;#type-child_spec&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt;, but the map is preferred.</source>
          <target state="translated">이전 튜플 형식은 이전 버전과의 호환성을 위해 유지 되지만 &lt;code&gt;&lt;a href=&quot;#type-child_spec&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt; 참조 하지만 맵이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="5213f93470dcbb8caa4306da1f34f9dc9cde6c3f" translate="yes" xml:space="preserve">
          <source>The old tuple formats with &lt;code&gt;Ip&lt;/code&gt; address and &lt;code&gt;Udp&lt;/code&gt; port number found in old configurations still work.</source>
          <target state="translated">이전 구성에서 찾은 &lt;code&gt;Ip&lt;/code&gt; 주소 및 &lt;code&gt;Udp&lt;/code&gt; 포트 번호를 가진 이전 튜플 형식은 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8c6a30a350aa9ef26562d44a342bd9fffb85daa0" translate="yes" xml:space="preserve">
          <source>The old user tag (if any) is returned, or &lt;code&gt;undefined&lt;/code&gt; if no user tag was present or dynamic tracing is not enabled.</source>
          <target state="translated">이전 사용자 태그 (있는 경우)가 반환되거나 사용자 태그가 없거나 동적 추적이 활성화 &lt;code&gt;undefined&lt;/code&gt; 경우 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="560418bd51e719aa06237064ddd18055f504721b" translate="yes" xml:space="preserve">
          <source>The only allowed driver option is &lt;code&gt;kill_ports&lt;/code&gt;, which means that all ports opened to the driver are killed with exit reason &lt;code&gt;driver_unloaded&lt;/code&gt; when no process any longer has the driver loaded. This situation arises either when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;, or when the last process having loaded the driver exits.</source>
          <target state="translated">유일하게 허용되는 드라이버 옵션은 &lt;code&gt;kill_ports&lt;/code&gt; 이며, 더 이상 드라이버가로드 된 프로세스가없는 경우 종료 이유 &lt;code&gt;driver_unloaded&lt;/code&gt; 로 드라이버에 열린 모든 포트가 종료 됩니다. 이 상황은 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 를 호출 하거나 드라이버를로드 한 마지막 프로세스가 종료 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b877b313b1006940c4cf41c60f09d3385fb04336" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;StateFunctionResult&lt;/code&gt; and &lt;code&gt;HandleEventResult&lt;/code&gt; is that for &lt;code&gt;StateFunctionResult&lt;/code&gt; the next state must be an atom, but for &lt;code&gt;HandleEventResult&lt;/code&gt; there is no restriction on the next state.</source>
          <target state="translated">유일한 차이점 &lt;code&gt;StateFunctionResult&lt;/code&gt; 및 &lt;code&gt;HandleEventResult&lt;/code&gt; 을 위한이다 &lt;code&gt;StateFunctionResult&lt;/code&gt; 다음 상태는 원자이어야하지만 대한 &lt;code&gt;HandleEventResult&lt;/code&gt; 다음 상태에 대한 제한은 없다.</target>
        </trans-unit>
        <trans-unit id="0f50b6fea79bf8e8e2c3a8ded26b5d687ae24528" translate="yes" xml:space="preserve">
          <source>The only documentation that is recommended to be released in this way are the man pages. HTML and PDF will normally be distributed in some other manner.</source>
          <target state="translated">이 방법으로 릴리스 할 것을 권장하는 유일한 설명서는 매뉴얼 페이지입니다. HTML과 PDF는 일반적으로 다른 방식으로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="1130e04c19ee8513c73e7178d0ff68d3aa9b5d59" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is &lt;code&gt;error:undef&lt;/code&gt; which guarantees to include the Module, Function and Arity of the attempted function as the first stacktrace entry.</source>
          <target state="translated">이 규칙의 유일한 예외는 &lt;code&gt;error:undef&lt;/code&gt; 입니다. 이는 시도 된 기능의 모듈, 기능 및 특성을 첫 번째 스택 추적 항목으로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bf2d1dc9bc29c7d67e629d6a36aab11ede21435f" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is the class &lt;code&gt;error&lt;/code&gt; with the reason &lt;code&gt;undef&lt;/code&gt; which is guaranteed to include the &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Arity&lt;/code&gt; of the attempted function as the first stacktrace entry.</source>
          <target state="translated">이 규칙에 대한 유일한 예외는 &lt;code&gt;undef&lt;/code&gt; 이유 가있는 클래스 &lt;code&gt;error&lt;/code&gt; 이며 시도 된 함수 의 &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; 및 &lt;code&gt;Arity&lt;/code&gt; 가 첫 번째 스택 추적 항목 으로 포함되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="cba16851052fe41ed6e022bc41a2dcd36c32376e" translate="yes" xml:space="preserve">
          <source>The only exported function from the driver is &lt;code&gt;driver_init&lt;/code&gt;. This function returns the &lt;code&gt;driver_entry&lt;/code&gt; structure that points to the other functions in the driver. The &lt;code&gt;driver_init&lt;/code&gt; function is declared with a macro, &lt;code&gt;DRIVER_INIT(drivername)&lt;/code&gt;. (This is because different operating systems have different names for it.)</source>
          <target state="translated">드라이버에서 내 보낸 유일한 함수는 &lt;code&gt;driver_init&lt;/code&gt; 입니다. 이 함수는 드라이버의 다른 함수를 가리키는 &lt;code&gt;driver_entry&lt;/code&gt; 구조를 반환합니다 . &lt;code&gt;driver_init&lt;/code&gt; 의 기능 매크로와 선언 &lt;code&gt;DRIVER_INIT(drivername)&lt;/code&gt; . (운영 체제마다 이름이 다르기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="1696dc38d1cf9a5d02abc823dd0e7fc5c6596e2d" translate="yes" xml:space="preserve">
          <source>The only feature that not is implemented is the &lt;code&gt;netascii&lt;/code&gt; transfer mode.</source>
          <target state="translated">구현되지 않은 유일한 기능은 &lt;code&gt;netascii&lt;/code&gt; 전송 모드입니다.</target>
        </trans-unit>
        <trans-unit id="b5c833b89182cc5b90fce17ff719f78c8281aaac" translate="yes" xml:space="preserve">
          <source>The only new user interface function is the one provided by the user in the configuration file. The function is started by the &lt;code&gt;ModuleName:FunctionName&lt;/code&gt; notation.</source>
          <target state="translated">유일한 새로운 사용자 인터페이스 기능은 구성 파일에서 사용자가 제공 한 기능입니다. 이 기능은 &lt;code&gt;ModuleName:FunctionName&lt;/code&gt; 표기법으로 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4c6a2cba6db5082ab2b924d01428d176098f7b4" translate="yes" xml:space="preserve">
          <source>The only possible error reason &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;{&quot;global_groups definition error&quot;, Error}&lt;/code&gt;.</source>
          <target state="translated">유일하게 가능한 오류 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;{&quot;global_groups definition error&quot;, Error}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4302c1a5eaa9921e04a9ee05f8db970b626954e6" translate="yes" xml:space="preserve">
          <source>The only reason to set it to &lt;code&gt;false&lt;/code&gt; is if you want to continue sending data to the socket after a close is detected, for example, if the peer uses &lt;code&gt;&lt;a href=&quot;gen_tcp#shutdown-2&quot;&gt;gen_tcp:shutdown/2&lt;/a&gt;&lt;/code&gt; to shut down the write side.</source>
          <target state="translated">이를 &lt;code&gt;false&lt;/code&gt; 로 설정하는 유일한 이유 는 예를 들어 피어가 &lt;code&gt;&lt;a href=&quot;gen_tcp#shutdown-2&quot;&gt;gen_tcp:shutdown/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 쓰기 측을 종료 한 경우와 같이 닫기가 감지 된 후 소켓으로 데이터를 계속 전송하려는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="0bd2b35842e406e11aa99f3c06919005b7f0b40e" translate="yes" xml:space="preserve">
          <source>The only signal ordering guarantee given is the following: if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if &lt;code&gt;A&lt;/code&gt; sends a signal &lt;code&gt;S1&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, and later sends signal &lt;code&gt;S2&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;S1&lt;/code&gt; is guaranteed not to arrive after &lt;code&gt;S2&lt;/code&gt;.</source>
          <target state="translated">제공되는 유일한 신호 순서 보장은 다음과 같습니다. 만약 한 엔티티가 동일한 목적지 엔티티에 여러 개의 신호를 보내면 그 순서는 유지됩니다. 그 경우,이고 &lt;code&gt;A&lt;/code&gt; 신호 전송 &lt;code&gt;S1&lt;/code&gt; 을 에 &lt;code&gt;B&lt;/code&gt; , 이상 신호 전송 &lt;code&gt;S2&lt;/code&gt; 를 로 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;S1&lt;/code&gt; 은 이후에 도착하지 않는 것이 확실한 &lt;code&gt;S2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16e25f07eac66ff46d41498e9c52f4e662f5d9c6" translate="yes" xml:space="preserve">
          <source>The only supported option is &lt;code&gt;{verify,boolean()}&lt;/code&gt;. If verification is turned on (by specifying &lt;code&gt;{verify,true}&lt;/code&gt;), the function uses whatever information is present in the file to assert that the information is not damaged. How this is done depends on which &lt;code&gt;extended_info&lt;/code&gt; was written using &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유일하게 지원되는 옵션은 &lt;code&gt;{verify,boolean()}&lt;/code&gt; 입니다. &lt;code&gt;{verify,true}&lt;/code&gt; 를 지정하여 확인이 설정되어 있으면 함수는 파일에있는 모든 정보를 사용하여 정보가 손상되지 않았 음을 확인합니다. 이를 수행하는 방법은 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 을 사용하여 작성된 &lt;code&gt;extended_info&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="a4d83fec128ceaff5533b8b8493896363c149eb7" translate="yes" xml:space="preserve">
          <source>The only supported usage is to generate one distinct random sequence from this start state.</source>
          <target state="translated">유일하게 지원되는 사용법은이 시작 상태에서 하나의 고유 한 무작위 시퀀스를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f32acd6c078a02af6a8141ee25a3cbecc6c24eae" translate="yes" xml:space="preserve">
          <source>The only syntactical limitation imposed by the preprocessor on the arguments to a macro application (viewed as sequences of tokens) is that they must be balanced with respect to parentheses, brackets, &lt;code&gt;begin ... end&lt;/code&gt;, &lt;code&gt;case ... end&lt;/code&gt;, etc. The &lt;code&gt;text&lt;/code&gt; node type can be used to represent arguments which are not regular Erlang constructs.</source>
          <target state="translated">매크로 응용 프로그램에 대한 인수 (토큰 순서로 표시)에 대해 전 처리기에서 부과하는 구문상의 제한은 괄호, 괄호, &lt;code&gt;begin ... end&lt;/code&gt; , &lt;code&gt;case ... end&lt;/code&gt; 등과 관련하여 균형을 이루어야한다는 것입니다 . &lt;code&gt;text&lt;/code&gt; 노드 유형은 일반적인 Erlang 구문이 아닌 인수를 나타내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bcbae1f57b05af5cbe66ffd509cb1bd7d6129be" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;{register, UserId, TargetName, AgentConfig}&lt;/code&gt; 리턴하는 유일한 사용자 는 &lt;strong&gt;기본 사용자&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1b3a9187732633f1cf125b19158045930fb9262" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;{register, UserId, TargetName2, AgentConfig}&lt;/code&gt; 리턴하는 유일한 사용자 는 &lt;strong&gt;기본 사용자&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="856c8192723936f88433456a55a9d3e8225ac26b" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, agent_info()}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;{register, UserId, TargetName2, agent_info()}&lt;/code&gt; 리턴하는 유일한 사용자 는 &lt;strong&gt;기본 사용자&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66ccb0d98fc09fa8872b21645b16bf70dd169beb" translate="yes" xml:space="preserve">
          <source>The only valid values for &lt;code&gt;&amp;lt;range&amp;gt;&lt;/code&gt; are &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;unicode&lt;/code&gt;. &lt;code&gt;latin1&lt;/code&gt; means that only code points &amp;lt; 256 (except control characters, and so on) are considered printable. &lt;code&gt;unicode&lt;/code&gt; means that all printable characters in all Unicode character ranges are considered printable by the I/O functions.</source>
          <target state="translated">&lt;code&gt;&amp;lt;range&amp;gt;&lt;/code&gt; 에 유효한 값 은 &lt;code&gt;latin1&lt;/code&gt; 및 &lt;code&gt;unicode&lt;/code&gt; 입니다. &lt;code&gt;latin1&lt;/code&gt; 은 코드 포인트 &amp;lt;256 (제어 문자 등 제외) 만 인쇄 가능한 것으로 간주됨을 의미합니다. &lt;code&gt;unicode&lt;/code&gt; 는 모든 유니 코드 문자 범위의 모든 인쇄 가능 문자가 I / O 기능에 의해 인쇄 가능한 것으로 간주됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="02b1141f03eddf910011a4ff2a58eb780a8ab4e0" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 반환 된 opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 참조는이 모듈에서 다른 함수를 호출 할 때 클라이언트 식별자로 사용될 수 있습니다. 그러나 &lt;code&gt;KeyOrName&lt;/code&gt; 이 &lt;code&gt;target_name()&lt;/code&gt; 인 경우, 즉 테스트 스위트에서 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문에 대한 호출을 통해 서버 이름이 지정된 경우 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 대신이 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="216692fe587eacd8f1cf30a3339eb308bb1cb50e" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is used and it is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 반환 된 opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 참조는이 모듈에서 다른 함수를 호출 할 때 클라이언트 식별자로 사용될 수 있습니다. 그러나 &lt;code&gt;KeyOrName&lt;/code&gt; 이 사용되고 &lt;code&gt;target_name()&lt;/code&gt; 인 경우, 즉 서버가 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 또는 테스트 스위트 의 &lt;code&gt;require&lt;/code&gt; 문에 대한 호출을 통해 이름이 지정된 경우 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 대신) 대신이 이름을 사용할 수 있습니다 ( ) .</target>
        </trans-unit>
        <trans-unit id="dab51a13d4ecc21e5671204ca36e445fd1f3de37" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 반환 된 opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 참조는이 연결을 통해 세션을 열 때 연결 식별자로 사용할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 참조) . 그러나 &lt;code&gt;KeyOrName&lt;/code&gt; 이 &lt;code&gt;target_name()&lt;/code&gt; 인 경우, 즉 테스트 스위트에서 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문에 대한 호출을 통해 서버 이름이 지정된 경우 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 대신이 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a66edf19af62a3385d416b41ffcad011c88ad9a" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as client identifier when calling any other function in this module.</source>
          <target state="translated">이 함수에서 반환 된 불투명 한 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 참조는이 모듈에서 다른 함수를 호출 할 때 클라이언트 식별자로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dbb23ff6963a9fa5daa339e7b22a266927eaf0fb" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에서 반환 된 불투명 한 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 참조는이 연결을 통해 세션을 열 때 연결 식별자로 필요합니다 ( &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="07aa6b76a1d620737ff1463895883152bf7bd915" translate="yes" xml:space="preserve">
          <source>The operating system has no concept of drives.</source>
          <target state="translated">운영 체제에는 드라이브 개념이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d1f7c571653276add5945991e7d8dbaf8340b38" translate="yes" xml:space="preserve">
          <source>The operating systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;os:system_time()&lt;/code&gt;. This may or may not be an accurate view of POSIX time. This time may typically be adjusted both backwards and forwards without limitation. That is, &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; may be observed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 의 운영 체제보기 . 검색하려면 &lt;code&gt;os:system_time()&lt;/code&gt; 호출하십시오 . POSIX 시간을 정확하게 볼 수도 있고 아닐 수도 있습니다. 이 시간은 전형적으로 제한없이 앞뒤로 조정될 수있다. 즉, &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; 이 관찰 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8b7dc04007a8243cf1e155a5507f9e9a7b4ed595" translate="yes" xml:space="preserve">
          <source>The operation was aborted, as the process needed to be garbage collected to determine the operation result, and the operation was requested by passing option &lt;code&gt;{allow_gc, false}&lt;/code&gt;.</source>
          <target state="translated">작업 결과를 판별하기 위해 프로세스를 가비지 수집해야하므로 작업이 중단되었으며 &lt;code&gt;{allow_gc, false}&lt;/code&gt; 옵션을 전달하여 작업이 요청되었습니다 .</target>
        </trans-unit>
        <trans-unit id="028d2f9f2cf1ad6ba073b32e1d502dfedbbb24a1" translate="yes" xml:space="preserve">
          <source>The operator of a &lt;code&gt;Common Test&lt;/code&gt; system can receive event notifications continuously during a test run. For example, &lt;code&gt;Common Test&lt;/code&gt; reports when a test case starts and stops, the current count of successful, failed, and skipped cases, and so on. This information can be used for different purposes such as logging progress and results in another format than HTML, saving statistics to a database for report generation, and test system supervision.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 시스템 의 운영자 는 테스트 실행 중에 지속적으로 이벤트 알림을 수신 할 수 있습니다. 예를 들어, &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 사례가 시작 및 중지 될 때, 현재 성공, 실패 및 건너 뛴 사례 수 등을보고합니다. 이 정보는 HTML 이외의 형식으로 진행 상황 및 결과 로깅, 보고서 생성을 위해 데이터베이스에 통계 저장 및 테스트 시스템 감독과 같은 다양한 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac9cd2f3357019ca23e28a1a5c29f888acd7d48" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;add_module&lt;/code&gt; is &lt;code&gt;delete_module&lt;/code&gt;, which unloads a module:</source>
          <target state="translated">&lt;code&gt;add_module&lt;/code&gt; 의 반대 는 &lt;code&gt;delete_module&lt;/code&gt; 이며 모듈을 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="8201763988fd73d2d4e9e61c9df537349bc58481" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;use_stdio&lt;/code&gt;. It uses file descriptors 3 and 4 for communication with Erlang.</source>
          <target state="translated">&lt;code&gt;use_stdio&lt;/code&gt; 와 반대입니다 . Erlang과의 통신을 위해 파일 디스크립터 3과 4를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6947afa7b807cda54cd165aa32ce74a3d79f4c15" translate="yes" xml:space="preserve">
          <source>The optimization of the binary append operation requires that there is a &lt;strong&gt;single&lt;/strong&gt; ProcBin and a &lt;strong&gt;single reference&lt;/strong&gt; to the ProcBin for the binary. The reason is that the binary object can be moved (reallocated) during an append operation, and when that happens, the pointer in the ProcBin must be updated. If there would be more than one ProcBin pointing to the binary object, it would not be possible to find and update all of them.</source>
          <target state="translated">이진 추가 작업을 최적화하려면 &lt;strong&gt;단일&lt;/strong&gt; ProcBin과 이진에 대한 ProcBin에 대한 &lt;strong&gt;단일 참조가&lt;/strong&gt; 있어야합니다. 추가 작업 중에 이진 개체를 이동 (재 할당) 할 수 있기 때문에 ProcBin의 포인터를 업데이트해야합니다. 이진 개체를 가리키는 둘 이상의 ProcBin이 있으면 모든 개체를 찾아 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a7dfbb8b5004581e731dee0d182116bbc44ffc2" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;agent_capabilities&lt;/code&gt;, if present, specifies that the AGENT-CAPABILITIES statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the agent-capabilitie will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="translated">&lt;code&gt;agent_capabilities&lt;/code&gt; 옵션이있는 경우 MIB의 AGENT-CAPABILITIES 문이 컴파일 된 mib에 포함되도록 (mib-entry 레코드와 함께) 지정합니다. agent-capabilitie의 mib-entry 레코드 는 &lt;code&gt;assocList&lt;/code&gt; 필드 에이 정보에 대한 &lt;code&gt;reference&lt;/code&gt; 및 &lt;code&gt;modules&lt;/code&gt; 부분을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="06424cbe694389a0379fd6422e76eb2e7b311463" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;db&lt;/code&gt; specifies which database should be used for the default instrumentation.</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; 옵션 은 기본 계측에 사용해야하는 데이터베이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b1c38411f37d947a6f2316b11a66ae14df30f64e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;deprecated&lt;/code&gt; specifies if a deprecated definition should be kept or not. If the option is false the MIB compiler will ignore all deprecated definitions.</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 옵션 은 더 이상 사용되지 않는 정의를 유지해야하는지 여부를 지정합니다. 옵션이 false이면 MIB 컴파일러는 더 이상 사용되지 않는 정의를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="55335984c5b08e8d1673e107cca029d522769243" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;description&lt;/code&gt; specifies if the text of the DESCRIPTION field will be included or not.</source>
          <target state="translated">옵션 &lt;code&gt;description&lt;/code&gt; 은 DESCRIPTION 필드의 텍스트를 포함할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="09b9fb64f572f9490ecb854f2b8072cc568815e6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;group_check&lt;/code&gt; specifies whether the mib compiler should check the OBJECT-GROUP macro and the NOTIFICATION-GROUP macro for correctness or not.</source>
          <target state="translated">&lt;code&gt;group_check&lt;/code&gt; 옵션 은 mib 컴파일러가 OBJECT-GROUP 매크로와 NOTIFICATION-GROUP 매크로의 정확성을 검사 해야하는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ee1cb6b787011127b81f08d59e1c6d1d5e4d9685" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;i&lt;/code&gt; specifies the path to search for imported (compiled) MIB files. The directories should be strings with a trailing directory delimiter.</source>
          <target state="translated">옵션 &lt;code&gt;i&lt;/code&gt; 는 가져온 (컴파일 된) MIB 파일을 검색 할 경로를 지정합니다. 디렉토리는 후행 디렉토리 분리 문자가있는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="eae87d7de383250a9c21b21bec8bbf0784d992a8" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;il&lt;/code&gt; (include_lib) also specifies a list of directories to search for imported MIBs. It assumes that the first element in the directory name corresponds to an OTP application. The compiler will find the current installed version. For example, the value [&quot;snmp/mibs/&quot;] will be replaced by [&quot;snmp-3.1.1/mibs/&quot;] (or what the current version may be in the system). The current directory and the &lt;code&gt;&amp;lt;snmp-home&amp;gt;/priv/mibs/&lt;/code&gt; are always listed last in the include path.</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; (include_lib) 옵션 은 가져온 MIB를 검색 할 디렉토리 목록도 지정합니다. 디렉토리 이름의 첫 번째 요소가 OTP 응용 프로그램에 해당한다고 가정합니다. 컴파일러는 현재 설치된 버전을 찾습니다. 예를 들어 [ &quot;snmp / mibs /&quot;] 값은 [ &quot;snmp-3.1.1 / mibs /&quot;] (또는 현재 버전이 시스템에있는 값)으로 바뀝니다. 현재 디렉토리와 &lt;code&gt;&amp;lt;snmp-home&amp;gt;/priv/mibs/&lt;/code&gt; 는 항상 포함 경로의 마지막에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="aecef6269c58a221d8b83cd35b4abe167bc9b4fb" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;imports&lt;/code&gt;, if present, specifies that the IMPORT statement of the MIB shall be included in the compiled mib.</source>
          <target state="translated">&lt;code&gt;imports&lt;/code&gt; 옵션 이있는 경우 MIB의 IMPORT 문이 컴파일 된 mib에 포함되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7d050cf3a9e6eaff748854538bc9531c00c71d49" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module&lt;/code&gt;, if present, specifies the name of a module which implements all instrumentation functions for the MIB.</source>
          <target state="translated">옵션 &lt;code&gt;module&lt;/code&gt; (있는 경우)은 MIB에 대한 모든 계측 기능을 구현하는 모듈의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f2aabaa290b5cad088915be695ef4e5e2d192872" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_compliance&lt;/code&gt;, if present, specifies that the MODULE-COMPLIANCE statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the module-compliance will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="translated">옵션 &lt;code&gt;module_compliance&lt;/code&gt; 는 존재하는 경우 MIB의 MODULE-COMPLIANCE 문이 컴파일 된 mib에 (mib-entry 레코드와 함께) 포함되도록 지정합니다. 모듈 준수의 mib-entry 레코드 에는 &lt;code&gt;assocList&lt;/code&gt; 필드 에이 정보에 대한 &lt;code&gt;reference&lt;/code&gt; 및 &lt;code&gt;module&lt;/code&gt; 부분 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4c88030e67c25f56859a203283edd3aad2cb537" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_identity&lt;/code&gt;, if present, specifies that the info part of the MODULE-IDENTITY statement of the MIB shall be included in the compiled mib.</source>
          <target state="translated">옵션 &lt;code&gt;module_identity&lt;/code&gt; 는 존재하는 경우 MIB의 MODULE-IDENTITY 문의 정보 부분이 컴파일 된 mib에 포함되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b9f802c1128cac15a491e948fd2133dd4c271326" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;no_defs&lt;/code&gt;, if present, specifies that if a managed object does not have an instrumentation function, the default instrumentation function should NOT be used, instead this is reported as an error, and the compilation aborts.</source>
          <target state="translated">&lt;code&gt;no_defs&lt;/code&gt; 옵션 이 있으면 관리 대상 객체에 계측 기능이없는 경우 기본 계측 기능을 사용하지 않아야하며 대신 오류로보고되어 컴파일이 중단되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3534ebdcb42cec6bc4ed923a32d42f384e018c6f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;preferred_algorithms&lt;/code&gt; may be complicated to use for adding or removing single algorithms. First one has to list them with &lt;code&gt;ssh:default_algorithms()&lt;/code&gt; and then do changes in the lists.</source>
          <target state="translated">&lt;code&gt;preferred_algorithms&lt;/code&gt; 옵션 은 단일 알고리즘을 추가하거나 제거하는 데 사용하기가 복잡 할 수 있습니다. 먼저 &lt;code&gt;ssh:default_algorithms()&lt;/code&gt; 나열한 다음 목록에서 변경을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0781dd6b89fb812468ff9fa696eedd3b05b73df" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;reference&lt;/code&gt; specifies if the text of the REFERENCE field, when found in a table definition, will be included or not.</source>
          <target state="translated">옵션 &lt;code&gt;reference&lt;/code&gt; 는 테이블 정의에있는 REFERENCE 필드의 텍스트가 포함되는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9c2f0f1df982a9202e8988ea8ba0887c0ec765a3" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;relaxed_row_name_assign_check&lt;/code&gt;, if present, specifies that the row name assign check shall not be done strictly according to the SMI (which allows only the value 1). With this option, all values greater than zero is allowed (&amp;gt;= 1). This means that the error will be converted to a warning.</source>
          <target state="translated">&lt;code&gt;relaxed_row_name_assign_check&lt;/code&gt; 옵션은 존재하는 경우 행 이름 지정 검사가 SMI (값 1 만 허용)에 따라 엄격하게 수행되지 않도록 지정합니다. 이 옵션을 사용하면 0보다 큰 모든 값이 허용됩니다 (&amp;gt; = 1). 이는 오류가 경고로 변환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="151eec6c2db1b331e575634845f94f69b16d7c18" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;user_dir&lt;/code&gt; defaults to directory &lt;code&gt;users ~/.ssh&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;user_dir&lt;/code&gt; 옵션의 기본값은 디렉토리 &lt;code&gt;users ~/.ssh&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29d7dbac9950684e60e65c932b5345b19e0b54d6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;verbosity&lt;/code&gt; specifies the verbosity of the SNMP mib compiler. I.e. if warning, info, log, debug and trace messages shall be shown.</source>
          <target state="translated">&lt;code&gt;verbosity&lt;/code&gt; 옵션 은 SNMP mib 컴파일러의 상세도를 지정합니다. 즉, 경고, 정보, 로그, 디버그 및 추적 메시지가 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5705298d46062a2bdcc353cd9d9485048e006df9" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings&lt;/code&gt; specifies whether warning messages should be shown.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; 옵션 은 경고 메시지를 표시할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e6ac8043daec14dfce4fd3a09fc4e68dffb195c6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings_as_errors&lt;/code&gt;, if present, specifies whether warnings should be treated as errors.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;warnings_as_errors&lt;/code&gt; 옵션은 경고 를 오류로 취급해야하는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="222e8e711eaedda0de12d881bcddb354da9d562f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;{inline_size,Size}&lt;/code&gt; controls how large functions that are allowed to be inlined. Default is &lt;code&gt;24&lt;/code&gt;, which keeps the size of the inlined code roughly the same as the un-inlined version (only relatively small functions are inlined).</source>
          <target state="translated">&lt;code&gt;{inline_size,Size}&lt;/code&gt; 옵션 은 얼마나 큰 함수를 인라인 할 수 있는지 제어합니다. 기본값은 &lt;code&gt;24&lt;/code&gt; 이며 인라인 코드의 크기를 인라인되지 않은 버전과 거의 동일하게 유지합니다 (상대적으로 작은 함수 만 인라인 됨).</target>
        </trans-unit>
        <trans-unit id="7d5f42ecfc1068f199f3ebaf4be4351cea9cfd06" translate="yes" xml:space="preserve">
          <source>The option &lt;strong&gt;does not&lt;/strong&gt; affect how data is returned from the I/O functions or how it is sent in the I/O protocol, it only affects how the I/O device is to handle Unicode characters to the &quot;physical&quot; device.</source>
          <target state="translated">이 옵션 &lt;strong&gt;은&lt;/strong&gt; I / O 함수에서 데이터를 반환하는 방법이나 I / O 프로토콜에서 데이터를 전송하는 방법 &lt;strong&gt;에는&lt;/strong&gt; 영향을 미치지 &lt;strong&gt;않으며&lt;/strong&gt; I / O 장치가 유니 코드 문자를 &quot;물리적&quot;장치로 처리하는 방법에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="338c829674166b013ae8d81f99bc61cb99452fea" translate="yes" xml:space="preserve">
          <source>The option also triggers port-killing (if driver option &lt;code&gt;kill_ports&lt;/code&gt; is used) although there are pending users, making it usable for forced driver replacement, but laying much responsibility on the driver &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;. The pending option is seldom used as one does not want other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; to have loaded the driver when code change is underway.</source>
          <target state="translated">보류중인 사용자가 &lt;code&gt;kill_ports&lt;/code&gt; 옵션은 포트 강제 종료 (드라이버 옵션 kill_ports 가 사용되는 경우)를 트리거 하여 강제 드라이버 교체에 사용할 수 있지만 드라이버 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 많은 책임이 있습니다. 보류중인 옵션은 코드 변경이 진행 중일 때 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드하기를 원하지 않기 때문에 거의 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f2ca5efd3f45626d14f10b1048bf3a919d5d5db7" translate="yes" xml:space="preserve">
          <source>The option can be given in three different forms as seen above:</source>
          <target state="translated">옵션은 위에서 볼 수 있듯이 세 가지 다른 형태로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c1f8228c64d69ef6b194e7e3a544bd5d6d3471" translate="yes" xml:space="preserve">
          <source>The option can be set by using flag &lt;code&gt;-cover_stop&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, by adding &lt;code&gt;{cover_stop,true|false}&lt;/code&gt; to argument &lt;code&gt;Opts&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, or by adding a &lt;code&gt;cover_stop&lt;/code&gt; term in the test specification (see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results).</source>
          <target state="translated">옵션이 플래그를 사용하여 설정할 수 있습니다 &lt;code&gt;-cover_stop&lt;/code&gt; 와 &lt;code&gt;ct_run&lt;/code&gt; 을 추가하여 &lt;code&gt;{cover_stop,true|false}&lt;/code&gt; 인수에 &lt;code&gt;Opts&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; , 또는 추가하여 &lt;code&gt;cover_stop&lt;/code&gt; 의 테스트 사양에 용어 (섹션 참조 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 섹션 실행에를 테스트 및 분석 결과).</target>
        </trans-unit>
        <trans-unit id="a831925265214b18bff284c9cb5f8da772ac0d22" translate="yes" xml:space="preserve">
          <source>The option cooperates with the daemon-option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; in the following way:</source>
          <target state="translated">이 옵션 은 다음과 같은 방식으로 데몬 옵션 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 과 협력합니다 .</target>
        </trans-unit>
        <trans-unit id="46610d896c3ed60bac06af5aa9b492b0218d289f" translate="yes" xml:space="preserve">
          <source>The option is good for reducing the risk of &quot;slow DoS&quot; attacks.</source>
          <target state="translated">이 옵션은 &quot;느린 DoS&quot;공격의 위험을 줄이는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7b36472af701f82ed3aadc8a7a7a28419165841c" translate="yes" xml:space="preserve">
          <source>The option list can contain the following options:</source>
          <target state="translated">옵션 목록에는 다음 옵션이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbaef9197380d100811d0eacc53dce62a553d255" translate="yes" xml:space="preserve">
          <source>The option list given in the &lt;code&gt;&lt;a href=&quot;ssh#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; option is available with the key &lt;code&gt;key_cb_private&lt;/code&gt;.</source>
          <target state="translated">에 주어진 옵션 목록 &lt;code&gt;&lt;a href=&quot;ssh#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션은 키를 사용할 수 있습니다 &lt;code&gt;key_cb_private&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df3c954b5ba9c1474ae29416fce03f6aaa090802" translate="yes" xml:space="preserve">
          <source>The option takes a list with instructions to append, prepend or remove algorithms:</source>
          <target state="translated">이 옵션은 알고리즘을 추가, 추가 또는 제거하기위한 지침이 포함 된 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2eb6213b7b87f0b7e6e4d25afe9e32cc806c629" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Category&lt;/code&gt; argument can be used to categorize the log printout. Categories can be used for two things as follows:</source>
          <target state="translated">선택적인 &lt;code&gt;Category&lt;/code&gt; 인수를 사용하여 로그 출력을 분류 할 수 있습니다. 카테고리는 다음과 같이 두 가지 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="447f5a3f76e3e9563c9b86d4ea43d4333c4ebffe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Descr&lt;/code&gt; parameter is included &quot;as is&quot; in the &lt;code&gt;relup&lt;/code&gt; file, see &lt;code&gt;&lt;a href=&quot;relup&quot;&gt;relup(4)&lt;/a&gt;&lt;/code&gt;. Defaults to the empty list.</source>
          <target state="translated">선택적 &lt;code&gt;Descr&lt;/code&gt; 매개 변수는 &lt;code&gt;relup&lt;/code&gt; 파일에 &quot;있는 그대로&quot;포함되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;relup&quot;&gt;relup(4)&lt;/a&gt;&lt;/code&gt; 참조 ) . 빈 목록이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5f923e9b577173731c7b96e064927ce55ee5384c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Timeout&lt;/code&gt; parameter specifies a time-out in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;Timeout&lt;/code&gt; 매개 변수는 시간 제한 ( 밀리 초)을 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52335a394cf2ecea7217c7a04e3f8442f2097418" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;expect&lt;/code&gt; declaration can be placed anywhere before the last optional section with Erlang code. It is used for suppressing the warning about conflicts that is ordinarily given if the grammar is ambiguous. An example:</source>
          <target state="translated">선택적 &lt;code&gt;expect&lt;/code&gt; 선언은 Erlang 코드를 사용하여 마지막 선택적 섹션 앞에 위치 할 수 있습니다. 문법이 모호한 경우 일반적으로 발생하는 충돌에 대한 경고를 억제하는 데 사용됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="161604dc3e7d1bc8b928595e85930b898a263976" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; can be used to define a function that is called in the following cases:</source>
          <target state="translated">선택적 인수 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 를 사용하여 다음과 같은 경우에 호출되는 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de6e1bc58d56088e6eddee453ec6c1aeb739d3a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;Varbinds&lt;/code&gt; defines values for the objects in the notification. If no value is given for an object, the &lt;code&gt;Agent&lt;/code&gt; performs a get-operation to retrieve the value.</source>
          <target state="translated">선택적 인수 &lt;code&gt;Varbinds&lt;/code&gt; 는 알림의 개체 값을 정의합니다. 개체에 값이 제공되지 않으면 &lt;code&gt;Agent&lt;/code&gt; 는 get-operation을 수행하여 값을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d9e24b2c05b3f59535f6993ef411d13d031da358" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;'author'&lt;/code&gt; and &lt;code&gt;'version'&lt;/code&gt; are only used with &lt;code&gt;'windows'&lt;/code&gt; option mode.</source>
          <target state="translated">옵션 &lt;code&gt;'author'&lt;/code&gt; 와 &lt;code&gt;'version'&lt;/code&gt; 에서만 사용되는 &lt;code&gt;'windows'&lt;/code&gt; 옵션 모드.</target>
        </trans-unit>
        <trans-unit id="d6e6ee87f0886860f355c1e2932aa71133b1ec67" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;cpu_time&lt;/code&gt; or &lt;code&gt;{cpu_time, true}&lt;/code&gt; makes the timestamps in the trace be in CPU time instead of wallclock time which is the default. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;cpu_time&lt;/code&gt; 또는 &lt;code&gt;{cpu_time, true}&lt;/code&gt; 옵션 은 추적의 시간 소인을 기본값 인 벽시계 시간 대신 CPU 시간으로 만듭니다. 이 옵션은 &lt;code&gt;start&lt;/code&gt; 옵션 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a575a8485a0e80fe603347e1de8782c8007d6e61" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; are mutually exclusive, and &lt;code&gt;global&lt;/code&gt; is the default (if no options are specified). The options &lt;code&gt;call_count&lt;/code&gt; and &lt;code&gt;meta&lt;/code&gt; perform a kind of local tracing, and cannot be combined with &lt;code&gt;global&lt;/code&gt;. A function can be globally or locally traced. If global tracing is specified for a set of functions, then local, meta, call time, and call count tracing for the matching set of local functions is disabled, and conversely.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 옵션 은 상호 배타적이며 &lt;code&gt;global&lt;/code&gt; 이 기본값입니다 (옵션이 지정되지 않은 경우). &lt;code&gt;call_count&lt;/code&gt; 및 &lt;code&gt;meta&lt;/code&gt; 옵션 은 일종의 로컬 추적을 수행하며 &lt;code&gt;global&lt;/code&gt; 과 결합 할 수 없습니다 . 함수는 전체적으로 또는 로컬로 추적 될 수 있습니다. 함수 세트에 글로벌 추적이 지정된 경우, 일치하는 로컬 함수 세트에 대한 로컬, 메타, 호출 시간 및 호출 횟수 추적이 사용 불가능하게됩니다.</target>
        </trans-unit>
        <trans-unit id="532c3466b01dbba024ee7d7263923dee4eb39f70" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;{verbose, true}&lt;/code&gt; adds some trace flags that &lt;code&gt;fprof&lt;/code&gt; does not need, but that may be interesting for general debugging purposes. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; 또는 &lt;code&gt;{verbose, true}&lt;/code&gt; 옵션 은 &lt;code&gt;fprof&lt;/code&gt; 가 필요하지 않은 추적 플래그를 추가 하지만 일반적인 디버깅 목적에는 흥미로울 수 있습니다. 이 옵션은 &lt;code&gt;start&lt;/code&gt; 옵션 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="42859c21f2b79ff6b36fc89627196cf7c13e3b9e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;{nowarn_unused_function, FAs}&lt;/code&gt;, &lt;code&gt;{nowarn_bif_clash, FAs}&lt;/code&gt;, and &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; are only recognized when given in files. They are not affected by options &lt;code&gt;warn_unused_function&lt;/code&gt;, &lt;code&gt;warn_bif_clash&lt;/code&gt;, or &lt;code&gt;warn_deprecated_function&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{nowarn_unused_function, FAs}&lt;/code&gt; , &lt;code&gt;{nowarn_bif_clash, FAs}&lt;/code&gt; 과 &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; 파일에 주어진 경우에만 인식됩니다. 옵션 &lt;code&gt;warn_unused_function&lt;/code&gt; , &lt;code&gt;warn_bif_clash&lt;/code&gt; 또는 &lt;code&gt;warn_deprecated_function&lt;/code&gt; 의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="52fb8838009488073df993b32117ab4a617e4e27" translate="yes" xml:space="preserve">
          <source>The options above can be used both in clients and in daemons (servers). They are further explained below.</source>
          <target state="translated">위의 옵션은 클라이언트와 데몬 (서버) 모두에서 사용할 수 있습니다. 그것들은 아래에 더 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9822c92221a3f35f766011a9109d3678a91584e" translate="yes" xml:space="preserve">
          <source>The options and values supported by the OTP I/O devices are as follows:</source>
          <target state="translated">OTP I / O 장치가 지원하는 옵션 및 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="966a458ac5f5553b2b1772cc14d9f0802ad711ce" translate="yes" xml:space="preserve">
          <source>The options are &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;. The first one replaces the default set, while the latter modifies the default set.</source>
          <target state="translated">옵션은 &lt;code&gt;preferred_algorithms&lt;/code&gt; 및 &lt;code&gt;modify_algorithms&lt;/code&gt; 입니다. 첫 번째는 기본 세트를 대체하고 후자는 기본 세트를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0993030c5ac4d368f471285e301a74deb9b525f8" translate="yes" xml:space="preserve">
          <source>The options defaults to existing, write and keep.</source>
          <target state="translated">옵션은 기존, 쓰기 및 유지로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a90ed84ac6c9da62366fd72993b92a3d6548993" translate="yes" xml:space="preserve">
          <source>The options for the tracee:</source>
          <target state="translated">피 추적자 옵션 :</target>
        </trans-unit>
        <trans-unit id="d0d619e9e8a7b4ef0ea604d389b298331dfe1155" translate="yes" xml:space="preserve">
          <source>The options in &lt;code&gt;OptionList&lt;/code&gt; modify the defaults as follows:</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 의 옵션은 다음과 같이 기본값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3cdec8fc084975065672d9bc75d5f2d7a5819ddb" translate="yes" xml:space="preserve">
          <source>The options in the &lt;code&gt;{server, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:ssl_accept/3&lt;/code&gt;, and the options in the &lt;code&gt;{client, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:connect/4&lt;/code&gt;.</source>
          <target state="translated">의 옵션 &lt;code&gt;{server, Opts}&lt;/code&gt; 호출 할 때 튜플이 사용됩니다 &lt;code&gt;ssl:ssl_accept/3&lt;/code&gt; , 그리고의 옵션 &lt;code&gt;{client, Opts}&lt;/code&gt; 호출 할 때 튜플 사용되는 &lt;code&gt;ssl:connect/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b32dbf5a7282fb93990ccd87cc73489c02dc49" translate="yes" xml:space="preserve">
          <source>The order in which a SetFun is applied to the elements of an unordered set is not specified, and can change in future versions of this module.</source>
          <target state="translated">순서가 지정되지 않은 세트의 요소에 SetFun이 적용되는 순서는 지정되지 않으며이 모듈의 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36c81c4641ae489656e683b39af63a52c09b9a1" translate="yes" xml:space="preserve">
          <source>The order in which keys are declared in matching has no relevance.</source>
          <target state="translated">키가 일치하도록 선언 된 순서는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba864cd36b5d9fc0734824a2d89b5010877afe23" translate="yes" xml:space="preserve">
          <source>The order in which test cases in a group are executed is under normal circumstances the same as the order specified in the test case list in the group definition. With property &lt;code&gt;shuffle&lt;/code&gt; set, however, &lt;code&gt;Common Test&lt;/code&gt; instead executes the test cases in random order.</source>
          <target state="translated">그룹의 테스트 케이스가 실행되는 순서는 정상적인 상황에서 그룹 정의의 테스트 케이스 목록에 지정된 순서와 동일합니다. 그러나 속성 &lt;code&gt;shuffle&lt;/code&gt; 설정 하면 &lt;code&gt;Common Test&lt;/code&gt; 가 대신 테스트 케이스를 무작위 순서로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9181dd756bf0c244588172ca0c10840e8c09e01c" translate="yes" xml:space="preserve">
          <source>The order in which the expressions constructing the keys (and their associated values) are evaluated is not defined. The syntactic order of the key-value pairs in the construction is of no relevance, except in the recently mentioned case of two matching keys.</source>
          <target state="translated">키를 구성하는 표현식 (및 관련 값)이 평가되는 순서는 정의되지 않습니다. 구성에서 키-값 쌍의 구문 순서는 최근에 언급 한 두 개의 일치하는 키를 제외하고는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b2e651aff4100a2544284cdd623666e00826d4f" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; is only valid for &lt;code&gt;ordered_set&lt;/code&gt; tables, they are synonyms for other tables. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; / &lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; / &lt;code&gt;prev&lt;/code&gt; 의 순서는 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 에만 유효 하며 다른 테이블과 동의어입니다. 테이블 끝에 도달하면 특수 키 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="25f2ba6ee8246f16a08bc23339d4a331af938338" translate="yes" xml:space="preserve">
          <source>The order of AVPs in an encoded message is determined by the CCF of the message in question.</source>
          <target state="translated">인코딩 된 메시지에서 AVP의 순서는 해당 메시지의 CCF에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="fca0f7684c3b5a228fba4c8df60980c0fb7304b8" translate="yes" xml:space="preserve">
          <source>The order of the &lt;code&gt;InfoTuple&lt;/code&gt;s is undefined and all &lt;code&gt;InfoTuple&lt;/code&gt;s are not mandatory. The &lt;code&gt;InfoTuple&lt;/code&gt;s part of the result can be changed without prior notice.</source>
          <target state="translated">&lt;code&gt;InfoTuple&lt;/code&gt; 의 순서 는 정의되어 있지 않으며 모든 &lt;code&gt;InfoTuple&lt;/code&gt; 은 필수가 아닙니다. 결과 의 &lt;code&gt;InfoTuple&lt;/code&gt; 부분은 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a424f07125a5351756bef9206873c14f5a6353a0" translate="yes" xml:space="preserve">
          <source>The order of the identifier types implies the hierarchy of the CPU topology. The valid orders are as follows:</source>
          <target state="translated">식별자 유형의 순서는 CPU 토폴로지의 계층 구조를 의미합니다. 유효한 주문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ef0543efe4d20b5865e3801acad36673d50a7e1" translate="yes" xml:space="preserve">
          <source>The order of the instructions is important.</source>
          <target state="translated">지침의 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="40a9e5e0989674c7605430c6223ced2839090722" translate="yes" xml:space="preserve">
          <source>The order within an request is undefined and variables are not processed in a defined order. Do not assume that the first variable in the PDU will be processed before the second, even if the agent processes variables in this order. It cannot even be assumed that requests belonging to different sub-agents have any order.</source>
          <target state="translated">요청 내의 순서는 정의되어 있지 않으며 변수는 정의 된 순서로 처리되지 않습니다. 에이전트가이 순서대로 변수를 처리하더라도 PDU의 첫 번째 변수가 두 번째 변수보다 먼저 처리된다고 가정하지 마십시오. 다른 서브 에이전트에 속하는 요청에는 순서가 있다고 가정 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d9c8867ac57c93dfa1e9dd7ececb7cee20d1616" translate="yes" xml:space="preserve">
          <source>The ordinal for the current wrap log file in the range &lt;code&gt;1..MaxNoFiles&lt;/code&gt;, where &lt;code&gt;MaxNoFiles&lt;/code&gt; is specified by the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;size&lt;/code&gt; or set by &lt;code&gt;change_size/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1..MaxNoFiles&lt;/code&gt; 범위의 현재 랩 로그 파일 서수입니다. 여기서 &lt;code&gt;MaxNoFiles&lt;/code&gt; 는 &lt;code&gt;open/1&lt;/code&gt; 옵션 &lt;code&gt;size&lt;/code&gt; 되거나 &lt;code&gt;change_size/2&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6550278cb65a35db070f10d5936d5bb981ed919" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; record used in the failed &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">실패한 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*.&lt;/a&gt;&lt;/code&gt; 사용 된 원래 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 레코드 .</target>
        </trans-unit>
        <trans-unit id="970df94b5a2d0508f33375517efeb60800ec3879" translate="yes" xml:space="preserve">
          <source>The original I/O protocol was simple and flexible. Demands for memory efficiency and execution time efficiency have triggered extensions to the protocol over the years, making the protocol larger and somewhat less easy to implement than the original. It can certainly be argued that the current protocol is too complex, but this section describes how it looks today, not how it should have looked.</source>
          <target state="translated">원래 I / O 프로토콜은 간단하고 유연했습니다. 메모리 효율성 및 실행 시간 효율성에 대한 요구로 인해 수년에 걸쳐 프로토콜 확장이 시작되어 프로토콜이 원래보다 더 크고 구현하기가 쉽지 않습니다. 현재의 프로토콜이 너무 복잡하다고 주장 할 수도 있지만,이 섹션에서는 현재의 프로토콜이 어떻게 보일지가 아니라 현재의 모습을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0f3737702a282f6801504751b80a23982a8e7770" translate="yes" xml:space="preserve">
          <source>The original balance condition &lt;strong&gt;h(T) &amp;lt;= ceil(c * log(|T|))&lt;/strong&gt; has been changed to the similar (but not quite equivalent) condition &lt;strong&gt;2 ^ h(T) &amp;lt;= |T| ^ c&lt;/strong&gt;. This should also be OK.</source>
          <target state="translated">원래 잔액 조건 &lt;strong&gt;h (T) &amp;lt;= ceil (c * log (| T |))&lt;/strong&gt; 가 유사한 (그러나 동일하지는 않음) 조건 &lt;strong&gt;2 ^ h (T) &amp;lt;= | T |로 변경되었습니다. ^ c&lt;/strong&gt; . 이것도 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="7c191efd6920f25c3ba576f5b703e200e55bf2d5" translate="yes" xml:space="preserve">
          <source>The original implementation is mostly done by Scott Lystiger Fritchie as an Open Source Contribution and it should be viewed as such even though the source for dynamic tracing as well as this module is included in the main distribution. However, the ability to use dynamic tracing of the virtual machine is a very valuable contribution which OTP has every intention to maintain as a tool for the developer.</source>
          <target state="translated">원래 구현은 대부분 Scott Lystiger Fritchie가 공개 소스 기고로 수행하며이 모듈뿐만 아니라 동적 추적 소스도 기본 배포에 포함되어있는 것처럼 간주해야합니다. 그러나 가상 머신의 동적 추적을 사용하는 기능은 OTP가 개발자를위한 도구로 유지하려는 모든 의도에 매우 중요한 기여입니다.</target>
        </trans-unit>
        <trans-unit id="1fb9c163b9ae8bc176015b798d7f0fe518b0cc1e" translate="yes" xml:space="preserve">
          <source>The original problem was to parse the grammar &lt;code&gt;(a | b) &amp;amp; (c | d)&lt;/code&gt;. The following code addresses this problem:</source>
          <target state="translated">원래 문제는 문법 &lt;code&gt;(a | b) &amp;amp; (c | d)&lt;/code&gt; 를 구문 분석하는 것이 었습니다 . 다음 코드는이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="fd881abf9ded0ff52d6c0c5cc6411dc02ab57f19" translate="yes" xml:space="preserve">
          <source>The originating module for a log event is only detected if the key &lt;code&gt;mfa&lt;/code&gt; exists in the metadata, and is associated with &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;. When log macros are used, this association is automatically added to all log events. If an API function is called directly, without using a macro, the logging client must explicitly add this information if module levels shall have any effect.</source>
          <target state="translated">로그 이벤트의 시작 모듈은 키 &lt;code&gt;mfa&lt;/code&gt; 가 메타 데이터에 존재하고 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 와 연관된 경우에만 감지됩니다 . 로그 매크로를 사용하면이 연관이 모든 로그 이벤트에 자동으로 추가됩니다. 매크로를 사용하지 않고 API 함수를 직접 호출하는 경우 모듈 레벨에 영향을 줄 경우 로깅 클라이언트는이 정보를 명시 적으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a90fb6c08256a161c6eb483a2634b3ee24142c2" translate="yes" xml:space="preserve">
          <source>The originating user will wait for a reply or a timeout (defined by the request_timer). When it receives the reply this will optionally be acknowledged (regulated by auto_ack), and forwarded to the user. If an interim pending reply is received, the long_request_timer will be used instead of the usual request_timer, in order to enable avoidance of spurious re-sends of the request.</source>
          <target state="translated">원래 사용자는 응답 또는 시간 종료를 기다립니다 (request_timer에 의해 정의 됨). 응답을 수신하면 선택적으로 승인 (auto_ack에 의해 규제 됨)되어 사용자에게 전달됩니다. 임시 보류 응답이 수신되면 요청의 허위 재전송을 피하기 위해 일반적인 request_timer 대신 long_request_timer가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e92f5e32fcae91a4c9f4be9a317837d1de0ba2b" translate="yes" xml:space="preserve">
          <source>The other POSIX classes are unchanged, and match only characters with code points less than 128.</source>
          <target state="translated">다른 POSIX 클래스는 변경되지 않으며 코드 포인트가 128 미만인 문자 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a1b939845b7eda3d69e2e492e608d1e0b328d6c2" translate="yes" xml:space="preserve">
          <source>The other backtracking verbs are not treated specially if they appear in a positive assertion. In particular, (*THEN) skips to the next alternative in the innermost enclosing group that has alternations, regardless if this is within the assertion.</source>
          <target state="translated">다른 역 추적 동사는 긍정적 인 주장으로 나타나면 특별히 취급되지 않습니다. 특히, (* THEN)은 이것이 어설 션 내에 있는지 여부에 관계없이 교대가있는 가장 안쪽의 묶음 그룹에서 다음 대안으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="500a74c2c6e51cd76905327b832ede2fe0521759" translate="yes" xml:space="preserve">
          <source>The other callback functions of &lt;code&gt;ch3&lt;/code&gt; must also be modified and perhaps a new interface function must be added, but this is not shown here.</source>
          <target state="translated">&lt;code&gt;ch3&lt;/code&gt; 의 다른 콜백 함수 도 수정해야하며 새로운 인터페이스 함수를 추가해야하지만 여기에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1666602d3dd9e1b07910e384ad36de2d7fa0e9b" translate="yes" xml:space="preserve">
          <source>The other keys are ignored by &lt;code&gt;systools&lt;/code&gt;.</source>
          <target state="translated">다른 키는 &lt;code&gt;systools&lt;/code&gt; 에 의해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff87693daa403b15e56f02488339c0b3e4fa0a09" translate="yes" xml:space="preserve">
          <source>The other time stamps look as follows:</source>
          <target state="translated">다른 타임 스탬프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d61abb80ef251301a72eea2a6b5eddae542b20ef" translate="yes" xml:space="preserve">
          <source>The output file &lt;code&gt;OutFile&lt;/code&gt; defaults to &lt;code&gt;Module.COVER.out&lt;/code&gt;, or &lt;code&gt;Module.COVER.html&lt;/code&gt; if the option &lt;code&gt;html&lt;/code&gt; was used.</source>
          <target state="translated">출력 파일 &lt;code&gt;OutFile&lt;/code&gt; 기본값 &lt;code&gt;Module.COVER.out&lt;/code&gt; 는 , 또는 &lt;code&gt;Module.COVER.html&lt;/code&gt; 옵션의 경우 &lt;code&gt;html&lt;/code&gt; 사용했다.</target>
        </trans-unit>
        <trans-unit id="58ca31dbd1427ec5eab0714fa958680db4f60d0e" translate="yes" xml:space="preserve">
          <source>The output file contains Erlang source code for a parser module with module name equal to the &lt;code&gt;Parserfile&lt;/code&gt; parameter. After compilation, the parser can be called as follows (the module name is assumed to be &lt;code&gt;myparser&lt;/code&gt;):</source>
          <target state="translated">출력 파일에는 모듈 이름이 &lt;code&gt;Parserfile&lt;/code&gt; 매개 변수 와 동일한 구문 분석기 모듈에 대한 Erlang 소스 코드가 포함되어 있습니다 . 컴파일 후 파서는 다음과 같이 호출 될 수 있습니다 (모듈 이름은 &lt;code&gt;myparser&lt;/code&gt; 로 가정 ).</target>
        </trans-unit>
        <trans-unit id="950bb6bb3590d1b255219966cda8abbac6d08f2f" translate="yes" xml:space="preserve">
          <source>The output files in this case get their names from the configuration file. If the configuration file is named &lt;code&gt;SetOfFiles.set.asn&lt;/code&gt;, the names of the output files are &lt;code&gt;SetOfFiles.hrl, SetOfFiles.erl, and SetOfFiles.asn1db&lt;/code&gt;.</source>
          <target state="translated">이 경우 출력 파일은 구성 파일에서 이름을 가져옵니다. 구성 파일 이름이 &lt;code&gt;SetOfFiles.set.asn&lt;/code&gt; 인 경우 출력 파일 이름은 &lt;code&gt;SetOfFiles.hrl, SetOfFiles.erl, and SetOfFiles.asn1db&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bb85e310428587626e30c116127a2422cb890a6" translate="yes" xml:space="preserve">
          <source>The output format is the same for all log events.</source>
          <target state="translated">출력 형식은 모든 로그 이벤트에 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5ed44c5ce1be01aac830a9b9d364b5bda8cb5f89" translate="yes" xml:space="preserve">
          <source>The output from Erlang Top is as follows:</source>
          <target state="translated">Erlang Top의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4375455178eca4e09ac1ea27af2822d564dd76b8" translate="yes" xml:space="preserve">
          <source>The output is a new file which is called &lt;code&gt;&amp;lt;mibname&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="translated">출력은 &lt;code&gt;&amp;lt;mibname&amp;gt;.bin&lt;/code&gt; 이라는 새 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="cf16c507f23262a645872ad8bd5824124e5cfbee" translate="yes" xml:space="preserve">
          <source>The output is not to a file, but instead as a tuple &lt;code&gt;{FileName, binary()}&lt;/code&gt;. The binary is a full zip archive with header and can be extracted with, for example, &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">출력은 파일이 아니라 튜플 &lt;code&gt;{FileName, binary()}&lt;/code&gt; 됩니다. 바이너리는 헤더가 포함 된 전체 Zip 아카이브이며 예를 들어 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 로 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8d74c93a5b988198b9814a0f75a0ef9857da6e1" translate="yes" xml:space="preserve">
          <source>The output mechanisms are similar to the input. The &lt;code&gt;do_send&lt;/code&gt; routine is as follows:</source>
          <target state="translated">출력 메커니즘은 입력과 유사합니다. &lt;code&gt;do_send&lt;/code&gt; 의 다음과 같은 루틴은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="3eeb56a012bbd124b84f163ce270cf01c80c63bc" translate="yes" xml:space="preserve">
          <source>The output of the Erlang shell is discarded.</source>
          <target state="translated">Erlang 쉘의 출력이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c10e1f5cf0633868a0d6acdff9b23bdac7f561" translate="yes" xml:space="preserve">
          <source>The output produced by this function is a directory structure with the following structure:</source>
          <target state="translated">이 함수에 의해 생성 된 출력은 다음 구조의 디렉토리 구조입니다.</target>
        </trans-unit>
        <trans-unit id="674403e3c388ef76a5e40cb3d72afaed1e950c87" translate="yes" xml:space="preserve">
          <source>The overall format of the term format is as follows:</source>
          <target state="translated">용어 형식의 전체 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38835811defd1f6c34454d9d8396ca9e3e5af5d1" translate="yes" xml:space="preserve">
          <source>The overall size of data generated by &lt;code&gt;ttb&lt;/code&gt; can be greater than the wrap specification suggests. If a traced node restarts and autoresume is enabled, the old wrap log is always stored and a new one is created.</source>
          <target state="translated">&lt;code&gt;ttb&lt;/code&gt; 에 의해 생성 된 데이터의 전체 크기 는 랩 스펙이 제안한 것보다 클 수 있습니다. 추적 된 노드가 다시 시작되고 자동 재개가 사용 가능한 경우 이전 랩 로그가 항상 저장되고 새 랩 로그가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="61cb6b8dd505955f977238c607e61cb7a82df0c8" translate="yes" xml:space="preserve">
          <source>The overall structure is shown in the following figure:</source>
          <target state="translated">전체 구조는 다음 그림에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d3d3de02c6a33e51e88647ce88261f5af1cf9c" translate="yes" xml:space="preserve">
          <source>The owner process can read and write to the table. Other processes can only read the table. This is the default setting for the access rights.</source>
          <target state="translated">소유자 프로세스는 테이블을 읽고 쓸 수 있습니다. 다른 프로세스는 테이블을 읽을 수만 있습니다. 액세스 권한의 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="089e146f1ffd790b907f38b914bb227184826d25" translate="yes" xml:space="preserve">
          <source>The palindrome-matching patterns above work only if the subject string does not start with a palindrome that is shorter than the entire string. For example, although &quot;abcba&quot; is correctly matched, if the subject is &quot;ababa&quot;, PCRE finds palindrome &quot;aba&quot; at the start, and then fails at top level, as the end of the string does not follow. Once again, it cannot jump back into the recursion to try other alternatives, so the entire match fails.</source>
          <target state="translated">위의 회문 일치 패턴은 주제 문자열이 전체 현보다 짧은 회문으로 시작하지 않는 경우에만 작동합니다. 예를 들어, &quot;abcba&quot;가 올바르게 일치하더라도 주제가 &quot;ababa&quot;인 경우 PCRE는 시작시 회문 &quot;aba&quot;를 찾은 다음 문자열의 끝이 따르지 않으므로 최상위 레벨에서 실패합니다. 다시 한번, 다른 대안을 시도하기 위해 재귀로 돌아갈 수 없으므로 전체 경기가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="16b533f17b54668ffb1295b9bb8d4f9eb100b70f" translate="yes" xml:space="preserve">
          <source>The paragraphs are per default sorted in decreasing order of the ACC column for the marked function. The calling list and called list within one paragraph are also per default sorted in decreasing order of their ACC column.</source>
          <target state="translated">단락은 기본적으로 표시된 기능에 대해 ACC 열의 내림차순으로 정렬됩니다. 한 단락 내의 호출 목록과 호출 목록도 기본적으로 ACC 열의 내림차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d4d2b62e1143e2dd17a07c3bb206ef9be5f7b2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Echo&lt;/code&gt; guides the client about need to hide the password.</source>
          <target state="translated">&lt;code&gt;Echo&lt;/code&gt; 매개 변수 는 클라이언트에게 비밀번호를 숨길 필요가 있음을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="5cfbf68425808c36b1647fe7633ef469ae247239" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the managers. &lt;code&gt;Receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">&lt;code&gt;Receiver&lt;/code&gt; 매개 변수 는 Inform-Requests 배달에 대한 정보를 보낼 위치를 지정합니다. 에이전트는 Inform-Requests를 전송하고 관리자의 승인을 기다립니다. &lt;code&gt;Receiver&lt;/code&gt; 는 세 가지 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93a8824964c3c68da73bbc8d10931f15f14a1ad" translate="yes" xml:space="preserve">
          <source>The parameter is ignored on platforms that are known to not be posix compatible (Windows and SunOS).</source>
          <target state="translated">posix와 호환되지 않는 플랫폼 (Windows 및 SunOS)에서는이 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e3af558ccfd68eba22bfa2a8b643ad678f8a28" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;accumulate&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt; can be changed during runtime with function &lt;code&gt;&lt;a href=&quot;etop#config-2&quot;&gt;etop:config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;etop#config-2&quot;&gt;etop:config/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 런타임 동안 매개 변수 &lt;code&gt;lines&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;accumulate&lt;/code&gt; 및 &lt;code&gt;sort&lt;/code&gt; 을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8e6a51df5790dddef932d3398c6395529808020" translate="yes" xml:space="preserve">
          <source>The parameters are as described in &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, except the &lt;code&gt;Timeout&lt;/code&gt; value.</source>
          <target state="translated">매개 변수는 &lt;code&gt;Timeout&lt;/code&gt; 값을 제외하고 &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ce98213439a608e155e2aca750dfccce5c0b98e" translate="yes" xml:space="preserve">
          <source>The parameters of this function cannot be properly checked by the runtime system when executed by arbitrary threads. This can cause the function not to fail when it should.</source>
          <target state="translated">이 함수의 매개 변수는 임의의 스레드에서 실행될 때 런타임 시스템에서 올바르게 확인할 수 없습니다. 이로 인해 기능이 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec665272ce04d7ab2f0ef6b068d9c3325cbd4bf" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; are the same as to &lt;code&gt;&lt;a href=&quot;#report_event&quot;&gt;et_collector:report_event/6&lt;/a&gt;&lt;/code&gt; in the previous chapter. The big difference between the two is in the semantics of the two functions. The second actually reports an &lt;code&gt;Event&lt;/code&gt; to the &lt;code&gt;Collector&lt;/code&gt; while the first does nothing, it just returns the atom &lt;code&gt;hopefully_traced&lt;/code&gt;. In order to make the parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; turn up in the &lt;code&gt;Collector&lt;/code&gt;, tracing of that function must be activated and the &lt;code&gt;Collector&lt;/code&gt; must be registered as a &lt;code&gt;Tracer&lt;/code&gt; of the &lt;code&gt;Raw Trace Data&lt;/code&gt;.</source>
          <target state="translated">행 파라미터 &lt;code&gt;et:trace_me/5&lt;/code&gt; 로 동일하다 &lt;code&gt;&lt;a href=&quot;#report_event&quot;&gt;et_collector:report_event/6&lt;/a&gt;&lt;/code&gt; 이전 장이다. 둘 사이의 큰 차이점은 두 기능의 의미에 있습니다. 두 번째는 실제로 &lt;code&gt;Event&lt;/code&gt; 를 &lt;code&gt;Collector&lt;/code&gt; 보고하는 반면 첫 번째는 아무 것도 수행하지 않고 원자 만 &lt;code&gt;hopefully_traced&lt;/code&gt; 를 반환합니다 . 행 파라미터하기 위해서는 &lt;code&gt;et:trace_me/5&lt;/code&gt; 차례로 최대 &lt;code&gt;Collector&lt;/code&gt; 그 추적 기능은 활성화되어야하며 &lt;code&gt;Collector&lt;/code&gt; A와 등록해야 &lt;code&gt;Tracer&lt;/code&gt; 의 &lt;code&gt;Raw Trace Data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6476df9bd7becd5f1615533b733c1dab82d38f7" translate="yes" xml:space="preserve">
          <source>The parent of the process, that is, the process that executed &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt;.</source>
          <target state="translated">인 프로세스의 부모, 실행하는 프로세스 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;spawn_link&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0ee187ad5dff135b81bffe6ade6896261862f011" translate="yes" xml:space="preserve">
          <source>The parse result will be:</source>
          <target state="translated">파싱 ​​결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="908e2b3e43d5891b77738e237f36e159be4612ea" translate="yes" xml:space="preserve">
          <source>The parse transform is implemented in the module &lt;code&gt;ms_transform&lt;/code&gt; and the source &lt;strong&gt;must&lt;/strong&gt; include the file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source will result in a runtime error, not a compile time ditto. The include file is easiest included by adding the line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="translated">구문 분석 변환은 &lt;code&gt;ms_transform&lt;/code&gt; 모듈에서 구현되며 소스 &lt;strong&gt;는&lt;/strong&gt; 이 의사 함수가 작동하도록 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 에 ms_transform.hrl 파일을 포함 &lt;strong&gt;해야합니다&lt;/strong&gt; . 소스에 hrl 파일을 포함시키지 않으면 컴파일 시간이 아니라 런타임 오류가 발생합니다. 포함 파일은 &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; 행을 추가하여 가장 쉽게 포함됩니다 . 소스 파일에.</target>
        </trans-unit>
        <trans-unit id="9a0fcc18541768fed9656f58cddeaa15df804db5" translate="yes" xml:space="preserve">
          <source>The parse transform is provided in the &lt;code&gt;ms_transform&lt;/code&gt; module and the source &lt;strong&gt;must&lt;/strong&gt; include file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source results in a runtime error, not a compile time error. The include file is easiest included by adding line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="translated">구문 분석 변환은 &lt;code&gt;ms_transform&lt;/code&gt; 모듈에 제공되며 소스 &lt;strong&gt;는&lt;/strong&gt; 이 의사 함수가 작동하도록 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 에 ms_transform.hrl 파일을 포함 &lt;strong&gt;해야합니다&lt;/strong&gt; . 소스에 hrl 파일을 포함시키지 않으면 컴파일 시간 오류가 아니라 런타임 오류가 발생합니다. 포함 파일은 &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; 를 추가하여 가장 쉽게 포함됩니다 . 소스 파일에.</target>
        </trans-unit>
        <trans-unit id="fa633312a20d20d1705e931b8f39b80fb7e1696b" translate="yes" xml:space="preserve">
          <source>The parser can be tested as follows:</source>
          <target state="translated">파서는 다음과 같이 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d631ad0e789906de6a0dbe0f9ecc3c2c43edfa6d" translate="yes" xml:space="preserve">
          <source>The parsing failed.</source>
          <target state="translated">파싱에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="c723b00d013bcc979e9e3335bbd7a9da3fabcff7" translate="yes" xml:space="preserve">
          <source>The parsing was successful.</source>
          <target state="translated">파싱이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="a49afee373329c5d676f06380eda3a2c7220be60" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;AbsForm&lt;/code&gt; is the abstract form of the parsed form.</source>
          <target state="translated">파싱이 성공했습니다. &lt;code&gt;AbsForm&lt;/code&gt; 은 구문 분석 된 양식의 추상 양식입니다.</target>
        </trans-unit>
        <trans-unit id="eb6f7d761bbc4ec8ae3eb1becad08674a67adfed" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;ExprList&lt;/code&gt; is a list of the abstract forms of the parsed expressions.</source>
          <target state="translated">파싱이 성공했습니다. &lt;code&gt;ExprList&lt;/code&gt; 는 구문 분석 된 표현식의 추상 형식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="92efbe38030d8e57be00bf5943de97bce61a93f6" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;Term&lt;/code&gt; is the Erlang term corresponding to the token list.</source>
          <target state="translated">파싱이 성공했습니다. &lt;code&gt;Term&lt;/code&gt; 는 토큰 목록에 해당하는 얼랭 용어입니다.</target>
        </trans-unit>
        <trans-unit id="dd9391eec0e6a1677450d11b0522f2da3f205730" translate="yes" xml:space="preserve">
          <source>The parts of &lt;code&gt;Pattern&lt;/code&gt; found in &lt;code&gt;Subject&lt;/code&gt; are not included in the result.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 에서 찾은 &lt;code&gt;Pattern&lt;/code&gt; 부분은 결과에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b76c5acf9e48a823e1ce8da1feab2e91ccd0b05" translate="yes" xml:space="preserve">
          <source>The patched applications are appended to the list of installed applications. Take a look at &lt;code&gt;&amp;lt;InstallDir&amp;gt;/releases/OTP-REL/installed_application_versions&lt;/code&gt;.</source>
          <target state="translated">패치 된 응용 프로그램이 설치된 응용 프로그램 목록에 추가됩니다. &lt;code&gt;&amp;lt;InstallDir&amp;gt;/releases/OTP-REL/installed_application_versions&lt;/code&gt; 를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="de8aec81a8619523440bf735eef84868583ed273" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist at the master node &lt;code&gt;Master&lt;/code&gt;.</source>
          <target state="translated">경로 &lt;code&gt;Path&lt;/code&gt; (파일 또는 디렉토리)는 마스터 노드에 존재하지 않는 &lt;code&gt;Master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9efed4ade7b3864058f4bc8126d22473cb9ba0df" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist.</source>
          <target state="translated">경로 &lt;code&gt;Path&lt;/code&gt; (파일 또는 디렉토리)가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00b2a07ab726e41d953579382af2a4c7a39f62f9" translate="yes" xml:space="preserve">
          <source>The path is not relative.</source>
          <target state="translated">경로는 상대적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="302ff460ef043ede1fb15ed8b241c07bf3d0af3a" translate="yes" xml:space="preserve">
          <source>The path is relative to the top-level log directory if &lt;code&gt;ct:run:testspec(TestSpec)&lt;/code&gt; executes the test.</source>
          <target state="translated">&lt;code&gt;ct:run:testspec(TestSpec)&lt;/code&gt; 이 테스트를 실행하는 경우 경로는 최상위 로그 디렉토리를 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ed296092ce0cab58b679cc1f44b7eff89a2c0d6a" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent configuration files.</source>
          <target state="translated">경로 위치는 영구 구성 파일을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="df84aee71581027a14aa1d0460434f6a1cd2bc48" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent data files.</source>
          <target state="translated">경로 위치는 영구 데이터 파일을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f41c20a183605aaa02c5a050804cb5f85891fc8" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient data files on a local machine.</source>
          <target state="translated">경로 위치는 로컬 시스템의 임시 데이터 파일을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="24ac97a8853d3eb3c0e82e90ec7ff8a99f90d2b1" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient log files on a local machine.</source>
          <target state="translated">경로 위치는 로컬 시스템의 임시 로그 파일을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fabb1e75bc1356932aba105b5820e5c24d189a02" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on a specified volume, or it is a specific file on the current working volume.</source>
          <target state="translated">경로 이름은 지정된 볼륨의 현재 작업 디렉토리에 상대적이거나 현재 작업 볼륨의 특정 파일입니다.</target>
        </trans-unit>
        <trans-unit id="329f4e1f9e1361ccb26d9048eedbf79a0fc09f6b" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on the current volume.</source>
          <target state="translated">경로 이름은 현재 볼륨의 현재 작업 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="698e20309829f4ab61d3971bbd487b1bdda9857f" translate="yes" xml:space="preserve">
          <source>The path name refers to a specific file on a specific volume.</source>
          <target state="translated">경로 이름은 특정 볼륨의 특정 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c82c62dcbb94f72c91af63848dc5e39d27171439" translate="yes" xml:space="preserve">
          <source>The path to the directory where the distribution modules reside must be known at boot. This can be achieved either by specifying &lt;code&gt;-pa &amp;lt;path&amp;gt;&lt;/code&gt; on the command line or by building a boot script containing the applications used for your distribution protocol. (In the &lt;code&gt;uds_dist&lt;/code&gt; protocol, only the &lt;code&gt;uds_dist&lt;/code&gt; application needs to be added to the script.)</source>
          <target state="translated">배포시 배포 모듈이있는 디렉토리의 경로를 알고 있어야합니다. 이것은 명령 행에서 &lt;code&gt;-pa &amp;lt;path&amp;gt;&lt;/code&gt; 를 지정 하거나 분배 프로토콜에 사용되는 응용 프로그램을 포함하는 부트 스크립트를 빌드하여 수행 할 수 있습니다. ( &lt;code&gt;uds_dist&lt;/code&gt; 프로토콜에서는 &lt;code&gt;uds_dist&lt;/code&gt; 어플리케이션 만 스크립트에 추가하면됩니다.)</target>
        </trans-unit>
        <trans-unit id="698dcce20dfe46d840644fbd320bb371ef1dcc60" translate="yes" xml:space="preserve">
          <source>The paths could easily be changed by options: &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션은 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 쉽게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e863090f08be4587b861f731a6d55a6ce32f762" translate="yes" xml:space="preserve">
          <source>The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself.</source>
          <target state="translated">패턴은 &quot;고정&quot;되어야합니다. 즉, 검색된 문자열 ( &quot;제목 문자열&quot;)의 첫 번째 일치 지점에서만 일치하도록 제한됩니다. 이 효과는 패턴 자체의 적절한 구성으로도 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b998a50f666939e90060048d8bd7137cbf14f7" translate="yes" xml:space="preserve">
          <source>The pattern is here within parentheses so that the recursion refers to them instead of the whole pattern.</source>
          <target state="translated">패턴은 여기에 괄호 안에 있으므로 재귀는 전체 패턴 대신 패턴을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0cc98b553afe0b60b841f7b9f1c109087f0da93e" translate="yes" xml:space="preserve">
          <source>The pattern provided to the functions must be a valid record, and the first element of the provided tuple must be the &lt;code&gt;record_name&lt;/code&gt; of the table. The special element &lt;code&gt;'_'&lt;/code&gt; matches any data structure in Erlang (also known as an Erlang term). The special elements &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; behave as Erlang variables, that is, they match anything, bind the first occurrence, and match the coming occurrences of that variable against the bound value.</source>
          <target state="translated">함수에 제공된 패턴은 유효한 레코드 여야하며 제공된 튜플의 첫 번째 요소 는 테이블 의 &lt;code&gt;record_name&lt;/code&gt; 이어야 합니다. 특수 요소 &lt;code&gt;'_'&lt;/code&gt; 는 Erlang (Erlang 용어라고도 함)의 모든 데이터 구조와 일치합니다. 특수 요소 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 는 Erlang 변수로 작동합니다. 즉, 임의의 항목과 일치하고 첫 번째 항목을 바인딩하며 해당 변수의 다음 항목을 바인딩 된 값과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="2c0886b7cf654b6b834bf58578aecb88e02ed55d" translate="yes" xml:space="preserve">
          <source>The pattern(s) must be matched multiple times. If &lt;code&gt;N&lt;/code&gt; is speciified, the pattern(s) are matched &lt;code&gt;N&lt;/code&gt; times, and the function returns &lt;code&gt;HaltReason = done&lt;/code&gt;. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="translated">패턴은 여러 번 일치해야합니다. 경우 &lt;code&gt;N&lt;/code&gt; 이 speciified되면, 패턴은 매칭 &lt;code&gt;N&lt;/code&gt; 의 시간과 함수 반환 &lt;code&gt;HaltReason = done&lt;/code&gt; . 이 옵션은 하나 이상의 &lt;code&gt;HaltPatterns&lt;/code&gt; 에 의해 중단 될 수 있습니다 . &lt;code&gt;MatchList&lt;/code&gt; 은 항상의 목록, 즉, 리턴 &lt;code&gt;Match&lt;/code&gt; 대신 하나의 &lt;code&gt;Match&lt;/code&gt; . 또한 &lt;code&gt;HaltReason&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="268d1764864d982e7120f74e74c9fd6647497d91" translate="yes" xml:space="preserve">
          <source>The patterns in the clause head can be successfully matched against the given arguments.</source>
          <target state="translated">절 헤드의 패턴을 주어진 인수와 성공적으로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cf98c378247e817abc5f228e3f59d4dd5e3a6c9" translate="yes" xml:space="preserve">
          <source>The peer certificate is returned as a DER-encoded binary. The certificate can be decoded with &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt;</source>
          <target state="translated">피어 인증서는 DER로 인코딩 된 이진으로 반환됩니다. 인증서는 &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt; 를 사용 하여 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c33a7248317e3e4d5645db402b82fdf9bfcfb31" translate="yes" xml:space="preserve">
          <source>The performance degradation for a system that is enabled for sequential tracing is negligible as long as no tracing is activated. When tracing is activated, there is an extra cost for each traced message, but all other messages are unaffected.</source>
          <target state="translated">순차 추적에 사용 가능한 시스템의 성능 저하는 추적이 활성화되지 않는 한 무시할 수 있습니다. 추적이 활성화되면 추적 된 각 메시지에 대해 추가 비용이 발생하지만 다른 모든 메시지에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8cbfc9b98e9849da11c2e28dbb992bbe4ea2486" translate="yes" xml:space="preserve">
          <source>The permissible options are the same as for &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, except that option&lt;code&gt;capture&lt;/code&gt; is not allowed. Instead a &lt;code&gt;{return, ReturnType}&lt;/code&gt; is present. The default return type is &lt;code&gt;iodata&lt;/code&gt;, constructed in a way to minimize copying. The &lt;code&gt;iodata&lt;/code&gt; result can be used directly in many I/O operations. If a flat &lt;code&gt;list()&lt;/code&gt; is desired, specify &lt;code&gt;{return, list}&lt;/code&gt;. If a binary is desired, specify &lt;code&gt;{return, binary}&lt;/code&gt;.</source>
          <target state="translated">허용되는 옵션은 옵션 &lt;code&gt;capture&lt;/code&gt; 가 허용되지 않는다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 과 동일합니다 . 대신 &lt;code&gt;{return, ReturnType}&lt;/code&gt; 이 있습니다. 기본 반환 유형은 복사를 최소화하는 방식으로 구성된 &lt;code&gt;iodata&lt;/code&gt; 입니다. &lt;code&gt;iodata&lt;/code&gt; 결과는 많은 I / O 작업에 직접 사용할 수 있습니다. 단순 &lt;code&gt;list()&lt;/code&gt; 이 필요한 경우 &lt;code&gt;{return, list}&lt;/code&gt; 지정 하십시오 . 이진이 필요한 경우 &lt;code&gt;{return, binary}&lt;/code&gt; 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6319938072e5f5bf04da6b368d9c42dc62f6e008" translate="yes" xml:space="preserve">
          <source>The pid</source>
          <target state="translated">pid</target>
        </trans-unit>
        <trans-unit id="3f16145e2d18587f6b89bcea6a5d1f5d05a57b75" translate="yes" xml:space="preserve">
          <source>The pid of the heir of the table, or &lt;code&gt;none&lt;/code&gt; if no heir is set.</source>
          <target state="translated">테이블 상속자의 pid이거나 상속자가 설정되지 &lt;code&gt;none&lt;/code&gt; 경우에는 pid입니다 .</target>
        </trans-unit>
        <trans-unit id="bad35c800b2a5b5e2bf66d0ff3f487490a14c90c" translate="yes" xml:space="preserve">
          <source>The pid of the owner of the table.</source>
          <target state="translated">테이블 소유자의 pid.</target>
        </trans-unit>
        <trans-unit id="eb05b4cc61bcd44e5954e6a679ba99c62203c819" translate="yes" xml:space="preserve">
          <source>The pid of the receiving process. The pid is to refer to a process on the local node.</source>
          <target state="translated">수신 프로세스의 pid. pid는 로컬 노드의 프로세스를 참조하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="826db1b9e643364ce8e57b8ab6ccf5be81118acd" translate="yes" xml:space="preserve">
          <source>The point of sending data as a list header, is to facilitate matching on the data received.</source>
          <target state="translated">리스트 헤더로서 데이터를 송신하는 요점은 수신 된 데이터에 대한 매칭을 용이하게하는 것이다.</target>
        </trans-unit>
        <trans-unit id="a0dac0c856b6bd486d6d80e0c5f670c5e59ababc" translate="yes" xml:space="preserve">
          <source>The polling feature is controlled by the configuration values &lt;code&gt;poll_limit&lt;/code&gt; and &lt;code&gt;poll_interval&lt;/code&gt; and is by default disabled. This means that the function immediately returns all complete strings received and saves a remaining non-terminated string for a later &lt;code&gt;get_data&lt;/code&gt; call.</source>
          <target state="translated">폴링 기능은 구성 값 &lt;code&gt;poll_limit&lt;/code&gt; 및 &lt;code&gt;poll_interval&lt;/code&gt; 에 의해 제어 되며 기본적으로 사용되지 않습니다. 이는 함수가 수신 한 모든 완전한 문자열을 즉시 리턴하고 나중에 &lt;code&gt;get_data&lt;/code&gt; 호출을 위해 종료되지 않은 나머지 문자열을 저장함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5d6f13f29266bcb18f4282624a4022662ca669ae" translate="yes" xml:space="preserve">
          <source>The pool of nodes</source>
          <target state="translated">노드 풀</target>
        </trans-unit>
        <trans-unit id="9f5b4ca13c9ab872bb6daaa4dfbebefbf017cc04" translate="yes" xml:space="preserve">
          <source>The port ID of the receiving port. The port ID is to refer to a port on the local node.</source>
          <target state="translated">수신 포트의 포트 ID입니다. 포트 ID는 로컬 노드의 포트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ddfe98846c7da18189a1df423baa1aaca1defcc" translate="yes" xml:space="preserve">
          <source>The port can only be used for input.</source>
          <target state="translated">포트는 입력에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e788605ff88677668be04c2f0461ee176fc8414" translate="yes" xml:space="preserve">
          <source>The port can only be used for output.</source>
          <target state="translated">포트는 출력에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5668c5527d21298d324cca59ff3c8059f2e94f" translate="yes" xml:space="preserve">
          <source>The port controlling communication with the remote node.</source>
          <target state="translated">원격 노드와의 통신을 제어하는 ​​포트입니다.</target>
        </trans-unit>
        <trans-unit id="d8add36b162d7f85fd7335d4a43fd4c5d3cb6a19" translate="yes" xml:space="preserve">
          <source>The port does &lt;strong&gt;not&lt;/strong&gt; reply with &lt;code&gt;{Port,connected}&lt;/code&gt;.</source>
          <target state="translated">포트가 &lt;code&gt;{Port,connected}&lt;/code&gt; 로 응답 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e2ddef440aa65eb46a9df15d1fd89471e5e732" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) creating the new port.</source>
          <target state="translated">새 포트를 작성하는 포트 (드라이버 인스턴스)의 포트 핸들.</target>
        </trans-unit>
        <trans-unit id="405194befe843be0a71985802205fb7d1880fe5a" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) doing the acknowledgment.</source>
          <target state="translated">승인을 수행하는 포트 (드라이버 인스턴스)의 포트 핸들.</target>
        </trans-unit>
        <trans-unit id="95eb949bda5093de827dd6c5e24f46c8d5c5fb5e" translate="yes" xml:space="preserve">
          <source>The port identifier for the port that this structure corresponds to. It is needed for most &lt;code&gt;driver_XXX&lt;/code&gt; calls from the driver back to the emulator.</source>
          <target state="translated">이 구조가 해당하는 포트의 포트 식별자. 드라이버에서 에뮬레이터로 돌아가는 대부분의 &lt;code&gt;driver_XXX&lt;/code&gt; 호출에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="66cfb7457c3ee07be7aa92ceb66e42b6845d40bb" translate="yes" xml:space="preserve">
          <source>The port identifier of the port that is currently executed by the scheduler.</source>
          <target state="translated">스케줄러가 현재 실행중인 포트의 포트 ID입니다.</target>
        </trans-unit>
        <trans-unit id="4d482aa64430d6219ae86b9b4af57ffcff9757f8" translate="yes" xml:space="preserve">
          <source>The port identifier.</source>
          <target state="translated">포트 식별자.</target>
        </trans-unit>
        <trans-unit id="56b2c676adbaff1c1e1e0d421f4b603ad3e33a68" translate="yes" xml:space="preserve">
          <source>The port is created using the BIF &lt;code&gt;open_port/2&lt;/code&gt; with &lt;code&gt;{spawn,ExtPrg}&lt;/code&gt; as the first argument. The string &lt;code&gt;ExtPrg&lt;/code&gt; is the name of the external program, including any command line arguments. The second argument is a list of options, in this case only &lt;code&gt;{packet,2}&lt;/code&gt;. This option says that a 2 byte length indicator is to be used to simplify the communication between C and Erlang. The Erlang port automatically adds the length indicator, but this must be done explicitly in the external C program.</source>
          <target state="translated">포트는 첫 번째 인수로 &lt;code&gt;{spawn,ExtPrg}&lt;/code&gt; 와 함께 BIF &lt;code&gt;open_port/2&lt;/code&gt; 를 사용하여 작성됩니다 . 문자열 &lt;code&gt;ExtPrg&lt;/code&gt; 는 명령 행 인수를 포함하여 외부 프로그램의 이름입니다. 두 번째 인수는 옵션 목록이며이 경우에는 &lt;code&gt;{packet,2}&lt;/code&gt; 입니다. 이 옵션은 2 바이트 길이 표시기가 C와 Erlang 간의 통신을 단순화하는 데 사용된다고 말합니다. Erlang 포트는 길이 표시기를 자동으로 추가하지만 외부 C 프로그램에서 명시 적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d515078a6d0f1b9f22ce1b5d7e5c099ff2874fa5" translate="yes" xml:space="preserve">
          <source>The port is not closed at the end of the file and does not produce an exit signal. Instead, it remains open and a &lt;code&gt;{Port, eof}&lt;/code&gt; message is sent to the process holding the port.</source>
          <target state="translated">포트는 파일 끝에서 닫히지 않으며 종료 신호를 생성하지 않습니다. 대신 열린 상태로 있고 &lt;code&gt;{Port, eof}&lt;/code&gt; 보유한 프로세스 로 {Port, eof} 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6a456a28936847225b9929c122d159c3ef3485f0" translate="yes" xml:space="preserve">
          <source>The port is then created using the BIF &lt;code&gt;open_port/2&lt;/code&gt;, with the tuple &lt;code&gt;{spawn, DriverName}&lt;/code&gt; as the first argument. The string &lt;code&gt;SharedLib&lt;/code&gt; is the name of the port driver. The second argument is a list of options, none in this case:</source>
          <target state="translated">그런 다음 튜플 &lt;code&gt;{spawn, DriverName}&lt;/code&gt; 을 첫 번째 인수로 사용하여 BIF &lt;code&gt;open_port/2&lt;/code&gt; 를 사용하여 포트가 작성됩니다 . 문자열 &lt;code&gt;SharedLib&lt;/code&gt; 는 포트 드라이버의 이름입니다. 두 번째 인수는 옵션 목록이며이 경우에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9fcfec977ea3c1e018c7d81f66fbf088c0f1d7b" translate="yes" xml:space="preserve">
          <source>The port message queue is set into a busy state when the amount of command data queued on the message queue reaches the &lt;code&gt;high&lt;/code&gt; limit. The port message queue is set into a not busy state when the amount of command data queued on the message queue falls below the &lt;code&gt;low&lt;/code&gt; limit. Command data is in this context data passed to the port using either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;. Notice that these limits only concerns command data that have not yet reached the port. The &lt;code&gt;&lt;a href=&quot;#set_busy_port&quot;&gt;busy port&lt;/a&gt;&lt;/code&gt; feature can be used for data that has reached the port.</source>
          <target state="translated">메시지 큐에 큐잉 된 명령 데이터의 양이 도달하면 포트 메시지 큐가 비지 상태로 설정되어 &lt;code&gt;high&lt;/code&gt; 한도. 메시지 큐에 큐잉 된 명령 데이터의 양이 아래로 떨어지면 포트 메시지 큐가 비지 상태로되지 설정된 &lt;code&gt;low&lt;/code&gt; 한도. 명령 데이터는이 컨텍스트에서 &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; 또는 &lt;code&gt;port_command/[2,3]&lt;/code&gt; . 이 한계는 아직 포트에 도달하지 않은 명령 데이터에만 적용됩니다. 사용 &lt;code&gt;&lt;a href=&quot;#set_busy_port&quot;&gt;busy port&lt;/a&gt;&lt;/code&gt; 기능은 포트에 도달 한 데이터에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20086dbd568a4d1794aae351e6d4783a1bb4f27a" translate="yes" xml:space="preserve">
          <source>The port name of the new port. You usually want to use the same port name as the driver name (&lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt;driver_name&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">새 포트의 포트 이름입니다. 일반적으로 드라이버 이름과 동일한 포트 이름 ( &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt;driver_name&lt;/a&gt;&lt;/code&gt; 필드)을 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="f0f47e8645d1b1ba4480dbc54c2d1360eb57b767" translate="yes" xml:space="preserve">
          <source>The port number on which the node accept connection requests.</source>
          <target state="translated">노드가 연결 요청을 수락하는 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="14a2d34036c08fb128310c5494cd65660394733e" translate="yes" xml:space="preserve">
          <source>The port owner &lt;code&gt;Pid&lt;/code&gt; can communicate with the port &lt;code&gt;Port&lt;/code&gt; by sending and receiving messages. (In fact, any process can send the messages to the port, but the port owner must be identified in the message).</source>
          <target state="translated">포트 소유자 &lt;code&gt;Pid&lt;/code&gt; 는 메시지를 송수신 하여 포트 &lt;code&gt;Port&lt;/code&gt; 와 통신 할 수 있습니다 . 실제로 모든 프로세스는 메시지를 포트로 보낼 수 있지만 메시지에서 포트 소유자를 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="53c673fa38fb63daad8279f5786d12a340c3879a" translate="yes" xml:space="preserve">
          <source>The port that the HTTP server listen to. If zero is specified as port, an arbitrary available port is picked and function &lt;code&gt;httpd:info/2&lt;/code&gt; can be used to determine which port was picked.</source>
          <target state="translated">HTTP 서버가 청취하는 포트입니다. 포트로 0을 지정하면 임의의 사용 가능한 포트가 선택되고 &lt;code&gt;httpd:info/2&lt;/code&gt; 기능을 사용하여 선택되는 포트를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="303cb397a1becf617c4be6350ca5fd61cb80f620" translate="yes" xml:space="preserve">
          <source>The ports implemented by this driver operate in two major modes, named &lt;code&gt;command&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;. In &lt;code&gt;command&lt;/code&gt; mode, only passive reading and writing (like &lt;code&gt;gen_tcp:recv&lt;/code&gt;/&lt;code&gt;gen_tcp:send&lt;/code&gt;) can be done. The port is in this mode during the distribution handshake. When the connection is up, the port is switched to &lt;code&gt;data&lt;/code&gt; mode and all data is immediately read and passed further to the Erlang emulator. In &lt;code&gt;data&lt;/code&gt; mode, no data arriving to &lt;code&gt;uds_command&lt;/code&gt; is interpreted, only packaged and sent out on the socket. The &lt;code&gt;uds_control&lt;/code&gt; callback does the switching between those two modes.</source>
          <target state="translated">이 드라이버로 구현 된 포트는 &lt;code&gt;command&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 라는 두 가지 주요 모드에서 작동 합니다 . 에서 &lt;code&gt;command&lt;/code&gt; 모드, 패시브 읽기와 쓰기 (같은 &lt;code&gt;gen_tcp:recv&lt;/code&gt; / &lt;code&gt;gen_tcp:send&lt;/code&gt; ) 할 수 있습니다. 분배 핸드 셰이크 중에 포트가이 모드에 있습니다. 연결되면 포트가 &lt;code&gt;data&lt;/code&gt; 모드로 전환되고 모든 데이터를 즉시 읽고 Erlang 에뮬레이터로 전달합니다. 에서 &lt;code&gt;data&lt;/code&gt; 모드에 도착하는 데이터 &lt;code&gt;uds_command&lt;/code&gt; 는 , 해석에만 패키지와 소켓으로부터 송신된다. &lt;code&gt;uds_control&lt;/code&gt; 의 콜백이 두 모드 사이의 전환을한다.</target>
        </trans-unit>
        <trans-unit id="479cb4b39a01954743d9faba125677bc9ccf6bba" translate="yes" xml:space="preserve">
          <source>The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey Friedl originated the idea (and the name) in the first edition of his book. Mike McCloskey liked it, so implemented it when he built the Sun Java package, and PCRE copied it from there. It ultimately found its way into Perl at release 5.10.</source>
          <target state="translated">소유 수량화 구문은 Perl 5.8 구문의 확장입니다. Jeffrey Friedl은 그의 책의 첫 번째 판에서 아이디어와 이름을 시작했습니다. Mike McCloskey는이를 좋아하여 Sun Java 패키지를 빌드 할 때 구현했으며 PCRE는이 패키지를 복사했습니다. 릴리스 5.10에서 궁극적으로 Perl로 향했습니다.</target>
        </trans-unit>
        <trans-unit id="3636e381fdb27bd130356d04a1054555e03c668b" translate="yes" xml:space="preserve">
          <source>The possible commands are &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, and &lt;code&gt;unlink&lt;/code&gt;.</source>
          <target state="translated">가능한 명령은 &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;command&lt;/code&gt; , &lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;control&lt;/code&gt; , &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;link&lt;/code&gt; , &lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;unlink&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed31e825086e99a9550da0520a157f768b47fed9" translate="yes" xml:space="preserve">
          <source>The possible error reasons and the corresponding diagnostic strings returned by &lt;code&gt;formaterror/1&lt;/code&gt; are as follows:</source>
          <target state="translated">&lt;code&gt;formaterror/1&lt;/code&gt; 에 의해 리턴되는 가능한 오류 이유 및 해당 진단 문자열 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c76008544af718ead9afe49e6a29a494608280a0" translate="yes" xml:space="preserve">
          <source>The possible modifications are:</source>
          <target state="translated">가능한 수정 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f67dca2d282eb65ee7030798081655de26212d8e" translate="yes" xml:space="preserve">
          <source>The possible monitor messages to expect are the same as when using option &lt;code&gt;unloaded&lt;/code&gt; to function &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예상되는 모니터 메시지는 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 기능에 &lt;code&gt;unloaded&lt;/code&gt; 옵션을 사용할 때와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3402737cdfb2af426a71f1abc6fcfd8e890b8dfe" translate="yes" xml:space="preserve">
          <source>The possible path validation errors are given on form &lt;code&gt;{bad_cert, Reason}&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is:</source>
          <target state="translated">가능한 경로 유효성 검증 오류는 &lt;code&gt;{bad_cert, Reason}&lt;/code&gt; 양식에 제공되며 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a941da52cdacf4f18dab68834ca9a0b9b380d76" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;SeqTraceFlag&lt;/code&gt; are available in &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">사용할 수있는 값 &lt;code&gt;SeqTraceFlag&lt;/code&gt; 는 사용할 수 있습니다 &lt;code&gt;seq_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8463b8102b0a232e391b76c31a7662065c9a35d8" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;code&gt;Reason&lt;/code&gt; returned when an error occurs are:</source>
          <target state="translated">오류가 발생할 때 리턴 되는 가능한 &lt;code&gt;Reason&lt;/code&gt; 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9e7ad200abbd6c26753c3e135059d909819a0d3" translate="yes" xml:space="preserve">
          <source>The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of &lt;strong&gt;metacharacters&lt;/strong&gt;, which do not stand for themselves but instead are interpreted in some special way.</source>
          <target state="translated">정규 표현식의 힘은 패턴에 대안과 반복을 포함하는 능력에서 비롯됩니다. 이것들은 &lt;strong&gt;메타 문자를&lt;/strong&gt; 사용하여 패턴으로 인코딩되며 , 이는 자체를 나타내지 않고 대신 특별한 방식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b75dfccef8bf15d11af3ec419501f78711191fcb" translate="yes" xml:space="preserve">
          <source>The pre (post) functions for different tables are evaluated in unspecified order.</source>
          <target state="translated">다른 테이블에 대한 사전 (사후) 기능은 지정되지 않은 순서로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ef1f9e226e4b6cb5e965d6e8bd26fbd505355d6e" translate="yes" xml:space="preserve">
          <source>The precise effect of \cx on ASCII characters is as follows: if x is a lowercase letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A (A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes hex 7B (; is 3B). If the data item (byte or 16-bit value) following \c has a value &amp;gt; 127, a compile-time error occurs. This locks out non-ASCII characters in all modes.</source>
          <target state="translated">ASCII 문자에 대한 \ cx의 정확한 효과는 다음과 같습니다. x가 소문자이면 대문자로 변환됩니다. 그런 다음 문자의 비트 6 (16 진수 40)이 반전됩니다. 따라서 \ cA ~ \ cZ는 16 진 01 ~ 16 진 1A (A는 41, Z는 5A)가되지만 \ c {는 16 진 3B ({는 7B)가되고 \ c; 16 진 7B (3B)가됩니다. \ c 다음에 오는 데이터 항목 (바이트 또는 16 비트 값)의 값이 127보다 크면 컴파일 타임 오류가 발생합니다. 모든 모드에서 비 ASCII 문자를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="b9ec8174f3c0fbb4a103d0721bac0a4593311c47" translate="yes" xml:space="preserve">
          <source>The precision field selects base, for example:</source>
          <target state="translated">정밀도 필드는 기본을 선택합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="fe3ebba2ea20548fa4e1d8023343d98509aee9ee" translate="yes" xml:space="preserve">
          <source>The preferred way to do driver code replacement is to let &lt;strong&gt;one single process&lt;/strong&gt; keep track of the driver. When the process starts, the driver is loaded. When replacement is required, the driver is reloaded. Unload is probably never done, or done when the process exits. If more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has a driver loaded when code replacement is demanded, the replacement cannot occur until the last &quot;other&quot; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has unloaded the driver.</source>
          <target state="translated">드라이버 코드 교체를 수행하는 선호되는 방법은 &lt;strong&gt;단일 프로세스&lt;/strong&gt; 가 드라이버를 추적 하도록하는 &lt;strong&gt;것&lt;/strong&gt; 입니다. 프로세스가 시작되면 드라이버가로드됩니다. 교체가 필요한 경우 드라이버가 다시로드됩니다. 언로드는 절대 수행되지 않거나 프로세스가 종료 될 때 수행됩니다. 코드 교체가 필요할 때 둘 이상의 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 에게 드라이버가로드 된 경우 마지막 &quot;다른&quot; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 드라이버를 언로드 할 때까지 교체를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="733bbb9127b2be9265fae567e547e0cecf362a58" translate="yes" xml:space="preserve">
          <source>The prefix can be a possibly deep list of characters or an atom. Example:</source>
          <target state="translated">접두사는 문자 또는 원자의 깊은 목록 일 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="dba1348d69926c90183adbcb04fa0974199d7975" translate="yes" xml:space="preserve">
          <source>The pretty printer &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;erl_prettypr&lt;/a&gt;&lt;/code&gt; is implemented on top of the library module &lt;code&gt;&lt;a href=&quot;prettypr&quot;&gt;prettypr&lt;/a&gt;&lt;/code&gt;: this is a powerful and flexible generic pretty printing library, which is also distributed separately.</source>
          <target state="translated">예쁜 프린터 &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;erl_prettypr&lt;/a&gt;&lt;/code&gt; 라이브러리 모듈의 상단에 구현 &lt;code&gt;&lt;a href=&quot;prettypr&quot;&gt;prettypr&lt;/a&gt;&lt;/code&gt; 은 :이 별도로 배포되는 강력하고 유연한 일반적인 꽤 인쇄 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="55f286a009d576b38e8e85ec7239710e5fc14790" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;install/2&lt;/code&gt; procedure differs somewhat from that of the ordinary &lt;code&gt;Install&lt;/code&gt; shell script. In fact, &lt;code&gt;create/1&lt;/code&gt; makes the release package as complete as possible, and leave to the &lt;code&gt;install/2&lt;/code&gt; procedure to finish by only considering location-dependent files.</source>
          <target state="translated">이전 &lt;code&gt;install/2&lt;/code&gt; 절차는 일반 &lt;code&gt;Install&lt;/code&gt; 셸 스크립트 와 약간 다릅니다 . 실제로 &lt;code&gt;create/1&lt;/code&gt; 은 릴리스 패키지를 가능한 한 완벽하게 만들고 위치 종속 파일 만 고려 하여 &lt;code&gt;install/2&lt;/code&gt; 절차를 마칩니다.</target>
        </trans-unit>
        <trans-unit id="3fa312f724214bcc1cd80a76985d7a69b991d85b" translate="yes" xml:space="preserve">
          <source>The previous example can be simplified by using the &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; module to create an Erlang term:</source>
          <target state="translated">이전 예제는 &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; 모듈을 사용하여 Erlang 용어를 작성 하여 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b46669f7567ee67b00ce88c3207ede01b10c7f03" translate="yes" xml:space="preserve">
          <source>The previous example of state time-outs only work if the state machine stays in the same state during the time-out time. And event time-outs only work if no disturbing unrelated events occur.</source>
          <target state="translated">상태 제한 시간의 이전 예는 제한 시간 동안 상태 시스템이 동일한 상태를 유지하는 경우에만 작동합니다. 또한 이벤트 시간 초과는 방해가되지 않는 관련 이벤트가 발생하지 않는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b3459bae934771664d1dcbf0310cab83038c641d" translate="yes" xml:space="preserve">
          <source>The previous list comprehension expression contains a number of syntactical elements:</source>
          <target state="translated">이전 목록 이해 표현식에는 여러 구문 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ec95b9934bf0009efc315d92c2afbbfc37fa92" translate="yes" xml:space="preserve">
          <source>The previous sections describe how to get started with &lt;code&gt;Mnesia&lt;/code&gt; and how to build a &lt;code&gt;Mnesia&lt;/code&gt; database. This section describes the more advanced features available when building a distributed, fault-tolerant &lt;code&gt;Mnesia&lt;/code&gt; database. The following topics are included:</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작 하는 방법과 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스 를 구축하는 방법에 대해 설명했습니다 . 이 섹션에서는 내결함성 분산 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스를 구축 할 때 사용할 수있는 고급 기능에 대해 설명 합니다. 다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bb3f030405dcf222bd64e25ad1c880d277340fe4" translate="yes" xml:space="preserve">
          <source>The previous write and read example can be extended with encryption and decryption as follows:</source>
          <target state="translated">이전 쓰기 및 읽기 예제는 다음과 같이 암호화 및 암호 해독으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57796ceed90f470b2305125d019084fa629b2ede" translate="yes" xml:space="preserve">
          <source>The primary Logger configuration is a map with the following keys:</source>
          <target state="translated">기본 로거 구성은 다음 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ff1cf20a564ba3e279a69440c710bf978e373ae2" translate="yes" xml:space="preserve">
          <source>The primary log level can be overridden by a log level configured per module. This is to, for instance, allow more verbose logging from a specific part of the system.</source>
          <target state="translated">기본 로그 수준은 모듈 당 구성된 로그 수준으로 재정의 할 수 있습니다. 예를 들어 시스템의 특정 부분에서 더 자세한 로깅을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d1ae98d9ae06c45e41cf5ff9b762c21068711a9b" translate="yes" xml:space="preserve">
          <source>The primary use case for this option is to bind sockets into &lt;code&gt;&lt;a href=&quot;http://www.kernel.org/doc/Documentation/networking/vrf.txt&quot;&gt;Linux VRF instances&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본 사용 사례는 소켓을 &lt;code&gt;&lt;a href=&quot;http://www.kernel.org/doc/Documentation/networking/vrf.txt&quot;&gt;Linux VRF instances&lt;/a&gt;&lt;/code&gt; 에 바인딩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="11e6f9bf4b0c0ac23f2c434d8c992babdb65c4e0" translate="yes" xml:space="preserve">
          <source>The primitive Erlang boot sequence was terminated, most probably because the boot script has errors or cannot be read. This is usually a configuration error; the system can have been started with a faulty &lt;code&gt;-boot&lt;/code&gt; parameter or with a boot script from the wrong OTP version.</source>
          <target state="translated">부팅 스크립트에 오류가 있거나 읽을 수 없기 때문에 기본 Erlang 부팅 순서가 종료되었습니다. 일반적으로 구성 오류입니다. 시스템이 결함이있는 &lt;code&gt;-boot&lt;/code&gt; 매개 변수 또는 잘못된 OTP 버전의 부트 스크립트 로 시작되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f4b4edb0f46f3c079a1f4a56d0fa6ad3463effc" translate="yes" xml:space="preserve">
          <source>The printout consists of one paragraph per called function. The function &lt;strong&gt;marked&lt;/strong&gt; with '%' is the one the paragraph concerns - &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. Above the marked function are the &lt;strong&gt;calling&lt;/strong&gt; functions - those that has called the marked, and below are those &lt;strong&gt;called&lt;/strong&gt; by the marked function.</source>
          <target state="translated">인쇄물은 호출 된 함수 당 하나의 단락으로 구성됩니다. '%' &lt;strong&gt;로 표시된&lt;/strong&gt; 함수 는 단락에 관련된 함수입니다 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; . 표시된 함수 위에는 &lt;strong&gt;호출하는&lt;/strong&gt; 함수가 있습니다. 표시된 함수는 아래에 있으며 , 표시된 함수는 &lt;strong&gt;호출&lt;/strong&gt; 된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="cb0cc2d12f7673987ac78181af36308d13b093fb" translate="yes" xml:space="preserve">
          <source>The printout continues:</source>
          <target state="translated">인쇄물이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="88eb7754fad0268a64d4c07aa796eac3d3d2ab89" translate="yes" xml:space="preserve">
          <source>The printout starts with:</source>
          <target state="translated">인쇄물은 다음으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="45f91a7c53ea68084b88cb17f900ef0b40205e6b" translate="yes" xml:space="preserve">
          <source>The printout to parse is typically the result of a &lt;code&gt;select&lt;/code&gt; command in SQL. The returned &lt;code&gt;Table&lt;/code&gt; is a list of tuples, where each tuple is a row in the table.</source>
          <target state="translated">구문 분석 출력은 일반적으로 SQL 의 &lt;code&gt;select&lt;/code&gt; 명령 결과입니다 . 리턴 된 &lt;code&gt;Table&lt;/code&gt; 은 튜플 목록이며 각 튜플은 테이블의 행입니다.</target>
        </trans-unit>
        <trans-unit id="324a8be8e8a88abcf82aab2f92ee5692197fd525" translate="yes" xml:space="preserve">
          <source>The priority of the Erlang emulator. Default to the Windows default priority.</source>
          <target state="translated">Erlang 에뮬레이터의 우선 순위. 기본값은 Windows 기본 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="9484243e544c5f1274424b246682b09a4351581e" translate="yes" xml:space="preserve">
          <source>The private internet extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">개인 인터넷 확장명 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3578adaa26da6e601dfec21f2beb5043ca19f9a3" translate="yes" xml:space="preserve">
          <source>The private key contains the public key.</source>
          <target state="translated">개인 키에는 공개 키가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb7c14f7ed96915fedd1cf72c76ce0b4318ac44c" translate="yes" xml:space="preserve">
          <source>The problem is the clause with the variable &lt;code&gt;Int&lt;/code&gt;. As a variable can match anything, including the atoms &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, which the following clauses also match, the compiler must generate suboptimal code that executes as follows:</source>
          <target state="translated">문제는 변수가 &lt;code&gt;Int&lt;/code&gt; 인 절입니다 . 변수가 원자 &lt;code&gt;four&lt;/code&gt; , &lt;code&gt;five&lt;/code&gt; 및 &lt;code&gt;six&lt;/code&gt; 을 포함하여 다음 절도 일치하는 항목과 일치 할 수 있으므로 컴파일러는 다음과 같이 실행되는 차선의 코드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="97101ea56c3365ae0f09e70bee55a9ade66266a3" translate="yes" xml:space="preserve">
          <source>The problem of &lt;strong id=&quot;topsort&quot;&gt;topological sorting&lt;/strong&gt; is to find a total ordering of S that is a superset of the partial ordering. A digraph G = (V, E) is equivalent to a relation E on V (we neglect that the version of directed graphs provided by the &lt;code&gt;digraph&lt;/code&gt; module allows multiple edges between vertices). If the digraph has no cycles of length two or more, the reflexive and transitive closure of E is a partial ordering.</source>
          <target state="translated">&lt;strong id=&quot;topsort&quot;&gt;위상 정렬&lt;/strong&gt; 의 문제 는 부분 순서의 상위 집합 인 S의 전체 순서를 찾는 것입니다. digraph G = (V, E)는 V의 관계 E와 같습니다 (우리는 &lt;code&gt;digraph&lt;/code&gt; 모듈이 제공하는 방향 그래프의 버전이 정점 사이에 여러 모서리를 허용 함 을 무시합니다 ). 이 그래프에 길이가 2 이상인 사이클이없는 경우, E의 반사 및 전이 폐쇄는 부분 순서입니다.</target>
        </trans-unit>
        <trans-unit id="6dc36bb1f0c67349dd2ad95f241625aa11fedd24" translate="yes" xml:space="preserve">
          <source>The procedure described uses either Cygwin, MSYS or MSYS2 as a build environment. You run the bash shell in Cygwin/MSYS/MSYS2 and use the gnu make/configure/autoconf etc to do the build. The emulator C-source code is, however, mostly compiled with Microsoft Visual C++&amp;trade;, producing a native Windows binary. This is the same procedure as we use to build the pre-built binaries. Why we use VC++ and not gcc is explained further in the FAQ section.</source>
          <target state="translated">설명 된 절차는 빌드 환경으로 Cygwin, MSYS 또는 MSYS2를 사용합니다. Cygwin / MSYS / MSYS2에서 bash 쉘을 실행하고 gnu make / configure / autoconf 등을 사용하여 빌드를 수행하십시오. 그러나 에뮬레이터 C 소스 코드는 대부분 Microsoft Visual C ++ &amp;trade;로 컴파일되어 기본 Windows 바이너리를 생성합니다. 이것은 미리 빌드 된 바이너리를 빌드 할 때 사용하는 절차와 동일합니다. gcc가 아닌 VC ++를 사용하는 이유는 FAQ 섹션에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3defe5ccf8f073a7bfba94a853f4b3e04c4fd936" translate="yes" xml:space="preserve">
          <source>The procedure for installing an embedded system is the same as for an ordinary system (see Installation Guide), except for the following:</source>
          <target state="translated">내장형 시스템을 설치하는 절차는 다음을 제외하고 일반 시스템과 동일합니다 (설치 안내서 참조).</target>
        </trans-unit>
        <trans-unit id="3e1ec300b173f8914d2686b10b0da9ca7aa25ede" translate="yes" xml:space="preserve">
          <source>The process &quot;pong&quot; now does:</source>
          <target state="translated">&quot;퐁&quot;프로세스는 이제 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="db27ebbde3aba8040f9a717035d37465555bb852" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;0.Item.0&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;0.Item.0&amp;gt;&lt;/code&gt; 프로세스 가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="23867be26ea372bdca1cdb7f994ce5aa95efde29" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 프로세스 가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="8981f50685978b00cd49a2baa1c8ac07d3e68007" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;Pid&lt;/code&gt; must be alive, local, and not already the owner of the table. The calling process must be the table owner.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 는 살아 있고 로컬이어야하며 테이블 소유자가 아니어야합니다. 호출 프로세스는 테이블 소유자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ce97685440137bac537d3a5eb324dcf9c30fc8" translate="yes" xml:space="preserve">
          <source>The process ID of the Erlang process to become owner of the new port. This process will be linked to the new port. You usually want to use &lt;code&gt;driver_caller(port)&lt;/code&gt; as &lt;code&gt;owner_pid&lt;/code&gt;.</source>
          <target state="translated">새 포트의 소유자가 될 Erlang 프로세스의 프로세스 ID. 이 프로세스는 새 포트에 연결됩니다. 일반적으로 &lt;code&gt;driver_caller(port)&lt;/code&gt; 를 &lt;code&gt;owner_pid&lt;/code&gt; 로 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="069991f41691da930cb8b00055cd75415a3bfbb4" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;exit/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exit/1&lt;/code&gt; 이라는 프로세스</target>
        </trans-unit>
        <trans-unit id="ff2c0d20578ead716abbff96344be128bf1b9a3f" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;throw/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;throw/1&lt;/code&gt; 이라는 프로세스</target>
        </trans-unit>
        <trans-unit id="181d7e73097c8d6559d2b5b87438e37ef9de3355" translate="yes" xml:space="preserve">
          <source>The process executing the call does not belong to any application.</source>
          <target state="translated">호출을 실행하는 프로세스는 어떤 응용 프로그램에도 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f1ecb9f48b736f7cd2db1444bab09f031bc5fcb" translate="yes" xml:space="preserve">
          <source>The process has terminated.</source>
          <target state="translated">프로세스가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e60b1f056e03500b54fc847d023aec3ec8683ca" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; does not execute old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스 는 &lt;code&gt;Module&lt;/code&gt; 대한 이전 코드를 실행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="efbf96e7df8ac572e485b865c501336d859faf3c" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; executes old code for &lt;code&gt;Module&lt;/code&gt;. That is, the current call of the process executes old code for this module, or the process has references to old code for this module, or the process contains funs that references old code for this module.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스 는 &lt;code&gt;Module&lt;/code&gt; 에 대한 이전 코드를 실행 합니다. 즉, 프로세스의 현재 호출은이 모듈에 대한 이전 코드를 실행하거나 프로세스에이 모듈의 이전 코드에 대한 참조가 있거나 프로세스에이 모듈의 이전 코드를 참조하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe4451cfd96b4642a3cd1e82d934d848d394bb5" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; has been garbage collected.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 식별 한 프로세스 는 가비지 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c11a4446151542c2c9c338884f572b30ec36ffc" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Suspendee&lt;/code&gt; is suspended unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;. If &lt;code&gt;unless_suspending&lt;/code&gt; is combined with option &lt;code&gt;asynchronous&lt;/code&gt;, a suspend request is sent unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt; or if a suspend request already has been sent and is in transit. If the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;, or if combined with option &lt;code&gt;asynchronous&lt;/code&gt; and a send request already is in transit, &lt;code&gt;false&lt;/code&gt; is returned and the suspend count on &lt;code&gt;Suspendee&lt;/code&gt; remains unchanged.</source>
          <target state="translated">호출 프로세스가 이미 &lt;code&gt;Suspendee&lt;/code&gt; 를 일시 중단하지 않는 한 Suspendee 가 식별 한 프로세스는 일시 &lt;code&gt;Suspendee&lt;/code&gt; 됩니다. &lt;code&gt;unless_suspending&lt;/code&gt; 이 옵션 &lt;code&gt;asynchronous&lt;/code&gt; 와 결합 된 경우 호출 프로세스가 &lt;code&gt;Suspendee&lt;/code&gt; 를 일시 중단 하거나 일시 중단 요청이 이미 전송되어 전송중인 경우 가 아니면 일시 중단 요청이 전송됩니다 . 호출 프로세스가 이미 &lt;code&gt;Suspendee&lt;/code&gt; 를 일시 중단 중이거나 옵션 &lt;code&gt;asynchronous&lt;/code&gt; 와 결합되고 전송 요청이 이미 전송중인 경우 &lt;code&gt;false&lt;/code&gt; 가 반환되고 &lt;code&gt;Suspendee&lt;/code&gt; 의 일시 중단 횟수 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc6dbdee5963a4c4de105af29cdc7452461b900b" translate="yes" xml:space="preserve">
          <source>The process identifier for the process that owns the port.</source>
          <target state="translated">포트를 소유 한 프로세스의 프로세스 식별자.</target>
        </trans-unit>
        <trans-unit id="82a4df785e628bbb31440878eae2c3ce1aa2f090" translate="yes" xml:space="preserve">
          <source>The process identifier of the controlling process for a connection.</source>
          <target state="translated">연결 제어 프로세스의 프로세스 식별자.</target>
        </trans-unit>
        <trans-unit id="c1019f88201ff8eebe4c4c8f11ee6ecb8f045c63" translate="yes" xml:space="preserve">
          <source>The process identifier of the process that is currently executed by the scheduler. If there is such a process, this entry is followed by the &lt;strong&gt;State&lt;/strong&gt;, &lt;strong&gt;Internal State&lt;/strong&gt;, &lt;strong&gt;Program Counter&lt;/strong&gt;, and &lt;strong&gt;CP&lt;/strong&gt; of that same process. The entries are described in section &lt;code&gt;&lt;a href=&quot;#processes&quot;&gt;Process Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 현재 실행중인 프로세스의 프로세스 ID입니다. 그러한 프로세스가있는 경우이 항목 다음에 동일한 프로세스 의 &lt;strong&gt;State&lt;/strong&gt; , &lt;strong&gt;Internal State&lt;/strong&gt; , &lt;strong&gt;Program Counter&lt;/strong&gt; 및 &lt;strong&gt;CP&lt;/strong&gt; 가 이어집니다 . 항목은 &lt;code&gt;&lt;a href=&quot;#processes&quot;&gt;Process Information&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb011da943a6720eb915f7c73d873d81a032acd" translate="yes" xml:space="preserve">
          <source>The process identifier.</source>
          <target state="translated">프로세스 식별자.</target>
        </trans-unit>
        <trans-unit id="27fe3ed1814a1292249730be37daf32c06d0df69" translate="yes" xml:space="preserve">
          <source>The process information returned by this function may be used to locate and terminate remaining processes after tests have finished executing. The function would typically by called from Common Test Hook functions.</source>
          <target state="translated">이 기능에 의해 반환 된 프로세스 정보는 테스트 실행이 완료된 후 나머지 프로세스를 찾아 종료하는 데 사용될 수 있습니다. 이 함수는 일반적으로 Common Test Hook 함수에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e6bedca78a3506c8b135dc2b8bd0767845069ac2" translate="yes" xml:space="preserve">
          <source>The process is also set to trap exits, which enables detection of failure of the external program:</source>
          <target state="translated">프로세스는 엑시트를 트랩하도록 설정되어 외부 프로그램의 실패를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="667f772f31f497429c78d5ea973176a8eb647545" translate="yes" xml:space="preserve">
          <source>The process is awaken when a message is sent to it, and control resumes in &lt;code&gt;Module:Function&lt;/code&gt; with the arguments specified by &lt;code&gt;Args&lt;/code&gt; with the call stack emptied, meaning that the process terminates when that function returns. Thus &lt;code&gt;erlang:hibernate/3&lt;/code&gt; never returns to its caller.</source>
          <target state="translated">메시지가 메시지로 전송되면 프로세스가 깨어나고 호출 스택을 비운 상태에서 &lt;code&gt;Args&lt;/code&gt; 에 지정된 인수를 사용하여 &lt;code&gt;Module:Function&lt;/code&gt; 에서 제어가 다시 시작됩니다 . 즉, 해당 함수가 반환되면 프로세스가 종료됩니다. 따라서 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 는 호출자에게 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ba834279970a7606bdcc555a88858fe5cdb6aca" translate="yes" xml:space="preserve">
          <source>The process is running.</source>
          <target state="translated">프로세스가 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="bfc91c3fc885823bbc69fd5edf12fc9288324645" translate="yes" xml:space="preserve">
          <source>The process is stopped at a breakpoint.</source>
          <target state="translated">프로세스는 중단 점에서 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="4e77677e6bacc9af8fae16fce0e3ff20590fece9" translate="yes" xml:space="preserve">
          <source>The process is suspended, either by the BIF &lt;code&gt;erlang:suspend_process/1&lt;/code&gt; or because it tries to write to a busy port.</source>
          <target state="translated">BIF &lt;code&gt;erlang:suspend_process/1&lt;/code&gt; 에 의해 프로세스가 사용 중이거나 사용중인 포트에 쓰려고하기 때문에 프로세스가 일시 중단되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ec639777c6fbd39eddc16455128329cd62f77aa3" translate="yes" xml:space="preserve">
          <source>The process is to wait indefinitely for a matching message; this is the same as not using a timeout. This can be useful for timeout values that are calculated at runtime.</source>
          <target state="translated">프로세스는 일치하는 메시지를 무한정 기다리는 것입니다. 타임 아웃을 사용하지 않는 것과 같습니다. 런타임시 계산되는 시간 초과 값에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83208c2a966f339873e15e8fdadbc8eaec4e600" translate="yes" xml:space="preserve">
          <source>The process is waiting in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">프로세스가 &lt;code&gt;receive&lt;/code&gt; 문 에서 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="490d1a02b4671d2f440059a33d6b5bf46ed39b4c" translate="yes" xml:space="preserve">
          <source>The process locks are sorted after its class like all other locks. It is convenient to look at specific processes and ports as classes. We can do this by swapping class and class identifiers with &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt;.</source>
          <target state="translated">프로세스 잠금은 다른 모든 잠금과 마찬가지로 클래스 다음에 정렬됩니다. 특정 프로세스와 포트를 클래스로 보는 것이 편리합니다. 클래스 식별자와 클래스 식별자를 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 으로 바꾸면 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab71454c03a7a40960af21879aaea3b714e94712" translate="yes" xml:space="preserve">
          <source>The process of abstracting out the common features of a number of different programs is called &lt;strong&gt;procedural abstraction&lt;/strong&gt;. Procedural abstraction can be used to write several different functions that have a similar structure, but differ in some minor detail. This is done as follows:</source>
          <target state="translated">여러 다른 프로그램의 공통 기능을 추상화하는 과정을 &lt;strong&gt;절차 적 추상화&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 절차 적 추상화를 사용하면 구조는 비슷하지만 약간의 세부 사항이 다른 여러 가지 함수를 작성할 수 있습니다. 이것은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ead71597be31bdb70e88141c28f9f2a4406c239b" translate="yes" xml:space="preserve">
          <source>The process of handling an HTTP request involves several steps, such as:</source>
          <target state="translated">HTTP 요청을 처리하는 프로세스에는 다음과 같은 여러 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="73248bb9e604234911f321cbc273914ed901fdd0" translate="yes" xml:space="preserve">
          <source>The process or port that the trace belongs to.</source>
          <target state="translated">추적이 속하는 프로세스 또는 포트.</target>
        </trans-unit>
        <trans-unit id="f33ec46395f0f62c1d01a1ea2da5eba9a23d0892" translate="yes" xml:space="preserve">
          <source>The process or port with the corresponding registered name is traced. The process or port may be a remote process (on another Erlang node). The node must be added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">등록 된 해당 이름의 프로세스 또는 포트가 추적됩니다. 프로세스 또는 포트는 원격 프로세스 일 수 있습니다 (다른 Erlang 노드에서). &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 노드를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="797b5a91a8e60a806f3452dece6f7cd3883f0a36" translate="yes" xml:space="preserve">
          <source>The process performing the registration will be monitored. Which means that if that process should die, all agents registered by that user process will be unregistered. All outstanding requests will be canceled.</source>
          <target state="translated">등록을 수행하는 프로세스가 모니터링됩니다. 즉, 해당 프로세스가 종료되면 해당 사용자 프로세스에 의해 등록 된 모든 에이전트가 등록 해제됩니다. 모든 미해결 요청이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb0435cbc590f55163deae437b8266e597b2e46" translate="yes" xml:space="preserve">
          <source>The process priority of the emulator. Can be one of the following:</source>
          <target state="translated">에뮬레이터의 프로세스 우선 순위. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd66a4360cd6cbde0a0ee9091b32df8224b27834" translate="yes" xml:space="preserve">
          <source>The process then terminates with reason &lt;code&gt;Reason&lt;/code&gt; for &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;{Reason,Stack}&lt;/code&gt; for the others.</source>
          <target state="translated">이 과정은 다음 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; 에 대한 &lt;code&gt;exit/1&lt;/code&gt; 또는 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 다른 사람을 위해.</target>
        </trans-unit>
        <trans-unit id="d1fd3ae34693cf45eb0f6d67aaf690952ebb7fe3" translate="yes" xml:space="preserve">
          <source>The process trace token is set to the trace token from the message.</source>
          <target state="translated">프로세스 추적 토큰은 메시지에서 추적 토큰으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6c783222fca1057432e796e94441d99e31c4d2ed" translate="yes" xml:space="preserve">
          <source>The process was currently running. If the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; was called, this was the process calling it.</source>
          <target state="translated">프로세스가 현재 실행 중입니다. BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; 이 호출 된 경우이를 호출하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="82a3bf215f40b6a47f89483c4acc26d02d7b3f1c" translate="yes" xml:space="preserve">
          <source>The process was on its way to exit.</source>
          <target state="translated">프로세스가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="f141b2b54a0e0f93bea0340098e765164fced9dd" translate="yes" xml:space="preserve">
          <source>The process was scheduled to run but is currently not running (&quot;in the run queue&quot;).</source>
          <target state="translated">프로세스가 실행되도록 예약되었지만 현재 실행 중이 아닙니다 ( &quot;실행 큐에서&quot;).</target>
        </trans-unit>
        <trans-unit id="2810522b49b7629b84a03c4f78227a04b09abe5b" translate="yes" xml:space="preserve">
          <source>The process was waiting for something (in &lt;code&gt;receive&lt;/code&gt;).</source>
          <target state="translated">프로세스가 무언가를 기다리고있었습니다 ( &lt;code&gt;receive&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27d3cd0b8797a36f6ea5cee6f120e89b7d3af94f" translate="yes" xml:space="preserve">
          <source>The processes created by the service can, as opposed to normal services, be &quot;killed&quot; with the task manager. Killing an emulator that is started by a service triggers the &quot;OnFail&quot; action specified for that service, which can be a reboot.</source>
          <target state="translated">서비스가 생성 한 프로세스는 일반 서비스와 달리 작업 관리자를 통해 &quot;종료&quot;될 수 있습니다. 서비스에 의해 시작된 에뮬레이터를 종료하면 해당 서비스에 대해 지정된 &quot;OnFail&quot;작업이 트리거됩니다 (재부팅 가능).</target>
        </trans-unit>
        <trans-unit id="4d0fdc2fce3dc489670b9aaebda13b3b3434f1aa" translate="yes" xml:space="preserve">
          <source>The profiling result is delivered as a term containing a sorted list of entries, one per module. Each module entry contains a sorted list of functions. The sorting order in both cases is of decreasing call count.</source>
          <target state="translated">프로파일 링 결과는 모듈 당 하나씩 정렬 된 항목 목록을 포함하는 용어로 제공됩니다. 각 모듈 항목에는 정렬 된 기능 목록이 있습니다. 두 경우 모두 정렬 순서는 통화 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6855e78a7f0fc77588d6aebc869c8f249ff318eb" translate="yes" xml:space="preserve">
          <source>The program Igor merges the source code of one or more Erlang modules into a single module, which can then replace the original set of modules. Igor is also able to rename a set of (possibly interdependent) modules, without joining them into a single module.</source>
          <target state="translated">프로그램 Igor는 하나 이상의 Erlang 모듈의 소스 코드를 단일 모듈로 병합하여 원래 모듈 세트를 대체 할 수 있습니다. Igor는 또한 단일 모듈로 결합하지 않고 일련의 (상호 적으로 종속적 인) 모듈의 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8195bc3c2103b70768bbe121c78ace9e38d4b38" translate="yes" xml:space="preserve">
          <source>The program at the other side of a port is often a C program. To help the C programmer, the Erl_Interface library has been developed, including the following five parts:</source>
          <target state="translated">포트의 다른쪽에있는 프로그램은 종종 C 프로그램입니다. C 프로그래머를 돕기 위해 다음 다섯 부분을 포함하여 Erl_Interface 라이브러리가 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="9cb003c21eb552de99312a5e6d1ef17c2df06991" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that the function given as argument is truly synchronous and that no work continues after the function has returned a value.</source>
          <target state="translated">프로그래머는 인수로 제공된 함수가 실제로 동 기적이어야하며 함수가 값을 리턴 한 후에도 계속 작업하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8563f5a39583bb15e30f23bba9afb2129b0dea31" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;proplist_file&lt;/code&gt; and &lt;code&gt;file&lt;/code&gt; are mutually exclusive. Also newer properties may not be supported as Apache-like options, this is a legacy feature.</source>
          <target state="translated">&lt;code&gt;proplist_file&lt;/code&gt; 및 &lt;code&gt;file&lt;/code&gt; 특성 은 상호 배타적입니다. 또한 최신 속성은 Apache와 같은 옵션으로 지원되지 않을 수 있으며 이는 레거시 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ec3820a1952a9bf6dd6589dfc08be32bf37ba810" translate="yes" xml:space="preserve">
          <source>The properties for a group are always printed in the top of the HTML log for &lt;code&gt;init_per_group/2&lt;/code&gt;. The total execution time for a group is included at the bottom of the log for &lt;code&gt;end_per_group/2&lt;/code&gt;.</source>
          <target state="translated">그룹의 특성은 항상 &lt;code&gt;init_per_group/2&lt;/code&gt; 의 HTML 로그 맨 위에 인쇄됩니다 . 그룹의 총 실행 시간은 &lt;code&gt;end_per_group/2&lt;/code&gt; 의 로그 맨 아래에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0658e68a98aef88d6e658150857250258c9aa19" translate="yes" xml:space="preserve">
          <source>The properties for directories are as follows:</source>
          <target state="translated">디렉토리의 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c21d4cead30e9277ec44f6f7b10414a0626222c2" translate="yes" xml:space="preserve">
          <source>The properties for the security directories are as follows:</source>
          <target state="translated">보안 디렉토리의 특성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1311e2c285781d781a81d4ea6d0fb15f0a88ba6" translate="yes" xml:space="preserve">
          <source>The properties of the sessions will be exactly the same, except that when using &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, you may start multiple sessions over the same SSH connection. Each session is implemented as an SSH channel.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 를 사용할 때 동일한 SSH 연결을 통해 여러 세션을 시작할 수 있다는 점을 제외하면 세션의 속성은 정확히 동일합니다. 각 세션은 SSH 채널로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="2db0406d66f21d5b36229de1553b67aafe2dce31" translate="yes" xml:space="preserve">
          <source>The property names represented by &lt;strong&gt;xx&lt;/strong&gt; above are limited to the Unicode script names, the general category properties, &quot;Any&quot;, which matches any character (including newline), and some special PCRE properties (described in the next section). Other Perl properties, such as &quot;InMusicalSymbols&quot;, are currently not supported by PCRE. Notice that \P{Any} does not match any characters and always causes a match failure.</source>
          <target state="translated">위의 &lt;strong&gt;xx로&lt;/strong&gt; 표시되는 특성 이름은 유니 코드 스크립트 이름, 일반 카테고리 특성, &quot;모든 문자&quot;(개행 포함)와 일치하는 &quot;Any&quot;및 일부 특수 PCRE 특성 (다음 섹션에서 설명)으로 제한됩니다. &quot;InMusicalSymbols&quot;와 같은 다른 Perl 속성은 현재 PCRE에서 지원되지 않습니다. \ P {Any}는 어떤 ​​문자와도 일치하지 않으며 항상 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b66b0619fa655f54cf968828bbc7d5585eb77d5" translate="yes" xml:space="preserve">
          <source>The property tests are assumed to be in subdirectory &lt;code&gt;property_test&lt;/code&gt;.</source>
          <target state="translated">특성 테스트는 property_test 서브 디렉토리에 있다고 가정 &lt;code&gt;property_test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cecd3acaa022724f92df164ddb141a901162aee3" translate="yes" xml:space="preserve">
          <source>The protection of the dumped table (that is, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, or &lt;code&gt;public&lt;/code&gt;). A table loaded from the file gets the same protection.</source>
          <target state="translated">덤프 된 테이블의 보호 (즉, &lt;code&gt;private&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;public&lt;/code&gt; ). 파일에서로드 된 테이블은 동일한 보호를받습니다.</target>
        </trans-unit>
        <trans-unit id="ea098b4d622a71447129857377ff429cb6e98cf7" translate="yes" xml:space="preserve">
          <source>The protection of the table.</source>
          <target state="translated">테이블의 보호.</target>
        </trans-unit>
        <trans-unit id="2d49c5ef78ce098f6cf07e79b387a293a3f5f71d" translate="yes" xml:space="preserve">
          <source>The protocol (messages sent to and received from the server) is also hidden. This is good programming practice and allows one to change the protocol without changing the code using the interface functions.</source>
          <target state="translated">프로토콜 (서버와주고받는 메시지)도 숨겨져 있습니다. 이것은 좋은 프로그래밍 관행이며 인터페이스 기능을 사용하여 코드를 변경하지 않고 프로토콜을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af664d953b1ecbbc88733b368b7ab068bb4ba398" translate="yes" xml:space="preserve">
          <source>The protocol engine uses callback modules to handle various things:</source>
          <target state="translated">프로토콜 엔진은 콜백 모듈을 사용하여 다양한 것을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="45aaae8278825f7a88f5605ecd8a29c30678b26a" translate="yes" xml:space="preserve">
          <source>The protocol handling processes in &lt;code&gt;Common Test&lt;/code&gt;, implemented by &lt;code&gt;ct_telnet&lt;/code&gt;, &lt;code&gt;ct_ssh&lt;/code&gt;, &lt;code&gt;ct_ftp&lt;/code&gt;, and so on, do verbose printing to the test case logs. This can be switched off with flag &lt;code&gt;-silent_connections&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ct_telnet&lt;/code&gt; , &lt;code&gt;ct_ssh&lt;/code&gt; , &lt;code&gt;ct_ftp&lt;/code&gt; 등으로 구현 된 &lt;code&gt;Common Test&lt;/code&gt; 의 프로토콜 처리 프로세스 는 테스트 케이스 로그에 자세한 인쇄를 수행합니다. &lt;code&gt;-silent_connections&lt;/code&gt; 플래그를 사용하여 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7483add893bc17e440cace13830412bb71cc8e83" translate="yes" xml:space="preserve">
          <source>The protocol stack does also handle things like automatic sending of acknowledgements, pending transactions, re-send of messages, supervision of connections etc.</source>
          <target state="translated">프로토콜 스택은 승인 자동 전송, 보류중인 트랜잭션, 메시지 재전송, 연결 감독 등과 같은 작업도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dd90b6a6ff5727727e4daa87f469034b2b5161f8" translate="yes" xml:space="preserve">
          <source>The protocol type &lt;code&gt;http&lt;/code&gt; is only to be used for the first line when an &lt;code&gt;HttpRequest&lt;/code&gt; or an &lt;code&gt;HttpResponse&lt;/code&gt; is expected. The following calls are to use &lt;code&gt;httph&lt;/code&gt; to get &lt;code&gt;HttpHeader&lt;/code&gt;s until &lt;code&gt;http_eoh&lt;/code&gt; is returned, which marks the end of the headers and the beginning of any following message body.</source>
          <target state="translated">프로토콜 유형 &lt;code&gt;http&lt;/code&gt; 는 &lt;code&gt;HttpRequest&lt;/code&gt; 또는 &lt;code&gt;HttpResponse&lt;/code&gt; 가 예상 될 때 첫 번째 행에만 사용 됩니다. 다음 호출은 사용할 수 있습니다 &lt;code&gt;httph&lt;/code&gt; 를 얻을 수 &lt;code&gt;HttpHeader&lt;/code&gt; 까지의 &lt;code&gt;http_eoh&lt;/code&gt; , 반환되는 마크 헤더의 끝 부분 및 다음과 같은 메시지 본문의 시작을.</target>
        </trans-unit>
        <trans-unit id="535cbad2526a219432d1c3150baaa80223145620" translate="yes" xml:space="preserve">
          <source>The protocol-independent architectural model on the network level is the well-known client-server model for management operations. This model is based on the client-server principle, where the manager (client) sends a request from a manager to an agent (server) when it accesses management information. The agent sends a reply back to the manager. There are two main differences to the normal client-server model:</source>
          <target state="translated">네트워크 수준에서 프로토콜 독립적 인 아키텍처 모델은 관리 작업을 위해 잘 알려진 클라이언트-서버 모델입니다. 이 모델은 클라이언트-서버 원칙을 기반으로하며, 여기서 관리자 (클라이언트)는 관리 정보에 액세스 할 때 관리자로부터 에이전트 (서버)로 요청을 보냅니다. 상담원은 관리자에게 회신을 보냅니다. 일반적인 클라이언트-서버 모델에는 두 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b945eead3d07f17de2dbf5269f341d725ae12921" translate="yes" xml:space="preserve">
          <source>The public key handling can be customized by implementing the following behaviours from &lt;code&gt;ssh&lt;/code&gt;:</source>
          <target state="translated">공개 키 처리는 &lt;code&gt;ssh&lt;/code&gt; 에서 다음 동작을 구현하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36b59dc532efc1e5c7b32fe689f2d2e6632ebccc" translate="yes" xml:space="preserve">
          <source>The public-key algorithm OID name atoms are as follows:</source>
          <target state="translated">공개 키 알고리즘 OID 이름 원자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a15b14b311d626350885eb389b70b1402e8566a" translate="yes" xml:space="preserve">
          <source>The purpose is to have a mechanism for a human to accept an otherwise faulty Certificate. In for example a web browser, you could get a question like</source>
          <target state="translated">목적은 사람이 다른 결함이있는 인증서를 수락 할 수있는 메커니즘을 갖는 것입니다. 예를 들어 웹 브라우저에서 다음과 같은 질문을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da4fdf22d3807497c8bad4c3fa2b75601232aeb" translate="yes" xml:space="preserve">
          <source>The purpose is to inform the &lt;code&gt;receiver&lt;/code&gt; of the result of the delivery (was the notification acknowledged or not) for each target.</source>
          <target state="translated">목적은 &lt;code&gt;receiver&lt;/code&gt; 에게 각 대상에 대한 전달 결과 (알림이 승인되었는지 여부)를 알리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3ba6f0037561095ae27788eb1fae4aa354ad82a" translate="yes" xml:space="preserve">
          <source>The purpose of notification filters is to allow for modification and/or suppression of a notification.</source>
          <target state="translated">통지 필터의 목적은 통지의 수정 및 / 또는 억제를 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e9701b065192ac8404e84b8b9c52feac07c04bf" translate="yes" xml:space="preserve">
          <source>The purpose of the Erlang ODBC application is to provide the programmer with an ODBC interface that has a Erlang/OTP touch and feel. So that the programmer may concentrate on solving his/her actual problem instead of struggling with pointers and memory allocation which is not very relevant for Erlang. This user guide will give you some information about technical issues and provide some examples of how to use the Erlang ODBC interface.</source>
          <target state="translated">Erlang ODBC 응용 프로그램의 목적은 프로그래머에게 Erlang / OTP 터치 및 느낌이있는 ODBC 인터페이스를 제공하는 것입니다. 따라서 프로그래머는 Erlang과 관련이없는 포인터 및 메모리 할당으로 어려움을 겪지 않고 실제 문제를 해결하는 데 집중할 수 있습니다. 이 사용자 안내서는 기술적 인 문제에 대한 정보를 제공하고 Erlang ODBC 인터페이스를 사용하는 방법에 대한 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3a6d9bf1c2c25a8cd3bddca112e22cfd0ab28d5" translate="yes" xml:space="preserve">
          <source>The purpose of the OTP_Mibs application is to provide an SNMP management information base for Erlang nodes.</source>
          <target state="translated">OTP_Mibs 애플리케이션의 목적은 Erlang 노드에 대한 SNMP 관리 정보 기반을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="83e927dfda3dd650e3137512b144dd84450aebd9" translate="yes" xml:space="preserve">
          <source>The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt;characters_to_binary/3&lt;/a&gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">이 함수의 목적은 주로 추가 처리를 위해 유니 코드 문자 조합을 목록 표현으로 순수한 유니 코드 문자열로 변환하는 것입니다. 외부 엔터티에 데이터를 쓰려면 reverse_characters_to_binary &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt;characters_to_binary/3&lt;/a&gt;&lt;/code&gt; 기능 이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7ff9c9b9dec703339d3bdb8b0c4fd2008e1ebebd" translate="yes" xml:space="preserve">
          <source>The purpose of the network interface filter is to allow for filtering of messages (accept or reject) receive and send. This is done on two levels:</source>
          <target state="translated">네트워크 인터페이스 필터의 목적은 수신 및 송신 메시지를 필터링 (수락 또는 거부) 할 수 있도록하는 것입니다. 이것은 두 가지 수준에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="380d75fe3dc7c1d9bcb891cc0287c70808132793" translate="yes" xml:space="preserve">
          <source>The purpose of the transaction sender is to accumulate transactions for a more efficient message sending. The transactions that are accumulated are transaction request and transaction ack. For transaction ack's the benefit is quite large, since the transactions are small and it is possible to have ranges (which means that transaction acks for transactions 1, 2, 3 and 4 can be sent as a range 1-4 in one transaction ack, instead of four separate transactions).</source>
          <target state="translated">트랜잭션 발신자의 목적은보다 효율적인 메시지 전송을 위해 트랜잭션을 누적하는 것입니다. 누적 된 트랜잭션은 트랜잭션 요청 및 트랜잭션 확인입니다. 트랜잭션 ACK의 경우 트랜잭션이 작고 범위를 가질 수 있으므로 이점이 상당히 큽니다 (즉, 트랜잭션 1, 2, 3 및 4에 대한 트랜잭션 ACK는 하나의 트랜잭션 ACK에서 범위 1-4로 전송 될 수 있음을 의미 함) 4 개의 개별 거래 대신).</target>
        </trans-unit>
        <trans-unit id="285eddd7bec05e75e8a6d971be6aadc6efc04add" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to do a minimal decode of Megaco message. A successfull result is a &lt;code&gt;'MegacoMessage'&lt;/code&gt; in which only version and mid has been initiated. This function is used by the megaco_messenger module when the &lt;code&gt;decode_message/3&lt;/code&gt; function fails to figure out the mid (the actual sender) of the message.</source>
          <target state="translated">이 기능의 목적은 Megaco 메시지의 최소 디코딩을 수행하는 것입니다. 성공적인 결과는 버전과 미드 만 &lt;code&gt;'MegacoMessage'&lt;/code&gt; 입니다. 이 함수는 &lt;code&gt;decode_message/3&lt;/code&gt; 함수가 메시지의 중간 (실제 발신자)을 파악하지 못하는 경우 megaco_messenger 모듈 에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8c094a70f3fb457644d9fe5a09333364897998e8" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to generate the usm- related security data needed for usm processing in the agent. Specifically, updating the usmUserTable.</source>
          <target state="translated">이 기능의 목적은 에이전트에서 usm 처리에 필요한 usm 관련 보안 데이터를 생성하는 것입니다. 특히 usmUserTable을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="e4997df3d063972a7e3b9575b1cf9377dc21bae3" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to simplify SNMP configuration for the test case writer. Many test cases can use default values for common operations and then no SNMP configuration files need to be supplied. When it is necessary to change particular configuration parameters, a subset of the relevant SNMP configuration files can be passed to &lt;code&gt;ct_snmp&lt;/code&gt; by &lt;code&gt;Common Test&lt;/code&gt; configuration files. For more specialized configuration parameters, a simple SNMP configuration file can be placed in the test suite data directory. To simplify the test suite, &lt;code&gt;Common Test&lt;/code&gt; keeps track of some of the SNMP manager information. This way the test suite does not have to handle as many input parameters as if it had to interface wthe OTP SNMP manager directly.</source>
          <target state="translated">이 모듈의 목적은 테스트 케이스 작성기의 SNMP 구성을 단순화하는 것입니다. 많은 테스트 사례가 일반적인 작업에 기본값을 사용할 수 있으므로 SNMP 구성 파일을 제공 할 필요가 없습니다. 이 특정 구성 매개 변수를 변경할 필요가있는 경우, 관련 SNMP 구성 파일의 부분 집합에 전달 될 수 &lt;code&gt;ct_snmp&lt;/code&gt; 에 의해 &lt;code&gt;Common Test&lt;/code&gt; 구성 파일. 보다 전문화 된 구성 매개 변수를 위해 간단한 SNMP 구성 파일을 테스트 스위트 데이터 디렉토리에 배치 할 수 있습니다. 테스트 스위트를 단순화하기 위해 &lt;code&gt;Common Test&lt;/code&gt; 는 일부 SNMP 관리자 정보를 추적합니다. 이 방법으로 테스트 스위트는 OTP SNMP 관리자와 직접 인터페이스해야하는 것처럼 많은 입력 매개 변수를 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d919b258d0197ec8d853aab267758bf87f5d968e" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to increase performance by reducing the number of operating system calls. Thus, the &lt;code&gt;write/2&lt;/code&gt; calls must be for sizes significantly less than &lt;code&gt;Size&lt;/code&gt;, and not interspersed by too many other file operations.</source>
          <target state="translated">이 옵션의 목적은 운영 체제 호출 수를 줄여 성능을 향상시키는 것입니다. 따라서 &lt;code&gt;write/2&lt;/code&gt; 호출은 &lt;code&gt;Size&lt;/code&gt; 보다 상당히 작은 크기 여야하며 너무 많은 다른 파일 조작에 의해 산재되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6764da434257370babfd601803893f5ca699a25d" translate="yes" xml:space="preserve">
          <source>The purpose of this section is to let the newcomer get started in quickly writing and executing some first simple tests with a &quot;learning by example&quot; approach. Most explanations are left for later sections. If you are not much into &quot;learning by example&quot; and prefer more technical details, go ahead and skip to the next section.</source>
          <target state="translated">이 섹션의 목적은 초보자가 &quot;예시 학습&quot;접근 방식을 사용하여 몇 가지 첫 번째 간단한 테스트를 빠르게 작성하고 시작하는 것입니다. 대부분의 설명은 이후 섹션에 남겨집니다. &quot;예를 들어 학습&quot;에 익숙하지 않고 기술적 인 세부 사항을 선호하는 경우 다음 섹션으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5baba518ef35fe89fecc8d2eabb40055ac16675f" translate="yes" xml:space="preserve">
          <source>The purpose of this tutorial is to describe different interoperability mechanisms that can be used when integrating a program written in Erlang with a program written in another programming language, from the Erlang programmer's perspective.</source>
          <target state="translated">이 학습서의 목적은 Erlang으로 작성된 프로그램을 Erlang 프로그래머의 관점에서 다른 프로그래밍 언어로 작성된 프로그램과 통합 할 때 사용할 수있는 다양한 상호 운용성 메커니즘을 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad7e63be85ec6284886f671e4aac3786bf5f89cd" translate="yes" xml:space="preserve">
          <source>The purpose of this user guide is to introduce you to the Erlang mode for Emacs and gives some relevant background information of the functions and features. See also &lt;code&gt;&lt;a href=&quot;erlang.el&quot;&gt;Erlang mode reference manual&lt;/a&gt;&lt;/code&gt; The purpose of the Erlang mode itself is to facilitate the developing process for the Erlang programmer.</source>
          <target state="translated">이 사용자 안내서의 목적은 Emacs 용 Erlang 모드를 소개하고 기능 및 특징에 대한 관련 배경 정보를 제공하는 것입니다. 참조 &lt;code&gt;&lt;a href=&quot;erlang.el&quot;&gt;Erlang mode reference manual&lt;/a&gt;&lt;/code&gt; 자체가 얼랑 프로그래머를위한 개발 과정을 촉진하는 것입니다 얼랑 모드의 목적.</target>
        </trans-unit>
        <trans-unit id="ea3039623e684f7c81037387c6d7f5eb72507985" translate="yes" xml:space="preserve">
          <source>The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present. This can be useful for subpatterns that are referenced as subroutines from elsewhere in the pattern (but see also section &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt;Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt;). Items other than subpatterns that have a {0} quantifier are omitted from the compiled pattern.</source>
          <target state="translated">수량 자 {0}이 (가) 허용되어 이전 항목과 수량자가없는 것처럼 표현식이 작동합니다. 패턴의 다른 곳에서 서브 루틴으로 참조되는 서브 패턴에 유용 할 수 있습니다 (단, 참조 용으로 만 서브 패턴 &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt;Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt; ). {0} 수량자를 갖는 서브 패턴 이외의 항목은 컴파일 된 패턴에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="9ffdab0f26f651e47a43589852883c8b5ecab0d9" translate="yes" xml:space="preserve">
          <source>The query asks for the restriction of external calls except the unresolved calls to calls to functions that are externally used but neither exported nor built-in functions (the &lt;code&gt;||&lt;/code&gt; operator restricts the used functions while the &lt;code&gt;|&lt;/code&gt; operator restricts the calling functions). The &lt;code&gt;-&lt;/code&gt; operator returns the difference of two sets, and the &lt;code&gt;+&lt;/code&gt; operator to be used below returns the union of two sets.</source>
          <target state="translated">쿼리는 외부에서 사용하지만 (내 보낸되지도 내장 함수하지도되는 함수 호출에 해결되지 않은 통화를 제외하고 외부 호출의 제한을 요청 &lt;code&gt;||&lt;/code&gt; 의 그동안 운영자가 사용하는 기능을 제한 &lt;code&gt;|&lt;/code&gt; 운영자가 호출 기능을 제한합니다). &lt;code&gt;-&lt;/code&gt; 오퍼레이터는 두 세트의 차분을 반환하고 &lt;code&gt;+&lt;/code&gt; 의 오퍼레이터는 리턴 아래 두 가지의 조합을 사용한다.</target>
        </trans-unit>
        <trans-unit id="f690a75130a74f61a6b149376be5c663bfe1f1d3" translate="yes" xml:space="preserve">
          <source>The queue can be manipulated from any threads if a port data lock is used. For more information, see &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;ErlDrvPDL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 데이터 잠금이 사용되는 경우 모든 스레드에서 큐를 조작 할 수 있습니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;ErlDrvPDL&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fca3c136aa3b7db81fe20cdb9588464345ea02d4" translate="yes" xml:space="preserve">
          <source>The ratio between the number of collisions and the number of tries (acquisitions) in percentage.</source>
          <target state="translated">충돌 횟수와 시도 횟수 (획득 횟수)의 비율 (백분율)입니다.</target>
        </trans-unit>
        <trans-unit id="44affb61a9f1b3e79f7f910ffd11f6983e2b7acd" translate="yes" xml:space="preserve">
          <source>The raw data pointed to by &lt;code&gt;data&lt;/code&gt; is only mutable after a call to &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt;enif_realloc_binary&lt;/a&gt;&lt;/code&gt;. All other functions that operate on a binary leave the data as read-only. A mutable binary must in the end either be freed with &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; or made read-only by transferring it to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. However, it does not have to occur in the same NIF call. Read-only binaries do not have to be released.</source>
          <target state="translated">원시 데이터가 가리키는 &lt;code&gt;data&lt;/code&gt; 를 호출 한 후에 만 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt;enif_realloc_binary&lt;/a&gt;&lt;/code&gt; . 바이너리에서 작동하는 다른 모든 기능은 데이터를 읽기 전용으로 남겨 둡니다. 가변 바이너리는 결국 &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; 로 해제 되거나 enif_make_binary 로 Erlang 용어로 전송하여 읽기 전용으로 &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt; 합니다. 그러나 동일한 NIF 호출에서 발생할 필요는 없습니다. 읽기 전용 바이너리는 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e697470bc64df4548085b65b4119eaa00152f6fc" translate="yes" xml:space="preserve">
          <source>The raw memory information can be decoded by the Crashdump Viewer tool. You can then see the stack dump, the message queue (if any), and the dictionary (if any).</source>
          <target state="translated">원시 메모리 정보는 Crashdump Viewer 도구로 디코딩 할 수 있습니다. 그런 다음 스택 덤프, 메시지 큐 (있는 경우) 및 사전 (있는 경우)을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b9348a6665f910941aa4666d77803d6bab3e84" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;ErrorDescription&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">읽기 조작이 실패했으며 &lt;code&gt;ErrorDescription&lt;/code&gt; 매개 변수 는 오류에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7bbc097f89bd9fc9542bcc569f782bd621e86844" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;What&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">읽기 작업이 실패했으며 매개 변수 &lt;code&gt;What&lt;/code&gt; 는 오류에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb6a39bb3dee1cf5c8904fe1074aac9c463a49da" translate="yes" xml:space="preserve">
          <source>The read was successful and &lt;code&gt;Terms&lt;/code&gt; is the list of successfully matched and read items.</source>
          <target state="translated">읽기에 성공했으며 &lt;code&gt;Terms&lt;/code&gt; 는 성공적으로 일치하고 읽은 항목의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dcfa32e23c0ed6b07d119f5cbe4a63799ba2a7c0" translate="yes" xml:space="preserve">
          <source>The reader of this section is assumed to be familiar with the following:</source>
          <target state="translated">이 섹션의 독자는 다음에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ba2a82a53accd93542c2130c8adecd6ee219c0ca" translate="yes" xml:space="preserve">
          <source>The reading failed and &lt;code&gt;FreadError&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">읽기에 실패했으며 &lt;code&gt;FreadError&lt;/code&gt; 는 오류에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="daa863f5699aef2a6313b5f617a1c72b21feead3" translate="yes" xml:space="preserve">
          <source>The real difference is instead in system characteristics, which is best shown with the mstone1 test.</source>
          <target state="translated">실제 차이점은 시스템 특성에 있으며, 이는 mstone1 테스트에서 가장 잘 나타납니다.</target>
        </trans-unit>
        <trans-unit id="45e718b5cc8c016eeb0b83bab7279b93e9d7f448" translate="yes" xml:space="preserve">
          <source>The reason for having this limit is that if the cache is large, the GC can potentially take a long time, during which the agent is locked.</source>
          <target state="translated">이 제한이있는 이유는 캐시가 큰 경우 에이전트가 잠기는 동안 GC에 시간이 오래 걸릴 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="188404504e5ffcfc4e22d678f33dc7b1dabcdeee" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of a compiled match specification is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="translated">컴파일 된 일치 스펙의 외부 표현이없는 이유는 성능입니다. 향후 릴리스에서는 변경 될 수 있지만이 인터페이스는 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d12e3451eede4d21837264efccb2d76d8bb6ff89" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of compiled match specifications is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="translated">컴파일 된 일치 스펙의 외부 표현이없는 이유는 성능입니다. 향후 릴리스에서는 변경 될 수 있지만이 인터페이스는 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="62037923291a9bc215c53f9d64f569edf7ad5f37" translate="yes" xml:space="preserve">
          <source>The reason for the dump is shown in the beginning of the file as:</source>
          <target state="translated">덤프 이유는 파일 시작 부분에 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2faab1fcd118d3b3332e3465dbb0be228ca6f80a" translate="yes" xml:space="preserve">
          <source>The reason for the latter is presumably interoperability: allowing arbitrary AVPs setting the M-bit in a command makes its interpretation implementation-dependent, since there's no guarantee that all implementations will understand the same set of arbitrary AVPs in the context of a given command. However, interpreting &lt;code&gt;AVP&lt;/code&gt; in a command grammar as any AVP, regardless of M-bit, renders 1.3.4 meaningless, since the receiver can simply ignore any AVP it thinks isn't relevant, regardless of the sender's intent.</source>
          <target state="translated">후자의 이유는 아마도 상호 운용성 때문일 수 있습니다. 명령에서 M- 비트를 설정하는 임의의 AVP를 허용하면 해석이 구현에 따라 달라집니다. 모든 구현이 주어진 명령의 맥락에서 동일한 임의의 AVP를 이해할 것이라는 보장이 없기 때문입니다. 그러나 M- 비트에 관계없이 명령 문법에서 &lt;code&gt;AVP&lt;/code&gt; 를 로 해석 하면 1.3.4는 의미가 없습니다. 수신자는 발신자의 의도와 상관없이 관련이 없다고 생각되는 모든 AVP를 무시할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="670dee16e7dda71243b144db55242f7df8863db8" translate="yes" xml:space="preserve">
          <source>The reason for this division of the interfaces into compile-time and runtime is that only runtime modules (&lt;code&gt;asn1rt*&lt;/code&gt;) need to be loaded in an embedded system.</source>
          <target state="translated">이러한 인터페이스를 컴파일 타임과 런타임으로 나누는 이유 는 임베디드 시스템에 런타임 모듈 ( &lt;code&gt;asn1rt*&lt;/code&gt; ) 만 로드하면되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="78fc68d51d1cbc8283fa7ece8361aa9511ea81ac" translate="yes" xml:space="preserve">
          <source>The reason for this function is that continuation terms contain compiled match specifications and therefore are invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent &lt;code&gt;select/1&lt;/code&gt; calls even though it has been stored on disk or on another node.</source>
          <target state="translated">이 함수의 이유는 연속 용어에 컴파일 된 일치 스펙이 포함되므로 외부 용어 형식으로 변환하면 무효화되기 때문입니다. 원래 일치 스펙이 그대로 유지되면 연속을 복원 할 수 있습니다. 즉, 디스크 또는 다른 노드에 저장된 경우에도 후속 &lt;code&gt;select/1&lt;/code&gt; 호출 에서 다시 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e66b56334bd4302b0b55eee5e555ae3f6f42859" translate="yes" xml:space="preserve">
          <source>The reason is that a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; contains a direct pointer to the binary data.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; 에 이진 데이터에 대한 직접 포인터가 포함되어 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="fa3e28310c9f5068c3bc594e80fb7f8131e7f277" translate="yes" xml:space="preserve">
          <source>The reason we get a deadlock in the first example is because when TAB is pressed to expand the function name, the group leader (which handles character input) calls &lt;code&gt;mymod:module_info()&lt;/code&gt;. This generates a trace message which, in turn, causes the tracer process to send an IO request to the group leader (by calling &lt;code&gt;io:format/2&lt;/code&gt;). We end up in a deadlock.</source>
          <target state="translated">첫 번째 예제에서 교착 상태가 발생하는 이유는 TAB을 눌러 함수 이름을 확장 할 때 문자 입력을 처리하는 그룹 리더가 &lt;code&gt;mymod:module_info()&lt;/code&gt; 호출하기 때문 입니다. 이는 추적 메시지를 생성하여 추적 프로그램 프로세스가 IO 요청을 그룹 리더에게 보내도록합니다 ( &lt;code&gt;io:format/2&lt;/code&gt; 호출 ). 우리는 교착 상태에 빠지게됩니다.</target>
        </trans-unit>
        <trans-unit id="d334c8815a940e1117cd6bf97ab09bf24cf15d4d" translate="yes" xml:space="preserve">
          <source>The recognized allocators are listed in &lt;code&gt;erts_alloc(3)&lt;/code&gt;. Information about super carriers can be obtained from ERTS 8.0 with &lt;code&gt;{allocator, erts_mmap}&lt;/code&gt; or from ERTS 5.10.4; the returned list when calling with &lt;code&gt;{allocator, mseg_alloc}&lt;/code&gt; also includes an &lt;code&gt;{erts_mmap, _}&lt;/code&gt; tuple as one element in the list.</source>
          <target state="translated">인식 된 할당자는 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 나열됩니다 . 슈퍼 캐리어에 대한 정보는 &lt;code&gt;{allocator, erts_mmap}&lt;/code&gt; 을 사용하는 ERTS 8.0 또는 ERTS 5.10.4에서 얻을 수 있습니다 . &lt;code&gt;{allocator, mseg_alloc}&lt;/code&gt; 호출 할 때 리턴 된 목록 에는 &lt;code&gt;{erts_mmap, _}&lt;/code&gt; 튜플도 목록의 한 요소로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1601ceca58dc5bb418d4d058642b8127306f81a6" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;file_info&lt;/code&gt; contains the following fields:</source>
          <target state="translated">&lt;code&gt;file_info&lt;/code&gt; 레코드 에는 다음 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="90fa624e6ef711e6538891034b680bc3cf375ce0" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;megaco_incr_timer&lt;/code&gt; contains the following fields:</source>
          <target state="translated">&lt;code&gt;megaco_incr_timer&lt;/code&gt; 레코드 에는 다음 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd91c53b0842e666e7eac373490635f53ee82f94" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;snmpa_notification_delivery_info&lt;/code&gt; contains the following fields:</source>
          <target state="translated">&lt;code&gt;snmpa_notification_delivery_info&lt;/code&gt; 레코드 에는 다음 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef7e07ae45347add7e7787bb739a3aea7c0c97a" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;xmlAttribute&lt;/code&gt; holds the name and value of an attribute in the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. All attributes of an element is a list of xmlAttribute in the field &lt;code&gt;attributes&lt;/code&gt; of the xmlElement record.</source>
          <target state="translated">레코드 &lt;code&gt;xmlAttribute&lt;/code&gt; 필드의의 속성의 이름과 값을 보유하고 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;value&lt;/code&gt; . 요소의 모든 속성은 xmlElement 레코드 의 필드 &lt;code&gt;attributes&lt;/code&gt; 에있는 xmlAttribute 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="18b3b71ec5bfcc1ff63cbc72d59db895c56c0f72" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_comment&lt;/code&gt; only contains the archive comment for a zip archive.</source>
          <target state="translated">&lt;code&gt;zip_comment&lt;/code&gt; 레코드 는 zip 아카이브에 대한 아카이브 주석 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="857d4f5792009846db2a99430f060ca57c895a3d" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_file&lt;/code&gt; contains the following fields:</source>
          <target state="translated">&lt;code&gt;zip_file&lt;/code&gt; 레코드 는 다음 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="72cb006aafe2a35c580dddc00f0e1af4643c65e2" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;{boss, klacke, bjarne}&lt;/code&gt; can also be inserted. This record contains an implicit reference to another employee that does not yet exist in the database. &lt;code&gt;Mnesia&lt;/code&gt; does not enforce this.</source>
          <target state="translated">레코드 &lt;code&gt;{boss, klacke, bjarne}&lt;/code&gt; 도 삽입 할 수 있습니다. 이 레코드에는 아직 데이터베이스에없는 다른 직원에 대한 암시 적 참조가 포함됩니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 이것을 시행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eeb48859b3ad695cfb58e1472606a8b95d102ac9" translate="yes" xml:space="preserve">
          <source>The record declarations for a module &lt;code&gt;M&lt;/code&gt; are placed in a separate &lt;code&gt;M.hrl&lt;/code&gt; file.</source>
          <target state="translated">모듈 &lt;code&gt;M&lt;/code&gt; 에 대한 레코드 선언 은 별도의 &lt;code&gt;M.hrl&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f84ddcf67fb899e512597e0ee97ecc7c382394" translate="yes" xml:space="preserve">
          <source>The record definition is found in xmerl.hrl.</source>
          <target state="translated">레코드 정의는 xmerl.hrl에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b708de2ffe05d9893e05e616dfbb164eb37b0f6f" translate="yes" xml:space="preserve">
          <source>The record initially returned by &lt;code&gt;megaco:connect/4,5&lt;/code&gt;. It identifies a &quot;virtual&quot; connection and may be reused after a reconnect (disconnect + connect).</source>
          <target state="translated">처음에 &lt;code&gt;megaco:connect/4,5&lt;/code&gt; 가 레코드를 리턴했습니다 . &quot;가상&quot;연결을 식별하고 다시 연결 한 후 다시 사용할 수 있습니다 (연결 끊기 + 연결).</target>
        </trans-unit>
        <trans-unit id="a7f4e92997b0d8825962c8c3544ff9c3495a9e48" translate="yes" xml:space="preserve">
          <source>The record is defined in the Kernel include file &lt;code&gt;&quot;inet.hrl&quot;&lt;/code&gt;.</source>
          <target state="translated">레코드는 커널 포함 파일 &lt;code&gt;&quot;inet.hrl&quot;&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="87950d43bd1bd589a1c9d9ae13c4a20a531dad00" translate="yes" xml:space="preserve">
          <source>The record must be defined in the shell to enable use of the record syntax in the examples:</source>
          <target state="translated">예제에서 레코드 구문을 사용하려면 셸에서 레코드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dc35961a83e47be02049c0ff9dabcb3687ccf9d" translate="yes" xml:space="preserve">
          <source>The record representation of the Diameter header. Values in a &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;&lt;a href=&quot;#decode-2&quot;&gt;decode/2&lt;/a&gt;&lt;/code&gt; are as extracted from the incoming message. Values set in an &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; passed to &lt;code&gt;&lt;a href=&quot;#encode-2&quot;&gt;encode/2&lt;/a&gt;&lt;/code&gt; are preserved in the encoded binary(), with the exception of &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;cmd_code&lt;/code&gt; and &lt;code&gt;application_id&lt;/code&gt;, all of which are determined by the &lt;code&gt;&lt;a href=&quot;#dictionary&quot;&gt;dictionary()&lt;/a&gt;&lt;/code&gt; in question.</source>
          <target state="translated">직경 헤더의 레코드 표현입니다. &lt;code&gt;&lt;a href=&quot;#decode-2&quot;&gt;decode/2&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 값 은 수신 메시지에서 추출 된 값입니다 . &lt;code&gt;&lt;a href=&quot;#encode-2&quot;&gt;encode/2&lt;/a&gt;&lt;/code&gt; 에 전달 된 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 설정된 값 은 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;cmd_code&lt;/code&gt; 및 &lt;code&gt;application_id&lt;/code&gt; 를 제외하고 인코딩 된 binary ()에 보존됩니다. 이 값은 모두 해당 &lt;code&gt;&lt;a href=&quot;#dictionary&quot;&gt;dictionary()&lt;/a&gt;&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f1ffbe66bd5cda775f3eecb9e76ac9a6773796b" translate="yes" xml:space="preserve">
          <source>The reference count of driver binary is normally to be decremented by calling &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버 바이너리의 참조 카운트는 일반적으로 &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; 를 호출하여 감소합니다 .</target>
        </trans-unit>
        <trans-unit id="d02f19c19b420c90f199ab4d6f0e29073cf27683" translate="yes" xml:space="preserve">
          <source>The reference material is divided into the following sections:</source>
          <target state="translated">참조 자료는 다음 섹션으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="14b2330f91efad717120789b2f96d3d8f50d2e67" translate="yes" xml:space="preserve">
          <source>The reference objects &lt;strong&gt;sub binaries&lt;/strong&gt; and &lt;strong&gt;match contexts&lt;/strong&gt; can reference part of a refc binary or heap binary.</source>
          <target state="translated">참조 객체 &lt;strong&gt;하위 이진&lt;/strong&gt; 및 &lt;strong&gt;일치 컨텍스트&lt;/strong&gt; 는 refc 이진 또는 힙 이진의 일부를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f3eb9a07f806c6c71dfeae710e0da778e14bc05" translate="yes" xml:space="preserve">
          <source>The registered name of the port, if any.</source>
          <target state="translated">포트의 등록 된 이름입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="c9cf711a7294ba24b8c0e11fc28d22a091e59813" translate="yes" xml:space="preserve">
          <source>The registered name of the process, if any.</source>
          <target state="translated">프로세스의 등록 된 이름입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="d5bafed5b0dd3a5d4eb9ad07383aa0c7c6a85578" translate="yes" xml:space="preserve">
          <source>The registered name, &lt;code&gt;RegName&lt;/code&gt;, can be any atom. The name can be ignored by the C code, or, for example, be used to distinguish between different types of messages. An example of Erlang code using short node names follows:</source>
          <target state="translated">등록 된 이름 인 &lt;code&gt;RegName&lt;/code&gt; 은 임의의 원자가 될 수 있습니다. 이름은 C 코드에서 무시하거나 예를 들어 다른 유형의 메시지를 구별하는 데 사용될 수 있습니다. 짧은 노드 이름을 사용하는 Erlang 코드의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1514fe84ab0f4ebd6e6cad9a7b7bbf021b9cbbe" translate="yes" xml:space="preserve">
          <source>The registered name, if any. If a registered name is not displayed, it can be that Debugger received information about the process before the name was registered. Try selecting &lt;strong&gt;Edit &amp;gt; Refresh&lt;/strong&gt;.</source>
          <target state="translated">등록 된 이름입니다 (있는 경우). 등록 된 이름이 표시되지 않으면 디버거가 이름이 등록되기 전에 프로세스에 대한 정보를 수신했을 수 있습니다. &lt;strong&gt;편집&amp;gt; 새로 고침을&lt;/strong&gt; 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="253fb5321acafacd5bcd81a207e0260e1e20f165" translate="yes" xml:space="preserve">
          <source>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. For any action resulting in a change to the global name table, all tables on other nodes are automatically updated.</source>
          <target state="translated">등록 된 이름은 모든 노드의 복제본 전역 이름 테이블에 저장됩니다. 중앙 저장 지점이 없습니다. 따라서 이름을 pid로 변환하는 것은 항상 로컬에서 수행되므로 빠릅니다. 글로벌 이름 테이블을 변경하는 조치의 경우 다른 노드의 모든 테이블이 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="b656ecffd1ced10be89c73c0264120c641a1a963" translate="yes" xml:space="preserve">
          <source>The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type.</source>
          <target state="translated">레지스트리에는 키와 값이 포함되어 있습니다. 키는 파일 시스템의 디렉토리와 유사하며 계층 구조를 형성합니다. 값은 파일과 유사하며 이름과 값 및 유형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f19e0edc2bdf4a111b804cb06a4a4fda7a24377" translate="yes" xml:space="preserve">
          <source>The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs.</source>
          <target state="translated">레지스트리는 Windows에서 다양한 시스템 및 소프트웨어 정보를 저장하는 데 사용되는 계층 적 데이터베이스입니다. 설치 데이터가 포함되어 있으며 설치 프로그램 및 시스템 프로그램에 의해 업데이트됩니다. Erlang 설치 프로그램은 Erlang에 필요한 데이터를 추가하여 레지스트리를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a1df08771ef4b4eb79805f54d0af976d930c81c1" translate="yes" xml:space="preserve">
          <source>The registry must have been opened in write mode.</source>
          <target state="translated">레지스트리가 쓰기 모드로 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e31d2327ae3a594ef721ad76afd4e76d34b773c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;(|at)&lt;/code&gt; first match at the initial position of string &lt;code&gt;cat&lt;/code&gt;, giving the result set &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; (the second &lt;code&gt;{0,0}&lt;/code&gt; is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</source>
          <target state="translated">정규 표현식 &lt;code&gt;(|at)&lt;/code&gt; 은 문자열 &lt;code&gt;cat&lt;/code&gt; 의 초기 위치에서 먼저 일치 하여 결과 세트 &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; 을 제공합니다 (두 번째 &lt;code&gt;{0,0}&lt;/code&gt; 은 하위 표현식으로 표시됨). 괄호). 경기의 길이가 0이므로 아직 다음 위치로 진행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c67bde651eeeb2e55477d91b265e707252cb8bd3" translate="yes" xml:space="preserve">
          <source>The regular expression is specified as a Unicode &lt;code&gt;charlist()&lt;/code&gt; and the resulting regular expression code is to be run against a valid Unicode &lt;code&gt;charlist()&lt;/code&gt; subject. Also consider option &lt;code&gt;ucp&lt;/code&gt; when using Unicode characters.</source>
          <target state="translated">정규식은 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; 로 지정되며 결과 정규식 코드는 유효한 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; 주제 에 대해 실행 됩니다. 유니 코드 문자를 사용할 때는 옵션 &lt;code&gt;ucp&lt;/code&gt; 도 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b1e3caf6818ade884c58fbfd440b868fffc15b" translate="yes" xml:space="preserve">
          <source>The regular expressions allowed here is a subset of the set found in &lt;code&gt;egrep&lt;/code&gt; and in the AWK programming language, as defined in the book, The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger. They are composed of the following characters:</source>
          <target state="translated">여기에 허용 된 정규식은 AVReho, BW Kernighan, PJ Weinberger의 AWK 프로그래밍 언어 책에 정의 된대로 &lt;code&gt;egrep&lt;/code&gt; 및 AWK 프로그래밍 언어로 된 세트의 하위 세트입니다 . 다음과 같은 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4fcc0ee2bcb5481ad7e8a8560c012d54b3a581" translate="yes" xml:space="preserve">
          <source>The relation of equality between the elements of {a,b,c}:</source>
          <target state="translated">{a, b, c}의 요소들 사이의 평등 관계 :</target>
        </trans-unit>
        <trans-unit id="0c26a1fbdd58094ae590c77744a027cfe086295e" translate="yes" xml:space="preserve">
          <source>The relationships between the predefined variables &lt;code&gt;XU&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and a few others are worth elaborating upon. The reference manual mentions two ways of expressing the set of all functions, one that focuses on how they are defined: &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt;, and one that focuses on how they are used: &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt;. The reference also mentions some &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; about the variables:</source>
          <target state="translated">미리 정의 된 변수 &lt;code&gt;XU&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 와 다른 몇 가지 관계는 자세히 설명 할 가치가 있습니다. : 참조 설명서는 두 가지가 정의하는 방법에 초점을 맞추고 모든 기능을 하나의 집합을 표현하는 방법을 언급 &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt; 그들이 사용하는 방법에 초점을 맞추고, 한 : &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt; . 참고 문헌 에는 변수에 대한 몇 가지 &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; 언급 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c6e207d55ada23ec986425dc6bc5e23db12059" translate="yes" xml:space="preserve">
          <source>The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] &amp;times; ... &amp;times; Y[n]) to Z. The &lt;strong id=&quot;tuple_relative_product&quot;&gt;relative product&lt;/strong&gt; of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &amp;lt;= i &amp;lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] &amp;times; ... &amp;times; X[n]. The &lt;strong id=&quot;multiple_relative_product&quot;&gt;multiple relative product&lt;/strong&gt; of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &amp;lt;= i &amp;lt;= n}.</source>
          <target state="translated">이진 관계의 상대적인 곱은 다음과 같이 n 개의 관계로 일반화 될 수 있습니다. TR을 X에서 Y [i]까지의 이진 관계의 순서 집합 (R [1], ..., R [n])으로하고 S를 (Y [1] &amp;times; ... &amp;times; Y [n의 이진 관계로하자. TR과 S 의 &lt;strong id=&quot;tuple_relative_product&quot;&gt;상대 곱은&lt;/strong&gt; X에서 Z 로의 이진 관계 T로 정의됩니다. 따라서 각 T &amp;lt;= i에 대해 Y [i]에 요소 y [i]가있는 경우에만 x T z가 정의됩니다. x = [y] 및 (y [1], ..., y [n]) Sz가되도록 n = n. 이제 TR을 X [i]에서 Y [i] 로의 이진 관계의 순서화 된 세트 (R [1], ..., R [n])로하고 S는 X [1] &amp;times; ... &amp;times;의 서브 세트라고하자. X [n]. TR과 S 의 &lt;strong id=&quot;multiple_relative_product&quot;&gt;다중 상대 곱은&lt;/strong&gt; 집합 {z : z = ((x [1], ..., x [n]), (y [1], ..., y [n] )) S의 일부 (x [1], ..., x [n]) 및 R [i]의 일부 (x [i], y [i]), 1 &amp;lt;= i &amp;lt;= n}에 대해.</target>
        </trans-unit>
        <trans-unit id="1a5a729dfd664ee2cc4b65eb400d7906d640d28a" translate="yes" xml:space="preserve">
          <source>The relative product of two functions F1 and F2 is called the &lt;strong id=&quot;composite&quot;&gt;composite&lt;/strong&gt; of F1 and F2 if the range of F1 is a subset of the domain of F2.</source>
          <target state="translated">F1 의 범위가 F2 도메인의 부분 집합 인 경우 두 함수 F1 및 F2의 상대 곱을 F1 및 F2의 &lt;strong id=&quot;composite&quot;&gt;합성&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="c3e4729853dcefec28c04c62495d1227e52695db" translate="yes" xml:space="preserve">
          <source>The release handler at a node running on a diskless machine, or with a read-only file system, must be configured accordingly using the following SASL configuration parameters (for details, see &lt;code&gt;sasl(6)&lt;/code&gt;):</source>
          <target state="translated">디스크가없는 시스템에서 실행되거나 읽기 전용 파일 시스템으로 실행되는 노드의 릴리스 핸들러는 다음 SASL 구성 매개 변수를 사용하여 적절히 구성해야합니다 (자세한 내용은 &lt;code&gt;sasl(6)&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="aba90e774f5b7292d69eb5ee7c87083b704de367" translate="yes" xml:space="preserve">
          <source>The release handler can also be used to unpack and install release packages when not running Erlang as an embedded system. However, in this case the user must somehow ensure that correct boot scripts and configuration files are used if the system must be restarted.</source>
          <target state="translated">릴리스 핸들러를 사용하여 Erlang을 임베디드 시스템으로 실행하지 않을 때 릴리스 패키지의 압축을 풀고 설치할 수도 있습니다. 그러나이 경우 시스템을 다시 시작해야하는 경우 사용자는 올바른 부팅 스크립트 및 구성 파일을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a98562301df489f924334591464c2abdffdac36" translate="yes" xml:space="preserve">
          <source>The release handler evalutes &lt;code&gt;apply(M, F, A)&lt;/code&gt;.</source>
          <target state="translated">릴리스 핸들러는 &lt;code&gt;apply(M, F, A)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a5810b19374ebd0aa36b0ddc3dbb430e23ad41e2" translate="yes" xml:space="preserve">
          <source>The release handler process is a locally registered process on each node. When a release is installed in a distributed system, the release handler on each node must be called. The release installation can be synchronized between nodes. From an operator view, it can be unsatisfactory to specify each node. The aim is to install one release package in the system, no matter how many nodes there are. It is recommended that software management functions are written that take care of this problem. Such a function can have knowledge of the system architecture, so it can contact each individual release handler to install the package.</source>
          <target state="translated">릴리스 핸들러 프로세스는 각 노드에서 로컬로 등록 된 프로세스입니다. 분배 시스템에 릴리스가 설치되면 각 노드의 릴리스 핸들러를 호출해야합니다. 릴리스 설치는 노드간에 동기화 될 수 있습니다. 운영자보기에서 각 노드를 지정하는 것이 불만족 스러울 수 있습니다. 목표는 노드 수에 관계없이 시스템에 하나의 릴리스 패키지를 설치하는 것입니다. 이 문제를 해결하는 소프트웨어 관리 기능을 작성하는 것이 좋습니다. 이러한 기능은 시스템 아키텍처에 대한 지식이 있으므로 각 개별 릴리스 핸들러에 문의하여 패키지를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d789ea08f7bf36cfa8a0d6324e5d810748f8d2a" translate="yes" xml:space="preserve">
          <source>The release handler suspends, asks for code change, and resumes processes by calling the functions &lt;code&gt;sys:suspend/1,2&lt;/code&gt;, &lt;code&gt;sys:change_code/4,5&lt;/code&gt;, and &lt;code&gt;sys:resume/1,2&lt;/code&gt;, respectively.</source>
          <target state="translated">릴리스 핸들러는 각각 &lt;code&gt;sys:suspend/1,2&lt;/code&gt; , &lt;code&gt;sys:change_code/4,5&lt;/code&gt; 및 &lt;code&gt;sys:resume/1,2&lt;/code&gt; 함수를 호출하여 코드 변경을 요청하고 프로세스를 재개합니다 .</target>
        </trans-unit>
        <trans-unit id="bd503abbdadf3c3e7f2d6dab188fa7588e61f6b8" translate="yes" xml:space="preserve">
          <source>The release handling instructions for adding, removing, and restarting applications apply to primary applications only. There are no corresponding instructions for included applications. However, since an included application is really a supervision tree with a topmost supervisor, started as a child process to a supervisor in the including application, a &lt;code&gt;relup&lt;/code&gt; file can be manually created.</source>
          <target state="translated">응용 프로그램을 추가, 제거 및 다시 시작하기위한 릴리스 처리 지침은 기본 응용 프로그램에만 적용됩니다. 포함 된 응용 프로그램에 해당하는 지침이 없습니다. 그러나 포함 된 응용 프로그램은 실제로 최상위 관리자가있는 감독 트리이므로 포함 응용 프로그램의 관리자에게 자식 프로세스로 시작되므로 &lt;code&gt;relup&lt;/code&gt; 파일을 수동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3463f0904903fe50d36a8d31b7efcf59b3d94b17" translate="yes" xml:space="preserve">
          <source>The release of a maintenance patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; version while the release of an emergency patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; version. This is however not necessarily always the case since changes of OTP versions are based on the actual changes in the code and not based on whether the patch was planned or not. For more information see the &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; section above.</source>
          <target state="translated">유지 보수 패치 패키지의 릴리스는 일반적으로 OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 버전의 증가를 의미하고 응급 패치 패키지의 릴리스는 일반적으로 OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; 버전 의 증가를 의미합니다 . 그러나 OTP 버전의 변경은 코드의 실제 변경을 기반으로하고 패치의 계획 여부를 기반으로하지 않기 때문에 반드시 그런 것은 아닙니다. 자세한 내용은 위 의 &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f38068eb9610d0b0cbd1a9bc480aef4c5039577" translate="yes" xml:space="preserve">
          <source>The release package by default contains:</source>
          <target state="translated">릴리스 패키지에는 기본적으로 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1ddf2f95ffb2351a4606d3527df333525dbf30af" translate="yes" xml:space="preserve">
          <source>The release package can be &lt;strong&gt;unpacked&lt;/strong&gt;, which extracts the files. An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The currently used version of the release is then upgraded or downgraded to the specified version by evaluating the instructions in the &lt;code&gt;relup&lt;/code&gt; file. An installed release can be made &lt;strong&gt;permanent&lt;/strong&gt;. Only one permanent release can exist in the system, and this release is used if the system is restarted. An installed release, except the permanent one, can be &lt;strong&gt;removed&lt;/strong&gt;. When a release is removed, all files belonging to that release only are deleted.</source>
          <target state="translated">릴리즈 패키지의 &lt;strong&gt;압축을 풀면&lt;/strong&gt; 파일이 추출됩니다. 압축이 풀린 릴리스를 &lt;strong&gt;설치할&lt;/strong&gt; 수 있습니다 . 그런 다음 &lt;code&gt;relup&lt;/code&gt; 파일 의 지침을 평가하여 현재 사용되는 버전의 릴리스를 지정된 버전으로 업그레이드하거나 다운 그레이드 합니다. 설치된 릴리스를 &lt;strong&gt;영구적&lt;/strong&gt; 으로 만들 수 있습니다 . 시스템에는 하나의 영구 릴리스 만 존재할 수 있으며 시스템이 다시 시작되면이 릴리스가 사용됩니다. 영구 릴리스를 제외한 설치된 릴리스는 &lt;strong&gt;제거&lt;/strong&gt; 할 수 있습니다 . 릴리스가 제거되면 해당 릴리스에 속하는 모든 파일 만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b6c34e733e444ceb133eb0558e587c5c6c416c" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is compared with all release resource files &lt;code&gt;Name2.rel&lt;/code&gt;, specified in &lt;code&gt;UpFrom&lt;/code&gt; and &lt;code&gt;DownTo&lt;/code&gt;. For each such pair, the following is deducted:</source>
          <target state="translated">릴리스 리소스 파일 &lt;code&gt;Name.rel&lt;/code&gt; 은 모든 버전의 리소스 파일과 비교 &lt;code&gt;Name2.rel&lt;/code&gt; 에 지정된 &lt;code&gt;UpFrom&lt;/code&gt; 및 &lt;code&gt;DownTo&lt;/code&gt; . 이러한 각 쌍에 대해 다음이 공제됩니다.</target>
        </trans-unit>
        <trans-unit id="7359f911881a84330db66568ed156a10773a2e38" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine the version and modules of each application (keys &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;).</source>
          <target state="translated">릴리스 자원 파일 &lt;code&gt;Name.rel&lt;/code&gt; 을 읽고 어떤 응용 프로그램이 릴리스에 포함되는지 판별합니다. 그런 다음 관련 응용 프로그램 리소스 파일 &lt;code&gt;App.app&lt;/code&gt; 를 읽어 각 응용 프로그램의 버전과 모듈을 확인합니다 (keys &lt;code&gt;vsn&lt;/code&gt; 및 &lt;code&gt;modules&lt;/code&gt; , &lt;code&gt;app(4)&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="20395e6c5537d7e841a28ec3e32487d66bee87cf" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine which modules to be loaded, and if and how the applications are to be started. (Keys &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;.</source>
          <target state="translated">릴리스 자원 파일 &lt;code&gt;Name.rel&lt;/code&gt; 을 읽고 어떤 응용 프로그램이 릴리스에 포함되는지 판별합니다. 그런 다음 관련 응용 프로그램 리소스 파일 &lt;code&gt;App.app&lt;/code&gt; 을 읽어서로드 할 모듈과 응용 프로그램 시작 여부 및 방법을 결정합니다. (키 &lt;code&gt;modules&lt;/code&gt; 및 &lt;code&gt;mod&lt;/code&gt; 는 &lt;code&gt;app(4)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eefac0bf9340fed3bf570202c8d7eea59ecf327" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system) and the file is therefore now instead duplicated in the tar file so no manual copying is necessary.</source>
          <target state="translated">릴리스 자원 파일 &lt;code&gt;mysystem.rel&lt;/code&gt; 이 tar 파일에 복제되었습니다. 원래이 파일은 &lt;code&gt;release_handler&lt;/code&gt; 가이 파일을 별도로 추출 할 수 있도록 &lt;code&gt;releases&lt;/code&gt; 디렉토리 에만 저장되었습니다 . tar 파일의 압축을 풀면 &lt;code&gt;release_handler&lt;/code&gt; 는 자동으로 파일을 &lt;code&gt;releases/FIRST&lt;/code&gt; 에 복사합니다 . 그러나 때로는 tar 파일이 &lt;code&gt;release_handler&lt;/code&gt; 를 포함하지 않고 (예를 들어, 첫 번째 대상 시스템의 압축을 풀 때) 압축 이 풀리 므로 파일이 tar 파일에 대신 복제되므로 수동 복사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c80217b964ae1583cdca52537267d331ce978fc" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system). The file is therefore now instead duplicated in the tar file so no manual copying is needed.</source>
          <target state="translated">릴리스 자원 파일 &lt;code&gt;mysystem.rel&lt;/code&gt; 이 tar 파일에 복제되었습니다. 원래이 파일은 &lt;code&gt;release_handler&lt;/code&gt; 가이 파일을 별도로 추출 할 수 있도록 &lt;code&gt;releases&lt;/code&gt; 디렉토리 에만 저장되었습니다 . tar 파일의 압축을 풀면 &lt;code&gt;release_handler&lt;/code&gt; 는 자동으로 파일을 &lt;code&gt;releases/FIRST&lt;/code&gt; 에 복사합니다 . 그러나 때로는 tar 파일이 &lt;code&gt;release_handler&lt;/code&gt; 를 포함하지 않고 (예를 들어, 첫 번째 대상 시스템의 압축을 풀 때) 압축이 풀립니다. 따라서 파일은 이제 tar 파일에 복제되므로 수동 복사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ef92a0cda894349ddeef7379b503e49a64bdb11" translate="yes" xml:space="preserve">
          <source>The release resource file is to be called &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">릴리스 리소스 파일의 이름은 &lt;code&gt;Name.rel&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5471bf3aa3be047811963240dcf5d4400757add" translate="yes" xml:space="preserve">
          <source>The release resource file is used to generate &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt;. A system that is transferred to and installed at another site is called a &lt;strong&gt;target system&lt;/strong&gt;. How to use a release package to create a target system is described in System Principles.</source>
          <target state="translated">릴리스 자원 파일은 &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt; 를 생성하는 데 사용 됩니다 . 다른 사이트로 전송되어 설치되는 &lt;strong&gt;시스템을 대상 시스템&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 릴리스 패키지를 사용하여 대상 시스템을 작성하는 방법은 시스템 원칙에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c96a363d42d5cbc941b3bdee5cae6301bb427b" translate="yes" xml:space="preserve">
          <source>The releases directory (&lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</source>
          <target state="translated">릴리스 디렉토리 ( &lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0ac93c2480f7003ed1b072da8ef587cc263275" translate="yes" xml:space="preserve">
          <source>The releases page is incomplete and very experimental.</source>
          <target state="translated">릴리스 페이지는 불완전하고 매우 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="fca42c3d6efd5f3bf7036a14ae119c2bac9a56a9" translate="yes" xml:space="preserve">
          <source>The remaining Erlang script file can either contain Erlang &lt;strong&gt;source code&lt;/strong&gt;, an &lt;strong&gt;inlined beam file&lt;/strong&gt;, or an &lt;strong&gt;inlined archive file&lt;/strong&gt;.</source>
          <target state="translated">나머지 Erlang 스크립트 파일에는 Erlang &lt;strong&gt;소스 코드&lt;/strong&gt; , &lt;strong&gt;인라인 빔 파일&lt;/strong&gt; 또는 &lt;strong&gt;인라인 아카이브 파일이&lt;/strong&gt; 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="839a2a9520ffa3810212231d0366ad625cbea04a" translate="yes" xml:space="preserve">
          <source>The remaining arguments are pointers to callback functions that can be used to initialize the library. They are not used in this simple example, hence they are all set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">나머지 인수는 라이브러리를 초기화하는 데 사용할 수있는 콜백 함수에 대한 포인터입니다. 이 간단한 예제에서는 사용되지 않으므로 모두 &lt;code&gt;NULL&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="848fe4988b3ebd532672ddf229d63bf17a87732d" translate="yes" xml:space="preserve">
          <source>The remaining filters only show function calls and function returns. All other trace message are discarded. To get the most out of these filters, &lt;code&gt;et_viewer&lt;/code&gt; must know the caller of each function and the time of return. This can be obtained using both the &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; flags when tracing. Notice that flag &lt;code&gt;return_to&lt;/code&gt; only works with local call trace, that is, when trace patterns are set with &lt;code&gt;ttb:tpl&lt;/code&gt;.</source>
          <target state="translated">나머지 필터는 함수 호출 및 함수 리턴 만 표시합니다. 다른 모든 추적 메시지는 삭제됩니다. 이러한 필터를 &lt;code&gt;et_viewer&lt;/code&gt; 하려면 et_viewer 가 각 함수의 호출자와 리턴 시간을 알아야합니다. 추적 할 때 &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;return_to&lt;/code&gt; 플래그를 사용하여 얻을 수 있습니다 . &lt;code&gt;return_to&lt;/code&gt; 플래그 는 로컬 호출 추적, 즉 추적 패턴이 &lt;code&gt;ttb:tpl&lt;/code&gt; 으로 설정된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ff5ca4f7571fd6b542abb7d48ce27d3b2fc439a8" translate="yes" xml:space="preserve">
          <source>The remote host &lt;code&gt;node&lt;/code&gt; is unreachable.</source>
          <target state="translated">원격 호스트 &lt;code&gt;node&lt;/code&gt; 에 도달 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d37d54820fa9581d298dd9136f05c8334760d7a0" translate="yes" xml:space="preserve">
          <source>The remote mid (of the connection). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="translated">(연결의) 원격 중간. &lt;code&gt;megaco_mid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba62da86bb3f99cdfb2879e83169ae1e52ad3de4" translate="yes" xml:space="preserve">
          <source>The remote process was monitoring the local process at the time of the crash.</source>
          <target state="translated">원격 프로세스가 충돌 당시 로컬 프로세스를 모니터링하고있었습니다.</target>
        </trans-unit>
        <trans-unit id="f6bb61a4811825e7030b032141e0fc103f13c80c" translate="yes" xml:space="preserve">
          <source>The remote username of the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트의 원격 사용자 이름 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="87cb1661c7bb66858ea881ceaeef4b6250aa903b" translate="yes" xml:space="preserve">
          <source>The renaming affects only remote calls (also when disguised by import declarations); local calls within a module are not affected, and no function definitions are renamed. Since the arity cannot change, the new name is represented by &lt;code&gt;{NewModule, NewName}&lt;/code&gt; only. Only calls matching the specified arity will match; multiple entries are necessary for renaming calls to functions that have the same module and function name, but different arities.</source>
          <target state="translated">이름 변경은 원격 호출에만 영향을줍니다 (가져 오기 선언으로 위장한 경우). 모듈 내의 로컬 호출은 영향을받지 않으며 함수 정의의 이름이 바뀌지 않습니다. arity는 변경할 수 없으므로 새 이름은 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; 만 표시됩니다. 지정된 arity와 일치하는 통화 만 일치합니다. 동일한 모듈 및 기능 이름을 갖지만 다른 특성을 가진 함수에 대한 호출의 이름을 바꾸려면 여러 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7db0a5b5bf696ee011ef06c85df210d03986dfa2" translate="yes" xml:space="preserve">
          <source>The repair time is still proportional to the number of records in the file, but Dets repairs used to be much slower in the past. Dets has been massively rewritten and improved.</source>
          <target state="translated">복구 시간은 여전히 ​​파일의 레코드 수에 비례하지만 Dets 복구는 과거에 훨씬 느려졌습니다. Det는 크게 재 작성되고 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2c4a2bf8d01876589d2d63a72ca740faf035967" translate="yes" xml:space="preserve">
          <source>The replacement string can contain the special character &lt;code&gt;&amp;amp;&lt;/code&gt;, which inserts the whole matching expression in the result, and the special sequence &lt;code&gt;\&lt;/code&gt;N (where N is an integer &amp;gt; 0), &lt;code&gt;\g&lt;/code&gt;N, or &lt;code&gt;\g{&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</source>
          <target state="translated">대체 문자열에는 특수 문자 &lt;code&gt;&amp;amp;&lt;/code&gt; 가 포함될 수 있으며 결과에 일치하는 전체 표현식을 삽입하고 특수 시퀀스 &lt;code&gt;\&lt;/code&gt; N (여기서 N은 정수&amp;gt; 0), &lt;code&gt;\g&lt;/code&gt; N 또는 &lt;code&gt;\g{&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; 을 포함합니다. 하위 표현식 번호 N이 결과에 삽입됩니다. 해당 번호의 하위 표현식이 정규 표현식에 의해 생성되지 않으면 아무것도 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faa500aee01a190343697194d03c438c2c602d2a" translate="yes" xml:space="preserve">
          <source>The reply will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">응답은 snmpm_user 콜백 함수 &lt;code&gt;handle_pdu&lt;/code&gt; 에 대한 호출을 통해 사용자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a4f1cc106b1e894d4c96e8e317dc640fccb08d0" translate="yes" xml:space="preserve">
          <source>The reply, if it arrives, will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">응답이 도착하면 snmpm_user 콜백 함수 &lt;code&gt;handle_pdu&lt;/code&gt; 에 대한 호출을 통해 사용자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f6b172375ebcae29181dbc0b6ea9f54803c80f5" translate="yes" xml:space="preserve">
          <source>The report browser is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; defined in STDLIB.</source>
          <target state="translated">보고서 브라우저는 &lt;code&gt;log_mf_h&lt;/code&gt; 정의 된 오류 로거 핸들러 log_mf_h에 의해 작성된 오류 보고서를 찾아보고 형식화하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="462562f8f81a87927a15414f09bedcc8da9f2dcf" translate="yes" xml:space="preserve">
          <source>The reports are matched using the &lt;code&gt;proplists&lt;/code&gt; module in STDLIB. The report must be a proplist to be matched against any of the filters.</source>
          <target state="translated">보고서는 STDLIB 의 &lt;code&gt;proplists&lt;/code&gt; 모듈을 사용하여 일치됩니다 . 보고서는 필터와 일치하는 proplist 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3841a22e3cae4249c1648495d6d06b7dc360f0ae" translate="yes" xml:space="preserve">
          <source>The representation for an empty list, that is, the Erlang syntax &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">비어있는 목록, 즉 Erlang 구문 &lt;code&gt;[]&lt;/code&gt; 을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="90aa0c68b7c44e3dde7bae01a4485de7f117fcb2" translate="yes" xml:space="preserve">
          <source>The representation of a Diameter message as passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; or returned from a &lt;code&gt;handle_request/3&lt;/code&gt; callback. The record representation is as outlined in &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;: a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt;. Any of the formats is accepted at encode.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 에 전달 되거나 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 에서 반환 된 Diameter 메시지 표현 . 레코드 표현은 &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다 . 사전 파일에 정의 된 메시지는 각 구성 요소 AVP에 대해 하나의 필드가있는 레코드로 인코딩됩니다. 마찬가지로, 메시지는 헤드가 원자 값 메시지 이름 (관련 사전 파일에 지정된대로)이고 꼬리가 AVP 이름 / 값 쌍의 목록이거나 AVP에서 키가 입력 된 맵인 목록으로 인코딩 될 수 있습니다. 이름. 디코딩시 형식은 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt; 에 의해 결정됩니다 . 모든 형식은 인코딩시 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="82a411d117dc57a26bcb9e1f9d378e3ca11f15b7" translate="yes" xml:space="preserve">
          <source>The req_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">이 함수에 대한 req_data () 인수는 handle_trans_request / 3에 의해 리턴 된 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="23e7ef624fc47862089915bb4bc3e847e83284d8" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;Type&lt;/code&gt; as passed to &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;. This is only mandatory when the connection has been initiated by this node. That is, the connection is set up via &lt;code&gt;setup/5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 에 전달 된 요청 &lt;code&gt;Type&lt;/code&gt; 입니다. 이 노드에서 연결을 시작한 경우에만 필수입니다. 즉, 연결은 &lt;code&gt;setup/5&lt;/code&gt; 를 통해 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="bb7e74979895ad253263a88483e0213dfefa217d" translate="yes" xml:space="preserve">
          <source>The request is &lt;strong&gt;ignored&lt;/strong&gt; because &lt;code&gt;net_kernel&lt;/code&gt; is busy changing &lt;code&gt;net_ticktime&lt;/code&gt; to &lt;code&gt;NewNetTicktime&lt;/code&gt; seconds.</source>
          <target state="translated">요청이되어 &lt;strong&gt;무시&lt;/strong&gt; 하기 때문에 &lt;code&gt;net_kernel&lt;/code&gt; 은 바쁜 변화입니다 &lt;code&gt;net_ticktime&lt;/code&gt; 에 &lt;code&gt;NewNetTicktime&lt;/code&gt; 의 초.</target>
        </trans-unit>
        <trans-unit id="8e8fce11312bcfaed7ec364cadd3a5f46ff33d51" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. &lt;code&gt;cast&lt;/code&gt;, and thus &lt;code&gt;free&lt;/code&gt;, then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">요청은 메시지로 작성되어 &lt;code&gt;gen_server&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;cast&lt;/code&gt; , 따라서 &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;ok&lt;/code&gt; 를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="03229c07c994ef8bacaf94e79a42852e8c89a6f8" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{reply,Reply,State1}&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is the reply that is to be sent back to the client, and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">요청은 메시지로 작성되어 &lt;code&gt;gen_server&lt;/code&gt; 로 전송됩니다 . 요청이 수신되면 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt; 호출 하여 튜플 &lt;code&gt;{reply,Reply,State1}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;Reply&lt;/code&gt; 다시 클라이언트로 전송되는 응답이며, &lt;code&gt;State1&lt;/code&gt; 정이 의 상태에 대한 새 값입니다 &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6363c9ddb932fe00abea80ec408ab4c1cea65ddc" translate="yes" xml:space="preserve">
          <source>The request line as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트에서 온 요청 라인 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e51eb4e82ec44b07e0af2fe79e985e993a82848" translate="yes" xml:space="preserve">
          <source>The request line exactly as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트에서 온 요청 라인 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3416c5291401473a7cf1526d471fda57329a38c" translate="yes" xml:space="preserve">
          <source>The request may have reached the server and may have been performed. However, no answer was received from the server within the expected time.</source>
          <target state="translated">요청이 서버에 도달하여 수행되었을 수 있습니다. 그러나 예상 시간 내에 서버에서 응답을받지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="0609829732d849e2037ce824c383ed1a7b424ab2" translate="yes" xml:space="preserve">
          <source>The request was accepted and &lt;code&gt;SupervisorPid&lt;/code&gt; is the process identifier of the connection supervisor process (which is created in the &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; callback).</source>
          <target state="translated">요청이 수락되었고 &lt;code&gt;SupervisorPid&lt;/code&gt; 는 연결 감독자 프로세스의 프로세스 식별자입니다 ( &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 콜백 에서 생성됨 ).</target>
        </trans-unit>
        <trans-unit id="d76fc415bd89f84963ae3ee419c891159d20a10c" translate="yes" xml:space="preserve">
          <source>The request was rejected. This is a fatal error. The acceptor process should terminate.</source>
          <target state="translated">요청이 거부되었습니다. 이것은 치명적인 오류입니다. 수락 자 프로세스가 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0af04869dc460d9fffda5c9cafebc1aa148f650e" translate="yes" xml:space="preserve">
          <source>The requests served by the EPMD are summarized in the following figure.</source>
          <target state="translated">EPMD가 제공하는 요청은 다음 그림에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="766cb0fbb7f32280a11f9d0fcaaf21cc2abaa201" translate="yes" xml:space="preserve">
          <source>The resources can send notifications to the manager as well. Examples of notifications are events and alarms. The resource needs to generate protocol-independent notifications. The following picture illustrates how this is achieved:</source>
          <target state="translated">리소스는 관리자에게 알림을 보낼 수도 있습니다. 알림의 예로는 이벤트 및 알람이 있습니다. 리소스는 프로토콜 독립적 알림을 생성해야합니다. 다음 그림은이를 달성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2c83b49760a86aadaf5f3b2f1036293a1e089f52" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;DUMP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;DUMP_REQ&lt;/code&gt; 에 대한 응답 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a65d28bc38322c3bd1cfbf2bf8711df7091101cd" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;KILL_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;KILL_REQ&lt;/code&gt; 에 대한 응답 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3c2ac7160df49c4588c05e57b87e5aff9422c1f" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;NAMES_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;NAMES_REQ&lt;/code&gt; 에 대한 응답 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dd3fa630ddc8b538f974287e27afabd12f4340d" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;STOP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;STOP_REQ&lt;/code&gt; 에 대한 응답 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbc3d39894fa2184326a46cadccf5d5f95e1ce70" translate="yes" xml:space="preserve">
          <source>The response message &lt;code&gt;ALIVE2_RESP&lt;/code&gt; is as follows:</source>
          <target state="translated">응답 메시지 &lt;code&gt;ALIVE2_RESP&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6677705b73ca8640b5bfd49e04c30a99a6b85930" translate="yes" xml:space="preserve">
          <source>The response shows that the file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been created. This is called a backup file, and it contains an initial schema. If more than one node in the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; had been specified, identical backup files would have been created on all nodes.</source>
          <target state="translated">응답은 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 파일 이 작성되었음을 보여줍니다 . 이를 백업 파일이라고하며 초기 스키마가 포함되어 있습니다. &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 함수에서 둘 이상의 노드 가 지정된 경우 모든 노드에서 동일한 백업 파일이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4067e1f0937adfc4de129b497938ce1fa751f3a" translate="yes" xml:space="preserve">
          <source>The rest of the driver is more or less UDS-specific and not of general interest.</source>
          <target state="translated">운전자의 나머지는 다소 UDS에 따라 다르며 일반적인 관심사는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b248e72516f25e453000ce440baff629617e3ca9" translate="yes" xml:space="preserve">
          <source>The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP).</source>
          <target state="translated">따라서이 섹션의 나머지 부분은 Erlang 프로그래머가 읽기에 적합하지 않지만 예제는 (* SKIP)에서 사용할 수있는 이름을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8d01a53de4ed7d8cd3faf10a1aef24441bc36b6e" translate="yes" xml:space="preserve">
          <source>The restart strategy is specified by the &lt;code&gt;strategy&lt;/code&gt; key in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">재시작 전략은 콜백 함수 &lt;code&gt;init&lt;/code&gt; 가 반환 한 수퍼바이저 플래그 맵에서 &lt;code&gt;strategy&lt;/code&gt; 키로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="536cf89c0e01376b78ab828ece36006c915f41c1" translate="yes" xml:space="preserve">
          <source>The restoration is performed as a single transaction. If the database is large, it cannot always be restored online. The old database must then be restored by installing a fallback, followed by a restart.</source>
          <target state="translated">복원은 단일 트랜잭션으로 수행됩니다. 데이터베이스가 큰 경우 항상 온라인으로 복원 할 수 없습니다. 그런 다음 폴백을 설치 한 다음 다시 시작하여 이전 데이터베이스를 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="afdaf9dae668c3f7bdc0ca10a94463ffda8086c1" translate="yes" xml:space="preserve">
          <source>The restriction operators are defined for closures as well; &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is interpreted as the direct or indirect function calls from the &lt;code&gt;xref&lt;/code&gt; module, while the interpretation of &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is the set of direct calls from &lt;code&gt;xref&lt;/code&gt;. If some graph is to be used in several graph analyses, it saves time to assign the &lt;code&gt;digraph&lt;/code&gt; representation of the graph to a user variable, and then make sure that every graph analysis operates on that variable instead of the list representation of the graph.</source>
          <target state="translated">제한 연산자도 클로저에 대해 정의됩니다. &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; 는 &lt;code&gt;xref&lt;/code&gt; 모듈 에서 직접 또는 간접 함수 호출로 해석되며 &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; 는 &lt;code&gt;xref&lt;/code&gt; 로부터의 직접 호출 집합입니다 . 일부 그래프를 여러 그래프 분석에 사용하는 경우 그래프의 &lt;code&gt;digraph&lt;/code&gt; 표현을 사용자 변수 에 할당하는 데 시간을 절약 하고 모든 그래프 분석이 그래프의 목록 표현 대신 해당 변수에서 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="603dc83e6b9810f3ec3760b7629ba1cc75f2b142" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Excl_Message&lt;/code&gt; has the same structure as a complete decode would have, except for the parts of the top type that were not decoded. The undecoded parts are on their places in the structure on format &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Excl_Message&lt;/code&gt; 는 디코딩되지 않은 최상위 유형의 부분을 제외하고 완전한 디코딩과 동일한 구조를 갖습니다. 디코딩되지 않은 부분은 &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt; 형식의 구조에서 해당 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5bf40f10fe2bffb0315d5af0604d375695096e5" translate="yes" xml:space="preserve">
          <source>The result above are the fastest of these configurations for each codec. The figures presented are the average of all used messages.</source>
          <target state="translated">위의 결과는 각 코덱에 대해 가장 빠른 구성입니다. 제시된 수치는 사용 된 모든 메시지의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="32893fd2ec1b1eb00ce0a52b29ac7e0d97610291" translate="yes" xml:space="preserve">
          <source>The result contains information about the following &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">결과에는 다음 &lt;code&gt;Item&lt;/code&gt; 에 대한 정보가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e8b477b4aed021fef6ebb0a1b67b1473cc13b37" translate="yes" xml:space="preserve">
          <source>The result from each test case is recorded in a dedicated HTML log file, created for the particular test run. An overview page displays each test case represented by a table row showing total execution time, if the case was successful, failed, or skipped, plus an optional user comment. For a failed test case, the reason for termination is also printed in the comment field. The overview page has a link to each test case log file, providing simple navigation with any standard HTML browser.</source>
          <target state="translated">각 테스트 사례의 결과는 특정 테스트 실행을 위해 작성된 전용 HTML 로그 파일에 기록됩니다. 개요 페이지에는 총 실행 시간 (사례가 성공, 실패 또는 건너 뛴 경우)과 선택적 사용자 의견을 표시하는 표 행으로 표시되는 각 테스트 사례가 표시됩니다. 실패한 테스트 케이스의 경우 종료 이유도 주석 필드에 인쇄됩니다. 개요 페이지에는 각 테스트 케이스 로그 파일에 대한 링크가 있으며 표준 HTML 브라우저로 간단한 탐색을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="200d78a9c16efccfba75389c2e312a153f45a8e8" translate="yes" xml:space="preserve">
          <source>The result from running the test is printed in log files in HTML format (stored in unique log directories on a different level). The following illustration shows the log file structure:</source>
          <target state="translated">테스트 실행 결과는 HTML 형식의 로그 파일 (다른 레벨의 고유 한 로그 디렉토리에 저장 됨)로 인쇄됩니다. 다음 그림은 로그 파일 구조를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="374ecad7f3c9133bbe397289798ccaaa43ce127d" translate="yes" xml:space="preserve">
          <source>The result is &quot;normalized&quot;:</source>
          <target state="translated">결과는 &quot;정규화되었습니다&quot;:</target>
        </trans-unit>
        <trans-unit id="859cd92f58e2a9a54c26d7e8f5204e954bdffebd" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;. The fun is straightforward, so the only problem is that all the data from the table must be transferred from the table to the calling process for filtering. That is inefficient compared to the &lt;code&gt;ets:match/2&lt;/code&gt; call where the filtering can be done &quot;inside&quot; the emulator and only the result is transferred to the process.</source>
          <target state="translated">결과는 &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt; 입니다. 재미는 간단하므로 유일한 문제는 테이블의 모든 데이터가 필터링을 위해 테이블에서 호출 프로세스로 전송되어야한다는 것입니다. 필터링이 에뮬레이터 &quot;내부&quot;에서 수행 될 수 있고 결과 만 프로세스로 전송 되는 &lt;code&gt;ets:match/2&lt;/code&gt; 호출 과 비교하면 비효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="3cac868d8974153152b55d9efa1e40ff1114e69d" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt;, as expected. The equivalent expression using a handwritten match specification would look like this:</source>
          <target state="translated">결과는 &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt; 입니다. 필기 일치 사양을 사용하는 등식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8636350d1356e8fb3f319b7140bff8ef6a16d4e" translate="yes" xml:space="preserve">
          <source>The result is a list of characters.</source>
          <target state="translated">결과는 문자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1bedbbe8e33126fcebf6fc95fcd5a51821596e48" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt; and &lt;code&gt;Files&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details).</source>
          <target state="translated">그 결과, 한 쌍 &lt;code&gt;{Tree, Stubs}&lt;/code&gt; , &lt;code&gt;Tree&lt;/code&gt; 모두 코드 병합의 결과 인 소스 코드를 나타내는 &lt;code&gt;Sources&lt;/code&gt; 및 &lt;code&gt;Files&lt;/code&gt; 및 &lt;code&gt;Stubs&lt;/code&gt; (참조 스터브 모듈 디스크립터 목록 &lt;code&gt;merge_sources/3&lt;/code&gt; 세부 사항 참조).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
