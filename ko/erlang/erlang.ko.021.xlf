<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">postgres의 결과를 확인합니다. 데이터 인 경우 열 데이터가있는 목록 목록으로 인코딩합니다. postgres의 모든 것은 C 문자열이므로 &lt;code&gt;ei_x_encode_string&lt;/code&gt; 을 사용 하여 결과를 문자열로 Erlang에 보냅니다. (목록의 머리글에는 열 이름이 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">여기에서 Erlang 코드와 Beam 코드가 모두 포함 된 아카이브 스크립트를 생성 한 다음 아카이브의 모든 파일을 반복하고 해당 컨텐츠와 파일에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">여기서 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 생성 하여 &lt;code&gt;../projectdir&lt;/code&gt; 디렉토리에 배치합니다 . 이 파일에는 세 파일의 기능, 레코드 및 매크로 정의에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">여기서 우리는 &lt;code&gt;get_until&lt;/code&gt; 을 구현하고 &lt;code&gt;get_chars&lt;/code&gt; 와 &lt;code&gt;get_line&lt;/code&gt; 을 구현하기 위해 내부 헬퍼를 사용하여 조금만 부정했습니다 . 프로덕션 코드에서 이것은 비효율적 일 수 있지만 이는 다른 요청의 빈도에 따라 다릅니다. &lt;code&gt;put_chars/2&lt;/code&gt; 및 &lt;code&gt;get_until/5&lt;/code&gt; 함수 구현을 시작하기 전에 몇 가지 나머지 요청을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">여기서 우리는 어떤 기능도 그 자체를 크게 구별하지 않는 것을 보았습니다. 이는 매우 정상적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">여기에서 &lt;code&gt;|&lt;/code&gt; 목록에서 처음 두 요소를 가져옵니다. 목록에 요소가있는 것보다 많은 요소를 목록에서 가져 오려고하면 오류가 반환됩니다. [] 요소가없는 목록의 특별한 경우도 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">여기서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;M0&lt;/code&gt; 에서 &lt;code&gt;M4&lt;/code&gt; 는 결과 맵 용어입니다.</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">여기서 &lt;code&gt;Arguments&lt;/code&gt; 는 0 개 이상의 인수 목록입니다. &lt;code&gt;-callback&lt;/code&gt; 속성은 별도의 유형 정보는 문서를 작성하거나 불일치를 찾는 도구에서 사용 할 수 있기 때문에 선호된다.</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">여기서 &lt;code&gt;Bin&lt;/code&gt; 은 바인딩되고 요소는 바인딩과 마찬가지로 바인딩되거나 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">여기서 &lt;code&gt;Expr&lt;/code&gt; 은 임의의 표현이며 각 &lt;code&gt;Qualifier&lt;/code&gt; 는 생성기 또는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">여기서 &lt;code&gt;Fd&lt;/code&gt; 는 대상 파일의 파일 설명자 또는 atom &lt;code&gt;standard_io&lt;/code&gt; 입니다. &lt;code&gt;_TraceInfo&lt;/code&gt; 는 추적 정보 파일의 정보를 포함합니다 ( &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; 섹션 참조 ). &lt;code&gt;State&lt;/code&gt; 는 형식 핸들러 fun에 대한 상태 변수입니다. 변수 &lt;code&gt;State&lt;/code&gt; 의 초기 값은 다음 과 같이 핸들러 옵션으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">여기서 &lt;code&gt;File&lt;/code&gt; 은 &lt;code&gt;X&lt;/code&gt; 대신 새 변수로 사용됩니다 . 펀 바디의 코드가 펀 외부에 정의 된 변수 &lt;code&gt;File&lt;/code&gt; 을 참조 할 수 없기 때문에 그렇게 현명하지 않습니다 . 이 예제를 컴파일하면 다음과 같은 진단이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">여기서 &lt;code&gt;S1LogDir&lt;/code&gt; 및 &lt;code&gt;S2LogDir&lt;/code&gt; 은 각각의 테스트에 대한 &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">여기서 &lt;code&gt;conn_types&lt;/code&gt; 는 SSH, Telnet, FTP, RPC 및 / 또는 SNMP를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;demo()&lt;/code&gt; 는 &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">여기서 &lt;code&gt;init&lt;/code&gt; 는 입력 데이터가 필요하지 않으며 인수를 무시합니다. 들면 &lt;code&gt;terminal_logger&lt;/code&gt; , 내부 상태는 사용되지 않는다. 들어 &lt;code&gt;file_logger&lt;/code&gt; , 내부 상태는 열린 파일 디스크립터를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">여기서, &lt;code&gt;tuplep&lt;/code&gt; 의 포인트 &lt;code&gt;ETERM&lt;/code&gt; 의 두 요소 튜플을 나타내는 구조체; 함수 이름 (아톰) 및 인수 (정수) 기능 사용 &lt;code&gt;erl_element()&lt;/code&gt; 에서 &lt;code&gt;erl_eterm&lt;/code&gt; 을 이러한 요소를 추출 할 수 있지만, 또한 포인터로 선언해야 &lt;code&gt;ETERM&lt;/code&gt; 의 구조체 :</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">여기서 &lt;code&gt;complex.erl&lt;/code&gt; 구현에서 C와의 통신은 숨겨져 있습니다. 다음 섹션에서는 다양한 상호 운용성 메커니즘을 사용하여이 모듈을 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">여기에서 데이터 유형 &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; 는 다음 Erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">여기서 &lt;code&gt;on_load&lt;/code&gt; 지시문 은 모듈이로드 될 때 함수 &lt;code&gt;init&lt;/code&gt; 가 자동으로 호출되도록 하는 데 사용됩니다 . 경우 &lt;code&gt;init&lt;/code&gt; 이외의 반환 아무것도 &lt;code&gt;ok&lt;/code&gt; 의 NIF 라이브러리의 로딩이 예에서 실패 할 때 같은 모듈이 언로드 전화를 걸고 그 안에 기능에 실패.</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">여기서 핸들러는 구성 변수를 동적으로 다시로드 할 수도 있습니다. 경우 &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; 테스트 케이스로부터 함수 호출, 모든 변수는로드 &lt;code&gt;config_driver:read_config/1&lt;/code&gt; 최신의 값으로 갱신하고, 변수에 대한 새로운 값 &lt;code&gt;localtime&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">여기에서는 이전 예제와 동일한 테스트 실행이 실행됩니다 (가능한 경우 반복 될 수 있음). 그러나 시간 종료가 발생하면 1 시간 후에 &lt;code&gt;Common Test&lt;/code&gt; 는 중지하기 전에 전체 테스트 실행을 완료합니다 (즉, &lt;code&gt;to1&lt;/code&gt; 과 &lt;code&gt;to2&lt;/code&gt; 는 항상 동일한 테스트 실행에서 실행 됨).</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">여기서는 예제 1과 동일한 테스트가 실행되지만 &lt;code&gt;force_stop&lt;/code&gt; 플래그 가 &lt;code&gt;skip_rest&lt;/code&gt; 로 설정되었습니다 . 디렉토리에서 테스트 실행 중에 타임 아웃이 발생하면 &lt;code&gt;to1&lt;/code&gt; , 나머지 테스트 케이스 &lt;code&gt;to1&lt;/code&gt; 생략하며 테스트에서 테스트를 실행하지 않고 중단 &lt;code&gt;to2&lt;/code&gt; 다른 시간. 디렉토리에서 테스트 실행 중에 타임 아웃이 발생하면 &lt;code&gt;to2&lt;/code&gt; , 나머지 테스트 케이스 &lt;code&gt;to2&lt;/code&gt; 스킵되어 시험이 중단된다.</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">여기에서 &lt;code&gt;Opts&lt;/code&gt; 변수에 해당하는 세그먼트 에는 &lt;strong&gt;유형 수정자가&lt;/strong&gt; 있으며 &lt;code&gt;Opts&lt;/code&gt; 가 이진에 바인딩되도록 지정 합니다 . 다른 모든 변수는 기본 유형이 부호없는 정수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">여기서 테스트 디렉토리 &lt;code&gt;to1&lt;/code&gt; 의 스위트와 &lt;code&gt;to2&lt;/code&gt; 의 스위트 는 한 번의 테스트 실행으로 실행됩니다. 시간 초과 이벤트는 10 분 후에 발생합니다. 남은 시간이 있으면 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 실행을 반복합니다 (즉, test &lt;code&gt;to1&lt;/code&gt; 로 시작 ). 시간 종료 후 현재 작업이 완료되면 (플래그 &lt;code&gt;force_stop&lt;/code&gt; 때문에) &lt;code&gt;Common Test&lt;/code&gt; 가 중지됩니다 . 그 결과, 지정된 테스트 실행은 테스트 후 중단 할 수 &lt;code&gt;to1&lt;/code&gt; 및 테스트하기 전에 &lt;code&gt;to2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">여기서는 &lt;code&gt;to1&lt;/code&gt; 및 &lt;code&gt;to2&lt;/code&gt; 테스트를 포함한 테스트 실행 이 5 회 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">여기서 &quot;ts1&quot;로 지정된 테스트가 먼저 실행 된 다음 &quot;ts2&quot;로 지정된 테스트가 완료되고 마지막으로 &quot;ts3&quot;및 &quot;ts4&quot;가 지정된 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">여기서 재미의 머리 부분에 정의 된 변수 &lt;code&gt;X&lt;/code&gt; 는 새로운 변수입니다. fun 내에서 사용되는 변수 &lt;code&gt;Stream&lt;/code&gt; 은 &lt;code&gt;file:open&lt;/code&gt; 줄 에서 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">여기에서 &lt;code&gt;div.error&lt;/code&gt; 출력에 기본 검정 대신 흰색 텍스트가 사용됩니다 ( &lt;code&gt;pre&lt;/code&gt; 에 대한 다른 속성 설정 은 영향을받지 않음).</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">여기서, &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 는 다음 인수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">16 진수</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">HiPE는 다음 시스템에서 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">HiPE는 다음 시스템 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">메뉴 숨기기 :</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">높은 내결함성</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">고급 지침</target>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 단조 시간 소스의 초당 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; . OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 정렬 되는지 여부 에 대해 아무 것도 말하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 보다 좋지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">현재 OS 시스템 시간 원본의 초당 가능한 최고 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; . OS에서 해상도 정보를 검색 할 수없는 경우 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 은 &lt;code&gt;Function&lt;/code&gt; 반환 값 의 시간 단위 해상도로 설정됩니다 . 즉, 실제 해상도는 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 낮을 수 있습니다 . 해상도는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 가 해상도와 일치 하는지 여부 에 대해 아무 것도 말하지 않습니다 . 그러나 정밀도가 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 보다 좋지 않다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Hmac 기능- &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">후크 옵션 &lt;code&gt;log_type&lt;/code&gt; 을 사용하여 &lt;code&gt;cth_conn_log&lt;/code&gt; 동작 을 변경할 수 있습니다 . 이 옵션의 기본값은 &lt;code&gt;raw&lt;/code&gt; 이며 위에서 설명한 동작이 발생합니다. 값이 &lt;code&gt;html&lt;/code&gt; 로 설정 되면 모든 Telnet 통신이 대신 테스트 케이스 HTML 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">후크 옵션 &lt;code&gt;log_type&lt;/code&gt; 은 로깅 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">구성 파일에 지정된 후크 옵션은 테스트 스위트의 하드 코드 된 후크 옵션을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">구성 파일에 지정된 후크 옵션은 테스트 스위트의 하드 코드 된 후크 옵션을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">홉별 및 엔드-투-엔드 식별자는 발신 요청을 보낼 때 직경으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">가로 탭 (HT)</target>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">호스트 = &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">호스트를 찾을 수 없거나 FTP 서버를 찾을 수 없거나 FTP 서버에서 연결을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">호스트 키 알고리즘.</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">호스트 키</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">호스트 공개 키</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">호스트 IP 주소 AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">호스트 이름 추출</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">호스트 이름은이 기능이 호출 된 Erlang 노드에서 net_adm : localhost ()를 호출 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">노드의 호스트 이름, &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">호스트 이름 및 호스트 주소</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">카테고리를 CSS 태그에 매핑하는 방법은 테스트 실행 및 결과 분석 섹션의 &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">코드를 컴파일하고로드하는 방법은 언어 문제가 아니라 시스템에 따라 다릅니다. 이 섹션에서는 Erlang / OTP에서의 컴파일 및 코드 로딩에 대해 문서의 관련 부분을 참조하여 설명합니다.</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">출력에 타임 스탬프가 표시되기 전에 Erlang을 비활성화해야하는 시간. 기본값은 &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; 이며 최소값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">&quot;ALIVE&quot;메시지를 로그에 기록하기 전에 출력을 기다리는 시간 (분). 기본값은 15이며 최소값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">소켓에서 읽거나받은 바이트 수는 &lt;code&gt;sent&lt;/code&gt; 와 비슷한 방식으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">소켓을 통해 전송 된 바이트 수 이것은 랩핑 할 수 있지만 Erlang 분포는이 값이 변경된 경우에만 관심이 있으므로 분포에는 문제가되지 않습니다. (Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 는 드라이버를 호출하여이 값을 사용하여 가져옵니다. &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 루틴을 통해 수행됩니다 .)</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">스케줄러가 바운드되는 방식 예를 들어, 온라인으로 스케줄러보다 실행중인 프로세스 수가 적은 상황에서 런타임 시스템은 프로세스를 스케줄러 ID가 낮은 스케줄러로 마이그레이션하려고합니다. 스케줄러가 하드웨어에 더 많이 퍼질수록 그러한 상황에서 런타임 시스템에 더 많은 자원을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">디버그 가능 Erlang 런타임 시스템을 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">외부 세계와 통신하는 방법 및 다른 언어로 작성된 소프트웨어 (포트) 이 내용은 &lt;code&gt;Interoperability Tutorial&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수신 메시지에서 직경 헤더의 메시지 길이 필드에서 오류를 처리하는 방법 이 컨텍스트에서 오류는 전송을 통해 수신 된 길이가 20 바이트 이상 (헤더 길이) 이상, 4의 배수 (유효한 길이) 또는 해당 메시지의 길이가 아니라는 것입니다. 인터페이스는 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">대상 환경에 릴리스를 설치하는 방법은 섹션 2 시스템 원칙의 대상 시스템에 대한 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떻게 프로그램 응용 프로그램에 설명되어 &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떻게 프로그램 릴리스에 설명되어있다 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">이 섹션에는 마스터 에이전트에서 &lt;code&gt;fTrap&lt;/code&gt; 을 전송하여 트랩을 보내는 방법 이 나와 있습니다. 마스터 에이전트에는 트랩이 정의 된 MIB &lt;code&gt;EX1-MIB&lt;/code&gt; 가로 드되어 있습니다. 이 트랩은 &lt;code&gt;myName&lt;/code&gt; 및 &lt;code&gt;fIndex&lt;/code&gt; 트랩과 함께 두 변수를 보내도록 지정합니다 . &lt;code&gt;fIndex&lt;/code&gt; 는 테이블 열이므로 &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; 호출에서 행의 값과 색인을 제공해야합니다 . 아래 예에서는 문제의 행이 2 ( &lt;code&gt;fIndex&lt;/code&gt; 2 인 행)로 색인화되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">애플리케이션의 코드, 즉 감독 트리를 시작 및 중지하는 방법은 다음 두 가지 콜백 함수로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 프로그램이나 &lt;code&gt;systemtap&lt;/code&gt; 스크립트 를 작성하는 방법 은 책과 인터넷의 많은 페이지에서 배울 수 있습니다. 이 매뉴얼 페이지에는 각 플랫폼의 동적 추적 도구 사용에 대한 설명서가 포함되어 있지 않습니다. 그러나 &lt;code&gt;runtime_tools&lt;/code&gt; 애플리케이션 의 &lt;code&gt;examples&lt;/code&gt; 디렉토리 에는 시작하는 데 도움이되는 &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;systemtap&lt;/code&gt; 프로그램 의 포괄적 인 예제가 포함되어 있습니다 . 다른 정보 소스는 런타임 도구 사용자 안내서 의 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; 장입니다.</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">그러나 NTP는 안전하지 않습니다. NTP 서버를 사용할 수 없거나 &lt;code&gt;ntp.conf&lt;/code&gt; 가 잘못 구성되었거나 컴퓨터와 인터넷 연결이 끊길 수 있습니다. 또한 일광 절약 시간을 처리하는 올바른 방법을 생각하는 사용자 (또는 시스템 관리자)에게 1 년에 두 번 1 시간 씩 시계를 조정하는 것 (잘못된 방법)이있을 수 있습니다. 더 복잡하게하기 위해이 사용자는 인터넷에서 소프트웨어를 가져 왔으며 컴퓨터에서 정확한 시간을 인식하지 못했습니다. 사용자는 벽시계를 정확한 시간과 동기화하는 데 신경 쓰지 않습니다. 사용자는 프로그램이 시간에 대해 무제한 지식을 갖기를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">그러나이 방법으로 시작된 노드는 TLS 매개 변수가 제공되지 않으므로 다른 노드와의 통신을 거부합니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">그러나 전체 바이트가 아닌 비트 문자열은 허용되지 않으므로 UTF 문자를 8 비트 경계를 따라 분할하여 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">그러나 &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; 를 사용하여 인증서를 디코딩 할 수도 있습니다 .이 인증서는 인증서의 표준 부분을 사용자 정의하고 재귀 적으로 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">그러나 영숫자가 아닌 다른 문자를 이스케이프 처리해도 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">그러나 &lt;code&gt;SET OF&lt;/code&gt; 유형의 값 의 경우, DER 인코딩 형식은 요소를 인코딩의 오름차순으로 전송해야하므로 런타임시 고가의 정렬 절차를 의미합니다. 따라서 가능하면 &lt;code&gt;SET OF&lt;/code&gt; 대신 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">그러나 여기에는 사용 방법과 xmerl 사용 방법에 대한 몇 가지 예가 있습니다. 사용자 인터페이스에 대한 자세한 설명은 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">그러나, &lt;code&gt;cp1&lt;/code&gt; 또한 재시작 기능 &lt;code&gt;application:takeover/2&lt;/code&gt; 를 이동 &lt;code&gt;myapp&lt;/code&gt; 행 &lt;code&gt;cp1&lt;/code&gt; 같은 &lt;code&gt;cp1&lt;/code&gt; 보다 높은 우선 순위를 갖는다 &lt;code&gt;cp3&lt;/code&gt; 이 애플리케이션한다. 이 경우 응용 프로그램을 시작하기 위해 &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; 가 &lt;code&gt;cp1&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">그러나 수량 자 뒤에 물음표가 있으면 욕심이 멈추고 대신 가능한 최소 횟수와 일치하므로 다음 패턴이 C 주석과 함께 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">그러나 다른 프로세스에 드라이버가로드 된 경우 &lt;code&gt;reload_driver&lt;/code&gt; 를 호출 하면 오류 코드 &lt;code&gt;pending_process&lt;/code&gt; 가 리턴 됩니다 . 앞에서 언급했듯이 권장 설계는 &quot;드라이버 리 로더&quot;이외의 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 해당 드라이버로드를 요구 하지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">그러나 백 슬래시 다음의 10 진수가 &amp;lt;10이면 항상 역 참조로 간주되며 전체 패턴에 캡처 된 왼쪽 괄호가 많지 않은 경우에만 오류가 발생합니다. 즉, 참조되는 괄호는 숫자 &amp;lt;10에 대한 참조의 왼쪽에있을 필요는 없습니다.이 유형의 &quot;앞뒤 참조&quot;는 반복이 포함되고 오른쪽의 하위 패턴이 초기 반복.</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">그러나 첫 번째 패턴이 일치하지 않으면 두 번째 패턴이 테스트됩니다. 일치하면 메시지가 큐에서 제거되고 두 번째 패턴에 해당하는 조치가 실행됩니다. 두 번째 패턴이 일치하지 않으면 테스트 할 패턴이 더 이상 없을 때까지 세 번째 패턴이 시도됩니다. 테스트 할 패턴이 더 이상 없으면 첫 번째 메시지가 큐에 보관되고 두 번째 메시지가 대신 시도됩니다. 이 패턴과 일치하면 적절한 조치가 실행되고 두 번째 메시지가 큐에서 제거됩니다 (첫 번째 메시지와 다른 메시지는 큐에 유지). 두 번째 메시지가 일치하지 않으면 큐의 끝에 도달 할 때까지 세 번째 메시지가 시도됩니다. 큐의 끝에 도달하면프로세스는 실행을 차단 (실행 중지)하고 새 메시지가 수신되고이 절차가 반복 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">그러나 입력 &lt;code&gt;Data&lt;/code&gt; 가 순수 이진이면 오류 튜플의 세 번째 부분도 이진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">그러나 다음 예제와 같이 테이블이 명시 적 레코드 이름으로 인수로 작성되면 테이블 이름에 관계없이 구독자 레코드를 두 테이블 모두에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">이 작업이 완료되고 경우, &lt;code&gt;relup&lt;/code&gt; 의 파일이 생성뿐만 아니라 그것은 (제거 및 추가하고있다) 다시 시작하기위한 지침 포함됩니다 &lt;code&gt;prim_app&lt;/code&gt; 를 , 그것도 시작하기위한 지침 포함됩니다 &lt;code&gt;ch_app&lt;/code&gt; 를 (다운 그레이드의 경우이를 중지를) . &lt;code&gt;ch_app&lt;/code&gt; 가 새 &lt;code&gt;.rel&lt;/code&gt; 파일 에는 포함되어 있지만 이전 파일 에는 포함되어 있지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">그러나 다음과 같이 &lt;code&gt;escript&lt;/code&gt; 를 호출하면 첫 번째 행의 내용은 중요하지 않지만 무시되는 Erlang 코드는 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">그러나 압축을 푼 후 릴리스를 실행하기 전에 대상 의 &lt;code&gt;sys.config&lt;/code&gt; 내에서 변수를 바꾸는 것이 편리 할 수도 있습니다 . 당신이있는 경우 &lt;code&gt;sys.config.src&lt;/code&gt; 을 가 포함됩니다와 같은 유효한 얼랑 용어 파일이 될 필요는 없습니다 &lt;code&gt;sys.config&lt;/code&gt; . 릴리스를 실행하기 전에 동일한 디렉토리에 유효한 &lt;code&gt;sys.config&lt;/code&gt; 가 있어야 하므로 &lt;code&gt;sys.config.src&lt;/code&gt; 를 사용 하려면 릴리스를 부팅하기 전에 필요한 것을 채우고 &lt;code&gt;sys.config&lt;/code&gt; 를 디스크에 쓸 수있는 도구가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">그러나 두 개의 최상위 분기를 사용하도록 다시 작성된 경우 PCRE를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">그러나이 추가 정보를 고려할지 여부를 선택하는 것은 사양을 처리하는 도구에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">그러나 이보다 점으로 구분 된 부분이 더 존재할 수 있습니다. 점으로 구분 된 부분은 음이 아닌 정수로 구성됩니다. &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 보다 덜 중요한 모든 부분 이 &lt;code&gt;0&lt;/code&gt; 이면 생략됩니다. 세 가지 일반 부품 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 는 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt; 때문에 다음 호출에서 확장이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">그러나 더티 작업을 사용하여 데이터베이스를 업데이트하는 경우 데이터베이스가 일관성이없는 상태로 유지 될 위험이 있습니다. 더티 오퍼레이션은 반드시 필요한 성능상의 이유로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">그러나 간단한 동작은 여러 가지 방법으로 수정할 수 있습니다. 예를 들어, Net if 프로세스는 바이트에 일종의 암호화 / 암호 해독 체계를 적용하거나 프록시 필터로 작동하여 일부 패킷을 프록시 에이전트로 보내고 일부 패킷을 마스터 에이전트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">그러나 간단한 동작은 여러 가지 방법으로 수정할 수 있습니다. 예를 들어, Net if 프로세스는 바이트에 일종의 암호화 / 암호 해독 체계를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">그러나 최적화를 사용할 수없는 경우가 있습니다. . *가 패턴의 다른 곳에서 역 참조의 주제 인 캡처 괄호 안에 있으면 시작시 일치가 실패 할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">그러나이 절차는 시간이 오래 걸릴 수 있습니다. 바로 가기 기능 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 은 디스크에서 모든 테이블을 더 빠른 속도로로드합니다. 이 기능은 네트워크 상황에 관계없이 디스크에서 테이블을 강제로로드합니다.</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">그러나 이전 (R14 이전) 코드가 OTP 버전 R14A 이상으로 컴파일 될 때 동작이 변경되지 않도록하기 위해 다음 제한 사항이 적용됩니다. R14A 이전의 OTP 버전 (ERTS 버전)에서 자동으로 가져온 BIF의 이름을 대체하는 경우 5.8) 코드에서 해당 함수를 암시 적으로 정규 호출하면 컴파일러 지시문을 사용하여 자동 가져 오기를 명시 적으로 제거하거나 해당 함수를 정규 함수 호출로 바꿔야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 다음 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">그러나 예를 들어 IA5String (ASCII와 매우 유사한)을 사용할 때 바이트 65 (10 진수 표기법) &lt;strong&gt;는&lt;/strong&gt; 문자 'A'를 &lt;strong&gt;의미&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">HTTP 클라이언트 서비스 시작 / 중지</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Http 데이터 형식</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">하이픈 (범위를 지정하는 것으로 해석 될 수있는 경우에만)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">하이픈은 SMIv2 (실용적인 접근 방식)에서 허용됩니다. 그 이유는 SMIv2에 따르면 SMIv1에서 변환 된 객체에는 하이픈이 허용되지만 다른 것에는 하이픈이 허용되지 않기 때문입니다. 컴파일러를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">I / O 오류</target>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">I / O는 유니 코드에서 가장 문제가되는 영역입니다. 파일은 바이트가 저장되는 엔터티이며 프로그래밍은 문자와 바이트를 상호 교환 가능한 것으로 취급해야합니다. 유니 코드 문자를 사용하면 파일에 데이터를 저장하려는 경우 인코딩을 결정해야합니다. Erlang에서는 인코딩 옵션을 사용하여 텍스트 파일을 열어서 바이트가 아닌 문자를 읽을 수 있지만 바이트 단위 I / O를 위해 파일을 열 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">I / O 라이브러리 기능.</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">I / O 서버는 약간 다르게 동작합니다. 터미널 (또는 &lt;code&gt;stdout&lt;/code&gt; )에 연결된 I / O 서버 는 일반적으로 인코딩 옵션에 관계없이 유니 코드 데이터를 처리 할 수 ​​있습니다. 이것은 현대적인 환경을 기대하지만 구식 터미널이나 파이프에 쓸 때 충돌하지 않으려는 경우에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">시스템 전체의 I / O 서버는 유니 코드 데이터를 처리 할 수 ​​있으며 장치에 대한 출력 또는 입력시 데이터를 변환하는 옵션이 있습니다. 앞에서 설명한 것처럼 &lt;code&gt;shell&lt;/code&gt; 모듈은 유니 코드 터미널을 지원하며 &lt;code&gt;file&lt;/code&gt; 모듈은 디스크의 다양한 유니 코드 형식과의 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">IANA 고려 사항</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC (Erlang IDL Compiler)는 IDL 인터페이스 사양이 지정된 경우 Erlang, C 또는 Java로 스텁 코드를 자동으로 생성하는 인터페이스 생성기입니다. IC 사용 설명서 및 IC 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">IC 파일. IDL 컴파일러를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF-프로토콜 Megaco를 호출</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG (Interface Generator)는 특정 키워드가있는 C 헤더 파일이있는 경우 Erlang 프로그램과 C 프로그램 간의 포트 또는 소켓 통신을위한 코드를 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-Erlang / OTP R6B에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP (코르 바)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">정수, INT, SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">IP 주소, &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">호스트 주소가 &lt;code&gt;any&lt;/code&gt; 로 지정 될 때 사용할 IP 버전 .</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">IPsec은 직경에 투명합니다.</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1 (0-255, 바이트 당 하나의 문자). 여기에서 케이스 매개 변수 &lt;code&gt;InEncoding&lt;/code&gt; 은 &lt;code&gt;latin1&lt;/code&gt; 으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">ITU-프로토콜 H.248을 호출</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 에서 반환 한 &lt;code&gt;ssh&lt;/code&gt; 채널의 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">이상적으로 코드에는 첫 번째 유형의 효율적인 코드 만 포함됩니다. 속도가 너무 느리면 응용 프로그램을 프로파일 링하여 성능 병목 현상의 위치를 ​​찾고 병목 현상 만 최적화하십시오. 다른 코드는 최대한 깨끗하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">식별 된 프로세서 상태는 운영 체제마다 다를 수 있으며 동일한 운영 체제에서 서로 다른 &lt;code&gt;cpu_sup&lt;/code&gt; 버전간에 변경 될 수 있습니다 . 그러나 모든 사용 중 및 모든 비 사용 중 프로세서 상태에서 소비 된 CPU 사이클의 백분율 공유의 합계는 항상 최대 100 %가됩니다.</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">버퍼로 인코딩 된 Erlang 용어의 유형을 식별하고 리턴합니다. 후행 &lt;strong&gt;매직&lt;/strong&gt; 식별자를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">파일이있는 파일 시스템을 식별합니다. Windows에서 숫자는 다음과 같이 드라이브를 나타냅니다. 0은 A :를 의미하고 1은 B :를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">사용할 키를 식별합니다. 형식은로드 된 엔진에 따라 다릅니다. libcrypto 의 &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; 함수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">정렬 할 정보를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">숫자로 괄호를 식별하는 것은 간단하지만 복잡한 정규식에서 숫자를 추적하기가 어려울 수 있습니다. 또한 표현식이 수정되면 숫자가 변경 될 수 있습니다. 이 어려움을 돕기 위해 PCRE는 하위 패턴의 이름 지정을 지원합니다. 이 기능은 릴리스 5.10까지 Perl에 추가되지 않았습니다. Python은 이전에 기능을 가지고 있었고 PCRE는 Python 구문을 사용하여 릴리스 4.0에서 기능을 도입했습니다. PCRE는 이제 Perl과 Python 구문을 모두 지원합니다. Perl은 동일한 번호의 서브 패턴이 다른 이름을 가질 수 있도록하지만 PCRE는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">표의 문자 공간</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">(* ACCEPT)가 캡처 괄호 안에 있으면 지금까지의 데이터가 캡처됩니다. 예를 들어 다음은 &quot;AB&quot;, &quot;AAD&quot;또는 &quot;ACD&quot;와 일치합니다. &quot;AB&quot;와 일치하면 외부 괄호로 &quot;B&quot;가 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">(* COMMIT)이 발생하는 유일한 역 추적 동사 인 경우 일단 통과되면 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 은 현재 시작점에서 일치하는 것을 찾거나 전혀 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;schedule&quot;&lt;/code&gt; 이 &lt;code&gt;Kernel&lt;/code&gt; 의 &lt;code&gt;global&lt;/code&gt; 모듈에 알려진 경우 , 스케줄 서비스에 메시지를 보내는 데 사용할 수있는 Erlang pid가 리턴됩니다. 또한 &lt;code&gt;node&lt;/code&gt; 는 서비스가 등록 된 노드의 이름을 포함하도록 초기화되므로 변수를 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 에 전달하여 간단히 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 가 사용되는 모든 이벤트가 처리됩니다 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 우리가 처음 지점 상태에 따라 다음 이벤트에 따라와 이벤트 중심의 접근 방식을 사용하고 우리는 (그러나이없는) 수 :</target>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 등의 목록을 반환하지 않습니다, 어떤 상태에 통화가 완료 입력합니다.</target>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 반환이 포함 된 목록 &lt;code&gt;state_enter&lt;/code&gt; 을 의 &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 모든 상태 변화에의 호출 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 인수를 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; . 이것은 이벤트처럼 보이지만 실제로는 이전 상태 콜백이 반환 된 후 이벤트가 새 상태 콜백으로 전달되기 전에 수행되는 호출입니다. &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 이러한 콜은 상태 콜백으로부터 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 튜플을 반환함으로써 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 상태를 변환한다 그것이없는 상태의 원인 호를 입력하는 상태를 바꾸고 있지 상태 변화로 간주된다.</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; , 현재의 이벤트가 연기한다.</target>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 을 사용하고 하나되어 상태 변화를, 그것은 초기 상태, 또는 콜백 결과 중 하나는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 가 사용된다 &lt;code&gt;gen_statem&lt;/code&gt; 는 인수를 사용하여 새로운 상태 콜백을 호출 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; 사용되며, 정확히 하나 개의 시스템 구성 파일이 사용되어야하며, 해당 파일을 호출하는 것입니다 &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Abs&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 절대 타이머가 시작되며,이 경우 &lt;code&gt;false&lt;/code&gt; 기본 인 상대를. 자세한 내용은 &lt;code&gt;erlang:start_timer/4&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">경우 &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; , &lt;code&gt;Suspendee&lt;/code&gt; 은 일시 중단 된 상태로 현재.</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Alg&lt;/code&gt; 이다 &lt;code&gt;crypto&lt;/code&gt; 이 기능이 정확히처럼 동작 &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">경우 &lt;code&gt;Alg&lt;/code&gt; 이다 &lt;code&gt;crypto_cache&lt;/code&gt; 를 이 기능은 OpenSSL의 랜덤 데이터 페치 &lt;code&gt;RAND_bytes&lt;/code&gt; 64 개 비트 시스템에 빠르게 계산하게하는 56 비트의 내부 워드 크기를 사용하여 속도를 캐시.</target>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">&lt;code&gt;Asn1module&lt;/code&gt; 이 확장명이없는 파일 이름 인 경우 먼저 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; , &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (이전 ASN.1 컴파일러와 호환 가능)로 가정합니다. &lt;code&gt;Asn1module&lt;/code&gt; 은 파일 이름을 포함하거나 포함하지 않는 파일 이름을 포함하여 전체 경로 이름 (상대적 또는 절대적) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">경우 &lt;code&gt;Bin&lt;/code&gt; 전체 패킷을 포함하지 않는, &lt;code&gt;{more,Length}&lt;/code&gt; 반환됩니다. &lt;code&gt;Length&lt;/code&gt; 는 패킷 의 예상 &lt;strong&gt;총 크기&lt;/strong&gt; 이거나 예상 패킷 크기를 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; . 그런 다음 더 많은 데이터를 추가하여 &lt;code&gt;decode_packet&lt;/code&gt; 을 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">경우 &lt;code&gt;BinRel1&lt;/code&gt; 가 생략되면, 요소가 등가의 관계 &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; R [i]를, 거리 R [1] &amp;times; ... &amp;times; 범위 R [N]의 범위가 &quot;직관적 아무것도 없다 (대신 사용 잃어버린&quot;).</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;Binaries&lt;/code&gt; 가 플랫 바이너리 목록이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">경우 &lt;code&gt;Binary&lt;/code&gt; 모듈의 오브젝트 코드가 포함되어 &lt;code&gt;Module&lt;/code&gt; , 오브젝트 코드이 BIF로드. 모듈 &lt;code&gt;Module&lt;/code&gt; 에 대한 코드가 이미 존재하면 모든 내보내기 참조가 교체되어 새로로드 된 코드를 가리 킵니다. 이전에로드 된 코드는 해당 코드를 실행하는 프로세스가 여전히있을 수 있으므로 이전 코드로 시스템에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">경우 &lt;code&gt;BlockState =:= block&lt;/code&gt; 다중 스케줄링은 차단된다. 즉, 하나의 스케줄러 스레드 만 실행됩니다. 경우 &lt;code&gt;BlockState =:= unblock&lt;/code&gt; 아무도 다른 블록 멀티 스케줄링,이 프로세스는 한 번 차단했습니다, 멀티 스케줄링은 차단 해제입니다.</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">경우 &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; , 일반 다중 스케줄링이 차단됩니다. 즉, 하나의 일반 스케줄러 스레드 만 실행되지만 여러 개의 더티 스케줄러가 실행될 수 있습니다. 경우 &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; 아무도 다른 블록 일반 멀티 스케줄링,이 과정은 한 번만 차단했습니다, 일반 다중 스케줄링은 차단 해제입니다.</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">경우 &lt;code&gt;Body&lt;/code&gt; 돌려 같다 &lt;code&gt;{Fun,Arg}&lt;/code&gt; , 웹 서버 시도는 &lt;code&gt;apply/2&lt;/code&gt; 에 &lt;code&gt;Fun&lt;/code&gt; 와 &lt;code&gt;Arg&lt;/code&gt; 인수로. 웹 서버는 fun 이 HTTP 응답 인 목록 &lt;code&gt;(Body)&lt;/code&gt; 을 반환 하거나 HTTP 응답이 클라이언트에 다시 &lt;code&gt;sent&lt;/code&gt; 되면 원자 를 반환 할 것으로 예상합니다 . fun에서 &lt;code&gt;close&lt;/code&gt; 가 반환 되면 문제가 발생한 것이므로 서버는 연결을 닫아 클라이언트에게이를 알립니다.</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">경우 &lt;code&gt;Bool&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; (기본값), &lt;code&gt;rb&lt;/code&gt; 에 에러 메시지를 출력 &lt;code&gt;stdout&lt;/code&gt; 이 발생하는 모든 나쁜 보고서에 대한,하지만 로깅 프로세스가 종료되지 않습니다. 인쇄 가능한 모든 보고서가 작성됩니다. 파일에 로깅을 사용하는 경우, &lt;code&gt;rb&lt;/code&gt; 인쇄는 &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; 인쇄 할 수없는 보고서의 위치에서 로그 파일을.</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">경우 &lt;code&gt;Bool&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;rb&lt;/code&gt; 로깅을 중지 (과에 에러 메시지를 출력 &lt;code&gt;stdout&lt;/code&gt; ) 그것은 잘못된 형식의 보고서가 발생합니다. 파일에 로깅이 활성화되면 오류 메시지도 로그 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">&lt;code&gt;Boolean == true&lt;/code&gt; 인 경우 소켓에 대해 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 옵션 이 설정되어 있으므로 소량의 데이터도 즉시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Button&lt;/code&gt; 상부 형이며 구성은 배제하기 위해 필요한 &lt;code&gt;number&lt;/code&gt; 디코드에서 &lt;code&gt;Type_List&lt;/code&gt; 구성 파일에 지시가 &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; . 당신이 디코드 함수를 호출 할 경우 &lt;code&gt;decode_Button_exclusive&lt;/code&gt; 을 , &lt;code&gt;Decode_Instruction&lt;/code&gt; 이 있다 &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master가 처음에 테스트 스펙 또는 &lt;code&gt;InclNodes&lt;/code&gt; 목록 에 지정된 테스트 노드에 연결하는 데 실패한 경우 , 운영자는 해당 노드의 상태를 수동으로 확인한 후 다시 시작하는 옵션이 프롬프트됩니다. 누락 된 노드없이 실행하거나 작업을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">경우 &lt;code&gt;CurrentIndentation&lt;/code&gt; 가 음수, 아무 개행없는 유일한 공간이 세퍼레이터로 사용된다.</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">경우 &lt;code&gt;Data&lt;/code&gt; 잘못된 I / O 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">경우 &lt;code&gt;Dates&lt;/code&gt; 양식을 가지고 &lt;code&gt;{DateTo, to}&lt;/code&gt; , 이전에 발생한 보고서 &lt;code&gt;DateTo&lt;/code&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">경우 &lt;code&gt;Dest&lt;/code&gt; A는 &lt;code&gt;pid()&lt;/code&gt; , 그것은해야합니다 &lt;code&gt;pid()&lt;/code&gt; 현재 런타임 시스템 인스턴스에 생성 프로세스의. 이 프로세스는 종료되었거나 종료되지 않았습니다. 경우 &lt;code&gt;Dest&lt;/code&gt; 인 &lt;code&gt;atom()&lt;/code&gt; , 그것은 로컬로 등록 프로세스의 이름으로 해석된다. 이름으로 언급 된 프로세스는 타이머 만료시 조회됩니다. 이름이 프로세스를 참조하지 않으면 오류가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Dest&lt;/code&gt; A는 &lt;code&gt;pid()&lt;/code&gt; 타이머가 자동으로 프로세스에 의해 참조이 취소됩니다 &lt;code&gt;pid()&lt;/code&gt; 살아 아니거나 프로세스가 종료되는 경우. 이 기능은 ERTS 5.4.11에서 도입되었습니다. &lt;code&gt;Dest&lt;/code&gt; 가 &lt;code&gt;atom()&lt;/code&gt; 경우 타이머가 자동으로 취소되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">경우 &lt;code&gt;Destination&lt;/code&gt; 파일 이름을 의미, 그것은 열립니다 &lt;code&gt;write&lt;/code&gt; 복사하기 전에 모드 목록 앞에 추가 모드, 완료되면 마감했다.</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 이없는 경우</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Distributed == default&lt;/code&gt; 인 경우 , Kernel 구성 매개 변수 &lt;code&gt;distributed&lt;/code&gt; 의 응용 프로그램 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">경우 &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; , 응용 프로그램이 배포된다. 인수는 &lt;code&gt;distributed&lt;/code&gt; 커널 구성 매개 변수의 응용 프로그램 값을 대체합니다 . &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름이어야합니다 (첫 번째 인수와 동일). 노드가 충돌하고 &lt;code&gt;Time&lt;/code&gt; 이 지정된 경우 응용 프로그램 제어기는 다른 노드에서 응용 프로그램을 다시 시작하기 전에 &lt;code&gt;Time&lt;/code&gt; 밀리 초) 동안 대기 합니다. 경우 &lt;code&gt;Time&lt;/code&gt; 지정되지 않은, 그것은 기본값은 &lt;code&gt;0&lt;/code&gt; 과 응용 프로그램이 즉시 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 정수 바이트 &lt;code&gt;0..255&lt;/code&gt; 또는 일반 바이트를 포함하는 이진 목록은 가능한 경우 클라이언트로 다시 전송됩니다. &lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;unicode&lt;/code&gt; 인 경우 전체 유니 코드 범위의 정수 목록 또는 UTF-8로 인코딩 된 이진은 클라이언트로 전송됩니다. 사용자 제공 함수는 항상 정수 목록을 보지만 절대 이진은 아니지만 &lt;code&gt;Encoding&lt;/code&gt; 이 &lt;code&gt;unicode&lt;/code&gt; 인 경우 목록에 숫자&amp;gt; 255가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">경우 &lt;code&gt;End == close&lt;/code&gt; 채널이 서버에 의해 폐쇄 될 때, 데이터는 호출자에게 반환된다. 이 시간이 초과되기 전에 &lt;code&gt;{timeout,Data}&lt;/code&gt; 가 발생하면 함수는 {timeout, Data}를 리턴합니다 (여기서 &lt;code&gt;Data&lt;/code&gt; 는 지금까지 수신 된 데이터 임).</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">경우 &lt;code&gt;End == timeout&lt;/code&gt; , 시간 제한이 예상되며, &lt;code&gt;{ok,Data}&lt;/code&gt; 타임 아웃의 경우 모두 반환되고 채널이 닫힐 때.</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">경우 &lt;code&gt;End&lt;/code&gt; 재미있는이다,이 재미는 하나 개의 인수, 수신의 데이터 값이라고 &lt;code&gt;ssh_cm&lt;/code&gt; 의 메시지 (참조 &lt;code&gt;ssh_connection(3)&lt;/code&gt; . 재미 중 하나를 반환하는 것입니다 &lt;code&gt;true&lt;/code&gt; 반환 지금까지 수집 된 데이터를 수신 동작을 종료 (그리고 가지고 ) 또는 &lt;code&gt;false&lt;/code&gt; 는 서버에서 더 많은 데이터를 기다립니다. 재미가 제공 되더라도 서버가 채널을 닫으면 즉시 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">경우 &lt;code&gt;EnumTypeName&lt;/code&gt; 이 정보를 ASN 사양에 존재하지 않는, 컴파일은 오류 코드가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; 이벤트 매니저는 세계적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; . 이름이 제공되지 않으면 이벤트 관리자가 등록되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; , 이벤트 매니저는 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; 레지스트리와 이벤트 관리자 레지스터에 의해 표현 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 콜백 함수 내보내이다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에 대응하는 기능으로 동작하도록하며, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;EventType&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , 응답 전화를 건 기다립니다. 회신이 또는 다른에서 보낼 수있는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 으로 반환하여 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 또는 호출하여 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">경우 &lt;code&gt;Expr1&lt;/code&gt; 이름으로 평가하지만,이 이름이 등록되지 않은하는 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">경우 &lt;code&gt;ExprF&lt;/code&gt; 가 원자이고, 함수는 사용하여 호출 할 수 있다고 &lt;strong&gt;암시 정규화 함수 이름&lt;/strong&gt; . &lt;code&gt;ExprF&lt;/code&gt; 함수 가 로컬로 정의 된 경우 호출됩니다. 또는 &lt;code&gt;M&lt;/code&gt; 모듈 에서 &lt;code&gt;ExprF&lt;/code&gt; 를 명시 적으로 가져 오는 경우 &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; 이 호출됩니다. 경우 &lt;code&gt;ExprF&lt;/code&gt; 이 둘 로컬로 선언되지도 명시 적으로 가져, &lt;code&gt;ExprF&lt;/code&gt; 은 자동으로 수입 BIF의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">경우 &lt;code&gt;Extra&lt;/code&gt; IS는 &lt;code&gt;log&lt;/code&gt; , 일치하는 이벤트가 허용됩니다. 경우 &lt;code&gt;Extra&lt;/code&gt; 이다 &lt;code&gt;stop&lt;/code&gt; , 일치하는 이벤트가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">경우 &lt;code&gt;Extra&lt;/code&gt; IS는 &lt;code&gt;log&lt;/code&gt; , 진행 보고서는 사용할 수 있습니다. 경우 &lt;code&gt;Extra&lt;/code&gt; 이다 &lt;code&gt;stop&lt;/code&gt; , 진행 보고서는 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">경우 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; , 또는 &lt;code&gt;Pad&lt;/code&gt; A는 &lt;code&gt;*&lt;/code&gt; 문자의 다음 인수 &lt;code&gt;Data&lt;/code&gt; 값으로 사용된다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">경우 &lt;code&gt;FIPS_mode_set&lt;/code&gt; 가 반환 &lt;code&gt;no&lt;/code&gt; 에는 OpenSSL 라이브러리를 사용할 수 없습니다 FIPS되지 않고 암호화 지원 모드 중 하나를 FIPS하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family3&lt;/code&gt; 은 인덱스 세트의 인덱스 집합 같다고 가정 등이다 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family3&lt;/code&gt; 가 [I] 사이의 차이이다 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I] 경우 &lt;code&gt;Family2&lt;/code&gt; 는 달리, I 매핑 &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;Family3&lt;/code&gt; 는 인덱스 집합의 교집합 가족 등이다 &lt;code&gt;Family1&lt;/code&gt; : S 및 &lt;code&gt;Family2&lt;/code&gt; 의 인덱스 집합 및 : &lt;code&gt;Family3&lt;/code&gt; [I]가 교차로 인 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I].</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 및 &lt;code&gt;Family2&lt;/code&gt; 가 있는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family3&lt;/code&gt; 은 인덱스 세트의 결합이라고 가정 등이다 &lt;code&gt;Family1&lt;/code&gt; S와 : &lt;code&gt;Family2&lt;/code&gt; 의 인덱스 집합 및 : &lt;code&gt;Family3&lt;/code&gt; 은 [I]는의 조합이다 &lt;code&gt;Family1&lt;/code&gt; [I] 및 &lt;code&gt;Family2&lt;/code&gt; [I] 만약 둘 다 맵 i, 그렇지 않으면 &lt;code&gt;Family1&lt;/code&gt; [i] 또는 &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 은 [I] .</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 이진 관계이다 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는 인 &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 은 [I] .</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I]은 I의 인덱스 세트에서의 각각의 세트의 집합 &lt;code&gt;Family1&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는 인 &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 는 [I ].</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;Family1&lt;/code&gt; [I] 모든 I의 인덱스 세트에 대한 세트의 집합 &lt;code&gt;Family1&lt;/code&gt; 는 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]는이다 &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; [내가 ].</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 은 IS &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; 하는 I 인덱스 집합의 해당 요소에 &lt;code&gt;Fun&lt;/code&gt; 인가 &lt;code&gt;Family1&lt;/code&gt; [I] 복귀 &lt;code&gt;true&lt;/code&gt; . 경우 &lt;code&gt;Fun&lt;/code&gt; 튜플 &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; 다음 &lt;code&gt;Fun2&lt;/code&gt; 에가 에인가되는 &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Family1&lt;/code&gt; [I], 그렇지 &lt;code&gt;Fun&lt;/code&gt; 에인가 &lt;code&gt;Family1&lt;/code&gt; [I].</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; 는 A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;Family2&lt;/code&gt; 은 동일한 인덱스 세트와 가족 &lt;code&gt;Family1&lt;/code&gt; 되도록 &lt;code&gt;Family2&lt;/code&gt; [I]이 호출의 결과 &lt;code&gt;SetFun&lt;/code&gt; 와 &lt;code&gt;Family1&lt;/code&gt; 인수 [I]가.</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">경우 &lt;code&gt;Family1&lt;/code&gt; [I]은 몇 가지 내가하는과 프로세스가 종료에 대해 빈 집합입니다 &lt;code&gt;badarg&lt;/code&gt; 의 메시지.</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">경우 &lt;code&gt;Family&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;BinRel&lt;/code&gt; 는 난의 인덱스 집합에 속하도록 모든 쌍 (I, X)를 함유하는 바이너리 관계이다 &lt;code&gt;Family&lt;/code&gt; 및 X에 속하는 &lt;code&gt;Family&lt;/code&gt; [I]가.</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">경우 &lt;code&gt;File&lt;/code&gt; 지정되지 않은 크래시 덤프를 선택 할 수있는, 파일 대화 상자가 열립니다.</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 을 실행할 수없는 경우 POSIX 오류 코드를 이유로 오류 예외가 발생합니다. 오류 이유는 OS마다 다를 수 있습니다. 일반적으로 오류 &lt;code&gt;enoent&lt;/code&gt; 시도가 발견되지 않고 프로그램을 실행하려고 할 때 발생 &lt;code&gt;eacces&lt;/code&gt; 지정된 파일이 실행되지 않을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 에 객체 파일 ( &lt;code&gt;.beam&lt;/code&gt; ) 을 나타내는 접미사가있는 경우 EUnit은 지정된 파일에서 모듈을 다시로드하여 테스트합니다. 그렇지 않은 경우, 파일은 테스트 라이브러리를 포함하는 텍스트 파일 인 것으로 간주되며 표준 라이브러리 함수 &lt;code&gt;file:path_consult/2&lt;/code&gt; 사용하여 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">경우 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 는 A는 &lt;code&gt;string()&lt;/code&gt; , &lt;code&gt;make_config/1&lt;/code&gt; 사용 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 을 파일 이름으로. &lt;code&gt;FileNameOrIODev&lt;/code&gt; 라는 파일 이 작성되고 구성이 해당 파일에 작성됩니다. 경우 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 가 이다 &lt;code&gt;io_device()&lt;/code&gt; (모듈의 참조 문서 &lt;code&gt;io&lt;/code&gt; 구성은 입출력 장치에 기록 될 것이다).</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Filename&lt;/code&gt; 기호 링크, 바로이 함수가 반환 같은 결과하지 &lt;code&gt;read_file_info/1&lt;/code&gt; . 심볼릭 링크를 지원하지 않는 플랫폼에서이 기능은 항상 &lt;code&gt;read_file_info/1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">경우 &lt;code&gt;Fix&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 테이블 &lt;code&gt;Name&lt;/code&gt; , 그렇지 않으면 테이블이 출시, 호출 프로세스에 의해 (한 번 더) 고정됩니다. 고정 프로세스가 종료되면 테이블도 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">&lt;code&gt;Flag&lt;/code&gt; 가 &lt;code&gt;get&lt;/code&gt; 인 경우 , 기록 된 모든 이벤트 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;print&lt;/code&gt; , 기록 된 이벤트가 인쇄됩니다 &lt;code&gt;standard_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 새 구독이 시작됩니다. &lt;code&gt;Flag&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 동일한 &lt;code&gt;Options&lt;/code&gt; 시작된 모든 이전 구독 이 중지됩니다. 두 옵션 목록에 동일한 옵션 집합이 포함 된 경우 두 옵션 목록은 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">경우 &lt;code&gt;Flags = all&lt;/code&gt; , 모든 가능한 플래그가 셋 (Set)됩니다.</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Flush&lt;/code&gt; 로 설정 &lt;code&gt;finish&lt;/code&gt; 보류 입력 보류 출력 플러시 처리, 및 &lt;code&gt;deflate/3&lt;/code&gt; 복귀한다. 이후 스트림에서 유일하게 가능한 조작은 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">&lt;code&gt;Flush&lt;/code&gt; 가 &lt;code&gt;full&lt;/code&gt; 로 설정 되면 &lt;code&gt;sync&lt;/code&gt; 와 같이 모든 출력이 플러시되고 이전 압축 데이터가 손상되었거나 임의 액세스가 필요한 경우 압축 해제 상태가이 지점부터 다시 시작될 수 있도록 압축 상태가 재설정됩니다. 사용하여 &lt;code&gt;full&lt;/code&gt; 너무 자주하는 것은 심각한 압축 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">&lt;code&gt;Flush&lt;/code&gt; 가 &lt;code&gt;sync&lt;/code&gt; 로 설정 되면 보류중인 모든 출력이 출력 버퍼로 플러시되고 출력이 바이트 경계로 정렬되므로 압축 해제 기는 지금까지 사용 가능한 모든 입력 데이터를 얻을 수 있습니다. 플러싱은 일부 압축 알고리즘의 압축을 저하시킬 수 있습니다. 따라서 필요할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">&lt;code&gt;Force = true&lt;/code&gt; 경우 에이전트는 이전 mib를로드하지 못한 후에도 각 mib를 계속로드하려고 시도합니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">경우 &lt;code&gt;Force = true&lt;/code&gt; 다음 에이전트는 심지어 이전 MIB를 언로드 실패한 후 각 MIB을 언로드하려고 할 것입니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; , &lt;code&gt;et_viewer&lt;/code&gt; 응용 프로그램 ET의 그래픽 추적 로그를 제시하는 데 사용됩니다. &lt;code&gt;ttb&lt;/code&gt; 메뉴에서 선택할 수있는 몇 가지 필터 제공 &lt;strong&gt;필터 및 확장&lt;/strong&gt; 에 &lt;code&gt;et_viewer&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; 각 추적 메시지라고합니다.</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">경우 &lt;code&gt;FormatHandler&lt;/code&gt; 가 지정되지 않은, 기본 핸들러는 텍스트 라인으로 각 추적 메시지를 제시 사용된다.</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">경우 &lt;code&gt;Forms&lt;/code&gt; 이외에 다른 유형의 구문 트리입니다 &lt;code&gt;form_list&lt;/code&gt; 가 , 의견을 사용하여 직접 삽입됩니다 &lt;code&gt;recomment_tree/2&lt;/code&gt; 및 의견은 결과에 postcomments로 추가되는 과정에서 남은.</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">경우 &lt;code&gt;Fun(Item)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Item&lt;/code&gt; 결과 큐에 복사됩니다. &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;Item&lt;/code&gt; 이 복사되지 않습니다. 목록을 반환 하면 결과 큐 에 &lt;code&gt;Item&lt;/code&gt; 대신 목록 요소가 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 로컬 재미는, &lt;code&gt;Module&lt;/code&gt; 재미가 정의 된 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 로컬 재미이고, &lt;code&gt;Name&lt;/code&gt; 로컬 기능을 구현하는 재미의 이름입니다. (이 이름은 컴파일러에 의해 생성되었으며 정보 용으로 만 사용됩니다. 로컬 함수이므로 직접 호출 할 수 없습니다.) 현재 재미를 위해로드 된 코드가 없으면 원자 대신 &lt;code&gt;[]&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 외부 재미는, &lt;code&gt;Module&lt;/code&gt; 재미가 참조하는 모듈이다.</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">하면 &lt;code&gt;Fun&lt;/code&gt; 외부 재미이고, &lt;code&gt;Name&lt;/code&gt; 재미가 참조하는 내 보낸 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">경우 &lt;code&gt;Function&lt;/code&gt; 삽입이 테이블에 객체, 또는 다른 프로세스에 삽입이 테이블에 개체를 해당 개체 &lt;strong&gt;수&lt;/strong&gt; (키 순서에 따라)가 통과에 포함.</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">경우 &lt;code&gt;HandlerId&lt;/code&gt; 입니다 &lt;code&gt;default&lt;/code&gt; 호출하는 것과,이 항목의 수정 기본 핸들러,</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;How == read&lt;/code&gt; 나에 버퍼링 더 나가는 데이터가없는 &lt;code&gt;Socket&lt;/code&gt; 포트 소켓이 즉시 종료 및 발견 된 모든 오류가 반환됩니다 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">경우 &lt;code&gt;How&lt;/code&gt; 문서화 된 대안 중 하나가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;I&lt;/code&gt; 는 음이 아닌 정수가 아니거나 배열 크기를 고정하고있는 경우 &lt;code&gt;I&lt;/code&gt; 가 최대 인덱스보다 큰 경우, 호출 실패 원인 &lt;code&gt;badarg&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">경우 &lt;code&gt;IgnoreCase&lt;/code&gt; 를이 입니다 &lt;code&gt;true&lt;/code&gt; 함수는 않습니다 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; 평등 시험 전에 즉시.</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 가 인 &lt;code&gt;latin1&lt;/code&gt; 정수&amp;gt; 255 목록에서 발견 될 때마다, 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">&lt;code&gt;InEncoding&lt;/code&gt; 이 &lt;code&gt;latin1&lt;/code&gt; 인 경우 각 바이트가 유효한 ISO Latin-1 범위에 속하므로 바이너리는 전체 바이트를 포함하는 한 항상 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 가 인 &lt;code&gt;latin1&lt;/code&gt; 파라미터 &lt;code&gt;Data&lt;/code&gt; 에 해당합니다 &lt;code&gt;iodata()&lt;/code&gt; 형이지만위한 &lt;code&gt;unicode&lt;/code&gt; 파라미터 &lt;code&gt;Data&lt;/code&gt; 정수&amp;gt; 255 (는 ISO 라틴 1 벗어난 유니 코드 문자)를 포함 할 수 있으며,이 무효하게되는 &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 는 유니 코드 유형 인 다음 중 하나가 발견 될 때마다 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">경우 &lt;code&gt;InEncoding&lt;/code&gt; 이 가 UTF 유형 중 하나입니다, 어떤 바이너리 바이트는 인코딩 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;Incr =:= 0&lt;/code&gt; 및 &lt;code&gt;From =/= To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;IpPort&lt;/code&gt; 은 생략한다 &lt;code&gt;162&lt;/code&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;IsDst == true&lt;/code&gt; , &lt;code&gt;Localtime&lt;/code&gt; 일광 절약 시간 동안이며, 경우 &lt;code&gt;IsDst == false&lt;/code&gt; 이 아니다. 경우 &lt;code&gt;IsDst == undefined&lt;/code&gt; , 기본 OS는 호출과 같은 어떤 추측 할 &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; 이 잘못된 항목 인 경우</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ItemList&lt;/code&gt; 지정되면, 결과는 &lt;code&gt;InfoTupleList&lt;/code&gt; . &lt;code&gt;InfoTuple&lt;/code&gt; 에서의 &lt;code&gt;InfoTupleList&lt;/code&gt; 는 대응 포함 된 &lt;code&gt;Item&lt;/code&gt; 은 AS 동일한 순서의 &lt;code&gt;Item&lt;/code&gt; 에 포함 된 S &lt;code&gt;ItemList&lt;/code&gt; . 유효한 &lt;code&gt;Item&lt;/code&gt; 은 &lt;code&gt;ItemList&lt;/code&gt; 에 여러 번 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">경우 &lt;code&gt;Key&lt;/code&gt; 하지 존재하지, 새로운 기록이 값으로 생성됩니다 &lt;code&gt;Incr&lt;/code&gt; 이 0보다 큰 경우, 그렇지 않으면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">경우 &lt;code&gt;Key&lt;/code&gt; 존재 &lt;code&gt;Map1&lt;/code&gt; 이전 관련 값은 값으로 대체됩니다 &lt;code&gt;Value&lt;/code&gt; . 이 함수는 새로운 관련 값이 포함 된 새 맵 &lt;code&gt;Map2&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">경우 &lt;code&gt;KeyOrName&lt;/code&gt; 가 구성된 것이다 &lt;code&gt;server_id()&lt;/code&gt; 또는 &lt;code&gt;target_name()&lt;/code&gt; 와 같은 ID와 연관된가,이 서버에 대한 옵션은 구성 파일로부터 페치된다.</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">경우 &lt;code&gt;LinkTo&lt;/code&gt; PID를이, 그것은 로그의 소유자가됩니다. 경우 &lt;code&gt;LinkTo&lt;/code&gt; 없는 &lt;code&gt;none&lt;/code&gt; ,가 증가하여 일부 프로세스에 의해 익명으로 사용하는 로그 레코드 &lt;code&gt;users&lt;/code&gt; 카운터. 기본적으로 &lt;code&gt;open/1&lt;/code&gt; 을 호출하는 프로세스 는 로그를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ListOfBinRels&lt;/code&gt; 가 비어 목록 [R [1], ..., R [N] 이진 관계의 &lt;code&gt;BinRel1&lt;/code&gt; 는 이진 관계이다 후 &lt;code&gt;BinRel2&lt;/code&gt; 이 는 IS &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; [I] 순서화 세트 (R의이. .., R [n]) 및 &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">&lt;code&gt;Loader&lt;/code&gt; 가 다른 것이라면 , 사용자 제공 &lt;code&gt;Loader&lt;/code&gt; 포트 프로그램이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 은 바이너리이며, &lt;code&gt;tftp_binary&lt;/code&gt; 는 콜백 모듈로 사용된다. 이진은 블록 단위로 전송되며 전송 된 바이트 수는 &lt;code&gt;LastCallbackState&lt;/code&gt; 에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 문자열이며, 등록 된 콜백 모듈이없는, &lt;code&gt;tftp_file&lt;/code&gt; 는 콜백 모듈로서 사용된다. &lt;code&gt;LocalFilename&lt;/code&gt; 이라는 파일을 블록별로 읽고 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 전송 된 바이트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 문자열이며, 등록 된 콜백 모듈이없는, &lt;code&gt;tftp_file&lt;/code&gt; 는 콜백 모듈로서 사용된다. 전송 된 각 블록을 &lt;code&gt;LocalFilename&lt;/code&gt; 파일 에 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 전송 된 바이트 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 이 문자열이 등록 된 콜백 모듈이 있으며, &lt;code&gt;LocalFilename&lt;/code&gt; 는 이들 및 제 매치에 대응하는 콜백 모듈 regexps '에 대해 테스트되어 사용되거나 일치하는 정규 표현식이 발견되지 않는 경우 오류 튜플이 반환된다.</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;LocalFilename&lt;/code&gt; 는 원자 인 &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;tftp_binary&lt;/code&gt; 는 콜백 모듈로서 사용된다. 전송 된 모든 블록을 연결하고 &lt;code&gt;LastCallbackState&lt;/code&gt; 에서 단일 바이너리로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 이 map 유형이 아닌 경우 , &lt;code&gt;badmap&lt;/code&gt; 유형의 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">키 교환에서 &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; 이면 연결 끊김으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">&lt;code&gt;Minutes&lt;/code&gt; 가 &lt;code&gt;infinity&lt;/code&gt; 로 설정 되면 최대 시간이 지났기 때문에 다시 키잉이 발생하지 않습니다. &lt;code&gt;Bytes&lt;/code&gt; 를 &lt;code&gt;infinity&lt;/code&gt; 설정 하면 특정 양의 데이터가 전송 된 후 키 재 지정이 금지됩니다. 옵션 값이 &lt;code&gt;{infinity, infinity}&lt;/code&gt; 되면 키 변경이 시작되지 않습니다. 피어가 시작한 키 다시 입력은 여전히 ​​수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 가 일치하지 않는 트랜잭션 결정 감지 &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; 시스템 이벤트는 응용 프로그램을 대체 또는 불일치를 해결하기위한 다른 적절한 조치를 설치할 수있는 기회를 제공하기 위해 생성된다. &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러 의 기본 동작은 앞에서 설명한대로 파티션 된 네트워크의 결과로 데이터베이스가 일치하지 않는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 는 로컬 노드와 다른 노드 모두받은 시작할 검출 &lt;code&gt;mnesia_down&lt;/code&gt; 서로, &lt;code&gt;Mnesia&lt;/code&gt; 는 생성 &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; 시스템 이벤트를 이전에 기재된 바와 같이 작용한다.</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 파일이 제대로 가능성이 정전의 결과로 폐쇄되지 않았 음을 감지, 그것은 유사한 방식으로 나쁜 파일을 복구하려고합니다. 데이터가 손실 될 수 있지만 데이터가 일치하지 않더라도 &lt;code&gt;Mnesia&lt;/code&gt; 를 다시 시작할 수 있습니다. 구성 매개 변수 &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; 을 사용하여 시작시 &lt;code&gt;Mnesia&lt;/code&gt; 의 동작을 제어 할 수 있습니다 . 경우 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; 은 파일을 복구하려고 시도합니다. 경우 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 값이 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; 은 이 용의자 파일을 감지하면 다시 시작하지 않습니다. 이 구성 매개 변수는 로그 파일 &lt;code&gt;DAT&lt;/code&gt; 의 복구 동작에 영향을줍니다. 파일 및 기본 백업 미디어.</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 거래에 참여하는 일부 노드에서 시작되지 &lt;strong&gt;및&lt;/strong&gt; 로컬 노드 나 이미 실행중인 노드 중 어느 것도 트랜잭션의 결과를 알고, &lt;code&gt;Mnesia&lt;/code&gt; 은 기본적으로 일을 기다립니다. 최악의 시나리오에서는 &lt;code&gt;Mnesia&lt;/code&gt; 가 트랜잭션에 대한 올바른 결정을 내리고 시작을 완료 하기 전에 다른 모든 관련 노드를 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 고장, 시스템 정보를 파일로 덤프됩니다 &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; 을 . 이 파일에 포함 된 시스템 정보 유형은 &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; 함수를 사용하여 생성 할 수도 있습니다 . 경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 시스템이 이상하게 작동,하는 것이 좋습니다 &lt;code&gt;Mnesia&lt;/code&gt; 코어 덤프 파일이 버그 리포트에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">만약 &lt;code&gt;Module2:init/1&lt;/code&gt; 반환 올바른 값이 함수의 반환 &lt;code&gt;ok&lt;/code&gt; . 경우 &lt;code&gt;Module2:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; 또는 리턴 값 예기치 &lt;code&gt;Term&lt;/code&gt; 이 함수 리턴 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 또는 &lt;code&gt;{error,Term}&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패하거나 반환 오류 튜플 또는 잘못된 값이 함수가 반환 &lt;code&gt;{error,Errorr}&lt;/code&gt; , &lt;code&gt;Error&lt;/code&gt; 오류에 대한 정보와 용어이며, 이유와 감독자 브리지 종료 &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 잘못된 값이 함수가 반환 실패하거나 반환 &lt;code&gt;{error,Term}&lt;/code&gt; , &lt;code&gt;Term&lt;/code&gt; 오류에 대한 정보와 용어이며, 이유와 감독자 종료 &lt;code&gt;Term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">만약 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; , 함수가 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 복귀 &lt;code&gt;{stop,Reason}&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; , 처리를 종료하고, 함수 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; ,이 함수가 반환 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 복귀 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , 처리를 종료하고,이 함수가 리턴 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 &lt;code&gt;ignore&lt;/code&gt; ,이 함수가 반환은 &lt;code&gt;ignore&lt;/code&gt; 뿐만 아니라 이성과 감독자 브리지 종료 &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 &lt;code&gt;ignore&lt;/code&gt; ,이 함수가 반환은 &lt;code&gt;ignore&lt;/code&gt; 뿐만 아니라, 이성과 수퍼바이저 종료 &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Module:init/1&lt;/code&gt; 반환 성공적인 완료를 나타내는 정확한 값을, 이벤트 관리자는 이벤트 핸들러이 함수가 반환의 추가 &lt;code&gt;ok&lt;/code&gt; . 경우 &lt;code&gt;Module:init/1&lt;/code&gt; 실패 &lt;code&gt;Reason&lt;/code&gt; 또는 반환 &lt;code&gt;{error,Reason}&lt;/code&gt; , 이벤트 핸들러가 무시되고이 함수가 반환 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">경우 &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; 내보낼 수 없습니다, common_test 호출을 시도합니다 &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; 대신. 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 원자이고, 소스 파일의 경로가 아닌, 다음의 코드로 모듈의 오브젝트 파일을 찾아 원래 컴파일러 옵션과 소스 경로를 추출하기 위해 검색된다. 소스 파일이 원래 위치에없는 경우 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 오브젝트 파일의 디렉토리를 기준으로 해당 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 해석됩니다 인터프리터가 호출되고 해석의 반환 값 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 호출이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 로드되고 오브젝트 파일이 존재하고 같은 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 로드하지만하지 않습니다 네이티브 코드를</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되었지만 코드 경로에서 해당 오브젝트 파일을 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되었지만 오브젝트 파일에 다른 MD5 체크섬이있는 코드가 포함 된 경우 .</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 Cover 컴파일되지 않은 경우 함수는 &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 원자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이 현재로드되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 제공되지 않으며, 모든 커버 컴파일 또는 이전 수입 모듈에 대한 데이터를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이로드되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">경우 &lt;code&gt;Module&lt;/code&gt; 네이티브 코드가로드로드 된 모듈의 이름입니다</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Modules&lt;/code&gt; 원자 (하나 개의 모듈)이며, 반환 될 것이다 &lt;code&gt;Answer&lt;/code&gt; 다른 리턴이리스트 것, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Modules&lt;/code&gt; 원자 (하나 개의 모듈)은 상기 복귀 할 것이다 &lt;code&gt;OneResult&lt;/code&gt; 다른 반환 될 것이다 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">경우에 &lt;code&gt;Modules&lt;/code&gt; 주어지지 커버 데이터 테이블의 데이터가 모든 모듈은 분석된다. 여기에는 커버 컴파일 된 모듈과 가져온 모듈이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">경우 &lt;code&gt;Modules=dynamic&lt;/code&gt; 이벤트 매니저의 경우, 이벤트 매니저 프로세스 정보 용 현재 설치된 이벤트 핸들러 (목록에 대한 분리 처리기 &lt;code&gt;gen_event&lt;/code&gt; 는 모듈 이름 대신에이리스트에있는 경우)을 체크한다.</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;MonitorPid&lt;/code&gt; 가없는 경우</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">&lt;code&gt;MonitorPid&lt;/code&gt; 가 로컬 프로세스가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">경우 &lt;code&gt;MonitorRef&lt;/code&gt; 가 호출 프로세스를 호출하여 얻은 기준 인 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 이 모니터링은 턴 오프된다. 모니터링이 이미 꺼져 있으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; = 0 인 경우 프로세스에 대해 통화 저장이 비활성화됩니다 (기본값). 통화 저장 목록의 크기가 설정 될 때마다 그 내용이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; (별칭 이름 &lt;code&gt;Key&lt;/code&gt; ) 연결을 식별하는 데 사용됩니다,이 이름은 후속 호출에 대한 연결 참조로 사용할 수 있습니다. &lt;code&gt;Name&lt;/code&gt; 과 관련된 한 번에 하나의 열린 연결 만 가능합니다. &lt;code&gt;Key&lt;/code&gt; 가 사용되는 경우 , 후속 호출에 리턴 된 핸들을 사용해야합니다 ( &lt;code&gt;Key&lt;/code&gt; 에 지정된 구성 데이터를 사용하여 다중 연결을 열 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 입력 모듈 중 하나의 이름 인 경우 해당 모듈의 코드가 결과 코드 상단에 표시되며 추가 &quot;헤더&quot;주석이 추가되지 않습니다. 즉, 해당 모듈의 모양이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 입니다 &lt;code&gt;ip_address()&lt;/code&gt; , 표준 역으로 생성을위한 쿼리 도메인 이름 &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; IPv4 주소의 이름 또는 &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; IPv6 주소의 이름입니다. 이 경우 &lt;code&gt;Class = in&lt;/code&gt; 및 &lt;code&gt;Type = ptr&lt;/code&gt; 을 사용하려고 하지만 자동으로 수행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 발견, 메시지 &lt;code&gt;Msg&lt;/code&gt; 해당 PID로 전송됩니다. pid는 함수의 반환 값이기도합니다. 이름을 찾지 못하면이 함수는 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 발견, 해당 PID가 반환됩니다. 이름을 찾지 못하면 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 전역 적으로 등록 된 이름이 아닌 경우 호출 함수는 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 이유로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 심볼릭 링크 아니라,이 기능은 동일한 결과를 반환 &lt;code&gt;read_file_info/1&lt;/code&gt; . 심볼릭 링크를 지원하지 않는 플랫폼에서이 기능은 항상 &lt;code&gt;read_file_info/1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;Dir&lt;/code&gt; 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">경우 &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; 상기 &lt;code&gt;net_ticktime&lt;/code&gt; 변화 천이 기간의 종료에서 수행되고; 그렇지 않으면 처음에. 전환 기간 동안 &lt;code&gt;net_kernel&lt;/code&gt; 은 모든 연결에서 적어도 &lt;code&gt;MTTI&lt;/code&gt; 밀리 초 마다 나가는 트래픽이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;NewVsn&lt;/code&gt; 가 옵션으로 설치되어 &lt;code&gt;{update_paths,true}&lt;/code&gt; , 다음 &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; 를 반환 &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">경우 &lt;code&gt;NextState =/= State&lt;/code&gt; 상태 기계는 새로운 상태로 변경됩니다. 활성화 된 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; 이 수행되고 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; 모든 이벤트 가 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 실패하거나 존재하지 않는 메시지 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 프로세스에 전달된다. 프로세스가 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 를 두 번 호출 하고 &lt;code&gt;Node&lt;/code&gt; 종료되면 두 개의 노드 &lt;code&gt;nodedown&lt;/code&gt; 메시지가 프로세스에 전달됩니다. &lt;code&gt;Node&lt;/code&gt; 에 연결되지 않은 경우 Node 를 작성하려고 시도합니다. 이것이 실패하면 &lt;code&gt;nodedown&lt;/code&gt; 메시지가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 있습니다 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;Options&lt;/code&gt; 다음 또한 configration 매개 변수 커널에 추가됩니다 &lt;code&gt;inet_dist_listen_options&lt;/code&gt; 및 &lt;code&gt;inet_dist_connect_options&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Node&lt;/code&gt; 연결된 노드가 반환 값은에서와 동일합니다 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;Sock&lt;/code&gt; 에 대한 배포 소켓입니다 &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">경우 &lt;code&gt;NodeRefs&lt;/code&gt; 이 값이 &lt;code&gt;all_nodes&lt;/code&gt; 을 , 작동 또는 시험은 지정된 모든 테스트 노드에서 수행됩니다. ( &lt;code&gt;NodeRefs&lt;/code&gt; 요소가 없는 용어를 선언 해도 같은 효과가 있습니다). 경우 &lt;code&gt;NodeRefs&lt;/code&gt; 이 값이 &lt;code&gt;master&lt;/code&gt; , 동작 만 수행되는 &lt;code&gt;Common Test&lt;/code&gt; 마스터 노드 (즉, 로그 디렉토리를 설정하거나 이벤트 처리기를 설치합니다).</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;Nodename&lt;/code&gt; 로컬 노드 오류 이유 &lt;code&gt;cant_add_local_node&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Norm&lt;/code&gt; 되지 않습니다 &lt;code&gt;none&lt;/code&gt; 이 함수는 평등 시험 전에 즉시 정상화를 적용합니다. &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; 의 네 가지 정규화 형식이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 는 목록, 기능 검사입니다 &lt;strong&gt;모든&lt;/strong&gt; 키 아무것도 삽입하기 전에이. 목록에 존재하는 &lt;strong&gt;모든&lt;/strong&gt; 키가 테이블에없는 경우가 아니면 삽입되지 않습니다. &lt;code&gt;insert/2&lt;/code&gt; 와 마찬가지로 전체 작업은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 이 32 비트 정수에 맞지 않는 경우</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 이 32 비트 정수에 맞지 않는 경우</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Opt&lt;/code&gt; 어떤 원자, 그것은으로 해석됩니다 &lt;code&gt;{Opt,true}&lt;/code&gt; 과 원자 문자열 시작하지 않는 한 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 를 해석하고, &lt;code&gt;{Opt,false}&lt;/code&gt; . 예를 들어, &lt;code&gt;usevc&lt;/code&gt; 는 &lt;code&gt;{usevc,true}&lt;/code&gt; 의 별명 이고 &lt;code&gt;nousevc&lt;/code&gt; 는 &lt;code&gt;{usevc,false}&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">경우 &lt;code&gt;OptList&lt;/code&gt; 은 유효한의 적절한 목록이 아닙니다 &lt;code&gt;Opt&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;OptParams&lt;/code&gt; 이 제공되지 않으며, 기본값은 &lt;code&gt;[]&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; 이 유효하지 않은 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 유효하지 않은 옵션 목록 인 경우</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 유효하지 않은 옵션 목록 인 경우</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 가 목록이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Options&lt;/code&gt; 이다 &lt;code&gt;[]&lt;/code&gt; 로서 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 이 목록 인 경우 &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; 와 동일하지만 그렇지 않으면 &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; 하지만이 함수를 직접 사용하는 것이 더 효율적입니다 .</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 가 &lt;code&gt;[]&lt;/code&gt; 가 아닌 경우 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">경우 &lt;code&gt;Opts&lt;/code&gt; 지정하거나 경우되지 &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; 대 삭제되고 새로운 파일이 만들어집니다. 경우 &lt;code&gt;Opts = [append]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; 대 삭제되지 않는다. 새로운 정보는 파일 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">경우 &lt;code&gt;Out&lt;/code&gt; 지정되어, &lt;code&gt;FormatHandler&lt;/code&gt; 는 에 파일 기술자 가져 &lt;code&gt;Out&lt;/code&gt; 첫 번째 매개 변수로합니다.</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; , 옵션 &lt;code&gt;asynchronous&lt;/code&gt; 의 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 사용되었으며 suspendee 아직에 의해 중단되지 &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Path&lt;/code&gt; 디렉토리입니다, &lt;code&gt;default_index/2&lt;/code&gt; , 그것은 설정 지시어에 지정된 자원이나 파일 검색을 시작 &lt;code&gt;DirectoryIndex&lt;/code&gt; 에 . 적절한 리소스 나 파일이 발견되면 &lt;code&gt;Path&lt;/code&gt; 끝에 추가 된 다음 반환됩니다. &lt;code&gt;Path&lt;/code&gt; 에는 해당 파일이 발견되지 않은 경우 변경되지 않은 반환되는 경우 또는 &lt;code&gt;Path&lt;/code&gt; 디렉토리가 아니다. &lt;code&gt;config_db()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된대로 ETS 테이블 형식의 서버 구성 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">경우 &lt;code&gt;Pattern1&lt;/code&gt; 과 &lt;code&gt;Pattern2&lt;/code&gt; 유효한 패턴은, 다음도 유효한 패턴입니다 :</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 이 2 진이거나 길이가 0보다 &lt;code&gt;badarg&lt;/code&gt; 적절한 바이너리 목록이 아닌 경우 잘못된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Pid2&lt;/code&gt; 존재하지 않는의 'DOWN'메시지가 즉시 전송됩니다 &lt;code&gt;Reason&lt;/code&gt; 로 설정 &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;Pid2&lt;/code&gt; 종료 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; 하는 'DOWN'메시지가 전송됩니다 &lt;code&gt;Pid1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 동일 &lt;code&gt;self()&lt;/code&gt; , 어떤 &lt;code&gt;async&lt;/code&gt; 옵션이 통과되지 않은, 가비지 컬렉션, 호출하는 것과 동일하다, 한 번에 수행 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; . 그렇지 않으면 가비지 수집 요청이 &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스로 전송되고 적절한 경우 처리됩니다. &lt;code&gt;async&lt;/code&gt; 옵션이 전달 되지 않은 경우 호출자 는 &lt;code&gt;GCResult&lt;/code&gt; 가 사용 가능하고 리턴 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 동일 &lt;code&gt;self()&lt;/code&gt; , 어떤 &lt;code&gt;async&lt;/code&gt; 옵션이 통과되지 않은, 동작을 한 번에 수행됩니다. 그렇지 않으면 작업에 대한 요청이 &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스로 전송되고 적절한 경우 처리됩니다. &lt;code&gt;async&lt;/code&gt; 옵션이 전달 되지 않으면 호출자 는 &lt;code&gt;CheckResult&lt;/code&gt; 가 사용 가능하고 리턴 될 때까지 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; ,에서 반환 된 PID 인 I / O 장치입니다 &lt;code&gt;open/2&lt;/code&gt; ,이 기능은 파일 이름을 반환하거나 오히려 :</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 로컬 프로세스가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 노드 로컬 프로세스 식별자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Pid&lt;/code&gt; 종료 트래핑되지, &lt;code&gt;Pid&lt;/code&gt; 자체가 종료 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 엑시트를 트래핑하는 경우 엑시트 신호는 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 메시지로 변환되어 &lt;code&gt;Pid&lt;/code&gt; 의 메시지 큐로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;PidOrPort&lt;/code&gt; 가 존재하지 않는 경우 BIF의 동작은 호출 프로세스가 종료를 트래핑하는지 여부에 따라 다릅니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">&lt;code&gt;PidOrPort&lt;/code&gt; 가 기존 로컬 프로세스 또는 포트가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">경우 &lt;code&gt;Port == 0&lt;/code&gt; , 기본 OS의 양수인 무료 UDP 포트를 사용 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">경우 &lt;code&gt;Port == 0&lt;/code&gt; , 기본 OS의 양수인 사용 가능한 포트 번호를 사용 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">경우 &lt;code&gt;Port&lt;/code&gt; 열려있는 포트의 식별자, 또는 열린 포트의 등록 된 이름이 아닙니다. 호출 프로세스가 이전에 &lt;code&gt;Port&lt;/code&gt; 로 식별 된 닫힌 포트에 링크 된 경우, 이 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생 하기 전에 포트의 종료 신호가 전달되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">&lt;code&gt;Port&lt;/code&gt; 가 열린 포트 또는 열린 포트의 등록 된 이름이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;PosLen&lt;/code&gt; 이 진 밖에서 어떤 식 으로든 참조에서는, &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Prefix&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 의 접두사 인 경우 접두사를 제거하고 나머지 &lt;code&gt;String&lt;/code&gt; 을 반환하고 , 그렇지 않으면 &lt;code&gt;nomatch&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">경우 &lt;code&gt;QH2&lt;/code&gt; 을 위한 함수 호출이다 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 섹션에 정의 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;gb_table:table/1&lt;/code&gt; 은 GB-트리 반복기는 각 응답에 대한 개시 &lt;code&gt;QH1&lt;/code&gt; . 그런 다음 gb-tree의 객체가 하나씩 반환됩니다. 다음과 같은 객체를 얻는 데 최소한의 계산 능력이 필요하기 때문에이 경우 테이블을 순회하는 가장 효율적인 방법 일 것입니다. 그러나 &lt;code&gt;QH2&lt;/code&gt; 가 테이블이 아니라 더 복잡한 QLC 인 경우, 특히 응답이 적은 경우 캐시에서 응답을 수집하기 위해 일부 RAM 메모리를 사용하는 것이 더 효율적일 수 있습니다. 그러면 &lt;code&gt;QH2&lt;/code&gt; 를 평가하는 것으로 가정해야합니다 &lt;code&gt;QH2&lt;/code&gt; 가 한 번만 평가되는 경우 쿼리의 의미가 변경되지 않도록 부작용이 없습니다 . 답변을 캐싱하는 한 가지 방법은 우선 &lt;code&gt;QH2&lt;/code&gt; 를 평가 하고 쿼리에서 &lt;code&gt;QH2&lt;/code&gt; 에 대한 답변 목록을 대체하는 것 입니다. 또 다른 방법은 옵션 &lt;code&gt;cache&lt;/code&gt; 를 사용하는 것 입니다. 다음과 같이 표현됩니다 :</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Reason&lt;/code&gt; 원자이다 &lt;code&gt;kill&lt;/code&gt; 입니다, 경우 &lt;code&gt;exit(Pid, kill)&lt;/code&gt; 라고하며, untrappable 종료 신호로 전송 &lt;code&gt;Pid&lt;/code&gt; 종료 이유 무조건 종료가, &lt;code&gt;killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">경우 &lt;code&gt;Reason&lt;/code&gt; 원자입니다 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;Pid&lt;/code&gt; 종료하지 않습니다. 엑시트를 트래핑하는 중이면 엑시트 신호는 &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; 메시지로 변환되어 해당 메시지 큐로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;Receiver&lt;/code&gt; 값이 &lt;code&gt;{Tag, Recv}&lt;/code&gt; , 인도가에 따라 수행되고 &lt;code&gt;Recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">경우 &lt;code&gt;Receiver&lt;/code&gt; A는 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 다음 알림 전달에 관한 정보가 전달 될 것이다 기록 &lt;code&gt;receiver&lt;/code&gt; 에 의해 정의 된 콜백 함수를 통하여 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 에서 의 내용에 따라 동작 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 레코드.</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">&lt;code&gt;RegName&lt;/code&gt; 이 이미 사용중인 경우</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RegName&lt;/code&gt; 가 인 원자 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">경우 &lt;code&gt;Repair&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 필요한 경우, 현재 로그 파일이 복구됩니다. 복원이 시작되면 오류 로그에 메시지가 출력됩니다. 경우 &lt;code&gt;false&lt;/code&gt; 지정된 경우에는 자동 복구가 시도되지 않습니다. 대신 손상된 로그 파일을 열려고 시도 하면 튜플 &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;truncate&lt;/code&gt; 지정된 로그 파일이 비어있는 로그를 생성, 절단된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 로 , 읽기 전용 모드로 열린 로그에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">경우 &lt;code&gt;Report&lt;/code&gt; 지도입니다, 그것은 같은 포맷하기 전에 키 - 값 목록으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">경우 &lt;code&gt;ReqId&lt;/code&gt; 0보다 작은, 그것은이 정보 (즉, 정보가 메시지가 삭제되기 전에 검색되지 않았다) 관리자에 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, 패킷 만 구성 &lt;code&gt;[119, Result]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;TimerRef&lt;/code&gt; 에 해당하는 타이머를 찾을 수 없습니다. 타이머가 만료되었거나 취소되었거나 &lt;code&gt;TimerRef&lt;/code&gt; 가 타이머에 해당하지 않기 때문 입니다. 타이머가 만료 된 경우에도 타임 아웃 메시지가 목적지에 도착했는지 여부를 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;TimerRef&lt;/code&gt; 에 해당하는 타이머를 찾을 수 없습니다. 타이머가 만료되었거나 이미 취소되었거나 &lt;code&gt;TimerRef&lt;/code&gt; 가 타이머와 일치하지 않았기 때문일 수 있습니다. 타이머가 만료 된 경우에도 타임 아웃 메시지가 목적지에 도착했는지 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; 정수, 그것은 취소 된 타이머가 만료 할 때까지 남은 시간 (밀리 초)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">경우 &lt;code&gt;Result&lt;/code&gt; 정수, 그것은 타이머가 만료 될 때까지 남은 시간 (밀리 초)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Rules&lt;/code&gt; 왼쪽으로 또는 빈 목록입니다, 기본 시스템 규칙이 사용됩니다. 커널 애플리케이션 매개 변수 &lt;code&gt;source_search_rules&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">경우 &lt;code&gt;Schedulers&lt;/code&gt; 또는 &lt;code&gt;SchedulersOnline&lt;/code&gt; 가 음수로 지정된 값은 각각 구성된 논리 프로세서 나 논리 프로세서의 기본 번호는 가능한 감산된다.</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">경우 &lt;code&gt;Scope&lt;/code&gt; 작업의이 &lt;code&gt;local&lt;/code&gt; , 대체는 로컬 노드에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">경우 &lt;code&gt;Server&lt;/code&gt; 입니다 &lt;code&gt;self()&lt;/code&gt; 익명 서버는 단지 사용하는 경우로 만들어집니다 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; . 경우 &lt;code&gt;Server&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 명명 된 서버는 단지 사용하는 경우와 같이 생성된다 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; . 그러나이 함수를 호출 &lt;strong&gt;하기 전에 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 이름 이 적절히 등록되어 있어야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스 ID로 전체적으로 등록 &lt;code&gt;GlobalName&lt;/code&gt; 하여 &lt;code&gt;global:register_name/2&lt;/code&gt; 이름이 제공되지 않을 경우를 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 처리는 등록되지 않는다.</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={local,Name}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 된 프로세스는 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 레지스트리와 프로세스 레지스터로 표시 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 콜백 함수 내보내이다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에 대응하는 기능처럼 동작한다, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">경우 &lt;code&gt;Server_or_Actions&lt;/code&gt; 는 A는 &lt;code&gt;list()&lt;/code&gt; 와 동일한 &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 없는 것을 제외 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 등록되어 있지 않은해야하고 &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; . 이것은 익명 서버를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">경우 &lt;code&gt;SetFun&lt;/code&gt; 는 숫자 I&amp;gt; = 1이며 &lt;code&gt;Set1&lt;/code&gt; 과는 , 릴레이션이다 후 리턴 세트가 인 &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Set1&lt;/code&gt; I 좌표 상.</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 평범 &lt;code&gt;socket()&lt;/code&gt; 하십시오 업그레이드 &lt;code&gt;gen_tcp&lt;/code&gt; , 수행하는 SSL / TLS 서버 측 악수 리턴한다 TLS 소켓 인 SSL 소켓에, 또는 이에 상응하는, 소켓.</target>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">경우 &lt;code&gt;Socket&lt;/code&gt; 입니다 &lt;code&gt;sslsocket()&lt;/code&gt; : 추가 SSL은 / TLS / DTLS의에 지정된 것과 옵션 제공 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 다음과는 SSL / TLS / DTLS 악수를 수행합니다. 핸드 셰이크가 성공하면 새 TLS / DTLS 소켓을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 가 파일 이름을 참조하는 경우 , 복사하기 전에 모드 목록 앞에 &lt;code&gt;read&lt;/code&gt; 모드 가있는 상태로 열리고 완료되면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">경우 &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; , 분리 시험 사양에 따라 생성된다. 경우 &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; , 모든 사양은 하나 개의 테스트에 병합 될 것이다.</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">경우 &lt;code&gt;Streams&lt;/code&gt; 빈 목록입니다, &lt;strong&gt;모든&lt;/strong&gt; 스트림은 다음 필터를 보내 주시기 바랍니다 :</target>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , 감독자 다리로 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; 감독자 다리 같이 국부적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; , 감독자 다리로 등록 된 &lt;code&gt;Name&lt;/code&gt; 모듈로 표시되는 레지스트리를 사용. &lt;code&gt;Module&lt;/code&gt; 수출 함수가 콜백입니다 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에서 해당 기능처럼 행동 할 수있는, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupName={global,Name}&lt;/code&gt; , 감독자는 다음과 같이 전 세계적으로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SupName={local,Name}&lt;/code&gt; 감독자가 로컬로 등록 된 &lt;code&gt;Name&lt;/code&gt; 사용 &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">경우 &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; , 감독자는 다음과 같이 등록 된 &lt;code&gt;Name&lt;/code&gt; 으로 표시 레지스트리 사용하여 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Module&lt;/code&gt; 기능을 내 보내야합니다 콜백 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , 및 &lt;code&gt;send/2&lt;/code&gt; 에서 해당 기능처럼 행동해야하며, &lt;code&gt;global&lt;/code&gt; . 따라서 &lt;code&gt;{via,global,Name}&lt;/code&gt; 은 유효한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 프로세스 식별자가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">경우 &lt;code&gt;Term&lt;/code&gt; 및 &lt;code&gt;Pattern&lt;/code&gt; 매칭 될 수있는 기능은 비 - 제로 값 및 바인드 어떤 결합되지 않은 변수 반환 &lt;code&gt;Pattern&lt;/code&gt; . 경우 &lt;code&gt;Term&lt;/code&gt; 과 &lt;code&gt;Pattern&lt;/code&gt; 일치하지 않는, &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 입니다 &lt;code&gt;infinity&lt;/code&gt; 어쨌든 만료되지 못했네으로, 더 타이머가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 상대적이며 &lt;code&gt;0&lt;/code&gt; 에는 타이머가 실제로 시작되지 않으며, 대신 시간 제한 이벤트는 아직 외부 이벤트를 받았지만, 이후 이미 이벤트를 대기하지 전에 처리됩니다 수 있도록 대기열에.</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 이 상대적이고 &lt;code&gt;0&lt;/code&gt; 으로 타이머가 실제로 시작되지 않은 경우, 시간 종료 이벤트가 큐에 대기되어 아직 외부 이벤트를 수신하지 전에 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">경우 &lt;code&gt;Time&lt;/code&gt; 정수로 지정되어,이 기능의 대기 &lt;code&gt;Time&lt;/code&gt; 새로운 프로세스 (밀리 초) 호출 할 &lt;code&gt;init_ack&lt;/code&gt; , 또는 &lt;code&gt;{error, timeout}&lt;/code&gt; 반환되고, 프로세스가 살해된다.</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">경우 &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 단위의 정수 값으로 설정되고, Mnesia 힘 &quot;헤비급 거래는&quot;현재의 트랜잭션의 결과가 불분명 한 경우에도, 완료한다. &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 후에 Mnesia는 트랜잭션을 커밋 또는 종료하고 시작을 계속합니다. 이로 인해 일부 노드에서 트랜잭션이 커밋되고 다른 노드에서 트랜잭션이 종료 될 수 있습니다. 트랜잭션이 스키마 트랜잭션 인 경우 불일치가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">받는 &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; 및 &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; 와 &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TupleOfBinRels&lt;/code&gt; 가 {R [1], ..., R [N]} 이진 관계 비어 튜플이고 &lt;code&gt;BinRel1&lt;/code&gt; 는 이진 관계이다 후 &lt;code&gt;BinRel2&lt;/code&gt; 은 은 IS &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; 순서화 세트 (R은, [I] ..., R [n]) 및 &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">경우 &lt;code&gt;Type = load&lt;/code&gt; 응용 프로그램은로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">&lt;code&gt;Type = none&lt;/code&gt; 인 경우 해당 모듈의 코드가로드되었지만 응용 프로그램이로드되지 않고 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; 경우 | 과도 | 임시 응용 프로그램이로드되고 시작 대응하는 방식으로 참조되는 &lt;code&gt;application(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;file&lt;/code&gt; , 클라이언트라는 이름의 파일에 저장된 모든 추적 메시지를 읽고 &lt;code&gt;Filename&lt;/code&gt; 또는 지정된 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 를 콘솔 및하자의 기본 핸들러 함수 형식 메시지 (같은 추적을 만들 때 사용되는, trace_port / 2 참조를해야합니다) . 파일 추적 포트 드라이버가 파일에 저장된 데이터를 해석하는 한 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;follow_file&lt;/code&gt; , 클라이언트 상기와 같이 동작합니다 &lt;code&gt;file&lt;/code&gt; 의 경우,하지만 의해 중단 될 때까지 파일에서 더 많은 데이터를 읽고 (공정)하려고 계속 &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;WrapFilesSpec&lt;/code&gt; 은이 &lt;code&gt;Type&lt;/code&gt; 의 두 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;ip&lt;/code&gt; 의 TCP / IP 포트로 클라이언트 커넥트 &lt;code&gt;PortNumber&lt;/code&gt; 이 호스트의 &lt;code&gt;Hostname&lt;/code&gt; 이 추적 메시지를 읽는 경우, TCP / IP 연결이 닫힐 때까지에서. &lt;code&gt;Hostname&lt;/code&gt; 을 지정 하지 않으면 로컬 호스트로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;port&lt;/code&gt; , 다음 두 번째 매개 변수는해야 &lt;strong&gt;재미&lt;/strong&gt; 인수를 취하지 않고 호출시에 새롭게 문을 연 추적 포트를 반환합니다. 이러한 &lt;strong&gt;재미&lt;/strong&gt; 는 바람직하게 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;process&lt;/code&gt; , 메시지 핸들러 함수는 (지정할 수 있습니다 &lt;code&gt;HandlerSpec&lt;/code&gt; 을 ). 핸들러 함수는 두 개의 인수를 갖는 &lt;code&gt;fun&lt;/code&gt; 여야하는 각 추적 메시지에 대해 호출되며 첫 번째 인수는 메시지를 그대로 포함하고 두 번째 인수는 마지막 호출의 리턴 값을 포함합니다. 두 번째 매개 변수의 초기 값은 &lt;code&gt;HandlerSpec&lt;/code&gt; 의 &lt;code&gt;InitialData&lt;/code&gt; 부분에 지정됩니다 . &lt;code&gt;HandlerFun&lt;/code&gt; 는 호출 할 때 수행 할 적절한 조치를 선택할 수 있습니다, 그것을 반환하여 다음의 호출에 대한 상태를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;table&lt;/code&gt; , 반대 일치하는 객체는 튜플이 될 것입니다. 그런 다음이 함수는 &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; 를 반환합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 실제 &lt;code&gt;ets:select/2&lt;/code&gt; 호출 에서 결과 가되었던 것입니다 . 일치 사양이 객체 튜플과 일치하지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;trace&lt;/code&gt; ,에 일치하는 객체 목록이 될 것입니다. 이 함수는 &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Type&lt;/code&gt; 에 대한 설명에 나와있는 메모리 타입 중 하나가 아닌 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">경우 &lt;code&gt;[]&lt;/code&gt; 반환, 어떤 OS 단조 시간을 사용할 수 없습니다. 리스트에는 &lt;code&gt;Key&lt;/code&gt; 가 첫 번째 요소이고 &lt;code&gt;Value&lt;/code&gt; 가 두 번째 요소 인 두 개의 튜플이 포함 됩니다. 이 튜플의 순서는 정의되어 있지 않습니다. 다음 튜플이 목록에 포함될 수 있지만 앞으로 더 많은 튜플이 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">경우 &lt;code&gt;[node()]&lt;/code&gt; 또 이미 지정된 노드의에 존재하는 경우 다음 연결이 거부됩니다. 유형 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;nodes&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 동등 &lt;code&gt;[]&lt;/code&gt; 는 , &lt;code&gt;[node()]&lt;/code&gt; , &lt;code&gt;[node()|nodes()]&lt;/code&gt; 와 평가 값이 각각 발생하는 각 식의 평가는 새로운 연결을 할 때마다 설립. 참고 &lt;code&gt;false&lt;/code&gt; 연결의 수를 제한은 동일한 피어 설립한다.</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; 가 -32768 ~ 32767 (포함) 범위 의 정수 &lt;code&gt;N&lt;/code&gt; 으로 지정된 경우 해당 번호는 제어 프로세스로 전달 될 소켓의 데이터 메시지 계수에 추가됩니다. 더하기 결과가 음수이면 카운트는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 메시지 전달을 통해 또는 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 로 명시 적으로 설정 하여 카운트가 &lt;code&gt;0&lt;/code&gt; 에 도달 하면 소켓 모드는 자동으로 수동 ( &lt;code&gt;{active, false}&lt;/code&gt; ) 으로 재설정됩니다 . 이 활성 모드의 소켓이 수동 모드로 전환되면 &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; 메시지 가 제어 프로세스로 전송되어 소켓에서 더 많은 데이터 메시지를 수신하려면 호출해야 함을 알려줍니다. &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 소켓을 다시 활성 모드로 설정하려면 inet : setopts / 2 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">경우 &lt;code&gt;alloc&lt;/code&gt; 성공 &lt;code&gt;dealloc&lt;/code&gt; 또한 실행된다. 그러나 &lt;code&gt;alloc&lt;/code&gt; 이 실패하면 &lt;code&gt;dealloc&lt;/code&gt; 이 실행되지 않지만 HTML 로그에서 &lt;code&gt;SKIPPED&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;get_resource_status&lt;/code&gt; 는 &lt;code&gt;alloc_and_dealloc&lt;/code&gt; 경우에 관계없이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">&lt;code&gt;answer_3xxx&lt;/code&gt; 인 경우 handle_request &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 없이 요청에 응답 합니다. &lt;code&gt;answer&lt;/code&gt; 하면 해당 연결이 RFC 3588 공통 사전을 아래와 같이 구성하지 않는 한 콜백없이 5xxx 오류도 응답됩니다. 경우 &lt;code&gt;callback&lt;/code&gt; 다음 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 항상 발생하고있는 경우 반환 값은, 피어에 송신 답을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">경우 &lt;code&gt;audit_trail_log&lt;/code&gt; 의 지정 로깅이 수행해야한다는,이 매개 변수가 &lt;strong&gt;있어야&lt;/strong&gt; 정의 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;auto_ack&lt;/code&gt; 는 사실, 다음 경우 &lt;code&gt;trans_ack&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , ACK의 즉시 전송됩니다. 경우 &lt;code&gt;trans_ack&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 다음의 대신 축적 이상 (참조 보내기위한 거래 보낸 사람 처리로 전송됩니다 ACK &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 및 &lt;code&gt;trans_timer&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 후 오류가 발생할 &lt;code&gt;handle_answer/4&lt;/code&gt; 와 동일한 방식으로서 속 콜백 &lt;code&gt;handle_request/3&lt;/code&gt; 에서 통신 에러와, &lt;code&gt;errors&lt;/code&gt; 의 필드 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 콜백으로 전달. &lt;code&gt;report&lt;/code&gt; 경우 오류가 포함 된 답변이 콜백없이 삭제되고 경고 보고서가 로그에 작성됩니다. &lt;code&gt;discard&lt;/code&gt; 하면 오류가 포함 된 답변이 콜백없이 자동으로 삭제됩니다. &lt;code&gt;report&lt;/code&gt; 및 &lt;code&gt;discard&lt;/code&gt; 사례 모두에서 해당 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 호출에 대한 리턴 값 은 콜백이 발생하여 &lt;code&gt;{error, failure}&lt;/code&gt; 리턴 한 것과 같습니다..</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">경우 &lt;code&gt;ch4&lt;/code&gt; 있는 응용 프로그램의 일부 &lt;code&gt;sp_app&lt;/code&gt; 및 모듈의 새 버전은 버전 &quot;1&quot;에서이 응용 프로그램의 &quot;2&quot;로 업그레이드가 될 때로드 될 &lt;code&gt;sp_app.appup&lt;/code&gt; 이 같은 다음 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;cp1&lt;/code&gt; 다운되면, 시스템의 다른 노드 중 하나를 확인 &lt;code&gt;cp2&lt;/code&gt; 또는 &lt;code&gt;cp3&lt;/code&gt; , 실행중인 응용 프로그램의 최소 수를 가지고 있지만, 5 초 동안 대기 &lt;code&gt;cp1&lt;/code&gt; 다시 시작합니다. 경우 &lt;code&gt;cp1&lt;/code&gt; 다시 시작하지 않고 &lt;code&gt;cp2&lt;/code&gt; 보다 적은 수의 응용 프로그램을 실행 &lt;code&gt;cp3&lt;/code&gt; , &lt;code&gt;myapp&lt;/code&gt; 와는 에서 다시 시작 &lt;code&gt;cp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 이 &lt;code&gt;-help&lt;/code&gt; 옵션과 함께 호출 되면 유효한 모든 시작 플래그를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">경우 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 가 같은 값으로 설정 &lt;code&gt;flush_qlen&lt;/code&gt; , 드롭 모드를 사용할 수 없습니다 발생할 수 없다.</target>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_call/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; 이 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_ports/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_procs/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_receive/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_running_ports/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_running_procs/3&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;enabled_send/3&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 다른 이상의 값으로 설정된다 &lt;code&gt;latin1&lt;/code&gt; 상기 &lt;code&gt;read_line/1&lt;/code&gt; 통화 데이터가 255보다 큰 문자가 포함 된 경우 실패 이유 모듈 &lt;code&gt;io(3)&lt;/code&gt; 등의 파일을 읽는 경우에 선호된다.</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">경우 &lt;code&gt;epmd&lt;/code&gt; 노드 탐색에 사용되는, 당신은 일반적으로 (불행하게도 문서화) 사용하려는 &lt;code&gt;erl_epmd&lt;/code&gt; 모듈 (의 일부 &lt;code&gt;kernel&lt;/code&gt; (가)와 포트들을 등록하기 위해 응용 프로그램) &lt;code&gt;epmd&lt;/code&gt; 하고 검색 &lt;code&gt;Creation&lt;/code&gt; 사용.</target>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;erl_script_nocache&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 서버는 페이지 캐싱 프록시를 방지 HTTP 헤더 필드를 추가합니다. 콘텐츠는 각 요청마다 다를 수 있으므로 일반적으로 동적 콘텐츠에 좋습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">경우 &lt;code&gt;erl_script_timeout&lt;/code&gt; 는 데이터 청크의 각각의 서버는 대기를 통해 전달되는 시간 (초)으로 설정 &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; . 기본값은 &lt;code&gt;15&lt;/code&gt; 입니다. 이것은 erl 체계를 사용하는 스크립트에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;error_logger&lt;/code&gt; 이 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 옵션 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">&lt;code&gt;ev&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 &lt;code&gt;-1&lt;/code&gt; 유형 인 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 로 캐스트 된 모든 것이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">만약 &lt;code&gt;exit&lt;/code&gt; 후 질문 종료에 전송 프로세스. 경우에 &lt;code&gt;handle&lt;/code&gt; 있는 메시지가 생성 평소대로 처리된다 &lt;code&gt;handle_request/3&lt;/code&gt; 또는 &lt;code&gt;handle_answer/4&lt;/code&gt; (하나가 발생하는 경우)를 나타내는 콜백 &lt;code&gt;5015&lt;/code&gt; 에러 (DIAMETER_INVALID_MESSAGE_LENGTH 참조). 경우 &lt;code&gt;discard&lt;/code&gt; 후 해당 메시지가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;extra&lt;/code&gt; 에 지정된 &lt;code&gt;Options&lt;/code&gt; , 반환 값은 &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; 대신 &lt;code&gt;{ok, Epp}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 에 &lt;code&gt;extra&lt;/code&gt; 가 지정된 경우 반환 값은 &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; 대신 {ok, [Form], Extra &lt;code&gt;{ok, [Form]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 인 경우 (수동 모드, 기본값) 호출자는 소켓에서 사용 가능한 데이터를 검색하기 위해 명시 적 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 호출을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 후 동료가 공유되지 않습니다. 경우 &lt;code&gt;[node()]&lt;/code&gt; 다음 동료는 노드의 지정된 목록과 함께 공유됩니다. 경우 &lt;code&gt;eval()&lt;/code&gt; 다음 동료 평가 지정된 함수에 의해 반환 된 노드와 공유하는 피어 연결을 사용할 수있게 또는 로컬 연결에 대한 원격 서비스 요청 정보를 때마다. &lt;code&gt;true&lt;/code&gt; 값 은 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 과 같습니다 . 목록의 &lt;code&gt;node()&lt;/code&gt; 값 은 무시되므로 서비스 모음을 모두 동일한 노드 목록과 공유하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; 다음 원격 동료가 사용되지 않습니다. 경우 &lt;code&gt;[node()]&lt;/code&gt; 다음 노드의 지정된 목록에서 유일한 동료가 사용된다. 경우 &lt;code&gt;eval()&lt;/code&gt; 만 지정된 함수에 의해 반환 동료가 사용되는 원격 서비스가 가능한 피어 연결에 대한 정보를 전달 할 때마다 평가했다. &lt;code&gt;true&lt;/code&gt; 값 은 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 과 같습니다 . 목록 의 값 &lt;code&gt;node()&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 사용자와의 상호 작용이 예에 추가 할 서버 수용성으로, 필요한 경우, 서버에 접속하는 클라이언트 비활성화 &lt;code&gt;known_hosts&lt;/code&gt; 파일 또는 암호를 제공.</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">경우 &lt;code&gt;false&lt;/code&gt; , 키가 저장되지 않고, 키는 여전히 같은 호스트의 다음 액세스에 알 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;latin1&lt;/code&gt; 에 , 경로 이름의 번역이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 반환 &lt;code&gt;utf8&lt;/code&gt; , tar 파일을 생성 할 때 경로 이름은 UTF-8 인코딩 및 경로 이름은 tar 파일을 추출 할 때 UTF-8로 인코딩 된 것으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;final&lt;/code&gt; 반환되고, 오프셋 시간은 최종 상태에서 이미 있었다. 다른 &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; 호출 또는 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 가 사용 되지 않았기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;0&lt;/code&gt; 백업은 (증분 백업입니다) 생성, 수정, 또는 삭제 된 마지막 백업 이후 또는 복원 된 개체 만이 포함되어 있습니다. 백업 후 더티로 표시된 모든 개체가 이제 정리되고 삭제로 표시된 모든 개체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;EI_BIN&lt;/code&gt; , 다섯 번째 인수 &lt;code&gt;int *size&lt;/code&gt; 필요하며, 개체의 크기를 반환 할 수 있습니다 그래서.</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 입니다 &lt;code&gt;EI_BIN&lt;/code&gt; , 다섯 번째 인수 &lt;code&gt;size&lt;/code&gt; 가 가리키는 객체의 크기를 바이트 단위로 나타내는 필요 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;hibernate&lt;/code&gt; 대신 시간 제한 값의 지정된 다음 메시지가 (호출하여 도착하기를 기다릴 때, 프로세스가 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init_per_group&lt;/code&gt; 가 생략되어,이 기능은 이후라고 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">경우 &lt;code&gt;init_per_suite&lt;/code&gt; 이 존재하는 테스트 케이스를 실행하기 전에, 그것은 처음이라고합니다. 일반적으로 제품군의 모든 테스트 사례에 공통적 인 초기화가 포함되며 한 번만 수행됩니다. 스위트의 테스트 케이스가 올바르게 실행되도록 &lt;code&gt;init_per_suite&lt;/code&gt; 는 테스트 대상 시스템 (SUT) 또는 &lt;code&gt;Common Test&lt;/code&gt; 호스트 노드 또는 둘 다에서 상태 및 환경을 설정하고 확인하는 데 권장 됩니다. 다음은 초기 구성 작업의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;init_per_suite&lt;/code&gt; 는 실패, 테스트 스위트의 모든 테스트 케이스 (소위 자동으로 건너 뜁니다 &lt;strong&gt;자동 생략&lt;/strong&gt; 포함) &lt;code&gt;end_per_suite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 가 실패 하면 post_init_per_suite 후에이 함수가 호출 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">&lt;code&gt;init_per_testcase&lt;/code&gt; 가 충돌하는 경우 ( &lt;strong&gt;auto skipped&lt;/strong&gt; 라고 함 )</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 충돌, 또는 반환 &lt;code&gt;{skip,Reason}&lt;/code&gt; 또는 &lt;code&gt;{fail,Reason}&lt;/code&gt; , 기능 &lt;code&gt;end_per_testcase&lt;/code&gt; 가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 이 존재, 그것은 제품군의 각 테스트 케이스 전에 호출된다. 일반적으로 각 테스트 사례에 대해 수행해야하는 초기화가 포함됩니다 ( 스위트의 &lt;code&gt;init_per_suite&lt;/code&gt; 에 대한 아날로그 분석 ).</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">경우 &lt;code&gt;init_per_testcase&lt;/code&gt; 는 튜플 반환 &lt;code&gt;{skip,Reason}&lt;/code&gt; (전화 &lt;strong&gt;사용자는 생략&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ip_access&lt;/code&gt; 와 &lt;code&gt;name_access&lt;/code&gt; 가 비슷하게 구현 되면 ListOfExtraArguments를 사용하여 &lt;code&gt;generic_access&lt;/code&gt; 함수를 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">경우 &lt;code&gt;keysearch&lt;/code&gt; 는 원자 반환 &lt;code&gt;false&lt;/code&gt; 일부 오류가 발생하여 서버가 다시 메시지를 보냅니다 :</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">키 &lt;code&gt;keysearch&lt;/code&gt; 반환되는 경우 :</target>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;kill&lt;/code&gt; 맵에 정의되지 않은 시스템 기본값이 사용됩니다. 기본 시스템 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 그것은 두 가지 옵션을 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;erl(1)&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 이 인수로 지정된 경우 디버거는 현재 노드에서만 코드를 해석합니다. &lt;code&gt;global&lt;/code&gt; 이 인수로 지정된 경우 디버거는 알려진 모든 노드에서 코드를 해석하며 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">경우 &lt;code&gt;m:fact/1&lt;/code&gt; 인수없이 절 머리 일치와 같은 음의 번호로 호출된다. &lt;code&gt;function_clause&lt;/code&gt; 의 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 인 경우 하나의 마스터 에이전트가 시작됩니다. 그렇지 않으면 에이전트가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">경우 &lt;code&gt;maximum&lt;/code&gt; 로 전달 &lt;code&gt;Type&lt;/code&gt; 및 에뮬레이터 계측 모드에서 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">&lt;code&gt;mon&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 성공적인 호출은 &lt;code&gt;mon&lt;/code&gt; 이 가리키는 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 구조체에 모니터 ID를 저장합니다 . 이 식별자는 나중에 &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; 로 제거하기 위해 모니터를 참조 하거나 enif_compare_monitors 와 비교하는 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 됩니다. 모니터는 트리거되거나 자원이 할당 해제 될 때 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">경우 &lt;code&gt;msg_env&lt;/code&gt; 가 설정되어 &lt;code&gt;NULL&lt;/code&gt; 의 &lt;code&gt;msg&lt;/code&gt; 용어는 복사되고 원래의 용어와 그 환경은 여전히 호출 후 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">경우 &lt;code&gt;myapp&lt;/code&gt; 실행되고 &lt;code&gt;cp3&lt;/code&gt; , 그리고 경우 &lt;code&gt;cp2&lt;/code&gt; 지금 다시 시작, 그것은 다시 시작하지 않습니다 &lt;code&gt;myapp&lt;/code&gt; 와를 사이의 순서로, &lt;code&gt;cp2&lt;/code&gt; 와 &lt;code&gt;cp3&lt;/code&gt; 노드가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">경우 &lt;code&gt;nc&lt;/code&gt; 할당 자에 의해 관리되는 다중 블록 캐리어 (제외 주 - 블록 캐리어)의 현재 수는, 다음의 크기 &lt;code&gt;mseg_alloc&lt;/code&gt; 의 이 할당에 의해 할당 된 다중 블록 캐리어 대충 &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; 때 &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; 및 &lt;code&gt;lmbcs&lt;/code&gt; &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; . 파라미터의 값 경우 &lt;code&gt;sbct&lt;/code&gt; 이 파라미터의 값보다 큰 &lt;code&gt;lmbcs&lt;/code&gt; 상기 할당 파라미터의 값보다 큰 캐리어 - 블록 생성 할 수도 &lt;code&gt;lmbcs&lt;/code&gt; 을 하지만. 를 통해 할당 Singleblock 사업자 &lt;code&gt;mseg_alloc&lt;/code&gt; 는 전체 페이지 크기가된다.</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">경우 &lt;code&gt;no_repeat&lt;/code&gt; 이 값으로 설정되어, 반복 된 파일 동기화 작업이 불가능, 그것은 디스크에 기록됩니다 얼마나 빨리 또는 느리게 데이터를 결정하는 운영 체제 설정입니다. 사용자는 &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 파일 동기화를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">경우 &lt;code&gt;no_repeat&lt;/code&gt; 는 값으로 설정되고, 반복적 동기 동작은 불가능하다. 사용자는 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 disk_log 동기화를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , &lt;code&gt;name&lt;/code&gt; 이 발견 된 노드의 이름을 함수가 채울 수있는 버퍼에 대한 포인터 입니다. 필요한 경우 &lt;code&gt;node&lt;/code&gt; 를 &lt;code&gt;erl_connect()&lt;/code&gt; 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">경우 &lt;code&gt;once&lt;/code&gt; , 하나의 메시지가 자동으로 메시지 큐에 저장하고, 수동 모드를 자동으로 리셋되어 이후. 이것은 흐름 제어를 제공하고 수신기가 다른 프로세스 간 메시지와 인터리브 된 들어오는 SCTP 데이터를 수신 할 수있는 가능성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;os_sup_enable&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; ,이 함수를 호출해야합니다 &lt;strong&gt;후&lt;/strong&gt; OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; 가 중지됩니다. &lt;code&gt;Dir&lt;/code&gt; 백업 사본 및 대한 얼랑 특정 구성 파일이 들어있는 디렉토리를 정의 &lt;code&gt;syslogd&lt;/code&gt; 를 , 그리고에서 메시지를 수신 할 수있는 명명 된 파이프 &lt;code&gt;syslogd&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 입니다. &lt;code&gt;Conf&lt;/code&gt; 는 &lt;code&gt;syslogd&lt;/code&gt; 구성 파일의 전체 이름을 정의합니다 . 기본값은 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os_sup_enable&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; 을 시작 &lt;strong&gt;하기&lt;/strong&gt; 전에이 함수를 호출해야합니다 . &lt;code&gt;Dir&lt;/code&gt; 백업 사본 및 대한 얼랑 특정 구성 파일이 들어있는 디렉토리를 정의 &lt;code&gt;syslogd&lt;/code&gt; 를 , 그리고에서 메시지를 수신 할 수있는 명명 된 파이프 &lt;code&gt;syslogd&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 입니다. &lt;code&gt;Conf&lt;/code&gt; 는 &lt;code&gt;syslogd&lt;/code&gt; 구성 파일의 전체 이름을 정의합니다 . 기본값은 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">경우 &lt;code&gt;preliminary&lt;/code&gt; 반환되고, 마무리 수행 및 오프셋 시간은 최종되었다.</target>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">경우 &lt;code&gt;read/2&lt;/code&gt; 통화가되지 크게 미만, 또는보다 큰 크기에 관한 &lt;code&gt;Size&lt;/code&gt; 바이트, 더 성능 향상은 기대할 수 없다.</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">경우 &lt;code&gt;read&lt;/code&gt; 지정된 경우에만 요청이 기록됩니다 얻는다.</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;read&lt;/code&gt; 지정 만받은 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">테이블에 대해 &lt;code&gt;read_concurrency&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 인 경우 모든 요청이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;read_write&lt;/code&gt; , 모두 발신 및 수신 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;registered_name&lt;/code&gt; 은 의 일부 &lt;code&gt;ItemList&lt;/code&gt; 프로세스가 등록 된 이름이없는하는 &lt;code&gt;{registered_name, []}&lt;/code&gt; , &lt;code&gt;InfoTuple&lt;/code&gt; 는&lt;strong&gt;것이다&lt;/strong&gt; 결과에 포함 &lt;code&gt;InfoTupleList&lt;/code&gt; . 단일 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 을 지정하고 &lt;code&gt;process_info/1&lt;/code&gt; 을 사용 하는 경우이 동작이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;remove_handler&lt;/code&gt; 가 반환되는 이벤트 핸들러를 호출하여 삭제 &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;script_nocache&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 기본적으로 HTTP 서버는 헤더 페이지를 캐싱 프록시를 방지하기 위해 필요한 필드를 추가합니다. 일반적으로 이것이 바람직하다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">응용 프로그램이로드되기 전에 &lt;code&gt;set_env/4&lt;/code&gt; 가 호출 되면 &lt;code&gt;Application.app&lt;/code&gt; 파일에 지정된 응용 프로그램 환경 값 이 이전에 설정된 값 보다 우선합니다. 응용 프로그램을 다시로드 할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 헤드의 크기가 거기에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">경우 &lt;code&gt;stop&lt;/code&gt; 반환되면, 로그 이벤트는 즉시 삭제됩니다. 필터가 1 차인 경우 핸들러 필터 또는 콜백이 호출되지 않습니다. 핸들러 필터 인 경우 해당 핸들러 콜백이 호출되지 않지만 다음 이벤트 (있는 경우)에 첨부 된 필터로 로그 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">경우 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 가 설정되어 &lt;code&gt;0&lt;/code&gt; , 모든 로그 이벤트는 동 기적으로 처리됩니다. 즉, 비동기 로깅이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">경우 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 가 동일한 값으로 설정된다 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 동기 모드를 사용할 수 없습니다. 즉, 삭제 또는 플러시가 호출되지 않으면 핸들러는 항상 비동기 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 식별 노드 로컬 포트,이 기능은 포트 변수 초기화 &lt;code&gt;*port_id&lt;/code&gt; 그것을 반환에서 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 포트가 활성 상태인지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 튜플은이 함수 세트 &lt;code&gt;*array&lt;/code&gt; 튜플의 요소들을 포함하는 배열 포인트를 세트하고 &lt;code&gt;*arity&lt;/code&gt; 요소들의 수. 배열은 읽기 전용이며 &lt;code&gt;(*array)[N-1]&lt;/code&gt; 은 튜플의 N 번째 요소입니다. 튜플의 arity가 0이면 &lt;code&gt;*array&lt;/code&gt; 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 노드 로컬 프로세스의 PID입니다,이 기능은 PID 변수가 초기화 &lt;code&gt;*pid&lt;/code&gt; 그것을 반환에서 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 프로세스가 활성 상태인지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">경우에 &lt;code&gt;throw/1&lt;/code&gt; 캐치 내에서 평가되지 않습니다하는 &lt;code&gt;nocatch&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">&lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; )에 의해 지정된 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;timetrap&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; , 또는 둘 다, 특정 테스트 케이스에 대해 구체적으로 설정되지 않은 디폴트 값 함수에 의해 특정 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_call/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_garbage_collection/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_ports/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">경우 &lt;code&gt;trace_procs/5&lt;/code&gt; 가 정의되어 있지, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 대신이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_receive/5&lt;/code&gt; 가 정의되어 있지 않으면 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_running_ports/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_running_procs/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">&lt;code&gt;trace_send/5&lt;/code&gt; 가 정의되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">경우 &lt;code&gt;trans_req&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 다음 요청 (들)은 (자신의 메시지)를 즉시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;trans_req&lt;/code&gt; 는 사실, 다음 요청 (들) 대신에 축적 이상 (참조 보내기위한 거래 보낸 사람 처리로 전송됩니다 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 및 &lt;code&gt;trans_timer&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (전체 활성 모드), 대기중인 데이터 나 이벤트가 소유하는 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 시작 중에 구성 파일을 다시 읽고 구성 데이터베이스의 내용을 무시합니다. 따라서 &lt;code&gt;true&lt;/code&gt; 인 경우 에이전트를 재부팅 할 때 구성 데이터베이스에 대한 변경 사항이 유실됩니다.</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 새 외부 이벤트를 기다리기 위해 &lt;code&gt;receive&lt;/code&gt; 하기 전에 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;gen_statem&lt;/code&gt; 을 동면합니다 .</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , (재 조립 / 조각을 필요로) 현재의 PMTU 크기보다 큰 메시지를 보낼하려는 시도에 오류를 유도한다. 메시지 조각화는 배달의 논리적 원자성에 영향을 미치지 않습니다. 이 옵션은 성능상의 이유로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 net_if는 IP 주소에 바인딩됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 net_if는 실행중인 호스트의 모든 IP 주소를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 net_if는 IP 및 포트 주소를 재사용 할 수 있도록 지정하지 않습니다. 경우 &lt;code&gt;false&lt;/code&gt; 주소는 재사용로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 현재 이벤트를 연기하고 상태가 변경 될 때 ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) 다시 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 에이전트는 각 GET 요청에 대한 하나 개의 스레드와 멀티 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 클라이언트는 인증에 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 클라이언트는이 문제를 동일한 호스트가 연결되어 다음 번에 동의 피하기 위해 허용 호스트 키를 저장합니다. &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션 이 없으면 &quot;known_hosts&quot;파일에 키가 저장됩니다. 해당 파일의 위치는 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 실행 시간 및 감소가 축적된다.</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 특정 로그 이벤트가 발생할 때, 로그 소유자에게 통지된다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이벤트가 발생하면 소유자에게 다음 메시지 중 하나가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; ,이 차종 &lt;code&gt;epp_dodger&lt;/code&gt; 타입의 노드로 해석 할 수 없었던 어떤 프로그램 형태의 대체 &lt;code&gt;text&lt;/code&gt; (참조 &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; 양식의 원시 토큰 시퀀스를 나타내는 대신의 구문 분석 오류를보고). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">경우 &lt;code&gt;u&lt;/code&gt; 는 서브 식별자로서 사용된다 (즉, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; )에 기초하여 모든 할당 자 &lt;code&gt;alloc_util&lt;/code&gt; 가 수행된다. 경우 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , 또는 &lt;code&gt;T&lt;/code&gt; 는 서브 식별자 이루어진다 식별자만을 특정 할당로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;volatile&lt;/code&gt; 반환되기 때문에, 오프셋 시간을 확정 할 수없는 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">경우 &lt;code&gt;write&lt;/code&gt; 지정된 경우에만 보낸 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">경우 &lt;code&gt;write&lt;/code&gt; 지정된 경우에만 설정 요청이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">테이블에 대해 &lt;code&gt;write_concurrency&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">경우 &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; 반환, 에뮬레이터를 다시 시작 업그레이드 명령이 실행되기 전에. 에뮬레이터 또는 응용 프로그램 커널, STDLIB 또는 SASL이 업데이트 된 경우에 발생합니다. 새로운 에뮬레이터 버전과 이러한 핵심 응용 프로그램은 재시작 후 실행됩니다. 다른 모든 응용 프로그램의 경우 이전 버전이 시작되고 업그레이드 지침을 실행하여 업그레이드가 정상적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;{eof, Endline}&lt;/code&gt; 즉시 반환, 호출합니다 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 수익을 &lt;code&gt;{ok, eof}&lt;/code&gt; . 경우 &lt;code&gt;{eof, Endline}&lt;/code&gt; 기대하는 입력 끝 파서, 반환 전에 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 은 물론, (상기 참조) 에러 메시지를 리턴한다. 그렇지 않으면 &lt;code&gt;{ok, Result}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">소스 사양 (기본 설정)에 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 가 설정되어 있으면 결합 사양의 용어가 소스 사양의 용어와 병합됩니다 ( 이전 &lt;code&gt;merge_tests&lt;/code&gt; 의 설명에 따름 ).</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{noreply,NewState}&lt;/code&gt; 를 반환한다 &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; 또는 &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; 상기 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스로 계속 실행 &lt;code&gt;NewState&lt;/code&gt; . &lt;code&gt;From&lt;/code&gt; 에 대한 회신은 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">경우 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 반환, 이벤트 매니저는 (호출하여 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), 다음 이벤트가 발생하는 대기. 전체 이벤트 관리자 프로세스가 최대 절전 모드로 전환 되도록 이벤트 핸들러 중 하나가 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 를 리턴하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;{ok,NewState}&lt;/code&gt; 또는 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 반환, 가능한 업데이트 된 내부 상태와 이벤트 관리자의 이벤트 핸들러 남아 &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">경우 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; 반환, 이벤트 매니저 (호출하여 최대 절전 모드로 전환 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; , 다음 이벤트가 발생하는 대기).</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; 반환됩니다 &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; 또는 &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; 다시 주어진다 &lt;code&gt;From&lt;/code&gt; 의 반환 값으로 &lt;code&gt;call/2,3&lt;/code&gt; 또는에 포함 의 반환 값 &lt;code&gt;multi_call/2,3,4&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스는 다음 업데이트 가능한 내부 상태와 실행을 계속 &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">경우 &lt;code&gt;{save_calls,N}&lt;/code&gt; 이 과정 설정되어있는, 어떤 함수 호출은 전화 저장 목록에 저장되지 않습니다. 통화 저장 목록은 지워지지 않습니다. 또한 보내기, 받기 및 시간 초과 이벤트가 여전히 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 되도록 옵션에 지정된 &lt;code&gt;Start&lt;/code&gt; &amp;gt; 크기 &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0 또는 &lt;code&gt;Start + Length&lt;/code&gt; 이다&amp;gt;의 크기 &lt;code&gt;Subject&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 되도록 옵션에 지정된 &lt;code&gt;Start&lt;/code&gt; &amp;gt;의 크기 &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; +의 &lt;code&gt;Length&lt;/code&gt; &amp;lt;0 또는 &lt;code&gt;Start&lt;/code&gt; +의 &lt;code&gt;Length&lt;/code&gt; &amp;gt; 크기 &lt;code&gt;Subject&lt;/code&gt; 하는 &lt;code&gt;badarg&lt;/code&gt; 의 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 그룹의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 그룹에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환되는 모듈의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 는 HTML 결과 페이지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 스위트의 모든 테스트 케이스는 생략하고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 반환, 테스트 케이스는 건너 뛰고 &lt;code&gt;Reason&lt;/code&gt; 제품군에 대한 개요 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">경우 &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; 반환됩니다에 대한 응답 &lt;code&gt;From&lt;/code&gt; 사용하여 명시 적으로 지정해야합니다 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스는 호출 &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; 및 종료합니다.</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; 반환, &lt;code&gt;Reply&lt;/code&gt; 되돌아 주어진다 &lt;code&gt;From&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; , 이벤트 핸들러에 의해 대체된다 반환 &lt;code&gt;Handler2&lt;/code&gt; 제 호출하여 &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; 후 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 여기서 &lt;code&gt;Term&lt;/code&gt; 인 &lt;code&gt;Module:terminate/2&lt;/code&gt; 의 반환 값 . 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">경우 &lt;strong&gt;어떤&lt;/strong&gt; 의 &lt;strong&gt;다른&lt;/strong&gt; 콜백 기능 (종료, 던지거나 일반 충돌) 충돌 또는 (유효한 수익이 지정된 경우) 잘못된 결과를 반환,이 함수가 호출됩니다. 사용자가이 오류를 처리 할 수 ​​있도록하는 것이 목적입니다 (예 : 오류 보고서 발행).</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;false&lt;/strong&gt; 인 경우 mega_ 메시지는 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;false&lt;/strong&gt; 인 경우 mega_ 메시지는 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">경우 &lt;strong&gt;사실&lt;/strong&gt; , MEGACO 메시지 &lt;strong&gt;를 다시 보냅니다&lt;/strong&gt; 사용하여 만든 &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; 기능을. &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 초기 메시지 전송이 여전히 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">A와 B가 일치하지만 C에 오류가 있으면 일치는 A로 역 추적되지 않습니다. 대신 다음 대안, 즉 D로 이동합니다. 그러나 (* THEN)을 포함하는 서브 패턴에 대안이 주어지면 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">A가 X의 부분 집합 인 경우 R 아래의 A &lt;strong id=&quot;image&quot;&gt;이미지&lt;/strong&gt; 는 A의 일부 x에 대한 {y : x R y 세트입니다. B가 Y의 부분 집합 인 경우 B의 &lt;strong id=&quot;inverse_image&quot;&gt;역상&lt;/strong&gt; 은 B의 일부 y에 대해 {x : x R y 세트입니다.</target>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K := V&lt;/code&gt; 인 경우 Rep (A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 인 경우 Rep (A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K := V&lt;/code&gt; 이며 여기서 &lt;code&gt;K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 유형 인 경우 Rep (A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">A가 연관 유형 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; 이며 여기서 &lt;code&gt;K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 유형 인 경우 Rep (A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">A와 일치하지만 B는 실패하면 (* COMMIT)으로의 역 추적이 전체 일치를 실패시킵니다. 그러나 A와 B가 일치하지만 C가 실패하면 역 추적 (* THEN)으로 인해 다음 대체 (ABD)가 시도됩니다. 이 동작은 일관되지만 항상 Perl과 동일하지는 않습니다. 그것은 두 개 이상의 역 추적 동사가 연속적으로 나타나면 마지막 동사는 효과가 없다는 것을 의미합니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 케이스 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 인 경우, &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; (여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스, &lt;code&gt;B&lt;/code&gt; 는 본문) 인 경우 C가 case 절인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; , 즉, 명시 적으로 예외 클래스와 캐치 절 &lt;code&gt;throw&lt;/code&gt; 및 또는 명시 적 스택 트레이스 변수없이 &lt;code&gt;_&lt;/code&gt; 는 명시 적으로 예외 클래스없이 명시 적 스택 트레이스 변수없이 캐치 절 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">&lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 catch 절 P 인 경우 , 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; 이며, 명백한 예외 클래스와 캐치 절 &lt;code&gt;throw&lt;/code&gt; 와 함께 또는 명시 스택 트레이스 변수없이 &lt;code&gt;_&lt;/code&gt; 명백한 예외 클래스없이 캐치 절 구별 될 수없고 명시적인 스택 트레이스 변수없이</target>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; 이며 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴이고 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; 즉, 명시 적 예외 클래스 및 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가있는 catch 절은 명시 적 예외 클래스가 있고 catch 예외가없는 catch 절과 구별 될 수 없습니다. 명시 적 스택 추적 변수</target>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절인 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; 여기서 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 변수 패턴, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; 일 때 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 가변 패턴이고, &lt;code&gt;P&lt;/code&gt; 는 패턴, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스, &lt;code&gt;S&lt;/code&gt; 는 변수, &lt;code&gt;B&lt;/code&gt; 는 본문입니다. Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">C가 catch 절 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; 일 때 &lt;code&gt;X&lt;/code&gt; 는 원자 리터럴 또는 가변 패턴이고, &lt;code&gt;P&lt;/code&gt; 는 패턴이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이며, &lt;code&gt;B&lt;/code&gt; 는 본문이고 Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; 즉, 명시 적 예외 클래스 및 명시 적 스택 추적 변수 &lt;code&gt;_&lt;/code&gt; 가 있는 catch 절을 구별 할 수 없습니다. 명시적인 예외 클래스가 있고 명시적인 stacktrace 변수가없는 catch 절</target>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">C가 구속 조건 &lt;code&gt;V :: T&lt;/code&gt; 이고 여기서 &lt;code&gt;V&lt;/code&gt; 가 유형 변수이고 &lt;code&gt;T&lt;/code&gt; 가 유형이면 Rep (C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 함수 절 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 순서이고 &lt;code&gt;B&lt;/code&gt; 는 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; 일 때 C가 함수 절 (Ps) 인 경우 , 여기서 &lt;code&gt;Ps&lt;/code&gt; 는 패턴 시퀀스이고, &lt;code&gt;Gs&lt;/code&gt; 는 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 는 바디 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">C가 if 절 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; 이고 여기서 &lt;code&gt;Gs&lt;/code&gt; 가드 시퀀스이고 &lt;code&gt;B&lt;/code&gt; 가 본문 인 경우 Rep (C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">CPU 토폴로지 정보를 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">D가 &lt;code&gt;F_1&lt;/code&gt; , ..., &lt;code&gt;F_k&lt;/code&gt; 형식으로 구성된 모듈 선언 이면 Rep (D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 비트 스트링 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; 경우 &amp;lt;&amp;lt; E_0 || Q_1, ..., Q_k &amp;gt;&amp;gt; . 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이며 Rep (E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 입니다. 담당자 (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">E가 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 이면 여기서 각 &lt;code&gt;Size_i&lt;/code&gt; 는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형별 목록입니다. Rep (E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">E가 블록 표현식 인 경우 &lt;code&gt;begin B end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 는 바디 인 경우 Rep (E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; 케이스 표현식 케이스 E_0이면; ...; Cc_k end , 여기서 &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 catch 표현식 &lt;code&gt;catch E_0&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 단점 뼈대 인 경우 &lt;code&gt;[E_h | E_t]&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절이고 Rep (E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 입니다. (Erlang / OTP R15 이전 : Rep (E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현 &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 변수이고 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 함수 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">E가 재미있는 표현식 &lt;code&gt;fun Name/Arity&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 함수 호출 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">E가 목록 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; 경우 [E_0 || Q_1, ..., Q_k] . 여기서 각 &lt;code&gt;Q_i&lt;/code&gt; 는 한정자이며 Rep (E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 입니다. 담당자 (Q)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 작성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 이고 Rep (E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">E가 맵 업데이트 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 또는 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 일치 연산자 표현식 &lt;code&gt;P = E_0&lt;/code&gt; 이면 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이며 Rep (E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">E가 괄호로 묶인 표현식 &lt;code&gt;( E_0 )&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;Rep(E_0)&lt;/code&gt; . 즉, 괄호로 묶은 표현식은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 인 경우 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; . 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이고, &lt;code&gt;E_0&lt;/code&gt; 은 표현식이고 &lt;code&gt;B_t&lt;/code&gt; 는 본문이며 Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 수신 표현식 인 경우 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , 여기서 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이고 Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 작성 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인 경우 &lt;code&gt;E_0#Name.Field&lt;/code&gt; 에 액세스 하십시오 ( 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원 자임). Rep (E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자 인 경우 Rep (E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">E가 레코드 업데이트 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 는 원자 인 경우 Rep (E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 인 경우 &lt;code&gt;try B after A end&lt;/code&gt; . 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 body 인 경우 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 식이면 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Tc_i&lt;/code&gt; 는 catch 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 케이스 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , 여기서 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절이며 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">E가 try 표현식 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; (여기서 &lt;code&gt;B&lt;/code&gt; 는 본문이고 각 &lt;code&gt;Cc_i&lt;/code&gt; 는 case 절이고 각 &lt;code&gt;Tc_j&lt;/code&gt; 는 catch 절입니다. 그런 다음 Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">E가 튜플 스켈레톤 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">E가 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">E가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 인 경우 Rep (E) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; 경우 E가 if 표현식 이면; ...; Ic_k end , 여기서 각 &lt;code&gt;Ic_i&lt;/code&gt; 는 if 절이고 Rep (E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;E_1 Op E_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 match operator &lt;code&gt;=&lt;/code&gt; 이외의 2 진 연산자 인 경우 Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">E가 연산자 표현식 &lt;code&gt;Op E_0&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 인 경우 Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">E가 nil이면 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (E) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">Erlang이 긴 이름 분산 모드로 시작된 경우 어딘가에서 도메인 이름을 가져 &lt;code&gt;inet&lt;/code&gt; 정보에 대한 시스템 inet 구성 파일을 읽습니다 . 찾은 모든 호스트 및 확인자 정보도 기록되지만 Erlang이 기본 조회를 위해 구성된 경우에는 사용되지 않습니다. 조회 방법이 &lt;code&gt;'file'&lt;/code&gt; 또는 &lt;code&gt;'dns'&lt;/code&gt; 로 변경되면이 정보가 유용 해집니다 ( 아래 참조).</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">Erlang이 예를 들어 목록 &lt;code&gt;[$a,$b,$c]&lt;/code&gt; 를 포트로 &lt;code&gt;bufflen&lt;/code&gt; , &lt;code&gt;buff&lt;/code&gt; 변수 는 &lt;code&gt;3&lt;/code&gt; 이고 버프 변수는 &lt;code&gt;{'a','b','c'}&lt;/code&gt; 를 포함합니다 ( &lt;code&gt;NULL&lt;/code&gt; 종료 없음) ). 일반적으로 첫 번째 바이트는 opcode로 사용되며,이 드라이버에서도 마찬가지입니다 (적어도 포트가 &lt;code&gt;command&lt;/code&gt; 모드 인 경우). opcode는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 선언 인 경우 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; , 여기서 각 &lt;code&gt;Fc_i&lt;/code&gt; 는 길이가 같은 &lt;code&gt;Arity&lt;/code&gt; 의 패턴 시퀀스를 가진 함수 절이며 Rep (F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 스펙 인 경우 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; (여기서 &lt;code&gt;Spec&lt;/code&gt; 은 atom &lt;code&gt;spec&lt;/code&gt; 또는 atom &lt;code&gt;callback&lt;/code&gt; 이며 각 &lt;code&gt;Ft_i&lt;/code&gt; 는 길이가 &lt;code&gt;Arity&lt;/code&gt; 인 인수 시퀀스가있는 제한적인 함수 유형입니다. 그런 다음 Rep (F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 함수 스펙 인 경우 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; , 여기서 각 &lt;code&gt;Ft_i&lt;/code&gt; 는 길이가 &lt;code&gt;Arity&lt;/code&gt; 인 인수 시퀀스가있는 제한적인 함수 유형이며 Rep (F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">F가 레코드 선언 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; 이고 여기서 각 &lt;code&gt;V_i&lt;/code&gt; 가 레코드 필드 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 입니다. Rep (V)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">F가 레코드 필드 유형 &lt;code&gt;Name :: Type&lt;/code&gt; 인 경우, &lt;code&gt;Type&lt;/code&gt; 은 유형 인 경우 Rep (F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">F가 유형 선언 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Type&lt;/code&gt; 은 원자 &lt;code&gt;type&lt;/code&gt; 이거나 &lt;code&gt;opaque&lt;/code&gt; 경우 각 &lt;code&gt;V_i&lt;/code&gt; 는 변수이고 &lt;code&gt;T&lt;/code&gt; 는 유형이고 Rep (F ) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">F가 와일드 속성 &lt;code&gt;-A(T)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">F가 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; 경우 Rep (F) = {attribute, LINE, export, [{Fun_1, A_1}, ..., {Fun_k, A_k}]} .</target>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-file(File,Line)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">F가 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 경우 Rep (F) = {attribute, LINE, import, {Mod, [{Fun_1, A_1}, .. ., {Fun_k, A_k}]}} .</target>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">F가 속성 &lt;code&gt;-module(Mod)&lt;/code&gt; 인 경우 Rep (F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">&lt;code&gt;Ft_1 when Fc&lt;/code&gt; 일 때 Ft가 제한된 함수 유형 Ft_1이면 &lt;code&gt;Ft_1&lt;/code&gt; 은 함수 유형이고 &lt;code&gt;Fc&lt;/code&gt; 는 함수 제약 조건 인 경우 Rep (T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 입니다. 담당자 (Fc)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Ft가 함수 유형 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; 이면 각 &lt;code&gt;T_i&lt;/code&gt; 는 유형 인 경우 Rep (Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">G가 유향 그래프 인 경우 G의 꼭짓점과 가장자리가 &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; 의 꼭짓점과 가장자리와 동일하다는 것이 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Gt가 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 인 경우, 각 &lt;code&gt;Size_i&lt;/code&gt; 는 가드 테스트이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형 지정자 목록 인 경우 Rep (Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 위를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 단점 뼈대 인 경우 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 함수 호출 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; 이면 &lt;code&gt;A&lt;/code&gt; 는 원자 인 경우 Rep (Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">GT는 함수 호출이면 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; , &lt;code&gt;A_m&lt;/code&gt; 가 원자이다 &lt;code&gt;erlang&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 는 원자 또는 조작자 후 담당자 (Gt의)이다 = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 작성 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Gt가 맵 업데이트 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 또는 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)에 대해서는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">Gt가 괄호로 묶인 가드 테스트 &lt;code&gt;( Gt_0 )&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt; 즉, 괄호로 묶은 가드 테스트는 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 작성 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">GT는이 기록 필드 액세스이면 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; , &lt;code&gt;Field&lt;/code&gt; 다음 원자, 담당자 (GT는) =이다 &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 레코드 필드 인덱스 &lt;code&gt;#Name.Field&lt;/code&gt; 이고 여기서 &lt;code&gt;Field&lt;/code&gt; 가 원자 인 경우 Rep (Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Gt가 튜플 스켈레톤 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; 인 경우 Rep (Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Gt가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 A는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">Gt가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 이면 Rep (Gt) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 운영자 가드 테스트 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; 인 경우 &lt;code&gt;Op&lt;/code&gt; 는 match operator &lt;code&gt;=&lt;/code&gt; 이외의 이진 연산자 인 경우 Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Gt가 운영자 가드 테스트 &lt;code&gt;Op Gt_0&lt;/code&gt; 이면 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 인 경우 Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Gt가 nil이면 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 문자 리터럴 인 경우 Rep (L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 부동 리터럴 인 경우 Rep (L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">L이 &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; 문자로 구성된 문자열 리터럴 인 경우 Rep (L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 원자 리터럴 인 경우 Rep (L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">L이 정수 리터럴 인 경우 Rep (L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">Mnesia가 로컬 노드에서 작동 중지되면이 함수는 현재 작동 &lt;code&gt;extra_db_nodes&lt;/code&gt; 다른 &lt;code&gt;db_nodes&lt;/code&gt; 및 extra_db_nodes 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">Mnesia가 시작되면이 함수는 로컬 노드의 Mnesia가 완전히 연결된 노드를 반환합니다. Mnesia가 스키마 정보를 교환 한 노드 만 &lt;code&gt;running_db_nodes&lt;/code&gt; 로 포함됩니다 . 스키마를 병합 한 후에는 로컬 Mnesia 시스템이 완전히 작동하며 응용 프로그램이 원격 복제본에 대한 액세스를 수행 할 수 있습니다. 스키마 병합 전에 Mnesia는 로컬에서만 작동합니다. 때로는 &lt;code&gt;running_db_nodes&lt;/code&gt; 목록에 모든 &lt;code&gt;db_nodes&lt;/code&gt; 및 &lt;code&gt;extra_db_nodes&lt;/code&gt; 보다 더 많은 노드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">Mnesia를 저장 방법으로 사용하는 경우 HTTP 서버보다 먼저 Mnesia를 시작해야합니다. Mnesia를 처음 시작하면 Mnesia를 시작하기 전에 스키마와 테이블을 작성해야합니다. Mnesia를 생성하고 시작하는 두 가지 기능을 가진 모듈의 간단한 예가 여기에 제공됩니다. &lt;code&gt;first_start/0&lt;/code&gt; 기능 이 처음으로 사용됩니다. 스키마와 테이블을 만듭니다. &lt;code&gt;start/0&lt;/code&gt; 은 연속적인 시작에 사용됩니다. &lt;code&gt;start/0&lt;/code&gt; 은 Mnesia를 시작하고 테이블이 시작되기를 기다립니다. 이 함수는 스키마와 테이블이 이미 작성된 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">P가 비트 스트링 패턴 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; 인 경우, 각 &lt;code&gt;Size_i&lt;/code&gt; 는 정수로 평가할 수있는 표현식이고 각 &lt;code&gt;TSL_i&lt;/code&gt; 는 유형별리스트입니다. 담당자 (P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . 담당자 (TSL)는 아래를 참조하십시오. 생략 된 &lt;code&gt;Size_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 . 생략 된 &lt;code&gt;TSL_i&lt;/code&gt; 는 &lt;code&gt;default&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 복합 패턴 &lt;code&gt;P_1 = P_2&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">P가 단점 패턴 인 경우 &lt;code&gt;[P_h | P_t]&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">P가 맵 패턴 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; 이고 Rep (P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">P가 nil 패턴 &lt;code&gt;[]&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{nil,LINE}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">P가 괄호로 묶인 패턴 &lt;code&gt;( P_0 )&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;Rep(P_0)&lt;/code&gt; , 즉 괄호로 묶인 패턴은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 필드 인덱스 패턴 &lt;code&gt;#Name.Field&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;Field&lt;/code&gt; 는 원자 인 경우 Rep (P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">P가 레코드 패턴 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;Field_i&lt;/code&gt; 가 원자 또는 &lt;code&gt;_&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">P가 튜플 패턴 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; 인 경우 Rep (P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">P가 범용 패턴 &lt;code&gt;_&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">P가 가변 패턴 &lt;code&gt;V&lt;/code&gt; 이면 Rep (P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 A는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 .</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">P가 원자 리터럴 &lt;code&gt;L&lt;/code&gt; 인 경우 Rep (P) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 &lt;code&gt;Op P_0&lt;/code&gt; 이면 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일시 숫자로 평가할 수있는 표현식의 발생) 인 경우 Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">P가 연산자 패턴 &lt;code&gt;P_1 Op P_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 2 진 연산자입니다 (이것은 리터럴 문자열 또는 문자 목록에 적용된 &lt;code&gt;++&lt;/code&gt; 발생 또는 컴파일시 숫자로 평가 될 수있는 표현식 발생입니다) )를 입력 한 다음 Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">PER 인코딩이 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">Ps가 일련의 패턴 &lt;code&gt;P_1, ..., P_k&lt;/code&gt; 이면 Rep (Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; 입니다. 이러한 시퀀스는 함수 또는 재미에 대한 인수 목록으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 비트 스트링 생성기 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; 이고 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">Q가 필터 &lt;code&gt;E&lt;/code&gt; 이고 여기서 &lt;code&gt;E&lt;/code&gt; 가 표현식이면 Rep (Q) = &lt;code&gt;Rep(E)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Q가 제너레이터 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; 이며, 여기서 &lt;code&gt;P&lt;/code&gt; 는 패턴이고 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">R이 X와 Y의 관계이고 S가 Y와 Z 의 관계인 경우 R과 S 의 &lt;strong id=&quot;relative_product&quot;&gt;상대 곱은&lt;/strong&gt; x와 Z의 관계 T가 정의되어 있으므로 요소 y가있는 경우에만 x T z x R y 및 y S z와 같은 Y에서.</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">R이 X의 관계이고 S가 x = y가 아닌 x R y 인 경우 x S y가 정의되어 있으면 S는 R에 해당하는 &lt;strong id=&quot;strict_relation&quot;&gt;엄격한&lt;/strong&gt; 관계입니다. 반대로 S가 X의 관계인 경우 R은 x S y 또는 x = y 인 경우 x R y가되도록 정의되며, R은 S에 해당하는 &lt;strong id=&quot;weak_relation&quot;&gt;약한&lt;/strong&gt; 관계입니다.</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">R이 X에서 동등성 관계이고 x가 X의 요소 인 경우, R에 대한 x 의 &lt;strong id=&quot;equivalence_class&quot;&gt;동등성 클래스&lt;/strong&gt; 는 x R y가 보유하는 X의 모든 요소 y의 세트입니다. 동등성 클래스는 X의 파티셔닝을 구성합니다. 반대로, C가 X의 파티션 인 경우, X가 동일한 동등성 클래스에 속하는 경우 X의 두 요소에 대해 유지되는 관계는 파티션 C에 의해 유발 된 동등성 관계입니다.</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">R이 X에서 동등성 관계인 경우 &lt;strong id=&quot;canonical_map&quot;&gt;표준 맵&lt;/strong&gt; 은 X의 모든 요소를 ​​해당 동등성 클래스에 맵핑하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">S가 R에서 A 로의 제한 인 경우 R은 S에서 X 로의 &lt;strong id=&quot;extension&quot;&gt;확장&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">S가 세트의 요소 (T, X) 인 경우 T는 &lt;strong id=&quot;valid_type&quot;&gt;유효한&lt;/strong&gt; X &lt;strong id=&quot;valid_type&quot;&gt;유형&lt;/strong&gt; , T는 S 유형, X는 외부 S 세트입니다. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; 는 유형에서 세트를 작성하고 Erlang 용어는 외부 집합으로 바뀌었다.</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">SASL이 &lt;code&gt;.rel&lt;/code&gt; 파일에 응용 프로그램으로 포함되어 있지 않으면 해당 릴리스를 업그레이드에 사용할 수 없으므로 경고가 표시됩니다. 이 경고를 끄려면 &lt;code&gt;no_warn_sasl&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">SNMPv3을 사용하는 경우 이러한 MIB가 기본적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">SetFun을 fun로 지정하면 지정된 세트의 각 요소에 fun이 적용되고 리턴 값은 세트로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">SetFun이 튜플 &lt;code&gt;{external, Fun}&lt;/code&gt; 로 지정되면 지정된 세트의 각 요소의 외부 세트에 Fun이 적용되고 리턴 값은 외부 세트 인 것으로 가정됩니다. 비 순차 세트의 요소를 외부 세트로 선택하고 외부 세트의리스트로부터 새로운 비 순차 세트를 조립하는 것이 본 구현에서 각 요소를 세트로 수정하는 것보다 더 효율적이다. 그러나이 최적화는 비 순차 세트의 요소가 원자 또는 순서 세트 인 경우에만 사용할 수 있습니다. 또한 요소 유형이 Fun의 일부 절 (작성된 세트의 유형이 지정된 세트의 유형에 Fun을 적용한 결과 임)과 일치하고 Fun이 선택, 복제 또는 요소의 일부를 재정렬.</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">T가 &lt;code&gt;( T_0 )&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;Rep(T_0)&lt;/code&gt; . 즉, 괄호로 묶은 유형은 해당 본문과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">T가 비트 열 유형 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; 이고 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 이 단일 정수 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 재미있는 유형 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">T가 재미있는 유형 &lt;code&gt;fun()&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">T가 fun type &lt;code&gt;fun(Ft)&lt;/code&gt; 이면 &lt;code&gt;Ft&lt;/code&gt; 가 함수 유형이면 Rep (T) = &lt;code&gt;Rep(Ft)&lt;/code&gt; 입니다. Rep (Ft)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">T가 맵 유형 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">T가 맵 유형 &lt;code&gt;map()&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 사전 정의 된 (또는 내장 된) 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">T가 레코드 유형 &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;F_i&lt;/code&gt; 는 레코드 필드 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; 입니다. 담당자 (F)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">T가 원격 유형 &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;tuple()&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 유형 공용체 인 경우 &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">T가 유형 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 . 유형 변수는 밑줄 ( &lt;code&gt;_&lt;/code&gt; )을 제외한 모든 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 사용자 정의 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 주석이 달린 유형 &lt;code&gt;A :: T_0&lt;/code&gt; 이면 &lt;code&gt;A&lt;/code&gt; 는 변수이고 Rep (T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">T가 원자 또는 정수 리터럴 L이면 Rep (T) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">T가 정수 범위 타입 &lt;code&gt;L .. H&lt;/code&gt; 인 경우, &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;H&lt;/code&gt; 는 싱글 톤 정수 타입이면 Rep (T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;Op T_0&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생) 인 경우 Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;T_1 Op T_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 2 진 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생) 인 경우 Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">T가 빈 목록 유형 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">TLS가 요청되면 ( &lt;code&gt;Bool=true&lt;/code&gt; ) 연결 프로세스는 피어와 TLS 핸드 셰이크를 시작해야하며 수락 프로세스는 핸드 셰이크 수락을 준비해야합니다. 성공적인 핸드 셰이크 다음에 상위 프로세스 에 대한 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 메시지 가 와야 합니다. 핸드 셰이크에 실패하면 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">TS가 유형 지정자 &lt;code&gt;A:Value&lt;/code&gt; 이며 여기서 &lt;code&gt;A&lt;/code&gt; 는 원자이고 &lt;code&gt;Value&lt;/code&gt; 는 정수이면 Rep (TS) = &lt;code&gt;{A,Value}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">TS가 유형 지정자 &lt;code&gt;A&lt;/code&gt; 이고 여기서 &lt;code&gt;A&lt;/code&gt; 가 원자 인 경우 Rep (TS) = &lt;code&gt;A&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">Trace Tool Builder를 원격 노드에 사용하려면 추적 제어 노드를 &lt;strong&gt;hidden&lt;/strong&gt; 으로 시작하는 것이 좋습니다 . 이렇게하면 추적 된 노드에서 &quot;보이지&quot;않고 추적 된 노드에 연결할 수 있습니다. 즉, 추적 된 노드에서 &lt;code&gt;nodes()&lt;/code&gt; BIF가 호출되면 추적 제어 노드가 표시되지 않습니다. 숨겨진 노드를 시작하려면 &lt;code&gt;-hidden&lt;/code&gt; 과 같이 &lt;code&gt;erl&lt;/code&gt; 명령에 -hidden 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열 &lt;code&gt;VarName&lt;/code&gt; 은 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열 &lt;code&gt;VarName&lt;/code&gt; 및 &lt;code&gt;Value&lt;/code&gt; 는 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열에는 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">유니 코드 파일 이름 변환이 적용되고 파일 시스템이 투명하면 유니 코드로 해석 할 수없는 파일 이름이 발생할 수 있습니다.이 경우 원시 파일 이름 (즉, 이진)을 처리 할 수 ​​있도록 &lt;code&gt;fun()&lt;/code&gt; 을 준비해야합니다. 정규식에 코드 포인트&amp;gt; 255가 포함 된 경우 예상 문자 인코딩을 준수하지 않는 (즉, 유효한 UTF-8로 인코딩되지 않은) 파일 이름과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">유니 코드 파일 이름이 활성화되어 있으면 &lt;code&gt;os:getenv/0,1&lt;/code&gt; , &lt;code&gt;os:putenv/2&lt;/code&gt; 및 &lt;code&gt;os:unsetenv/1&lt;/code&gt; 에 대한 호출은 유니 코드 문자열을 처리합니다. Unix와 같은 플랫폼에서 내장 함수는 UTF-8 환경 변수를 코드 포인트가 255보다 큰 유니 코드 문자열로 또는 그로부터 변환합니다. Windows에서는 환경 시스템 API의 유니 코드 버전이 사용되며 코드 포인트&amp;gt; 255 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">유니 코드 변환이 유효한 경우 ( &lt;code&gt;~ts&lt;/code&gt; ), 255보다 큰 문자가 허용됩니다. 변환 수정자를 사용하면 반환 된 목록에 정수&amp;gt; 255가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A :: T&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 인 경우 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E :: T&lt;/code&gt; 이며 여기서 &lt;code&gt;E&lt;/code&gt; 는 표현식이고 &lt;code&gt;T&lt;/code&gt; 는 유형 인 경우 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E&lt;/code&gt; 인 경우 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A&lt;/code&gt; 이면 Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">VM이 유니 코드 파일 이름 모드 인 경우 &lt;code&gt;string()&lt;/code&gt; 및 &lt;code&gt;char()&lt;/code&gt; 는&amp;gt; 255가 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; 유형 의 설명서도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">VM이 유니 코드 파일 이름 모드 인 경우 문자는&amp;gt; 255를 &lt;code&gt;RawFilename&lt;/code&gt; 할 수 없습니다 . RawFilename 은 유니 코드 변환이 적용되지 않는 파일 이름입니다 . 즉 파일 시스템에서 예상되는 유니 코드 인코딩을 준수하지 않는 문자 (UTF가 아닌 문자)를 포함 할 수 있습니다. VM이 유니 코드 파일 이름 모드로 시작되었지만 -8 자). 파일 이름 에는 널 문자 (정수 값 0)를 &lt;strong&gt;사용할&lt;/strong&gt; 수 없습니다 (끝까지도).</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">X = Y이면 R &lt;strong&gt;을&lt;/strong&gt; X 에서 관계라고합니다.</target>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 길이 둘 이상의 버텍스를 통해 존재 &lt;code&gt;V&lt;/code&gt; 사이클이리스트로서 반환한다 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 정점. 경우 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;V&lt;/code&gt; 가 존재 루프리스트로서 반환한다 &lt;code&gt;[V]&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 를 통한 사이클 이 존재 하지 않으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">코드 경로에 &lt;code&gt;Dir&lt;/code&gt; 이 이미 있으면 이전 위치에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">경우 &lt;code&gt;StateFun&lt;/code&gt; 의 기능 충돌 또는 예외를 발생 프로세스의 기존 상태에 대한 변경되지 &lt;code&gt;gen_server&lt;/code&gt; 및 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스. 용 &lt;code&gt;gen_event&lt;/code&gt; 처리하는 충돌 또는 실패 &lt;code&gt;StateFun&lt;/code&gt; 의 기능 수단이 그것이 실패하거나 변하지 충돌시에 작동하고, 특정의 이벤트 핸들러의 상태; 동일한 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 등록 된 다른 이벤트 핸들러의 상태를 변경하는 데 여전히 성공할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;StateFun&lt;/code&gt; 함수가 프로세스 상태의 변경에 영향을 미치지 않기로 결정 하면 프로세스 유형에 관계없이 &lt;code&gt;State&lt;/code&gt; 인수를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;Tag&lt;/code&gt; speciifed되고, 반환 된 &lt;code&gt;Match&lt;/code&gt; 또한 일치 포함 &lt;code&gt;Tag&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;RxMatch&lt;/code&gt; 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">경우 &lt;code&gt;Threshold&lt;/code&gt; 지정되고, 카운터 값이 리셋된다 &lt;code&gt;SetValue&lt;/code&gt; 는 다음의 조건이 발생할 경우 :</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pid()&lt;/code&gt; 은 튜플 &lt;code&gt;{timeout, Millis}&lt;/code&gt; , &lt;code&gt;{in, Location}&lt;/code&gt; , 및 &lt;code&gt;{out, Location}&lt;/code&gt; 존재, &lt;code&gt;Location&lt;/code&gt; (어느 쪽 MFA 인 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 기능을 설명) 여기서 프로세스 in / out으로 예약되었거나 원자 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">경우 &lt;code&gt;port()&lt;/code&gt; 은 튜플 &lt;code&gt;{timeout, Millis}&lt;/code&gt; 및 &lt;code&gt;{port_op,Op}&lt;/code&gt; 이 존재한다. &lt;code&gt;Op&lt;/code&gt; 는 실행중인 드라이버 콜백에 따라 &lt;code&gt;proc_sig&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;output&lt;/code&gt; , &lt;code&gt;event&lt;/code&gt; 또는 &lt;code&gt;dist_cmd&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">경우 &lt;code&gt;property_parm()&lt;/code&gt; 입력 (일부로 발견 &lt;code&gt;SDP&lt;/code&gt; 그럼 그대로 남아).</target>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;relup&lt;/code&gt; 의 파일 및 / 또는이라는 시스템 구성 파일 &lt;code&gt;sys.config&lt;/code&gt; , 또는 &lt;code&gt;sys.config.src&lt;/code&gt; 이 발견되어,이 파일은 릴리스 패키지에 포함되어 있습니다. &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;strong&gt;틱이&lt;/strong&gt; 발생, 즉, 연결의 다른 쪽 끝에있는 얼랑 노드가 아직 살아 있는지를보기 위해 노드를 폴링하고있다, 함수는 반환 &lt;code&gt;ERL_TICK&lt;/code&gt; 어떠한 메시지 버퍼에 저장되지 않습니다. 또한 &lt;code&gt;erl_errno&lt;/code&gt; 는 &lt;code&gt;EAGAIN&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">&lt;strong&gt;틱이&lt;/strong&gt; 발생 하는 경우, 즉 연결의 다른 쪽 끝에있는 Erlang 노드가이 노드를 폴링하여 여전히 &lt;code&gt;ERL_TICK&lt;/code&gt; 인지 확인한 경우, 틱이 수신되어 응답했지만 메시지가 배치되지 않았 음을 나타내는 ERL_TICK을 리턴합니다. 버퍼에. 이 경우 &lt;code&gt;erl_receive_msg()&lt;/code&gt; 다시 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">바이너리가 프로세스 또는 포트에 메시지로 전송되면 바이너리는 축소되고 추가 작업을 수행하면 바이너리 데이터가 새로운 바이너리로 복사됩니다. 예를 들어 다음 코드 조각에서 &lt;code&gt;Bin1&lt;/code&gt; 은 세 번째 줄에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">이진이 더 큰 이진을 참조하는 경우 (종종 이진이라고도 함) 참조 된 이진의 크기를 얻는 것이 유용 할 수 있습니다. 이 기능은 프로그램에서 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; 사용을 트리거하는 데 사용할 수 있습니다 . 이진을 복사함으로써, 작은 이진이 참조하는 원래, 아마도 큰 이진을 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">통화가이 기능에 추가되어있는 경우, 모듈에 말 &lt;code&gt;m1&lt;/code&gt; 의 새로운 버전의 경우, 런타임 오류가 릴리스 업그레이드하는 동안 발생할 수있는 수 &lt;code&gt;m1&lt;/code&gt; 처음로드 및 호출이됩니다 &lt;code&gt;ch3:available/0&lt;/code&gt; 의 새 버전 전에 &lt;code&gt;ch3&lt;/code&gt; 로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">TFTP 서버에서 파일 액세스를 수행하는 콜백이 너무 오래 걸리면 (더블 TFTP 시간 초과) 서버가 연결을 중단하고 클라이언트에 오류 응답을 보냅니다. 이는 서버가 이전보다 더 빠르게 연결에 연결된 리소스를 해제 함을 의미합니다. 서버는 단순히 클라이언트가 포기했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">콜백 함수가 실패하거나 잘못된 값을 반환하면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">콜백 함수가 실패하거나 잘못된 값을 반환하면 별도로 명시하지 않는 한 &lt;code&gt;gen_statem&lt;/code&gt; 이 종료됩니다. 그러나 클래스 &lt;code&gt;throw&lt;/code&gt; 예외 는 오류로 간주되지 않고 모든 콜백 함수의 유효한 반환으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 다른 모든 하위 프로세스가 종료 된 후 종료 된 프로세스를 포함하여 모든 하위 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 해당 프로세스 만 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 나머지 하위 프로세스 (즉, 종료 된 프로세스 이후의 하위 프로세스가 시작 순서로 종료 됨)가 종료됩니다. 그런 다음 종료 된 하위 프로세스 및 나머지 하위 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">클라이언트와 서버가 RFC 2817에서 정의한 업그레이드 메커니즘을 사용하여 일반 TCP / IP 연결을 TLS 연결로 업그레이드하려는 경우 Erlang SSL 응용 프로그램 API에서 지원됩니다. 예를 들어 동일한 포트에서 HTTP 및 HTTPS를 지원하고 가상 호스팅을 구현하는 데 유용 할 수 있습니다. 이것은 TLS 기능 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">클라이언트가 서버의 응답 권한을 제한하는 헤더 필드 중 하나 이상을 전송하는 경우 표준에서는이를 처리하는 방법을 지정하지 않습니다. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 는 다음 순서로 각 필드를 제어하며 필드 중 하나가 현재 상태와 일치하지 않으면 적절한 응답으로 요청이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">쉘이 명령 (로컬 함수 호출)을 인식하지 못하면 먼저 &lt;code&gt;user_default&lt;/code&gt; 모듈에서 함수를 찾으려고 시도하며 , 여기서 사용자 정의 된 로컬 명령을 배치 할 수 있습니다. 발견되면 함수가 평가되고, 그렇지 않으면 &lt;code&gt;shell_default&lt;/code&gt; 모듈의 함수를 평가하려고 시도 합니다. &lt;code&gt;user_default&lt;/code&gt; 모듈을 명시 적으로로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; 선택하는 주석이 있으면 두 번째 줄에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">완전한 시스템이 디스크없는 및 / 또는 읽기 전용 클라이언트 노드로 구성된 경우, &lt;code&gt;clients&lt;/code&gt; 디렉토리가 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에 추가됩니다 . 읽기 전용 노드는 읽기 전용 파일 시스템이있는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">창 크기가 더 큰 압축 스트림이 입력으로 지정되면 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;data_error&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">일치하는 하위 패턴에 대한 조건 테스트가 고유하지 않은 숫자를 참조하는 경우 해당 숫자의 하위 패턴이 일치하면 테스트가 참입니다.</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">구성 변수가 여러 파일에 정의되어 있고 가능한 모든 값에 액세스하려는 경우 함수 &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; 를 사용 하고 옵션 목록에서 &lt;code&gt;all&lt;/code&gt; 를 지정 하십시오. 그런 다음 값이 목록으로 리턴되고 요소 순서는 시작시 구성 파일이 지정된 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">구성 변수가 여러 파일에 정의 된 경우 &lt;code&gt;all&lt;/code&gt; 옵션 을 사용하여 가능한 모든 값에 액세스하십시오. 값이 목록으로 반환됩니다. 요소의 순서는 시작시 구성 파일이 지정된 순서에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">구성 변수 키가 이름과 연관된 경우 ( &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문으로) 키 대신 이름을 사용하여 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">연결 시도가 실패하면 다음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">이 명령 후에 충돌이 발생하면 시스템을 복구 할 수 없으며 이전 릴리스 버전에서 다시 시작됩니다. 명령은 스크립트에서 한 번만 발생해야합니다. 모든 &lt;code&gt;load_object_code&lt;/code&gt; 명령 뒤에 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">충돌이 발생하면 환경 변수 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 가 설정 되지 않으면 &lt;code&gt;erl_crash.dump&lt;/code&gt; 가 작성되지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">사용자 정의 CLI가 설치된 경우 (옵션 &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; 참조 ) 위의 규칙은 사용자 정의 CLI에 의해 암시 된 것으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">기본 개체 &lt;code&gt;Default&lt;/code&gt; 가 지정되면 키가 테이블에서 누락 된 경우 업데이트 할 개체로 사용됩니다. 키 대신 값이 무시되고 적절한 키 값으로 대체됩니다. 리턴 값은 기본 오브젝트가 사용되지 않은 것처럼 (즉, 단일 업데이트 된 요소 또는 해당 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">HTTP 서버 구성 파일의 인증 지시문과 &lt;code&gt;htaccess&lt;/code&gt; 파일 모두에 의해 디렉토리가 제한되는 경우 , 사용자는 요청이 성공하기 위해 두 가지 방법으로 파일에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">재해가 발생하고 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스가 손상된 경우 백업에서 재구성 할 수 있습니다. 백업에 오래된 데이터가 포함되어 있으므로이를 최후의 수단으로 간주하십시오. 데이터는 일관성있게 유지되지만 이전 백업을 사용하여 데이터베이스를 복원하면 데이터가 확실히 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">디스크없는 및 / 또는 읽기 전용 클라이언트 노드가 시작 &lt;code&gt;start_erl.data&lt;/code&gt; 파일 이 마스터 노드의 클라이언트 디렉토리에 있습니다. 따라서 &lt;code&gt;START_ERL_DATA&lt;/code&gt; 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">SASL 구성 매개 변수 &lt;code&gt;static_emulator&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 디스크없는 및 / 또는 읽기 전용 클라이언트 노드가 시작 되려는 경우 &lt;code&gt;-boot&lt;/code&gt; 및 &lt;code&gt;-config&lt;/code&gt; 플래그를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">드라이버가 기능적인 방식으로 사용되는 경우 (즉, 상태를 유지하지 않지만 일부 계산 만 수행하고 결과를 반환하는 경우) 등록 된 이름을 가진 여러 포트를 미리 열어서 사용할 포트를 기반으로 선택할 수 있습니다 스케줄러 ID는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">기능이 R13A 이상에 추가 된 경우 텍스트에 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">파일 이름이 인수로 지정된 경우 디버거는이 파일에서 해당 설정을로드하려고합니다. 설정에 대한 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">필터 또는 처리기가 여전히 충돌하는 경우 Logger는 해당 필터 또는 처리기를 구성에서 제거하고 짧은 오류 메시지를 터미널에 인쇄합니다. 충돌 이유 및 기타 세부 사항이 포함 된 디버그 이벤트도 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">재미 등록을 시도 할 때 이미 재미가 등록 된 경우 &lt;code&gt;{error, exists}&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">함수가 입력으로 지정되고 마지막 입력 함수가 &lt;code&gt;{end_of_input, Value}&lt;/code&gt; 리턴 하면, 출력으로 지정된 함수는 &lt;code&gt;{value, Value}&lt;/code&gt; 인수와 함께 호출됩니다 . 이를 통해 입력 기능으로 계산 된 값으로 일련의 출력 기능을 쉽게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">시스템의 가비지 콜렉션으로 인해 힙의 할당 된 크기가 최소 &lt;code&gt;Size&lt;/code&gt; 단어 인 경우 &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;GcPid&lt;/code&gt; 및 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;timeout&lt;/code&gt; 태그가 지정된 튜플 이 존재하지 않는다는 점을 제외하면 &lt;code&gt;long_gc&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">시스템의 가비지 콜렉션이 최소 &lt;code&gt;Time&lt;/code&gt; 벽시계 밀리 초를 소요하면 &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;GcPid&lt;/code&gt; 는 가비지 수집 된 pid입니다. &lt;code&gt;Info&lt;/code&gt; 는 가비지 콜렉션의 결과를 설명하는 2 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈이 Cover 컴파일되지 않은 경우 오류 이유 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">그룹에 하위 그룹이 포함 된 경우 이들 그룹의 실행 속성을 그룹 튜플에 지정할 수도 있습니다. &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; 여기서 &lt;code&gt;SubGroups&lt;/code&gt; 는 튜플 목록, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; 또는 &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; 부분 군을 나타냅니다. &lt;code&gt;SubGroups&lt;/code&gt; 목록에 지정되지 않은 그룹에 대해 &lt;code&gt;group/0&lt;/code&gt; 에 정의 된 모든 하위 그룹 은 사전 정의 된 속성으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">그룹에 병렬 속성이있는 경우 테스트 사례가 동시에 생성되고 병렬로 실행됩니다. 그러나 테스트 케이스는 &lt;code&gt;end_per_group/2&lt;/code&gt; 와 병렬로 실행할 수 없습니다. 즉, 병렬 그룹을 실행하는 시간이 그룹에서 가장 느린 테스트 케이스의 실행 시간과 같습니다. 테스트 케이스를 병렬로 실행하면 부정적인 결과는 HTML 요약 페이지가 그룹의 &lt;code&gt;end_per_group/2&lt;/code&gt; 함수 가 완료 될 때까지 개별 테스트 케이스 로그에 대한 링크로 업데이트되지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">현재 구성과 비교하여 키가 제거되고 키가 로거에 의해 알려진 경우 기본값이 사용됩니다. 사용자 정의 키인 경우 값이 제거되거나 기본값이 삽입되면 핸들러 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">현재 구성과 비교하여 키가 제거되면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">&lt;code&gt;ModFiles&lt;/code&gt; 목록이 입력으로 제공되면 &lt;code&gt;Result&lt;/code&gt; 목록 이 리턴됩니다. 반환 된 목록의 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; 에서 식별자 목록이 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">로컬 함수가 자동 반입 된 BIF와 동일한 이름을 갖는 경우, 의미는 내재적으로 규정 된 함수 호출이 BIF가 아닌 로컬로 정의 된 함수로 보내진다는 의미입니다. 혼동을 피하기 위해 BIF를 자동으로 가져 오지 않도록 하는 컴파일러 지시문 인 &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; 있습니다. 특정 상황에서 이러한 컴파일 지시문은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">로그 이벤트가 특정 핸들러에 대한 모든 기본 필터 및 모든 핸들러 필터를 통과하면 로거는 이벤트를 &lt;strong&gt;핸들러 콜백으로&lt;/strong&gt; 전달합니다 . 핸들러는 이벤트를 대상으로 형식화하고 인쇄합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">로그가 분배되도록 구성된 경우 모든 항목이 모든 노드에 기록되지 않을 수 있습니다. &lt;code&gt;wrap_log_reader&lt;/code&gt; 는 호출 된 노드의 로그 만 읽습니다. 모든 항목을 읽었는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">지정된 이름의 로그가 일부 노드에서 로컬이고 동일한 노드에 분산 된 로그를 열려고하면 튜플 &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; 이 반환됩니다. 로그가 일부 노드에 분배되고 동일한 노드에서 로컬로 로그를 열려고하면 동일한 튜플이 리턴됩니다. 개별 분산 디스크 로그를 처음 열면 해당 로그가 (비어있을 수있는) 분산 디스크 로그에 추가됩니다. 제공된 옵션 값은 옵션 &lt;code&gt;distributed&lt;/code&gt; 의해 언급 된 모든 노드에서 사용됩니다 . 개별 분산 로그는 서로의 옵션 값에 대해 아무것도 모르므로 &lt;code&gt;open/1&lt;/code&gt; 을 여러 번 호출하여 분산 로그를 만들어 각 노드에 고유 한 옵션 값을 부여 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">매크로가 여러 모듈에서 사용되는 경우 매크로 정의를 포함 파일에 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치하지 않으면 인증서를 수락해야하는 상황이있을 수 있습니다. 예를 들어 오래된 인증서를 수락하도록 선택한 웹 브라우저를 생각해보십시오. 이 옵션을 사용하면 이러한 기능을 구현할 수 있습니다. 이 &lt;code&gt;fun/1&lt;/code&gt; 은 일치하는 &lt;code&gt;ReferenceID&lt;/code&gt; 가 없을 때 호출됩니다 . fun의 반환 값 ( &lt;code&gt;boolean()&lt;/code&gt; )이 결과를 결정합니다. 만약 &lt;code&gt;true&lt;/code&gt; 하여 인증서가 그렇지 않은 경우 접수가 거부됩니다. 사용 설명서의 &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">멤버가 종료되면 그룹에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">&quot;가상&quot;연결이 설정되기 전에 메시지가 수신되면 연결이 자동으로 설정됩니다. MGC는 실제로 개방적이며 전송 계층 접촉이 수행되는 방식에 따라 사용할 인코딩 및 전송 서비스를 동적으로 결정할 수 있습니다. IP 전송의 경우 두 개의 포트가 표준화되어 있습니다. 하나는 텍스트 인코딩 용이고 다른 하나는 이진 인코딩 용입니다. 예를 들어 UDP 패킷이 텍스트 포트에서 수신 된 경우 인코딩 및 전송을 즉시 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">모듈이 Cover 컴파일되지 않은 경우 오류 이유 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">모듈이 커버로부터 컴파일 된 경우 &lt;code&gt;.beam&lt;/code&gt; 의 사용, 즉 파일 &lt;code&gt;compile_beam/1&lt;/code&gt; 또는 &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; 소스 코드가 동일한 디렉토리에서 발견 될 수 있다는 것이 가정된다 &lt;code&gt;.beam&lt;/code&gt; 의 파일에 &lt;code&gt;../src&lt;/code&gt; 상대적 해당 디렉토리로 또는 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 의 소스 경로를 사용하십시오 . 후자를 사용할 때 두 가지 경로가 검사됩니다. 먼저 &lt;code&gt;../src&lt;/code&gt; 를 결합하여 구성되는 경로와 후행 &lt;code&gt;src&lt;/code&gt; 구성 요소 아래의 컴파일 된 경로의 꼬리와 컴파일 된 경로 자체입니다. 소스 코드가 없으면 오류 이유 &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">가비지 수집시 모니터링 프로세스가 너무 커서 시스템 모니터 메시지를 발생시키기 시작하면 메시지가 프로세스 메시지 큐를 확대하여 문제점을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">예를 들어 &lt;code&gt;gen_server&lt;/code&gt; 의 내부 상태 형식 변경과 같이보다 복잡한 변경이 이루어진 경우 간단한 코드 교체로는 충분하지 않습니다. 대신 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">이름 충돌이 발생하면 컴파일러는 &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; 메시지를 보고 정의 이름이 바뀌 었는지 여부와 데이터를 인코딩 / 디코딩하는 데 사용해야하는 새 이름을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">에 이름 경우 &lt;code&gt;Files&lt;/code&gt; 기존 파일의 이름이 아닌, 이고르는 모듈의 이름을 나타내며, 위치 및 해당 소스 파일을 읽으려고 가정합니다. 파싱 ​​된 파일은 &lt;code&gt;Sources&lt;/code&gt; 에 추가되고 &lt;code&gt;merge_sources/3&lt;/code&gt; 에 전달됩니다 . 즉, &lt;code&gt;Sources&lt;/code&gt; 항목은 파일에서 항목을 읽기 전에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">기존 레코드와 동일한 키를 사용하여 새 항목을 삽입하면 이전 레코드를 덮어 씁니다. 그러나 테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 각 키는 여러 레코드에 맵핑 될 수 있습니다. &lt;code&gt;bag&lt;/code&gt; 유형 테이블의 모든 레코드 는 고유하며 키만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">새 모듈이 도입되면 다음 지침이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">더티 작업 중에 노드가 중단되면 테이블로드 메커니즘을 통해 모든 복제본에 대해 업데이트가 수행되거나 전혀 수행되지 않습니다. 비동기 더티 업데이트와 동기 더티 업데이트는 모두 경량 트랜잭션과 동일한 복구 원칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">노드가 다운되면 해당 노드에 대한 모든 연결이 제거됩니다. &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; 호출 하면 노드가 강제로 연결 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">분산 응용 프로그램이 실행중인 노드보다 &lt;code&gt;distributed&lt;/code&gt; 에 따라 우선 순위가 높은 노드가 시작되면 응용 프로그램은 새 노드에서 다시 시작되고 이전 노드에서 중지됩니다. 이것을 &lt;strong&gt;인계&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">옵션이 &lt;code&gt;extended&lt;/code&gt; 옵션으로 패턴을 컴파일 하면 (문자 클래스 이외의) 패턴의 공백과 문자 클래스 외부의 #과 다음 줄 바꾸기 사이의 문자는 무시됩니다. 이스케이프 백 슬래시는 패턴의 일부로 공백 또는 # 문자를 포함하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">패턴이. * 또는. {0,}으로 시작하고 &lt;code&gt;dotall&lt;/code&gt; 옵션 (Perl 옵션 &lt;code&gt;/s&lt;/code&gt; 와 동일 )이 설정되어 점이 개행과 일치하도록 허용하면 패턴이 암시 적으로 고정됩니다. 다음 문자가 모든 문자 위치에 대해 시도되기 때문입니다. 제목 문자열에. 따라서 첫 번째 이후의 모든 위치에서 전체 경기를 재시도 할 필요가 없습니다. PCRE는 일반적으로 \ A가 앞에 오는 것처럼 이러한 패턴을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">패턴이 &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; 로 시작하면 컴파일시 옵션 &lt;code&gt;no_start_optimize&lt;/code&gt; 를 설정하는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">영구 응용 프로그램이 종료되면 다른 모든 응용 프로그램과 전체 Erlang 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">영구 응용 프로그램이 종료되면 다른 모든 응용 프로그램 및 런타임 시스템도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">실행 큐에 포트를 넣거나 제거하면 &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">하나 이상의 캡처 하위 패턴을 포함하는 포지티브 어설 션이 성공하지만 나중에 패턴과 일치하지 않으면이 어설 션을 역 추적 할 수 있으며, 더 높은 번호의 캡처가 설정되어 있지 않은 경우에만 어설 션 내의 캡처가 재설정됩니다. 불행히도 이것은 현재 구현의 근본적인 한계이며 PCRE1은 현재 유지 보수 전용 상태이므로 변경되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">추가 압축 해제에 사전 설정 사전이 필요한 경우이 함수는 &lt;code&gt;need_dictionary&lt;/code&gt; 튜플을 반환합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">프로세스가 시드를 먼저 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 을 호출 하면 &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; 이 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">프로세스가 시드를 먼저 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; 을 호출하면 기본 알고리즘을 사용하여 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; 이 자동으로 호출되고 일정하지 않은 시드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">드라이버가로드 된 프로세스가 죽으면 언로드가 수행되는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트로 전송하여 시스템의 프로세스가 일시 중단되면 &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;SusPid&lt;/code&gt; 는 &lt;code&gt;Port&lt;/code&gt; 로 보낼 때 일시 중지 된 pid입니다 .</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트가 노드 간 통신을 처리 한 원격 노드의 프로세스로 전송하여 시스템의 프로세스가 일시 중단되면 &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;SusPid&lt;/code&gt; 는 노드 간 통신 포트 &lt;code&gt;Port&lt;/code&gt; 를 통해 보낼 때 일시 중단 된 pid입니다 .</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">프로세스가 실행 큐에 넣거나 제거되면 &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 . 선점 된 후 실행 큐에 다시 삽입 된 실행 프로세스는이 메시지를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">시스템의 프로세스 또는 포트가 최소 &lt;code&gt;Time&lt;/code&gt; 벽시계 밀리 초 동안 중단없이 실행 되면 &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;PidOrPort&lt;/code&gt; 는 실행중인 프로세스 또는 포트입니다. &lt;code&gt;Info&lt;/code&gt; 는 이벤트를 설명하는 2 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">프로세스가 단순히 바이너리를 유지하는 경우 ( &quot;루프 데이터&quot;또는 프로세스 사전에) 가비지 수집기는 결국 바이너리를 축소 할 수 있습니다. 이러한 바이너리가 하나만 유지되면 축소되지 않습니다. 프로세스가 나중에 축소 된 이진에 추가하는 경우 이진 개체는 데이터가 추가 될 위치를 위해 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">잠금을 보유한 프로세스가 종료되거나 노드가 작동 중지되면 프로세스가 보유한 잠금이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">등록 된 이름을 가진 프로세스가 종료되거나 노드가 작동 중지되면 모든 노드에서 이름이 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">예를 들어 &lt;code&gt;init_per_suite/1&lt;/code&gt; 의 실행 중에 프로세스 &lt;code&gt;P&lt;/code&gt; 가 생성 되면 &lt;code&gt;init_per_suite&lt;/code&gt; 프로세스 의 그룹 리더를 상속합니다 . 이 그룹 리더는 앞에서 언급 한 중앙 I / O 서버 프로세스입니다. 나중에 &lt;strong&gt;병렬 테스트 케이스 실행&lt;/strong&gt; 중 일부 이벤트가 &lt;code&gt;P&lt;/code&gt; 를 처리 하여 &lt;code&gt;io:format/1/2&lt;/code&gt; 를 호출하면 해당 그룹 호출이 리턴되지 않으며 (그룹 리더가 응답하지 않는 상태이므로) &lt;code&gt;P&lt;/code&gt; 가 정지됩니다. .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">대소 문자가 일치하지 않을 때 문자를 포함하는 범위를 사용하면 두 경우 모두 문자와 일치합니다. 예를 들어, [Wc]는 [] [\\ ^ _`wxyzabc]와 동일하며 대소 문자를 구분하지 않습니다. 비 UTF 모드에서 프랑스어 로케일의 문자표를 사용중인 경우 두 경우 모두 [\ xc8- \ xcb]가 강조된 E 문자와 일치합니다. UTF 모드에서 PCRE는 유니 코드 속성 지원으로 컴파일 된 경우에만 255보다 큰 값을 가진 문자에 대한 대소 문자 개념을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">수신 된 메시지가 여러 트랜잭션 요청이 포함되어있는 경우,이 옵션은 요청이 동일한 프로세스 (순차적으로 처리해야하는지 여부를 나타내는 &lt;code&gt;false&lt;/code&gt; ) 또는 각 요청이 자체 프로세스에 의해 처리 할 필요가있는 경우 ( &lt;code&gt;true&lt;/code&gt; 즉, 별도의 프로세스는 각 요청에 대해 만들어지는) .</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">레코드가 노드 &lt;code&gt;N1&lt;/code&gt; 에 멈춰 있고 노드 &lt;code&gt;N2&lt;/code&gt; 의 레코드에 대해 고정 잠금을 설정하려고 하면 레코드가 해제되어 있어야합니다. 이 작업은 비용이 많이 들고 성능이 저하됩니다. &lt;code&gt;N2&lt;/code&gt; 에서 &lt;code&gt;s_write/1&lt;/code&gt; 요청 을 발행하면 고정 해제가 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">레코드가 여러 모듈에서 사용되는 경우 레코드 정의를 포함 파일에 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">복구 가능한 오류가 발생하면 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴 하고 원래 응용 프로그램 스펙이 복원됩니다. 복구 할 수없는 오류가 발생하면 시스템이 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">일반 코어 덤프가 원하는 경우,하자 &lt;code&gt;heart&lt;/code&gt; 환경 변수 사용 중단에 킬 (kill) 신호를 설정하여 노하우를 &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; 를 . 설정되지 않거나 &lt;code&gt;SIGABRT&lt;/code&gt; 로 설정되지 않은 경우 기본 동작은 &lt;code&gt;SIGKILL&lt;/code&gt; 을 사용하는 종료 신호입니다 .</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;Name-Vsn&lt;/code&gt; &lt;code&gt;ebin&lt;/code&gt; 이라는 일반 디렉토리 가 ebin 서브 디렉토리 가있는 코드 경로에 존재 하면이 디렉토리의 경로가 리턴됩니다 ( &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 아님).</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">요청에 대한 응답이 제 시간에 수신되지 않으면 megaco 스택은 해당 테이블에서 요청에 대한 모든 정보를 제거합니다. 이 작업이 완료된 후 회신이 도착하면 앱에서이 메시지를 보낼 위치를 알 수 없습니다. 메시지는 로컬 노드 (링크가있는 노드)에서이 기능을 호출하여 &quot;사용자&quot;에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">행이 생성되면 항상 내부 열을 &lt;code&gt;&quot;internal&quot;&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 올바른 논리 프로세서 ID를 항상 확인할 수있는 것은 아니기 때문에 자동 무시됩니다. 오류가보고되면 오류 이벤트가 기록됩니다. 스케줄러가 요청한대로 바인드되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 올바른 논리 프로세서 ID를 항상 확인할 수있는 것은 아니기 때문에 자동 무시됩니다. 오류가보고되면 &lt;code&gt;error_logger&lt;/code&gt; 에보고됩니다 . 스케줄러가 요청한대로 바인드되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 절전 모드 또는 해제 상태가되면 &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">스케줄러 스레드가 나노초마다 새로운 참조를 생성하면 584 년이 지난 후에 참조가 가장 빨리 재사용됩니다. 즉, 가까운 미래에 그것들은 충분히 독특합니다.</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">스크립트가 발견되면 가장 먼저 발생하는 것은 응용 프로그램 사양이 릴리스 버전 &lt;code&gt;Vsn&lt;/code&gt; 에 속하는 &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;sys.config&lt;/code&gt; 에 따라 업데이트되는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">셔플 된 테스트 케이스 그룹이 반복되면 시드가 회전간에 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">기능 모듈을 간단하게 확장 한 경우 새 버전의 모듈을 시스템에로드하고 이전 버전을 제거하면 충분합니다. 이것을 &lt;strong&gt;간단한 코드 교체&lt;/strong&gt; 라고 &lt;strong&gt;하며&lt;/strong&gt; 이를 위해 다음 명령어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 를 사용 하지 않고 소켓이 연결된 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 를 사용 하지 않고 소켓이 연결된 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오. 경우 &lt;code&gt;{ip, Address}&lt;/code&gt; 및 / 또는 &lt;code&gt;{port, port_number()}&lt;/code&gt; 이 옵션과 결합되면, &lt;code&gt;fd&lt;/code&gt; 연결하기 전에 지정된 인터페이스와 포트에 바인딩됩니다. 이러한 옵션을 지정하지 않으면 &lt;code&gt;fd&lt;/code&gt; 가 이미 적절하게 바인딩되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">&lt;code&gt;gen_udp&lt;/code&gt; 를 사용 하지 않고 소켓이 열린 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오. &lt;code&gt;Port&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정되지 않은 경우 및 / 또는 &lt;code&gt;{ip, ip_address()}&lt;/code&gt; 가이 옵션과 결합되면 &lt;code&gt;fd&lt;/code&gt; 는 지정된 인터페이스 및 포트가 열린 후 바인딩됩니다. 이러한 옵션을 지정하지 않으면 &lt;code&gt;fd&lt;/code&gt; 가 이미 적절하게 바인딩되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">소켓이 이미 연결되어 있으면 &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; 을 사용하여 열린 파일 디스크립터를 &lt;code&gt;gen_udp&lt;/code&gt; 로 전달할 수 있습니다 . 프리 바운드 파일 디스크립터 번호를 나타내는 명령 행 인수를 사용하여 자동화 할 수 있습니다. 예를 들어, 포트가 69이고 파일 디스크립터 22가 &lt;code&gt;setuid_socket_wrap&lt;/code&gt; 에 의해 열린 경우, 명령 행 인수 &quot;-tftpd_69 22&quot;는 포트 69를 여는 대신 프리 바운드 파일 디스크립터 22를 사용하도록 트리거합니다. UDP 옵션 &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; 가 자동으로 추가됩니다. 명령 행 인수에 대해서는 &lt;code&gt;init:get_argument/&lt;/code&gt; 및 UDP 옵션에 대해서는 &lt;code&gt;gen_udp:open/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">&lt;code&gt;shuffle&lt;/code&gt; 속성이 있는 그룹에 하위 그룹이 지정된 경우 그룹 의 테스트 사례 (및 기타 하위 그룹)와 관련하여이 하위 그룹의 실행 순서는 임의적입니다. 그러나 하위 그룹의 테스트 사례 순서는 임의적이지 않습니다 (하위 그룹에 &lt;code&gt;shuffle&lt;/code&gt; 속성 이없는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">프로세스에서 포트에 대한 동기 호출이 수행되면 호출 런타임은 포트에 대한 호출 런타임 동안 실행할 수없는 것으로 간주됩니다. 호출 프로세스는 &lt;code&gt;inactive&lt;/code&gt; 로 통지 되고 나중에 포트 콜백이 리턴되면 &lt;code&gt;active&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 특정 키가있는 일부 레코드 만 삭제해야하는 경우가 있습니다. &lt;code&gt;delete_object/3&lt;/code&gt; 함수를 사용하여 수행 할 수 있습니다 . 이 기능에는 완전한 레코드가 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">테이블이 &lt;code&gt;set&lt;/code&gt; 유형 인 경우 각 키는 하나 또는 0 개의 레코드로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">임시 응용 프로그램이 종료되면보고되지만 다른 응용 프로그램은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">터미널 기호가 범주의 유일한 멤버이고 기호 이름이 범주 이름과 동일한 경우 토큰 형식은 &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">그룹 정의에 따라 그룹에 속하는 테스트 케이스가 그룹 스펙없이 실행되는 경우, 즉 (명령 행 사용)</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 사례가 실패하면이 기능은 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스를 건너 뛰면 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 다음에이 함수가 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">테스트 케이스가 &lt;code&gt;multiply_timetraps&lt;/code&gt; 에 의해 다중화되고 ( &lt;code&gt;scale_timetraps&lt;/code&gt; 가 활성화 된 경우 스케일 업될 수 있는 시간 동안) 일시 중단 해야하는 경우 , &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 (예 &lt;code&gt;timer:sleep/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">모듈의 세 번째 인스턴스가로드되면 코드 서버는 이전 코드를 제거 (퍼지)하고 그 안에있는 모든 프로세스가 종료됩니다. 그런 다음 세 번째 인스턴스는 '현재'가되고 이전의 현재 코드는 '이전'이됩니다.</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">모듈의 세 번째 인스턴스가로드되면 코드 서버는 이전 코드를 제거 (퍼지)하고 그 안에있는 모든 프로세스가 종료됩니다. 그런 다음 세 번째 인스턴스는 '현재'가되고 이전의 현재 코드는 '이전'이됩니다.</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">스레드가 이미 작동중인 경우 통화가 대기되고 순서대로 실행됩니다. 각 드라이버 인스턴스에 대해 동일한 스레드를 사용하면 호출이 순서대로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">스레드 풀이 사용 가능한 경우 스레드가 사용됩니다. 인수 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 풀의 스레드는 라운드 로빈 방식으로 사용 되며 &lt;code&gt;driver_async&lt;/code&gt; 에 대한 각 호출 은 풀의 다음 스레드를 사용합니다. 인수 &lt;code&gt;key&lt;/code&gt; 설정되면이 동작이 변경됩니다. 두 개의 동일한 &lt;code&gt;*key&lt;/code&gt; 값은 항상 동일한 스레드를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">추적 포트 ( &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 참조 )가 로컬 노드에서 실행중인 경우 추적 프로그램 프로세스로 원격 노드를 추적 할 수 없습니다. 오류 이유 &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; 가 리턴됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 기능 을 사용하여 원격 노드에서 추적 포트를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">추적 프로그램이 두 목록 모두에 지정된 경우 사용 목록의 추적 프로그램이 우선합니다. 추적 프로그램이 지정되지 않으면 일치 스펙을 실행하는 프로세스와 동일한 추적 프로그램 (메타 추적 프로그램이 아님)이 사용됩니다. 해당 프로세스에 추적 프로그램이 없으면 추적 플래그가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">트랜잭션에 비대칭 복제 된 테이블의 업데이트 또는 스키마 테이블의 업데이트가 포함 된 경우 헤비급 커밋 프로토콜이 사용됩니다. 이 프로토콜은 테이블 복제 방법에 관계없이 트랜잭션을 완료 할 수 있습니다. 헤비급 트랜잭션의 일반적인 용도는 복제본이 한 노드에서 다른 노드로 이동하는 경우입니다. 그런 다음 복제본이 완전히 이동했거나 그대로 남아 있는지 확인하십시오. 두 노드 모두에 복제본이 있거나 전혀 노드가없는 상황에서는 절대로 끝나지 마십시오. 커밋 프로토콜의 중간에 노드가 충돌하더라도 트랜잭션은 원 자성이어야합니다. 헤비급 커밋 프로토콜은 간단한 프로토콜보다 트랜잭션 조정자와 참여자간에 더 많은 메시지를 포함하며 시작시 복구 작업을 수행하여 종료 또는 커밋 작업을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">트랜잭션이 비정상적 으로 종료되면 &lt;code&gt;Mnesia&lt;/code&gt; 는 해당 트랜잭션이 보유한 잠금을 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">임시 애플리케이션이 비정상적으로 종료되면 다른 모든 애플리케이션과 전체 Erlang 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">임시 애플리케이션이 &lt;code&gt;Reason == normal&lt;/code&gt; 종료되면 보고되지만 다른 애플리케이션은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">일시적인 응용 프로그램이 reason &lt;code&gt;normal&lt;/code&gt; 로 종료되면 보고되지만 다른 응용 프로그램은 종료되지 않습니다. 임시 애플리케이션이 비정상적으로 종료 된 경우 (즉, &lt;code&gt;normal&lt;/code&gt; 이외의 다른 이유로) 다른 모든 애플리케이션 및 런타임 시스템도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">나노초마다 고유 한 정수가 생성되면 584 년이 지난 후에 고유 한 정수가 가장 빨리 재사용됩니다. 즉, 가까운 미래에 그것들은 충분히 독특합니다.</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">사용자가 테스트 스위트의 서브 세트 만 실행하려는 경우 한 테스트 케이스가 다른 테스트 케이스에 성공적으로 의존 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">오브젝트 값이 &lt;code&gt;send_notification&lt;/code&gt; 함수에 제공되지 않으면 서브 에이전트는 get-operation을 수행 하여 오브젝트 를 검색합니다. 이 서브 에이전트에서 오브젝트가 구현되지 않은 경우, 상위 에이전트는 get-operation을 수행하여 오브젝트를 검색하려고 시도합니다. 이 에이전트에서 오브젝트가 구현되지 않은 경우 오브젝트를 상위로 전달하는 식입니다. 결국 마스터 에이전트에 도달하고이 시점에서 알 수없는 모든 개체 값을 해결해야합니다. 마스터 에이전트조차 알 수없는 일부 개체는 오류로 간주되며 오류 보고서 모듈의 &lt;code&gt;user_err/2&lt;/code&gt; 에 대한 호출과 함께보고됩니다 . 이 경우 알림이 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">알림의 변수가 테이블 요소 인 경우 요소의 &lt;code&gt;RowIndex&lt;/code&gt; 를 &lt;code&gt;Varbinds&lt;/code&gt; 목록에 제공해야 합니다. 이 경우 알림에 전송 된 객체 식별자는이 요소를 식별하는 객체 식별자입니다. 이 객체 식별자는 나중에 가져 오기 작업에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">긍정적 인 주장에 이름이있는 동사가 발견되면 마지막으로 발견 된 경우 이름이 기록되고 다시 전달됩니다. 부정적 주장이나 긍정적 인 주장에 실패하는 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">단어가 SMIv1 또는 SMIv2의 키워드 인 경우, 컴파일러의 키워드입니다 (SMIv1에서만 벗어남).</target>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">모든 것이 잘 진행되면 &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; 이 리턴됩니다. 여기서 &lt;code&gt;ResultOfFun&lt;/code&gt; 은 &lt;code&gt;Fun&lt;/code&gt; 의 마지막 표현식 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">패턴의 모든 대안이 \ G로 시작하면 표현식이 시작 일치 위치에 고정되고 &quot;anchored&quot;플래그가 컴파일 된 정규식에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">는 IF &lt;code&gt;.erlang&lt;/code&gt; 파일이 발견, 유효한 얼랑 표현식을 포함하는 것으로 가정한다. 이러한 표현식은 마치 쉘에 입력 된 것처럼 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 할당은 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">I / O 장치가 2 진 모드로 설정된 경우 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 함수 는 목록 대신 2 진을 리턴 할 수 있습니다. 바이너리는 Erlang / OTP R13A에서와 같이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">는 I / O 서버가 인식하지 못하는 요청이 발생하는 경우이다 (그의 &lt;code&gt;io_request&lt;/code&gt; 튜플이 예상되는 형식을 가지고 있지만, &lt;code&gt;Request&lt;/code&gt; 의 I / O 서버는 오류 튜플있는 유효한 응답을 보내는 것입니다 알 수없는) :</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">MIB 객체 인스턴스가 정확히 하나의 하위 트리에 속하는 경우 해당 항목의 유형에 따라 인스턴스가 관련 MIB보기에 포함되거나 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">MIB 오브젝트 인스턴스가 둘 이상의 서브 트리에 속하는 경우, 가장 많은 수의 서브 식별자를 포함하고 사 전적으로 가장 큰 서브 트리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">MIB 객체 인스턴스가 관련 하위 트리에 속하지 않으면 인스턴스가 MIB보기에 없습니다.</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">algs_list ()에서 alg_entry ()가 누락되면 해당 항목에 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">알고리즘 이름이 목록에서 두 번 이상 나타나면 동작이 정의되지 않은 것입니다. 속성 목록의 태그도 최대 한 번 발생한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">요청 처리에서 작성된 애플리케이션 콜백이 실패하면 (pick_peer, 준비 _ 요청, 준비 _ 전송, handle_answer 또는 handle_error) 요청을 보내려는 시도가 있는지 여부에 따라 &lt;code&gt;{error,encode}&lt;/code&gt; 또는 &lt;code&gt;{error,failure}&lt;/code&gt; 가 리턴됩니다. 수송을 통해.</target>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">산술 표현식, 부울 표현식, 단락 표현식 또는 가드 BIF 호출이 실패하면 (잘못된 인수로 인해) 전체 가드가 실패합니다. 가드가 가드 시퀀스의 일부인 경우 시퀀스의 다음 가드 (즉, 다음 세미콜론 다음의 가드)가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">로그 파일을 처음으로 열려는 시도가 실패하면 EXIT 메시지 &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; 과 함께 디스크 로그 프로세스가 종료됩니다 . 이 함수는 다른 모든 오류에 대해 &lt;code&gt;{error, Reason}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">로그를 다시 열거 나 자르려는 시도가 실패하면 ( &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; 참조 ) 디스크 로그 프로세스가 즉시 종료됩니다. 프로세스가 종료되기 전에 소유자에 대한 링크 및 차단 프로세스 ( &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; 참조 )가 제거됩니다. 결과적으로 링크는 한 방향으로 만 작동합니다. 다른 프로세스가 동시에 로그를 자르거나 다시 여는 경우 디스크 로그를 사용하는 프로세스는 오류 메시지 &lt;code&gt;no_such_log&lt;/code&gt; 를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">에지가 v에서 &lt;strong id=&quot;out_neighbour&quot;&gt;나오고&lt;/strong&gt; w에 입사하면 w 는 v 의 &lt;strong id=&quot;out_neighbour&quot;&gt;외부 이웃&lt;/strong&gt; 이라고하며 v는 w의 내부 &lt;strong id=&quot;in_neighbour&quot;&gt;이웃&lt;/strong&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">직원이 1997 년 이후에 시작했지만 2001 년 이전에 &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">직원이 1997 년 이전에 시작한 경우 튜플 &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">에뮬레이터를 다시 시작해야하고 업그레이드 지침이 필요하지 않은 경우, 다시 시작 자체가 업그레이드 된 응용 프로그램이 새 버전을 실행하기에 충분하면 간단한 &lt;code&gt;relup&lt;/code&gt; 파일을 수동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">재전송 중 인코딩 오류가 발생하면 요청 프로세스가 실패하고 &lt;code&gt;{error,failure}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">전체 패킷이 &lt;code&gt;Bin&lt;/code&gt; 에 포함되어 있으면 나머지 바이너리와 함께 &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">오류 코드가 리턴되면 포트가 시작되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 오류 가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견되면의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용하여 오류가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 기능을 사용하여보고되며, &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용 하여 오류 가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류, 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용하여보고되며 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">오류가 리턴되면 일치 스펙 컴파일 오류가 원인 일 수 있습니다. 이러한 오류는 문자열이 컴파일 오류에 대한 텍스트 설명 인 튜플 &lt;code&gt;{error, string()}&lt;/code&gt; 의 목록으로 표시됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">오류가 리턴되면 추적 프로그램 서버가 이미 실행 중이 거나 ( &lt;code&gt;{error,already_started}&lt;/code&gt; ) &lt;code&gt;HandlerFun&lt;/code&gt; 에서 예외가 발생 했기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 호출 된 후이 함수가 호출됩니다. 경우 &lt;code&gt;set&lt;/code&gt; 이 객체에 대해 호출, &lt;code&gt;undo&lt;/code&gt; 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">설치 중 오류가 발생하면 시스템은 이전 버전의 릴리스를 사용하여 재부팅됩니다. 설치에 성공하면 새 버전의 릴리스를 사용하여 시스템이 나중에 작동하지만 문제가 발생하여 시스템이 재부팅되면 이전 버전을 다시 사용하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">소켓에서 오류가 발생하면 다음 메시지가 전달됩니다 ( &lt;code&gt;{active, false}&lt;/code&gt; 가 소켓의 옵션 목록에 지정되어 있지 않은 경우 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 패킷이 검색되는 경우 제외).</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈로 열린 파일에 액세스 할 때 오류가 발생하면 파일 처리 프로세스가 종료됩니다. 프로세스가 나중에 액세스하려고하면 사용 불능 파일 프로세스가 중단 될 수 있습니다. 향후 릴리스에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">오류가 발생 하면 &lt;code&gt;is_set_ok&lt;/code&gt; 함수 다음에 함수 &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 가 호출 됩니다. 경우 &lt;code&gt;set&lt;/code&gt; 이 객체에 대해 호출, &lt;code&gt;undo&lt;/code&gt; 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하는 경우 중 하나에 &lt;code&gt;is_set_ok&lt;/code&gt; 단계, 또는에서 &lt;code&gt;set&lt;/code&gt; 상, 호출 된 모든 기능 &lt;code&gt;is_set_ok&lt;/code&gt; 하지만 &lt;code&gt;set&lt;/code&gt; , 호출되어 &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">오류가 발생하면 기능에 의해 시작된 응용 프로그램이 중지되어 실행중인 응용 프로그램 세트를 초기 상태로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하면 오류 튜플 &lt;code&gt;{error, Reason}&lt;/code&gt; 과 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">오류가 발생하면 오류 튜플 &lt;code&gt;{error, Reason}&lt;/code&gt; 과 함께 프로세스가 종료됩니다 . 오류 튜플은 키와 구별 할 수 없으므로 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">오류가 발생하면이 경우 스택 추적이 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">오류가 발생하면 출력이 없습니다. 예:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AfterBody&lt;/code&gt; 자체를 평가하는 동안 예외가 발생하면 포착되지 않습니다. 따라서 &lt;code&gt;Exprs&lt;/code&gt; , &lt;code&gt;Body&lt;/code&gt; 또는 &lt;code&gt;ExceptionBody&lt;/code&gt; 에서 예외 후에 &lt;code&gt;AfterBody&lt;/code&gt; 가 평가 되면 해당 예외는 손실되고 &lt;code&gt;AfterBody&lt;/code&gt; 의 예외에 의해 마스크됩니다 .</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">&lt;code&gt;ExceptionBody&lt;/code&gt; 평가 중에 예외가 발생하면 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;Exprs&lt;/code&gt; 를 평가하는 동안 예외가 발생 하지만 실제 가드 시퀀스 가있는 올바른 &lt;code&gt;Class&lt;/code&gt; 의 일치하는 &lt;code&gt;ExceptionPattern&lt;/code&gt; 이 없으면 &lt;code&gt;Exprs&lt;/code&gt; 가 &lt;code&gt;try&lt;/code&gt; 표현식 으로 묶이지 않은 것처럼 예외가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">위와 같이 종료 신호가 수신되면 튜플 &lt;code&gt;{From,Name}&lt;/code&gt; 이 &lt;code&gt;server_logoff&lt;/code&gt; 함수를 사용하여 서버 &lt;code&gt;User_List&lt;/code&gt; 에서 삭제됩니다 . 서버가 실행되는 노드가 작동 중지되면 종료 신호 (시스템에 의해 자동으로 생성됨)가 모든 클라이언트 프로세스 ( &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; )로 전송되어 모든 클라이언트 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">MIB를 컴파일 할 때 변수 &lt;code&gt;myVar&lt;/code&gt; 에 대한 연관 파일의 인스 트루먼 테이션 함수에 이름이없는 경우 컴파일러는 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">정수 시간 종료 값이 제공되면 시간 &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 내에 요청 또는 메시지가 수신되지 않으면 시간 종료가 발생합니다 . 시간 &lt;code&gt;timeout&lt;/code&gt; 는 atom timeout으로 표시되며 이는 &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; 콜백 함수에 의해 처리됩니다 . 원자 &lt;code&gt;infinity&lt;/code&gt; 는 무한정 대기하는 데 사용할 수 있으며 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">소유자가 로그를 다시 소유자로 열려고 시도하면 리턴 값 &lt;code&gt;{ok, Log}&lt;/code&gt; 로 승인 되지만 디스크 로그의 상태는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">인식 할 수없는 유형 옵션 &lt;code&gt;T&lt;/code&gt; 가 지정되었거나 &lt;code&gt;Type&lt;/code&gt; 이 올바른 목록이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">지원되지 않는 알고리즘이 &lt;code&gt;modify_algs_list()&lt;/code&gt; 에 있으면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">업그레이드에 OTP R15 이전의 에뮬레이터에서 OTP R15 이상으로의 변경이 포함 된 경우, &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; 경고 가 발행됩니다. 이에 대한 자세한 내용은 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;Design Principles&lt;/code&gt; 을 참조하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">메시지를 압축하는 경우 및 방법 예는 &lt;code&gt;none&lt;/code&gt; , 즉 compression 및 &lt;code&gt;zlib&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">유니 코드 변환 수정자가 형식 문자열 ( &lt;code&gt;~ts&lt;/code&gt; 또는 &lt;code&gt;~tc&lt;/code&gt; )에 사용되는 경우에만 결과 목록에 ISO Latin-1 문자 범위를 벗어난 문자 (숫자&amp;gt; 255)가 포함될 수 있습니다. 그렇다면 결과는 여전히 일반적인 Erlang &lt;code&gt;string()&lt;/code&gt; 이며 유니 코드 데이터가 허용되는 모든 컨텍스트에서 잘 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 시작하고 조작 하려면 정의와 데이터를 일반 텍스트 파일에 작성하는 것이 더 쉬운 경우가 많습니다. 처음에는 테이블과 데이터가 없거나 필요한 테이블이 없습니다. 프로토 타이핑의 초기 단계에서는 모든 데이터를 하나의 파일에 기록하고 해당 파일을 처리하며 파일의 데이터를 데이터베이스에 삽입하는 것이 좋습니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 텍스트 파일에서 읽은 데이터로 초기화 할 수 있습니다. 다음 두 가지 기능을 사용하여 텍스트 파일을 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Mnesia 데이터베이스에 영속 변수를 저장하기 위해 이러한 변수 중 하나를 다시 구현해야하는 경우 변수를 자체적으로 구현해야합니다. 해당 MIB는 기본 MIB 대신 컴파일되고로드됩니다. 새로 컴파일 된 MIB는 원래 MIB와 이름이 동일해야하며 (예 : STANDARD-MIB 또는 SNMPv2-MIB) SNMP 구성 디렉토리에 있어야합니다 ( &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 이 디렉토리 이름이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">시스템의 Erlang 프로세스 &lt;code&gt;Pid&lt;/code&gt; 가 일정량 이상의 총 시스템 메모리를 할당 한 경우, 알람 &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">스크립트가 HTTP 헤더 필드를 추가 한 경우, 그것들은 &lt;code&gt;deliver/2&lt;/code&gt; 를 처음 호출해야하고 호출의 데이터는 문자열이어야합니다. 헤더가 완료된 후의 호출에는 복사 오버 헤드를 줄이기 위해 이진 데이터가 포함될 수 있습니다. &lt;code&gt;SessionID&lt;/code&gt; 의 데이터 유형에 대해서는 아무 것도 가정하지 마십시오 . &lt;code&gt;SessionID&lt;/code&gt; 는 구현 한 ESI 콜백 함수에 대한 입력으로 제공된 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 기능이 실패하거나 오류 튜플 또는 잘못된 값을 리턴하는 경우, 수퍼바이저는 먼저 이유 &lt;code&gt;shutdown&lt;/code&gt; 와 함께 이미 시작된 모든 하위 프로세스를 종료 한 후 자체 종료 하고 &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘에서 &quot;필수 구성 데이터&quot;를 사용하는 기능 (예 : Telnet 또는 FTP)을 호출하려면 먼저 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 와 함께 구성 데이터가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;필수 구성 데이터&quot;를 사용하는 기능 (예 : 기능 &lt;code&gt;ct_telnet&lt;/code&gt; 또는 &lt;code&gt;ct_ftp&lt;/code&gt; )을 Erlang 쉘에서 호출하려면 먼저 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 의 구성 데이터가 필요합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;require&lt;/code&gt; 문과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">인수 중 하나라도 유효하지 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">테이블이 없거나 Dets 테이블이 열리지 않으면 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">&lt;code&gt;+sbt&lt;/code&gt; 가 전달 될 때 이러한 오류가 발생하면 런타임 시스템은 오류 메시지를 인쇄하고 시작을 거부합니다. &lt;code&gt;+stbt&lt;/code&gt; 가 전달 될 때 이러한 오류가 발생하면 런타임 시스템은 자동으로 오류를 무시하고 바인딩되지 않은 스케줄러를 사용하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">대체 바이너리의 &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; 크기에 지정된 위치가 있으면 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">&lt;code&gt;-daemon&lt;/code&gt; 인수를 지정하지 않으면 &lt;code&gt;epmd&lt;/code&gt; 는 시작된 쉘의 제어 터미널과 함께 일반 프로그램으로 실행됩니다. 일반적으로 데몬으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">&lt;code&gt;Archive&lt;/code&gt; 인수 가 2 진으로 지정된 경우 2 진의 컨텐츠는 zip 아카이브로 간주되고 그렇지 않으면 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">인수 &lt;code&gt;MFA&lt;/code&gt; 가 원자 &lt;code&gt;on_load&lt;/code&gt; 인 경우 일치 스펙 및 플래그 목록은 새로로드 된 모든 모듈에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">인수 &lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;{binary,Binary}&lt;/code&gt; 로 지정 되면 2 진의 컨텐츠는 tar 아카이브 인 것으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;{file,Fd}&lt;/code&gt; 로 지정 되면 &lt;code&gt;Fd&lt;/code&gt; 는 함수 &lt;code&gt;file:open/2&lt;/code&gt; 에서 리턴 된 파일 디스크립터 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">인수 &lt;code&gt;type&lt;/code&gt; 을 지정하면이 유형의로드 된 모든 보고서가 표시됩니다. 정수 인수가 지정되면이 참조 번호가있는 보고서가 표시됩니다. 인수를 지정하지 않으면 모든 보고서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">원자 &lt;code&gt;start&lt;/code&gt; 이 연속으로 지정된 경우 용어를 읽을 디스크 로그가 선택됩니다. 현재 노드의 로컬 또는 분산 디스크 로그는 다른 노드의 개별 분산 로그보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">이전 예에서 원자 그룹화를 사용하는 경우, 매처는 &quot;foo&quot;와 처음 일치하지 않으면 즉시 포기합니다. 이 표기법은 다음 예 와 같이 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 로 시작하는 일종의 특수 괄호입니다 .</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">테이블을 작성할 때 속성 &lt;code&gt;{local_content, true}&lt;/code&gt; 가 지정되면 테이블은 존재하도록 테이블을 지정하는 노드에 상주하지만 테이블에 대한 쓰기 조작은 로컬 사본에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">인증 또는 암호화가 사용되는 경우 (SNMPv3 만 해당) &lt;code&gt;crypto&lt;/code&gt; 응용 프로그램을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">인증 또는 암호화가 사용되는 경우 (SNMPv3 만 해당) &lt;code&gt;crypto&lt;/code&gt; 응용 프로그램을 시작하십시오 . 이 단계를 잊어 버린 경우 에이전트는 시작되지 않지만 &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">자동 건너 뛴 테스트 사례가 종료 상태에 영향을 미치지 않는 경우. 기본 동작은 시작 플래그를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">자동 커밋 모드가 설정되어 있으면 각 쿼리는 개별 트랜잭션으로 간주되며 실행 후 자동 커밋됩니다. 둘 이상의 조회가 동일한 트랜잭션의 일부가되도록하려면 자동 확약 모드를 해제해야합니다. 그런 다음 commit / 3을 명시 적으로 호출하여 트랜잭션을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">덤프에서 사용 가능한 경우 이는 원자 테이블의 총 원자 수입니다. 원자 테이블의 크기를 사용할 수없는 경우 덤프에 표시되는 원자 수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">더 이상 사용되지 않는 바이너리는 가능한 빨리 버려야합니다. ( &lt;code&gt;Number&lt;/code&gt; 를 0으로 설정하십시오 .)</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">스케줄러 바인딩이 지원되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 와 &lt;code&gt;Destination&lt;/code&gt; 이 모두 파일 이름을 참조하는 경우 파일을 복사하기 위해 &lt;code&gt;[read, binary]&lt;/code&gt; 및 &lt;code&gt;[write, binary]&lt;/code&gt; 각각 모드 목록 앞에 추가되어 열립니다 .</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">이미 실행중인 동안 통화 카운트 추적이 시작되면 카운트는 0에서 다시 시작됩니다. 실행 카운터를 일시 중지하려면 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 사용 하십시오 . 일시 정지 및 실행 카운터는 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 0부터 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">&lt;code&gt;analyse/0..2&lt;/code&gt; 가 실행 되는 동안 콜 카운터가 여전히 실행 중이면 결과가 일치하지 않을 수 있습니다. 이는 &lt;code&gt;analyse/0..2&lt;/code&gt; 실행하는 프로세스 가 예약되어 다른 프로세스가 분석중인 카운터를 증가시킬 수 있는 경우에 발생합니다. 분석하기 전에 &lt;code&gt;pause()&lt;/code&gt; 를 호출 하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">통화 시간 추적이 이미 실행되는 동안 시작되면 카운트와 시간이 0에서 다시 시작됩니다. 실행 카운터를 일시 중지하려면 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 사용 하십시오 . 일시 정지 및 실행 카운터는 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 0부터 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">여러 번 호출하면 마지막 주석 만 인쇄됩니다. 테스트 케이스 리턴 값 &lt;code&gt;{comment,Comment}&lt;/code&gt; 는이 함수로 설정된 문자열을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">사용자 애플리케이션에 알려지지 않은 확장자로 호출 된 경우, 리턴 값 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;NElements&lt;/code&gt; 및 &lt;code&gt;DepthFun&lt;/code&gt; 을 포함하는 인수로 &lt;code&gt;FormatFun&lt;/code&gt; 을 호출 하는 데 실패하면 &lt;code&gt;NElements&lt;/code&gt; 및 &lt;code&gt;DepthFun&lt;/code&gt; 을 제외한 인수 ( &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; 또는 &lt;code&gt;all&lt;/code&gt; )를 사용하여 &lt;code&gt;FormatFun&lt;/code&gt; 이 다시 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">역 참조시 대 / 소문자 일치가 적용되는 경우 문자 대 / 소문자가 적합합니다. 예를 들어, 원래 캡처 서브 패턴이 대소 문자없이 일치하더라도 다음은 &quot;rah rah&quot;및 &quot;RAH RAH&quot;와 일치하지만 &quot;RAH rah&quot;와는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">드라이버 콜백을 호출하는 스레드가 아닌 다른 스레드에서 특정 포트 특정 데이터에 액세스해야하는 경우 포트 데이터 잠금을 사용하여 데이터 작업을 동기화 할 수 있습니다. 현재 에뮬레이터가 포트 데이터 잠금과 연결하는 유일한 포트 별 데이터는 드라이버 큐입니다.</target>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">하나 이상의 스위트에 대해 컴파일이 실패하면 컴파일 오류가 tty에 인쇄되고 운영자는 누락 된 스위트없이 테스트 실행을 진행해야하는지 아니면 중단되어야하는지 묻습니다. 운영자가 진행하기로 선택하면 스위트가 누락 된 테스트가 HTML 로그에 표시됩니다. 경우 &lt;code&gt;Common Test&lt;/code&gt; (경우 컴파일 실패 후 사용자에게 메시지를 표시 할 수없는 &lt;code&gt;Common Test&lt;/code&gt; 제어하지 않습니다 &lt;code&gt;stdin&lt;/code&gt; ), 테스트 실행이 누락 된 스위트 룸없이 자동으로 진행된다. 그러나이 동작은 &lt;code&gt;ct_run&lt;/code&gt; 플래그 &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 옵션 &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; 로 수정할 수 있습니다. &lt;code&gt;abort_if_missing_suites&lt;/code&gt; 인 경우로 설정되어 &lt;code&gt;true&lt;/code&gt; , 테스트 실행은 일부 스위트 룸 컴파일에 실패하면 즉시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;--enable-static-nifs&lt;/code&gt; 를 통해 정적 포함을 위해 NIF를 컴파일하는 경우 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 선언 전에 &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;--enable-static-drivers&lt;/code&gt; 를 통해 정적 포함을 위해 드라이버를 컴파일하는 경우 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 선언 전에 &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">구성 요소 (키-값 튜플)를 값 대신 결과로 리턴하려면 option &lt;code&gt;element&lt;/code&gt; 를 사용하십시오 . 리턴 된 요소는 &lt;code&gt;{Required,Value}&lt;/code&gt; 양식 입니다.</target>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">교차 커버 분석이 수행되고 현재 테스트에 대해 누적 된 커버리지 결과가있는 경우 &quot;모든 테스트에서 수집 된 표지 데이터&quot;링크가이 결과로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">지정된 인코딩으로 변환 할 수없는 형식으로 데이터를 &lt;code&gt;io_device()&lt;/code&gt; 로 보내 거나 데이터의 문자 범위를 처리 할 수없는 형식으로 데이터를 반환하는 함수에서 데이터를 읽으면 오류가 발생하고 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 열린 pty에 대한 입력 및 출력 흐름 제어를 비활성화합니다 . Ctrl-D 대신 분리하여 Ctrl-S를 사용하여 실수로 흐름 제어를 차단하여 빔 프로세스 전체를 차단할 수 있으며 감독자로서 심장을 움직이는 경우에도 유용합니다. 터미널에 로그 메시지를 쓸 때 심장 프로세스가 차단되어 심장 프로세스가 작업을 수행 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">빈 일치 항목과 존재하지 않는 하위 패턴을 구별해야하는 경우 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 사용하고 Erlang 코드에서 최종 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">비어 있으면 스케줄러가 작업을 수행 한 것입니다. 비어 있지 않으면 스케줄러가 일부 절전 상태이거나 일시 중단 된 것입니다. 이 항목은 SMP 가능 에뮬레이터에만 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">사용 가능하고 사용 가능한 경우 프로세스 SASL 로그 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">활성화 된 경우 각 스케줄러에 신호가 전송되어 응답 성을 확인합니다. 시스템 점검은 하트 비트가 포트 프로그램으로 전송되기 전에 발생합니다. 스케줄러가 충분히 응답하지 않으면 심장 프로그램은 해당 하트 비트를 수신하지 않으므로 결국 노드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">모든 것이 성공하면 콜백 함수는 가능한 기본값 또는 내부 상태 값을 구성에 추가하고 조정 된 맵을 &lt;code&gt;{ok,Config2}&lt;/code&gt; 에 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">모든 것이 성공하면 콜백 함수는 &lt;code&gt;{ok,Config3}&lt;/code&gt; 에서 조정 가능한 구성을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">flag &lt;code&gt;-loader&lt;/code&gt; 를 생략하면 기본값은 &lt;code&gt;efile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">플래그 &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 또는 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 가 지정되면 첫 번째 튜플 요소는 대신 &lt;code&gt;trace_ts&lt;/code&gt; 이며 타임 스탬프는 메시지 튜플에서 마지막으로 추가 요소로 추가됩니다. 여러 타임 스탬프 플래그가 전달되면 &lt;code&gt;timestamp&lt;/code&gt; 는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 보다 우선하며, &lt;code&gt;monotonic_timestamp&lt;/code&gt; 보다 우선 합니다. 모든 타임 스탬프 플래그가 기억되므로 두 개가 전달되고 우선 순위가 가장 높은 것이 비활성화 된 경우 다른 하나가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">플래그 &lt;code&gt;-pa&lt;/code&gt; 또는 &lt;code&gt;-pz&lt;/code&gt; 가 &lt;code&gt;Common Test&lt;/code&gt; 그룹 옵션 (앞에 &lt;code&gt;-erl_args&lt;/code&gt; )에 지정된 경우 상대 디렉토리는 절대로 변환되고 &lt;code&gt;Common Test&lt;/code&gt; 의해 코드 경로에 다시 삽입됩니다 . 이는 &lt;code&gt;Common Test&lt;/code&gt; 가 테스트 실행 중 작업 디렉토리를 변경할 때 사용자 모듈을로드하는 데 문제가 발생하지 않도록하기위한 것 입니다. 그러나 &lt;code&gt;Common Test&lt;/code&gt; 는 명령 행에서 &lt;code&gt;-pz&lt;/code&gt; 다음에 &lt;code&gt;-erl_args&lt;/code&gt; 플래그 &lt;code&gt;-pa&lt;/code&gt; 및 -pz를 무시합니다 . 이러한 디렉토리는 코드 경로에 정상적으로 (즉, 지정된 형식으로) 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 megaco가 응답을 전달할 수없는 경우, &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; 아닌 한 콜백 함수 &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 통해 해당 이유가 사용자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">발견되면이 파일은 릴리스 패키지가 작성 될 때 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">기능의 경우 &lt;code&gt;start_link/3,4,5&lt;/code&gt; 이 호출되기 전에 사용되는 프로세스가 충돌 &lt;code&gt;init_ack/1,2&lt;/code&gt; , &lt;code&gt;{error, Reason}&lt;/code&gt; 호출 프로세스 트랩 종료하는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">함수 호출이 추적되면 추적 패턴 추가 단추를 클릭하여 &lt;strong&gt;추적 패턴을 추가&lt;/strong&gt; 해야합니다 . 모듈, 기능 및 일치 사양을 선택하십시오. 기능을 선택하지 않으면 모듈의 모든 기능이 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">주어진 경우 연결에 대한 최소 바이트 / 초 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">헤더 파일 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 이 포함되어 있지 않으면 fun이 변환되지 않으므로 &lt;strong&gt;런타임 오류가&lt;/strong&gt; 발생할 수 있습니다 (fun이 순수한 Erlang 컨텍스트에서 유효한지 여부에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">심장이 Erlang 런타임 시스템을 종료 &lt;strong&gt;하지&lt;/strong&gt; 않아야 하는 경우 환경 변수 &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; 를 사용하여이를 표시 할 수 있습니다 . 이는 예를 들어 특정 정리 시퀀스의 일부로 마음으로 실행되는 명령이이를 처리하는 경우 유용 할 수 있습니다. 설정하지 않거나 &lt;code&gt;TRUE&lt;/code&gt; 로 설정하지 않으면 기본 동작은 위에서 설명한대로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">대신 &lt;code&gt;m1&lt;/code&gt; 과 &lt;code&gt;ch3&lt;/code&gt; 이 동일한 응용 프로그램에 속하는 경우 &lt;code&gt;.appup&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">대신 &lt;code&gt;s2&lt;/code&gt; 의 커버 사양 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">대신 다음 패턴이 사용되면 &quot;센스와 책임&quot;및 다른 두 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">&lt;code&gt;end_per_testcase&lt;/code&gt; 를 실행하는 동안 성공한 테스트 케이스의 상태가 실패로 변경되는 것으로 &lt;code&gt;end_per_testcase&lt;/code&gt; 되면 end_per_testcase 는 튜플 &lt;code&gt;{fail,Reason}&lt;/code&gt; ( 이유는 테스트 케이스가 실패한 &lt;code&gt;Reason&lt;/code&gt; 설명 함) 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">원본 문서와 비슷한 들여 쓰기와 줄 바꿈을 얻는 것이 중요한 경우 적절한 위치에 공백과 줄 바꿈 값이있는 #xmlText {} 레코드를 추가해야합니다. DTD가 참조되는 원래 프롤로그를 유지해야 할 수도 있습니다. 그렇다면 RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; 를 &lt;code&gt;export_simple/3&lt;/code&gt; 에 전달할 수 있습니다 . 다음 예제 코드는 이전 예제의 변경 사항을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">이 코드를 사용 변경하는 동안 응용 프로그램이 비활성화되는 시간을 최소화하는 것이 중요 경우 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;atomic_load/1&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">종료 전에 정리해야하는 경우 종료 전략은 시간 종료 값 이어야 하고 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 함수에서 종료 신호를 트랩하도록 설정해야합니다 . 종료 명령을 &lt;code&gt;gen_server&lt;/code&gt; 는 콜백 함수 &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">종료 전에 정리해야하는 경우 종료 전략은 시간 종료 값 이어야 하고 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;init/1&lt;/code&gt; 함수로 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 호출하여 종료 신호를 트랩하도록 자체 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">인코딩 / 디코딩 기능을 사용하여 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 세트를 Erlang 파일로 컴파일해야하는 경우 구성 파일에 모든 관련 파일을 나열하십시오. 이 구성 파일은 이중 확장자 &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; 을 가져야합니다 ( &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; 일 수 있음 ). 파일의 각 행마다 하나씩 입력 파일 이름을 따옴표 ( &quot;&quot;)로 나열하십시오. 입력 파일이 &lt;code&gt;File1.asn&lt;/code&gt; , &lt;code&gt;File2.asn&lt;/code&gt; 및 &lt;code&gt;File3.asn&lt;/code&gt; 인 경우 구성 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">관리자가 테이블에서 행을 작성하거나 삭제할 수있는 경우 &lt;code&gt;is_set_ok&lt;/code&gt; 에 대한 &lt;code&gt;RowStatus&lt;/code&gt; 열 이 있어야하며 , &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;undo&lt;/code&gt; 가 제대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 을로드 할 수 있고 &lt;code&gt;Function/N&lt;/code&gt; 기능을 내 보내면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">Mnesia가 테이블에 삽입 된 모든 &lt;code&gt;person&lt;/code&gt; 레코드 의 속성 &lt;code&gt;address&lt;/code&gt; 에 추가 인덱스 테이블을 빌드하고 유지 보수해야하는 경우 다음 코드가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵의 기존 키와 일치하지 않으면 키 &lt;code&gt;K&lt;/code&gt; 에서 값 &lt;code&gt;V&lt;/code&gt; 에 대한 새로운 연관이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 의 기존 키와 일치하지 않으면 런타임에 &lt;code&gt;badarg&lt;/code&gt; 유형의 예외 가 트리거됩니다. 일치하는 키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 에 있으면 연관된 값이 새 값 &lt;code&gt;V&lt;/code&gt; 로 대체되고 평가 된 맵 표현식은 새 맵을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 의 기존 키와 일치하면 연관된 값이 새 값 &lt;code&gt;V&lt;/code&gt; 로 대체됩니다 . 두 경우 모두 평가 된 맵 표현식은 새 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">나중에 만약 &lt;code&gt;Pid&lt;/code&gt; 사유로 종료 &lt;code&gt;Reason&lt;/code&gt; , 이유와 감독자 브리지 종료 &lt;code&gt;Reason&lt;/code&gt; 뿐만 아니라. 나중에 &lt;code&gt;Reason&lt;/code&gt; 이유로 수퍼바이저가 수퍼바이저 브릿지를 중지 한 경우 &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; 를 호출 하여 종료합니다.</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">긴 노드 노드 이름이 사용되는 경우 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 를 호출하여 초기화를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">많은 프로세스가 테이블을 수정하면 모든 프로세스가 테이블을 해제 (또는 종료) 할 때까지 테이블은 고정 된 상태로 유지됩니다. 참조 카운터는 프로세스별로 유지되며 N 개의 연속 수정에는 테이블을 해제하기 위해 N 개의 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">많은 프로세스가 테이블을 수정하면 모든 프로세스가 테이블을 해제하거나 종료 할 때까지 테이블은 고정 된 상태로 유지됩니다. 참조 카운터는 프로세스별로 유지되며 N 개의 연속 수정 프로그램에서는 테이블을 해제하려면 N 개의 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">지도의 경우 &lt;code&gt;map_in&lt;/code&gt; 가 포함 &lt;code&gt;key&lt;/code&gt; ,이 기능의 사본하게 &lt;code&gt;map_in&lt;/code&gt; 에서 &lt;code&gt;*map_out&lt;/code&gt; 을 하고, 제거 &lt;code&gt;key&lt;/code&gt; 와 관련된 값입니다. 지도의 경우 &lt;code&gt;map_in&lt;/code&gt; 이 포함되지 않은 &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;*map_out&lt;/code&gt; 이 설정되어 &lt;code&gt;map_in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">모드가 방해를 받으면 서버가 강제로 차단되고 진행중인 모든 요청이 종료되고 다시로드가 즉시 시작됩니다. 모드가 방해받지 않는 경우 새 연결이 허용되지 않지만 재로드가 완료되기 전에 진행중인 요청을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">모듈이 인라인으로 컴파일되면 가짜 경고가 발생할 수 있습니다. 에서 &lt;strong&gt;옵션&lt;/strong&gt; 메뉴는 바이트 코드를 분석 할 때 인라인 컴파일 된 모듈을 무시하도록 선택할 수 있습니다. 소스 코드에서 시작할 때 Dialyzer에서 인라인을 명시 적으로 해제하므로 문제가되지 않습니다. Dialyzer는 현재 인라인 컴파일 된 코드 부분을 찾을 수있는 방법이 없기 때문에이 옵션을 사용하면 인라인 컴파일 된 모듈의 모든 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">더 복잡한 필터링이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하고 RFC 5277의 &quot;이벤트 알림에 대한 XML 스키마&quot;에 따라 정확한 필터를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">마지막 &lt;code&gt;MaxT&lt;/code&gt; 초 동안 &lt;code&gt;MaxR&lt;/code&gt; 이상의 재시작이 발생 하면 수퍼바이저가 모든 하위 프로세스를 종료 한 다음 자체적으로 종료합니다. 이 경우 수퍼바이저 자체의 종료 이유는 &lt;code&gt;shutdown&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">기본 운영 체제에서보고 한대로 사용 가능한 시스템 메모리가 일정량 이상 할당되면 알람 &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">패턴에 둘 이상의 역 추적 동사가 존재하는 경우, (* COMMIT) 뒤에 오는 다른 동사가 먼저 트리거 될 수 있으므로 일치하는 동안 (* COMMIT)을 전달한다고해서 항상 일치하는 것이이 시작점에 있어야하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">하나 이상의 역 추동 동사가 패턴으로 존재하는 경우, 역 추적 동사가 첫 번째 동작으로 동작합니다. 예를 들어, A, B 등이 복잡한 패턴 조각 인 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">둘 이상의 프로세스가 동일한 &lt;code&gt;Path&lt;/code&gt; 로 이미로드 된 드라이버 를로드하려고 시도하거나 동일한 프로세스가 여러 번로드를 시도하면 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 에뮬레이터는 &lt;code&gt;load/2&lt;/code&gt; 호출을 추적 하므로 드라이버가 언로드되기 전에 동일한 프로세스에서 해당 수의 &lt;code&gt;unload/2&lt;/code&gt; 호출을 수행해야합니다. 따라서 응용 프로그램이 필요할 때 프로세스 또는 응용 프로그램간에 공유되는 드라이버를로드하는 것이 안전합니다. 시스템의 다른 부분에 문제를 일으키지 않고 안전하게 언로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">다중 예약이 활성화 된 경우 에뮬레이터에서 둘 이상의 스케줄러 스레드가 사용됩니다. 다중 예약은 두 가지 방법으로 차단할 수 있습니다. 하나를 제외한 모든 스케줄러가 차단되었거나 하나를 제외한 모든 &lt;strong&gt;일반&lt;/strong&gt; 스케줄러가 차단되었습니다. 일반 스케줄러 만 차단되면 더티 스케줄러는 프로세스를 계속 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">여러 &lt;code&gt;-eval&lt;/code&gt; 표현식이 지정된 경우 지정된 순서대로 순차적으로 평가됩니다. &lt;code&gt;-eval&lt;/code&gt; 표현식은 &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-run&lt;/code&gt; 함수 호출 (이는 지정된 순서대로)을 사용하여 순차적으로 평가됩니다 . &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-run&lt;/code&gt; 과 마찬가지로 종료되지 않은 평가는 시스템 초기화 프로세스를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">여러 타임 스탬프 플래그가 전달되면 &lt;code&gt;timestamp&lt;/code&gt; 는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 보다 우선하며, &lt;code&gt;monotonic_timestamp&lt;/code&gt; 보다 우선 합니다. 모든 타임 스탬프 플래그가 기억되므로 두 개가 전달되고 우선 순위가 가장 높은 것이 비활성화 된 경우 다른 하나가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">이름 등록이 성공하면 새 &lt;code&gt;gen_server&lt;/code&gt; 프로세스는 콜백 함수 &lt;code&gt;ch3:init([])&lt;/code&gt; 호출합니다 . &lt;code&gt;init&lt;/code&gt; 는 &lt;code&gt;{ok, State}&lt;/code&gt; 를 리턴 할 것으로 예상되며 , 여기서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 내부 상태입니다 . 이 경우 상태는 사용 가능한 채널입니다.</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">이름 등록이 성공하면 새 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스는 콜백 함수 &lt;code&gt;code_lock:init(Code)&lt;/code&gt; 호출합니다 . 이 함수는 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 를 반환 할 것으로 예상되는데 , 여기서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 초기 상태입니다 ( 이 경우 &lt;code&gt;locked&lt;/code&gt; . 문이 잠겨 있다고 가정합니다. &lt;code&gt;Data&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 내부 서버 데이터입니다 . 여기서 서버 데이터는 올바른 버튼 시퀀스를 저장하는 키 &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; 저장하는 키 길이 및 수집 된 버튼을 같은 길이까지 저장하는 키 &lt;code&gt;buttons&lt;/code&gt; 이있는 &lt;code&gt;map&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">어느 경우 &lt;code&gt;-minimal&lt;/code&gt; ,도 &lt;code&gt;-sasl&lt;/code&gt; 가 인수로 전달하면 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">엔드 포인트를 원하지 않으면 다음과 같이 테스트하고 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">&lt;code&gt;ContextName&lt;/code&gt; 을 지정 하지 않으면 기본 &lt;code&gt;&quot;&quot;&lt;/code&gt; 컨텍스트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;NotifyName&lt;/code&gt; 이 지정 되지 않은 경우 (또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이면 ) 모든 관리 대상 ( 아래 &lt;code&gt;Addresses&lt;/code&gt; )으로 알림이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 을 지정 하지 않으면 모든 보고서가 나열됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
