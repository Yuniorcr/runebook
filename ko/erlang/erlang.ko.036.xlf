<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="a53a9f4087442a15c8d05293fde6edfea4bb383c" translate="yes" xml:space="preserve">
          <source>This module implements the command-line interface for running tests and basic functions for &lt;code&gt;Common Test&lt;/code&gt; case issues, such as configuration and logging.</source>
          <target state="translated">이 모듈 은 구성 및 로깅과 같은 &lt;code&gt;Common Test&lt;/code&gt; 사례 문제에 대한 테스트 및 기본 기능을 실행하기위한 명령 줄 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c9a16d56697c4875fd3dc95099670093ace6758a" translate="yes" xml:space="preserve">
          <source>This module implements the main API for logging in Erlang/OTP. To create a log event, use the &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; or the log &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">이 모듈은 Erlang / OTP에 로그인하기위한 기본 API를 구현합니다. 로그 이벤트를 작성하려면 &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; 또는 로그 &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="34096d8559e322df745393832ab2c6dfe7da7fb5" translate="yes" xml:space="preserve">
          <source>This module is a &lt;code&gt;gen_event&lt;/code&gt; handler module that can be installed in any &lt;code&gt;gen_event&lt;/code&gt; process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser (&lt;code&gt;rb(3)&lt;/code&gt;) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called &lt;code&gt;index&lt;/code&gt;, and report files &lt;code&gt;1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 설치할 수 있는 &lt;code&gt;gen_event&lt;/code&gt; 핸들러 모듈입니다 . 이벤트 관리자에게 전송 된 모든 이벤트를 디스크에 로그온합니다. 각 이벤트는 바이너리로 작성되므로 로깅 속도가 매우 빠릅니다. 그러나 파일을 읽으려면 보고서 브라우저 ( &lt;code&gt;rb(3)&lt;/code&gt; ) 와 같은 도구를 사용해야합니다. 이벤트는 여러 파일에 기록됩니다. 모든 파일이 사용되면 첫 번째 파일을 재사용하고 덮어 씁니다. 디렉토리 위치, 파일 수 및 각 파일의 크기를 구성 할 수 있습니다. 디렉토리에는 &lt;code&gt;index&lt;/code&gt; 라는 하나의 파일 과 보고서 파일 &lt;code&gt;1, 2, ...&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="91f4aea2b0c25de578d81458879b8b8a6606f33f" translate="yes" xml:space="preserve">
          <source>This module is a first step to run property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. A property testing tool like QuickCheck or PropEr is assumed to be installed.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 에서 특성 기반 테스트를 실행하기위한 첫 번째 단계 입니다. QuickCheck 또는 PropEr과 같은 속성 테스트 도구가 설치된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="745e849710741c8126631867ff49314e84421edc" translate="yes" xml:space="preserve">
          <source>This module is a front end to the pretty-printing library module &lt;code&gt;prettypr&lt;/code&gt;, for text formatting of abstract syntax trees defined by the module &lt;code&gt;erl_syntax&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 꽤 - 인쇄 라이브러리 모듈에 대한 프론트 엔드입니다 &lt;code&gt;prettypr&lt;/code&gt; 모듈에 의해 정의 된 추상 구문 트리의 서식 텍스트, &lt;code&gt;erl_syntax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="771c2457f87cf1d0281342c6af1f3ab5bb5e2564" translate="yes" xml:space="preserve">
          <source>This module is also used by the test module described in the next section.</source>
          <target state="translated">이 모듈은 다음 섹션에서 설명하는 테스트 모듈에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="029ed3af3c0fa1d9308479815ba39c6258f71e21" translate="yes" xml:space="preserve">
          <source>This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of &lt;code&gt;ordered_set&lt;/code&gt;, see below, access time is proportional to the logarithm of the number of stored objects.)</source>
          <target state="translated">이 모듈은 Erlang 내장 용어 스토리지 BIF에 대한 인터페이스입니다. 이를 통해 Erlang 런타임 시스템에 대량의 데이터를 저장하고 데이터에 지속적으로 액세스 할 수 있습니다. ( &lt;code&gt;ordered_set&lt;/code&gt; 의 경우 아래 참조, 액세스 시간은 저장된 오브젝트 수의 로그에 비례합니다.)</target>
        </trans-unit>
        <trans-unit id="2bf3be01bc933bf9be0bb2caf2dc7622f94a43df" translate="yes" xml:space="preserve">
          <source>This module is deprecated. For a description of the Magic Cookie system, refer to &lt;code&gt;Distributed Erlang&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. Magic Cookie 시스템에 대한 설명은 Erlang Reference Manual의 &lt;code&gt;Distributed Erlang&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a93d2db2466d23d6026908c314c14a83563ca6b" translate="yes" xml:space="preserve">
          <source>This module is mainly intended for internal use within OTP, but it has two functions that are exported for public use.</source>
          <target state="translated">이 모듈은 주로 OTP 내부에서 사용하기위한 것이지만 공용으로 내보내는 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a37f6b1919b03e1a3eef60f562daa64d563a0b3" translate="yes" xml:space="preserve">
          <source>This module is preloaded and contains the code for the &lt;code&gt;init&lt;/code&gt; system process that coordinates the startup of the system. The first function evaluated at startup is &lt;code&gt;boot(BootArgs)&lt;/code&gt;, where &lt;code&gt;BootArgs&lt;/code&gt; is a list of command-line arguments supplied to the Erlang runtime system from the local operating system; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 사전로드되어 있으며 시스템 시작을 조정하는 &lt;code&gt;init&lt;/code&gt; 시스템 프로세스에 대한 코드를 포함합니다 . 시작할 때 평가되는 첫 번째 함수는 &lt;code&gt;boot(BootArgs)&lt;/code&gt; . 여기서 &lt;code&gt;BootArgs&lt;/code&gt; 는 로컬 운영 체제에서 Erlang 런타임 시스템에 제공되는 명령 행 인수 목록입니다. &lt;code&gt;erl(1)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f8550670270cc6c0c154e6b678e3322ac083e01" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling GET requests to regular files. GET requests for parts of files is handled by &lt;code&gt;mod_range&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 일반 파일에 대한 GET 요청을 처리합니다. 파일의 일부에 대한 GET 요청은 &lt;code&gt;mod_range&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="539b25aff993fcacaf4286ade9ec0f542cedebde" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling HEAD requests to regular files. HEAD requests for dynamic content is handled by each module responsible for dynamic content.</source>
          <target state="translated">이 모듈은 일반 파일에 대한 HEAD 요청을 처리합니다. 동적 컨텐츠에 대한 HEAD 요청은 동적 컨텐츠를 담당하는 각 모듈에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5ce2d8127480b9b1949b76303752c4240c4a9505" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="translated">이 모듈은 토큰을 추상 형태의 형태 (즉, 최상위 구조), 표현식 또는 용어로 변환하는 기본 Erlang 파서입니다. 초록 형식은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다. 구문 분석 함수 ( &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt; ) 모듈에 허용 되려면 토큰 목록이 &lt;strong&gt;도트&lt;/strong&gt; 토큰으로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc2b019e4ec5090f2acbc77c196c921bcb3de610" translate="yes" xml:space="preserve">
          <source>This module is the default error report module, but can be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 기본 오류 보고서 모듈이지만 명시 적으로 구성 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84c431043a09432c4f87c8d3c357236a55bbfcb6" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0.</source>
          <target state="translated">이 모듈은 XML 파서에 대한 인터페이스이며 XML 1.0을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3104bc131d319b6e5efc35816fb7e2161d34e06f" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0. The XML parser is activated through &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; or &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. It returns records of the type defined in xmerl.hrl. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">이 모듈은 XML 파서에 대한 인터페이스이며 XML 1.0을 처리합니다. XML 파서는 &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 또는 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 를 통해 활성화됩니다 . xmerl.hrl에 정의 된 유형의 레코드를 리턴합니다. 사용자 정의 기능에 대한 &lt;code&gt;tutorial&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c37b4a9c779ad7673d2176f38ce64f13f8e8ff9a" translate="yes" xml:space="preserve">
          <source>This module is the main EUnit user interface.</source>
          <target state="translated">이 모듈은 기본 EUnit 사용자 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="380eae6ed1f14f5abc43a6827952590fc885d0c2" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;os_sup&lt;/code&gt; 의 Windows 백엔드로 사용됩니다 &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="85cabe69b73c75cfce665849059c6c267e570fc3" translate="yes" xml:space="preserve">
          <source>This module is used by module &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; for managing distributed disk logs. The disk log names are used as group names, which means that some action can be needed to avoid name clashes.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 모듈에서 분산 디스크 로그를 관리하는 데 사용됩니다 . 디스크 로그 이름은 그룹 이름으로 사용되므로 이름 충돌을 피하기 위해 몇 가지 조치가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2facc0dce78b1734ff96c5e2c414eea0b55cfeef" translate="yes" xml:space="preserve">
          <source>This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used.</source>
          <target state="translated">이 모듈은 Mnesia 응용 프로그램에서 사용되며 디스크에만 Erlang 용어를 효율적으로 저장하려는 사용자에게 &quot;있는 그대로&quot;제공됩니다. 많은 응용 프로그램은 파일에 일부 용어 만 저장하면됩니다. Mnesia는 트랜잭션, 쿼리 및 배포를 추가합니다. Dets 파일의 크기는 2GB를 초과 할 수 없습니다. 더 큰 테이블이 필요한 경우 Mnesia에서 테이블 조각화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4a5f76c2f39ee7d14410f547c13073a7f0ccea" translate="yes" xml:space="preserve">
          <source>This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended.</source>
          <target state="translated">이 모듈은 Erlang 코드에서 잘못된 구문 및 기타 버그가 있는지 확인하는 데 사용됩니다. 또한 권장하지 않는 코딩 관행에 대해서도 경고합니다.</target>
        </trans-unit>
        <trans-unit id="eeb466b5da365f466e8f7e7ccc932ed35a24cf1b" translate="yes" xml:space="preserve">
          <source>This module is used to load all Erlang modules into the system. The start script is also fetched with this low-level loader.</source>
          <target state="translated">이 모듈은 모든 Erlang 모듈을 시스템에로드하는 데 사용됩니다. 시작 스크립트는이 하위 수준 로더와 함께 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2290e1725f60788cc5c925cb7d57804f016396a1" translate="yes" xml:space="preserve">
          <source>This module is used to profile a program to find out how the execution time is used. Trace to file is used to minimize runtime performance impact.</source>
          <target state="translated">이 모듈은 프로그램을 프로파일 링하여 실행 시간이 어떻게 사용되는지 알아내는 데 사용됩니다. 파일 추적은 런타임 성능 영향을 최소화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c89a4f0fda18575f2da9f933c35be2fd6e70e09" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt;OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 모듈은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 준수하는 프로세스를 시작하는 데 사용됩니다 . &lt;code&gt;gen_server&lt;/code&gt; 모듈의 기능은 새 프로세스를 시작할 때 OTP 표준 동작 (예 : gen_server 및 &lt;code&gt;gen_statem&lt;/code&gt; )에 의해 사용됩니다 . 또한이 기능을 사용 하여 OTP 설계 원칙을 준수하는 &lt;strong&gt;특수 프로세스&lt;/strong&gt; , 사용자 정의 프로세스 를 시작할 수 있습니다 . 예를 들어, OTP 설계 원칙의 &lt;code&gt;sys and proc_lib&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f4ab243ee6586ee79497742f5b5a43934de147b" translate="yes" xml:space="preserve">
          <source>This module is usually part of the &lt;code&gt;erl_interface&lt;/code&gt; application, but is currently part of the Mnesia application.</source>
          <target state="translated">이 모듈은 일반적으로 &lt;code&gt;erl_interface&lt;/code&gt; 응용 프로그램의 일부이지만 현재 Mnesia 응용 프로그램의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="1e34649b10e11074b5eecec6992267ea5de9baf9" translate="yes" xml:space="preserve">
          <source>This module maintains a cache of CRLs. CRLs can be added to the cache using the function &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt;, and optionally automatically fetched through HTTP if the following argument is specified:</source>
          <target state="translated">이 모듈은 CRL 캐시를 유지 관리합니다. &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt; 함수를 사용하여 CRL을 캐시에 추가 할 수 있으며 다음 인수가 지정된 경우 HTTP를 통해 자동으로 페치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99468bcd97490a51d234dfa1e1aa1f1b75181a01" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하면 시스템의 노드를 &lt;strong&gt;전역 그룹&lt;/strong&gt; 으로 분할 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 각 글로벌 그룹에는 자체 글로벌 네임 스페이스가 있습니다 ( &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="8ac57e5b97d1c2443f197da3b8016c360ca297b4" translate="yes" xml:space="preserve">
          <source>This module makes it possible to read internally formatted wrap disk logs, see &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;wrap_log_reader&lt;/code&gt; does not interfere with &lt;code&gt;disk_log&lt;/code&gt; activities; there is however a bug in this version of the &lt;code&gt;wrap_log_reader&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하면 내부 형식의 랩 디스크 로그를 읽을 수 있습니다 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt; 참조 ) . &lt;code&gt;wrap_log_reader&lt;/code&gt; 는 &lt;code&gt;disk_log&lt;/code&gt; 활동을 방해하지 않습니다 . 그러나이 버전의 &lt;code&gt;wrap_log_reader&lt;/code&gt; 에는 버그가 있습니다. &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="989e49030b5db914fe14f640feffac69f14c2c8d" translate="yes" xml:space="preserve">
          <source>This module makes use of a directory where CRLs are stored in files named by the hash of the issuer name.</source>
          <target state="translated">이 모듈은 CRL이 발급자 이름의 해시로 이름이 지정된 파일에 저장된 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e4a8e573560a8571cd9ef1e8a9e51dcf07a77f3" translate="yes" xml:space="preserve">
          <source>This module needs to be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 명시 적으로 구성해야합니다 . &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b605512fe66b8682ce8b37c4cf3e4fbe2e01d42" translate="yes" xml:space="preserve">
          <source>This module operates on grapheme clusters. A &lt;strong&gt;grapheme cluster&lt;/strong&gt; is a user-perceived character, which can be represented by several codepoints.</source>
          <target state="translated">이 모듈은 grapheme 클러스터에서 작동합니다. &lt;strong&gt;자소 클러스터가&lt;/strong&gt; 여러 코드 포인트로 표현 될 수있는 사용자가인지 된 문자이다.</target>
        </trans-unit>
        <trans-unit id="bb1c46b6a237b6087130260dff45a5cc687d6cba" translate="yes" xml:space="preserve">
          <source>This module performs DNS name resolving to recursive name servers.</source>
          <target state="translated">이 모듈은 재귀 이름 서버로 DNS 이름 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4ab7b3a5e783c28b801aa97ce3c793f0d6d021bc" translate="yes" xml:space="preserve">
          <source>This module performs an identity parse transformation of Erlang code. It is included as an example for users who wants to write their own parse transformers. If option &lt;code&gt;{parse_transform,Module}&lt;/code&gt; is passed to the compiler, a user-written function &lt;code&gt;parse_transform/2&lt;/code&gt; is called by the compiler before the code is checked for errors.</source>
          <target state="translated">이 모듈은 Erlang 코드의 신원 구문 분석 변환을 수행합니다. 자체 구문 분석 변환기를 작성하려는 사용자를위한 예제로 포함되어 있습니다. &lt;code&gt;{parse_transform,Module}&lt;/code&gt; 옵션 이 컴파일러에 전달 되면 코드에서 오류를 검사하기 전에 컴파일러가 사용자 작성 함수 &lt;code&gt;parse_transform/2&lt;/code&gt; 를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a0037900bad0730ea9a030ba4069f75cb17a7f8b" translate="yes" xml:space="preserve">
          <source>This module provides (double-ended) FIFO queues in an efficient manner.</source>
          <target state="translated">이 모듈은 효율적인 방식으로 (더블 엔드) FIFO 대기열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86963c4e13e1aeb4e47cbb6c0a5df6d5e8a947ad" translate="yes" xml:space="preserve">
          <source>This module provides API functions to send SSH Connection Protocol events to the other side of an SSH channel.</source>
          <target state="translated">이 모듈은 SSH 연결 프로토콜 이벤트를 SSH 채널의 다른쪽에 보내는 API 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce8b320b968902deab02747f5036f5e0f055ee88" translate="yes" xml:space="preserve">
          <source>This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees.</source>
          <target state="translated">이 모듈은 Arne Andersson 교수의 일반 균형 트리를 제공합니다. 이들은 불평형 이진 트리에 비해 스토리지 오버 헤드가 없으며 AVL 트리보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="781b6c37f92636bd37c09e7bf44c27d67bf8df9d" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. An &lt;code&gt;orddict&lt;/code&gt; is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the &lt;strong&gt;Erlang term order&lt;/strong&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 사전을 제공합니다 . &lt;code&gt;orddict&lt;/code&gt; 는 쌍 목록의 키 값을 저장하는 데 사용되는 사전의 표현이다. 목록은 &lt;strong&gt;Erlang 용어 순서&lt;/strong&gt; 의 키 다음에 &lt;strong&gt;정렬&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="54ac9b6927419ddb4103884312f8097df3f2bb5a" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. The representation of a dictionary is not defined.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 사전을 제공합니다 . 사전의 표현은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="393cc80d6eca92a704f69151bc3d7efe95ae4615" translate="yes" xml:space="preserve">
          <source>This module provides a client api to the Lightweight Directory Access Protocol (LDAP).</source>
          <target state="translated">이 모듈은 LDAP (Lightweight Directory Access Protocol)에 클라이언트 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f62d79bfd7ef0367f3e971c525740d763d760116" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms use the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="translated">이 모듈은 의사 난수 생성기를 제공합니다. 이 모듈에는 여러 알고리즘이 포함되어 있습니다. 균일 분포 알고리즘 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; 의 xoroshiro116 + 및 xorshift1024 * 알고리즘을 사용합니다 . 정규 분포 알고리즘은 균일 분포 알고리즘 위에 &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; 의 Ziggurat 방법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f99a3f1888d10fffd183a70ef4c3a34c9ed1aee3" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;code&gt;Mnesia&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt;, and other data structures that provide an iterator style traversal of objects.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Mnesia&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt; 및 객체의 반복자 스타일 순회를 제공하는 기타 데이터 구조에 대한 쿼리 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4250319025eafcb7ae410e50274c9a7bdf114b1e" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt;Erlang Reference Manual&lt;/code&gt; and &lt;code&gt;Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="translated">이 모듈은 &lt;strong&gt;QLC 테이블에&lt;/strong&gt; 대한 조회 인터페이스를 제공합니다 . 일반적인 QLC 테이블은 Mnesia, ETS 및 Dets 테이블입니다. 사용자 정의 테이블에 대한 지원도 제공됩니다 ( &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션 참조) . &lt;strong id=&quot;query_list_comprehension&quot;&gt;쿼리를&lt;/strong&gt; 사용하여 표현되는 &lt;strong&gt;쿼리 목록 함축&lt;/strong&gt; (QLCs을). 조회에 대한 응답은 조회의 QLC가 나타내는 제한 조건을 충족시키는 QLC 테이블의 데이터에 의해 결정됩니다. QLC는 패턴에 도입 된 변수를 목록 표현식에 사용할 수 없다는 점을 제외하고 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 및 &lt;code&gt;Programming Examples&lt;/code&gt; 설명 된 일반 목록 이해와 유사합니다 . &lt;code&gt;cache&lt;/code&gt; 및 &lt;code&gt;unique&lt;/code&gt; 와 같은 최적화 및 옵션이없는 경우( QLC 테이블이없는 모든 QLC는 동일한 일반 목록 이해와 동일한 답변 목록으로 평가되는 &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047710b1ad9fd2f027b84c9368779228a800a4da" translate="yes" xml:space="preserve">
          <source>This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in 'An efficient and portable pseudo-random number generator', Journal of Applied Statistics. AS183. 1982. Also Byte March 1987.</source>
          <target state="translated">이 모듈은 난수 생성기를 제공합니다. 이 방법은 BA Wichmann과 ID Hill의 '효과적이고 휴대 가능한 의사 난수 생성기'(Journal of Applied Statistics)에 있습니다. AS183. 1982 년 3 월 바이트.</target>
        </trans-unit>
        <trans-unit id="52aa0232673b318eae9c0f57627c3e65f31b22a8" translate="yes" xml:space="preserve">
          <source>This module provides a set of cryptographic functions.</source>
          <target state="translated">이 모듈은 일련의 암호화 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2efbf1cf06a7e77fc1af683651fd7cc8b8da3411" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are sent to the &lt;code&gt;error_logger&lt;/code&gt; after a size check. Messages are truncated after 1024 chars. It is provided as an example.</source>
          <target state="translated">이 모듈은 SNMP 오류보고를위한 간단한 메커니즘을 제공합니다. 크기 확인 후 오류가 &lt;code&gt;error_logger&lt;/code&gt; 에 전송됩니다 . 1024 자 뒤에 메시지가 잘립니다. 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="096fb2e3550a9bb0e5272f77db40c6b69c2ccf79" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are written to stdout using the &lt;code&gt;io&lt;/code&gt; module. It is provided as an simple example.</source>
          <target state="translated">이 모듈은 SNMP 오류보고를위한 간단한 메커니즘을 제공합니다. &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 오류가 stdout에 기록됩니다 . 간단한 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1286f91cbc25e7fd94773e366acdb66f0cb92b07" translate="yes" xml:space="preserve">
          <source>This module provides a term storage on file. The stored terms, in this module called &lt;strong&gt;objects&lt;/strong&gt;, are tuples such that one element is defined to be the key. A Dets &lt;strong&gt;table&lt;/strong&gt; is a collection of objects with the key at the same position stored on a file.</source>
          <target state="translated">이 모듈은 파일에 용어 스토리지를 제공합니다. 이 모듈에서 &lt;strong&gt;objects&lt;/strong&gt; 라는 저장된 용어 는 하나의 요소가 키로 정의되도록 튜플입니다. Dets &lt;strong&gt;테이블&lt;/strong&gt; 은 키가 파일에 저장된 동일한 위치에있는 개체의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="1620c061e4de1e2d509ff847686aeef840c94ae4" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="translated">이 모듈은 레이블이 지정된 직접 그래프 버전을 제공합니다. 여기에 그래프를 적절하지 않은 방향으로 제공하는 그래프는 정점 사이의 여러 가장자리가 허용된다는 것입니다. 그러나 유 방향 그래프의 관례적인 정의가 여기에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cf7ab2f5fd96a0860285a8e510288d8e51d560" translate="yes" xml:space="preserve">
          <source>This module provides access to TCP/IP protocols.</source>
          <target state="translated">이 모듈은 TCP / IP 프로토콜에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce4f070d6f9440d796d3f2ff1b4d9fe245970d26" translate="yes" xml:space="preserve">
          <source>This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 방향 그래프의 깊이 우선 탐색을 기반으로 알고리즘을 제공합니다. 유 방향 그래프에 대한 기본 기능은 &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="750641c760c68123c0ef647455d03f63c154be54" translate="yes" xml:space="preserve">
          <source>This module provides an API for the zlib library (&lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt;). It is used to compress and decompress data. The data format is described by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 zlib 라이브러리 ( &lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt; ) 용 API를 제공합니다 . 데이터를 압축 및 압축 해제하는 데 사용됩니다. 데이터 포맷은 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt; 에 의해 설명된다 .</target>
        </trans-unit>
        <trans-unit id="faf120ddebe052c8dc6014a2841d031820c05adf" translate="yes" xml:space="preserve">
          <source>This module provides an Erlang shell.</source>
          <target state="translated">이 모듈은 Erlang 쉘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce785837b5ff1a707a464ab7d4098ba53cf3ddeb" translate="yes" xml:space="preserve">
          <source>This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of &lt;strong id=&quot;annotations&quot;&gt;annotations&lt;/strong&gt; as described in the following.</source>
          <target state="translated">이 모듈은 열, 줄 번호 및 텍스트와 같은 데이터를 보유하기 위해 Erlang Compiler 및 해당 도우미 모듈에서 사용하는 추상 유형을 제공합니다. 데이터 유형은 다음에 설명 된 &lt;strong id=&quot;annotations&quot;&gt;주석&lt;/strong&gt; 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="c240161f74f286924b1ecba60c9826a37e901d2d" translate="yes" xml:space="preserve">
          <source>This module provides an interface for loading and unloading &lt;strong&gt;Erlang linked-in drivers&lt;/strong&gt; in runtime.</source>
          <target state="translated">이 모듈은 런타임 &lt;strong&gt;에서 Erlang 링크드 드라이버&lt;/strong&gt; 를로드 및 언로드하기위한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0d50e0a3798c5432e0aff3d79f28ece00952d5f8" translate="yes" xml:space="preserve">
          <source>This module provides an interface to a number of mathematical functions.</source>
          <target state="translated">이 모듈은 여러 수학 함수에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5733344375dbedf0030d51fc4fa5b63269782bb" translate="yes" xml:space="preserve">
          <source>This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks.</source>
          <target state="translated">이 모듈은 BEAM 컴파일러가 작성한 파일 ( &quot;BEAM 파일&quot;)에 대한 인터페이스를 제공합니다. 교환 형식 파일에 대한 &quot;EA IFF 1985&quot;표준의 변형 인 사용 된 형식은 데이터를 청크로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="4c0abe15371bacb3988f25e8e42f9bd6deaa06d4" translate="yes" xml:space="preserve">
          <source>This module provides an interface to standard Erlang I/O servers. The output functions all return &lt;code&gt;ok&lt;/code&gt; if they are successful, or exit if they are not.</source>
          <target state="translated">이 모듈은 표준 Erlang I / O 서버에 대한 인터페이스를 제공합니다. 출력 기능은 모두 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환하고, 실패하면 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bb92749dec61f65e77f765c953d790353efc379f" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the file system.</source>
          <target state="translated">이 모듈은 파일 시스템에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ea2060b34505717f9518e88bbe84cae8d4301f7" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the standard Erlang compiler. It can generate either a new file, which contains the object code, or return a binary, which can be loaded directly.</source>
          <target state="translated">이 모듈은 표준 Erlang 컴파일러에 대한 인터페이스를 제공합니다. 객체 코드가 포함 된 새 파일을 생성하거나 직접로드 할 수있는 이진을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e596baf52d2a5d67161fc159d66bc7111b7496e" translate="yes" xml:space="preserve">
          <source>This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt;, the Erlang parser, or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 Erlang 표현식에 대한 인터프리터를 제공합니다. 표현식은 &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt; , Erlang 파서 또는 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 에 의해 리턴되는 추상 구문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c532b071cf1e2933fea5e0754fde5565914b25" translate="yes" xml:space="preserve">
          <source>This module provides computation of local and universal time, day of the week, and many time conversion functions.</source>
          <target state="translated">이 모듈은 현지 및 표준시, 요일 및 많은 시간 변환 기능의 계산을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f095529d267dab0aeb8e3b8b1364f61d105a9b58" translate="yes" xml:space="preserve">
          <source>This module provides for basic user authentication using textual files, Dets databases, or Mnesia databases.</source>
          <target state="translated">이 모듈은 텍스트 파일, Dets 데이터베이스 또는 Mnesia 데이터베이스를 사용한 기본 사용자 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9257a7b2b5d2a4ae1e7c3b4a499e70e6fee999d" translate="yes" xml:space="preserve">
          <source>This module provides functions for allocating and deallocating memory.</source>
          <target state="translated">이 모듈은 메모리 할당 및 할당 해제 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1acd3ec02989ce1863b1f9978f7179ed4f16a75" translate="yes" xml:space="preserve">
          <source>This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like &lt;code&gt;foo.erl&lt;/code&gt;, a long absolute name including a drive designator, a directory name like &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt;, or any variations in between.</source>
          <target state="translated">이 모듈은 파일 이름을 분석하고 조작하는 기능을 제공합니다. 이러한 기능은 Erlang 코드가 다른 파일 이름 형식을 가진 다양한 플랫폼에서 작동 할 수 있도록 설계되었습니다. 파일 이름은 파일을 나타내는 데 사용할 수있는 모든 문자열을 의미합니다. 파일 이름은 &lt;code&gt;foo.erl&lt;/code&gt; 과 같은 짧은 상대 이름 , 드라이브 지정자를 포함하는 긴 절대 이름, &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt; 과 같은 디렉토리 이름 또는 그 사이의 모든 변형 일 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="ba26786354c2721a7cffffe073a2f1107136ad72" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; through the user-level &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 SCTP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다. 이 구현에서는 OS 커널 이 사용자 수준 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 통해 SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; 를 지원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="6237d5a917a923f45f8684296ea4f397f5ee1fec" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the TCP/IP protocol.</source>
          <target state="translated">이 모듈은 TCP / IP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="047ce7d569f63519c312507e77fc10e7a0abdd77" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the UDP protocol.</source>
          <target state="translated">이 모듈은 UDP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4170af0d02bb4471c502310e774e78bff4f783ba" translate="yes" xml:space="preserve">
          <source>This module provides functions for creating and manipulating Erlang terms.</source>
          <target state="translated">이 모듈은 Erlang 용어를 작성하고 조작하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1e4339ab7b3c28859324758d30d70eff072c8031" translate="yes" xml:space="preserve">
          <source>This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master.</source>
          <target state="translated">이 모듈은 Erlang 슬레이브 노드를 시작하는 기능을 제공합니다. 마스터가 시작한 모든 슬레이브 노드는 마스터가 종료되면 자동으로 종료됩니다. 슬레이브에서 생성 된 모든 터미널 출력은 마스터 노드로 다시 전송됩니다. 파일 I / O는 마스터를 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b46a173f5bc0dfe98e3415de1917b5e2303db97e" translate="yes" xml:space="preserve">
          <source>This module provides functions for string processing.</source>
          <target state="translated">이 모듈은 문자열 처리 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb4e067fc4ce218df6cee6a75080152b7287b4b0" translate="yes" xml:space="preserve">
          <source>This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element.</source>
          <target state="translated">이 모듈은 유한 세트 및 세트로 표시되는 관계에 대한 조작을 제공합니다. 직관적으로, 집합은 요소의 모음입니다. 모든 요소는 세트에 속하며 세트에는 모든 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7c8f4236f4ac7c20019baf55ac92c3062eac4e" translate="yes" xml:space="preserve">
          <source>This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application.</source>
          <target state="translated">이 모듈은 Arne Andersson 교수의 일반 균형 트리를 사용하여 주문 된 세트를 제공합니다. 정렬 된 세트는 더 큰 세트의 경우 정렬 된 목록을 사용하는 것보다 훨씬 효율적일 수 있지만 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ba40f5b3e99d275a596aa07c0dff3f599128accf" translate="yes" xml:space="preserve">
          <source>This module provides per-directory user configurable access control.</source>
          <target state="translated">이 모듈은 디렉토리 별 사용자 구성 가능 액세스 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c12c2072886f929b57ed6b57be79da289e76ef8" translate="yes" xml:space="preserve">
          <source>This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry.</source>
          <target state="translated">이 모듈은 Windows에서 레지스트리에 대한 읽기 및 쓰기 액세스를 제공합니다. 기본적으로 레지스트리 액세스를위한 Win32 API 호출을 감싸는 포트 드라이버입니다.</target>
        </trans-unit>
        <trans-unit id="c778b6bf3c6ceb257250b7ae833621c36f93fd49" translate="yes" xml:space="preserve">
          <source>This module provides some limited support for concurrent access. All updates to single objects are guaranteed to be both &lt;strong&gt;atomic&lt;/strong&gt; and &lt;strong&gt;isolated&lt;/strong&gt;. This means that an updating operation to a single object either succeeds or fails completely without any effect (atomicity) and that no intermediate results of the update can be seen by other processes (isolation). Some functions that update many objects state that they even guarantee atomicity and isolation for the entire operation. In database terms the isolation level can be seen as &quot;serializable&quot;, as if all isolated operations are carried out serially, one after the other in a strict order.</source>
          <target state="translated">이 모듈은 동시 액세스에 대한 일부 제한된 지원을 제공합니다. 단일 객체에 대한 모든 업데이트는 &lt;strong&gt;원자 적&lt;/strong&gt; 이며 &lt;strong&gt;격리 된&lt;/strong&gt; 것이 &lt;strong&gt;어야&lt;/strong&gt; 합니다. 즉, 단일 개체에 대한 업데이트 작업이 아무런 효과 (원 자성)없이 성공하거나 실패하며 다른 프로세스 (격리)에서 업데이트의 중간 결과를 볼 수 없습니다. 많은 객체를 업데이트하는 일부 함수는 전체 작업에서 원자 성과 격리를 보장한다고 말합니다. 데이터베이스 용어에서 격리 수준은 &quot;일련 화 가능&quot;으로 볼 수 있습니다. 마치 모든 격리 된 작업이 엄격한 순서대로 순차적으로 수행되는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e080461e2e77686f66945fda37287e52c6b43e16" translate="yes" xml:space="preserve">
          <source>This module provides support for communication between distributed Erlang nodes and C-nodes, in a manner that is transparent to Erlang processes.</source>
          <target state="translated">이 모듈은 Erlang 프로세스에 투명한 방식으로 분산 Erlang 노드와 C- 노드 간의 통신을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9dd15c5a43f249c41879dce22695542c08e92337" translate="yes" xml:space="preserve">
          <source>This module provides support for registering, looking up, and unregistering names in the &lt;code&gt;global&lt;/code&gt; module. For more information, see &lt;code&gt;kernel:global&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;global&lt;/code&gt; 모듈 에서 이름을 등록, 조회 및 등록 취소하는 기능을 지원 합니다. 자세한 정보는 &lt;code&gt;kernel:global&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acc44f686954a04de29fbc3692f9d04d65486748" translate="yes" xml:space="preserve">
          <source>This module provides support for storing key-value pairs in a table known as a registry, backing up registries to &lt;code&gt;Mnesia&lt;/code&gt; in an atomic manner, and later restoring the contents of a registry from &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 레지스트리로 알려진 테이블에 키-값 쌍을 저장하고 레지스트리를 원자적인 방식으로 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 한 다음 나중에 &lt;code&gt;Mnesia&lt;/code&gt; 에서 레지스트리의 내용을 복원하는 기능을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="c4fb892b992e614adc88b69df82b17ae13945733" translate="yes" xml:space="preserve">
          <source>This module provides the API to an HTTP/1.1 compatible client according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Caching is not supported.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 따라 HTTP / 1.1 호환 클라이언트에 API를 제공합니다 . 캐싱은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6480b6d56431c3c7e09177c0ce29744efb2ce799" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with miscellaneous utility functions.</source>
          <target state="translated">이 모듈은 Erlang 웹 서버 API 모듈 프로그래머에게 기타 유틸리티 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c5916e2632e665c5b2f5f52d5c56b0a93bc00" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with utility functions for generic sockets communication. The appropriate communication mechanism is transparently used, that is, &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 Erlang 웹 서버 API 모듈 프로그래머에게 일반 소켓 통신을위한 유틸리티 기능을 제공합니다. 적절한 통신 메커니즘, 즉 &lt;code&gt;ip_comm&lt;/code&gt; 또는 &lt;code&gt;ssl&lt;/code&gt; 이 투명하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a178749a79e6fb26e39ef05fff26033dce75ac3" translate="yes" xml:space="preserve">
          <source>This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733.</source>
          <target state="translated">이 모듈은 RFC 6733에 정의 된대로 Diameter 프로토콜을 사용하여 메시지를 보내고받는 Diameter 노드를 사용자가 구현할 수있는 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2290d99631f95e83db0417df2bd64d3d9576bcac" translate="yes" xml:space="preserve">
          <source>This module provides the most basic API to the clients and servers that are part of the &lt;code&gt;Inets&lt;/code&gt; application, such as start and stop.</source>
          <target state="translated">이 모듈은 시작 및 중지와 같이 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램의 일부인 클라이언트 및 서버에 가장 기본적인 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c2dc289d587182daff0825395e7477905794ef0d" translate="yes" xml:space="preserve">
          <source>This module provides the parse transformation that makes calls to &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 에 대한 호출을 리터럴 일치 스펙으로 변환하는 구문 분석 변환을 제공합니다 . 또한 Erlang 쉘에서 호출 될 때 동일한 기능에 대한 백엔드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="721a3117429eceb8f061f5e2899bcbfb40bdf110" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;dict&lt;/code&gt; considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의 된 표현을 제공합니다. 한 가지 차이점은 &lt;code&gt;dict&lt;/code&gt; 에서 두 키가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주하지만이 모듈은 두 키가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 다른 것으로 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f2cfe02c9b447eb5cee32eb141157e31208af9a7" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; module. One difference is that while this module considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;orddict&lt;/code&gt; considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공합니다 . 한 가지 차이점은이 모듈이 두 개의 키가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주 하지만 &lt;code&gt;orddict&lt;/code&gt; 는 두 키가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 두 개의 키를 다르게 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38d6e52db1a80893122e1c828b20e43583ef95f9" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;ordsets&lt;/code&gt; considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의되지 않은 표현을 제공합니다. 한 가지 차이점은이 모듈이 두 요소가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 두 요소를 다르게 간주 하지만 &lt;code&gt;ordsets&lt;/code&gt; 는 두 요소가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 두 요소를 다르게 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6fff0aaa0429816efbfd85cd732dd006ea6157aa" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;sets&lt;/code&gt; considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의 된 표현을 제공합니다. 한 가지 차이점은 &lt;code&gt;sets&lt;/code&gt; 두 요소가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주하지만이 모듈은 두 요소가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교되지 않는 경우에만 다른 것으로 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="742e632c6552d16bd6d478a7d1daf12903965f79" translate="yes" xml:space="preserve">
          <source>This module provides useful functions related to time. Unless otherwise stated, time is always measured in &lt;strong&gt;milliseconds&lt;/strong&gt;. All timer functions return immediately, regardless of work done by another process.</source>
          <target state="translated">이 모듈은 시간과 관련된 유용한 기능을 제공합니다. 달리 명시되지 않는 한, 시간은 항상 &lt;strong&gt;밀리 초 단위로&lt;/strong&gt; 측정됩니다 . 다른 프로세스에서 수행 한 작업에 관계없이 모든 타이머 기능이 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d4e83f9e995a297aeebc8e6a32d2dba035f338" translate="yes" xml:space="preserve">
          <source>This module provides utility functions for working with URIs, according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 에 따라 URI 작업을위한 유틸리티 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="69116d4fbcf6560d1469aa6a1f54ad5b50520175" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_channel.</source>
          <target state="translated">이 모듈은 ssh_channel을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e4595252d25beb7eb4255174f697d15c0830a38f" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_daemon_channel.</source>
          <target state="translated">이 모듈은 ssh_daemon_channel을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="8aeeae3a06e268738003ec9e46ac483c94be8f5b" translate="yes" xml:space="preserve">
          <source>This module responses to requests for one or many ranges of a file. This is especially useful when downloading large files, as a broken download can be resumed.</source>
          <target state="translated">이 모듈은 하나 이상의 파일 범위에 대한 요청에 응답합니다. 깨진 파일을 다시 다운로드 할 수 있으므로 큰 파일을 다운로드 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="181bfa906d54214c120e83123d1185ab071fc48e" translate="yes" xml:space="preserve">
          <source>This module runs CGI scripts whenever a file of a certain type or HTTP method (see &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;) is requested.</source>
          <target state="translated">이 모듈은 특정 유형의 파일 또는 HTTP 메소드 ( &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 참조 )가 요청 될 때마다 CGI 스크립트를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="6cf32be7983eb16f31b4b6b42dc9e21cb5289f56" translate="yes" xml:space="preserve">
          <source>This module tokenises and parses most Erlang source code without expanding preprocessor directives and macro applications, as long as these are syntactically &quot;well-behaved&quot;. Because the normal parse trees of the &lt;code&gt;erl_parse&lt;/code&gt; module cannot represent these things (normally, they are expanded by the Erlang preprocessor &lt;code&gt;epp(3)&lt;/code&gt; before the parser sees them), an extended syntax tree is created, using the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 구문 상 &quot;잘 동작&quot;하는 한 전 처리기 지시문 및 매크로 응용 프로그램을 확장하지 않고도 대부분의 Erlang 소스 코드를 토큰 화하고 구문 분석합니다. &lt;code&gt;erl_parse&lt;/code&gt; 모듈 의 일반 구문 분석 트리는 이러한 것들을 나타낼 수 없기 때문에 (일반적으로 파서가보기 전에 Erlang 프리 프로세서 &lt;code&gt;epp(3)&lt;/code&gt; )에 의해 확장됩니다) 확장 구문 트리는 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 모듈을 사용하여 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="5da9ff3bf77e5f995d90689278c7a23b1597c8bb" translate="yes" xml:space="preserve">
          <source>This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on.</source>
          <target state="translated">이 모듈은 현재 키를 사용합니다. 현재 디렉토리와 매우 유사합니다. 현재 키에서 값을 가져올 수 있고 하위 키를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba20fa4df70d15689e43b0f44c7517efe1b08358" translate="yes" xml:space="preserve">
          <source>This module uses application &lt;code&gt;SSH&lt;/code&gt;, which provides detailed information about, for example, functions, types, and options.</source>
          <target state="translated">이 모듈은 기능, 유형 및 옵션과 같은 자세한 정보를 제공 하는 애플리케이션 &lt;code&gt;SSH&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c27440a34997ba37bea9913114676bb50554dcae" translate="yes" xml:space="preserve">
          <source>This module was written for one-to-many style sockets (type &lt;code&gt;seqpacket&lt;/code&gt;). With the addition of &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt;, one-to-one style sockets (type &lt;code&gt;stream&lt;/code&gt;) were introduced.</source>
          <target state="translated">이 모듈은 일대 다 스타일 소켓 ( &lt;code&gt;seqpacket&lt;/code&gt; 유형 ) 을 위해 작성되었습니다 . &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt; 의 추가로 , 일대일 스타일 소켓 (타입 &lt;code&gt;stream&lt;/code&gt; )이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="606223ff437db337a77e6be8dc6a090de4bc5931" translate="yes" xml:space="preserve">
          <source>This modules contains the interface to the &lt;code&gt;heart&lt;/code&gt; process. &lt;code&gt;heart&lt;/code&gt; sends periodic heartbeats to an external port program, which is also named &lt;code&gt;heart&lt;/code&gt;. The purpose of the &lt;code&gt;heart&lt;/code&gt; port program is to check that the Erlang runtime system it is supervising is still running. If the port program has not received any heartbeats within &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds (defaults to 60 seconds), the system can be rebooted.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;heart&lt;/code&gt; 프로세스에 대한 인터페이스가 포함되어 있습니다 . &lt;code&gt;heart&lt;/code&gt; 는 정기적 인 하트 비트를 외부 포트 프로그램으로 보내며,이 프로그램은 &lt;code&gt;heart&lt;/code&gt; 라고도 합니다. &lt;code&gt;heart&lt;/code&gt; 포트 프로그램 의 목적 은 감시중인 Erlang 런타임 시스템이 여전히 실행 중인지 확인하는 것입니다. 포트 프로그램이 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 초 (기본값은 60 초) 내에 하트 비트를 수신하지 않으면 시스템을 재부팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f8a20f0be71ce686a1d45af49ce482f6a78d69" translate="yes" xml:space="preserve">
          <source>This must however be done with care, as function &lt;code&gt;{return_trace}&lt;/code&gt; in the match specification destroys tail recursiveness.</source>
          <target state="translated">그러나 일치 스펙의 함수 &lt;code&gt;{return_trace}&lt;/code&gt; 가 테일 재귀를 파괴 하므로주의해서 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="68582ac86e79db46d57ee06207c511b4a861bfb5" translate="yes" xml:space="preserve">
          <source>This node uses some master nodes to store and fetch release information. All master nodes must be operational whenever release information is written by this node.</source>
          <target state="translated">이 노드는 일부 마스터 노드를 사용하여 릴리스 정보를 저장하고 가져옵니다. 이 노드가 릴리스 정보를 쓸 때마다 모든 마스터 노드가 작동 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2b52bf50e58c3cc457e61abee1b9f82215c9813" translate="yes" xml:space="preserve">
          <source>This node.</source>
          <target state="translated">이 노드.</target>
        </trans-unit>
        <trans-unit id="768833241e4c41a51c30053841c9a5be0a33a799" translate="yes" xml:space="preserve">
          <source>This now works as expected:</source>
          <target state="translated">이제 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4858903cb179e40729be5206f937b3196b299dba" translate="yes" xml:space="preserve">
          <source>This of course requires your editor to support UTF-8 as well. The same comment is also interpreted by functions like &lt;code&gt;file:consult/1&lt;/code&gt;, the release handler, and so on, so that you can have all text files in your source directories in UTF-8 encoding.</source>
          <target state="translated">물론 에디터는 UTF-8도 지원해야합니다. 동일한 주석은 &lt;code&gt;file:consult/1&lt;/code&gt; , 릴리스 핸들러 등과 같은 함수로 해석 되므로 소스 디렉토리의 모든 텍스트 파일을 UTF-8 인코딩으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfffe74a9c7d9d5e838ee7506a86798e8b02c78d" translate="yes" xml:space="preserve">
          <source>This off-line utility function can be used to convert the old snmp application config (pre snmp-4.0) to the new snmp agent config (as of snmp-4.0).</source>
          <target state="translated">이 오프라인 유틸리티 기능을 사용하여 이전 snmp 응용 프로그램 구성 (snmp-4.0 이전)을 새로운 snmp 에이전트 구성 (snmp-4.0 기준)으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2b5100380724d761bb0b871c669f6341e1d19e" translate="yes" xml:space="preserve">
          <source>This only applies if Erlang is started as a distributed node, i.e. if &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is specified. Otherwise, epmd is not started even if &lt;code&gt;-start_epmd true&lt;/code&gt; is given.</source>
          <target state="translated">이는 Erlang이 분산 노드로 시작된 경우, 즉 &lt;code&gt;-name&lt;/code&gt; 또는 &lt;code&gt;-sname&lt;/code&gt; 이 지정된 경우에만 적용됩니다 . 그렇지 않으면, -start_epmd &lt;code&gt;-start_epmd true&lt;/code&gt; 가 제공 되더라도 epmd가 시작되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36578cd782b1b1c7c098e80e28d83efcfb473d12" translate="yes" xml:space="preserve">
          <source>This operation is best described with an example.</source>
          <target state="translated">이 작업은 예제와 함께 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="726740b93f9a38ad69503060d61e78fcfc4ed2e8" translate="yes" xml:space="preserve">
          <source>This operation returns both configuration and state data from the server.</source>
          <target state="translated">이 작업은 서버에서 구성 및 상태 데이터를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c28d8949e39a67d4d2b916902211267c2c1b4e17" translate="yes" xml:space="preserve">
          <source>This option and option &lt;code&gt;match_limit&lt;/code&gt; are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</source>
          <target state="translated">이 옵션 및 옵션 &lt;code&gt;match_limit&lt;/code&gt; 는 드문 경우에만 사용됩니다. 이러한 한계를 변경하기 전에 PCRE 라이브러리 내부를 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6f9af6a987f2d3bf6639d97909039e3b4c47dc6a" translate="yes" xml:space="preserve">
          <source>This option augments the host name extraction from URIs and other Reference IDs. It could for example be a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of:</source>
          <target state="translated">이 옵션은 URI 및 기타 참조 ID에서 호스트 이름 추출을 향상시킵니다. 예를 들어 표준화되지 않은 매우 특수한 URI 일 수 있습니다. 재미는 참조 ID를 인수로 사용하여 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21da80d80de6786a8c35eb55211f1719f7ad6a3e" translate="yes" xml:space="preserve">
          <source>This option can also be used to override the default renaming of calls which use obsolete function names.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않는 함수 이름을 사용하는 기본 호출 이름 바꾸기를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb004a99221b3f8badd722205d40d87fd8410dc" translate="yes" xml:space="preserve">
          <source>This option can be used for adding members to a distributed disk log. Defaults to &lt;code&gt;[]&lt;/code&gt;, which means that the log is local on the current node.</source>
          <target state="translated">이 옵션은 분산 디스크 로그에 구성원을 추가하는 데 사용할 수 있습니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 로 , 현재 노드에서 로그가 로컬임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="23765e948e554b57ee502bc4f444d5a5c23a77a3" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon execute exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case but in the error case.</source>
          <target state="translated">이 옵션은 데몬이 클라이언트로부터 실행 요청을 실행하는 방법을 변경합니다. 리턴 값의 용어는 문자열이 아닌 유형 인 경우 문자열로 형식화됩니다. ok-case에는 후행 줄 바꿈이 추가되지 않지만 오류의 경우에는 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="53106c8ee8480a565ca1694a5aee9779aed8d667" translate="yes" xml:space="preserve">
          <source>This option changes the representation of the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; to use maps (instead of records). This option also suppresses the generation of &lt;code&gt;.hrl&lt;/code&gt; files.</source>
          <target state="translated">이 옵션은 맵 대신 레코드를 사용하도록 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 유형의 표시를 변경합니다 . 이 옵션은 또한 &lt;code&gt;.hrl&lt;/code&gt; 파일 생성을 억제 합니다.</target>
        </trans-unit>
        <trans-unit id="91dab051c90259277cd95566eff3cf880c2a9995" translate="yes" xml:space="preserve">
          <source>This option controls the debug level of &lt;code&gt;wx&lt;/code&gt;. As its name indicates it is only useful for debugging. See &lt;code&gt;wx:debug/1&lt;/code&gt; for more info.</source>
          <target state="translated">이 옵션은 &lt;code&gt;wx&lt;/code&gt; 의 디버그 레벨을 제어합니다 . 이름에서 알 수 있듯이 디버깅에만 유용합니다. 자세한 정보는 &lt;code&gt;wx:debug/1&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ec5e0644c323d96923ea009ec73a058e3e14790" translate="yes" xml:space="preserve">
          <source>This option controls the error handling behavior of Reltool. By default the window processes traps exit, but this behavior can altered by setting &lt;code&gt;trap_exit&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 Reltool의 오류 처리 동작을 제어합니다. 기본적으로 창은 트랩 종료를 처리하지만 &lt;code&gt;trap_exit&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e73575c5bb05401f153a1b408d8ff447357a91" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;true&lt;/code&gt; for backwards compatibility but we intend to remove the exception behavior in a future release. New code that needs to handle dictionaries manually should always specify &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 옵션의 기본값은 &lt;code&gt;true&lt;/code&gt; 이지만 이후 릴리스에서는 예외 동작을 제거하려고합니다. 사전을 수동으로 처리해야하는 새 코드는 항상 &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt; 를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24e5307f642c6711e98aa1e1851a0012231dc221" translate="yes" xml:space="preserve">
          <source>This option defines how the manager will handle the sending of response (acknowledgment) to received inform-requests.</source>
          <target state="translated">이 옵션은 관리자가 수신 된 정보 요청에 대한 응답 (확인) 전송을 처리하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0b065ec1d28b81abfd2469427265be5e95f2a102" translate="yes" xml:space="preserve">
          <source>This option determines which &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; are to be received (through &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;) along with the data. The only exception is &lt;code&gt;data_io_event&lt;/code&gt;, which enables or disables receiving of &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; ancillary data, not events. By default, all flags except &lt;code&gt;adaptation_layer_event&lt;/code&gt; are enabled, although &lt;code&gt;sctp_data_io_event&lt;/code&gt; and &lt;code&gt;association_event&lt;/code&gt; are used by the driver itself and not exported to the user level.</source>
          <target state="translated">이 옵션 은 데이터와 함께 수신 할 &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 를 통해 )를 결정합니다. 유일한 예외는 &lt;code&gt;data_io_event&lt;/code&gt; 입니다.이 이벤트는 이벤트가 아닌 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 보조 데이터 수신을 활성화 또는 비활성화 합니다. &lt;code&gt;sctp_data_io_event&lt;/code&gt; 및 &lt;code&gt;association_event&lt;/code&gt; 는 드라이버 자체에서 사용되며 사용자 레벨로 내 보내지 않지만 &lt;code&gt;adaptation_layer_event&lt;/code&gt; 를 제외한 모든 플래그가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f54c1964a5e915a3b9d8124e81def1141091a66" translate="yes" xml:space="preserve">
          <source>This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. &lt;code&gt;run/3&lt;/code&gt; always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</source>
          <target state="translated">이 옵션은 &quot;장기 실행 BIF&quot;측면에서 Erlang VM의 실행에 영향을 미치지 않습니다. &lt;code&gt;run/3&lt;/code&gt; 은 항상 Erlang 시스템의 실시간 속성을 보장하는 간격으로 Erlang 프로세스의 스케줄러를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6af47b199e89cf536046513882864286cab54688" translate="yes" xml:space="preserve">
          <source>This option does not guarantee exclusiveness on file systems not supporting &lt;code&gt;O_EXCL&lt;/code&gt; properly, such as NFS. Do not depend on this option unless you know that the file system supports it (in general, local file systems are safe).</source>
          <target state="translated">이 옵션은 NFS와 같이 &lt;code&gt;O_EXCL&lt;/code&gt; 을 제대로 지원하지 않는 파일 시스템에서만 사용할 수있는 것은 아닙니다 . 파일 시스템이 해당 파일 시스템을 지원한다는 것을 모르면이 옵션에 의존하지 마십시오 (일반적으로 로컬 파일 시스템은 안전합니다).</target>
        </trans-unit>
        <trans-unit id="170942e99acf8590a0f93f95af96a97ad9b43a74" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="translated">이 옵션 은 연결된 서버가 클라이언트가 이전에 보지 못한 호스트 키를 제시 할 때 작동하는 방법에 대한 &lt;code&gt;connect&lt;/code&gt; 기능을 안내합니다 . 기본값은 새 호스트 키를 허용할지 거부할지 stdio에 대한 질문을 사용자에게 요청하는 것입니다. 이전에 승인 된 호스트 키가 기록되는 &lt;code&gt;known_hosts&lt;/code&gt; 파일의 경로를 지정하려면 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . 키를 처리하는 일반적인 방법은 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f681818b307476626695654e1f4af8954537ac9" translate="yes" xml:space="preserve">
          <source>This option implies option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1b7df27500f11cd0120772f370d99f496bc69623" translate="yes" xml:space="preserve">
          <source>This option indicates weather the request should be resent until the reply is received, &lt;strong&gt;even&lt;/strong&gt; though a pending message has been received.</source>
          <target state="translated">이 옵션은 응답이 수신 될 때까지 요청을 재전송한다 날씨를 나타내는 &lt;strong&gt;도&lt;/strong&gt; 보류중인 메시지가 수신되었습니다 불구하고.</target>
        </trans-unit>
        <trans-unit id="6ee2dcf0c6730f63f33d0e9b597dde90cc7553c6" translate="yes" xml:space="preserve">
          <source>This option indicates weather the transport module should be told if a message send is a resend or not.</source>
          <target state="translated">이 옵션은 메시지 전송이 재전송되는지 여부에 따라 전송 모듈에 알려야하는 날씨를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f41d25f928d777038d78ec54aa87e0b2645ebe41" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; (in either order) results in 2 scheduler threads (50% of 4) and 1 scheduler thread online (25% of 4).</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; 설정 과 상호 작용 합니다. 예를 들어, 8 개의 논리 코어가 구성되고 8 개의 논리 코어를 사용할 수있는 시스템에서 &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; 옵션을 조합하면 2 개의 스케줄러 스레드 (4의 50 %)와 1이 생성됩니다. 스케줄러 스레드 온라인 (4의 25 %).</target>
        </trans-unit>
        <trans-unit id="f69d8c25bc614477e7fde4538f00fb8866b22040" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; (in either order) results in 2 dirty CPU scheduler threads (50% of 4) and 1 dirty CPU scheduler thread online (25% of 4).</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 설정 과 상호 작용 합니다. 예를 들어, 8 개의 논리 코어가 구성되고 8 개의 논리 코어가 사용 가능한 시스템에서 &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; 옵션을 조합하면 2 개의 더티 CPU 스케줄러 스레드 (4의 50 %)가 발생합니다. 1 개의 더티 CPU 스케줄러 스레드가 온라인 상태입니다 (4의 25 %).</target>
        </trans-unit>
        <trans-unit id="1b1652a93096a292ea9f23a8fb30440e0918cbec" translate="yes" xml:space="preserve">
          <source>This option is a fast way to test whether a module will compile successfully. This is useful for code generators that want to verify the code that they emit. No code is generated. If warnings are enabled, warnings generated by the &lt;code&gt;erl_lint&lt;/code&gt; module (such as warnings for unused variables and functions) are also returned.</source>
          <target state="translated">이 옵션은 모듈이 성공적으로 컴파일되는지 테스트하는 빠른 방법입니다. 이는 생성하는 코드를 확인하려는 코드 생성기에 유용합니다. 코드가 생성되지 않습니다. 경고가 활성화되면 &lt;code&gt;erl_lint&lt;/code&gt; 모듈에서 생성 된 경고 (예 : 사용하지 않는 변수 및 함수에 대한 경고)도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc4c98f53e89f54019044a7876ab12f92896246" translate="yes" xml:space="preserve">
          <source>This option is experimental.</source>
          <target state="translated">이 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="bebef7a4d11a54b9572f9f20a10693f30204b1e4" translate="yes" xml:space="preserve">
          <source>This option is highly recommended. It makes &lt;code&gt;run_erl&lt;/code&gt; run in the background completely detached from any controlling terminal and the command returns to the caller immediately. Without this option, &lt;code&gt;run_erl&lt;/code&gt; must be started using several tricks in the shell to detach it completely from the terminal in use when starting it. The option must be the first argument to &lt;code&gt;run_erl&lt;/code&gt; on the command line.</source>
          <target state="translated">이 옵션을 적극 권장합니다. 그것은 만드는 &lt;code&gt;run_erl&lt;/code&gt; 완전히 즉시 발신자에 대한 제어 단자와 명령 반환에서 분리 백그라운드에서 실행. 이 옵션이 없으면 &lt;code&gt;run_erl&lt;/code&gt; 을 시작할 때 사용중인 터미널에서 완전히 분리하기 위해 쉘에서 여러 가지 트릭을 사용하여 시작해야합니다. 옵션은 명령 행 에서 &lt;code&gt;run_erl&lt;/code&gt; 의 첫 번째 인수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="799c0d875ea63318c2c432ae65671fb00f9b1962" translate="yes" xml:space="preserve">
          <source>This option is more useful. Here, reloading is queued if the driver is &lt;strong&gt;not&lt;/strong&gt; loaded by any other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, but the driver has opened ports, in which case &lt;code&gt;{ok, pending_driver}&lt;/code&gt; is returned (a &lt;code&gt;monitor&lt;/code&gt; option is recommended).</source>
          <target state="translated">이 옵션이 더 유용합니다. 여기서 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를 로드 &lt;strong&gt;하지&lt;/strong&gt; 않았지만 드라이버가 포트를 열면 다시로드가 대기됩니다. 이 경우 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 가 반환됩니다 ( &lt;code&gt;monitor&lt;/code&gt; 옵션 권장).</target>
        </trans-unit>
        <trans-unit id="25d785f39f2ca30f9744131492e2e56cf2d21d95" translate="yes" xml:space="preserve">
          <source>This option is not allowed on &lt;code&gt;raw&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 파일 에는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f286491eda734e921e24014e8a8a1eb9199ffbe" translate="yes" xml:space="preserve">
          <source>This option is not recommended.</source>
          <target state="translated">이 옵션은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f578117bb772460a22238ad9cfabbec82d626246" translate="yes" xml:space="preserve">
          <source>This option is only meaningful if option &lt;code&gt;binary&lt;/code&gt; was specified when the socket was created. If option &lt;code&gt;header&lt;/code&gt; is specified, the first &lt;code&gt;Size&lt;/code&gt; number bytes of data received from the socket are elements of a list, and the remaining data is a binary specified as the tail of the same list. For example, if &lt;code&gt;Size == 2&lt;/code&gt;, the data received matches &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 소켓이 작성 될 때 옵션 &lt;code&gt;binary&lt;/code&gt; 진이 지정된 경우에만 의미가 있습니다 . 옵션 &lt;code&gt;header&lt;/code&gt; 가 지정되면 소켓에서 수신 된 데이터 의 첫 번째 &lt;code&gt;Size&lt;/code&gt; 번호 바이트는 목록의 요소이며 나머지 데이터는 동일한 목록의 꼬리로 지정된 이진입니다. 예를 들어, &lt;code&gt;Size == 2&lt;/code&gt; 인 경우 수신 된 데이터는 &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6aa3b24e42c5627fceb7d3a4c574f35704adb386" translate="yes" xml:space="preserve">
          <source>This option is only supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;).</source>
          <target state="translated">이 옵션은 표준 쉘 ( &lt;code&gt;group.erl&lt;/code&gt; ) 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b072703d1b18dfc3f9f5977b6079b835f0224f83" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the parameters specific to the peer address specified by &lt;code&gt;address&lt;/code&gt; within the association specified by &lt;code&gt;assoc_id&lt;/code&gt;. Field &lt;code&gt;address&lt;/code&gt; fmust be set by the caller; all other fields are filled in on return. If &lt;code&gt;assoc_id = 0&lt;/code&gt; (default), the &lt;code&gt;address&lt;/code&gt; is automatically translated into the corresponding association ID. This option is rarely used. For the semantics of all fields, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 읽기 전용입니다. 이것은 피어에 의해 지정된 주소로 특정 파라미터 결정 &lt;code&gt;address&lt;/code&gt; 로 지정된 관계 내의 &lt;code&gt;assoc_id&lt;/code&gt; 를 . 발신자가 필드 &lt;code&gt;address&lt;/code&gt; 설정해야합니다. 다른 모든 필드는 반환시 채워집니다. 경우 &lt;code&gt;assoc_id = 0&lt;/code&gt; (디폴트)은 &lt;code&gt;address&lt;/code&gt; 자동 대응하는 연관 ID로 변환된다. 이 옵션은 거의 사용되지 않습니다. 모든 필드의 의미에 대해서는 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="195222e570592e1300b4b25ab1af9e1c8e8e90bb" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the status of the SCTP association specified by &lt;code&gt;assoc_id&lt;/code&gt;. The following are the possible values of &lt;code&gt;state&lt;/code&gt; (the state designations are mostly self-explanatory):</source>
          <target state="translated">이 옵션은 읽기 전용입니다. &lt;code&gt;assoc_id&lt;/code&gt; 로 지정된 SCTP 연관 상태를 판별합니다 . 다음은 가능한 &lt;code&gt;state&lt;/code&gt; 값입니다 (상태 지정은 대부분 설명이 필요함).</target>
        </trans-unit>
        <trans-unit id="2a7c2f54502986cac56e74f74f0507e617134fa9" translate="yes" xml:space="preserve">
          <source>This option is removed, it generates a fatal error if used.</source>
          <target state="translated">이 옵션은 제거되어 사용하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d0dc8c0d9bb7eab4181aa210080e8a3266e279c" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">이 옵션은 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0aa3e98f799062b3c35a4a811d03b341b1e599" translate="yes" xml:space="preserve">
          <source>This option is supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;), the 'oldshell' (&lt;code&gt;user.erl&lt;/code&gt;), and the file I/O servers.</source>
          <target state="translated">이 옵션은 표준 쉘 ( &lt;code&gt;group.erl&lt;/code&gt; ), 'oldshell'( &lt;code&gt;user.erl&lt;/code&gt; ) 및 파일 I / O 서버에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a3a12611755048747534c6172534fba6193da6" translate="yes" xml:space="preserve">
          <source>This option is to be used only while running &lt;code&gt;erts_alloc_config(3)&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt; when using the created configuration.</source>
          <target state="translated">이 옵션을 실행하는 동안에 만 사용되는 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; , &lt;strong&gt;하지&lt;/strong&gt; 생성 된 구성을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="889aee4f7fdaed4924ebd813f97d33cc589d7043" translate="yes" xml:space="preserve">
          <source>This option is typically used when building or modifying a PLT as in:</source>
          <target state="translated">이 옵션은 일반적으로 다음과 같이 PLT를 작성하거나 수정할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="edf2a03815bd1d16fe28550db84f5fb84528060e" translate="yes" xml:space="preserve">
          <source>This option is used to &lt;strong&gt;reload&lt;/strong&gt; a driver from disk, most often in a code upgrade scenario. Having a &lt;code&gt;reload&lt;/code&gt; option also implies that parameter &lt;code&gt;Path&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; need to be consistent with earlier loads of the driver.</source>
          <target state="translated">이 옵션은 코드 업그레이드 시나리오에서 디스크에서 드라이버 를 &lt;strong&gt;다시로드&lt;/strong&gt; 하는 데 사용됩니다 . 갖는 &lt;code&gt;reload&lt;/code&gt; 옵션도 해당 매개 변수의 의미 &lt;code&gt;Path&lt;/code&gt; 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 드라이버의 이전 부하와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d51f4b2d1bb2d48353207aa92dd60bc3873e9f8f" translate="yes" xml:space="preserve">
          <source>This option should be set to &lt;code&gt;false&lt;/code&gt; since a sufficiently malicious peer can otherwise cause large amounts of memory to be consumed when decoded Diameter messages are passed between processes. The default value is for backwards compatibility.</source>
          <target state="translated">디코딩 된 직경 메시지가 프로세스간에 전달 될 때 충분히 악의적 인 피어가 많은 양의 메모리를 소비 할 수 있으므로이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 . 기본값은 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="57817b80cdc930329e3a4d5793e370393a3211f0" translate="yes" xml:space="preserve">
          <source>This option specifies how basic mib data is stored. This option is used by two parts of the snmp agent: The mib-server and the symbolic-store.</source>
          <target state="translated">이 옵션은 기본 mib 데이터가 저장되는 방법을 지정합니다. 이 옵션은 snmp 에이전트의 두 부분 (mib-server 및 symbolic-store)에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff5c27e867a6f1798699a8d8412847ef2c9f83ca" translate="yes" xml:space="preserve">
          <source>This option specifies if the user shall be notified of received segment replies or not.</source>
          <target state="translated">이 옵션은 사용자에게 수신 된 세그먼트 응답에 대한 통지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e191bd75bc4b33a8992d72798fec2d5cb030668d" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific socket option &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt;, such as in Linux kernel 2.0.30 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">이 옵션은 Linux 커널 2.0.30 이상에서와 같이 Linux 특정 소켓 옵션 &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt; 를 사용 하므로 런타임 시스템이 해당 운영 체제 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2b531690e0f1058c69b2d245e35526e30090198c" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific syscall &lt;code&gt;setns()&lt;/code&gt;, such as in Linux kernel 3.0 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">이 옵션은 Linux 커널 3.0 이상과 같은 Linux 특정 syscall &lt;code&gt;setns()&lt;/code&gt; 하므로 런타임 시스템이 해당 운영 체제 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="44252bdcc3d79897b51179b686a1c2db9495ee64" translate="yes" xml:space="preserve">
          <source>This option will be removed in a future release. The return value will always be &lt;code&gt;false&lt;/code&gt;, as the &lt;code&gt;elib_malloc&lt;/code&gt; allocator has been removed.</source>
          <target state="translated">이 옵션은 다음 릴리스에서 제거 될 예정입니다. 반환 값은 항상있을 것입니다 &lt;code&gt;false&lt;/code&gt; 은 AS, &lt;code&gt;elib_malloc&lt;/code&gt; 의 할당이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0dabdcd13ff03271c7b6e7a946847dbd231dc01" translate="yes" xml:space="preserve">
          <source>This option will use a lot of memory when enabled, which must be reclaimed with &lt;code&gt;lcnt:rt_clear&lt;/code&gt;. Note that it makes no distinction between locks that were destroyed and locks for which counting was disabled, so enabling this option will disable changes to the lock category mask.</source>
          <target state="translated">이 옵션은 활성화 될 때 많은 메모리를 사용하며, &lt;code&gt;lcnt:rt_clear&lt;/code&gt; 로 교정해야합니다 . 소멸 된 잠금과 계산이 비활성화 된 잠금을 구분하지 않으므로이 옵션을 사용하면 잠금 범주 마스크에 대한 변경이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="63372d9f26162432c70de9dd21cb0a2fa14e443c" translate="yes" xml:space="preserve">
          <source>This package contains modules for handling abstract syntax trees (ASTs) in Erlang, in a way that is compatible with the &quot;abstract format&quot; parse trees of the stdlib module &lt;code&gt;erl_parse&lt;/code&gt;, together with utilities for reading source files, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt;, and doing &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; in Erlang.</source>
          <target state="translated">이 패키지에는 Erdlan의 추상 구문 트리 (AST)를 처리하기위한 모듈이 포함되어 있으며, stdlib 모듈 &lt;code&gt;erl_parse&lt;/code&gt; 의 &quot;추상 형식&quot;구문 분석 트리와 호환되며 소스 파일을 읽기위한 유틸리티, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt; Erlang에서 모듈 이름 바꾸기 , &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; 수행 .</target>
        </trans-unit>
        <trans-unit id="2aa90d46e1988deecd458f84f25660e5efaeb6ec" translate="yes" xml:space="preserve">
          <source>This page presents a summary of values from all allocators underneath it.</source>
          <target state="translated">이 페이지에는 그 아래에있는 모든 할당 자의 값이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="239f6919f70832c0fd44ac0346db01f8572c3052" translate="yes" xml:space="preserve">
          <source>This pair of functions are used when open ports to the driver are to be killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; to allow for new driver code to get loaded.</source>
          <target state="translated">이 드라이버 쌍은 &lt;code&gt;driver_unloaded&lt;/code&gt; 이유와 함께 드라이버에 대한 열린 포트를 강제 종료 하여 새 드라이버 코드를로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1602bf3b2d8c23237b0a61febcf52e3e006d8036" translate="yes" xml:space="preserve">
          <source>This pair of functions is used when reloading is to be done after the last open port to the driver is closed.</source>
          <target state="translated">이 기능 쌍은 드라이버에 대한 마지막 열린 포트가 닫힌 후 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f14b771e39c5dc99621a28cd9cae451233b4cbb8" translate="yes" xml:space="preserve">
          <source>This parameter contains a list of options that are given to &lt;code&gt;zip:create/3&lt;/code&gt; when application specific files are packaged into an archive. Only a subset of the options are supported. The most useful options in this context are the ones that control which types of files should be compressed. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 응용 프로그램 특정 파일이 아카이브에 패키지 될 때 &lt;code&gt;zip:create/3&lt;/code&gt; 에 제공되는 옵션 목록이 있습니다 . 옵션의 일부만 지원됩니다. 이 컨텍스트에서 가장 유용한 옵션은 압축 할 파일 형식을 제어하는 ​​옵션입니다. 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58e5c112e068eb199424c98749e9d0931666cadb" translate="yes" xml:space="preserve">
          <source>This parameter controls the application and escript inclusion policy. It defaults to &lt;code&gt;derived&lt;/code&gt; which means that the applications that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting, will only be included if any other (explicitly or implicitly included) application uses it. The value &lt;code&gt;include&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be included. &lt;code&gt;exclude&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be excluded.</source>
          <target state="translated">이 매개 변수는 응용 프로그램 및 escript 포함 정책을 제어합니다. 기본적으로 &lt;code&gt;derived&lt;/code&gt; &lt;code&gt;incl_cond&lt;/code&gt; 명시 적 incl_cond 설정 이없는 응용 프로그램이 다른 응용 프로그램에서 명시 적 또는 암시 적으로 포함 된 경우에만 포함됨을 의미합니다. &lt;code&gt;include&lt;/code&gt; 값 은 명시적인 &lt;code&gt;incl_cond&lt;/code&gt; 설정이 없는 모든 응용 프로그램 및 escript가 포함됨을 의미합니다 . &lt;code&gt;exclude&lt;/code&gt; 는 명시적인 &lt;code&gt;incl_cond&lt;/code&gt; 설정이 없는 모든 응용 프로그램 및 escript가 제외됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="43b8b48e3d3e4e5f584a2110e61fc94f1dda52fb" translate="yes" xml:space="preserve">
          <source>This parameter controls the default handling of the &lt;code&gt;app&lt;/code&gt; files when a target system is generated. It defaults to &lt;code&gt;keep&lt;/code&gt; which means that &lt;code&gt;app&lt;/code&gt; files are copied to the target system and their contents are kept as they are. &lt;code&gt;strip&lt;/code&gt; means that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file where the non included modules are removed from the file. &lt;code&gt;all&lt;/code&gt; does also imply that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file, with the difference that all included modules are added to the file. If the application does not have any &lt;code&gt;app&lt;/code&gt; file a file will be created for &lt;code&gt;all&lt;/code&gt; but not for &lt;code&gt;keep&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 대상 시스템이 생성 될 때 &lt;code&gt;app&lt;/code&gt; 파일 의 기본 처리를 제어합니다 . 기본값은 &lt;code&gt;keep&lt;/code&gt; 입니다. 즉, &lt;code&gt;app&lt;/code&gt; 파일이 대상 시스템에 복사되고 해당 내용이 그대로 유지됩니다. &lt;code&gt;strip&lt;/code&gt; 은 포함되지 않은 모듈이 파일에서 제거 된 원본 &lt;code&gt;app&lt;/code&gt; 파일 의 내용에서 새 &lt;code&gt;app&lt;/code&gt; 파일이 생성됨을 의미 합니다. &lt;code&gt;all&lt;/code&gt; 는 포함 된 모든 모듈이 파일에 추가되는 차이와 함께 원래 &lt;code&gt;app&lt;/code&gt; 파일 의 내용에서 새 &lt;code&gt;app&lt;/code&gt; 파일이 생성됨을 의미 합니다. 애플리케이션에 &lt;code&gt;app&lt;/code&gt; 이없는 경우파일은 &lt;code&gt;keep&lt;/code&gt; 및 &lt;code&gt;strip&lt;/code&gt; 위한 것이 아니라 &lt;code&gt;all&lt;/code&gt; 위해 생성 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="178517341ccd2e5776c2cccf896941a880130c85" translate="yes" xml:space="preserve">
          <source>This parameter controls the module inclusion policy. It defaults to &lt;code&gt;all&lt;/code&gt; which means that if an application is included (either explicitly or implicitly) all modules in that application will be included. This implies that both modules that exist in the &lt;code&gt;ebin&lt;/code&gt; directory of the application, as well as modules that are named in the &lt;code&gt;app&lt;/code&gt; file will be included. If the parameter is set to &lt;code&gt;ebin&lt;/code&gt;, both modules in the &lt;code&gt;ebin&lt;/code&gt; directory and derived modules are included. If the parameter is set to &lt;code&gt;app&lt;/code&gt;, both modules in the &lt;code&gt;app&lt;/code&gt; file and derived modules are included. &lt;code&gt;derived&lt;/code&gt; means that only modules that are used by other included modules are included. The &lt;code&gt;mod_cond&lt;/code&gt; setting on system level is used as default for all applications.</source>
          <target state="translated">이 매개 변수는 모듈 포함 정책을 제어합니다. 기본값은 &lt;code&gt;all&lt;/code&gt; 입니다. 즉, 응용 프로그램이 명시 적 또는 암시 적으로 포함 된 경우 해당 응용 프로그램의 모든 모듈이 포함됩니다. 이는 애플리케이션 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 존재 하는 모듈과 &lt;code&gt;app&lt;/code&gt; 파일에 이름이 지정된 모듈이 모두 포함됨을 의미합니다. 매개 변수가 &lt;code&gt;ebin&lt;/code&gt; 으로 설정 되면 &lt;code&gt;ebin&lt;/code&gt; 디렉토리의 모듈과 파생 모듈이 모두 포함됩니다. 매개 변수가 &lt;code&gt;app&lt;/code&gt; 으로 설정 되면 &lt;code&gt;app&lt;/code&gt; 파일의 모듈과 파생 모듈이 모두 포함됩니다. &lt;code&gt;derived&lt;/code&gt; 포함 된 다른 모듈에서 사용하는 모듈 만 포함됨을 의미합니다. 시스템 레벨 의 &lt;code&gt;mod_cond&lt;/code&gt; 설정은 모든 응용 프로그램의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f35dbde0b2e6b7417fe1079d2c8cb135463fb518" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the &lt;code&gt;erl&lt;/code&gt; executable in the target system should automatically determine where it is installed or if it should use a hardcoded path to the installation. In the latter case the target system must be installed with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be used. If the system is relocatable, the file tree containing the target system can be moved to another location without re-installation. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 대상 시스템 의 &lt;code&gt;erl&lt;/code&gt; 실행 파일이 설치 위치를 자동으로 결정해야하는지 또는 하드 코딩 된 설치 경로를 사용 해야하는지 여부를 제어합니다 . 후자의 경우 대상 시스템을 사용하기 전에 &lt;code&gt;reltool:install/2&lt;/code&gt; 와 함께 설치해야합니다 . 시스템을 재배치 할 수 있으면 대상 시스템을 포함하는 파일 트리를 다시 설치하지 않고 다른 위치로 이동할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18eec3d4c813ec5a22514b8e2727f74034894ae8" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the module is included or not. By default the &lt;code&gt;mod_cond&lt;/code&gt; parameter on application and system level will be used to control whether the module is included or not. The value of &lt;code&gt;incl_cond&lt;/code&gt; overrides the module inclusion policy. &lt;code&gt;include&lt;/code&gt; implies that the module is included, while &lt;code&gt;exclude&lt;/code&gt; implies that the module is not included. &lt;code&gt;derived&lt;/code&gt; implies that the module is included if it is used by any other included module.</source>
          <target state="translated">이 매개 변수는 모듈의 포함 여부를 제어합니다. 기본적 으로 응용 프로그램 및 시스템 레벨 의 &lt;code&gt;mod_cond&lt;/code&gt; 매개 변수는 모듈의 포함 여부를 제어하는 ​​데 사용됩니다. &lt;code&gt;incl_cond&lt;/code&gt; 값은 모듈 포함 정책을 재정의합니다. &lt;code&gt;include&lt;/code&gt; 은 모듈이 포함되어 있음을 의미하고 &lt;code&gt;exclude&lt;/code&gt; 는 모듈이 포함되어 있지 않음을 의미합니다. &lt;code&gt;derived&lt;/code&gt; 은 포함 된 다른 모듈에서 모듈을 사용하는 경우 포함 된 모듈임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="40145ab28fcdbc933f15879eca2c3243c28ec539" translate="yes" xml:space="preserve">
          <source>This parameter defines the error report type used when messages are sent to error logger using the default callback function. Default is &lt;code&gt;std_error&lt;/code&gt;, which means the events are handled by the standard event handler.</source>
          <target state="translated">이 매개 변수는 기본 콜백 함수를 사용하여 메시지가 오류 로거에 전송 될 때 사용되는 오류 보고서 유형을 정의합니다. 기본값은 &lt;code&gt;std_error&lt;/code&gt; 입니다 . 이는 표준 이벤트 핸들러가 이벤트를 처리 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d8e1e13f6286b2183d8789f9f0f1c181e848b5c7" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;lib_dir&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;lib_dir&lt;/code&gt; 과 상호 배타적입니다 . 경우 &lt;code&gt;vsn&lt;/code&gt; 및 &lt;code&gt;lib_dir&lt;/code&gt; 가 모두 생략 최신 버전이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e97c191330c9143719f39676fbf0d64a524888a9" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;vsn&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;vsn&lt;/code&gt; 과 상호 배타적입니다 . 경우 &lt;code&gt;vsn&lt;/code&gt; 및 &lt;code&gt;lib_dir&lt;/code&gt; 가 모두 생략 최신 버전이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fccea6e9894e7980e5b72b89472e98f04ef2c3ca" translate="yes" xml:space="preserve">
          <source>This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;dateTime&lt;/code&gt; 유형 이며 RFC 3339를 준수합니다. 구현은 시간대를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="950fdba8a7f8faa27a2238104e4fbd9416d168d5" translate="yes" xml:space="preserve">
          <source>This parameter is the name of the driver to be used in subsequent calls to function &lt;code&gt;erlang:open_port&lt;/code&gt; in ERTS. The name can be specified as an &lt;code&gt;iolist()&lt;/code&gt; or an &lt;code&gt;atom()&lt;/code&gt;. The name specified when loading is used to find the object file (with the help of &lt;code&gt;Path&lt;/code&gt; and the system-implied extension suffix, that is, &lt;code&gt;.so&lt;/code&gt;). The name by which the driver identifies itself must also be consistent with this &lt;code&gt;Name&lt;/code&gt; parameter, much as the module name of a Beam file much corresponds to its filename.</source>
          <target state="translated">이 매개 변수는 ERTS의 &lt;code&gt;erlang:open_port&lt;/code&gt; 함수에 대한 후속 호출에 사용될 드라이버의 이름입니다 . 이름은 &lt;code&gt;iolist()&lt;/code&gt; 또는 &lt;code&gt;atom()&lt;/code&gt; 으로 지정할 수 있습니다 . 로드 할 때 지정된 이름은 &lt;code&gt;Path&lt;/code&gt; 및 시스템 암시 적 확장자 접미어 (즉, &lt;code&gt;.so&lt;/code&gt; )를 사용하여 오브젝트 파일을 찾는 데 사용됩니다 . 빔 파일의 모듈 이름이 해당 파일 이름과 거의 일치하므로 드라이버가 자신을 식별하는 이름도이 &lt;code&gt;Name&lt;/code&gt; 매개 변수 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44b3acd62887c89fa3ae2ebe622fc74f4ca003b3" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_app_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 일반적으로 대상 시스템에 포함하지 않아야하는 응용 프로그램 특정 파일을 제어하는 ​​정규식 목록을 포함합니다. 주문을 포함하여, 파일은 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_app_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_app_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f82af56ab8d93da6eddb3eddde55461bf95b47f" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files that should be included. Each file in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 포함 할 애플리케이션 특정 파일을 제어하는 ​​정규식 목록이 포함됩니다. 포함 시키려면 응용 프로그램의 각 파일이 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_app_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a274c6a75bab058057d8bad1dd9c6f7fc4d783d1" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should be included. Each file in the target system must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt; in order to be included. Which application files should be included is controlled with the parameters &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 시스템에 포함 할 파일을 제어하는 ​​정규식 목록이 포함됩니다. 대상 시스템의 각 파일이 포함 되려면 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_sys_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 포함 할 애플리케이션 파일은 &lt;code&gt;incl_app_filters&lt;/code&gt; 및 &lt;code&gt;excl_app_filters&lt;/code&gt; 매개 변수로 제어됩니다 . 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="110f1ed95034cf6ba82c260c7d3422382ccf8b06" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_sys_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 대상 시스템에 포함되지 않아야하는 시스템의 파일을 제어하는 ​​정규식 목록이 포함됩니다. 주문을 포함하여, 파일은 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_sys_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_sys_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff17bba9924b137232a805ed2fc26cbf5b146168" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should be included in an archive file (as opposed to being included as a regular directory outside the archive). Each top directory in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 아카이브 외부의 일반 디렉토리로 포함되는 것과 달리 아카이브 파일에 포함되어야하는 애플리케이션의 최상위 디렉토리를 제어하는 ​​정규식 목록이 포함됩니다. 포함 시키려면 응용 프로그램의 각 최상위 디렉토리가 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_app_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8cccf208765941cdf1852be703e61e2a97e335ee" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should not be included in an archive file. In order to be included in the application archive, a top directory must match some filter in &lt;code&gt;incl_archive_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_archive_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 아카이브 파일에 포함하지 않아야하는 애플리케이션의 최상위 디렉토리를 제어하는 ​​정규식 목록이 포함됩니다. 주문이 응용 프로그램 아카이브에 포함하여, 최고 디렉토리는 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_archive_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_archive_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28343ed29b2c1e141aa76f8b0c8cab09dcd45849" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the Erlang emulator is statically installed at the client node. A node with a static emulator cannot dynamically switch to a new emulator, as the executable files are statically written into memory.</source>
          <target state="translated">이 매개 변수는 Erlang 에뮬레이터가 클라이언트 노드에 정적으로 설치되는지 여부를 지정합니다. 실행 파일이 정적으로 메모리에 기록되므로 정적 에뮬레이터가있는 노드는 새 에뮬레이터로 동적으로 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d50377640826220d17a47ef2e3ec41045600adb8" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 부분은 대상 노드에서 수행 &lt;code&gt;-heart&lt;/code&gt; 예제에서는 노드가 자동으로 다시 시작될 수 있도록 -heart 옵션을 사용하여 임베디드 시스템으로 실행되도록 합니다. 자세한 정보 &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bac7f8bcb72cbf602859c2bbd2ca1accde6e195" translate="yes" xml:space="preserve">
          <source>This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to</source>
          <target state="translated">우리가 연구 한이 특정 예제 패턴에는 중첩 된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치시키기 위해 소유 수량화 도구를 사용하는 것이 중요합니다. 예를 들어이 패턴이</target>
        </trans-unit>
        <trans-unit id="cafdded1913809a983e1e03ea48bb5d4d797a73a" translate="yes" xml:space="preserve">
          <source>This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split.</source>
          <target state="translated">이 특정 그룹은 두 문자 시퀀스 CR 다음에 LF 또는 단일 문자 LF (행 피드, U + 000A), VT (수직 탭, U + 000B), FF (양식 피드, U + 000C) 중 하나와 일치합니다. , CR (캐리지 리턴, U + 000D) 또는 NEL (다음 줄, U + 0085). 두 문자 시퀀스는 분리 할 수없는 단일 단위로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fd9cfe743405ab50e9a660ad376f4821d6a0dd" translate="yes" xml:space="preserve">
          <source>This particular server probably does not use heap memory worth hibernating for. To gain anything from hibernation, your server would have to produce non-insignificant garbage during callback execution, for which this example server can serve as a bad example.</source>
          <target state="translated">이 특정 서버는 아마도 최대 절전 모드의 힙 메모리를 사용하지 않을 것입니다. 최대 절전 모드에서 무언가를 얻으려면 서버가 콜백 실행 중에 중요하지 않은 가비지를 생성해야합니다.이 예제 서버는 나쁜 예제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dff69f09f8373963a046e44d87eb56b39d18544d" translate="yes" xml:space="preserve">
          <source>This pattern matches &lt;code&gt;a\nb&lt;/code&gt;, as LF is no longer a newline. If more than one of them is present, the last one is used.</source>
          <target state="translated">LF는 더 이상 줄 바꿈이 아니므 &lt;code&gt;a\nb&lt;/code&gt; 패턴은 a \ nb 와 일치 합니다 . 둘 이상이 존재하면 마지막 것이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f3552b260ce80c8512e7857145bb94d23327e2" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="translated">이 단계는 사용자가 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt; 를 호출하여 시간 오프셋을 완료하면 시작됩니다 . 마무리는 한 번만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac25d4a9fb597e683c9984270c084780c2dc2975" translate="yes" xml:space="preserve">
          <source>This phase starts when the runtime system starts. A preliminary time offset based on current OS system time is determined. This offset is from now on to be fixed during the whole preliminary phase.</source>
          <target state="translated">이 단계는 런타임 시스템이 시작될 때 시작됩니다. 현재 OS 시스템 시간에 따른 예비 시간 오프셋이 결정됩니다. 이 오프셋은 지금부터 전체 예비 단계에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="a659cf785f049a86d756b9c813aaeb6a80c02b1c" translate="yes" xml:space="preserve">
          <source>This port is to represent the result of an accept operation. It is created when one wants to accept from a listen socket, and it is converted to a &lt;code&gt;portTypeCommand&lt;/code&gt; when the accept succeeds.</source>
          <target state="translated">이 포트는 승인 조작의 결과를 나타냅니다. 청취 소켓에서 승인하려고 할 때 작성 되며 승인이 성공하면 &lt;code&gt;portTypeCommand&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d46acb6abe2d76532e14cb270ed2c145b67edbb" translate="yes" xml:space="preserve">
          <source>This prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures, such as process identifiers, refs, and funs), and creation of new external function references. None of those resources are garbage collected, so unchecked creation of them can exhaust available memory.</source>
          <target state="translated">이것은 새로운 원자의 생성, 간접적으로 새로운 원자의 생성 (프로세스 식별자, 참조 및 펀 (fun)과 같은 특정 구조에 내장되어 있음) 및 새로운 외부 함수 참조의 생성을 방지합니다. 이러한 리소스는 가비지 수집되지 않으므로 확인하지 않은 생성은 사용 가능한 메모리를 소모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="161ffdf8aa7fe91e902cf0c46062cf3c8c9ce913" translate="yes" xml:space="preserve">
          <source>This problem does not exist if all nodes are Erlang nodes.</source>
          <target state="translated">모든 노드가 Erlang 노드 인 경우이 문제가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="970e9bfda49ef81fc9970f5d3a17505b795bc146" translate="yes" xml:space="preserve">
          <source>This problem is best solved by using Mnesia instead.</source>
          <target state="translated">이 문제는 대신 Mnesia를 사용하여 해결하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c05999f98fd47b44ec0f00834f055638c5316ef" translate="yes" xml:space="preserve">
          <source>This process cannot run in multiple instances on the same hardware. OS_Mon must be configured to start &lt;code&gt;os_sup&lt;/code&gt; on one node only if two or more Erlang nodes execute on the same machine.</source>
          <target state="translated">이 프로세스는 동일한 하드웨어의 여러 인스턴스에서 실행될 수 없습니다. 동일한 기계에서 둘 이상의 Erlang 노드가 실행되는 경우에만 하나의 노드에서 &lt;code&gt;os_sup&lt;/code&gt; 을 시작하도록 OS_Mon 을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb9e5caa10f9724817c37ffd6b5d433a1304dd3" translate="yes" xml:space="preserve">
          <source>This process executes &lt;code&gt;tut15:pong()&lt;/code&gt;. &lt;code&gt;Pong_PID&lt;/code&gt; is the process identity of the &quot;pong&quot; process. The function &lt;code&gt;start&lt;/code&gt; now creates another process &quot;ping&quot;:</source>
          <target state="translated">이 프로세스는 &lt;code&gt;tut15:pong()&lt;/code&gt; 실행 합니다. &lt;code&gt;Pong_PID&lt;/code&gt; 는 &quot;pong&quot;프로세스의 프로세스 ID입니다. 함수 &lt;code&gt;start&lt;/code&gt; 이제 다른 프로세스 &quot;ping&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54ffc50690eb1a1de62954626b5c9e0167a4eba5" translate="yes" xml:space="preserve">
          <source>This process executes:</source>
          <target state="translated">이 프로세스는 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="327419876abc14c730314a0010b944c17b63d4fa" translate="yes" xml:space="preserve">
          <source>This program aids release handling on Windows systems. The program is to be called by the &lt;code&gt;erlsrv&lt;/code&gt; program, read up the release data file &lt;code&gt;start_erl.data&lt;/code&gt;, and start Erlang. Some options to &lt;code&gt;start_erl&lt;/code&gt; are added and removed by the release handler during upgrade with emulator restart (more specifically option &lt;code&gt;-data&lt;/code&gt;).</source>
          <target state="translated">이 프로그램은 Windows 시스템에서의 릴리스 처리에 도움이됩니다. 이 프로그램은 &lt;code&gt;erlsrv&lt;/code&gt; 프로그램에 의해 호출되고 릴리스 데이터 파일 &lt;code&gt;start_erl.data&lt;/code&gt; 를 읽고 Erlang을 시작합니다. &lt;code&gt;start_erl&lt;/code&gt; 에 대한 일부 옵션 은 에뮬레이터 재시작으로 업그레이드하는 동안 릴리스 핸들러에 의해 추가 및 제거됩니다 (특히 &lt;code&gt;-data&lt;/code&gt; 옵션 ).</target>
        </trans-unit>
        <trans-unit id="670a2482a63126e58239dc332359f8bc1dff0e73" translate="yes" xml:space="preserve">
          <source>This program is called when the machine is started. It can be modified or rewritten to suit a special system. By default, it must be called &lt;code&gt;start&lt;/code&gt; and reside in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. Another start program can be used, by using configuration parameter &lt;code&gt;start_prg&lt;/code&gt; in application SASL.</source>
          <target state="translated">이 프로그램은 기계가 시작될 때 호출됩니다. 특수 시스템에 맞게 수정하거나 다시 작성할 수 있습니다. 기본적으로 &lt;code&gt;start&lt;/code&gt; 라고 하며 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 에 있어야합니다 . 응용 프로그램 SASL에서 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 를 사용하여 다른 시작 프로그램을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4747c1263fbc28b515ca78f638cbd9259a9eb523" translate="yes" xml:space="preserve">
          <source>This program is distributed both in compiled form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\bin) and in source form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\src). The purpose of the source code is to ease customization of the program for local needs, such as cyclic restart detection. There is also a &quot;make&quot;-file, written for the &lt;code&gt;nmake&lt;/code&gt; program distributed with Microsoft Visual C++. This program can, however, be compiled with any Win32 C compiler (possibly with minor modifications).</source>
          <target state="translated">이 프로그램은 컴파일 된 형태 (&amp;lt;Erlang root&amp;gt; \\ erts- &amp;lt;version&amp;gt; \\ bin)와 소스 형태 (&amp;lt;Erlang root&amp;gt; \\ erts- &amp;lt;version&amp;gt; \\ src)로 배포됩니다. 소스 코드의 목적은 주기적 재시작 감지와 같은 로컬 요구에 맞게 프로그램을 쉽게 사용자 정의 할 수 있도록하는 것입니다. Microsoft Visual C ++로 배포 된 &lt;code&gt;nmake&lt;/code&gt; 프로그램 용으로 작성된 &quot;make&quot;파일도 있습니다 . 그러나이 프로그램은 모든 Win32 C 컴파일러로 컴파일 할 수 있습니다 (사소한 수정이있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="5fbfadc49450aec422c508001aa868916550a963" translate="yes" xml:space="preserve">
          <source>This program is to set static parameters and environment variables such as &lt;code&gt;-sname Name&lt;/code&gt; and &lt;code&gt;HEART_COMMAND&lt;/code&gt; to reboot the machine.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;-sname Name&lt;/code&gt; 및 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 와 같은 정적 매개 변수 및 환경 변수를 설정 하여 시스템을 재부팅합니다.</target>
        </trans-unit>
        <trans-unit id="c3f3c1fffec91449fdead388f394beeb915ca247" translate="yes" xml:space="preserve">
          <source>This program is used to attach to a running Erlang runtime system, started with &lt;code&gt;run_erl&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;run_erl&lt;/code&gt; 로 시작하여 실행중인 Erlang 런타임 시스템에 연결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f003599afc35a270db5f4b7d7b284e4c9e32aee" translate="yes" xml:space="preserve">
          <source>This program is used to start the emulator, but you will not be connected to the shell. &lt;code&gt;to_erl&lt;/code&gt; is used to connect to the Erlang shell.</source>
          <target state="translated">이 프로그램은 에뮬레이터를 시작하는 데 사용되지만 셸에 연결되지는 않습니다. &lt;code&gt;to_erl&lt;/code&gt; 은 Erlang 쉘에 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6687161d9309502a24c4f52312cb9d9b40349c81" translate="yes" xml:space="preserve">
          <source>This program starts the Erlang emulator with parameters &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; set. It reads data about where these files are located from a file named &lt;code&gt;start_erl.data&lt;/code&gt;, which is located in &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt;. Each new release introduces a new data file. This file is automatically generated by the release handler in Erlang.</source>
          <target state="translated">이 프로그램은 매개 변수 &lt;code&gt;-boot&lt;/code&gt; 및 &lt;code&gt;-config&lt;/code&gt; 를 사용 하여 Erlang 에뮬레이터를 시작합니다 . &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 에있는 &lt;code&gt;start_erl.data&lt;/code&gt; 파일에서 이러한 파일이있는 위치에 대한 데이터를 읽습니다 . 각각의 새로운 릴리스에는 새로운 데이터 파일이 도입되었습니다. 이 파일은 Erlang의 릴리스 핸들러에 의해 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8f257f89dea065885b66a0cd478fca5389333698" translate="yes" xml:space="preserve">
          <source>This property is only valid if &lt;code&gt;auto_ack&lt;/code&gt; is true.</source>
          <target state="translated">이 속성은 &lt;code&gt;auto_ack&lt;/code&gt; 이 true 인 경우에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="5810ec17d7cb173c4fccedc7a14810f5d07c123d" translate="yes" xml:space="preserve">
          <source>This puts less load on the filesystem, but much more on the Erlang runtime system.</source>
          <target state="translated">이것은 파일 시스템에 적은 부하를 주지만 Erlang 런타임 시스템에는 더 많은 부하를줍니다.</target>
        </trans-unit>
        <trans-unit id="fe519e24650180a3fcf221d96e6f790286d56794" translate="yes" xml:space="preserve">
          <source>This query also removes duplicates but the answers are sorted. If there are many answers, temporary files are used. Notice that to get the first unique answer, all answers must be found and sorted. Both alternatives find duplicates by comparing answers, that is, if &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt; are answers found in that order, then &lt;code&gt;A2&lt;/code&gt; is a removed if &lt;code&gt;A1 == A2&lt;/code&gt;.</source>
          <target state="translated">이 쿼리는 중복 항목도 제거하지만 답변은 정렬됩니다. 많은 답변이있는 경우 임시 파일이 사용됩니다. 첫 번째 고유 답변을 얻으려면 모든 답변을 찾아서 정렬해야합니다. 두 대안 모두 답을 비교하여 중복을 찾습니다. 즉 &lt;code&gt;A1&lt;/code&gt; 과 &lt;code&gt;A2&lt;/code&gt; 가 순서대로 찾은 답 이면 &lt;code&gt;A1 == A2&lt;/code&gt; 경우 &lt;code&gt;A2&lt;/code&gt; 가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2f6bad75f3fbef13092a6a4222f43094d545fae" translate="yes" xml:space="preserve">
          <source>This query hits the feature of partially bound keys in table type &lt;code&gt;ordered_set&lt;/code&gt;, so that not the whole table needs to be searched, only the part containing keys beginning with &lt;code&gt;0&lt;/code&gt; is looked into.</source>
          <target state="translated">이 쿼리는 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에서 부분적으로 바인딩 된 키의 기능을 수행 하므로 전체 테이블을 검색 할 필요가 없으며 &lt;code&gt;0&lt;/code&gt; 으로 시작하는 키를 포함하는 부분 만 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="9e6a7904ebcd7549f287cc377bc5ea8dfe7feaba" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="translated">이 난수 생성기는 암호화 적으로 강력하지 않습니다. 강력한 암호화 난수 생성기가 필요한 경우 &lt;code&gt;crypto&lt;/code&gt; 모듈 의 기능 중 하나를 사용하십시오 ( 예 &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4aeff4461a7bf1567cdb7c34105213973f7dd8" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_all&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my_all&lt;/code&gt; 애플리케이션 에서 &lt;code&gt;logger&lt;/code&gt; 구성 매개 변수를 읽고 구성된 핸들러를 시작합니다. 구성의 내용은 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt; 과 동일한 규칙을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd05537434a4630f9db4b01dfd929c70a6829e0d" translate="yes" xml:space="preserve">
          <source>This reads the entire contents of &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; into the specified registry. After the restore, all the objects in the registry are marked as unmodified, so a later backup only affects objects that you have modified since the restore.</source>
          <target state="translated">&lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 의 전체 내용을 지정된 레지스트리로 읽습니다 . 복원 후 레지스트리의 모든 오브젝트가 수정되지 않은 것으로 표시되므로 이후 백업은 복원 이후 수정 한 오브젝트에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="13a79d754831b14cd54b94d9e66117a733bf984b" translate="yes" xml:space="preserve">
          <source>This reference manual describes types generated from the types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hiearchy, which makes them kind of hard to read.</source>
          <target state="translated">이 참조 매뉴얼은 &lt;code&gt;gen_statem&lt;/code&gt; 소스 코드 의 유형에서 생성 된 유형을 설명 하므로 올바른 유형입니다. 그러나 생성 된 설명은 유형의 귀를 반영하기 때문에 읽기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="1c8060b97047d75217dfaa592520c89dd24db028" translate="yes" xml:space="preserve">
          <source>This renders a result similar to the following:</source>
          <target state="translated">결과는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9f783544c6147fb46866ca14f57f1cf28fd64491" translate="yes" xml:space="preserve">
          <source>This request asks for a complete list of all options supported by the I/O server as well as their current values.</source>
          <target state="translated">이 요청은 I / O 서버가 지원하는 모든 옵션과 현재 값의 전체 목록을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="c9ef467065f7f3147aa63fa765e54a5cacd5c45f" translate="yes" xml:space="preserve">
          <source>This request is not really used, it is to be regarded as a debug feature.</source>
          <target state="translated">이 요청은 실제로 사용되지 않으며 디버그 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed5461b3e3a2705d00654ef7851baa95f3c5a7b" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt;net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="translated">이 요청은 Erlang 함수 &lt;code&gt;net_adm:names/1,2&lt;/code&gt; 를 통해 사용됩니다 . EPMD에 대한 TCP 연결이 열리고이 요청이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fa4697a836ae0380ae5f8e0e273aa79c5259e1e7" translate="yes" xml:space="preserve">
          <source>This request kills the running EPMD. It is almost never used.</source>
          <target state="translated">이 요청은 실행중인 EPMD를 종료합니다. 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37139085c2a33777870615ebb189dd29f4711b3" translate="yes" xml:space="preserve">
          <source>This results in the following record:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6a3367c426977d974ddf7ae39a973d34adfaba6" translate="yes" xml:space="preserve">
          <source>This results in the following records:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4754bd22d399a2af6e9567cb4368afe4e9a97e68" translate="yes" xml:space="preserve">
          <source>This return value is valid even if option &lt;code&gt;kill_ports&lt;/code&gt; was used, as killing ports can be a process that does not complete immediately. However, the condition is in that case transient. Monitors are always useful to detect when the driver is really unloaded.</source>
          <target state="translated">killing port는 즉시 완료되지 않는 프로세스 일 수 있으므로 &lt;code&gt;kill_ports&lt;/code&gt; 옵션 이 사용 된 경우 에도이 리턴 값은 유효 합니다. 그러나이 경우 조건은 일시적입니다. 모니터는 드라이버가 실제로 언로드되는시기를 감지하는 데 항상 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61bce59fa6b3bc349ada24ae6e1accf7342572aa" translate="yes" xml:space="preserve">
          <source>This returns the driver structure. The macro &lt;code&gt;DRIVER_INIT&lt;/code&gt; defines the only exported function. All the other functions are static, and will not be exported from the library.</source>
          <target state="translated">드라이버 구조를 반환합니다. 매크로 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 는 내 보낸 유일한 함수를 정의합니다. 다른 모든 함수는 정적이며 라이브러리에서 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="236d4116cd1bd104778ca12a47df3dca542bc4b6" translate="yes" xml:space="preserve">
          <source>This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result.</source>
          <target state="translated">이렇게하면 먼저 키 값을 가져 와서 저장된 값 목록에 새 값을 추가하고 결과를 저장하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="31f5366cf36758d97de45b416b180fe5021204ef" translate="yes" xml:space="preserve">
          <source>This scenario can occur if the driver code needs replacement during operation of the Erlang emulator. Implementing driver code replacement is a little more tedious than Beam code replacement, as one driver cannot be loaded as both &quot;old&quot; and &quot;new&quot; code. All &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded.</source>
          <target state="translated">이 시나리오는 Erlang 에뮬레이터 작동 중에 드라이버 코드를 교체해야하는 경우 발생할 수 있습니다. 하나의 드라이버를 &quot;오래된&quot;코드와 &quot;새로운&quot;코드로로드 할 수 없으므로 드라이버 코드 대체를 구현하는 것이 Beam 코드 대체보다 약간 지루합니다. 이전 코드를 언로드하고 새 코드를로드하려면 드라이버의 모든 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 포트를 열지 않은 상태에서 드라이버를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="503f88b8d41295f847befbf0174f96b5e1d17d21" translate="yes" xml:space="preserve">
          <source>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called &quot;dirty operations&quot;. The use of nested transactions is also described. The following topics are included:</source>
          <target state="translated">이 섹션에서는 또한 테이블 잠금 및 고정 잠금을 포함한 잠금 기능과 속도 향상 및 오버 헤드 감소를 위해 트랜잭션 시스템을 우회하는 대체 기능에 대해 설명합니다. 이러한 기능을 &quot;더러운 작업&quot;이라고합니다. 중첩 트랜잭션 사용에 대해서도 설명합니다. 다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ca13c61387c20120a915aa2aba2a70b09cc77ff8" translate="yes" xml:space="preserve">
          <source>This section contains information about all loaded modules.</source>
          <target state="translated">이 섹션에는로드 된 모든 모듈에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0afb7bdb78aa30270d4c5341a78528374ecd48c" translate="yes" xml:space="preserve">
          <source>This section contains information about all the ETS tables in the system. The following fields are of interest for each table:</source>
          <target state="translated">이 섹션에는 시스템의 모든 ETS 테이블에 대한 정보가 있습니다. 각 테이블에서 다음 필드가 관심 대상입니다.</target>
        </trans-unit>
        <trans-unit id="c705a253aaab772432302fcb590c6d71895de050" translate="yes" xml:space="preserve">
          <source>This section contains information about all the timers started with the BIFs &lt;code&gt;erlang:start_timer/3&lt;/code&gt; and &lt;code&gt;erlang:send_after/3&lt;/code&gt;. The following fields exist for each timer:</source>
          <target state="translated">이 절에는 BIF &lt;code&gt;erlang:start_timer/3&lt;/code&gt; 및 &lt;code&gt;erlang:send_after/3&lt;/code&gt; 로 시작된 모든 타이머에 대한 정보가 있습니다 . 각 타이머에 대해 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e593d062792a79977388f9b736ca5fdb84956c5e" translate="yes" xml:space="preserve">
          <source>This section contains simple introductory examples only. For a full description of the QLC query language, see the &lt;code&gt;qlc&lt;/code&gt; manual page in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">이 섹션에는 간단한 소개 예제 만 포함되어 있습니다. QLC 조회 언어에 대한 전체 설명은 &lt;code&gt;STDLIB&lt;/code&gt; 의 &lt;code&gt;qlc&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="388bc7f1102a9ae9f2581325e4b4730cdd3f0142" translate="yes" xml:space="preserve">
          <source>This section demonstrates how simple it is to write a basic (yet for many module testing purposes, often sufficiently complex) test suite and execute its test cases. This is not necessarily obvious when you read the remaining sections in this User's Guide.</source>
          <target state="translated">이 섹션에서는 기본 (많은 모듈 테스트 목적으로, 종종 복잡한 경우) 테스트 스위트를 작성하고 테스트 사례를 실행하는 것이 얼마나 간단한지를 보여줍니다. 이 사용 설명서의 나머지 섹션을 읽을 때 반드시 명확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e57241c5a98cbdf10642d048108a7272df13ecae" translate="yes" xml:space="preserve">
          <source>This section describes a simple driver for accessing a postgres database using the libpq C client library. Postgres is used because it is free and open source. For information on postgres, see &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 libpq C 클라이언트 라이브러리를 사용하여 postgres 데이터베이스에 액세스하기위한 간단한 드라이버에 대해 설명합니다. Postgres는 무료이며 오픈 소스이기 때문에 사용됩니다. postgres에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8941b0891a6ff874af251fbb759dca478d13c6f3" translate="yes" xml:space="preserve">
          <source>This section describes examples of how to use the Public Key API. Keys and certificates used in the following sections are generated only for testing the Public Key application.</source>
          <target state="translated">이 섹션에서는 공개 키 API를 사용하는 방법에 대한 예를 설명합니다. 다음 섹션에서 사용되는 키와 인증서는 공개 키 응용 프로그램을 테스트하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ba0088de53a90de56e1f80e0ac3933382d74faf7" translate="yes" xml:space="preserve">
          <source>This section describes how an embedded system is started. Four programs are involved and they normally reside in the directory &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. The only exception is the &lt;code&gt;start&lt;/code&gt; program, which can be located anywhere, and is also the only program that must be modified by the user.</source>
          <target state="translated">이 절에서는 내장 시스템이 시작되는 방법에 대해 설명합니다. 네 개의 프로그램이 관련되며 일반적으로 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 디렉토리에 있습니다. 유일한 예외는 &lt;code&gt;start&lt;/code&gt; 프로그램이며 어디에서나 찾을 수 있으며 사용자가 수정해야하는 유일한 프로그램이기도합니다.</target>
        </trans-unit>
        <trans-unit id="5dffe6465a9a88971444b067aa33f3c613e2da6a" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang distribution can use TLS to get extra verification and security.</source>
          <target state="translated">이 섹션에서는 Erlang 배포가 TLS를 사용하여 추가 확인 및 보안을 얻는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7ba1b8e520e730aff5ce60b5891f8456502ebe16" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang runtime system is configured for IP communication. It also explains how you can configure it for your needs by a configuration file. The information is primarily intended for users with special configuration needs or problems. There is normally no need for specific settings for Erlang to function properly on a correctly IP-configured platform.</source>
          <target state="translated">이 섹션에서는 Erlang 런타임 시스템이 IP 통신을 위해 구성되는 방법에 대해 설명합니다. 또한 구성 파일로 필요에 맞게 구성하는 방법에 대해서도 설명합니다. 이 정보는 주로 특수한 구성 요구 또는 문제가있는 사용자를위한 것입니다. Erlang이 올바르게 IP 구성 플랫폼에서 제대로 작동하기 위해서는 특정 설정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ba9d8ce48a5e18d389572e80e439e457082f15" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install Cygwin, MSYS or MSYS2.</source>
          <target state="translated">이 섹션에서는 Windows에서 Erlang 에뮬레이터 및 OTP 라이브러리를 빌드하는 방법에 대해 설명합니다. Windows 바이너리 릴리스는 Microsoft의 개발 도구가 없거나 Cygwin, MSYS 또는 MSYS2를 설치하지 않으려는 경우 여전히 선호되는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="23b49078ad714b83061016b41c527ea88a0ef01c" translate="yes" xml:space="preserve">
          <source>This section describes how to build your own driver for Erlang.</source>
          <target state="translated">이 섹션에서는 Erlang 용 고유 드라이버를 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9ea8a2e527669401063f6aeee8dc65aebcbab675" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative carrier protocol for the Erlang distribution. The distribution is normally carried by TCP/IP. Here is explained a method for replacing TCP/IP with another protocol.</source>
          <target state="translated">이 섹션에서는 Erlang 배포를위한 대체 반송파 프로토콜을 구현하는 방법에 대해 설명합니다. 분배는 일반적으로 TCP / IP에 의해 수행됩니다. 다음은 TCP / IP를 다른 프로토콜로 바꾸는 방법에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="ef9194590c5bbba89fd68a31ae7705b884e62724" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative discovery mechanism for Erlang distribution. Discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port discovery.</source>
          <target state="translated">이 섹션에서는 Erlang 배포를위한 대체 검색 메커니즘을 구현하는 방법에 대해 설명합니다. 감지는 일반적으로 포트 감지를 위해 DNS 및 EPMD (Erlang Port Mapper Daemon)를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="62a63b1a98e975cb1778e4a9f8ed67fec8fb504f" translate="yes" xml:space="preserve">
          <source>This section describes how to write a Net if process.</source>
          <target state="translated">이 섹션에서는 Net if 프로세스를 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a5a2806882d6d1e2d41fb571e953fc2694d49bf3" translate="yes" xml:space="preserve">
          <source>This section describes how to write a process that complies to the OTP design principles, without using a standard behaviour. Such a process is to:</source>
          <target state="translated">이 섹션에서는 표준 동작을 사용하지 않고 OTP 설계 원칙을 준수하는 프로세스를 작성하는 방법에 대해 설명합니다. 이러한 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db110007d4cae55a5cd2784be2448b1464cdeff4" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;Mnesia&lt;/code&gt; transaction system and the transaction properties that make &lt;code&gt;Mnesia&lt;/code&gt; a fault-tolerant, distributed Database Management System (DBMS).</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 트랜잭션 시스템 및 &lt;code&gt;Mnesia&lt;/code&gt; 를 내결함성 분산 데이터베이스 관리 시스템 (DBMS)으로 만드는 트랜잭션 속성에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="145559b08f0e7daceea91964fac1205f05f73a6b" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;erl_crash.dump&lt;/code&gt; file generated upon abnormal exit of the Erlang runtime system.</source>
          <target state="translated">이 절에서는 Erlang 런타임 시스템이 비정상 종료 될 때 생성되는 &lt;code&gt;erl_crash.dump&lt;/code&gt; 파일에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="615a4d70bf1eb0943d565d942619e06723c44a20" translate="yes" xml:space="preserve">
          <source>This section describes the ASN.1 types including their functionality, purpose, and how values are assigned in Erlang.</source>
          <target state="translated">이 섹션에서는 기능, 목적 및 Erlang에서 값이 할당되는 방법을 포함하여 ASN.1 유형에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4973acdcae6787712641efb91993666da08e3527" translate="yes" xml:space="preserve">
          <source>This section describes the basic steps when designing a &lt;code&gt;Mnesia&lt;/code&gt; database and the programming constructs that make different solutions available to the programmer. The following topics are included:</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스를 설계 할 때의 기본 단계 와 프로그래머가 다양한 솔루션을 사용할 수 있도록하는 프로그래밍 구조에 대해 설명합니다 . 다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="faf94ee7a5d096d374f74f2312ed2c9e2ebd27de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol introduced in Erlang/OTP R6. This description was previously located in &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; and has more or less been copied and &quot;formatted&quot; here. It has been almost unchanged since 1999, but the handshake has not changed much since then either.</source>
          <target state="translated">이 섹션에서는 Erlang / OTP R6에 도입 된 배포 핸드 셰이크 프로토콜에 대해 설명합니다. 이 설명은 이전에 &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; 있으며 여기에서 다소 복사 및 &quot;포맷&quot;되었습니다. 1999 년 이래로 거의 변하지 않았지만 그 이후로 악수는 크게 변하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d76e009e16bdd01f805b9e968741d4585ed774f4" translate="yes" xml:space="preserve">
          <source>This section describes the functions available for schema management, all which return either of the following tuples:</source>
          <target state="translated">이 섹션에서는 스키마 관리에 사용할 수있는 기능에 대해 설명합니다.이 기능은 모두 다음 튜플 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6589e4219f2138e744e1d40f56f69ff33d9cd04f" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net if process must be able to receive.</source>
          <target state="translated">이 섹션에서는 Net if 프로세스가 수신 할 수 있어야하는 수신 메시지에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba803131ede9177f9bd28303113e3a91a6271ee1" translate="yes" xml:space="preserve">
          <source>This section describes the internal files that are created and maintained by the &lt;code&gt;Mnesia&lt;/code&gt; system. In particular, the workings of the &lt;code&gt;Mnesia&lt;/code&gt; log are described.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에서 만들고 유지 관리하는 내부 파일에 대해 설명합니다 . 특히, &lt;code&gt;Mnesia&lt;/code&gt; 로그 의 작동 이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="16c349c9cdb2076b95c930dc72ed84bdd0fd6a91" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Solaris.</source>
          <target state="translated">이 절에서는 Solaris와 관련된 운영 체제 별 OTP 부분에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35c4d999a1922f58afda1ed0555720ff15b4c949" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Windows NT.</source>
          <target state="translated">이 절에서는 Windows NT와 관련된 운영 체제 별 OTP 부분에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="40285644d87303c5462b5e3de0dc15016aecc45b" translate="yes" xml:space="preserve">
          <source>This section describes the output format of the analyse command. See &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 분석 명령의 출력 형식에 대해 설명합니다. &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56322ae43abba91cc149a5278e951f77e9967920" translate="yes" xml:space="preserve">
          <source>This section describes the rules for constructing binaries using the bit syntax. Unlike when constructing lists or tuples, the construction of a binary can fail with a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">이 섹션에서는 비트 구문을 사용하여 바이너리를 구성하는 규칙에 대해 설명합니다. 리스트 나 튜플을 구성 할 때와 달리 바이너리 구성은 &lt;code&gt;badarg&lt;/code&gt; 예외로 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c65c0615f3b377f5b341fdeacc78b3636ed30f2" translate="yes" xml:space="preserve">
          <source>This section describes the rules for matching binaries, using the bit syntax.</source>
          <target state="translated">이 섹션에서는 비트 구문을 사용하여 바이너리를 일치시키는 규칙에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3efdb6c16651b89d1df8757e4dbe192b22b7b9d8" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 로 변환 된 약간 다른 일치 스펙에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="2b3b7f437eda66334d0b64118f5de15fc1fc7fab" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt;compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="translated">이 섹션에서는 Erlang 프로그램에 대한 구문 분석 트리의 표준 표현을 Erlang 용어로 설명합니다. 이 표현을 &lt;strong&gt;추상 형식&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 이러한 구문 분석 트리를 처리하는 함수는 &lt;code&gt;compile:forms/1,2&lt;/code&gt; 이며 다음 모듈의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2174d2f040729649ef711f3e5635d25b5e2b5fd1" translate="yes" xml:space="preserve">
          <source>This section describes the use of the registry, a simple mechanism for storing key-value pairs in a C-node, as well as backing them up or restoring them from an &lt;code&gt;Mnesia&lt;/code&gt; table on an Erlang node. For more detailed information about the individual API functions, see the &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 섹션에서는 C- 노드에 키-값 쌍을 저장 하고 Erlang 노드 의 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에서 키-값 쌍을 백업 또는 복원하기위한 간단한 메커니즘 인 레지스트리 사용에 대해 설명 합니다. 개별 API 함수에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e54bfa17aaa2c2d40ded61fef98685a45ccab20" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the state enter calls, so this example first branches depending on state:</source>
          <target state="translated">이 섹션에서는 하나의 &lt;code&gt;handle_event/4&lt;/code&gt; 함수 를 사용하기 위해 예제에서 변경해야 할 사항에 대해 설명 합니다. 이벤트에 따라 이전에 사용한 첫 번째 브랜치 접근 방식은 상태 입력 호출로 인해 여기서 제대로 작동하지 않으므로이 예제는 상태에 따라 첫 번째 브랜치입니다.</target>
        </trans-unit>
        <trans-unit id="62fe5fd22b036a47305b864aea85d4d04ebc8617" translate="yes" xml:space="preserve">
          <source>This section illustrates procedural abstraction. Initially, the following two examples are written as conventional functions.</source>
          <target state="translated">이 섹션에서는 절차 적 추상화를 보여줍니다. 처음에는 다음 두 가지 예가 일반적인 기능으로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cceb1f5cb17e39dece66daf2562fc578ef8e2eb3" translate="yes" xml:space="preserve">
          <source>This section includes examples of &lt;code&gt;.appup&lt;/code&gt; files for typical cases of upgrades/downgrades done in runtime.</source>
          <target state="translated">이 섹션에는 런타임에서 수행되는 일반적인 업그레이드 / 다운 그레이드 사례에 대한 &lt;code&gt;.appup&lt;/code&gt; 파일의 예가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8307ab1487485b0ab0c191a87d10ed0db502873" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using state enter calls, which deserves a new state diagram:</source>
          <target state="translated">이 섹션에는 언급 된 대부분의 수정 이후의 예와 더 많은 상태 입력 호출을 사용하는 예가 포함되며, 새로운 상태 다이어그램이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="46836c7cf8344b6ce7b90b07cbf3092bf8c64800" translate="yes" xml:space="preserve">
          <source>This section informs on interoperability, that is, information exchange, between Erlang and other programming languages. The included examples mainly treat interoperability between Erlang and C.</source>
          <target state="translated">이 섹션에서는 Erlang과 다른 프로그래밍 언어 간의 상호 운용성, 즉 정보 교환에 대해 설명합니다. 포함 된 예제는 주로 Erlang과 C 간의 상호 운용성을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="89f49f8072fe70dfd2c365690f214b5fdc461dd8" translate="yes" xml:space="preserve">
          <source>This section introduces &lt;code&gt;Mnesia&lt;/code&gt; with an example database. This example is referenced in the following sections, where the example is modified to illustrate various program constructs. This section illustrates the following mandatory procedures through examples:</source>
          <target state="translated">이 섹션에서는 예제 데이터베이스가있는 &lt;code&gt;Mnesia&lt;/code&gt; 를 소개 합니다. 이 예제는 다음 섹션에서 참조되며 여기서 다양한 프로그램 구성을 보여주기 위해 예제가 수정되었습니다. 이 섹션에서는 예제를 통해 다음과 같은 필수 절차를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4b9ffc517c7f7beea672bf3a45f0d5c54e6718e6" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt;Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="translated">이 섹션은 Erlang을 시작하기위한 빠른 시작 자습서입니다. 이 섹션의 모든 내용은 사실이지만 사실의 일부일뿐입니다. 예를 들어, 모든 난해한 형식이 아니라 가장 간단한 구문 형식 만 표시됩니다. 또한 크게 단순화 된 부품은 * manual *로 표시됩니다. 이것은 주제에 대한 더 많은 정보가 Erlang 책이나 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 에 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="7681f5719ebc6c3947920d0c8b79f4d20d935db2" translate="yes" xml:space="preserve">
          <source>This section is about installing an embedded system. The following topics are considered:</source>
          <target state="translated">이 섹션은 임베디드 시스템 설치에 관한 것입니다. 다음과 같은 주제가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="e1226c380377fda419e20eb5188c02f21ab8efb4" translate="yes" xml:space="preserve">
          <source>This section is about list functions that &lt;strong&gt;construct&lt;/strong&gt; lists. A tail-recursive function that does not construct a list runs in constant space, while the corresponding body-recursive function uses stack space proportional to the length of the list.</source>
          <target state="translated">이 섹션은리스트를 &lt;strong&gt;구성&lt;/strong&gt; 하는리스트 함수에 관한 것 입니다. 리스트를 구성하지 않는 tail-recursive 함수는 일정한 공간에서 실행되는 반면, 해당 body-recursive 함수는리스트의 길이에 비례하는 스택 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68c719f00318cfafeb4885e7d19be04a0e723344" translate="yes" xml:space="preserve">
          <source>This section is the Erlang reference manual. It describes the Erlang programming language.</source>
          <target state="translated">이 섹션은 Erlang 참조 매뉴얼입니다. Erlang 프로그래밍 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ef1c8ac7b879ac21c4bbd932c5c5aba836b3ebe" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;app(4)&lt;/code&gt; and &lt;code&gt;application(3)&lt;/code&gt; manual pages in Kernel.</source>
          <target state="translated">이 섹션은 커널 의 &lt;code&gt;app(4)&lt;/code&gt; 및 &lt;code&gt;application(3)&lt;/code&gt; 매뉴얼 페이지 와 함께 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d050299e9360b73cf317b1cb6719eba05c8f8b67" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_event(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 절은 &lt;code&gt;gen_event(3)&lt;/code&gt; 의 gen_event (3) 매뉴얼 페이지에서 읽습니다. 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b25498b71adedf6dc2be1b461a7355670bd9865a" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in &lt;code&gt;stdlib&lt;/code&gt;, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 섹션은 &lt;code&gt;stdlib&lt;/code&gt; 의 &lt;code&gt;gen_server(3)&lt;/code&gt; 매뉴얼 페이지에서 읽어야합니다 . 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e425baa0c9a68eb141d0fd0ffe5193c115033f3e" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_statem(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 섹션은 &lt;code&gt;gen_statem(3)&lt;/code&gt; 의 gen_statem (3) 매뉴얼 페이지에서 읽어야합니다. 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="834b2272d947ac4550fa4f7cf0a1b4b54d61e0d3" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;rel(4)&lt;/code&gt;, &lt;code&gt;systools(3)&lt;/code&gt;, and &lt;code&gt;script(4)&lt;/code&gt; manual pages in SASL.</source>
          <target state="translated">이 섹션은 SASL 의 &lt;code&gt;rel(4)&lt;/code&gt; , &lt;code&gt;systools(3)&lt;/code&gt; 및 &lt;code&gt;script(4)&lt;/code&gt; 매뉴얼 페이지 와 함께 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d930e6096fb887dbfeb97cc96dedbb64de3c9031" translate="yes" xml:space="preserve">
          <source>This section lists a few modules and BIFs to watch out for, not only from a performance point of view.</source>
          <target state="translated">이 섹션에는 성능 관점뿐만 아니라주의해야 할 몇 가지 모듈과 BIF가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="302cba4ce6be32265c131b8fff3be15369bb97a8" translate="yes" xml:space="preserve">
          <source>This section lists all funs. The following fields exist for each fun:</source>
          <target state="translated">이 섹션에는 모든 재미가 있습니다. 각 재미에는 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc1c1a16c9fc6835aa747c430d5753502607fd3" translate="yes" xml:space="preserve">
          <source>This section lists the open ports, their owners, any linked processes, and the name of their driver or external process.</source>
          <target state="translated">이 섹션에는 열린 포트, 소유자, 연결된 프로세스 및 드라이버 또는 외부 프로세스 이름이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="251c858a6feb418633832df9c31b24c8b4f5a1b7" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using Native Implemented Functions (NIFs).</source>
          <target state="translated">이 절에서는 NIF (Native Implemented Functions)를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="e7bc2bafdedf8fd30afa495c12130ded7ddd3fc5" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a C node. Notice that a C node is not typically used for solving simple problems like this, a port is sufficient.</source>
          <target state="translated">이 절에서는 C 노드를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명 합니다. C 노드는 일반적으로 이와 같은 간단한 문제를 해결하는 데 사용되지 않으며 포트로 ​​충분합니다.</target>
        </trans-unit>
        <trans-unit id="d8b1fe16968a43f36d99fc7c39a89fadb4f26e24" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a linked-in port driver.</source>
          <target state="translated">이 절에서는 연결된 포트 드라이버를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 예제 문제를 해결하는 방법에 대한 예를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6188e756764065c7ce79203e7dc5cecf3ee5f2b4" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a port and Erl_Interface. It is necessary to read the port example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; before reading this section.</source>
          <target state="translated">이 절에서는 포트와 Erl_Interface를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명합니다 . 에서 포트 예를 읽을 필요가 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 이 절을 읽기 전에.</target>
        </trans-unit>
        <trans-unit id="37a17f96d0247a59a445c39970b3c2ce5aa258a2" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in the &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; by using a port.</source>
          <target state="translated">이 섹션에서는 포트를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; 의 예제 문제를 해결하는 방법의 예를 간략하게 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="909ed75e66d95b03604cc684f38a417f30c36fa4" translate="yes" xml:space="preserve">
          <source>This section outlines the current Unicode support and gives some recipes for working with Unicode data.</source>
          <target state="translated">이 섹션에서는 현재 유니 코드 지원에 대해 간략하게 설명하고 유니 코드 데이터 작업을위한 몇 가지 레시피를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4548220d710b00d84d1083e484e819816bc4647" translate="yes" xml:space="preserve">
          <source>This section presents all the atoms in the system. This is only of interest if one suspects that dynamic generation of atoms can be a problem, otherwise this section can be ignored.</source>
          <target state="translated">이 섹션은 시스템의 모든 원자를 나타냅니다. 이것은 원자의 동적 생성이 문제가 될 수 있다고 의심되는 경우에만 관심이 있으며, 그렇지 않으면이 섹션을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98a32dcb47ef919db3aef2c03013357cf7c9199" translate="yes" xml:space="preserve">
          <source>This section presents the generic protocol-independent model for use within an OTP-based NE. This model is used by all OAM components and can be used by the applications. The advantage of the model is that it clearly separates the resources from the management protocol. The resources do not need to be aware of which management protocol is used to manage the system. The same resources can therefore be managed with different protocols.</source>
          <target state="translated">이 섹션에서는 OTP 기반 NE 내에서 사용하기위한 프로토콜 독립적 인 모델을 제시합니다. 이 모델은 모든 OAM 구성 요소에서 사용되며 응용 프로그램에서 사용할 수 있습니다. 이 모델의 장점은 리소스가 관리 프로토콜과 명확하게 분리된다는 것입니다. 리소스는 시스템을 관리하는 데 사용되는 관리 프로토콜을 알 필요가 없습니다. 따라서 동일한 프로토콜을 다른 프로토콜로 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="16347e215e685cc8a7eb7375f07fbbb91f2c9603" translate="yes" xml:space="preserve">
          <source>This section provides a brief overview on how to write efficient drivers.</source>
          <target state="translated">이 섹션에서는 효율적인 드라이버 작성 방법에 대한 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30913964bf9365a1caa81bfa4bb9ad170421d97f" translate="yes" xml:space="preserve">
          <source>This section provides a simplified demonstration of a &lt;code&gt;Mnesia&lt;/code&gt; system startup. The dialogue from the Erlang shell is as follows:</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 시작에 대한 간단한 데모를 제공합니다 . Erlang 쉘의 대화는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec0f201c25b61d89e7f6c76b13618afc0002a916" translate="yes" xml:space="preserve">
          <source>This section should be read with the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page in STDLIB, where all details about the supervisor behaviour is given.</source>
          <target state="translated">이 섹션은 STDLIB 의 &lt;code&gt;supervisor(3)&lt;/code&gt; 매뉴얼 페이지에서 읽어야합니다. 여기서 감독자 동작에 대한 모든 세부 사항이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="859dc9ee797ee513900af80c0e4f3984de1a34df" translate="yes" xml:space="preserve">
          <source>This section shows a small example of how to set up client/server connections using the Erlang shell. The returned value of the &lt;code&gt;sslsocket&lt;/code&gt; is abbreviated with &lt;code&gt;[...]&lt;/code&gt; as it can be fairly large and is opaque.</source>
          <target state="translated">이 섹션에서는 Erlang 쉘을 사용하여 클라이언트 / 서버 연결을 설정하는 방법에 대한 작은 예를 보여줍니다. &lt;code&gt;sslsocket&lt;/code&gt; 의 리턴 값은 상당히 크고 불투명하기 때문에 &lt;code&gt;[...]&lt;/code&gt; 로 축약됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b3f3a6882bc6f1c999e3d6f053e34aa184902fb" translate="yes" xml:space="preserve">
          <source>This section starts with a simple example, showing a generator and a filter:</source>
          <target state="translated">이 섹션은 간단한 예제로 시작하여 생성기와 필터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b10755987ebac7d338a7fd1a7c6bbec42a0583a6" translate="yes" xml:space="preserve">
          <source>This section tries to kill the old truths (or semi-truths) that have become myths.</source>
          <target state="translated">이 부분은 신화가 된 오래된 진실 (또는 반진)을 죽이려고합니다.</target>
        </trans-unit>
        <trans-unit id="4bc790cb1406d976325d74bbdbe32730d66b0176" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, as it explains important concepts, but this was written for an older driver interface so the examples do not work anymore. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">이 섹션은 오래 전에 작성되었습니다. 중요한 개념을 설명하기 때문에 대부분의 경우 여전히 유효하지만 이전 드라이버 인터페이스 용으로 작성되었으므로 더 이상 예제가 작동하지 않습니다. 독자는 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 문서도 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b93f78b17719c3a40516be4872cc22d2aa5ee759" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, but some things have changed since then. Some updates have been made to the documentation of the driver presented here, but more can be done and is planned for the future. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">이 섹션은 오래 전에 작성되었습니다. 대부분은 여전히 ​​유효하지만 그 이후로 일부 사항이 변경되었습니다. 여기에 제시된 드라이버의 문서가 일부 업데이트되었지만 더 많은 작업을 수행하고 향후 계획을 세울 수 있습니다. 독자는 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 문서도 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3acfdfded91bac52b2d4f66deb3db7bcfef3bb64" translate="yes" xml:space="preserve">
          <source>This sends a request with a specified connection header:</source>
          <target state="translated">지정된 연결 헤더로 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a989f27ccbc0cd1a9d3190ceeec551d99b4ccfce" translate="yes" xml:space="preserve">
          <source>This sends an HTTP request over a unix domain socket (experimental):</source>
          <target state="translated">이것은 유닉스 도메인 소켓을 통해 HTTP 요청을 보냅니다 (실험적).</target>
        </trans-unit>
        <trans-unit id="0367f390c138c4cdab5de93d4dcd533741c91409" translate="yes" xml:space="preserve">
          <source>This server can be started with the Kernel configuration parameter &lt;code&gt;start_boot_server&lt;/code&gt;.</source>
          <target state="translated">이 서버는 커널 구성 매개 변수 &lt;code&gt;start_boot_server&lt;/code&gt; 로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a01d31508a13cbee6fd61e7f30640416fa3e960" translate="yes" xml:space="preserve">
          <source>This server is used to assist diskless Erlang nodes that fetch all Erlang code from another machine.</source>
          <target state="translated">이 서버는 다른 시스템에서 모든 Erlang 코드를 가져 오는 디스크없는 Erlang 노드를 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d1e9f0f9d29165296c1877ce900cce295357757" translate="yes" xml:space="preserve">
          <source>This server is used to fetch all code, including the start script, if an Erlang runtime system is started with command-line flag &lt;code&gt;-loader inet&lt;/code&gt;. All hosts specified with command-line flag &lt;code&gt;-hosts Host&lt;/code&gt; must have one instance of this server running.</source>
          <target state="translated">이 서버는 Erlang 런타임 시스템이 명령 행 플래그 &lt;code&gt;-loader inet&lt;/code&gt; 로 시작된 경우 시작 스크립트를 포함하여 모든 코드를 가져 오는 데 사용됩니다 . 명령 행 플래그 &lt;code&gt;-hosts Host&lt;/code&gt; 로 지정된 모든 호스트 에는이 서버의 인스턴스 하나가 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b854dfbf08852692209c2c9428fe6541ba04a2b8" translate="yes" xml:space="preserve">
          <source>This session sets the system_tracer to the same process as the ordinary tracer process (i. e. &amp;lt;0.31.0&amp;gt;) and sets the trace pattern for the function &lt;code&gt;dbg:get_tracer&lt;/code&gt; to one that has the action of setting a sequential token. When the function is called by a traced process (all processes are traced in this case), the process gets &quot;contaminated&quot; by the token and &lt;code&gt;seq_trace&lt;/code&gt; messages are sent both for the server request and the response. The &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; after the call clears the &lt;code&gt;seq_trace&lt;/code&gt; token, why no messages are sent when the answer propagates via the shell to the console port. The output would otherwise have been more noisy.</source>
          <target state="translated">이 세션은 system_tracer를 일반 추적 프로그램 프로세스와 동일한 프로세스 (예 : &amp;lt;0.31.0&amp;gt;)로 설정하고 &lt;code&gt;dbg:get_tracer&lt;/code&gt; 함수의 추적 패턴을 순차적 토큰 설정 조치가있는 패턴 으로 설정합니다. 추적 된 프로세스가 함수를 호출하면 (이 경우 모든 프로세스가 추적 됨) 프로세스가 토큰에 의해 &quot;오염&quot;되고 &lt;code&gt;seq_trace&lt;/code&gt; 메시지가 서버 요청과 응답 모두에 대해 전송됩니다. &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; 호출 후 해제 &lt;code&gt;seq_trace&lt;/code&gt; 어떤 메시지가 전송되지 않는 이유 토큰을 때의 콘솔 포트에 쉘을 통해 응답 전파. 그렇지 않으면 출력이 더 시끄 럽습니다.</target>
        </trans-unit>
        <trans-unit id="7f6dee944ecab0b445c18e6ceefaac7d931ceec9" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; are added first in the PATH.</source>
          <target state="translated">이것은 환경에 대한 최종적인 손길이되어야하며, 그 후에는 건물이 쉬워야합니다. &lt;code&gt;./otp_build env_win32&lt;/code&gt; 를 &lt;code&gt;eval&lt;/code&gt; 없이 실행할 수 있으며 설정 한 환경이 정상인지 확인할 수 있습니다. 가능한 경우 경로는 공백으로 정리되고 (DOS 스타일의 짧은 이름을 대신 사용) 변수 &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt; , &lt;code&gt;CC&lt;/code&gt; , &lt;code&gt;CXX&lt;/code&gt; , &lt;code&gt;AR&lt;/code&gt; 및 &lt;code&gt;RANLIB&lt;/code&gt; 변수 는 각각의 래퍼 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; 디렉토리로 설정됩니다. &amp;gt; _tools / vc 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; 이 PATH에서 먼저 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d785e08dd7a56c60e1bed8756d1974bdb847eb99" translate="yes" xml:space="preserve">
          <source>This shows another important non-obvious case: a clause guard, even if it's as simple as &lt;code&gt;Y &amp;gt; 0&lt;/code&gt;, always consists of a single disjunction of one or more conjunctions of tests, much like a tuple of tuples. Thus:</source>
          <target state="translated">이것은 명백한 또 다른 중요한 경우를 보여줍니다. 절 보호는 &lt;code&gt;Y &amp;gt; 0&lt;/code&gt; 과 같이 단순하더라도 항상 튜플의 튜플과 같이 하나 이상의 테스트 조합으로 단일 분리로 구성됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="1fa8ade625dd050384ebfe47137813125a13ed25" translate="yes" xml:space="preserve">
          <source>This signal will be ignored.</source>
          <target state="translated">이 신호는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="92abfd0b7a6c2f6f6e673410127b459c582c4efd" translate="yes" xml:space="preserve">
          <source>This signal will notify &lt;code&gt;erl_signal_server&lt;/code&gt; when it is received by the Erlang runtime system.</source>
          <target state="translated">이 신호는 Erlang 런타임 시스템에 의해 수신 될 때 &lt;code&gt;erl_signal_server&lt;/code&gt; 에 통지 합니다.</target>
        </trans-unit>
        <trans-unit id="edab6f17da92a0f0da17b2cdabee390180519ab6" translate="yes" xml:space="preserve">
          <source>This signal will use the default signal handler for the operating system.</source>
          <target state="translated">이 신호는 운영 체제의 기본 신호 처리기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="da98f38cbd3a5312fa20fb0710bd3343db7b6751" translate="yes" xml:space="preserve">
          <source>This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \X matches one of these clusters.</source>
          <target state="translated">이 간단한 정의는 각 문자에 grapheme Breaking 속성을 부여하고 이러한 속성을 사용하여 확장 된 grapheme 클러스터의 경계를 정의하는 규칙을 작성하여 더 복잡한 종류의 복합 문자를 포함하도록 유니 코드로 확장되었습니다. 8.31 이후의 PCRE 릴리스에서 \ X는 이러한 클러스터 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e86121002d76857e44d3ab841a1269a83df96b05" translate="yes" xml:space="preserve">
          <source>This simple standard test, &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt;, a module which, using the &lt;code&gt;snmp_ex2_manager&lt;/code&gt; described in the previous section, implements a simple agent test utility.</source>
          <target state="translated">이 간단한 표준 테스트 인 &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt; 는 이전 섹션에서 설명한 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 를 사용하여 간단한 에이전트 테스트 유틸리티를 구현하는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="2d0034518115855077790a9986c987efa20b3785" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt;OTP Design Principles&lt;/code&gt;).</source>
          <target state="translated">OTP의 기능을 사용하면 이러한 종류의 문제를 쉽게 해결할 수 있습니다.이 기능을 사용하면 코드를 즉시 업데이트하는 방법도 제공합니다 ( &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e3b6d6c6628faa03b7c6f08bc646ad236cf4da32" translate="yes" xml:space="preserve">
          <source>This specialized decode decodes a subtype of a constructed value and is the fastest method to extract a subvalue. This decode is typically used when you want to inspect, for example, a version number, to be able to decide what to do with the entire value. The result is returned as &lt;code&gt;{ok,Value}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">이 특수화 된 디코드는 생성 된 값의 하위 유형을 디코딩하며 하위 값을 추출하는 가장 빠른 방법입니다. 이 디코드는 일반적으로 전체 값으로 수행 할 작업을 결정할 수 있도록 버전 번호와 같은 검사하려는 경우에 사용됩니다. 결과는 &lt;code&gt;{ok,Value}&lt;/code&gt; 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 으로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="77e086b8dea4b8bfb5a0597b5900b1d75b0fef9f" translate="yes" xml:space="preserve">
          <source>This starts Erlang in its own window, with fully functioning command-line editing and scrollbars. All flags except &lt;code&gt;-oldshell&lt;/code&gt; work as they do for &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 완전한 기능을 갖춘 명령 줄 편집 및 스크롤 막대와 함께 자체 창에서 Erlang을 시작합니다. &lt;code&gt;-oldshell&lt;/code&gt; 을 제외한 모든 플래그 는 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a43faa1a1676e12b0177f046a812f0d8364ec82d" translate="yes" xml:space="preserve">
          <source>This starts the Erlang runtime system and evaluates the following functions:</source>
          <target state="translated">그러면 Erlang 런타임 시스템이 시작되고 다음 기능이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb8d3378772860a522d3a705d4cc5d40c409e79" translate="yes" xml:space="preserve">
          <source>This state data can be regarded as sensitive, and maybe not what you want in the error log because of some unpredictable event.</source>
          <target state="translated">이 상태 데이터는 민감한 것으로 간주 될 수 있으며 예측할 수없는 이벤트로 인해 오류 로그에 원하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c14a1eab4a2d73f912f341632799fc7862da43" translate="yes" xml:space="preserve">
          <source>This state transition action can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 상태 전이 조치는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 로부터 리턴 하거나 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57901b1493b88f1a72b634f92f65ad89d7517d70" translate="yes" xml:space="preserve">
          <source>This step also implies that the Erlang code in the interface and distribution modules is written in such a way that it can be run in the startup phase. In particular, there can be no calls to the &lt;code&gt;application&lt;/code&gt; module or to any modules not loaded at boot time. That is, only &lt;code&gt;Kernel&lt;/code&gt;, &lt;code&gt;STDLIB&lt;/code&gt;, and the application itself can be used.</source>
          <target state="translated">이 단계는 또한 인터페이스 및 분배 모듈의 Erlang 코드가 시작 단계에서 실행될 수있는 방식으로 작성되었음을 의미합니다. 특히, &lt;code&gt;application&lt;/code&gt; 모듈 또는 부팅시로드되지 않은 모듈에 대한 호출이 없을 수 있습니다 . 즉, &lt;code&gt;Kernel&lt;/code&gt; , &lt;code&gt;STDLIB&lt;/code&gt; 및 애플리케이션 자체 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33eaf1a1a2a532c70f7ffcd5caaf8b22d9ff8909" translate="yes" xml:space="preserve">
          <source>This structure is to be used if all clients are running the same type of Erlang machine. If there are clients running different types of Erlang machines, or on different operating systems, the &lt;code&gt;clients&lt;/code&gt; directory can be divided into one subdirectory per type of Erlang machine. Alternatively, one &lt;code&gt;$ROOT&lt;/code&gt; can be set up per type of machine. For each type, some of the directories specified for the &lt;code&gt;$ROOT&lt;/code&gt; directory are to be included:</source>
          <target state="translated">이 구조는 모든 클라이언트가 동일한 유형의 Erlang 시스템을 실행중인 경우에 사용됩니다. 다른 유형의 Erlang 시스템 또는 다른 운영 체제에서 실행중인 클라이언트가있는 경우 &lt;code&gt;clients&lt;/code&gt; 디렉토리를 Erlang 시스템 유형마다 하나의 서브 디렉토리로 나눌 수 있습니다. 또는 머신 유형마다 하나의 &lt;code&gt;$ROOT&lt;/code&gt; 를 설정할 수 있습니다. 각 유형에 대해 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에 지정된 일부 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba107d8023d557fe4ebdc08a0485fead425f4a4c" translate="yes" xml:space="preserve">
          <source>This structure is used for all types of ports although some fields are useless for some types. The least memory consuming solution would be to arrange this structure as a union of structures. However, the multiple indirections in the code to access a field in such a structure would clutter the code too much for an example.</source>
          <target state="translated">이 구조는 모든 유형의 포트에 사용되지만 일부 필드는 일부 유형에는 쓸모가 없습니다. 가장 적은 메모리 소비 솔루션은이 구조를 구조의 결합으로 배열하는 것입니다. 그러나 코드에서 이러한 구조의 필드에 액세스하기위한 여러 간접 지시는 코드를 너무 복잡하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b9c807a7212c0db55e210d6237e55cf572102e59" translate="yes" xml:space="preserve">
          <source>This switches off logging for SSH and Telnet connections.</source>
          <target state="translated">SSH 및 Telnet 연결에 대한 로깅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c8936eaae5713c5223ec21e20e0d36d26fc0092" translate="yes" xml:space="preserve">
          <source>This switches off logging for all connection types.</source>
          <target state="translated">모든 연결 유형에 대한 로깅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f56bbb3abc53b0a624950444e1c66ce730f11613" translate="yes" xml:space="preserve">
          <source>This symbol should appear in the lhs of at least one grammar rule. This is the most general syntactic category which the parser ultimately will parse every input string into.</source>
          <target state="translated">이 기호는 적어도 하나의 문법 규칙에 나타납니다. 이것은 구문 분석기가 궁극적으로 모든 입력 문자열을 구문 분석하는 가장 일반적인 구문 범주입니다.</target>
        </trans-unit>
        <trans-unit id="a9ad3ed484ba9b2b41f2325fc27244234c66f278" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt;dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="translated">이 구문은 Runtime_Tools 의 추적 패턴 ( &lt;code&gt;dbg(3)&lt;/code&gt; ) 모듈에 사용 된 구문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ee2b2d8d451101694a58799b8409428a148a8058" translate="yes" xml:space="preserve">
          <source>This takes &lt;code&gt;H&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; in all possible ways. The result is the set of all lists &lt;code&gt;[H|T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the set of all possible permutations of &lt;code&gt;L&lt;/code&gt;, with &lt;code&gt;H&lt;/code&gt; removed:</source>
          <target state="translated">이것은 가능한 모든 방법으로 &lt;code&gt;L&lt;/code&gt; 에서 &lt;code&gt;H&lt;/code&gt; 를 가져옵니다 . 결과는 모든 목록의 집합이다 &lt;code&gt;[H|T]&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 는 모든 가능한 순열의 집합 인 &lt;code&gt;L&lt;/code&gt; 과, &lt;code&gt;H&lt;/code&gt; 제거 :</target>
        </trans-unit>
        <trans-unit id="618f3633ac8c2cadd4289f1c5621d970e601a5ca" translate="yes" xml:space="preserve">
          <source>This term is the encoding for external funs: &lt;code&gt;fun M:F/A&lt;/code&gt;.</source>
          <target state="translated">:이 용어는 외부 funs입니다에 대한 인코딩입니다 &lt;code&gt;fun M:F/A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb3ae0ca905f496ce783ad12cff60bb9bb87bbd" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 0 of the external format; it has been superseded by &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 용어는 외부 형식의 부 버전 0에서 사용됩니다. &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; (으) 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b517e1702cae7ec8ee019fdb69c857aa5330cfd8" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 1 of the external format.</source>
          <target state="translated">이 용어는 외부 형식의 부 버전 1에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0860084b170b958eacacb8679369f69a7b4a4046" translate="yes" xml:space="preserve">
          <source>This term represents a bitstring whose length in bits does not have to be a multiple of 8. The &lt;code&gt;Len&lt;/code&gt; field is an unsigned 4 byte integer (big-endian). The &lt;code&gt;Bits&lt;/code&gt; field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant.</source>
          <target state="translated">이 용어는 비트 단위의 길이가 8의 배수 일 필요가없는 비트 열을 나타냅니다. &lt;code&gt;Len&lt;/code&gt; 필드는 부호없는 4 바이트 정수 (빅 엔디안)입니다. &lt;code&gt;Bits&lt;/code&gt; 필드는 데이터 필드의 마지막 바이트에 사용되는 비트 (1-8)의 수이고, 최상위 비트에서 최하위로 계산.</target>
        </trans-unit>
        <trans-unit id="108bbd5cab7129c54f675f7643a23fb10026ce1d" translate="yes" xml:space="preserve">
          <source>This test specification declares that &lt;code&gt;node1@host1&lt;/code&gt; is to be started using the user callback function &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt;, and nodes &lt;code&gt;node1@host2&lt;/code&gt; and &lt;code&gt;node2@host2&lt;/code&gt; are to be started with the default callback module &lt;code&gt;ct_slave&lt;/code&gt;. The specified username and password are used to log on to remote host &lt;code&gt;host2&lt;/code&gt;. Also, function &lt;code&gt;module:function/0&lt;/code&gt; is evaluated on &lt;code&gt;node1@host3&lt;/code&gt;, and the result of this call is printed to the log.</source>
          <target state="translated">이 테스트 사양은 &lt;code&gt;node1@host1&lt;/code&gt; 이 사용자 콜백 함수 &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt; 을 사용하여 시작 되고 &lt;code&gt;node1@host2&lt;/code&gt; 및 &lt;code&gt;node2@host2&lt;/code&gt; 노드 가 기본 콜백 모듈 &lt;code&gt;ct_slave&lt;/code&gt; 로 시작되도록 선언 합니다. 지정된 사용자 이름 및 비밀번호는 원격 호스트 &lt;code&gt;host2&lt;/code&gt; 에 로그온하는 데 사용됩니다 . 또한 function &lt;code&gt;module:function/0&lt;/code&gt; 은 &lt;code&gt;node1@host3&lt;/code&gt; 에서 평가 되며이 호출의 결과는 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e29f7e984adbbfe8a53af166b10808cfa43c1c97" translate="yes" xml:space="preserve">
          <source>This tests all object files in the specified directory, as if they had been individually specified using &lt;code&gt;{file, FileName}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;{file, FileName}&lt;/code&gt; 사용하여 개별적으로 지정된 것처럼 지정된 디렉토리의 모든 오브젝트 파일을 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="76191fd55833467474b9c8b3bbd30d057e2c02a5" translate="yes" xml:space="preserve">
          <source>This the formatter callback function to be called from handlers. The log event is processed as follows:</source>
          <target state="translated">핸들러에서 호출 할 포맷터 콜백 함수입니다. 로그 이벤트는 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a753a4a3983a27e7aa021fa6ea24ccc7d272be01" translate="yes" xml:space="preserve">
          <source>This time argument 2 is used, which is the second element in the tuple. If this returns the atom &lt;code&gt;false&lt;/code&gt;, fred is not logged on and the following message is sent:</source>
          <target state="translated">이번에는 인수 2가 사용되는데, 이는 튜플의 두 번째 요소입니다. 이 반환 원자의 경우 &lt;code&gt;false&lt;/code&gt; , 프레드에 기록되지 않고 다음과 같은 메시지가 전송됩니다</target>
        </trans-unit>
        <trans-unit id="e6fffaa6a8f0644a7ea4fa7c7c74c76ec90d774c" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 시간은 일반적인 경우 단조 증가하는 시간이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 자세한 내용은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49beb73df376b7dea84521a1c52301d5531a79e4" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time.</source>
          <target state="translated">이 시간은 단조 증가하는 시간이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3748262d456a936f46c1ed22dababf257bb3fa6f" translate="yes" xml:space="preserve">
          <source>This time may or may not be an accurate view of POSIX time, and may or may not align with &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. The runtime system works towards aligning the two system times. Depending on the &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used, this can be achieved by letting Erlang system time perform a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 시간은 POSIX 시간을 정확하게 볼 수도 있고 아닐 수도 있으며 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 과 일치 할 수도 있고 일치하지 않을 수도 있습니다 . 런타임 시스템은 두 시스템 시간을 맞추기 위해 노력합니다. 사용 된 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; 에 따라 , Erlang 시스템 시간이 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 수행하게함으로써이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83d87d01faae0b3a7fef0f76f0e3a3892ae23062" translate="yes" xml:space="preserve">
          <source>This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;.</source>
          <target state="translated">이번에는 첫 번째 어설 션이 앞의 6 개 문자를보고 첫 번째 세 개가 숫자인지 확인한 다음 두 번째 어설 션이 앞의 세 개 문자가 &quot;999&quot;가 아닌지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="14391b08125b325189f3dcbd403d72965af6b345" translate="yes" xml:space="preserve">
          <source>This time, since the shell was not involved, no other work was done in the system during the profiling. If you retry the same example with a freshly started Erlang emulator, but omit the command &lt;code&gt;l(random)&lt;/code&gt;, the analysis will show a lot more function calls done by &lt;code&gt;code_server&lt;/code&gt; and others to automatically load the module &lt;code&gt;random&lt;/code&gt;.</source>
          <target state="translated">이번에는 쉘이 포함되지 않았으므로 프로파일 링 중에 시스템에서 다른 작업이 수행되지 않았습니다. 당신이 갓 시작 얼랑 에뮬레이터와 같은 예를 시도하지만, 명령 생략하는 경우 &lt;code&gt;l(random)&lt;/code&gt; , 분석은 수행 더 많은 함수 호출 표시됩니다 &lt;code&gt;code_server&lt;/code&gt; 자동으로 모듈로드와 다른 &lt;code&gt;random&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22a9f149405034822a960ba22d2e8646cd23a4b4" translate="yes" xml:space="preserve">
          <source>This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use.</source>
          <target state="translated">이번에는 재귀 대안이 먼저 시도되고 문자가 부족할 때까지 재귀가 계속되어 재귀가 실패합니다. 그러나 이번에는 더 높은 수준에서 시도 할 다른 대안이 있습니다. 이는 중요한 차이점입니다. 이전의 경우 나머지 대안은 더 깊은 재귀 수준에 있으며 PCRE는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c60619daf599e1009f83ff3339a4a66e29dc068d" translate="yes" xml:space="preserve">
          <source>This timer is started when the &lt;strong&gt;first&lt;/strong&gt; reply to an asynchronous request (issued using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; function) arrives. As long as this timer is running, replies will be delivered via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function, with their &quot;arrival number&quot; (see &lt;code&gt;UserReply&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function).</source>
          <target state="translated">이 타이머는 비동기 요청에 대한 &lt;strong&gt;첫 번째&lt;/strong&gt; 응답 ( &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 발행 된 )에 도달하면 시작됩니다. 이 타이머가 실행되는 한, 답글을 통해 전달 될 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; - 그들의 &quot;도착 번호&quot;로 콜백 함수 (참조 &lt;code&gt;UserReply&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; - 콜백 함수).</target>
        </trans-unit>
        <trans-unit id="7f582a8bac4499f4041fc098c02442c6d51efa18" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; (e.g. the last of the segment which makes up the reply) is received, but all segments has not yet been received.</source>
          <target state="translated">이 타이머는 &lt;code&gt;segmentation complete token&lt;/code&gt; 표시된 세그먼트 (예 : 응답을 구성하는 세그먼트의 마지막)가 수신되었지만 모든 세그먼트가 아직 수신되지 않은 경우 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f2ade158232a7f92c6ed91597d402fd153194a" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; is received, but all segments has not yet been received.</source>
          <target state="translated">이 타이머는 &lt;code&gt;segmentation complete token&lt;/code&gt; 표시된 세그먼트 가 수신되었지만 모든 세그먼트가 아직 수신되지 않은 경우 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="706cbfbf9ab1807332ea2d94bd3ad6011d82aa07" translate="yes" xml:space="preserve">
          <source>This transaction can write the text &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 1000 times to the terminal. However, &lt;code&gt;Mnesia&lt;/code&gt; guarantees that each transaction will eventually run. As a result, &lt;code&gt;Mnesia&lt;/code&gt; is not only deadlock free, but also livelock free.</source>
          <target state="translated">이 트랜잭션은 터미널에 &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 텍스트를 1000 번 쓸 수 있습니다 . 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 는 각 트랜잭션이 결국 실행되도록 보장합니다. 결과적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 교착 상태가 아니라 라이브 록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c15707ecd3d8e52159c361dec50a35ae8f4adf88" translate="yes" xml:space="preserve">
          <source>This transaction returns the list &lt;code&gt;[{foo,1,3}]&lt;/code&gt; if table &lt;code&gt;foo&lt;/code&gt; is of type &lt;code&gt;set&lt;/code&gt;. However, the list &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; is returned if the table is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">이 트랜잭션은 테이블 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;set&lt;/code&gt; 유형 인 경우 &lt;code&gt;[{foo,1,3}]&lt;/code&gt; 목록을 리턴합니다 . 그러나 테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf13712351a4aa96ae94ff06cddb20f5ef75fe11" translate="yes" xml:space="preserve">
          <source>This tries to match &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; or &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; twice. If &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; appears, the function returns &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 를 두 번 일치 시키려고합니다 . 만약 &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; 나타나면 함수 리턴 &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53c27958e7fca3ba05175a738c3a146371fd4e49" translate="yes" xml:space="preserve">
          <source>This tuple only exists if &lt;code&gt;Function&lt;/code&gt; can be used with different clocks. &lt;code&gt;ClockId&lt;/code&gt; corresponds to the clock identifier used when calling &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">이 튜플은 &lt;code&gt;Function&lt;/code&gt; 을 다른 시계와 함께 사용할 수있는 경우에만 존재합니다 . &lt;code&gt;ClockId&lt;/code&gt; 는 &lt;code&gt;Function&lt;/code&gt; 호출시 사용되는 시계 식별자에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ceff633d5c12b0ab1b989cd600fd3b0c1f9b57c7" translate="yes" xml:space="preserve">
          <source>This type is assigned in Erlang as follows:</source>
          <target state="translated">이 유형은 Erlang에서 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="34e89a0a89b0d1a14764e553fc94c9f4fbe45d6d" translate="yes" xml:space="preserve">
          <source>This type is further described in application &lt;code&gt;xmerl&lt;/code&gt;.</source>
          <target state="translated">이 유형은 &lt;code&gt;xmerl&lt;/code&gt; 응용 프로그램에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be71fbb0606c9b749f47ff7cbc7a8e0ca516ae1" translate="yes" xml:space="preserve">
          <source>This type of time-out is useful for example to act on inactivity. Let us restart the code sequence if no button is pressed for say 30 seconds:</source>
          <target state="translated">이 유형의 시간 초과는 예를 들어 비활성 상태에서 작동하는 데 유용합니다. 30 초 동안 아무 버튼도 누르지 않으면 코드 시퀀스를 다시 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0dd216aebaebb2374c204746cffeb0b8a3bfa66e" translate="yes" xml:space="preserve">
          <source>This utility function is used to create a formatted (pretty printable) string of the error reason received from either:</source>
          <target state="translated">이 유틸리티 함수는 다음 중 하나에서 수신 한 오류 이유의 형식화 된 (꽤 인쇄 가능한) 문자열을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e90f513c2d724696028de83a41a04ca02c00b03d" translate="yes" xml:space="preserve">
          <source>This utility is specific to Windows NT/2000/XP (and later versions of Windows). It allows Erlang emulators to run as services on the Windows system, allowing embedded systems to start without any user needing to log on. The emulator started in this way can be manipulated through the Windows services applet in a manner similar to other services.</source>
          <target state="translated">이 유틸리티는 Windows NT / 2000 / XP (및 이후 버전의 Windows)에만 해당됩니다. Erlang 에뮬레이터를 Windows 시스템에서 서비스로 실행할 수 있으므로 사용자가 로그온 할 필요없이 임베디드 시스템을 시작할 수 있습니다. 이러한 방식으로 시작된 에뮬레이터는 다른 서비스와 유사한 방식으로 Windows 서비스 애플릿을 통해 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55cb392aed5fc4d4c203d5436538e3f6a69fde3" translate="yes" xml:space="preserve">
          <source>This validation callback will be executed before any heartbeat is sent to the port program. For the validation to succeed it needs to return with the value &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">이 유효성 검증 콜백은 하트 비트가 포트 프로그램으로 전송되기 전에 실행됩니다. 유효성 검증이 성공하려면 &lt;code&gt;ok&lt;/code&gt; 값으로 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b8b5c1eef6ea78b8a30fd3fe8ec2afd6d40564e" translate="yes" xml:space="preserve">
          <source>This value can also be set through (OS) environment variable &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt;.</source>
          <target state="translated">이 값은 (OS) 환경 변수 &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt; 를 통해 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b09f82dfd17c02b5cc9bb38621d7a9dc8cc490" translate="yes" xml:space="preserve">
          <source>This value can be set at startup by passing command-line argument &lt;code&gt;+SDio&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">이 값은 &lt;code&gt;erl(1)&lt;/code&gt; 에서 명령 행 인수 &lt;code&gt;+SDio&lt;/code&gt; 를 전달하여 시작할 때 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f1511a226b28ee2f7a6351d90cc98e92a8e944" translate="yes" xml:space="preserve">
          <source>This value might wrap due to limitations in the underlying functionality provided by the operating system that is used.</source>
          <target state="translated">이 값은 사용되는 운영 체제에서 제공하는 기본 기능의 제한으로 인해 줄 바꿈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae87da20fd16a3057a07a29b3ed216aa69d1b30e" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a disk_log sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">이 값 (밀리 초)은 핸들러가 disk_log 동기화 조작을 수행하여 버퍼링 된 데이터를 디스크에 쓰는 빈도를 지정합니다. 처리기는 작업을 반복적으로 시도하지만 실제로 기록 된 경우에만 새 동기화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="562ee5839a71bc34778a37d5ff1caee77199d71c" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a file sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">이 값 (밀리 초)은 핸들러가 파일 동기화 조작을 수행하여 버퍼링 된 데이터를 디스크에 쓰는 빈도를 지정합니다. 처리기는 작업을 반복적으로 시도하지만 실제로 기록 된 경우에만 새 동기화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8a7dae834a17e1bfd7dcc5067b03add360f4e974" translate="yes" xml:space="preserve">
          <source>This variable sets the maximum size of a crash dump file in bytes. The crash dump will be truncated if this limit is exceeded. If the variable is not set, no size limit is enforced by default. If the variable is set to &lt;code&gt;0&lt;/code&gt;, the runtime system does not even attempt to write a crash dump file.</source>
          <target state="translated">이 변수는 크래시 덤프 파일의 최대 크기를 바이트 단위로 설정합니다. 이 한계를 초과하면 크래시 덤프가 잘립니다. 변수를 설정하지 않으면 기본적으로 크기 제한이 적용되지 않습니다. 변수가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 런타임 시스템은 크래시 덤프 파일을 쓰려고 시도조차하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8c996bd75b6c1e556e40ae90ed97ed437560b07" translate="yes" xml:space="preserve">
          <source>This variant is kept for compatibility.</source>
          <target state="translated">이 변형은 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f23ebd696e347931712dab86d1982b0ebcb811ea" translate="yes" xml:space="preserve">
          <source>This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails.</source>
          <target state="translated">이 동사는 패턴의 나머지 부분을 건너 뛰고 일치를 성공적으로 종료시킵니다. 그러나 서브 루틴이라고하는 서브 패턴 안에 있으면 해당 서브 패턴 만 성공적으로 종료됩니다. 그런 다음 일치는 외부 수준에서 계속됩니다. (* ACCEPT)가 긍정 주장에서 트리거되면 주장이 성공합니다. 부정 어설 션에서는 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d08ddef725078632007c7d27f955f2e16c27447f" translate="yes" xml:space="preserve">
          <source>This version encode atoms that can be represented by a latin1 string using latin1 encoding while only atoms that cannot be represented by latin1 are encoded using utf8.</source>
          <target state="translated">이 버전은 latin1 인코딩을 사용하여 latin1 문자열로 표시 될 수있는 원자를 인코딩하는 반면 latin1로 표현할 수없는 원자 만 utf8을 사용하여 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d758c1fa288ff4bea6ef5e3e118de5ef6067101b" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;wrap_log_reader&lt;/code&gt; does not detect if &lt;code&gt;disk_log&lt;/code&gt; wraps to a new index file between a call to &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; and the first call to &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt;. If this occurs, the call to &lt;code&gt;chunk()&lt;/code&gt; reads the last logged items in the log file, as the opened index file was truncated by &lt;code&gt;disk_log&lt;/code&gt;.</source>
          <target state="translated">이 버전의 &lt;code&gt;wrap_log_reader&lt;/code&gt; 이 경우 감지하지 못하는 &lt;code&gt;disk_log&lt;/code&gt; 에 대한 호출 사이에 새로운 인덱스 파일에 랩 &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; 과의 최초의 호출 &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt; . 이 경우 &lt;code&gt;chunk()&lt;/code&gt; 호출 은 열린 색인 파일이 &lt;code&gt;disk_log&lt;/code&gt; 에 의해 잘린 것처럼 로그 파일에서 마지막으로 기록 된 항목을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7892b8b3e220dc2d6df9f4226b75eda81b8a6c0a" translate="yes" xml:space="preserve">
          <source>This version of the stack is compliant with:</source>
          <target state="translated">이 버전의 스택은 다음을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="240472a34becd16e12bb3376c31742854774737c" translate="yes" xml:space="preserve">
          <source>This version of the stack supports version 1, 2 and 3 as defined by:</source>
          <target state="translated">이 버전의 스택은 다음에 의해 정의 된 버전 1, 2 및 3을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="12b130ec0f7a537e5f469d318f402ce06f564884" translate="yes" xml:space="preserve">
          <source>This way the decoder will detect which version is used and then use the proper decoder.</source>
          <target state="translated">이런 식으로 디코더는 사용되는 버전을 감지 한 다음 적절한 디코더를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fab39fc6a9980decfad2e7adaa7dbca6690bf5b" translate="yes" xml:space="preserve">
          <source>This weighted scheduler utilization will reach &lt;code&gt;1.0&lt;/code&gt; when schedulers are active the same amount of time as maximum available CPU time. If more schedulers exist than available logical processors, this value may be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">이 가중 스케줄러 사용률은 스케줄러가 사용 가능한 최대 CPU 시간과 동일한 시간 동안 활성화 될 때 &lt;code&gt;1.0&lt;/code&gt; 에 도달 합니다. 사용 가능한 논리 프로세서보다 많은 스케줄러가 존재하는 경우이 값은 &lt;code&gt;1.0&lt;/code&gt; 보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26f1c0ecf9835b048ce7fdf3cb11bce5cf430e0d" translate="yes" xml:space="preserve">
          <source>This will be transform into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;my_table&lt;/code&gt; 에 대한 하나의 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5959df48b0bcfac9f4ae84eabd6aeaab1c573506" translate="yes" xml:space="preserve">
          <source>This will be transform into two calls to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;my_table&lt;/code&gt; 에 대한 두 가지 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0938e7a4bcaf966d8f8e1648d8bf77602bdb131" translate="yes" xml:space="preserve">
          <source>This will create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">현재 디렉토리에 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8c674397ac895af2f7b4229947a7481b00df7c1" translate="yes" xml:space="preserve">
          <source>This will extract the string literal &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; into the variable &lt;code&gt;Foo&lt;/code&gt;. Note the use of the anonymous variable &lt;code&gt;9090&lt;/code&gt; to ignore the line number. To match and also bind a metavariable that must be an integer literal, we can use the convention of ending the integer with a 9, turning it into a Q-prefixed variable on the Erlang level (see the previous section).</source>
          <target state="translated">문자열 리터럴 &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; 을 변수 &lt;code&gt;Foo&lt;/code&gt; 로 추출합니다 . 행 번호를 무시하기 위해 익명 변수 &lt;code&gt;9090&lt;/code&gt; 을 사용 하십시오 . 정수 리터럴이어야하는 메타 변수를 일치시키고 바인드하기 위해 정수를 9로 끝내는 규칙을 사용하여 Erlang 레벨에서 Q 접두사 변수로 바꿉니다 (이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="6844398e7182f73065c78df4a613dbb5c67fbf34" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;copy_save&lt;/code&gt; option is enabled; see &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;copy_save&lt;/code&gt; 옵션이 활성화 되면 실패합니다 . &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="161516cb1d32cdac4670da18a1c368a544091541" translate="yes" xml:space="preserve">
          <source>This will have the following effect:</source>
          <target state="translated">다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="741ddd866b7f0cb141911125a2b18ae0245fffe3" translate="yes" xml:space="preserve">
          <source>This will produce a beam.smp.debug executable. The file are installed along side with the normal (opt) version &lt;code&gt;beam.smp&lt;/code&gt;.</source>
          <target state="translated">이것은 beam.smp.debug 실행 파일을 생성합니다. 파일은 일반 (opt) 버전 &lt;code&gt;beam.smp&lt;/code&gt; 와 함께 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a278059021fec133659ebfed89d918e76c5e908" translate="yes" xml:space="preserve">
          <source>This will start a &lt;code&gt;Collector&lt;/code&gt;, a &lt;code&gt;Viewer&lt;/code&gt; and also start the tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The &lt;code&gt;Raw Trace Data&lt;/code&gt; is collected by the &lt;code&gt;Collector&lt;/code&gt; and a view of it is displayed on the screen by the &lt;code&gt;Viewer&lt;/code&gt;. You can define your own &quot;views&quot; of the data by implementing your own &lt;code&gt;Filter&lt;/code&gt; functions and register them in the &lt;code&gt;Viewer&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;Collector&lt;/code&gt; , &lt;code&gt;Viewer&lt;/code&gt; 가 시작되고 &lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 호출 추적이 시작 됩니다. &lt;code&gt;Raw Trace Data&lt;/code&gt; 에 의해 수집 &lt;code&gt;Collector&lt;/code&gt; 과 이용의 전망은에 의해 화면에 표시됩니다 &lt;code&gt;Viewer&lt;/code&gt; . 자체 &lt;code&gt;Filter&lt;/code&gt; 기능 을 구현하여 데이터에 대한 &quot;보기&quot;를 정의 하고 &lt;code&gt;Viewer&lt;/code&gt; 에 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f434217aa97015d51cfaae19becfd875effa6d0a" translate="yes" xml:space="preserve">
          <source>This works even if &lt;code&gt;A&lt;/code&gt; is less than &lt;code&gt;-1.0&lt;/code&gt;, since in that case, &lt;code&gt;math:sqrt/1&lt;/code&gt; is never evaluated.</source>
          <target state="translated">이 경우 &lt;code&gt;math:sqrt/1&lt;/code&gt; 은 평가되지 않으므로 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;-1.0&lt;/code&gt; 보다 작은 경우에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3252af803922384f63b13c1da6ba4644d77b472e" translate="yes" xml:space="preserve">
          <source>This works for those codecs that support partial decode of the version, currently &lt;strong&gt;text&lt;/strong&gt;, and ber_bin (&lt;code&gt;megaco_binary_encoder&lt;/code&gt; and &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt;).</source>
          <target state="translated">이것은 현재 &lt;strong&gt;text&lt;/strong&gt; 및 ber_bin ( &lt;code&gt;megaco_binary_encoder&lt;/code&gt; 및 &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt; ) 버전의 부분 디코딩을 지원하는 코덱에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="68fb3cd1bc230ff55ec815a8606d4b126de4061a" translate="yes" xml:space="preserve">
          <source>This would give the same result as the earlier examples, namely:</source>
          <target state="translated">이는 이전 예제와 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f41ff74a32e2f2c5a120967bdd256a9d1fcf2924" translate="yes" xml:space="preserve">
          <source>This yields the following environment for &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">이렇게하면 &lt;code&gt;myapp&lt;/code&gt; 에 대한 다음 환경이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cfb63a03667f91e2dddce0870e2cddb4d2428fc" translate="yes" xml:space="preserve">
          <source>Those that are not part of an identified script are lumped together as &quot;Common&quot;. The following is the current list of scripts:</source>
          <target state="translated">식별 된 스크립트의 일부가 아닌 스크립트는 &quot;공통&quot;으로 묶습니다. 다음은 현재 스크립트 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e0fb7ae92ade7541465dddf7bdde5e485e470cba" translate="yes" xml:space="preserve">
          <source>Those warnings cannot be disabled (except by disabling all warnings).</source>
          <target state="translated">이러한 경고는 비활성화 할 수 없습니다 (모든 경고를 비활성화 한 경우 제외).</target>
        </trans-unit>
        <trans-unit id="c351ee3b38329481117c9035b830002ad412235a" translate="yes" xml:space="preserve">
          <source>Thread identifier.</source>
          <target state="translated">스레드 식별자.</target>
        </trans-unit>
        <trans-unit id="472d223957fc2ad616dbfe0655959f460d590ae4" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="translated">스레드 옵션 구조가 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음 필드가 존재합니다 :</target>
        </trans-unit>
        <trans-unit id="2d38b72cd000a892fe63ed8ba79ccaabfe4c2e80" translate="yes" xml:space="preserve">
          <source>Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are &amp;lt; 256, but they do work in this mode. The following are the extra escape sequences:</source>
          <target state="translated">특정 특성을 가진 문자와 일치하는 세 개의 이스케이프 시퀀스를 사용할 수 있습니다. 8 비트 비 UTF-8 모드 인 경우이 시퀀스는 코드 포인트가 &amp;lt;256 인 문자 테스트로 제한되지만이 모드에서는 작동합니다. 추가 이스케이프 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48145c695e12f789bd065e16fe1bba615544dbc8" translate="yes" xml:space="preserve">
          <source>Three network messages to execute the two-phase commit protocol</source>
          <target state="translated">2 단계 커밋 프로토콜을 실행하기위한 3 개의 네트워크 메시지</target>
        </trans-unit>
        <trans-unit id="5b4d080b2f7b28c85cb580a4943bbfa952b77805" translate="yes" xml:space="preserve">
          <source>Three predefined resolve functions exist: &lt;code&gt;random_exit_name/3&lt;/code&gt;, &lt;code&gt;random_notify_name/3&lt;/code&gt;, and &lt;code&gt;notify_all_name/3&lt;/code&gt;. If no &lt;code&gt;Resolve&lt;/code&gt; function is defined, &lt;code&gt;random_exit_name&lt;/code&gt; is used. This means that one of the two registered processes is selected as correct while the other is killed.</source>
          <target state="translated">&lt;code&gt;random_exit_name/3&lt;/code&gt; , &lt;code&gt;random_notify_name/3&lt;/code&gt; 및 &lt;code&gt;notify_all_name/3&lt;/code&gt; 의 세 가지 사전 정의 된 해결 기능이 있습니다 . &lt;code&gt;Resolve&lt;/code&gt; 기능이 정의되어 있지 않으면 &lt;code&gt;random_exit_name&lt;/code&gt; 이 사용됩니다. 이는 등록 된 두 프로세스 중 하나가 올바른 것으로 선택되고 다른 프로세스는 종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="789fe986bc68eef06a581bacefa09c9f316ad600" translate="yes" xml:space="preserve">
          <source>Three types of Dets tables exist:</source>
          <target state="translated">세 가지 유형의 Dets 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de17dda2df1b0a4a41a2a36ed513ae1a8fa82e62" translate="yes" xml:space="preserve">
          <source>Three types of logs are supported: transfer logs, security logs, and error logs. The de-facto standard Common Logfile Format is used for the transfer and security logging. There are numerous statistics programs available to analyze Common Logfile Format. The Common Logfile Format looks as follows:</source>
          <target state="translated">전송 로그, 보안 로그 및 오류 로그의 세 가지 유형의 로그가 지원됩니다. 사실상의 표준 공통 로그 파일 형식은 전송 및 보안 로깅에 사용됩니다. 공통 로그 파일 형식을 분석 할 수있는 수많은 통계 프로그램이 있습니다. 공통 로그 파일 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e9b97eab33817fa09e3b807cdad0cad941b514c" translate="yes" xml:space="preserve">
          <source>Three-per-em space</source>
          <target state="translated">3 인당 공간</target>
        </trans-unit>
        <trans-unit id="353307ebea91bdeb49e95a772ca9672b8b9ff1c9" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">최대 파일 크기에 대한 임계 값은 바이트 단위입니다. 한도를 초과하면 전송이 중단됩니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81e689740a1ea2ba496a99261372d7eb5ff76c39" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">최대 활성 연결 수에 대한 임계 값입니다. 한계가 초과되면 데몬은 새 연결 설정을 거부합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5d2d9adf32dacfb55f57f6ed9d271632c69577" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</source>
          <target state="translated">최대 재시도 횟수에 대한 임계 값입니다. 기본적으로 서버 / 클라이언트는 시간 초과가 만료되면 최대 5 번까지 메시지를 다시 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="0ef311c86e366780b4c01dfd6e2377efaa407576" translate="yes" xml:space="preserve">
          <source>Through CTHs the results of tests and configuration functions can be manipulated. The main purpose to do this with CTHs is to allow common patterns to be abstracted out from test suites and applied to multiple test suites without duplicating any code. All the callback functions for a CTH follow a common interface described hereafter.</source>
          <target state="translated">CTH를 통해 테스트 결과 및 구성 기능을 조작 할 수 있습니다. CTH를 사용하여이 작업을 수행하는 주요 목적은 코드를 복제하지 않고도 공통 테스트 패턴을 테스트 스위트에서 추출하여 여러 테스트 스위트에 적용 할 수 있도록하는 것입니다. CTH에 대한 모든 콜백 함수는 이후에 설명 된 공통 인터페이스를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0aa7d917559b259354cb862e1c7d69350b345c76" translate="yes" xml:space="preserve">
          <source>Through a trigger function with a match specification created with &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt; 로 작성된 일치 스펙을 가진 트리거 함수를 통해 .</target>
        </trans-unit>
        <trans-unit id="dee8ee6675b19f7cc839a400403e3a6bdfc64698" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;Mnesia&lt;/code&gt; (on one node) can hang if a double fault occurs, that is, when two nodes crash simultaneously and one attempts to start when the other refuses to start, for example, because of a hardware error.</source>
          <target state="translated">따라서 이중 오류가 발생하는 경우, 즉 두 노드가 동시에 충돌하고 다른 노드가 시작을 거부 할 때 (예 : 하드웨어 오류로 인해) 하나의 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08620ab1394e488e40f6d760c0e43eb52ae9ae1e" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ch3&lt;/code&gt; must be loaded before &lt;code&gt;m1&lt;/code&gt;, in the upgrade case, and conversely in the downgrade case. &lt;code&gt;m1&lt;/code&gt; is said to be &lt;strong&gt;dependent on&lt;/strong&gt;&lt;code&gt;ch3&lt;/code&gt;. In a release handling instruction, this is expressed by the &lt;code&gt;DepMods&lt;/code&gt; element:</source>
          <target state="translated">따라서 &lt;code&gt;ch3&lt;/code&gt; 은 &lt;code&gt;m1&lt;/code&gt; 전에 , 업그레이드의 경우, 반대로 다운 그레이드의 경우 로드되어야합니다 . &lt;code&gt;m1&lt;/code&gt; 은 &lt;code&gt;ch3&lt;/code&gt; 에&lt;strong&gt;의존&lt;/strong&gt; 한다고합니다 . 릴리스 처리 명령에서 이는 &lt;code&gt;DepMods&lt;/code&gt; 요소로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4aac5229f9aff631f4112d990ef52e941da8602" translate="yes" xml:space="preserve">
          <source>Thus, Erlang pids contain information about where the process executes. So if you know the pid of a process, the &quot;!&quot; operator can be used to send it a message disregarding if the process is on the same node or on a different node.</source>
          <target state="translated">따라서 Erlang pid에는 프로세스 실행 위치에 대한 정보가 포함됩니다. 프로세스의 pid를 알고 있다면 &quot;!&quot; 연산자는 프로세스가 동일한 노드 또는 다른 노드에 있는지 여부를 무시하고 메시지를 보내는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc9ac17e54e53ed54d89ecd362584a70502cce6" translate="yes" xml:space="preserve">
          <source>Thus, each table is made up of records, where the first element is a record name and the second element of the table is a key, which identifies the particular record in that table. The combination of the table name and a key is an arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; called the OID. For more information about the relationship beween the record name and the table name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">따라서 각 테이블은 레코드로 구성되며, 여기서 첫 번째 요소는 레코드 이름이고 두 번째 요소는 키이며 해당 테이블의 특정 레코드를 식별합니다. 테이블 이름과 키의 조합은 OID라고 하는 arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; 입니다. 레코드 이름과 테이블 이름 간의 관계에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt; 테이블 이름을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98419cf3e6cb70f3d1ec7c30e6c6cd8e96f4569b" translate="yes" xml:space="preserve">
          <source>Thus, groups of users with identical cookie files get Erlang nodes that can communicate freely and without interference from the magic cookie system. Users who want to run nodes on separate file systems must make certain that their cookie files are identical on the different file systems.</source>
          <target state="translated">따라서 동일한 쿠키 파일을 가진 사용자 그룹은 매직 쿠키 시스템의 간섭없이 자유롭게 통신 할 수있는 Erlang 노드를 얻습니다. 별도의 파일 시스템에서 노드를 실행하려는 사용자는 쿠키 파일이 다른 파일 시스템에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8100fa7ba98e8e96e75fe52a1370cae3f3496b11" translate="yes" xml:space="preserve">
          <source>Thus, in Erlang the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to encode a boolean value.</source>
          <target state="translated">따라서 Erlang에서 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 원자 는 부울 값을 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7ecce73f034bf35ecbb506fb930930ac4b3eff" translate="yes" xml:space="preserve">
          <source>Thus, it can be assumed that if an application wants to use tables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, the application must perform some action similar to following before it can use the tables:</source>
          <target state="translated">따라서 애플리케이션이 테이블 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 를 사용하려는 경우 애플리케이션이 테이블을 사용 하기 전에 다음과 유사한 조치를 수행해야 한다고 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e5bc2487ff82b85d2e3b10893d75ddc6f14f8fa" translate="yes" xml:space="preserve">
          <source>Thus, knowing the allowed structure it is easy to write a program that traverses the data structure and picks the information in the xmlElements records with name date.</source>
          <target state="translated">따라서 허용 된 구조를 알면 데이터 구조를 탐색하고 이름 날짜로 xmlElements 레코드의 정보를 선택하는 프로그램을 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2e92eacbda98564b7e1dba01abee128e6082f80" translate="yes" xml:space="preserve">
          <source>Thus, the call &lt;code&gt;ch3:alloc()&lt;/code&gt; returns the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the &lt;code&gt;gen_server&lt;/code&gt; then waits for new requests, now with an updated list of available channels.</source>
          <target state="translated">따라서 &lt;code&gt;ch3:alloc()&lt;/code&gt; 호출 은 할당 된 채널 &lt;code&gt;Ch&lt;/code&gt; 를 반환 하고 &lt;code&gt;gen_server&lt;/code&gt; 는 새로운 요청을 기다립니다. 이제는 사용 가능한 채널 목록이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebad642bddf4ab3db22dd4beeeeb7f4311403f9" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-COMMUNITY-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-COMMUNITY-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7c61a5b14ab98813376fed50c0cd8d251b07679" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-FRAMEWORK-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-FRAMEWORK-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="612f9db5bba916759b754b605a4e539b1a5e5a7e" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-NOTIFICATION-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-NOTIFICATION-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d1588ecea3ad2284ae9aa05caccc396d78985d5" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-STANDARD-MIB 및 SNMPv2-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="43f6071a8cb0a08a947926938c79fe87f3b23556" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-TARGET-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-TARGET-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="698103ec7a5a24bef7840c9a9eb88301e5ac5c6b" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-USER-BASED-SM-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="b154aa3e0b0b0cb0972c7b7c21e5fa2a7b63dbbc" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-VIEW-BASED-ACM-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ece286b7b7e10c58b8006a0db1d818bda1598793" translate="yes" xml:space="preserve">
          <source>Thus, the defined callbacks are as follows:</source>
          <target state="translated">따라서 정의 된 콜백은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7283b7df46e07452f871697fbbb43dfaeb34c85" translate="yes" xml:space="preserve">
          <source>Thus, the following pattern matches all possible clauses:</source>
          <target state="translated">따라서 다음 패턴은 가능한 모든 절과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a6da41a12dddbe97c927f5b83e0ea21b128613a3" translate="yes" xml:space="preserve">
          <source>Thus, the main representation of test sets is &lt;strong&gt;deep lists&lt;/strong&gt;, and a simple test object can be viewed as a test set containing only a single test; there is no difference between &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">따라서 테스트 세트의 주요 표현은 &lt;strong&gt;딥리스트&lt;/strong&gt; 이며 간단한 테스트 개체는 단일 테스트 만 포함하는 테스트 세트로 볼 수 있습니다. &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;[T]&lt;/code&gt; 사이에는 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="72fc65dc129a4472605c016017814aa86198846c" translate="yes" xml:space="preserve">
          <source>Thus, the module is called &lt;strong&gt;tut&lt;/strong&gt;. Notice the full stop &quot;.&quot; at the end of the line. The files which are used to store the module must have the same name as the module but with the extension &quot;.erl&quot;. In this case the file name is &lt;code&gt;tut.erl&lt;/code&gt;. When using a function in another module, the syntax &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; is used. So the following means call function &lt;code&gt;double&lt;/code&gt; in module &lt;code&gt;tut&lt;/code&gt; with argument &quot;10&quot;.</source>
          <target state="translated">따라서이 모듈을 &lt;strong&gt;tut&lt;/strong&gt; 라고 합니다. 멈춤 표시 &quot;.&quot; 줄의 끝에서. 모듈을 저장하는 데 사용되는 파일은 모듈 이름과 동일하지만 확장자는 &quot;.erl&quot;이어야합니다. 이 경우 파일 이름은 &lt;code&gt;tut.erl&lt;/code&gt; 입니다. 다른 모듈에서 함수를 사용할 때는 구문 &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; 이 사용됩니다. 따라서 다음은 인수 &quot;10&quot;으로 모듈 &lt;code&gt;tut&lt;/code&gt; 에서 함수 &lt;code&gt;double&lt;/code&gt; 을 호출하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c34ce3a6ce18ac5cd93d950cae3e6a6b1eaefbd7" translate="yes" xml:space="preserve">
          <source>Thus, two instances of the application run simultaneously during the takeover, so that data can be transferred from the old to the new instance. If this is not an acceptable behavior, parts of the old instance can be shut down when the new instance is started. However, the application cannot be stopped entirely, at least the top supervisor must remain alive.</source>
          <target state="translated">따라서 인계 중에 두 개의 애플리케이션 인스턴스가 동시에 실행되므로 이전 인스턴스에서 새 인스턴스로 데이터를 전송할 수 있습니다. 이것이 허용 가능한 동작이 아닌 경우 새 인스턴스가 시작될 때 이전 인스턴스의 일부가 종료 될 수 있습니다. 그러나 응용 프로그램을 완전히 중지 할 수는 없으며 최소한 최고 감독자가 살아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="495255dc624907e5a1daae0dcc0d862cd07a65e4" translate="yes" xml:space="preserve">
          <source>Tidies Erlang source files in a directory and its subdirectories.</source>
          <target state="translated">디렉토리와 서브 디렉토리에 Erlang 소스 파일을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="5ab18872f1a912f1810a74934cd2ae2c9eab483f" translate="yes" xml:space="preserve">
          <source>Tidies a syntax tree representation of a module definition. The given &lt;code&gt;Forms&lt;/code&gt; may be either a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. In either case, &lt;code&gt;Forms&lt;/code&gt; must represent a single complete module definition. The returned syntax tree has type &lt;code&gt;form_list&lt;/code&gt; and represents a tidied-up version of the same source code.</source>
          <target state="translated">모듈 정의의 구문 트리 표현을 정리합니다. 주어진 &lt;code&gt;Forms&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 단일 구문 트리 이거나 &quot;프로그램 형식&quot;을 나타내는 구문 트리 목록 일 수 있습니다 . 두 경우 모두 &lt;code&gt;Forms&lt;/code&gt; 은 하나의 완전한 모듈 정의를 나타내야합니다. 반환 된 구문 트리는 &lt;code&gt;form_list&lt;/code&gt; 유형 이며 동일한 소스 코드의 정리 된 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1ca9281bec4536e142232511847b2d622b54efd" translate="yes" xml:space="preserve">
          <source>Tidies an Erlang source code file.</source>
          <target state="translated">Erlang 소스 코드 파일을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="82f374f21b06bcdcda1afc18f61cb6cebcc8d024" translate="yes" xml:space="preserve">
          <source>Tidies and pretty-prints Erlang source code, removing unused functions, updating obsolete constructs and function calls, etc.</source>
          <target state="translated">Erlang 소스 코드 정리 및 예쁘게 인쇄, 사용하지 않는 함수 제거, 사용되지 않는 구문 및 함수 호출 업데이트 등</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="a82ad5fd600ff000d4dd1a4b75dec09bd53099b8" translate="yes" xml:space="preserve">
          <source>Time in milli-seconds.</source>
          <target state="translated">밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="fb90c3d94bbbbb48a0690451d16d4a2746e6cf58" translate="yes" xml:space="preserve">
          <source>Time in milliseconds.</source>
          <target state="translated">밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="52f73c9f88768be27ae1df301f0781defb2c8b55" translate="yes" xml:space="preserve">
          <source>Time interval (in seconds) between each update of the display.</source>
          <target state="translated">각 디스플레이 업데이트 사이의 시간 간격 (초).</target>
        </trans-unit>
        <trans-unit id="aa2bb96c7dd2c54fd6b747929cbd2b7c505afa22" translate="yes" xml:space="preserve">
          <source>Time is in milliseconds.</source>
          <target state="translated">시간은 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="9335c98c7b128731a14ad90889a8a634ba7a0e3f" translate="yes" xml:space="preserve">
          <source>Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT).</source>
          <target state="translated">현재 시간대 및 일광 절약 시간제에 따라 조정하면 시간이 현지화됩니다. 일광 절약 시간을 조정하지 않고 경도 0의 시간을 반영 할 때 시간은 보편적입니다. UTC (협정 세계시) 시간을 그리니치 표준시 (GMT)라고도합니다.</target>
        </trans-unit>
        <trans-unit id="778cab80afb8fbb53cb2e3770f0d9802c84b4243" translate="yes" xml:space="preserve">
          <source>Time is shown as percentage of total time and as absolute time.</source>
          <target state="translated">시간은 총 시간의 백분율과 절대 시간으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfab7fde2f2bd1c95dae042160e5b78de938455d" translate="yes" xml:space="preserve">
          <source>Time is vital to an Erlang program and, more importantly, &lt;strong&gt;correct&lt;/strong&gt; time is vital to an Erlang program. As Erlang is a language with soft real-time properties and we can express time in our programs, the Virtual Machine and the language must be careful about what is considered a correct time and in how time functions behave.</source>
          <target state="translated">시간이 더 중요한 얼랑 프로그램에 중요합니다, &lt;strong&gt;정확한&lt;/strong&gt; 시간은 얼랑 프로그램에 중요합니다. Erlang은 소프트 실시간 속성이있는 언어이므로 프로그램에서 시간을 표현할 수 있으므로 가상 머신과 언어는 올바른 시간으로 간주되는 시간과 시간 기능이 작동하는 방식에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfb8ee1d3368aa29179a6d65ecd926cdeee8b67e" translate="yes" xml:space="preserve">
          <source>Time of failure.</source>
          <target state="translated">실패 시간.</target>
        </trans-unit>
        <trans-unit id="e5b5ff320546cded57bcdfd8e9154e88bfce347b" translate="yes" xml:space="preserve">
          <source>Time since &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt;. Epoch is defined to be 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt;, 1970-01-01. &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; is defined to be exactly 86400 seconds long. Strangely enough, Epoch is defined to be a time in UTC, and UTC has another definition of how long a day is. Quoting the Open Group &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt;. The effect of this is that when an UTC leap second is inserted, POSIX time either stops for a second, or repeats the last second. If an UTC leap second would be deleted (which has not happened yet), POSIX time would make a one second leap forward.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt; 이후의 시간 . Epoch는 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; , 1970-01-01 로 정의됩니다 . &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; 정확히 86400 초로 정의됩니다. 이상하게도 Epoch는 UTC로 시간이 정의되고 UTC는 하루의 길이에 대한 다른 정의를 갖습니다. 오픈 그룹 인용 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt; . 그 결과 UTC 윤초가 삽입되면 POSIX 시간이 1 초 동안 멈추거나 마지막 초가 반복됩니다. UTC 도약 초가 삭제되면 (아직 발생하지 않은 경우) POSIX 시간이 1 초 도약합니다.</target>
        </trans-unit>
        <trans-unit id="daff1c5051fc31c193cbc0ef30cf4e11a8fa0acc" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">기다리는 데 시간이 많이 걸렸습니다. 또한 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 사용할 때 스케줄러가 더 이상 활성 상태임을보고하지 않는 상태 입니다. 따라서이 상태를 제외한 다른 모든 상태를 추가하고 스레드에서 모든 시간으로 나누면 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 분수 와 매우 비슷한 것을 얻을 수 있습니다. 추가 상태가 없으면 이번은 &lt;code&gt;other&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="4b70b59840bac36480b4ca278b19551bc7ff7ba0" translate="yes" xml:space="preserve">
          <source>Time spent checking for new I/O events.</source>
          <target state="translated">새로운 I / O 이벤트를 확인하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f8c4236fa95ff532dbcc0e2d31ef284b6605be9f" translate="yes" xml:space="preserve">
          <source>Time spent doing fullsweep garbage collection. Without extra states this time is part of the &lt;code&gt;gc&lt;/code&gt; state.</source>
          <target state="translated">풀 스윕 가비지 수집에 소요 된 시간입니다. 추가 상태가 없으면 이번은 &lt;code&gt;gc&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="804fe3e4c31d22ca440eb466bced64dac260645c" translate="yes" xml:space="preserve">
          <source>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</source>
          <target state="translated">가비지 수집에 소요 된 시간입니다. 추가 상태가 활성화되면 비 스위스 가비지 수집에 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f0d5415566936904747ef14c0c4e3fb853196c06" translate="yes" xml:space="preserve">
          <source>Time spent doing unaccounted things.</source>
          <target state="translated">설명되지 않은 일을하는 데 걸린 시간.</target>
        </trans-unit>
        <trans-unit id="4ba30f1fc2208657042880d6015e182708b6ae95" translate="yes" xml:space="preserve">
          <source>Time spent executing ETS BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">ETS BIF를 실행하는 데 소요 된 시간입니다. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6f0aba2d54a382bffda8610e637bf0f9265a1fa2" translate="yes" xml:space="preserve">
          <source>Time spent executing Erlang processes.</source>
          <target state="translated">Erlang 프로세스를 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2140217ef427aad1b621513a3b193759d78a1510" translate="yes" xml:space="preserve">
          <source>Time spent executing ports.</source>
          <target state="translated">포트를 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="1d9aa0e3f8d5f8534bd40659e4d0e67ab0101833" translate="yes" xml:space="preserve">
          <source>Time spent handling auxiliary jobs.</source>
          <target state="translated">보조 작업을 처리하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="18b77c82a332110e23d9be0001f08986fee15519" translate="yes" xml:space="preserve">
          <source>Time spent in BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">BIF에 소요 된 시간. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="bcdc57b7f7275d059418c6711b15d167f486f63c" translate="yes" xml:space="preserve">
          <source>Time spent in NIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">NIF에서 보낸 시간. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="4050018617b293ffdfb42ee633136a70a84f563a" translate="yes" xml:space="preserve">
          <source>Time spent managing memory. Without extra states this time is spread out over all other states.</source>
          <target state="translated">메모리 관리에 소요 된 시간입니다. 추가 상태가 없으면이 시간이 다른 모든 상태에 퍼집니다.</target>
        </trans-unit>
        <trans-unit id="9c01fc3b7f3c2c3c0d6942008a58943e7689d103" translate="yes" xml:space="preserve">
          <source>Time spent managing timers. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">타이머 관리에 소요 된 시간입니다. 추가 상태가 없으면 이번은 &lt;code&gt;other&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="219f1ac61c024af183643b65bf00f27585517b49" translate="yes" xml:space="preserve">
          <source>Time spent sending messages (processes only). Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">메시지를 보내는 데 소요 된 시간 (프로세스 만) 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="cbdb8b8de682894a050f647f9b6f67984322b3e7" translate="yes" xml:space="preserve">
          <source>Time spent sleeping.</source>
          <target state="translated">잠자는 시간.</target>
        </trans-unit>
        <trans-unit id="5e12873ae797e4ba07d58c20986f4c5eb0d01fbc" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages consist of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">프로필 메시지의 타임 스탬프는 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 단조 증가 정수로 구성됩니다. 타임 스탬프 (Ts)는 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0a74926d30453b95a42997402e366f9dbba46f4a" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages include a time stamp (Ts) that has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;. This is also the default if no time stamp flag is specified. If &lt;code&gt;cpu_timestamp&lt;/code&gt; has been enabled through &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, this also effects the time stamp produced in profiling messages when flag &lt;code&gt;timestamp&lt;/code&gt; is enabled.</source>
          <target state="translated">프로필 메시지의 타임 스탬프에는 &lt;code&gt;erlang:now()&lt;/code&gt; 반환 한 것과 동일한 형식의 타임 스탬프 (Ts)가 포함됩니다 . 타임 스탬프 플래그가 지정되지 않은 경우에도 기본값입니다. 경우 &lt;code&gt;cpu_timestamp&lt;/code&gt; 을 통해 활성화 된 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , 이것은 또한 플래그 때 메시지를 프로파일 링에서 생성 된 타임 스탬프에 영향을 미친다 &lt;code&gt;timestamp&lt;/code&gt; 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="22076e8ed9090afa79ae14afc1154da3fcea7d53" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages use &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">프로필 메시지의 타임 스탬프는 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="08ca334e927c4c6c13a180ed022f0e1809c6b0ea" translate="yes" xml:space="preserve">
          <source>Time unit expressed in parts per second. That is, the time unit equals &lt;code&gt;1/PartsPerSecond&lt;/code&gt; second.</source>
          <target state="translated">초당 단위로 표시되는 시간 단위. 즉, 시간 단위는 &lt;code&gt;1/PartsPerSecond&lt;/code&gt; 초입니다.</target>
        </trans-unit>
        <trans-unit id="56955f846ca14fda201279a48f5480070c862756" translate="yes" xml:space="preserve">
          <source>Time unit of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">의 시간 단위 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf7ef9b043acd2fefcc767917bfb64bbe68691e" translate="yes" xml:space="preserve">
          <source>Time unit of returned value.</source>
          <target state="translated">반환 값의 시간 단위.</target>
        </trans-unit>
        <trans-unit id="c31fd1a438289cad94f807ff509ea2830cb0a280" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 에 대한 호출로 설정 타이머를 작성하는 데 사용되는 시간 입니다. 타이머는 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cba69c610e8e4d4cb1aafc070b3b00791654be26" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 에 대한 호출로 설정 타이머를 작성하는 데 사용되는 시간 입니다. 타이머는 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ead486368f8803155ffc6453947e99e4019e5bc" translate="yes" xml:space="preserve">
          <source>Time warp safe code can handle a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타임 워프 안전 코드는 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="75c9ade9b7ea54157fc5ea15b058fcb35255e656" translate="yes" xml:space="preserve">
          <source>Time when the event record was created.</source>
          <target state="translated">이벤트 레코드가 작성된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="1078e1766373df8f70c0326e90a0881d10d2001d" translate="yes" xml:space="preserve">
          <source>Time when the trace was generated. Same as event_ts if omitted in trace data.</source>
          <target state="translated">추적이 생성 된 시간입니다. 추적 데이터에서 생략 된 경우 event_ts와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7c54440dd4618f7bc17db7c59ce90a91687e0a3f" translate="yes" xml:space="preserve">
          <source>Time-constrained tracing</source>
          <target state="translated">시간이 제한된 추적</target>
        </trans-unit>
        <trans-unit id="dad879fd6c0ee22983f6de70e89c35317fb40e21" translate="yes" xml:space="preserve">
          <source>Time-out expired.</source>
          <target state="translated">시간이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e8c25c48b5132875c91d0c03a35c580928a7337" translate="yes" xml:space="preserve">
          <source>Time-out time for the request.</source>
          <target state="translated">요청 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbff00965ebcca637b30964828cca5002698389b" translate="yes" xml:space="preserve">
          <source>Time-out timers &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events.</source>
          <target state="translated">타임 아웃 타이머 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 이 처리됩니다. 시간이 0 인 시간 초과는 아직 외부 수신되지 않은 이벤트가 발생하기 전에 상태 시스템에 전달되도록 보장되므로 해당 시간이 요청되면 해당 시간 초과 0 이벤트가 최신 수신 이벤트로 대기열에 추가됩니다. 즉, 삽입 및 연기 된 이벤트와 같은 이미 대기중인 이벤트 이후입니다.</target>
        </trans-unit>
        <trans-unit id="921bd14fe959f56d9bf6ef39fbc93c256e6bb1db" translate="yes" xml:space="preserve">
          <source>Time-out, in milliseconds, for establishing an association</source>
          <target state="translated">연결 설정을위한 시간 초과 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="b9d894573097754c7b54a6191c10c2264d5de941" translate="yes" xml:space="preserve">
          <source>Timeout ::</source>
          <target state="translated">타임 아웃 ::</target>
        </trans-unit>
        <trans-unit id="9ba0fea57692bed3e35ebe6f8f6d8f58f2ad3a37" translate="yes" xml:space="preserve">
          <source>Timeout :: timeout()) -&amp;gt;</source>
          <target state="translated">타임 아웃 :: timeout ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fd55cd4f150e662912da414d712d8565cc5d6ef" translate="yes" xml:space="preserve">
          <source>Timeout = &lt;code&gt;non_neg_integer()&lt;/code&gt;</source>
          <target state="translated">시간 초과 = &lt;code&gt;non_neg_integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c83fda5023992a3a755c63b7feecf8cc4bb563b5" translate="yes" xml:space="preserve">
          <source>Timeout has expired.</source>
          <target state="translated">타임 아웃이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="4de3dd3689e574562fe201d283c89d77aad9ff30" translate="yes" xml:space="preserve">
          <source>Timeout set the maximum time in milliseconds that each server request may take.</source>
          <target state="translated">시간 초과는 각 서버 요청에 걸리는 최대 시간 (밀리 초)을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0c72d1236b15e71c6081373a09d082eddd39e1e9" translate="yes" xml:space="preserve">
          <source>Timeout time for the call proxy.</source>
          <target state="translated">통화 프록시의 시간 초과 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b5240d69e014aa8db2761b61b654dac666884a70" translate="yes" xml:space="preserve">
          <source>Timeout) -&amp;gt;</source>
          <target state="translated">타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cbe7ffd10c56674d0aeb143b8aef6a19536cbe9f" translate="yes" xml:space="preserve">
          <source>Timer functions.</source>
          <target state="translated">타이머 기능.</target>
        </trans-unit>
        <trans-unit id="5775c0fa857a175458a6f31fe323d1c61544a03a" translate="yes" xml:space="preserve">
          <source>Timers and re-send of messages will be handled on locally on one node, that is node(1), in order to avoid unnecessary transfer of data between the Erlang nodes.</source>
          <target state="translated">Erlang 노드간에 불필요한 데이터 전송을 피하기 위해 타이머 및 메시지 재전송은 하나의 노드, 즉 node (1)에서 로컬로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="345e4b38e568b767b30f56f4731767a882691f68" translate="yes" xml:space="preserve">
          <source>Timestamp = {MegaSecs, Secs, MicroSecs}</source>
          <target state="translated">타임 스탬프 = {MegaSecs, Secs, MicroSecs}</target>
        </trans-unit>
        <trans-unit id="15a044fe233b5f5d8f3f995d7e5a1a639fcad92c" translate="yes" xml:space="preserve">
          <source>Timestamps are formatted according to RFC3339, and the time designator is the character used as date and time separator.</source>
          <target state="translated">타임 스탬프는 RFC3339에 따라 형식이 지정되며 시간 지정자는 날짜 및 시간 구분 기호로 사용되는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="ec489097f09779c8f0337c7ffff14c271f605260" translate="yes" xml:space="preserve">
          <source>Timetrap values can be extended with a multiplier value specified at startup with option &lt;code&gt;multiply_timetraps&lt;/code&gt;. It is also possible to let the test server decide to scale up timetrap time-out values automatically. That is, if tools such as &lt;code&gt;cover&lt;/code&gt; or &lt;code&gt;trace&lt;/code&gt; are running during the test. This feature is disabled by default and can be enabled with start option &lt;code&gt;scale_timetraps&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;multiply_timetraps&lt;/code&gt; 를 사용 하여 시작시 지정된 승수 값으로 타임 트랩 값을 확장 할 수 있습니다 . 테스트 서버가 타임 랩 타임 아웃 값을 자동으로 확장하도록 결정할 수도 있습니다. 즉 , 테스트 중에 &lt;code&gt;cover&lt;/code&gt; 나 &lt;code&gt;trace&lt;/code&gt; 와 같은 도구 가 실행되고있는 경우입니다. 이 기능은 기본적으로 비활성화되어 있으며 시작 옵션 &lt;code&gt;scale_timetraps&lt;/code&gt; 로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4a7717f17e9b8af076c5d38d2f59e28a523086" translate="yes" xml:space="preserve">
          <source>Tirhuta</source>
          <target state="translated">Tirhuta</target>
        </trans-unit>
        <trans-unit id="b51456deb293c14e281cc125141b1ca93bd63d71" translate="yes" xml:space="preserve">
          <source>Title case letter</source>
          <target state="translated">타이틀 케이스 레터</target>
        </trans-unit>
        <trans-unit id="175f9c3cbfadc16808edf4696a9a651beef5a26c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - client side</source>
          <target state="translated">TLS / DTLS 옵션 설명-클라이언트 측</target>
        </trans-unit>
        <trans-unit id="ebe960548ac60cdb2adcef7ca8456b9e2d23126c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - server side</source>
          <target state="translated">TLS / DTLS 옵션 설명-서버 측</target>
        </trans-unit>
        <trans-unit id="bf91222de5df25eb68a0c8123513399e374daae1" translate="yes" xml:space="preserve">
          <source>To &quot;teach&quot; the function how to extract, you can give a fun which replaces the default extraction function. The &lt;code&gt;fqdn_fun&lt;/code&gt; takes one argument and returns either a &lt;code&gt;string()&lt;/code&gt; to be matched to each CN-name or the atom &lt;code&gt;default&lt;/code&gt; which will invoke the default fqdn extraction function. The return value &lt;code&gt;undefined&lt;/code&gt; removes the current URI from the fqdn extraction.</source>
          <target state="translated">함수를 추출하는 방법을 &quot;교육&quot;하기 위해 기본 추출 기능을 대체하는 재미를 줄 수 있습니다. &lt;code&gt;fqdn_fun&lt;/code&gt; 는 하나 개의 인수 및 반환 값 중 하나 얻어 &lt;code&gt;string()&lt;/code&gt; 각각 CN-이름 또는 원자에 매칭되는 &lt;code&gt;default&lt;/code&gt; 기본 FQDN 추출 함수를 호출한다. &lt;code&gt;undefined&lt;/code&gt; 반환 값 은 fqdn 추출에서 현재 URI를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c6ddde9755b765c3b046311bcbccd6ae209f1079" translate="yes" xml:space="preserve">
          <source>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; instead of the simplified functions &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이러한 테이블에 액세스하려면 앞에서 설명한 간단한 액세스 기능을 사용할 수 없습니다. 예를 들어, 구독자 레코드를 테이블에 &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; 려면 단순화 된 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt; 대신 mnesia : write / 3 함수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8dcb832da82946e10018f4faeadf19cfc862a" translate="yes" xml:space="preserve">
          <source>To acess the record in your callback-module use:</source>
          <target state="translated">콜백 모듈에서 레코드에 액세스하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e9f9ccb32571596628f903ebec0197042453a6d" translate="yes" xml:space="preserve">
          <source>To achieve authentication and privacy, the client and server perform a TLS/DTLS handshake procedure before transmitting or receiving any data. During the handshake, they agree on a protocol version and cryptographic algorithms, generate shared secrets using public key cryptographies, and optionally authenticate each other with digital certificates.</source>
          <target state="translated">인증 및 개인 정보 보호를 위해 클라이언트와 서버는 데이터를 전송하거나 수신하기 전에 TLS / DTLS 핸드 셰이크 절차를 수행합니다. 핸드 셰이크 중에 프로토콜 버전 및 암호화 알고리즘에 동의하고 공개 키 암호화를 사용하여 공유 비밀을 생성하며 선택적으로 디지털 인증서로 서로 인증합니다.</target>
        </trans-unit>
        <trans-unit id="0ec1db4ecbaf3ec0b305eae994234d479d4f46e8" translate="yes" xml:space="preserve">
          <source>To act as a timetrap. The time-out is triggered when the function returns.</source>
          <target state="translated">타임 트랩으로 작동합니다. 시간 초과는 함수가 반환 될 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="589688126179f4b6262587b2faac1c9d33d97234" translate="yes" xml:space="preserve">
          <source>To activate the code coverage support, specify the name of the cover specification file as you start &lt;code&gt;Common Test&lt;/code&gt;. Do this by using flag &lt;code&gt;-cover&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">코드 적용 범위 지원을 활성화하려면 &lt;code&gt;Common Test&lt;/code&gt; 시작시 표지 스펙 파일의 이름을 지정하십시오 . 플래그를 사용하여이 작업을 수행 &lt;code&gt;-cover&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 예를 들어, :</target>
        </trans-unit>
        <trans-unit id="9cae8d843ee99890bf287306d3e1fa2ea6334285" translate="yes" xml:space="preserve">
          <source>To actor, such as receiver of message.</source>
          <target state="translated">메시지 수신자와 같은 행위자에게.</target>
        </trans-unit>
        <trans-unit id="b7c67d81ad5962900cef3025ec2c90eb9d886e13" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">disk_log 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 서브맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc71d9dc8116b79c66537800da31d34775d71f00" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">표준 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 서브맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25bba7220a4f7baf1911b739eb15c54b0c0b82c" translate="yes" xml:space="preserve">
          <source>To add hipe options, write like this from the Erlang shell:</source>
          <target state="translated">hipe 옵션을 추가하려면 Erlang 쉘에서 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3baa48763297e23c94a7b912bd0879afc5570f44" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">한 번에 하나의 파일을 열린 tar 파일에 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 하려면 add / 3,4 함수를 사용 하십시오 . 파일 추가를 마치면 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 tar 파일을 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="a84e38b55e72c3e97104e0980726fd48cb3019f6" translate="yes" xml:space="preserve">
          <source>To add or remove functions to the set of traced functions, use &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;.</source>
          <target state="translated">추적 된 함수 세트에 함수를 추가하거나 제거하려면 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fda79af0ac4d5d28c0ded42a7d7b009f4b62fd23" translate="yes" xml:space="preserve">
          <source>To add or remove one or more processes to the set of traced processes, use &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스 세트에 하나 이상의 프로세스를 추가하거나 제거하려면 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9ff12ed931dadbc8c2436f103539b09520bf39" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; to &lt;strong&gt;request unloading&lt;/strong&gt; to wait for &lt;strong&gt;actual unloading&lt;/strong&gt;, &lt;code&gt;monitor&lt;/code&gt; triggers can be specified in much the same way as when loading. However, as &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this function seldom are interested in more than decrementing the reference counts, monitoring is seldom needed.</source>
          <target state="translated">허용하기 위해 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 에게 &lt;strong&gt;요청 언 로딩을&lt;/strong&gt; 기다릴 &lt;strong&gt;실제 하역&lt;/strong&gt; , &lt;code&gt;monitor&lt;/code&gt; 트리거는로드 할 때와 거의 같은 방법으로 지정할 수 있습니다. 그러나이 기능 을 사용하는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 는 참조 횟수를 줄이는 데 관심이 거의 없으므로 모니터링이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59bb251ccc89a2f6d964901c5abf9140c03fcff3" translate="yes" xml:space="preserve">
          <source>To avoid copying data when a large binary is sent or returned from the driver to an Erlang process, the driver must first allocate the binary and then send it to an Erlang process in some way.</source>
          <target state="translated">큰 바이너리가 드라이버에서 Erlang 프로세스로 전송되거나 리턴 될 때 데이터를 복사하지 않으려면 드라이버는 먼저 바이너리를 할당 한 다음 어떤 방식 으로든 Erlang 프로세스로 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="2865a7885b23338eb552d918abbacdfb214f7e88" translate="yes" xml:space="preserve">
          <source>To avoid copying the result in each iteration, build the list in reverse order and reverse the list when you are done:</source>
          <target state="translated">각 반복에서 결과를 복사하지 않으려면 목록을 역순으로 작성하고 완료되면 목록을 역순으로 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e09f8fda1e6fc4cf2056ba424646d85461e4106" translate="yes" xml:space="preserve">
          <source>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify &lt;code&gt;UpFromVsn&lt;/code&gt; and &lt;code&gt;DownToVsn&lt;/code&gt;. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions &lt;code&gt;2.1.x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any number:</source>
          <target state="translated">업그레이드 지시 사항의 중복을 피하기 위해 정규식을 사용하여 &lt;code&gt;UpFromVsn&lt;/code&gt; 및 &lt;code&gt;DownToVsn&lt;/code&gt; 을 지정할 수 있습니다. 정규식으로 간주 되려면 버전 식별자를 이진으로 지정해야합니다. 예를 들어, 다음은 모든 버전 &lt;code&gt;2.1.x&lt;/code&gt; 와 일치합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 임의의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="f3e4e6304ab6854db5a3171fca0bb16d781ed384" translate="yes" xml:space="preserve">
          <source>To avoid hanging on open ports, use function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">열린 포트에 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 대신 try_load / 3 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31d3d102c2bccbc776e3cf95a6211839f76eac95" translate="yes" xml:space="preserve">
          <source>To avoid hard-coding data values related to the test and/or System Under Test (SUT) in the test suites, the data can instead be specified through configuration files or strings that &lt;code&gt;Common Test&lt;/code&gt; reads before the start of a test run. External configuration data makes it possible to change test properties without modifying the test suites using the data. Examples of configuration data follows:</source>
          <target state="translated">테스트 스위트의 테스트 및 / 또는 테스트 대상 시스템 (SUT)과 관련된 하드 코딩 데이터 값을 피하기 위해 테스트 실행을 시작하기 전에 &lt;code&gt;Common Test&lt;/code&gt; 가 읽는 구성 파일 또는 문자열을 통해 데이터를 지정할 수 있습니다. 외부 구성 데이터를 사용하면 데이터를 사용하여 테스트 스위트를 수정하지 않고도 테스트 특성을 변경할 수 있습니다. 구성 데이터의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff4064fdc26dd0f01d01190c1a8e9d791a3c3dfd" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">이를 피하기 위해 모든 테스트마다 서버 시작 및 중지를 고려할 수 있습니다. 따라서 시작 및 중지 조치를 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 에서 호출되는 공통 함수로 구현할 수 있습니다 . (시작 및 중지 기능은 별도로 테스트해야합니다.) 구성은 시작 기능과 함께 그룹화되어 공통 기능으로 구현 될 수도 있습니다. 마지막으로 클라이언트 연결 및 연결 해제 테스트를 하나의 테스트 사례로 그룹화 할 수 있습니다. 결과 제품군은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da22d86c6d5a5e12ab72051b2e07972d39e8f4d0" translate="yes" xml:space="preserve">
          <source>To avoid this, you can format the internal state that gets in the error log and gets returned from &lt;code&gt;sys:get_status/1,2&lt;/code&gt; by implementing function &lt;code&gt;Module:format_status/2&lt;/code&gt;, for example like this:</source>
          <target state="translated">이를 방지하기 위해 &lt;code&gt;Module:format_status/2&lt;/code&gt; 함수를 구현 하여 오류 로그에 도착하고 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 에서 리턴되는 내부 상태를 형식화 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df12af7ca1de496492c0fd73285a97d145fbb83" translate="yes" xml:space="preserve">
          <source>To be able to access a record in a fragmented table, &lt;code&gt;Mnesia&lt;/code&gt; must determine to which fragment the actual record belongs. This is done by module &lt;code&gt;mnesia_frag&lt;/code&gt;, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; callback behavior. It is recommended to read the documentation about the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; to see how &lt;code&gt;mnesia_frag&lt;/code&gt; can be used as a &lt;code&gt;mnesia_access&lt;/code&gt; callback module.</source>
          <target state="translated">조각화 된 테이블의 레코드에 액세스하려면 &lt;code&gt;Mnesia&lt;/code&gt; 는 실제 레코드가 속하는 조각을 결정해야합니다. 이것은 모듈에 의해 수행 &lt;code&gt;mnesia_frag&lt;/code&gt; , 구현 &lt;code&gt;mnesia_access&lt;/code&gt; 의 콜백 동작. 함수에 대한 설명서를 읽을 것을 권장 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; 방식을 볼 수 &lt;code&gt;mnesia_frag&lt;/code&gt; 는 A와 사용할 수 있습니다 &lt;code&gt;mnesia_access&lt;/code&gt; 의 콜백 모듈을.</target>
        </trans-unit>
        <trans-unit id="23318e76150bd1f0abc3ba7a0d5c11d745ade1e5" translate="yes" xml:space="preserve">
          <source>To be able to access another source than &lt;code&gt;running&lt;/code&gt;, the server must advertise &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;running&lt;/code&gt; 이외의 다른 소스에 액세스하려면 서버가 &lt;code&gt;:candidate&lt;/code&gt; 및 / 또는 &lt;code&gt;:startup&lt;/code&gt; 을 보급해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b51f87825f77244a25cc2b4cb931c55829d08561" translate="yes" xml:space="preserve">
          <source>To be able to build the 64bit VM, you will also need the 64bit MinGW compiler from:</source>
          <target state="translated">64 비트 VM을 빌드하려면 다음의 64 비트 MinGW 컴파일러도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="26291c0ee8be34dfdaf3cc8ddf503e49e01d4215" translate="yes" xml:space="preserve">
          <source>To be able to handle that the peer has done a shutdown on the write side, option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful.</source>
          <target state="translated">피어가 쓰기 측에서 시스템 종료를 처리했음을 처리하려면 옵션 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5203ca51ac51dc3846f4da1bcecefb73078a29b" translate="yes" xml:space="preserve">
          <source>To be able to match on events, the event handler module must include the header file &lt;code&gt;ct_event.hrl&lt;/code&gt;. An event is a record with the following definition:</source>
          <target state="translated">이벤트에서 일치 시키려면 이벤트 핸들러 모듈에 헤더 파일 &lt;code&gt;ct_event.hrl&lt;/code&gt; 이 포함되어야합니다 . 이벤트는 다음 정의를 가진 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="e3749ffc8118407236ba6c1778f7ad9201b5e31f" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">Erlang 시스템 시간의 변화에 ​​반응하려면, 발생한 시간을 감지 할 수 있어야합니다. Erlang 시스템 시간의 변경은 현재 시간 오프셋이 변경 될 때 발생합니다. 따라서 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 사용하여 시간 오프셋을 모니터링 할 수있는 가능성을 소개했습니다 . 시간 오프셋을 모니터링하는 프로세스는 시간 오프셋이 변경 될 때 다음 형식으로 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4db2f48a1319253c8231fa7c3d7cafe6f17c3bfc" translate="yes" xml:space="preserve">
          <source>To be backward compatible, &lt;code&gt;erlang:now/0&lt;/code&gt; remains &quot;as is&quot;, but &lt;strong&gt;you are strongly discouraged from using it&lt;/strong&gt;. Many use cases of &lt;code&gt;erlang:now/0&lt;/code&gt; prevents you from using the new &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, which is an important part of this new time functionality improvement.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;erlang:now/0&lt;/code&gt; 은 &quot;있는 그대로&quot;유지하지만 &lt;strong&gt;사용하지 않는 것이 좋습니다&lt;/strong&gt; . &lt;code&gt;erlang:now/0&lt;/code&gt; 의 많은 사용 사례는 새로운 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 를 사용하지 못하게 하므로이 새로운 시간 기능 개선의 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="329020006d74005fa227c858badad448a18d5417" translate="yes" xml:space="preserve">
          <source>To be explicit, this does not work:</source>
          <target state="translated">명시 적으로 말하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="921be93011160f60c5394e46977ec4ffed9f386b" translate="yes" xml:space="preserve">
          <source>To be exploited by documentation tools, such as EDoc, for generating program documentation of various forms</source>
          <target state="translated">다양한 형식의 프로그램 문서를 생성하기 위해 EDoc과 같은 문서 도구를 활용</target>
        </trans-unit>
        <trans-unit id="f48ee1f9c7b05fd181e829e8e9aa1a1a445ae544" translate="yes" xml:space="preserve">
          <source>To be made the default version, the newly installed release must be made &lt;strong&gt;permanent&lt;/strong&gt;, which means the previous version becomes &lt;strong&gt;old&lt;/strong&gt;:</source>
          <target state="translated">기본 버전, 새로 설치된 버전이 이루어져야 할하려면 &lt;strong&gt;영구&lt;/strong&gt; 이전 버전이되고 의미, &lt;strong&gt;오래된&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e74a300fec94193e2bb8d4e9a20ec23ef6d08170" translate="yes" xml:space="preserve">
          <source>To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478342ff97001f76e051ff05457f998d192f9c98" translate="yes" xml:space="preserve">
          <source>To bring up all functions of the module in the listbox, click the &lt;strong&gt;OK&lt;/strong&gt; button (or press the &lt;strong&gt;Return&lt;/strong&gt; or &lt;strong&gt;Tab&lt;/strong&gt; key) when a module name has been specified,.</source>
          <target state="translated">목록 상자에 모듈의 모든 기능을 불러 오려면 모듈 이름이 지정되었을 때 &lt;strong&gt;확인&lt;/strong&gt; 버튼을 클릭 하거나 &lt;strong&gt;Return&lt;/strong&gt; 또는 &lt;strong&gt;Tab&lt;/strong&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="eef5c50b74cfb025ae830e60721c49d26fd50ea9" translate="yes" xml:space="preserve">
          <source>To browse the file hierarchy and interpret the appropriate modules, either select a module name and click &lt;strong&gt;Choose&lt;/strong&gt; (or press carriage return), or double-click the module name. Interpreted modules have the type &lt;code&gt;erl src&lt;/code&gt;.</source>
          <target state="translated">파일 계층 구조를 찾아보고 적절한 모듈을 해석하려면 모듈 이름을 &lt;strong&gt;선택&lt;/strong&gt; 하고 &lt;strong&gt;선택을&lt;/strong&gt; 클릭 하거나 캐리지 리턴을 누르거나 모듈 이름을 두 번 클릭하십시오. 해석 된 모듈의 유형은 &lt;code&gt;erl src&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28e906186648188c00413e57f57d46fc8b55c323" translate="yes" xml:space="preserve">
          <source>To build the map &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">&lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt; 맵을 빌드하려면 다음 호출을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf559a27d31b4ba64718074dda19ef0d468cf4ad" translate="yes" xml:space="preserve">
          <source>To build the tuple &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">튜플 &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt; 으로 다음과 같은 호출을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94328137f8adf38a2d5782ddb946585047133b14" translate="yes" xml:space="preserve">
          <source>To call an arbitrary function from the release handler, the following instruction is used:</source>
          <target state="translated">릴리스 핸들러에서 임의의 함수를 호출하기 위해 다음 명령어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="648e7cf5c6adf0a3796e8cd7e102571a81de2b0f" translate="yes" xml:space="preserve">
          <source>To call the parser generator, use the following command:</source>
          <target state="translated">파서 생성기를 호출하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="754fcce3ba1a05a254eee986bb434f3d90945ecd" translate="yes" xml:space="preserve">
          <source>To change from old code to current code, a process must make a fully qualified function call.</source>
          <target state="translated">이전 코드에서 현재 코드로 변경하려면 프로세스가 완전한 함수 호출을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d43cb0d79f1f2a05084529861044cff6d89a0ac1" translate="yes" xml:space="preserve">
          <source>To change that we would need to insert action &lt;code&gt;hibernate&lt;/code&gt; in more places. For example, the state-independent &lt;code&gt;set_lock_button&lt;/code&gt; operation would have to use &lt;code&gt;hibernate&lt;/code&gt; but only in the &lt;code&gt;{open,_}&lt;/code&gt; state, which would clutter the code.</source>
          <target state="translated">이를 변경하려면 더 많은 위치에 &lt;code&gt;hibernate&lt;/code&gt; 동작을 삽입해야 합니다. 예를 들어, 상태 독립적 인 &lt;code&gt;set_lock_button&lt;/code&gt; 작업은 &lt;code&gt;hibernate&lt;/code&gt; 를 사용해야 하지만 &lt;code&gt;{open,_}&lt;/code&gt; 상태 에서만 코드가 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="6d2291b5accb98f7fdfc37910802e511d2e8b381" translate="yes" xml:space="preserve">
          <source>To change the above program to one that works out the minimum value of the element in a list, you only need to write &amp;lt; instead of &amp;gt;. (But it would be wise to change the name of the function to &lt;code&gt;list_min&lt;/code&gt;.)</source>
          <target state="translated">위의 프로그램을 목록에서 요소의 최소값을 계산하는 프로그램으로 변경하려면&amp;gt; 대신 &amp;lt;만 쓰면됩니다. 그러나 함수 이름을 &lt;code&gt;list_min&lt;/code&gt; 으로 변경하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="df565b9f1ce8851c5511996238157f3f30542cab" translate="yes" xml:space="preserve">
          <source>To change the algorithm list, there are two options which can be used in &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;. The options could of course be used in all other functions that initiates connections.</source>
          <target state="translated">알고리즘 목록을 변경하기 위해 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 에서 사용할 수있는 두 가지 옵션이 있습니다 . 옵션은 물론 연결을 시작하는 다른 모든 기능에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645ec6265eaa80d65a779b7caa5860ddbfdebc42" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러의 로그 레벨을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd786bf281877aa85271503f3c21215f44679fd5" translate="yes" xml:space="preserve">
          <source>To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this:</source>
          <target state="translated">홀수 개의 문자가있는 문자열뿐만 아니라 모든 회문 문자열과 일치하도록 패턴을 변경하려면 패턴을 다음과 같이 변경하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d9656eb62d534763e64141fc6d3d1d35b0b442bc" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로거의 기본 로그 레벨을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866ca5de7c21c0cf7da2438015592c26ee8d81d7" translate="yes" xml:space="preserve">
          <source>To change the rules that restrict the use of an asset, the user only needs write access to the directory where the asset is.</source>
          <target state="translated">자산 사용을 제한하는 규칙을 변경하려면 자산이있는 디렉토리에 대한 쓰기 권한 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="f5621caa72f0f06f014de0ebbc8d407830e5d0da" translate="yes" xml:space="preserve">
          <source>To check if your code is executed within a transaction, use the function &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt;. It returns &lt;code&gt;true&lt;/code&gt; when called inside a transaction context, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">트랜잭션 내에서 코드가 실행되는지 확인하려면 &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 트랜잭션 컨텍스트 내에서 호출되면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6b2516b6faafd214fb55f7400a6a5d85502f13d2" translate="yes" xml:space="preserve">
          <source>To check whether a term is a fun, use the test &lt;code&gt;is_function/1&lt;/code&gt; in a guard.</source>
          <target state="translated">용어가 재미 있는지 확인하려면 가드에서 &lt;code&gt;is_function/1&lt;/code&gt; 테스트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="61eaab6c693a13cade1df8955eec714a449d7d24" translate="yes" xml:space="preserve">
          <source>To choose the name for the generated module, for example, because you need to compile the same specs for different encoding rules.</source>
          <target state="translated">예를 들어 생성 된 모듈의 이름을 선택하려면 다른 인코딩 규칙에 대해 동일한 사양을 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1427a1da5e3a256c344db44b11dc0bba14915bf8" translate="yes" xml:space="preserve">
          <source>To close the window, click &lt;strong&gt;Done&lt;/strong&gt;.</source>
          <target state="translated">창을 닫으려면 &lt;strong&gt;완료를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b49e3e39a1c8fd0e9ebc5aae6e7cbc8ac29bcce" translate="yes" xml:space="preserve">
          <source>To communicate through Telnet to the host specified by &lt;code&gt;HostNameOrIpAddress&lt;/code&gt;, use the interface functions in &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;open(Name)&lt;/code&gt; and &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt;.</source>
          <target state="translated">Telnet을 통해 &lt;code&gt;HostNameOrIpAddress&lt;/code&gt; 로 지정된 호스트와 통신하려면 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 의 인터페이스 함수 &lt;code&gt;open(Name)&lt;/code&gt; 예 : open (Name) 및 &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc63914adafb29982dfe6a5968660a48f49ce2e" translate="yes" xml:space="preserve">
          <source>To compare styles, here follows the same example using &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt;, or rather the code to replace after function &lt;code&gt;init/1&lt;/code&gt; of the &lt;code&gt;pushbutton.erl&lt;/code&gt; example file above:</source>
          <target state="translated">스타일을 비교하기 위해 다음은 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 을 사용하는 동일한 예제 또는 위 의 &lt;code&gt;pushbutton.erl&lt;/code&gt; 예제 파일 의 함수 &lt;code&gt;init/1&lt;/code&gt; 이후에 대체 할 코드를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f9bdaaae36af33eb796c91b4364a72c96ddef2b5" translate="yes" xml:space="preserve">
          <source>To compare the importance of the printout to a specific verbosity level.</source>
          <target state="translated">인쇄물의 중요성을 특정 상세 레벨과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="54ed5bb067e17e1fa5d9fb9384ef7e59e200b2f4" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;erl_interface.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">코드를 컴파일하려면 명령 행에 적절한 &lt;code&gt;-I&lt;/code&gt; 인수를 지정 하여 C 컴파일러가 &lt;code&gt;erl_interface.h&lt;/code&gt; 를 찾을 위치를 알고 있는지 확인 하거나 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;CFLAGS&lt;/code&gt; 정의에 추가하십시오 . 이 경로의 올바른 값은 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; . 여기서,</target>
        </trans-unit>
        <trans-unit id="99dbaa9ef513face3ab175774b7916127ae86697" translate="yes" xml:space="preserve">
          <source>To complete the I/O server, we only need to read and write the table in an appropriate way:</source>
          <target state="translated">I / O 서버를 완성하려면 적절한 방법으로 테이블을 읽고 쓰면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef56703b3c226b895e39bdf18576e702cab5ae0b" translate="yes" xml:space="preserve">
          <source>To configure the Logger backend, use &lt;code&gt;Kernel configuration parameters&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; in the Logger API.</source>
          <target state="translated">로거 백엔드를 구성하려면 로거 API에서 &lt;code&gt;Kernel configuration parameters&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8abc4316358324e879aa4fb86c41abefacbe121" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt;, which stores information, such as the hostname, node name, and IP address for later use:</source>
          <target state="translated">분산 Erlang 노드에 연결하려면 먼저 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt; 로 연결 루틴을 초기화해야합니다 . erl_connect : erl_connect_init 는 나중에 사용할 수 있도록 호스트 이름, 노드 이름 및 IP 주소와 같은 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="da53f52f9b6e989d7d98084c289e93041ec03817" translate="yes" xml:space="preserve">
          <source>To constrain the match, it is needed to replace some of the &lt;code&gt;'_'&lt;/code&gt; elements. The code for matching out all female employees looks as follows:</source>
          <target state="translated">일치를 제한하려면 &lt;code&gt;'_'&lt;/code&gt; 요소 중 일부를 바꿔야 합니다. 모든 여성 직원을 매칭하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db8fca00f1d4d2a5725d8baaafde57fb1f7e09a3" translate="yes" xml:space="preserve">
          <source>To convert an error term returned from one of the functions above to a readable message, use function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 함수 중 하나에서 리턴 된 오류 용어를 읽을 수있는 메시지로 변환하려면 function_error &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="746ad6da742f525d196ec4f846fc54c5b8d6665f" translate="yes" xml:space="preserve">
          <source>To copy text to the clipboard, use &lt;code&gt;Ctrl-C&lt;/code&gt;.</source>
          <target state="translated">텍스트를 클립 보드에 복사하려면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f0c639143cf961891408084facf2efc28d6f4b6" translate="yes" xml:space="preserve">
          <source>To copy the selected text to the clipboard, either use &lt;code&gt;Ctrl-C&lt;/code&gt;, use the menu, or press the copy button in the toolbar.</source>
          <target state="translated">선택한 텍스트를 클립 보드에 복사하려면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 사용하거나 메뉴를 사용하거나 도구 모음에서 복사 단추를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="b2f36469b72d764889b8bc2c05eb18e7c2e00c94" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">임의의 iolist에서 바이너리 목록을 작성하려면 &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b64ef8fa41b5eb9b9fbad8912a240355ac0b560d" translate="yes" xml:space="preserve">
          <source>To create a port:</source>
          <target state="translated">포트를 만들려면</target>
        </trans-unit>
        <trans-unit id="c1b10e93b99ca718329a25a25398d8dc9f5d3821" translate="yes" xml:space="preserve">
          <source>To create the Mnesia tables, we use two records defined in &lt;code&gt;mod_auth.hrl&lt;/code&gt;, so that file must be included. &lt;code&gt;first_start/0&lt;/code&gt; creates a schema that specifies on which nodes the database is to reside. Then it starts Mnesia and creates the tables. The first argument is the name of the tables, the second argument is a list of options of how to create the table, see &lt;code&gt;mnesia(3)&lt;/code&gt;, documentation for more information. As the implementation of the &lt;code&gt;mod_auth_mnesia&lt;/code&gt; saves one row for each user, the type must be &lt;code&gt;bag&lt;/code&gt;. When the schema and the tables are created, function &lt;code&gt;mnesia:start/0&lt;/code&gt; is used to start Mnesia and waits for the tables to be loaded. Mnesia uses the directory specified as &lt;code&gt;mnesia_dir&lt;/code&gt; at startup if specified, otherwise Mnesia uses the current directory. For security reasons, ensure that the Mnesia tables are stored outside the document tree of the HTTP server. If they are placed in the directory which it protects, clients can download the tables. Only the Dets and Mnesia storage methods allow writing of dynamic user data to disk. &lt;code&gt;plain&lt;/code&gt; is a read only method.</source>
          <target state="translated">Mnesia 테이블을 작성하려면 &lt;code&gt;mod_auth.hrl&lt;/code&gt; 에 정의 된 두 개의 레코드를 사용 하므로 파일이 포함되어야합니다. &lt;code&gt;first_start/0&lt;/code&gt; 은 데이터베이스가 상주 할 노드를 지정하는 스키마를 작성합니다. 그런 다음 Mnesia를 시작하고 테이블을 만듭니다. 첫 번째 인수는 테이블의 이름이고 두 번째 인수는 테이블을 작성하는 방법에 대한 옵션 목록입니다 . 자세한 정보는 &lt;code&gt;mnesia(3)&lt;/code&gt; 문서를 참조하십시오. &lt;code&gt;mod_auth_mnesia&lt;/code&gt; 의 구현은 각 사용자에 대해 하나의 행을 저장하므로 유형은 &lt;code&gt;bag&lt;/code&gt; 이어야합니다 . 스키마와 테이블이 작성되면 &lt;code&gt;mnesia:start/0&lt;/code&gt; 함수가 Mnesia 를 시작하는 데 사용되며 테이블이로드되기를 기다립니다. Mnesia는 다음과 같이 지정된 디렉토리를 사용합니다. &lt;code&gt;mnesia_dir&lt;/code&gt; 지정된 경우 시작시 mnesia_dir , 그렇지 않으면 Mnesia는 현재 디렉토리를 사용합니다. 보안상의 이유로 Mnesia 테이블이 HTTP 서버의 문서 트리 외부에 저장되어 있는지 확인하십시오. 이들이 보호되는 디렉토리에 있으면, 클라이언트는 테이블을 다운로드 할 수 있습니다. Dets 및 Mnesia 스토리지 방법 만 사용하여 동적 사용자 데이터를 디스크에 쓸 수 있습니다. &lt;code&gt;plain&lt;/code&gt; 은 읽기 전용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7026fff802f7dac35b82f566aac0d4c80c766528" translate="yes" xml:space="preserve">
          <source>To create zip archives, use function &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;create/2,3&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브를 작성하려면 함수 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;create/2,3&lt;/code&gt; 으로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96ba6751b435aa130ce8000c31fb7a59eb14a8a4" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt;Module:init(Args)&lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; is called. This function behaves like an event handler function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">첫 번째 상태를 결정하기 위해 &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; 가 호출 되기 전에 &lt;code&gt;Module:init(Args)&lt;/code&gt; 콜백 함수 가 호출됩니다. 이 함수는 이벤트 핸들러 함수처럼 작동하지만 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;start/3,4&lt;/code&gt; 또는 start_link &lt;code&gt;start_link/3,4&lt;/code&gt; 함수 에서 인수 &lt;code&gt;Args&lt;/code&gt; 만 가져 오고 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 또는 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 리턴합니다. . 이 기능에서 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 조치 를 사용하면 연기 할 이벤트가 없으므로 해당 조치가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="51c111740de9350080c7972bf37d34610910e708" translate="yes" xml:space="preserve">
          <source>To define a release, create a &lt;strong&gt;release resource file&lt;/strong&gt;, or in short a &lt;code&gt;.rel&lt;/code&gt; file. In the file, specify the name and version of the release, which ERTS version it is based on, and which applications it consists of:</source>
          <target state="translated">릴리스를 정의하려면 &lt;strong&gt;릴리스 자원 파일&lt;/strong&gt; 또는 간단히 &lt;code&gt;.rel&lt;/code&gt; 파일을 작성하십시오. 파일에서 릴리스의 이름과 버전, 기반이되는 ERTS 버전 및 구성되는 응용 프로그램을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7dcb9b11962f5e7cb3516154fef97049f24faad8" translate="yes" xml:space="preserve">
          <source>To define an application, an &lt;strong&gt;application specification&lt;/strong&gt; is created, which is put in an &lt;strong&gt;application resource file&lt;/strong&gt;, or in short an &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">응용 프로그램을 정의하기 위해 응용 &lt;strong&gt;프로그램 사양&lt;/strong&gt; 이 만들어지고 &lt;strong&gt;응용 프로그램 리소스 파일&lt;/strong&gt; 또는 짧은 &lt;code&gt;.app&lt;/code&gt; 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="54b3619697604e99e71233bb1079a1597fb1c5a2" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the current version and previous versions of an application, an &lt;strong&gt;application upgrade file&lt;/strong&gt;, or in short an &lt;code&gt;.appup&lt;/code&gt; file is created. The file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name:</source>
          <target state="translated">현재 버전과 이전 버전의 응용 프로그램간에 업그레이드 / 다운 그레이드하는 방법을 정의하기 위해 &lt;strong&gt;응용 프로그램 업그레이드 파일&lt;/strong&gt; 또는 간단히 &lt;code&gt;.appup&lt;/code&gt; 파일이 생성됩니다. 파일 이름은 &lt;code&gt;Application.appup&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f1125003b8abae474fb015968f66692981cd19a0" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the new version and previous versions of a release, a &lt;strong&gt;release upgrade file&lt;/strong&gt;, or in short &lt;code&gt;relup&lt;/code&gt; file, is to be created.</source>
          <target state="translated">새 버전과 이전 버전의 릴리스간에 업그레이드 / 다운 그레이드하는 방법을 정의하려면 &lt;strong&gt;릴리스 업그레이드 파일&lt;/strong&gt; 또는 짧은 &lt;code&gt;relup&lt;/code&gt; 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e010624d4e818c00508b53d915d93db2cfd9d3a" translate="yes" xml:space="preserve">
          <source>To detect that the server is not the intended one, the client must additionaly perform a</source>
          <target state="translated">서버가 의도 한 것이 아니라는 것을 감지하려면 클라이언트가 추가로</target>
        </trans-unit>
        <trans-unit id="29f1578f8a4341b69585b80b12a72f76a9569382" translate="yes" xml:space="preserve">
          <source>To dig deeper into the general results, or the result of a specific test case, the operator can do so by following the links in the HTML presentation and read the major or minor log files. The &quot;all_runs.html&quot; page is a good starting point. It is located in &lt;code&gt;logdir&lt;/code&gt; and contains a link to each test run, including a quick overview (with date and time, node name, number of tests, test names, and test result totals).</source>
          <target state="translated">일반 결과 또는 특정 테스트 사례의 결과를보다 깊이 파고 들기 위해 HTML 프레젠테이션의 링크를 따라 주요 또는 부 로그 파일을 읽을 수 있습니다. &quot;all_runs.html&quot;페이지는 좋은 출발점입니다. 그것은에 위치하고 &lt;code&gt;logdir&lt;/code&gt; 및 (날짜와 시간, 노드 이름, 테스트의 수, 테스트 이름, 테스트 결과의 합계와) 빠른 개요를 포함하여 각 테스트 실행에 대한 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47ea787070856206ef8e8c44cdc817088453a80" translate="yes" xml:space="preserve">
          <source>To disable all electric commands set the variable &lt;code&gt;erlang-electric-commands&lt;/code&gt; to the empty list. In short, place the following line in your &lt;code&gt;.emacs&lt;/code&gt;-file:</source>
          <target state="translated">모든 전기 명령을 비활성화하려면 변수 &lt;code&gt;erlang-electric-commands&lt;/code&gt; 를 빈 목록으로 설정하십시오. 간단히 말해서 &lt;code&gt;.emacs&lt;/code&gt; -file 에 다음 줄을 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="2719f4e1a729a417c71b36c21728b88e49361422" translate="yes" xml:space="preserve">
          <source>To disable certain modes, do the following:</source>
          <target state="translated">특정 모드를 비활성화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7d843b983a258077823d6e0bf23f5a51462fef79" translate="yes" xml:space="preserve">
          <source>To disable the automatic compilation feature, use flag &lt;code&gt;-no_auto_compile&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, or option &lt;code&gt;{auto_compile,false}&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. With automatic compilation disabled, the user is responsible for compiling the test suite modules (and any help modules) before the test run. If the modules cannot be loaded from the local file system during startup of &lt;code&gt;Common Test&lt;/code&gt;, the user must preload the modules before starting the test. &lt;code&gt;Common Test&lt;/code&gt; only verifies that the specified test suites exist (that is, that they are, or can be, loaded). This is useful, for example, if the test suites are transferred and loaded as binaries through RPC from a remote node.</source>
          <target state="translated">자동 편집 기능, 사용 플래그를 사용하지 않으려면 &lt;code&gt;-no_auto_compile&lt;/code&gt; 와 &lt;code&gt;ct_run&lt;/code&gt; , 또는 옵션 &lt;code&gt;{auto_compile,false}&lt;/code&gt; 와 &lt;code&gt;ct:run_test/1&lt;/code&gt; . 자동 컴파일을 사용하지 않으면 사용자는 테스트 실행 전에 테스트 스위트 모듈 (및 모든 도움말 모듈)을 컴파일해야합니다. &lt;code&gt;Common Test&lt;/code&gt; 시작 중에 로컬 파일 시스템에서 모듈을로드 할 수없는 경우 사용자는 테스트를 시작하기 전에 모듈을 사전로드해야합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 지정된 테스트 스위트가 존재하는지 (즉,로드되거나로드 될 수 있는지) 만 검증합니다. 예를 들어 테스트 스위트가 원격 노드에서 RPC를 통해 바이너리로 전송되고로드되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ceb4119cc35a0a33e9fed4f8110e9358a175961e" translate="yes" xml:space="preserve">
          <source>To disconnect from the shell without exiting the Erlang system, type &lt;code&gt;Ctrl-D&lt;/code&gt;.</source>
          <target state="translated">Erlang 시스템을 종료하지 않고 쉘에서 연결을 끊으려면 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="b548ad5d8837c627142ce75e81cde50b52ba7141" translate="yes" xml:space="preserve">
          <source>To distinguish trace logs produced with this tool from other logs, option &lt;code&gt;file&lt;/code&gt; is used in &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;. The logs are therefore fetched to a directory named &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt;</source>
          <target state="translated">이 도구로 생성 된 추적 로그를 다른 로그와 구별하기 위해 옵션 &lt;code&gt;file&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 에 사용됩니다 . 따라서 로그는 &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt; 라는 디렉토리로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3e40468ed8befabe466118a08bf6fc28c0f6c6eb" translate="yes" xml:space="preserve">
          <source>To do this, create a &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; that defines which applications are included in the release.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; 에 포함 된 응용 프로그램을 정의 하는 릴리스 리소스 파일 을 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="71c169e0b7cdb28847a1d261315129b8416e6027" translate="yes" xml:space="preserve">
          <source>To do this, create an &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt;, and describe how the application is to be started and stopped.</source>
          <target state="translated">이를 수행하려면 &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt; 작성하고 애플리케이션 을 시작하고 중지하는 방법을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="24f741a20f0106dade011b163f1322e4510ccc13" translate="yes" xml:space="preserve">
          <source>To document function interfaces</source>
          <target state="translated">함수 인터페이스를 문서화하려면</target>
        </trans-unit>
        <trans-unit id="4e2effe3d108d7692e70e0242432ef9323088c3f" translate="yes" xml:space="preserve">
          <source>To downgrade from &lt;code&gt;Vsn&lt;/code&gt; to &lt;code&gt;FromVsn&lt;/code&gt;, &lt;code&gt;install_release&lt;/code&gt; must be called again:</source>
          <target state="translated">에서 다운 그레이드 할 &lt;code&gt;Vsn&lt;/code&gt; 에 &lt;code&gt;FromVsn&lt;/code&gt; , &lt;code&gt;install_release&lt;/code&gt; 는 다시 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="c857b1910cd745feb809b3e36bb979959ad34032" translate="yes" xml:space="preserve">
          <source>To each module using records, a pseudo function is added during compilation to obtain information about records:</source>
          <target state="translated">레코드를 사용하여 각 모듈에 의사 함수가 추가되어 레코드에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="aa7093d0b40db64d8d5dbb29fff9e15755ac8d7c" translate="yes" xml:space="preserve">
          <source>To effectively perform a batch of similar queries, you can use parameterized queries. This means that you in your SQL query string will mark the places that usually would contain values with question marks and then provide lists of values for each parameter. For instance you can use this to insert multiple rows into the &lt;code&gt;EMPLOYEE&lt;/code&gt; table while executing only a single SQL statement, for example code see &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; section in the &quot;Getting Started&quot; chapter.</source>
          <target state="translated">유사한 쿼리 일괄 처리를 효과적으로 수행하기 위해 매개 변수화 된 쿼리를 사용할 수 있습니다. 즉, SQL 쿼리 문자열에서 일반적으로 값이 물음표가 포함 된 위치를 표시 한 다음 각 매개 변수의 값 목록을 제공합니다. 예를 들어 , 단일 SQL 문만 실행하는 동안 &lt;code&gt;EMPLOYEE&lt;/code&gt; 테이블에 여러 행을 삽입하기 위해이를 사용할 수 있습니다. 예를 들어 코드 는 &quot;시작하기&quot;장의 &quot; &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b87466d719f55a7d0bc6167a3744c10376e2896" translate="yes" xml:space="preserve">
          <source>To enable inlining of list functions, use option &lt;code&gt;inline_list_funcs&lt;/code&gt;.</source>
          <target state="translated">목록 함수의 인라인을 활성화하려면 &lt;code&gt;inline_list_funcs&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="51f30cb208852b09d381f6f12d3f9662837e7b58" translate="yes" xml:space="preserve">
          <source>To enable inlining, either use the option &lt;code&gt;inline&lt;/code&gt; to let the compiler decide which functions to inline, or &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; to have the compiler inline all calls to the given functions. If the option is given inside a &lt;code&gt;compile&lt;/code&gt; directive in an Erlang module, &lt;code&gt;{Name,Arity}&lt;/code&gt; can be written as &lt;code&gt;Name/Arity&lt;/code&gt;.</source>
          <target state="translated">인라인 활성화 중 옵션 사용하려면 &lt;code&gt;inline&lt;/code&gt; 컴파일러가 인라인, 또는에있는 기능을 결정하도록 &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; 주어진 기능에 대한 모든 호출 인라인 컴파일러를합니다. 옵션이 Erlang 모듈 의 &lt;code&gt;compile&lt;/code&gt; 지시문 내에 제공되면 &lt;code&gt;{Name,Arity}&lt;/code&gt; 를 &lt;code&gt;Name/Arity&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f19bd3dcfaf9ef3d9cd6caa0e986c9a4690183" translate="yes" xml:space="preserve">
          <source>To enable or disable &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt;. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt; 를 활성화 또는 비활성화 합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82cdfffdcb7bb12d82a554ed4fb4604dfb3bff2f" translate="yes" xml:space="preserve">
          <source>To enable or disable time correction, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 수정을 활성화 또는 비활성화하려면 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="708713ed825ecbbe1d0ddcd36ee2857e998c3c1b" translate="yes" xml:space="preserve">
          <source>To enable the full power of Merl, your module needs to include the Merl header file:</source>
          <target state="translated">Merl의 모든 기능을 사용하려면 모듈에 Merl 헤더 파일이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8d53019e25d31ae87446a8faff92ab534fbdf049" translate="yes" xml:space="preserve">
          <source>To encode a list, without knowing the arity in advance:</source>
          <target state="translated">미리 arity를 ​​모르고 목록을 인코딩하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6cd4ebf865b6fcb86e3b3c3d86118b3cbc2de974" translate="yes" xml:space="preserve">
          <source>To ensure that &lt;code&gt;Common Test&lt;/code&gt; does not start executing tests, or closes its log files and shuts down, before the external application is ready for it, &lt;code&gt;Common Test&lt;/code&gt; can be synchronized with the application. During startup and shutdown, &lt;code&gt;Common Test&lt;/code&gt; can be suspended, simply by having a CTH evaluate a &lt;code&gt;receive&lt;/code&gt; expression in the init- or terminate function. The macros &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (the process executing the hook init function) and &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (the process executing the hook terminate function) each specifies the name of the correct &lt;code&gt;Common Test&lt;/code&gt; process to send a message to. This is done to return from the &lt;code&gt;receive&lt;/code&gt;. These macros are defined in &lt;code&gt;ct.hrl&lt;/code&gt;.</source>
          <target state="translated">되도록하려면 &lt;code&gt;Common Test&lt;/code&gt; 시험을 수행하기 시작하거나, 외부 응용 프로그램이 준비되기 전에, 아래의 로그 파일과 닫힌다을 종료하지 않고, &lt;code&gt;Common Test&lt;/code&gt; 응용 프로그램과 동기화 할 수 있습니다. 시작 및 종료 중에 CTH 가 초기화 또는 종료 기능에서 &lt;code&gt;receive&lt;/code&gt; 표현식을 평가하도록함으로써 &lt;code&gt;Common Test&lt;/code&gt; 를 일시 중단 할 수 있습니다 . 매크로 &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (후크 초기화 기능을 실행하는 프로세스) 및 &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (후크 종료 기능을 실행하는 프로세스)는 각각 메시지를 보낼 올바른 &lt;code&gt;Common Test&lt;/code&gt; 프로세스 의 이름을 지정합니다 . 이것은 &lt;code&gt;receive&lt;/code&gt; 에서 돌아 오기 위해 수행 됩니다.. 이 매크로는 &lt;code&gt;ct.hrl&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6a3ca4567317dc34953b8a7c1cc3b757bbc4816" translate="yes" xml:space="preserve">
          <source>To ensure that a driver instance always uses the same thread, the following call can be used:</source>
          <target state="translated">드라이버 인스턴스가 항상 동일한 스레드를 사용하도록하기 위해 다음 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b277a4b4779423015664e7a3f401ea54aeecd5" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ct:pal,2,3&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에 대한 출력물 (또는 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;ct:pal,2,3&lt;/code&gt; 으로 작성된 출력물 )이 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그가 아닌 테스트 케이스 로그 파일에 기록되도록하기 위해 &lt;code&gt;tc_start&lt;/code&gt; 및 &lt;code&gt;tc_done&lt;/code&gt; 에 일치시키는 &lt;code&gt;Common Test&lt;/code&gt; 서버 . 이러한 이벤트 사이의 기간 동안 모든 I / O는 테스트 케이스 로그 파일로 보내집니다. 이러한 이벤트는 잠재적 타이밍 문제를 피하기 위해 동기식으로 전송됩니다 (예 : 외부 프로세스의 I / O 메시지가 전달되기 직전에 테스트 케이스 로그 파일이 닫힘). 이것을 알면 &lt;code&gt;handle_event/2&lt;/code&gt; 를 조심해야합니다. 콜백 함수가 테스트 실행을 중단하지 않아 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a63e4ff906295f7807af4b654281729a99f4d599" translate="yes" xml:space="preserve">
          <source>To execute group &lt;code&gt;tests1&lt;/code&gt; twice with different properties for &lt;code&gt;tests2&lt;/code&gt; each time:</source>
          <target state="translated">매번 &lt;code&gt;tests2&lt;/code&gt; 에 대해 다른 속성으로 그룹 &lt;code&gt;tests1&lt;/code&gt; 을 두 번 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="7239843e8d90d77d86be2ae7b38276b2e33faca1" translate="yes" xml:space="preserve">
          <source>To execute the test cases in the recent test suite, type the following on the UNIX/Linux command line (assuming that the suite module is in the current working directory):</source>
          <target state="translated">최신 테스트 스위트에서 테스트 케이스를 실행하려면 스위트 모듈이 현재 작업 디렉토리에 있다고 가정하여 UNIX / Linux 명령 행에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="15b464ff8a64913edd497cc9c55da6f1268e3b00" translate="yes" xml:space="preserve">
          <source>To explain how it works, let us examine the following code line by line:</source>
          <target state="translated">작동 방식을 설명하기 위해 다음 코드를 한 줄씩 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6ace97c5b62d1ba123d6323684c350a22b583d3a" translate="yes" xml:space="preserve">
          <source>To extract all files from a tar file, use function &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt;. To extract only some files or to be able to specify some more options, use function &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">tar 파일에서 모든 파일을 추출하려면 extract &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 일부 파일 만 추출하거나 추가 옵션을 지정하려면 &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d79465290c25ae2d243af5890aece9f3a5c6794" translate="yes" xml:space="preserve">
          <source>To extract files from a zip archive, use function &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;extract/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브에서 파일을 추출하려면 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 또한 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;extract/1,2&lt;/code&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49b523abf1ecfbea37ac71cc8ad901ada87596e3" translate="yes" xml:space="preserve">
          <source>To facilitate addition or removal of algorithms the option &lt;code&gt;modify_algorithms&lt;/code&gt; is available. See the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">알고리즘의 추가 또는 제거를 용이하게하기 위해 &lt;code&gt;modify_algorithms&lt;/code&gt; 옵션을 사용할 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="318d261f2e9e44898ab106149f1818df3611a4d0" translate="yes" xml:space="preserve">
          <source>To facilitate for instance counting of failed tries, the &lt;code&gt;State&lt;/code&gt; variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the &lt;code&gt;State&lt;/code&gt; variable has the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">예를 들어 실패한 시도 횟수를 쉽게 계산하기 위해 &lt;code&gt;State&lt;/code&gt; 변수를 사용할 수 있습니다. 이 상태는 연결 당입니다. pwdfun이 연결을 위해 처음 호출 될 때 &lt;code&gt;State&lt;/code&gt; 변수의 값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb30040c24cb4398d4f306c6f75be49b3309b50e" translate="yes" xml:space="preserve">
          <source>To facilitate incremental MIB implementation, the tool can generate a prototype implementation for a whole MIB, or parts thereof. This allows different MIBs and management applications to be developed at the same time.</source>
          <target state="translated">증분 MIB 구현을 용이하게하기 위해, 툴은 전체 MIB 또는 그 일부에 대한 프로토 타입 구현을 생성 할 수있다. 이를 통해 서로 다른 MIB 및 관리 응용 프로그램을 동시에 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2bbbdeeda7bd5404449757f8d9770ca2ef7aaa9" translate="yes" xml:space="preserve">
          <source>To filter only by dates, specify the empty list as the &lt;code&gt;Filters&lt;/code&gt; parameter.</source>
          <target state="translated">날짜별로 만 필터링하려면 빈 목록을 &lt;code&gt;Filters&lt;/code&gt; 매개 변수 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="630e50a14a964d68d3d5576b2cd371a11e3b187e" translate="yes" xml:space="preserve">
          <source>To find &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; in all applications &lt;code&gt;src&lt;/code&gt; directories, use either of the following lines:</source>
          <target state="translated">모든 응용 프로그램 &lt;code&gt;src&lt;/code&gt; 디렉토리 에서 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 을 찾으려면 다음 행 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6396773c2bde8a4d52d39cd61a041b4f1f183b7" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.beam&lt;/code&gt; files in all applications, use the following line:</source>
          <target state="translated">모든 응용 프로그램에서 모든 &lt;code&gt;.beam&lt;/code&gt; 파일 을 찾으려면 다음 행을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20cf9c172afcf3da74dfc71cb0f3fcae5974105f" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in any subdirectory:</source>
          <target state="translated">하위 디렉토리에서 모든 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ed6cec65dd2913192c7cb022d1a0950d0fa1dc6" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 또는 &lt;code&gt;include&lt;/code&gt; 디렉토리 에서 모든 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾으려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="fccdf7c91c9fff2872abc1dbafd75d06a060282b" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.hrl&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에서 모든 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾 거나 디렉토리를 &lt;code&gt;include&lt;/code&gt; 시키려면 :</target>
        </trans-unit>
        <trans-unit id="8e72309f663e0cdb8ebe00ece9160cd743a20ac1" translate="yes" xml:space="preserve">
          <source>To find out which data types will be returned for the columns in a table use the function &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">테이블의 컬럼에 대해 리턴 될 데이터 유형을 찾으려면 &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="df081f6643e87b8a4d20937b6cf7036fe456bdf3" translate="yes" xml:space="preserve">
          <source>To find preceding keys in the table, use &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 이전 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bab05c393dca1da866e4258e15bc30ee1a82d0d1" translate="yes" xml:space="preserve">
          <source>To find subsequent keys in the table, use &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 후속 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5305b16b9a4a45c3c66348bdacc0a4e5b3a4971f" translate="yes" xml:space="preserve">
          <source>To find the first key in the table, use &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 첫 번째 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f84576968a9f5a5747d5c908246715868508fa22" translate="yes" xml:space="preserve">
          <source>To find the last key in the table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블에서 마지막 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b08cebc24b1775a65769e106895c5039d3db4448" translate="yes" xml:space="preserve">
          <source>To fold a function over all files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">zip 아카이브의 모든 파일에 대해 함수를 접으려면 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3107d752335f18f59b4878dac8c20e1cc44001a3" translate="yes" xml:space="preserve">
          <source>To force Unicode filename translation mode on systems where this is not the default was considered experimental in Erlang/OTP R14B01. This was because the initial implementation did not ignore wrongly encoded filenames, so that raw filenames could spread unexpectedly throughout the system. As from Erlang/OTP R16B, the wrongly encoded filenames are only retrieved by special functions (such as &lt;code&gt;file:list_dir_all/1&lt;/code&gt;). Since the impact on existing code is therefore much lower it is now supported. Unicode filename translation is expected to be default in future releases.</source>
          <target state="translated">이것이 기본값이 아닌 시스템에서 유니 코드 파일 이름 변환 모드를 강제 실행하는 것은 Erlang / OTP R14B01에서 실험적인 것으로 간주되었습니다. 초기 구현에서 잘못 인코딩 된 파일 이름을 무시하지 않았기 때문에 원시 파일 이름이 시스템 전체에 예기치 않게 퍼질 수있었습니다. Erlang / OTP R16B에서와 같이 잘못 인코딩 된 파일 이름은 특수 함수 (예 : &lt;code&gt;file:list_dir_all/1&lt;/code&gt; ) 로만 검색됩니다 . 따라서 기존 코드에 대한 영향이 훨씬 낮아 이제 지원됩니다. 향후 릴리스에서는 유니 코드 파일 이름 변환이 기본값이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="286ba4fce2df7e992d24f0fa54be1d66081e5721" translate="yes" xml:space="preserve">
          <source>To format the printout according to a user-specific HTML Style Sheet (CSS).</source>
          <target state="translated">사용자 별 CSS (HTML Style Sheet)에 따라 출력물의 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d829ca082ad3db2ea55b112c3bcb9aa6980d21fb" translate="yes" xml:space="preserve">
          <source>To forsee the effect of an option there is an experimental function &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt;. It mangles the options &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt; in the same way as &lt;code&gt;ssh:dameon&lt;/code&gt;, &lt;code&gt;ssh:connect&lt;/code&gt; and their friends does.</source>
          <target state="translated">옵션의 효과를 확인하기 위해 실험 기능 &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt; 있습니다. &lt;code&gt;ssh:dameon&lt;/code&gt; , &lt;code&gt;ssh:connect&lt;/code&gt; 와 같은 방식으로 &lt;code&gt;preferred_algorithms&lt;/code&gt; 및 &lt;code&gt;modify_algorithms&lt;/code&gt; 옵션을 엉망으로 만들며 친구와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6dec9bf90ad555856d14e7f8a0bcc0b6c2749f95" translate="yes" xml:space="preserve">
          <source>To fully understand how to configure the algorithms, it is essential to have a basic understanding of the SSH protocol and how OTP SSH app handles the corresponding items</source>
          <target state="translated">알고리즘 구성 방법을 완전히 이해하려면 SSH 프로토콜 및 OTP SSH 앱이 해당 항목을 처리하는 방법을 기본적으로 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="105f7930b5d0bd6dbe4b596f6e5e1aa3c7bab464" translate="yes" xml:space="preserve">
          <source>To gain performance by using the SMP emulator, your application &lt;strong&gt;must have more than one runnable Erlang process&lt;/strong&gt; most of the time. Otherwise, the Erlang emulator can still only run one Erlang process at the time, but you must still pay the overhead for locking. Although Erlang/OTP tries to reduce the locking overhead as much as possible, it will never become exactly zero.</source>
          <target state="translated">SMP 에뮬레이터를 사용하여 성능을 얻으려면 응용 프로그램에 대부분 &lt;strong&gt;실행 가능한 Erlang 프로세스가 두 개 이상 있어야합니다&lt;/strong&gt; . 그렇지 않으면, Erlang 에뮬레이터는 한 번에 하나의 Erlang 프로세스 만 실행할 수 있지만 잠금을 위해 여전히 오버 헤드를 지불해야합니다. Erlang / OTP는 잠금 오버 헤드를 최대한 줄이려고하지만 정확히 0이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cbd28c322c2b7823640cb5d04b4000794237448" translate="yes" xml:space="preserve">
          <source>To get an overview of the concepts and operation of &lt;code&gt;gen_statem&lt;/code&gt;, do read the &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; in &lt;code&gt;OTP Design Principles&lt;/code&gt; which frequently links back to this reference manual to avoid containing detailed facts that may rot by age.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 개념과 작동에 대한 개요를 보려면 &lt;code&gt;OTP Design Principles&lt;/code&gt; 의 &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; 을 읽고이 참조 매뉴얼에 자주 연결되어 연령별로 썩을 수있는 자세한 사실을 포함하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="01d79833ca3942345f121a64dcc3d55c1d0c6500" translate="yes" xml:space="preserve">
          <source>To get information about a PLT, use the following option:</source>
          <target state="translated">PLT에 대한 정보를 얻으려면 다음 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1d5a6ae5a2a64c460f8242067e0ee912a4a4259" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 모노 토닉 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1abf6bacf41753f2d4e4f3e187da0b6ca761589" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 시스템 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b209da3c80686caad1fbe93f4b143a75dbb826a1" translate="yes" xml:space="preserve">
          <source>To get log events on the same format as produced by &lt;code&gt;error_logger_tty_h&lt;/code&gt; and &lt;code&gt;error_logger_file_h&lt;/code&gt;, use the default formatter, &lt;code&gt;logger_formatter&lt;/code&gt;, with configuration parameter &lt;code&gt;legacy_header&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. This is the default configuration of the &lt;code&gt;default&lt;/code&gt; handler started by Kernel.</source>
          <target state="translated">&lt;code&gt;error_logger_tty_h&lt;/code&gt; 및 &lt;code&gt;error_logger_file_h&lt;/code&gt; 에 의해 생성 된 것과 동일한 형식으로 로그 이벤트를 얻으려면 구성 매개 변수 &lt;code&gt;legacy_header&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 기본 포맷터 &lt;code&gt;logger_formatter&lt;/code&gt; 를 사용하십시오 . 이것은 커널이 시작한 &lt;code&gt;default&lt;/code&gt; 핸들러 의 기본 구성입니다 .</target>
        </trans-unit>
        <trans-unit id="51cf577b00fc8216155e456c21c9c0183f56b93f" translate="yes" xml:space="preserve">
          <source>To get started, the least you need to do is to start a tracer with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;, and set the required trace flags on the processes you want to trace with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작하려면 최소한 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 로 추적 프로그램을 시작하고 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 로 추적하려는 프로세스에서 필요한 추적 플래그를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc4b00be659493772c3eb90fac788afdac82d1da" translate="yes" xml:space="preserve">
          <source>To get started, you should read about the &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; data type; the main constructor functions: &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt;; and the main layout function &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작하려면 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 데이터 형식에 대해 읽어야 합니다. 주요 생성자 함수 : &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; ; 메인 레이아웃 기능 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80a72b65fea86a98c851ba990e410aac5fd9f4fb" translate="yes" xml:space="preserve">
          <source>To get the consistent behavior of killing ports when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads, use driver option &lt;code&gt;kill_ports&lt;/code&gt; when loading the driver instead.</source>
          <target state="translated">마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 언로드 할 때 포트를 &lt;code&gt;kill_ports&lt;/code&gt; 하는 일관된 동작을 얻으려면 대신 드라이버를로드 할 때 드라이버 옵션 kill_ports를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97de7a8dc23625a08e5a773780e14b0a5c65aae2" translate="yes" xml:space="preserve">
          <source>To get the output printed to a file, use option &lt;code&gt;--output_file&lt;/code&gt;.</source>
          <target state="translated">출력을 파일로 인쇄하려면 &lt;code&gt;--output_file&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f76cd184a6e7c8d866643b588a8bdefe5b9edef" translate="yes" xml:space="preserve">
          <source>To get trace messages containing return values from functions, use the &lt;code&gt;{return_trace}&lt;/code&gt; match specification action instead.</source>
          <target state="translated">함수의 리턴 값이 포함 된 추적 메시지를 얻으려면 대신 &lt;code&gt;{return_trace}&lt;/code&gt; 일치 스펙 조치를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1820d2a1d5bd22bcad0e15651513a749cd0ea7ac" translate="yes" xml:space="preserve">
          <source>To give an indication on the possible performance gain using the specialized decodes, some measures have been performed. The relative figures in the outcome between selective, exclusive, and complete decode (the normal case) depend on the structure of the type, the size of the message, and on what level the selective and exclusive decodes are specified.</source>
          <target state="translated">특수화 된 디코드를 사용하여 가능한 성능 이득을 표시하기 위해 일부 측정이 수행되었습니다. 선택적, 배타적 및 완전한 디코딩 (일반적인 경우) 사이의 결과에서 상대적인 수치는 유형의 구조, 메시지의 크기 및 선택적 및 독점적 디코드가 지정된 레벨에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a6bae83c7d1a2e1a895f2a1aac969ea5d6956ad8" translate="yes" xml:space="preserve">
          <source>To hack the erlang libraries, you simply do a &lt;code&gt;make opt&lt;/code&gt; in the specific &quot;applications&quot; directory, like:</source>
          <target state="translated">erlang 라이브러리를 해킹하려면 다음 과 같이 특정 &quot;applications&quot;디렉토리에서 간단히 &lt;code&gt;make opt&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="25afbf964210cbb860d968d22f8aec5dd76f1cff" translate="yes" xml:space="preserve">
          <source>To handle Unicode characters in Erlang, a common representation in both lists and binaries is needed. EEP (10) and the subsequent initial implementation in Erlang/OTP R13A settled a standard representation of Unicode characters in Erlang.</source>
          <target state="translated">Erlang에서 유니 코드 문자를 처리하려면 목록과 이진 모두에서 공통된 표현이 필요합니다. Erlang / OTP R13A의 EEP (10) 및 후속 초기 구현은 Erlang에서 유니 코드 문자의 표준 표현을 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="342c993bd4e7155816205341dd7a1c3953a4f6f8" translate="yes" xml:space="preserve">
          <source>To have &lt;code&gt;Common Test&lt;/code&gt; encrypt a specified file using function &lt;code&gt;DES3&lt;/code&gt; in application &lt;code&gt;Crypto&lt;/code&gt;, call &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; The encrypted file can then be used as a regular configuration file in combination with other encrypted files or normal text files. However, the key for decrypting the configuration file must be provided when running the test. This can be done with flag/option &lt;code&gt;decrypt_key&lt;/code&gt; or &lt;code&gt;decrypt_file&lt;/code&gt;, or a key file in a predefined location.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 가 &lt;code&gt;Crypto&lt;/code&gt; 애플리케이션에서 함수 &lt;code&gt;DES3&lt;/code&gt; 을 사용하여 지정된 파일을 암호화하도록 하려면 &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 . 그런 다음 암호화 된 파일을 다른 암호화 된 파일 또는 일반 텍스트 파일과 함께 일반 구성 파일로 사용할 수 있습니다. 그러나 테스트를 실행할 때 구성 파일의 암호 해독 키가 제공되어야합니다. 이는 플래그 / 옵션 &lt;code&gt;decrypt_key&lt;/code&gt; 또는 &lt;code&gt;decrypt_file&lt;/code&gt; 또는 사전 정의 된 위치의 키 파일을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85cad9012ac3a0f7585ee9eb3d18653bcfe48b6e" translate="yes" xml:space="preserve">
          <source>To have an effect, a breakpoint must be set at an &lt;strong&gt;executable line&lt;/strong&gt;, which is a line of code containing an executable expression such as a matching or a function call. A blank line or a line containing a comment, function head, or pattern in a &lt;code&gt;case&lt;/code&gt; statement or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">효과를 얻으려면 &lt;strong&gt;실행 라인에&lt;/strong&gt; 중단 점을 설정해야합니다. &lt;strong&gt;실행 라인&lt;/strong&gt; 은 일치 또는 함수 호출과 같은 실행 가능 표현식을 포함하는 코드 라인입니다. &lt;code&gt;case&lt;/code&gt; 문이나 &lt;code&gt;receive&lt;/code&gt; 문에 주석, 함수 헤드 또는 패턴이 포함 된 빈 줄이나 줄 은 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3526ad99fb939a42fd2ac8a732fa13795a7fc7c2" translate="yes" xml:space="preserve">
          <source>To have effect, this function is to be called from &lt;code&gt;init_per_suite/1&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;) before any tests are performed.</source>
          <target state="translated">적용하려면 테스트를 수행하기 전에 &lt;code&gt;init_per_suite/1&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 참조 ) 에서이 함수를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2708c75c960cc2ecf9c829562c09567eee5b452b" translate="yes" xml:space="preserve">
          <source>To help adapt configuration data to a test suite (or test case) and improve readability.</source>
          <target state="translated">구성 데이터를 테스트 스위트 (또는 테스트 케이스)에 적용하고 가독성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="030c50a15bdc06f6e3b51217f3e73b7d2d5a9ad8" translate="yes" xml:space="preserve">
          <source>To help setup the environment, there is a bat file, &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt;, that set's the appropriate environment for a Windows command prompt. This is not appropriate for bash, so you'll need to convert it to bash-style environments by editing your &lt;code&gt;.bash_profile&lt;/code&gt;. In my case, where the SDK is installed in the default directory and &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; is &lt;code&gt;C:\Program Files&lt;/code&gt;, the commands for setting up a 32bit build environment (on a 64bit or 32bit machine) look like this (in Cygwin):</source>
          <target state="translated">환경 설정을 돕기 위해 Windows 명령 프롬프트에 적합한 환경 인 bat 파일 &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt; 있습니다. 이것은 bash에 적합하지 않으므로 &lt;code&gt;.bash_profile&lt;/code&gt; 을 편집하여 bash 스타일 환경으로 변환해야합니다 . 필자의 경우 SDK가 기본 디렉토리에 설치되어 있고 &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; 가 &lt;code&gt;C:\Program Files&lt;/code&gt; 인 경우 32 비트 빌드 환경 (64 비트 또는 32 비트 시스템에서)을 설정하는 명령은 다음과 같습니다 (Cygwin에서).</target>
        </trans-unit>
        <trans-unit id="8c68f332c622b4567e9853c18f5bd4711a371dc7" translate="yes" xml:space="preserve">
          <source>To help with debugging, EUnit defines several useful macros for printing messages directly to the console (rather than to the standard output). Furthermore, these macros all use the same basic format, which includes the file and line number where they occur, making it possible in some development environments (e.g., when running Erlang in an Emacs buffer) to simply click on the message and jump directly to the corresponding line in the code.</source>
          <target state="translated">디버깅을 돕기 위해 EUnit은 메시지를 표준 출력이 아닌 콘솔로 직접 인쇄하는 데 유용한 몇 가지 매크로를 정의합니다. 또한이 매크로는 모두 동일한 기본 형식을 사용합니다. 여기에는 파일과 줄 번호가 포함되어 있으며 일부 개발 환경 (예 : Emacs 버퍼에서 Erlang을 실행할 때)에서 간단히 메시지를 클릭하고 바로 이동할 수 있습니다. 코드에서 해당 라인.</target>
        </trans-unit>
        <trans-unit id="f2bf4f85026136c5e9d89c67190507dcee8f99df" translate="yes" xml:space="preserve">
          <source>To identify connections (described later).</source>
          <target state="translated">연결을 식별합니다 (나중에 설명).</target>
        </trans-unit>
        <trans-unit id="a3a37007760548419af74fbda4faaad4a58f472b" translate="yes" xml:space="preserve">
          <source>To illustrate the interoperability principles, C programs running in a UNIX environment have been used. It is assumed that you have enough knowledge to apply these principles to the relevant programming languages and platforms.</source>
          <target state="translated">상호 운용성 원칙을 설명하기 위해 UNIX 환경에서 실행되는 C 프로그램이 사용되었습니다. 이러한 원칙을 관련 프로그래밍 언어 및 플랫폼에 적용하기에 충분한 지식이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e25970fd2bf365203fb3a3002e19cdcdbb27a907" translate="yes" xml:space="preserve">
          <source>To illustrate this we make up an example where the buttons instead generate down and up (press and release) events, and the lock responds to an up event only after the corresponding down event.</source>
          <target state="translated">이를 설명하기 위해 버튼 대신 다운 및 업 (누르기 및 놓기) 이벤트를 생성하고 해당 다운 이벤트 이후에만 잠금이 업 이벤트에 응답하는 예를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="272786a4055a77679447504bd8a8b3f74b9c24f1" translate="yes" xml:space="preserve">
          <source>To illustrate this, do &lt;strong&gt;not&lt;/strong&gt; write as follows:</source>
          <target state="translated">이를 설명하기 위해 다음과 같이 쓰지 &lt;strong&gt;마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="968314d317898e187c56ec55b8af76cc4a65eba4" translate="yes" xml:space="preserve">
          <source>To illustrate this, suppose we extend our Mnesia &lt;code&gt;empTable&lt;/code&gt; with one internal column. We create it as before, but with an arity of 4, by adding another attribute.</source>
          <target state="translated">이를 설명하기 위해 Mnesia &lt;code&gt;empTable&lt;/code&gt; 을 하나의 내부 열로 확장한다고 가정하십시오 . 이전과 동일하지만 다른 속성을 추가하여 arity 4로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a162dc5a66ab8801f7f0ce0a26a9e8e3d6ef7a06" translate="yes" xml:space="preserve">
          <source>To illustrate this, the messenger example from the previous section is divided into the following five files:</source>
          <target state="translated">이를 설명하기 위해 이전 섹션의 메신저 예제는 다음 5 개의 파일로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="6bb28103d410bbb4345e8969c22657c7565cfc3a" translate="yes" xml:space="preserve">
          <source>To implement a new carrier for the Erlang distribution, the main steps are as follows.</source>
          <target state="translated">Erlang 배포를위한 새로운 이동 통신사를 구현하기위한 주요 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="279afddbfce41bfb8c90b18f6a7106e81cad960d" translate="yes" xml:space="preserve">
          <source>To implement a user-defined behaviour, write code similar to code for a special process, but call functions in a callback module for handling specific tasks.</source>
          <target state="translated">사용자 정의 동작을 구현하려면 특수 프로세스의 코드와 유사한 코드를 작성하지만 특정 작업을 처리하기 위해 콜백 모듈에서 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bbcff46d509465f1d50c1bdbf6bb8561780d4955" translate="yes" xml:space="preserve">
          <source>To implement an agent, the programmer writes instrumentation functions for the variables and the tables in the MIBs that the agent is going to support. A running prototype which handles &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;get-next&lt;/code&gt; can be created without any programming.</source>
          <target state="translated">에이전트를 구현하기 위해 프로그래머는 에이전트가 지원할 MIB의 변수 및 테이블에 대한 계측 기능을 작성합니다. 프로그래밍없이 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;get-next&lt;/code&gt; 를 처리하는 실행중인 프로토 타입을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330de1ad3973af593bbd7d81e03664889a42ea4e" translate="yes" xml:space="preserve">
          <source>To implement your own service discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">자체 서비스 검색 모듈을 구현하려면 자체 EPMD 모듈을 작성해야합니다. &lt;code&gt;EPMD module&lt;/code&gt; 다른 노드의 위치를 제공 할 책임이있다. 배포 모듈 ( &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; )은 EPMD 모듈을 호출하여 다른 노드의 IP 주소와 포트를 가져옵니다. Erlang / OTP의 일부인 EPMD 모듈은 DNS를 사용하여 호스트 이름을 확인하고 EPMD unix 프로세스를 사용하여 다른 노드의 포트를 가져옵니다. EPMD unix 프로세스는 잘 알려진 포트 인 포트 4369의 다른 노드에 연결하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="79134b2c4e38df5717fe5011c4463fea24abb3c3" translate="yes" xml:space="preserve">
          <source>To improve performance when analysing cover results it is possible to do multiple calls to &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; at once. You can also use the &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; convenience function.</source>
          <target state="translated">표지 결과를 분석 할 때 성능을 향상시키기 위해 여러 번의 호출을 수행하여 &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 을 한 번에 수행 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; 편의 기능을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d70eada12ec2a8f92aa033daf56e896f20d26d8f" translate="yes" xml:space="preserve">
          <source>To include other nodes in the coverage analysis, use &lt;code&gt;start/1&lt;/code&gt;. All cover compiled modules will then be loaded on all nodes, and data from all nodes will be summed up when analysing. For simplicity this example only involves the current node.</source>
          <target state="translated">적용 범위 분석에 다른 노드를 포함 시키려면 &lt;code&gt;start/1&lt;/code&gt; 을 사용하십시오 . 그러면 모든 컴파일 된 모듈이 모든 노드에로드되고 분석시 모든 노드의 데이터가 요약됩니다. 간단히하기 위해이 예제에는 현재 노드 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a5478a26ee1ac879ac54fc75bcb8b9a9f083c3ec" translate="yes" xml:space="preserve">
          <source>To include private shell commands, define them in a module &lt;code&gt;user_default&lt;/code&gt; and add the following argument as the first line in the &lt;code&gt;.erlang&lt;/code&gt; file:</source>
          <target state="translated">개인 쉘 명령을 포함하려면 &lt;code&gt;user_default&lt;/code&gt; 모듈에서 명령을 정의하고 &lt;code&gt;.erlang&lt;/code&gt; 파일 의 첫 번째 행으로 다음 인수를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="203ccb7faa11c702e1202041c2be3ef44596552b" translate="yes" xml:space="preserve">
          <source>To initialize the database, execute the following code on one of the two nodes:</source>
          <target state="translated">데이터베이스를 초기화하려면 두 노드 중 하나에서 다음 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="026d2b6accddb0e61f3eda91aff0268e88788933" translate="yes" xml:space="preserve">
          <source>To insert an &amp;amp; or a \ in the result, precede it with a \. Notice that Erlang already gives a special meaning to \ in literal strings, so a single \ must be written as &lt;code&gt;&quot;\\&quot;&lt;/code&gt; and therefore a double \ as &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">결과에 &amp;amp; 또는 \를 삽입하려면 앞에 \를 붙입니다. Erlang은 이미 리터럴 문자열에서 \에 특별한 의미를 부여하므로 단일 \는 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; 로 작성되어야 하고 따라서 이중 \는 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c018c38250aabfbb51e23ce90651060a950f1b96" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">시작 인수를 포함하여 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="44e25aea36620d24d591fc0a361139dfb3c4b11c" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">시작 인수를 포함하여 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="c9c7864f1c5249a35705cc8dcabba48f995e8ae5" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="025cdabf9ad94f75800cda5f1e9747d7ccc0323d" translate="yes" xml:space="preserve">
          <source>To install the CSS file (&lt;code&gt;Common Test&lt;/code&gt; inlines the definition in the HTML code), the file name can be provided when executing &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">CSS 파일을 설치하기 위해 ( &lt;code&gt;Common Test&lt;/code&gt; 는 HTML 코드에서 정의를 인라인합니다) &lt;code&gt;ct_run&lt;/code&gt; 을 실행할 때 파일 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb96dbc16afa611fcde38057919ecf9cc751bfa" translate="yes" xml:space="preserve">
          <source>To install the new version of the release in runtime, the &lt;strong&gt;release handler&lt;/strong&gt; is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the &lt;code&gt;release_handler&lt;/code&gt; module. For details, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">런타임에 새 버전의 릴리스를 설치하기 위해 &lt;strong&gt;릴리스 핸들러&lt;/strong&gt; 가 사용됩니다. 이는 릴리스 패키지의 포장 풀기, 설치 및 제거를 처리하는 SASL 응용 프로그램에 속하는 프로세스입니다. &lt;code&gt;release_handler&lt;/code&gt; 모듈을 통해 통신됩니다 . 자세한 내용 은 SASL 의 &lt;code&gt;release_handler(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73c1bf364dc283d1176ab1d289c500fd685a5dab" translate="yes" xml:space="preserve">
          <source>To interpret all displayed modules in the chosen directory, click &lt;strong&gt;All&lt;/strong&gt;.</source>
          <target state="translated">선택한 디렉토리에있는 모든 디스플레이 모듈을 해석하려면 클릭 &lt;strong&gt;모두&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3292879da2b34dcadcc9f9ce0648b935ba4e7f92" translate="yes" xml:space="preserve">
          <source>To interrupt the runtime system or the shell process (depending on what has been specified with system flag &lt;code&gt;+B&lt;/code&gt;), use &lt;code&gt;Ctrl-Break&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이나 쉘 프로세스를 중단하려면 (시스템 플래그로 지정 된 내용에 따라 &lt;code&gt;+B&lt;/code&gt; )를 사용 &lt;code&gt;Ctrl-Break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d9005b012d1045c52922820e7322a9dfa02e1f6" translate="yes" xml:space="preserve">
          <source>To investigate what Erlang thinks about the terminal, the call &lt;code&gt;io:getopts()&lt;/code&gt; can be used when the shell is started:</source>
          <target state="translated">Erlang이 터미널에 대해 어떻게 생각하는지 조사하기 위해 쉘이 시작될 때 &lt;code&gt;io:getopts()&lt;/code&gt; 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a6e867a167f9a4a740ad92d9902eefad28664c" translate="yes" xml:space="preserve">
          <source>To just run a shell on a remote machine, there are functions that bundles the needed three steps needed into one: &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt;. Similarily, to just open an sftp (file transfer) connection to a remote machine, the simplest way is to use &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 시스템에서 쉘을 실행하기 위해 필요한 세 단계를 하나로 묶는 기능이 있습니다 : &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt; . 마찬가지로 원격 시스템에 대한 sftp (파일 전송) 연결을 여는 가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9f2634ff9e5775d30c933d162e116bcf2daeb2ae" translate="yes" xml:space="preserve">
          <source>To learn what sequential tracing is and how it can be used, see the Reference Manual for &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">순차 추적이 무엇이고 어떻게 사용하는지 배우려면 &lt;code&gt;seq_trace&lt;/code&gt; 참조 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea8c91f9201e13f8a7af2544d0b6f79400981a45" translate="yes" xml:space="preserve">
          <source>To let the test suite continue on executing, return the configuration list that you want the test to use as the result.</source>
          <target state="translated">테스트 스위트가 계속 실행되도록하려면 테스트로 사용할 구성 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="d62397eee2357878fc975aeb84771b8bc2c06ea8" translate="yes" xml:space="preserve">
          <source>To limit the shutdown time, the time &lt;code&gt;init&lt;/code&gt; is allowed to spend taking down applications, command-line flag &lt;code&gt;-shutdown_time&lt;/code&gt; is to be used.</source>
          <target state="translated">종료 시간을 제한 하기 위해 &lt;code&gt;init&lt;/code&gt; 가 응용 프로그램을 종료하는 데 소요되는 시간 은 명령 행 플래그 &lt;code&gt;-shutdown_time&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31df00fd05b2b4e7d3ede7fd0ed32c7595a82e9c" translate="yes" xml:space="preserve">
          <source>To list the contents of a configuration file, use &lt;code&gt;list_config/1&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 내용을 나열하려면 &lt;code&gt;list_config/1&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5d893e9a4aaa1eb2af17414123d7e17dc6fd363" translate="yes" xml:space="preserve">
          <source>To listen on both SCTP and TCP, define one transport for each.</source>
          <target state="translated">SCTP와 TCP를 모두 청취하려면 각각에 대해 하나의 전송을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="07a54ad0b2a1bb175cf95b725d86a06fc8b48cbd" translate="yes" xml:space="preserve">
          <source>To look up one of the names:</source>
          <target state="translated">이름 중 하나를 찾으려면</target>
        </trans-unit>
        <trans-unit id="8a56bbc15981f1188aa9ff7ef71388335fe7c6a6" translate="yes" xml:space="preserve">
          <source>To make a debug build of the emulator, you need to recompile both &lt;code&gt;beam.dll&lt;/code&gt; (the actual runtime system) and &lt;code&gt;erlexec.dll&lt;/code&gt;. Do like this</source>
          <target state="translated">에뮬레이터의 디버그 빌드를 만들려면 &lt;code&gt;beam.dll&lt;/code&gt; (실제 런타임 시스템)과 &lt;code&gt;erlexec.dll&lt;/code&gt; 을 모두 다시 컴파일해야합니다 . 이처럼</target>
        </trans-unit>
        <trans-unit id="038da331fd12e331816c4b78d58a10e2cc57ca86" translate="yes" xml:space="preserve">
          <source>To make it clearer exactly what code the warnings refer to, the warnings in the following examples are inserted as comments after the clause they refer to, for example:</source>
          <target state="translated">경고가 참조하는 코드를보다 명확하게하기 위해 다음 예의 경고는 예를 들어 참조 절 뒤에 주석으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2982d9a90975bc47a9c7a7530d4f0cbaa3f7f2" translate="yes" xml:space="preserve">
          <source>To make it easier to understand this section, some terms are defined. This is a mix of our own terminology (Erlang/OS system time, Erlang/OS monotonic time, time warp) and globally accepted terminology.</source>
          <target state="translated">이 섹션을보다 쉽게 ​​이해할 수 있도록 일부 용어가 정의되어 있습니다. 이것은 자체 용어 (Erlang / OS 시스템 시간, Erlang / OS 단조 시간, 시간 왜곡) 및 전 세계적으로 사용되는 용어가 혼합 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2921bab0b743bbb6198162ca9c596c8d4e059429" translate="yes" xml:space="preserve">
          <source>To make the descriptions simpler, we first list some definitions:</source>
          <target state="translated">설명을 단순화하기 위해 먼저 몇 가지 정의를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="9c4714caed05dab02e49dd183a4006e068e3199f" translate="yes" xml:space="preserve">
          <source>To make the example runnable, we start implementing the reading and writing of the data to/from the ETS table. First function &lt;code&gt;put_chars/3&lt;/code&gt;:</source>
          <target state="translated">예제를 실행 가능하게 만들기 위해 ETS 테이블에서 데이터를 읽고 쓰는 작업을 시작합니다. 첫 번째 함수 &lt;code&gt;put_chars/3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="632f6f737e1f0ad548a43d9ad64573eca55f152d" translate="yes" xml:space="preserve">
          <source>To make the process change code, send the message &lt;code&gt;code_switch&lt;/code&gt; to it. The process then makes a fully qualified call to &lt;code&gt;m:loop()&lt;/code&gt; and changes to current code. Notice that &lt;code&gt;m:loop/0&lt;/code&gt; must be exported.</source>
          <target state="translated">프로세스 변경 코드를 작성하려면 &lt;code&gt;code_switch&lt;/code&gt; 메시지를 보내 십시오. 그런 다음 프로세스는 &lt;code&gt;m:loop()&lt;/code&gt; 를 완전히 호출 하고 현재 코드로 변경합니다. 알 &lt;code&gt;m:loop/0&lt;/code&gt; 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="e177c9389e3d182722e09e0544b0a24268ff84e3" translate="yes" xml:space="preserve">
          <source>To make the test fair, each new test run is to run in its own, newly created Erlang process. Otherwise, if all tests run in the same process, the later tests start out with larger heap sizes and therefore probably do fewer garbage collections. Also consider restarting the Erlang emulator between each test.</source>
          <target state="translated">테스트를 공정하게하기 위해 각각의 새로운 테스트 실행은 새로 생성 된 자체 Erlang 프로세스에서 실행됩니다. 그렇지 않으면 모든 테스트가 동일한 프로세스에서 실행되는 경우 이후 테스트는 더 큰 힙 크기로 시작되므로 가비지 콜렉션이 더 적을 수 있습니다. 또한 각 테스트간에 Erlang 에뮬레이터를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="120ecf4e057892d6019b012a82abcf83ac9ffd85" translate="yes" xml:space="preserve">
          <source>To make this happen the megaco stack has to be configured:</source>
          <target state="translated">이를 위해 megaco 스택을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="13169d7b871948e1e9a9c4457e119e83fe7939d4" translate="yes" xml:space="preserve">
          <source>To manipulate services, the logged on user is to have administrator privileges on the machine. The Erlang machine itself is (default) run as the local administrator. This can be changed with the Services applet in Windows.</source>
          <target state="translated">서비스를 조작하려면 로그온 한 사용자가 시스템에 대한 관리자 권한을 가지고 있어야합니다. Erlang 시스템 자체는 (기본) 로컬 관리자로 실행됩니다. 이것은 Windows의 서비스 애플릿으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330fd48fdffeb44ebc089750d09d688535c7db34" translate="yes" xml:space="preserve">
          <source>To manipulate the Erlang services easily, put the &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; directory in the path instead of &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt;. The &lt;code&gt;erlsrv&lt;/code&gt; program can be found from inside Erlang by using the &lt;code&gt;os:find_executable/1&lt;/code&gt; Erlang function.</source>
          <target state="translated">Erlang 서비스를 쉽게 조작하려면 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt; 대신 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; 디렉토리를 경로에 두십시오 . &lt;code&gt;erlsrv&lt;/code&gt; 의 프로그램은 이용 얼랑 내부에서 발견 될 수 &lt;code&gt;os:find_executable/1&lt;/code&gt; 얼랑 기능.</target>
        </trans-unit>
        <trans-unit id="7b0e537b9e6e88eafa3eeae7f7a02f18b4e1430f" translate="yes" xml:space="preserve">
          <source>To manipulate the table we implement the following utility functions:</source>
          <target state="translated">테이블을 조작하기 위해 다음 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="af1c290996a023ca9ee9b2902b6c1dc2a988f5c7" translate="yes" xml:space="preserve">
          <source>To match out the rest of a binary, specify a binary field without size:</source>
          <target state="translated">나머지 이진을 일치 시키려면 크기가없는 이진 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="50f6c59cd17dfe4a6719c66fb938f13bf13c9cd5" translate="yes" xml:space="preserve">
          <source>To match out the rest of a bitstring, specify a field without size:</source>
          <target state="translated">나머지 비트 열을 일치 시키려면 크기가없는 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3c74e2148772d016b06b50e91a05f48c85c5db24" translate="yes" xml:space="preserve">
          <source>To merge all wrap logs from two nodes:</source>
          <target state="translated">두 노드의 모든 랩 로그를 병합하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6ec3ba5252c54ac879e329c670bb92c1a4f26979" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성, 사용 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt; , 또는, 더 복잡한 병합이 필요한 경우와 현재 구성 읽어 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt; ,이 기능을 가진 새로운 구성 등을 쓰기 전에 병합을한다.</target>
        </trans-unit>
        <trans-unit id="7cbe08d74968e08a72c3be83982bb750cd3d4357" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성을 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt; 을 사용 하거나보다 복잡한 병합이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt; 으로 현재 구성을 읽은 다음이 기능으로 새 구성을 다시 작성하기 전에 병합을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5232b103674f04a52f0f595b415d6da9c86b5634" translate="yes" xml:space="preserve">
          <source>To not lose the data that the failing node stored up to the point of crash, the control node tries to fetch it before restarting trace. This must occur within the allowed time frame, otherwise it is aborted (default is 10 seconds, but it can be changed with &lt;code&gt;{resume, MSec}&lt;/code&gt;). The data fetched this way is then merged with all other traces.</source>
          <target state="translated">장애가 발생한 노드가 충돌 지점까지 저장 한 데이터를 잃지 않기 위해 제어 노드는 추적을 다시 시작하기 전에 데이터를 가져 오려고 시도합니다. 허용 된 시간 내에 발생해야합니다. 그렇지 않으면 중단됩니다 (기본값은 10 초이지만 &lt;code&gt;{resume, MSec}&lt;/code&gt; 로 변경할 수 있음 ). 이 방법으로 가져온 데이터는 다른 모든 추적과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="eead728bbb8cc0046ae68985d45f67a85158d6b1" translate="yes" xml:space="preserve">
          <source>To not update a driver and only recompile, it probably works when building for a 32-bit machine creating a false sense of security. Hopefully that will generate many important warnings. But when recompiling the same driver later on for a 64-bit machine, there &lt;strong&gt;will&lt;/strong&gt; be warnings and almost certainly crashes. So it is a &lt;strong&gt;bad&lt;/strong&gt; idea to postpone updating the driver and not fixing the warnings.</source>
          <target state="translated">드라이버를 업데이트하지 않고 다시 컴파일하기 만하면 잘못된 보안 감각을 만드는 32 비트 시스템을 빌드 할 때 작동합니다. 많은 중요한 경고가 발생하기를 바랍니다. 동일한 드라이버 나중에 64 비트 머신에 재 컴파일 때,이 &lt;strong&gt;것&lt;/strong&gt; 경고하고 거의 확실하게 충돌합니다. 그래서 그것은이다 &lt;strong&gt;나쁜&lt;/strong&gt; 드라이버를 업데이트하고 경고를 고정하지 연기 할 생각은.</target>
        </trans-unit>
        <trans-unit id="25dd351d674ee351bc0d61f733e4bc4ab3924c98" translate="yes" xml:space="preserve">
          <source>To only collect data from remote nodes without stopping &lt;code&gt;cover&lt;/code&gt; on those nodes, use &lt;code&gt;cover:flush/1&lt;/code&gt;</source>
          <target state="translated">해당 노드에서 &lt;code&gt;cover&lt;/code&gt; 를 중지하지 않고 원격 노드에서만 데이터를 수집하려면 &lt;code&gt;cover:flush/1&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9228c30057d8d3d2590c6d0ceb056f1bc0cfdc8f" translate="yes" xml:space="preserve">
          <source>To only update an existing value, the following syntax is used:</source>
          <target state="translated">기존 값만 업데이트하기 위해 다음 구문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91ac146297375e57e22dd83d0532b37bf8d61261" translate="yes" xml:space="preserve">
          <source>To open a file for writing and place the BOM first is even simpler:</source>
          <target state="translated">쓰기 위해 파일을 열고 BOM을 먼저 배치하는 것이 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="58c7c0dd2c707e847605f73d2bf4f644bea3024e" translate="yes" xml:space="preserve">
          <source>To open a popup menu from which the appropriate module can be selected, right-click the &lt;strong&gt;Module&lt;/strong&gt; entry.</source>
          <target state="translated">적절한 모듈을 선택할 수있는 팝업 메뉴를 열려면 &lt;strong&gt;모듈&lt;/strong&gt; 항목을 마우스 오른쪽 버튼으로 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="14f5619a76f5c4433353480eb14374da920455d5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the module to which the fun belongs, right-click the row and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">재미가 속한 모듈에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;mod&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="707dccebf0704f68a732417b3f2c2e2a669bd41f" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of a timer, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">타이머의 소유자 프로세스에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="67b5909ded381e129ca3cf333f0952bd76fc77a6" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of an ETS table, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">ETS 테이블의 소유자 프로세스에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="310178f41809534c7c90fe35f112b61d4b6677f5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the scheduler, double-click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">스케줄러에 대한 자세한 정보 페이지를 열려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;'식별자'에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="571318d856ef4524500a9b751e49f54bd8327c0e" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the table, double- click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">테이블에 대한 자세한 정보 페이지를 열려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;'식별자'에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f882324ba7cf66c628fe99da4190c380235eb46" translate="yes" xml:space="preserve">
          <source>To output characters on an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">I / O 장치에서 문자를 출력하려면 다음과 같은 &lt;code&gt;Request&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="4460b3a67f9f027204de0ad12d5d1dec14e5f20d" translate="yes" xml:space="preserve">
          <source>To overcome this situation, try to restart the ongoing transactions that are accessing tables on the failing node, and write a &lt;code&gt;mnesia_down&lt;/code&gt; entry to a log file.</source>
          <target state="translated">이 상황을 극복하려면 실패한 노드의 테이블에 액세스하는 진행중인 트랜잭션을 다시 시작하고 &lt;code&gt;mnesia_down&lt;/code&gt; 항목을 로그 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7f8360d8ea17a73622310335fec57f5f594e5a" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use</source>
          <target state="translated">병합없이 기존 구성을 덮어 쓰려면</target>
        </trans-unit>
        <trans-unit id="8eb9c41fc2b2f98f04f5d6d6242bc28f6713bd31" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합없이 기존 구성을 겹쳐 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt; 려면 set_handler_config / 2를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db040bf59efb80826409bf9f754e7a7431f35000" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합없이 기존 구성을 겹쳐 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt; 려면 set_primary_config / 1을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef5df41f2e14a8f5ccfe8eb5134454968930bd33" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">한 테스트 스위트에서 다른 테스트 스위트로 데이터를 전달하기 위해 동일한 메커니즘이 사용됩니다. 데이터는 종료 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 에 의해 저장되고 다음 제품군의 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 의해 읽혀 집니다. 제품군간에 데이터를 전달할 때 &lt;code&gt;Saver&lt;/code&gt; 는 테스트 제품군의 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="de196dbd1fc4727b3381ea786892e523ea66df78" translate="yes" xml:space="preserve">
          <source>To pass start arguments to the event handler init function, use option &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; instead of &lt;code&gt;-event_handler&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러 init 함수에 시작 인수를 전달하려면 &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; 대신 ct_run -event_handler_init 옵션을 사용 &lt;code&gt;-event_handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05760d82d1ff0699d6462cb51afbab4089fd15b2" translate="yes" xml:space="preserve">
          <source>To paste text, use &lt;code&gt;Ctrl-V&lt;/code&gt;.</source>
          <target state="translated">텍스트를 붙여 넣으려면 &lt;code&gt;Ctrl-V&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a0ab25b4dbcc22e8a0f55cfd17389d320947558" translate="yes" xml:space="preserve">
          <source>To perform a selective decode:</source>
          <target state="translated">선택적 디코딩을 수행하려면</target>
        </trans-unit>
        <trans-unit id="e34161a911d532a3fe5b96ed7a79392865f455a4" translate="yes" xml:space="preserve">
          <source>To perform an exclusive decode:</source>
          <target state="translated">단독 디코딩을 수행하려면</target>
        </trans-unit>
        <trans-unit id="3f8dad79e2d5118a556c41ca87119ccb799f35ee" translate="yes" xml:space="preserve">
          <source>To perform code coverage test (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">코드 범위 테스트를 수행하려면 ( &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a431fccb77738e590c035501f73871c8ebfc0dd5" translate="yes" xml:space="preserve">
          <source>To plug in a handler to the &lt;code&gt;Common Test&lt;/code&gt; Master event manager, specify &lt;code&gt;master&lt;/code&gt; as the node in &lt;code&gt;NodeRefs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master 이벤트 관리자에 핸들러를 연결하려면 &lt;code&gt;NodeRefs&lt;/code&gt; 에서 &lt;code&gt;master&lt;/code&gt; 를 노드로 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9a49f1cec23382260ab3c7111ed66a3064f4b5e" translate="yes" xml:space="preserve">
          <source>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a &lt;strong&gt;maximum restart intensity&lt;/strong&gt; is defined using two integer values specified with keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the above map. Assuming the values &lt;code&gt;MaxR&lt;/code&gt; for &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;MaxT&lt;/code&gt; for &lt;code&gt;period&lt;/code&gt;, then, if more than &lt;code&gt;MaxR&lt;/code&gt; restarts occur within &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;. &lt;code&gt;intensity&lt;/code&gt; defaults to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저가 자식 프로세스 종료 및 재시작의 무한 루프에 빠지지 않도록 위의 맵에서 키 &lt;code&gt;intensity&lt;/code&gt; 와 &lt;code&gt;period&lt;/code&gt; 지정된 두 정수 값을 사용하여 &lt;strong&gt;최대 재시작 강도&lt;/strong&gt; 를 정의합니다 . 값 가정 &lt;code&gt;MaxR&lt;/code&gt; 대한 &lt;code&gt;intensity&lt;/code&gt; 및 &lt;code&gt;MaxT&lt;/code&gt; 을 위한 &lt;code&gt;period&lt;/code&gt; 이상 '라면, &lt;code&gt;MaxR&lt;/code&gt; 의 재시작 내에 발생 &lt;code&gt;MaxT&lt;/code&gt; 의 초 감독자가 모든 하위 프로세스 자체를 종료한다. 이 경우 수퍼바이저 자체의 종료 이유는 &lt;code&gt;shutdown&lt;/code&gt; 입니다. &lt;code&gt;intensity&lt;/code&gt; 기본값은 &lt;code&gt;1&lt;/code&gt; 이며 &lt;code&gt;period&lt;/code&gt; 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b6bd58de0f6a9d2c9e5412e4769e5fc57c89331" translate="yes" xml:space="preserve">
          <source>To prevent accidentally reloading of modules affecting the Erlang runtime system, directories &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;compiler&lt;/code&gt; are considered &lt;strong&gt;sticky&lt;/strong&gt;. This means that the system issues a warning and rejects the request if a user tries to reload a module residing in any of them. The feature can be disabled by using command-line flag &lt;code&gt;-nostick&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에 영향을 미치는 모듈을 실수로 다시로드하는 것을 막기 위해 &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;compiler&lt;/code&gt; 디렉토리 는 &lt;strong&gt;sticky&lt;/strong&gt; 로 간주됩니다 . 이는 시스템이 경고를 발행하고 사용자가 모듈에 상주하는 모듈을 다시로드하려고하면 요청을 거부 함을 의미합니다. 이 기능은 명령 행 플래그 &lt;code&gt;-nostick&lt;/code&gt; 을 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dec616600e41a5b6ef771d942e395567b990586c" translate="yes" xml:space="preserve">
          <source>To prevent late answers (after the time-out) from polluting the message queue of the caller, a middleman process is used to do the calls. Late answers are then discarded when they arrive to a terminated process.</source>
          <target state="translated">늦은 응답 (시간 초과 후)이 호출자의 메시지 큐를 오염시키는 것을 방지하기 위해 중개자 프로세스가 호출을 수행하는 데 사용됩니다. 그런 다음 종료 된 프로세스에 도달하면 늦은 응답이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c59c8bcb62921917057af6666d0e9bc306363f2" translate="yes" xml:space="preserve">
          <source>To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘에 파일 목록을 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e7f46b82ce549b77ba51c1629aef0ab23feab88" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment,Comment}&lt;/code&gt;.</source>
          <target state="translated">HTML 결과 페이지의 &lt;code&gt;Comment&lt;/code&gt; 필드에 일부 정보를 인쇄하려면 &lt;code&gt;{comment,Comment}&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cc0874eca15de116c6433f2f6c8188ae52c6b95" translate="yes" xml:space="preserve">
          <source>To produce sensible results, &lt;code&gt;fprof&lt;/code&gt; tries not to charge any function more than once for ACC time. The instance highest up (with longest duration) in the call stack is chosen.</source>
          <target state="translated">합리적인 결과를 &lt;code&gt;fprof&lt;/code&gt; 위해 fprof 는 ACC 시간 동안 어떤 기능도 두 번 이상 충전하지 않습니다. 호출 스택에서 가장 높은 인스턴스 (길이가 가장 긴)가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb950e45ab67b6a47da12b4482a70174dcfdd0c" translate="yes" xml:space="preserve">
          <source>To provide customization and extensibility of the request handling of the HTTP servers, most of these steps are handled by one or more modules. These modules can be replaced or removed at runtime and new ones can be added. For each request, all modules are traversed in the order specified by the module directive in the server configuration file. Some parts, mainly the communication- related steps, are considered server core functionality and are not implemented using the Erlang web server API. A description of functionality implemented by the Erlang webserver API is described in &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP 서버의 요청 처리에 대한 사용자 정의 및 확장 성을 제공하기 위해 이러한 단계의 대부분은 하나 이상의 모듈에 의해 처리됩니다. 이러한 모듈은 런타임에 교체하거나 제거 할 수 있으며 새로운 모듈을 추가 할 수 있습니다. 각 요청에 대해 모든 모듈은 서버 구성 파일에서 모듈 지시문에 지정된 순서대로 순회합니다. 주로 통신 관련 단계 인 일부 부분은 서버 핵심 기능으로 간주되며 Erlang 웹 서버 API를 사용하여 구현되지 않습니다. Erlang 웹 서버 API로 구현 된 기능에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7caa6e3412703737187f18930265da85c613b9f8" translate="yes" xml:space="preserve">
          <source>To provide more information for bug detection tools, such as Dialyzer</source>
          <target state="translated">Dialyzer와 같은 버그 탐지 도구에 대한 자세한 정보를 제공하려면</target>
        </trans-unit>
        <trans-unit id="5563a933e99748f8947b5b13de253c9bebd73132" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;erl_receive()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;erl_receive&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;ErlMessage&lt;/code&gt; structure.</source>
          <target state="translated">견고성을 제공하기 위해 분산 Erlang 노드는 때때로 장애가 발생한 노드 또는 통신 링크를 감지하기 위해 연결된 모든 인접 노드를 폴링합니다. 이러한 메시지를받는 노드는 &lt;code&gt;ERL_TICK&lt;/code&gt; 메시지로 즉시 응답합니다 . 이것은 &lt;code&gt;erl_receive()&lt;/code&gt; 의해 자동으로 수행됩니다 . 그러나, 이것이 발생, &lt;code&gt;erl_receive&lt;/code&gt; 복귀 &lt;code&gt;ERL_TICK&lt;/code&gt; 을 에 메시지를 저장하지 않고 호출자 &lt;code&gt;ErlMessage&lt;/code&gt; 의 구조.</target>
        </trans-unit>
        <trans-unit id="c22d22ca8626a0d9ad4822b6abdf3304ff0e2ed1" translate="yes" xml:space="preserve">
          <source>To quickly get started on tracing function calls you can use the following code in the Erlang shell:</source>
          <target state="translated">추적 함수 호출을 빠르게 시작하려면 Erlang 쉘에서 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4216c6c1555a4ffc81851d786b4c47388d4033ab" translate="yes" xml:space="preserve">
          <source>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</source>
          <target state="translated">급여가 10 미만인 모든 사람의 급여를 10으로 올리고 모든 인상의 합계를 반환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="487f9ae77ed1f6bfc72656beab390cd3da83a3a4" translate="yes" xml:space="preserve">
          <source>To read characters from an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">I / O 장치에서 문자를 읽으려면 다음 &lt;code&gt;Request&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8ebc4e78936132f1c46d3f47b17ef930ad86f68e" translate="yes" xml:space="preserve">
          <source>To read data saved by a previous test case, use macro &lt;code&gt;config&lt;/code&gt; with a &lt;code&gt;saved_config&lt;/code&gt; key as follows:</source>
          <target state="translated">이전 테스트 사례에서 저장 한 데이터를 읽으려면 다음과 같이 &lt;code&gt;saved_config&lt;/code&gt; 키 와 함께 매크로 &lt;code&gt;config&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e65ac5f6db83037a2248f75d84c868aa8830d0a" translate="yes" xml:space="preserve">
          <source>To read test terms, use &lt;code&gt;Tag = tests&lt;/code&gt; (rather than &lt;code&gt;suites&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, or &lt;code&gt;cases&lt;/code&gt;). &lt;code&gt;Value&lt;/code&gt; is then the list of &lt;strong&gt;all&lt;/strong&gt; tests on the form &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt;, where &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt;.</source>
          <target state="translated">테스트 용어를 읽으려면 &lt;code&gt;suites&lt;/code&gt; , &lt;code&gt;groups&lt;/code&gt; 또는 &lt;code&gt;cases&lt;/code&gt; 대신 &lt;code&gt;Tag = tests&lt;/code&gt; 사용하십시오 . 그러면 &lt;code&gt;Value&lt;/code&gt; 는 &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt; 형식 의 &lt;strong&gt;모든&lt;/strong&gt; 테스트 목록입니다 . 여기서 &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt; [사례] .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5502e1d91075568dbfad6a71c308a3359400e11e" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터 값을 읽으려면 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf5d7d89573645295c9ea3ad3f20e180a97f562f" translate="yes" xml:space="preserve">
          <source>To read the value of a configuration variable, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 변수의 값을 읽으려면 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85dbe7571965e09b1298a761ceeca08b4c2e5f97" translate="yes" xml:space="preserve">
          <source>To read the values from the table directly is not always possible. It can be needed to search one or more tables to get the wanted data, and this is done by writing database queries. Queries are always more expensive operations than direct lookups done with &lt;code&gt;mnesia:read&lt;/code&gt;. Therefore, avoid queries in performance-critical code.</source>
          <target state="translated">테이블에서 직접 값을 읽는 것이 항상 가능한 것은 아닙니다. 원하는 데이터를 얻기 위해 하나 이상의 테이블을 검색해야 할 수 있으며 이는 데이터베이스 쿼리를 작성하여 수행됩니다. 쿼리는 &lt;code&gt;mnesia:read&lt;/code&gt; 로 직접 조회하는 것보다 항상 더 비싼 작업 입니다. 따라서 성능이 중요한 코드에서는 쿼리를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="9ca82b142769fd54c89e1f8c4e76ea91942c4a3b" translate="yes" xml:space="preserve">
          <source>To reboot on Windows, &lt;code&gt;HEART_COMMAND&lt;/code&gt; can be set to &lt;code&gt;heart -shutdown&lt;/code&gt; (included in the Erlang delivery) or to any other suitable program that can activate a reboot.</source>
          <target state="translated">&lt;code&gt;HEART_COMMAND&lt;/code&gt; 는 Windows에서 재부팅 하기 위해 &lt;code&gt;heart -shutdown&lt;/code&gt; (Erlang 제공에 포함) 또는 재부팅을 활성화 할 수있는 다른 적절한 프로그램으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7356ba3e6c5278038b64fa42047a269f1c25742e" translate="yes" xml:space="preserve">
          <source>To reload a driver, the process must have loaded the driver before, that is, there must be an active &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver in the process.</source>
          <target state="translated">드라이버를 다시로드하려면 프로세스가 드라이버를로드하기 전에 프로세스에서 드라이버의 활성 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa3cdbff1f4721e1fea3341a44c74cdfddea8582" translate="yes" xml:space="preserve">
          <source>To remove the special meaning from a sequence of characters, put them between \Q and \E. This is different from Perl in that $ and @ are handled as literals in \Q...\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples:</source>
          <target state="translated">일련의 문자에서 특별한 의미를 제거하려면 \ Q와 \ E 사이에 넣으십시오. $와 @는 PCRE의 \ Q ... \ E 시퀀스에서 리터럴로 처리되는 반면 $와 @는 Perl에서 변수 보간을 일으킨다는 점에서 이것은 Perl과 다릅니다. 다음 예를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="18463ee935cca0988ac023c8a2bb9233c9fed26c" translate="yes" xml:space="preserve">
          <source>To resolve BIF clashes, use explicit module names or the &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; compiler directive.</source>
          <target state="translated">BIF 충돌을 해결하려면 명시 적 모듈 이름 또는 &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; 컴파일러 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b836fc9905c583f17eeb633ad4676ccd91021746" translate="yes" xml:space="preserve">
          <source>To restrict access further, firewall software must be used.</source>
          <target state="translated">추가 액세스를 제한하려면 방화벽 소프트웨어를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8f49586e1a231ba1f54695cd73e9669c2fc73d3" translate="yes" xml:space="preserve">
          <source>To retain backwards compatibility, this module can also be used to start a standalone &lt;code&gt;nteventlog&lt;/code&gt; process which is not part of the OS_Mon supervision tree. When starting such a process, the user has to supply an identifier as well as a callback function to handle the messages.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해이 모듈을 사용 하여 OS_Mon 감독 트리의 일부가 아닌 독립형 &lt;code&gt;nteventlog&lt;/code&gt; 프로세스 를 시작할 수도 있습니다 . 이러한 프로세스를 시작할 때 사용자는 메시지를 처리하기 위해 콜백 함수뿐만 아니라 식별자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df78eacbc0781784bde23219396762a59c5fc919" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">어떤 프로세스가 어떤 테이블을 수정했는지에 대한 정보를 검색하려면 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; . 테이블을 수정하는 프로세스가 많은 시스템에는 테이블을 너무 오래 고정했을 때 경보를 보내는 모니터가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e2ab13997144de0b0946f9bce9ea8b713fdb68" translate="yes" xml:space="preserve">
          <source>To retrieve lock statistics information, use &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;. The collect operation will start a &lt;code&gt;lcnt&lt;/code&gt; server if it not already started. All collected data will be built into an Erlang term and uploaded to the server and a duration time will also be uploaded. This duration is the time between &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; and &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;.</source>
          <target state="translated">잠금 통계 정보를 검색하려면 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 을 사용하십시오 . 수집 작업은 &lt;code&gt;lcnt&lt;/code&gt; 서버가 아직 시작되지 않은 경우 시작합니다. 수집 된 모든 데이터는 Erlang 용어로 작성되어 서버에 업로드되며 지속 시간도 업로드됩니다. 이 기간은 &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; 과 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 사이의 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="ed81e642c8e411bd6b5d4f1ff2f2a981ab28269a" translate="yes" xml:space="preserve">
          <source>To retrieve options, the following request is used:</source>
          <target state="translated">옵션을 검색하기 위해 다음 요청이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9ff785694d496350bf52e12cf31257901fe0f9a" translate="yes" xml:space="preserve">
          <source>To retrieve previous command lines, press the &lt;code&gt;Up arrow&lt;/code&gt; or use &lt;code&gt;Ctrl-P&lt;/code&gt;.</source>
          <target state="translated">이전 명령 행을 검색하려면 &lt;code&gt;Up arrow&lt;/code&gt; 누르 거나 &lt;code&gt;Ctrl-P&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="559902e638ff39f33df6bbdca42175eae97e1371" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 시간 오프셋을 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3766f9d946545324fc3caa134e7e2c3cc1ac0495" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">스크립트의 경로 이름을 검색하려면 스크립트에서 &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; 을 호출 하십시오 (경로 이름은 대개는 아니지만 절대 경로 임).</target>
        </trans-unit>
        <trans-unit id="2fa3ffd8aedc2e1d61b1e455bb122f9f20bde0a5" translate="yes" xml:space="preserve">
          <source>To retrieve the size of a tuple, either use function &lt;code&gt;erl_size&lt;/code&gt; (which checks the type of the checked term and works for a binary as well as for a tuple) or &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; returns the arity of a tuple. &lt;code&gt;erl_size()&lt;/code&gt; does the same thing, but it checks that the argument is a tuple. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; returns the element corresponding to a given position in the tuple.</source>
          <target state="translated">튜플의 크기를 검색하려면 함수 &lt;code&gt;erl_size&lt;/code&gt; (확인 된 용어의 유형을 확인하고 이진 및 튜플에 대해 작동 함)를 사용하거나 &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; 는 튜플 의 arity를 ​​반환합니다. &lt;code&gt;erl_size()&lt;/code&gt; 는 동일한 작업을 수행하지만 인수가 튜플인지 확인합니다. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; 은 튜플 에서 주어진 위치에 해당하는 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e48e571028f75c8447b25387e9c4c4797341c527" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a tar file, use function &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;. To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">tar 파일의 파일 목록을 리턴하려면 함수 &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . Erlang 쉘에 파일 목록을 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="340c1d928e96b2c334351d4a254c0683a554ee08" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;table/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브에있는 파일 목록을 리턴하려면 &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;table/1,2&lt;/code&gt; 로도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="ede464349d4cd7d18cdfbdde4b663fdde07fb367" translate="yes" xml:space="preserve">
          <source>To return a timetrap time value (other than a function).</source>
          <target state="translated">함수 이외의 타임 트랩 시간 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b77285912aad5ab1ca119d023b421a0ece59988" translate="yes" xml:space="preserve">
          <source>To return only a few answers, cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers:</source>
          <target state="translated">몇 가지 답변 만 반환하기 위해 커서를 사용할 수 있습니다. 다음 코드는 고유 답변을 저장하기 위해 ETS 테이블을 사용하여 5 개 이하의 답변을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f1313328915fb09221beb5318c9e4409d5bb780" translate="yes" xml:space="preserve">
          <source>To return your own non-zero exit code, call &lt;code&gt;halt(ExitCode)&lt;/code&gt;, for example:</source>
          <target state="translated">0이 아닌 종료 코드를 리턴하려면 &lt;code&gt;halt(ExitCode)&lt;/code&gt; 호출하십시오 ( 예 :</target>
        </trans-unit>
        <trans-unit id="1b79ecfdca80ef63664553eeb43bf5bf50699646" translate="yes" xml:space="preserve">
          <source>To revert to the old representation of the types, use option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">유형의 이전 표현으로 되돌리려면 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="91cba5ad0a4514ff3580b9b3644134649e4008a3" translate="yes" xml:space="preserve">
          <source>To run DTLS add the option {protocol, dtls} to third argument.</source>
          <target state="translated">DTLS를 실행하려면 {protocol, dtls} 옵션을 세 번째 인수에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6379d836d463079cbc440c281ea46705465f1d9e" translate="yes" xml:space="preserve">
          <source>To run it manually do the following:</source>
          <target state="translated">수동으로 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="adfad10f00ccaf0e104d2a8e3a7d4d9ca3d7a1f4" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data from a test case that is to be skipped, return tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt;.</source>
          <target state="translated">건너 뛸 테스트 케이스에서 &lt;code&gt;Config&lt;/code&gt; 데이터 를 저장하려면 tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="519bc4bce2b33dabd607dc6ed921c16f90d09ddb" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data, return tuple &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; from &lt;code&gt;end_per_testcase&lt;/code&gt; or from the main test case function.</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 데이터 를 저장하려면 &lt;code&gt;end_per_testcase&lt;/code&gt; 또는 기본 테스트 케이스 함수에서 튜플 &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="27c3f8d5138cdbd33fa95b3ba65e0753971bf624" translate="yes" xml:space="preserve">
          <source>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</source>
          <target state="translated">확장 성을 높이려면 새 조각을 포함하여 모든 조각에 레코드가 고르게 분포되도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4c8083213bdb28df6c894a96e97a47fb6b900182" translate="yes" xml:space="preserve">
          <source>To schedule a dirty NIF for execution, the application has two options:</source>
          <target state="translated">더티 NIF 실행을 예약하기 위해 어플리케이션에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dcc54bfbac822c2d50a90e01df3c8520791a56a" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">지원되는 모든 암호 제품군을 보려면 &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt; 호출하십시오 . 연결에 사용 가능한 암호 스위트는 인증서에 따라 다릅니다. 연결에 사용하려는 특정 암호 스위트도 지정할 수 있습니다. 기본값은 가장 강한 것을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="faa6a0098bcbb7837e8269c97adc5d1ee4575f3f" translate="yes" xml:space="preserve">
          <source>To see more detailed information about a node, double-click the row, or right-click the row and select &lt;strong&gt;Properties for node &amp;lt;node&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;, to open the detailed information window for the controlling port.</source>
          <target state="translated">노드에 대한 자세한 정보를 보려면 행을 두 번 클릭하거나 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;node&amp;gt; 노드의 특성을&lt;/strong&gt; 선택하십시오 . 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;&amp;lt;port&amp;gt; 속성을&lt;/strong&gt; 선택 하여 제어 포트에 대한 자세한 정보 창을 열 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b51fe379feee1d788abaddbf99683f3e6711cc7" translate="yes" xml:space="preserve">
          <source>To see relevant version information for ssl, call &lt;code&gt;ssl:versions/0&lt;/code&gt; .</source>
          <target state="translated">ssl에 대한 관련 버전 정보를 보려면 &lt;code&gt;ssl:versions/0&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f1a753c21aa1ee5d67b189d4fc20785c035d677" translate="yes" xml:space="preserve">
          <source>To see what names there are:</source>
          <target state="translated">어떤 이름이 있는지 보려면 :</target>
        </trans-unit>
        <trans-unit id="1859a2e235479aee5e6ed677756b1cdde77dacdb" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">현재 시스템에 설치된 필터를 보려면 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . 필터는 적용된 순서대로 나열됩니다. 즉, 목록의 첫 번째 필터가 먼저 적용되는 방식으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="45a5562edb75b6f3eb1acaabf3b28d155bb31931" translate="yes" xml:space="preserve">
          <source>To select more text than fits in the window, start by selecting a small part in the beginning of the text you want, then use the scrollbar to view the end of the desired selection, point to it, and press the &lt;strong&gt;right&lt;/strong&gt; mouse button. The whole area between your first selection and the point where you right-clicked is included in the selection.</source>
          <target state="translated">창에 맞는 것보다 많은 텍스트를 선택하려면 원하는 텍스트의 시작 부분에서 작은 부분을 선택한 다음 스크롤 막대를 사용하여 원하는 선택의 끝을보고 가리킨 다음 마우스 &lt;strong&gt;오른쪽&lt;/strong&gt; 버튼을 누릅니다. 첫 번째 선택과 마우스 오른쪽 버튼으로 클릭 한 지점 사이의 전체 영역이 선택에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33c0c20ef88e8a421c1e58b4d073cd8cec174df4" translate="yes" xml:space="preserve">
          <source>To select text in the &lt;code&gt;werl&lt;/code&gt; window, press and hold the left mouse button and drag the mouse over the text you want to select. If the selection crosses line boundaries, the selected text consists of complete lines where applicable (just like in a word processor).</source>
          <target state="translated">&lt;code&gt;werl&lt;/code&gt; 창 에서 텍스트를 선택하려면 마우스 왼쪽 버튼을 누른 채 마우스를 선택하려는 텍스트 위로 드래그하십시오. 선택 영역이 선 경계를 넘는 경우 선택한 텍스트는 해당되는 경우 완전한 선으로 구성됩니다 (워드 프로세서에서와 ​​같이).</target>
        </trans-unit>
        <trans-unit id="baa709b93b3829a0df77188d6fd0ef0592956e57" translate="yes" xml:space="preserve">
          <source>To separate the first elements of the list from the rest of the list, &lt;code&gt;|&lt;/code&gt; is used. &lt;code&gt;First&lt;/code&gt; has got value 1 and &lt;code&gt;TheRest&lt;/code&gt; has got the value [2,3,4,5].</source>
          <target state="translated">목록의 첫 번째 요소를 나머지 목록과 분리하려면 &lt;code&gt;|&lt;/code&gt; 사용. &lt;code&gt;First&lt;/code&gt; 값은 1이고 &lt;code&gt;TheRest&lt;/code&gt; 는 [2,3,4,5]입니다.</target>
        </trans-unit>
        <trans-unit id="c01449dac6b2c1e79ac6f7a80fed6fdc43f67423" translate="yes" xml:space="preserve">
          <source>To set the default handler, that starts initially with the Kernel application, to log to file instead of &lt;code&gt;standard_io&lt;/code&gt;, change the Kernel default logger configuration. Example:</source>
          <target state="translated">커널 응용 프로그램으로 처음 시작하는 기본 핸들러를 &lt;code&gt;standard_io&lt;/code&gt; 대신 파일에 로그하도록 설정하려면 커널 기본 로거 구성을 변경하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="f3ccaabc6c6c384fa4607146b378de54d2e651c3" translate="yes" xml:space="preserve">
          <source>To set the time warp mode, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 왜곡 모드를 설정하려면 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0688ed50c18775a5b27e32c9d7ee33f891bdef" translate="yes" xml:space="preserve">
          <source>To set up Erlang distribution over TLS:</source>
          <target state="translated">TLS를 통한 Erlang 배포를 설정하려면</target>
        </trans-unit>
        <trans-unit id="d2cce9d630a9f1b9f9af96de1b5c45472cb5cc3c" translate="yes" xml:space="preserve">
          <source>To set up client/server connections:</source>
          <target state="translated">클라이언트 / 서버 연결을 설정하려면</target>
        </trans-unit>
        <trans-unit id="b43c85b2017cddcd0eeca4a7ee756681a2b5279f" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a UNIX systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt; in the your home directory.</source>
          <target state="translated">UNIX 시스템에서 Erlang Emacs 모드를 설정하려면 홈 디렉토리에서 &lt;code&gt;.emacs&lt;/code&gt; 파일을 편집 / 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="17525f3111c9dc221811cc59d7953bea94c55a6a" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a Windows systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt;, the location of the file depends on the configuration of the system. If the &lt;strong&gt;HOME&lt;/strong&gt; environment variable is set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in the directory indicated by the &lt;strong&gt;HOME&lt;/strong&gt; variable. If &lt;strong&gt;HOME&lt;/strong&gt; is not set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in &lt;code&gt;C:\&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템에서 Erlang Emacs 모드를 설정하려면 파일 &lt;code&gt;.emacs&lt;/code&gt; 를 편집 / 작성하십시오. 파일 의 위치는 시스템 구성에 따라 다릅니다. 는 IF &lt;strong&gt;홈페이지&lt;/strong&gt; 환경 변수가 설정되어, 이맥스는 찾습니다 &lt;code&gt;.emacs&lt;/code&gt; 디렉토리에 의해 표시에 파일 &lt;strong&gt;홈페이지&lt;/strong&gt; 변수입니다. 경우 &lt;strong&gt;홈페이지가&lt;/strong&gt; 설정되어 있지 않은, 이맥스는 찾습니다 &lt;code&gt;.emacs&lt;/code&gt; 에서 파일을 &lt;code&gt;C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3c1a4e5864dbab572e9a5afb37792b236ea4a2" translate="yes" xml:space="preserve">
          <source>To simplify driver replacement, avoid designing your system so that more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has the driver loaded.</source>
          <target state="translated">드라이버 교체를 단순화하려면 둘 이상의 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드 하도록 시스템을 설계하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6657bbbea9ee8b248ced80c3f983940e0a515151" translate="yes" xml:space="preserve">
          <source>To simulate a busy server, you can insert a delay between when &lt;code&gt;epmd&lt;/code&gt; gets notified that a new connection is requested and when the connection gets accepted.</source>
          <target state="translated">사용중인 서버를 시뮬레이트하기 위해 &lt;code&gt;epmd&lt;/code&gt; 에 새 연결이 요청되었다는 알림과 연결이 허용 되는 시점 사이에 지연을 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70ce8a79d8ffb4771e6a29808f1bcbc9c8b69320" translate="yes" xml:space="preserve">
          <source>To specify if the &lt;code&gt;cover&lt;/code&gt; tool is to be stopped after the test is completed (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">테스트가 완료된 후 &lt;code&gt;cover&lt;/code&gt; 도구를 중지 할지 여부를 지정하려면 ( &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f982d3b08151a090766a53c8ae58a0af1c7b2c36" translate="yes" xml:space="preserve">
          <source>To specify in which order groups are to be executed (also with respect to test cases that are not part of any group), add tuples on the form &lt;code&gt;{group,GroupName}&lt;/code&gt; to the &lt;code&gt;all/0&lt;/code&gt; list.</source>
          <target state="translated">차 단체 (또한 임의의 그룹의 일부가 아닌 테스트 케이스에 대해) 실행되어야하는 지정하려면 폼에 추가 튜플 &lt;code&gt;{group,GroupName}&lt;/code&gt; 받는 &lt;code&gt;all/0&lt;/code&gt; 목록.</target>
        </trans-unit>
        <trans-unit id="1db9eb6998e57480fd022b5b675c80cbbd9dce31" translate="yes" xml:space="preserve">
          <source>To specify starting line for scanning in document which contains fragments of XML.</source>
          <target state="translated">XML 조각이 포함 된 문서에서 스캔을위한 시작 줄을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f61119c7e1b2cdde6ff6d2fa7c86881726228a8c" translate="yes" xml:space="preserve">
          <source>To specify the modules to be included in the code coverage test, provide a cover specification file. With this file you can point out specific modules or specify directories containing modules to be included in the analysis. You can also specify modules to be excluded from the analysis.</source>
          <target state="translated">코드 커버리지 테스트에 포함될 모듈을 지정하려면 커버 스펙 파일을 제공하십시오. 이 파일을 사용하면 특정 모듈을 지정하거나 분석에 포함 할 모듈이 포함 된 디렉토리를 지정할 수 있습니다. 분석에서 제외 할 모듈을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e24433e118f3675a94b0839832059d75700c72" translate="yes" xml:space="preserve">
          <source>To specify which PLT, use option &lt;code&gt;--plt&lt;/code&gt;.</source>
          <target state="translated">어떤 PLT를 지정하려면 &lt;code&gt;--plt&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18d24b6fe052b97ca4a3faae65960b6ff118b488" translate="yes" xml:space="preserve">
          <source>To speed up the execution of &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt;, first call &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt;, using option &lt;code&gt;purge&lt;/code&gt;. This does the same check for old code. Then purges all modules that can be soft-purged. The purged modules do then no longer have any old code, and &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; does not need to do the checks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 의 실행 속도를 높이려면 먼저 &lt;code&gt;purge&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt; 를 호출 하십시오 . 이전 코드와 동일한 검사를 수행합니다. 그런 다음 소프트 퍼지 할 수있는 모든 모듈을 제거합니다. 제거 된 모듈에는 더 이상 이전 코드 가 없으므로 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 는 점검 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="881ed36f05e94ae0a21c8004b304eb3bc37646d6" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first message in a sequence.</source>
          <target state="translated">순차적 추적을 시작하려면 첫 번째 메시지를 순서대로 보내는 프로세스에서 추적 토큰을 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76f1852c3add5606a83bf5fb3f21588a546c38d4" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 노드에서 유사한 추적 프로그램을 시작하려면 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="af5676be701d6ebffdcd18fcceb076e666de274b" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 노드에서 유사한 추적 프로그램을 시작하려면 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="069df5419adf0afb2c7538e01048c5b636cbd10a" translate="yes" xml:space="preserve">
          <source>To start all applications specified in the original &lt;code&gt;mysystem.rel&lt;/code&gt; file, use flag &lt;code&gt;-boot&lt;/code&gt; as follows:</source>
          <target state="translated">원래 &lt;code&gt;mysystem.rel&lt;/code&gt; 파일에 지정된 모든 응용 프로그램을 시작하려면 다음과 같이 플래그 &lt;code&gt;-boot&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6430f32849bacfbbbfdd73794b90f8a5cb5633c" translate="yes" xml:space="preserve">
          <source>To start an &lt;strong&gt;embedded target system&lt;/strong&gt;, the shell script &lt;code&gt;bin/start&lt;/code&gt; is used. The script calls &lt;code&gt;bin/run_erl&lt;/code&gt;, which in turn calls &lt;code&gt;bin/start_erl&lt;/code&gt; (roughly, &lt;code&gt;start_erl&lt;/code&gt; is an embedded variant of &lt;code&gt;erl&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;임베디드 대상 시스템&lt;/strong&gt; 을 시작하려면 쉘 스크립트 &lt;code&gt;bin/start&lt;/code&gt; 가 사용됩니다. 이 스크립트는 &lt;code&gt;bin/run_erl&lt;/code&gt; 을 호출하고 차례로 &lt;code&gt;bin/start_erl&lt;/code&gt; 을 호출합니다 (대개 &lt;code&gt;start_erl&lt;/code&gt; 은 &lt;code&gt;erl&lt;/code&gt; 의 내장 변형입니다 ).</target>
        </trans-unit>
        <trans-unit id="9d22fc7b6b61af9ef2d6145dba2c1c36bbe3774d" translate="yes" xml:space="preserve">
          <source>To start an event manager for handling errors, as described in the previous example, call the following function:</source>
          <target state="translated">이전 예에서 설명한대로 오류 처리를 위해 이벤트 관리자를 시작하려면 다음 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="65443b4fc91dab6b76dab71d1d80de342db77ebd" translate="yes" xml:space="preserve">
          <source>To start the &lt;code&gt;Company&lt;/code&gt; database and get it running on the two specified nodes, enter the following commands:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스 를 시작하고 지정된 두 노드에서 실행하려면 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b812e0ece5117a4dc75569139c24b19927c8e4d0" translate="yes" xml:space="preserve">
          <source>To start the debug enabled runtime system execute:</source>
          <target state="translated">디버그 가능 런타임 시스템을 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7fffc54b92267ef311f536c196ba13936bd59530" translate="yes" xml:space="preserve">
          <source>To start the interactive shell mode, start an Erlang shell manually and call &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; to install any configuration data you might need (use &lt;code&gt;[]&lt;/code&gt; as argument otherwise). Then call &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">대화식 쉘 모드를 시작하려면 Erlang 쉘을 수동으로 시작하고 &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 필요한 구성 데이터를 설치하십시오 ( 그렇지 않으면 &lt;code&gt;[]&lt;/code&gt; 를 인수로 사용하십시오 ). 그런 다음 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 을 호출 하여 &lt;code&gt;Common Test&lt;/code&gt; 를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="2407e72a3ed0dce989e1ddb620f5b91d6fb2b5a8" translate="yes" xml:space="preserve">
          <source>To start, open a registry:</source>
          <target state="translated">시작하려면 레지스트리를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="37329084650848867e8284198738d0867fe2834a" translate="yes" xml:space="preserve">
          <source>To stop Erlang Top, use function &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang Top을 중지하려면 &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0a960f069bc98edbba1ff0928e02093c32ffad4" translate="yes" xml:space="preserve">
          <source>To stop a distributed application, &lt;code&gt;stop/1&lt;/code&gt; must be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to &lt;code&gt;stop/1&lt;/code&gt; on the node where the application currently executes stops its execution. The application is not moved between nodes, as &lt;code&gt;stop/1&lt;/code&gt; is called on the node where the application currently executes before &lt;code&gt;stop/1&lt;/code&gt; is called on the other nodes.</source>
          <target state="translated">분산 응용 프로그램을 중지하려면 실행할 수있는 모든 노드 (즉, 시작된 모든 노드)에서 &lt;code&gt;stop/1&lt;/code&gt; 을 호출해야합니다. 애플리케이션이 현재 실행중인 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 을 호출하면 실행이 중지됩니다. 다른 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 이 호출 되기 전에 현재 응용 프로그램이 실행되는 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 이 호출 되므로 응용 프로그램이 노드간에 이동되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b81bcf2bbed22c8b9d584525dc2bbe3c5752e21" translate="yes" xml:space="preserve">
          <source>To stop one or more tests, use function &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (to stop all) or &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 테스트를 중지하려면 함수 &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (모두 중지) 또는 &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c55a13290a9e7e9fdbffa7dec308f34e8baa6" translate="yes" xml:space="preserve">
          <source>To stop the Erlang emulator, close the &lt;code&gt;werl&lt;/code&gt; window.</source>
          <target state="translated">Erlang 에뮬레이터를 중지하려면 &lt;code&gt;werl&lt;/code&gt; 창을 닫으십시오 .</target>
        </trans-unit>
        <trans-unit id="805a085d9254eb5937e5f4dd565453dd8d6af7f9" translate="yes" xml:space="preserve">
          <source>To sum up this section: &lt;strong&gt;Do not use &lt;code&gt;erlang:now/0&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">이 섹션을 요약하면 : &lt;strong&gt; &lt;code&gt;erlang:now/0&lt;/code&gt; 을&lt;/strong&gt;&lt;strong&gt; 사용하지 마십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4c3f23c8b7d11fd791f43a0f06c76ab501c60d6" translate="yes" xml:space="preserve">
          <source>To summarize, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; only needs to create &lt;strong&gt;one&lt;/strong&gt; match context and no sub binaries.</source>
          <target state="translated">요약하면, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 은 &lt;strong&gt;하나의&lt;/strong&gt; 일치 컨텍스트 만 작성 하고 하위 바이너리는 작성 하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="76f6d1c7fd98a557f9e7456fd478d01cb713b47b" translate="yes" xml:space="preserve">
          <source>To support Unicode in Erlang, problems in various areas have been addressed. This section describes each area briefly and more thoroughly later in this User's Guide.</source>
          <target state="translated">Erlang에서 유니 코드를 지원하기 위해 다양한 영역의 문제가 해결되었습니다. 이 섹션에서는이 사용 설명서 뒷부분에서 각 영역에 대해 간략하고 자세하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="490eb8f14b00a3993b65db4b76111ea78b82422f" translate="yes" xml:space="preserve">
          <source>To support the debug facilites in &lt;code&gt;sys&lt;/code&gt;, a &lt;strong&gt;debug structure&lt;/strong&gt; is needed. The &lt;code&gt;Deb&lt;/code&gt; term is initialized using &lt;code&gt;sys:debug_options/1&lt;/code&gt;:</source>
          <target state="translated">에서 디버그 부대 시설 지원하기 위해 &lt;code&gt;sys&lt;/code&gt; 하는 &lt;strong&gt;디버그 구조가&lt;/strong&gt; 필요하다. &lt;code&gt;Deb&lt;/code&gt; 용어는 사용하여 초기화 &lt;code&gt;sys:debug_options/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27cb03280676d8f91c2c5f4617f6dcad84db1918" translate="yes" xml:space="preserve">
          <source>To take Erlang down gracefully, see the &lt;code&gt;erl_call(1)&lt;/code&gt; manual page in &lt;code&gt;erl_interface&lt;/code&gt; for details on the use of &lt;code&gt;erl_call&lt;/code&gt;. However, that requires that Erlang runs as a distributed node, which is not always the case.</source>
          <target state="translated">우아하게 얼랑을 촬영하려면 참조 &lt;code&gt;erl_call(1)&lt;/code&gt; 의 매뉴얼 페이지 &lt;code&gt;erl_interface&lt;/code&gt; 의 사용에 대한 자세한 내용은 &lt;code&gt;erl_call&lt;/code&gt; 을 . 그러나 Erlang을 분산 노드로 실행해야하지만 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="794cd63b456b29e5f25c1b3a3a1a7cadacb90ffd" translate="yes" xml:space="preserve">
          <source>To test the distribution, the &lt;code&gt;net_kernel:start/1&lt;/code&gt; function can be used. It is useful, as it starts the distribution on a running system, where tracing/debugging can be performed. The &lt;code&gt;net_kernel:start/1&lt;/code&gt; routine takes a list as its single argument. The list first element in the list is to be the node name (without the &quot;@hostname&quot;) as an atom. The second (and last) element is to be one of the atoms &lt;code&gt;shortnames&lt;/code&gt; or &lt;code&gt;longnames&lt;/code&gt;. In the example case, &lt;code&gt;shortnames&lt;/code&gt; is preferred.</source>
          <target state="translated">분배를 테스트하기 위해 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 기능을 사용할 수 있습니다. 추적 / 디버깅을 수행 할 수있는 실행중인 시스템에서 배포를 시작하므로 유용합니다. &lt;code&gt;net_kernel:start/1&lt;/code&gt; 루틴은 단일 인수로 목록을합니다. 목록에서 목록의 첫 번째 요소는 &quot;@hostname&quot;없이 노드 이름이 아톰 인 것입니다. 두 번째 (및 마지막) 요소는 원자의 &lt;code&gt;shortnames&lt;/code&gt; 또는 &lt;code&gt;longnames&lt;/code&gt; 중 하나입니다 . 이 예에서는 &lt;code&gt;shortnames&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="1e25ada887f1b7f960ffeb09cb03b19c929e33ba" translate="yes" xml:space="preserve">
          <source>To the extent that it's practical, support SystemTap on Linux via DTrace provider compatibility.</source>
          <target state="translated">가능한 한 DTrace 제공자 호환성을 통해 Linux에서 SystemTap을 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="fded3aabb510b1e1a75f760a53342f304a3c739e" translate="yes" xml:space="preserve">
          <source>To to start the application (agent and/or manager), the configuration files must be modified and there are two ways of doing this. Either edit the files manually, or run the configuration tool as follows.</source>
          <target state="translated">응용 프로그램 (에이전트 및 / 또는 관리자)을 시작하려면 구성 파일을 수정해야하며 두 가지 방법이 있습니다. 파일을 수동으로 편집하거나 다음과 같이 구성 도구를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="840859542432e2ae9a768d1a2567eb03227d2acc" translate="yes" xml:space="preserve">
          <source>To trace function calls, you also need to set up &lt;strong&gt;trace patterns&lt;/strong&gt;. Trace patterns select the function calls to be traced. The number of traced function calls can be further reduced with &lt;strong&gt;match specifications&lt;/strong&gt;. Match specifications can also be used to trigger more information in the trace messages.</source>
          <target state="translated">함수 호출을 추적하려면 추적 &lt;strong&gt;패턴도&lt;/strong&gt; 설정해야 &lt;strong&gt;합니다&lt;/strong&gt; . 추적 패턴은 추적 할 함수 호출을 선택합니다. &lt;strong&gt;일치 스펙&lt;/strong&gt; 으로 추적 된 함수 호출 수를 추가로 줄일 수 있습니다 . 일치 스펙을 사용하여 추적 메시지에서 추가 정보를 트리거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c07cb7f2e8d2563df9d5fc9199e90556dc33e70" translate="yes" xml:space="preserve">
          <source>To trigger file compression, its extension must match with the &lt;code&gt;compress&lt;/code&gt; condition and must not match the &lt;code&gt;uncompress&lt;/code&gt; condition. For example, if &lt;code&gt;compress&lt;/code&gt; is set to &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; is set to &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt;, only files with extension &lt;code&gt;&quot;gif&quot;&lt;/code&gt; are compressed.</source>
          <target state="translated">파일 압축을 트리거하려면 확장자가 &lt;code&gt;compress&lt;/code&gt; 조건과 일치해야하며 &lt;code&gt;uncompress&lt;/code&gt; 조건 과 일치하지 않아야합니다 . 예를 들어, &lt;code&gt;compress&lt;/code&gt; 가 &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; 로 설정 되고 &lt;code&gt;uncompress&lt;/code&gt; 가 &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt; 로 설정 되면 확장자가 &lt;code&gt;&quot;gif&quot;&lt;/code&gt; 인 파일 만 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcf647abab37b8b3f8542efaeba10430ea6f745" translate="yes" xml:space="preserve">
          <source>To turn off the Debugger stack trace facility, select option &lt;strong&gt;Stack Off&lt;/strong&gt;.</source>
          <target state="translated">디버거 스택 추적 기능을 끄려면 &lt;strong&gt;스택 끄기&lt;/strong&gt; 옵션을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="25889e4ee1555771488e4d2de1a7bf2d51b5a3ab" translate="yes" xml:space="preserve">
          <source>To turn off warnings for improper lists, add the following line to the source file:</source>
          <target state="translated">부적절한 목록에 대한 경고를 끄려면 소스 파일에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8ed98f94cb168a3368774c5de90ad9aac72676b6" translate="yes" xml:space="preserve">
          <source>To understand the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup, it is essential to understand how &lt;code&gt;Mnesia&lt;/code&gt; reacts when it loses contact with &lt;code&gt;Mnesia&lt;/code&gt; on another node. At this stage, &lt;code&gt;Mnesia&lt;/code&gt; cannot distinguish between a communication failure and a &quot;normal&quot; node-down. When this occurs, &lt;code&gt;Mnesia&lt;/code&gt; assumes that the other node is no longer running, whereas, in reality, the communication between the nodes has failed.</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 의 동작을 이해하려면 다른 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 와의 연결이 끊어진 경우 &lt;code&gt;Mnesia&lt;/code&gt; 가 어떻게 반응 하는지 이해해야합니다 . 이 단계에서 &lt;code&gt;Mnesia&lt;/code&gt; 는 통신 장애와 &quot;정상&quot;노드 다운을 구별 할 수 없습니다. 이러한 상황이 발생하면 &lt;code&gt;Mnesia&lt;/code&gt; 는 다른 노드가 더 이상 실행되고 있지 않다고 가정하지만 실제로는 노드 간 통신이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="57ca1753f443dcffddf87cab0a01f1c5e59426d5" translate="yes" xml:space="preserve">
          <source>To understand this text, you also have to look at the &lt;code&gt;yacc&lt;/code&gt; documentation in the UNIX(TM) manual. This is most probably necessary in order to understand the idea of a parser generator, and the principle and problems of LALR parsing with finite look-ahead.</source>
          <target state="translated">이 텍스트를 이해하려면 UNIX (TM) 매뉴얼 의 &lt;code&gt;yacc&lt;/code&gt; 문서 를 봐야합니다 . 이것은 아마도 파서 생성기의 아이디어와 유한 미리보기로 LALR 파싱의 원리와 문제점을 이해하기 위해 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="257c2b917b12b68949e96a87bad80aa179cede62" translate="yes" xml:space="preserve">
          <source>To understand what is discussed and examplified here, we recommended you to first read section &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 논의하고 시험 한 내용을 이해하려면 먼저 &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 섹션을 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a0d1537131067c43e7df0631cf8f01ef0dfa991f" translate="yes" xml:space="preserve">
          <source>To unregister a name:</source>
          <target state="translated">이름을 등록 취소하려면</target>
        </trans-unit>
        <trans-unit id="2d2a671d4b2f16d7f91c51ff47e2d4c92fb46607" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">게시 한 노드를 등록 해제하려면 &lt;code&gt;ei_publish()&lt;/code&gt; 에서 반환 한 설명자를 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c7fc1b435a8defaf215479b11edd52150783be" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should instead close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">게시 한 노드를 등록 해제하려면 대신 &lt;code&gt;ei_publish()&lt;/code&gt; 에서 반환 한 설명자를 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b518c28463d854508111ea65fca22a57c4c2cf2" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor.</source>
          <target state="translated">EPMD에 등록을 취소하려면 반환 된 설명자를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="769d2fa177fb9e7db683f9606bab6d12279b1eda" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor. Do not use &lt;code&gt;ei_unpublish()&lt;/code&gt;, which is deprecated anyway.</source>
          <target state="translated">EPMD에 등록을 취소하려면 반환 된 설명자를 닫으십시오. 더 이상 사용되지 않는 &lt;code&gt;ei_unpublish()&lt;/code&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="84b4679c04fbfbaa9588413bb040c5640c41eacc" translate="yes" xml:space="preserve">
          <source>To upgrade &lt;code&gt;ch_app&lt;/code&gt; from &lt;code&gt;&quot;1&quot;&lt;/code&gt; to &lt;code&gt;&quot;2&quot;&lt;/code&gt; (and to downgrade from &lt;code&gt;&quot;2&quot;&lt;/code&gt; to &lt;code&gt;&quot;1&quot;&lt;/code&gt;), you only need to load the new (old) version of the &lt;code&gt;ch3&lt;/code&gt; callback module. Create the application upgrade file &lt;code&gt;ch_app.appup&lt;/code&gt; in the &lt;code&gt;ebin&lt;/code&gt; directory:</source>
          <target state="translated">업그레이드하려면 &lt;code&gt;ch_app&lt;/code&gt; 에서 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 을 &lt;code&gt;&quot;2&quot;&lt;/code&gt; (과에서의 다운 그레이드에 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ), 당신은 단지 새로운 (구) 버전로드 할 필요 &lt;code&gt;ch3&lt;/code&gt; 콜백 모듈을. &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 애플리케이션 업그레이드 파일 &lt;code&gt;ch_app.appup&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f84bf7f2f7861b776ed5c35e1c7e32583ad5a627" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to an SSL connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">TCP / IP 연결을 SSL 연결로 업그레이드하려면 클라이언트와 서버가 동의해야합니다. 계약은 프로토콜 (예 : RFC 2817에 지정된 HTTP에서 사용 된 프로토콜)을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a48c54fe1c18b840875cc0d8882a5c73ce80e02" translate="yes" xml:space="preserve">
          <source>To upgrade to an SSL connection:</source>
          <target state="translated">SSL 연결로 업그레이드하려면</target>
        </trans-unit>
        <trans-unit id="ea7b425544bac4acf2d4b893b416d117aa7a59a1" translate="yes" xml:space="preserve">
          <source>To use Debugger, the basic steps are as follows:</source>
          <target state="translated">디버거를 사용하기위한 기본 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68fe3f1ab7b67db6b1b7b0c723fb8ab99d7ba09b" translate="yes" xml:space="preserve">
          <source>To use a literal &lt;code&gt;*&lt;/code&gt; character as &lt;code&gt;Pad&lt;/code&gt;, it must be passed as an argument:</source>
          <target state="translated">리터럴 &lt;code&gt;*&lt;/code&gt; 문자를 &lt;code&gt;Pad&lt;/code&gt; 로 사용하려면 인수로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfffbe9810584067e7d160ff8bce5770cf34f906" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following lines in your code:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 함수 를 사용하려면 코드에 다음 줄을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="e865188bf7a27ada82ac1699872c1f2decf0665c" translate="yes" xml:space="preserve">
          <source>To use encrypted debug information, a key must be provided to the compiler and &lt;code&gt;beam_lib&lt;/code&gt;. The key is specified as a string. It is recommended that the string contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used.</source>
          <target state="translated">암호화 된 디버그 정보를 사용하려면 컴파일러와 &lt;code&gt;beam_lib&lt;/code&gt; 에 키를 제공해야합니다 . 키는 문자열로 지정됩니다. 문자열은 32 자 이상이어야하며 숫자와 특수 문자뿐만 아니라 대문자와 소문자를 모두 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb23e34638bd9093d10ee97bb3a0e372512e3fc8" translate="yes" xml:space="preserve">
          <source>To use event handlers written for &lt;code&gt;error_logger&lt;/code&gt;, just add your event handler with</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 용으로 작성된 이벤트 핸들러를 사용하려면 다음 과 같이 이벤트 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0bdc7b110d3152a509f4766a597abefcfa1ed87d" translate="yes" xml:space="preserve">
          <source>To use the Erlang shell to run our test, you can evaluate the following call:</source>
          <target state="translated">Erlang 셸을 사용하여 테스트를 실행하려면 다음 호출을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4462aadd9025ab266be32a2032bf299d0b46f7" translate="yes" xml:space="preserve">
          <source>To use the disk_log handler instead of the default standard handler when starting an Erlang node, change the Kernel default logger to use &lt;code&gt;logger_disk_log_h&lt;/code&gt;. Example:</source>
          <target state="translated">얼랑 노드를 시작할 때 기본 표준 핸들러 대신 disk_log 핸들러를 사용하려면 사용에 대한 커널의 기본 로거 변경 &lt;code&gt;logger_disk_log_h&lt;/code&gt; 을 . 예:</target>
        </trans-unit>
        <trans-unit id="48d471ac0f461634b1a46f1744c359ab442ae3b1" translate="yes" xml:space="preserve">
          <source>To use the functions &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;release_shell&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기능을 사용하려면 &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;release_shell&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d698f2ffb5c429ffda0ac4557a52f1824b92cf1d" translate="yes" xml:space="preserve">
          <source>To use the pseudo functions triggering the translation, ensure to include the header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code. Failure to do so possibly results in runtime errors rather than compile time, as the expression can be valid as a plain Erlang program without translation.</source>
          <target state="translated">변환을 트리거하는 의사 함수를 사용하려면 소스 코드에 헤더 파일 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 을 포함시켜야합니다 . 그렇지 않으면 표현식이 변환없이 일반 Erlang 프로그램으로 유효 할 수 있으므로 컴파일 시간이 아닌 런타임 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f67b62fca597162026995f6815a18764fa1055" translate="yes" xml:space="preserve">
          <source>To use the real implementation, we must recompile the MIB and load it into the agent.</source>
          <target state="translated">실제 구현을 사용하려면 MIB를 다시 컴파일하여 에이전트에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="002952436d64ac58aa3de156b66387b85dc58e15" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">동적으로로드 된 코드에있는 드라이버를 추가하기 위해이 기능을 사용하는 것은 위험합니다. 추가 된 드라이버의 드라이버 코드가 동적으로로드 된 일반 드라이버 ( &lt;code&gt;erl_ddll&lt;/code&gt; 인터페이스로 로드 됨)와 동일한 동적으로로드 된 모듈 (즉, &lt;code&gt;.so&lt;/code&gt; 파일)에있는 경우 호출자는 드라이버 항목을 추가하기 전에 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="06c29935ed139b37075ecc2db062cd1dfb073f59" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute in both phases is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모드를 사용하려면 두 단계에서 실행될 모든 Erlang 코드가 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="af48a71f55d5ffa8ab787fda3994e5f52dec889c" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute on the runtime system is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모드를 사용하려면 런타임 시스템에서 실행될 모든 Erlang 코드가 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="847b164165eea8a7ac372dcfbedc4f6fbc9d1539" translate="yes" xml:space="preserve">
          <source>To use this program, you need to:</source>
          <target state="translated">이 프로그램을 사용하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a7e1aba43c701aa62b9243d847578c39295abed" translate="yes" xml:space="preserve">
          <source>To use this with threads and asynchronous routines, create a pipe on Unix and an &lt;code&gt;Event&lt;/code&gt; on Windows. When the routine completes, write to the pipe (use &lt;code&gt;SetEvent&lt;/code&gt; on Windows), this makes the emulator call &lt;code&gt;ready_input&lt;/code&gt; or &lt;code&gt;ready_output&lt;/code&gt;.</source>
          <target state="translated">이것을 스레드 및 비동기 루틴과 함께 사용하려면 Unix에서 파이프를 작성하고 Windows 에서 &lt;code&gt;Event&lt;/code&gt; 를 작성하십시오. 루틴이 완료되면 파이프에 기록 ( Windows에서 &lt;code&gt;SetEvent&lt;/code&gt; 사용 )하면 에뮬레이터가 &lt;code&gt;ready_input&lt;/code&gt; 또는 &lt;code&gt;ready_output&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="01b8773f5a669a11ac026442b354c5f873c02791" translate="yes" xml:space="preserve">
          <source>To validate the configuration strings, the callback module is to have function &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; exported.</source>
          <target state="translated">구성 문자열의 유효성을 검사하기 위해 콜백 모듈은 &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; 함수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="fe32e508b386431ed270d6f4036397947cfdf797" translate="yes" xml:space="preserve">
          <source>To verify that everything is ok you should open &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; in your web browser and make sure that there are zero failed test cases.</source>
          <target state="translated">모든 것이 &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; 확인하려면 웹 브라우저에서 $ ERL_TOP / release / tests / test_server / index.html 을 열고 실패한 테스트 사례가 없는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="816f7f291832fe5da7fded15c95dc5548b14b744" translate="yes" xml:space="preserve">
          <source>To verify that lock counting is enabled check that &lt;code&gt;[lock-counting]&lt;/code&gt; appears in the status text when the VM is started.</source>
          <target state="translated">잠금 계산이 활성화되어 있는지 확인 하려면 VM이 시작될 때 상태 텍스트에 &lt;code&gt;[lock-counting]&lt;/code&gt; 이 나타나는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79825059ed41d40f1eb38140584c29e49d43c05" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific module, double- click the row, or right-click it and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">특정 모듈에 대한 자세한 정보를 보려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;mod&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3ee7cdc20eb34f07a508b3dffa9cad2da375fa2" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific process, double- click the row in the list, or right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">특정 프로세스에 대한 자세한 정보를 보려면 목록에서 행을 두 번 클릭하거나 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9a2be366e30f8af91ea3157c65f941baf52859b" translate="yes" xml:space="preserve">
          <source>To view more details about a specific port, double-click the row or right-click it and select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;, where &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; is the process connected to the port.</source>
          <target state="translated">특정 포트에 대한 자세한 내용을 보려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;port&amp;gt;의 속성을&lt;/strong&gt; 선택하십시오 . 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;&amp;lt;pid&amp;gt; 속성을&lt;/strong&gt; 선택할 수도 있습니다 . 여기서 &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; 는 포트에 연결된 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="7c537dc716e918cf2d036be1a35d64af3e41081c" translate="yes" xml:space="preserve">
          <source>To view the result of a code coverage test, click the button labeled &quot;COVER LOG&quot; in the top-level index page for the test run.</source>
          <target state="translated">코드 적용 범위 테스트 결과를 보려면 테스트 실행을위한 최상위 인덱스 페이지에서 &quot;COVER LOG&quot;레이블이 지정된 단추를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="254465b8f25a6c97a3848f10e6162c3f124f7768" translate="yes" xml:space="preserve">
          <source>To view the result of macro expansion, a module can be compiled with the &lt;code&gt;'P'&lt;/code&gt; option. &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt;. This produces a listing of the parsed code after preprocessing and parse transforms, in the file &lt;code&gt;File.P&lt;/code&gt;.</source>
          <target state="translated">매크로 확장 결과를 보려면 &lt;code&gt;'P'&lt;/code&gt; 옵션을 사용하여 모듈을 컴파일 할 수 있습니다 . &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt; . 이렇게하면 &lt;code&gt;File.P&lt;/code&gt; 파일에서 사전 처리 및 구문 분석 변환 후 구문 분석 된 코드 목록이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2863e2789d755b777cac4c624de8395bb36a4b90" translate="yes" xml:space="preserve">
          <source>To visualize the structure of a syntax tree, you can use the function &lt;code&gt;merl:show(T)&lt;/code&gt;, which prints a summary. For example, entering</source>
          <target state="translated">구문 트리의 구조를 시각화하기 위해 &lt;code&gt;merl:show(T)&lt;/code&gt; 함수를 사용하면 요약을 인쇄 할 수 있습니다 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="420f383fbb828ef9ba78290b1722db9b09af55f0" translate="yes" xml:space="preserve">
          <source>To work with binaries in ISO Latin-1 encoding, use the &lt;code&gt;file&lt;/code&gt; module instead.</source>
          <target state="translated">ISO Latin-1 인코딩에서 이진 파일로 작업하려면 &lt;code&gt;file&lt;/code&gt; 모듈을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9368499385b79811c6e242f08579ba92f510e423" translate="yes" xml:space="preserve">
          <source>To write a function that inserts an employee record into the database, there must be an &lt;code&gt;at_dep&lt;/code&gt; record and a set of &lt;code&gt;in_proj&lt;/code&gt; records inserted. Examine the following code used to complete this action:</source>
          <target state="translated">직원 레코드를 데이터베이스에 삽입하는 함수를 작성하려면 &lt;code&gt;at_dep&lt;/code&gt; 레코드와 일련의 &lt;code&gt;in_proj&lt;/code&gt; 레코드가 삽입 되어 있어야 합니다. 이 조치를 완료하는 데 사용 된 다음 코드를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="870bc92e8fb7bb157e38a72767baac7170c3e8c4" translate="yes" xml:space="preserve">
          <source>To write functions that manipulate this data, remember the following:</source>
          <target state="translated">이 데이터를 조작하는 함수를 작성하려면 다음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="49f4806c44f9e994d710db8f38c6399e247bca8a" translate="yes" xml:space="preserve">
          <source>To write your own client channel handler, use the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt;. For server channel handlers use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; behaviour (replaces ssh_daemon_channel).</source>
          <target state="translated">고유 한 클라이언트 채널 핸들러를 작성하려면 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 동작을 사용하십시오 . 서버 채널 핸들러의 경우 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 동작을 사용하십시오 ( ssh_daemon_channel을 대체 함).</target>
        </trans-unit>
        <trans-unit id="f57b7cb4b41a526a6b5b1f9a162d27692ca9284c" translate="yes" xml:space="preserve">
          <source>Today there are no good ways of solving this problem and therefore the eval scheme can be removed in future release of &lt;code&gt;Inets&lt;/code&gt;.</source>
          <target state="translated">오늘날이 문제를 해결할 수있는 좋은 방법은 없으므로 향후 &lt;code&gt;Inets&lt;/code&gt; 릴리스에서 평가 체계를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7edb68e9d3675d0ca9b5133bc31d9005c2bc6f47" translate="yes" xml:space="preserve">
          <source>Too long external command.</source>
          <target state="translated">외부 명령이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="b53132babe55797aa27d88cc20db666d7ee40a5b" translate="yes" xml:space="preserve">
          <source>Tools that need to know about optional callback functions can call &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; to get a list of all optional callback functions.</source>
          <target state="translated">선택적 콜백 함수에 대해 알아야하는 도구는 &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; 를 호출하여 모든 선택적 콜백 함수 목록을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3a74b17c3a112fdfc9b4f6b58e1ba85a6ec96d" translate="yes" xml:space="preserve">
          <source>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by &lt;code&gt;malloc&lt;/code&gt; when &lt;code&gt;sbrk&lt;/code&gt; is called to get more memory from the operating system. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">상단 패드 크기 (KB). 운영 체제에서 더 많은 메모리를 얻기 위해 &lt;code&gt;sbrk&lt;/code&gt; 가 호출 될 때 &lt;code&gt;malloc&lt;/code&gt; 에 의해 할당되는 추가 메모리의 양입니다 . 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8688b9f02fc264d86ffee1ffffdff34e5d5032b9" translate="yes" xml:space="preserve">
          <source>Total amount of data allocated by an Erlang node</source>
          <target state="translated">Erlang 노드가 할당 한 총 데이터 양</target>
        </trans-unit>
        <trans-unit id="15b379311d06275e570d3c8276f0c74ac315b01b" translate="yes" xml:space="preserve">
          <source>Total and own</source>
          <target state="translated">총 소유</target>
        </trans-unit>
        <trans-unit id="c2270f01832f95299124e422ec6e4ca5b86124d0" translate="yes" xml:space="preserve">
          <source>Total memory of all fragments</source>
          <target state="translated">모든 조각의 총 메모리</target>
        </trans-unit>
        <trans-unit id="7e54e8f9975c397f222301a7b10e36746a3fb103" translate="yes" xml:space="preserve">
          <source>Total scheduler utilization will equal &lt;code&gt;1.0&lt;/code&gt; when all schedulers have been active all the time between the two measurements.</source>
          <target state="translated">두 스케줄 사이에서 모든 스케줄러가 항상 활성화 된 경우 총 스케줄러 사용량은 &lt;code&gt;1.0&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="75f139724c9414120075277ba75a5a2d7bac69ee" translate="yes" xml:space="preserve">
          <source>Total size of all fragments</source>
          <target state="translated">모든 조각의 총 크기</target>
        </trans-unit>
        <trans-unit id="3d7796a77f0c2216ea352ac72490e4ec4449ab38" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers, weighted against maximum amount of available CPU time.</source>
          <target state="translated">사용 가능한 최대 CPU 시간에 가중치를 둔 모든 정상 및 더티 CPU 스케줄러의 총 이용률.</target>
        </trans-unit>
        <trans-unit id="6da5bac4a207bc853f48fee09219f38e35859ae6" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers.</source>
          <target state="translated">모든 정상 및 더티 CPU 스케줄러의 전체 이용률.</target>
        </trans-unit>
        <trans-unit id="9bff8a7fc7360671cf907e56ce21842e96c20fad" translate="yes" xml:space="preserve">
          <source>TotalRunQueueLengths</source>
          <target state="translated">TotalRunQueueLengths</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="80bb48f4677c815e975d8c45891c82e4681bcb89" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder</source>
          <target state="translated">트레이스 툴 빌더</target>
        </trans-unit>
        <trans-unit id="250a4f0c0db1541060f17b5d70ba72e38869d686" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder is a base for building trace tools for single node or distributed Erlang systems. It requires the Runtime_Tools application to be available on the traced node.</source>
          <target state="translated">Trace Tool Builder는 단일 노드 또는 분산 Erlang 시스템을위한 추적 도구를 빌드하기위한 기반입니다. 추적 된 노드에서 Runtime_Tools 애플리케이션을 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e39bcc8d71bbaa0fa6b28e8699f8f1993f5c4d" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;arity&lt;/code&gt; can be used to change the contents of this message, so that &lt;code&gt;Arity&lt;/code&gt; is specified instead of &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 대신 &lt;code&gt;Arity&lt;/code&gt; 가 지정 되도록 추적 플래그 &lt;code&gt;arity&lt;/code&gt; 를 사용하여이 메시지의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2211485216352092a3c7b3ce77ba8fdb799ae23c" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;call&lt;/code&gt; is set on all processes. This means that any function activated with command &lt;code&gt;trc/1&lt;/code&gt; is traced on all existing and new processes.</source>
          <target state="translated">추적 플래그 &lt;code&gt;call&lt;/code&gt; 은 모든 프로세스에서 설정됩니다. 이는 &lt;code&gt;trc/1&lt;/code&gt; 명령으로 활성화 된 기능이 모든 기존 프로세스와 새 프로세스에서 추적 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0712efc6140a7fd34097a10dbcb83e8a2711b2c0" translate="yes" xml:space="preserve">
          <source>Trace garbage collection on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; that prints start, stop, and the time spent for each garbage collection.</source>
          <target state="translated">지정된 프로세스에서 가비지 콜렉션을 추적하십시오. 사용되는 형식 핸들러는 &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; 이며 시작, 중지 및 각 가비지 콜렉션에 소요 된 시간을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8ad201247194a3bc5c13be5040f0d1b1e662cf18" translate="yes" xml:space="preserve">
          <source>Trace in-scheduling and out-scheduling on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; that prints each in-scheduling and out-scheduling with process, time-stamp, and current function. It also prints the total time each traced process was scheduled in.</source>
          <target state="translated">지정된 프로세스에서 스케줄링 및 스케줄링을 추적합니다. 사용되는 형식 핸들러는 &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; 이며 프로세스, 타임 스탬프 및 현재 기능을 사용하여 각 예약 및 예약을 인쇄합니다. 또한 추적 된 각 프로세스가 예약 된 총 시간을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ffc9984032978aa3b6449468569d3553d6cf5759" translate="yes" xml:space="preserve">
          <source>Trace messages:</source>
          <target state="translated">추적 메시지 :</target>
        </trans-unit>
        <trans-unit id="4d4722f0d0980b84f26e05618ea2d6105d2b13ac" translate="yes" xml:space="preserve">
          <source>Trace patterns can also be added for traced messages. Click button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt; and select &lt;strong&gt;Messages sent&lt;/strong&gt; or &lt;strong&gt;Messages received&lt;/strong&gt;, and a match specification.</source>
          <target state="translated">추적 된 메시지에 대한 추적 패턴을 추가 할 수도 있습니다. &lt;strong&gt;추적 패턴 추가&lt;/strong&gt; 단추를 클릭 하고 &lt;strong&gt;전송 된 &lt;/strong&gt;&lt;strong&gt;메시지&lt;/strong&gt; 또는 &lt;strong&gt;수신 된 메시지&lt;/strong&gt; 및 일치 스펙을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0940d3dfe2f33f718de044f09bc83c6282e8f2ee" translate="yes" xml:space="preserve">
          <source>Trace patterns only apply to the traced processes and ports.</source>
          <target state="translated">추적 패턴은 추적 된 프로세스 및 포트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9473289ba2f7fdb4aceac50e9847d3fb9343a9" translate="yes" xml:space="preserve">
          <source>Trace patterns specify how to trace a function or a message by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">추적 패턴은 일치 스펙을 사용하여 기능 또는 메시지를 추적하는 방법을 지정합니다. 일치 스펙은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02e22fba6caaac8c0531907ae75bbb4f037b1bf" translate="yes" xml:space="preserve">
          <source>Traces &lt;code&gt;Item&lt;/code&gt; in accordance to the value specified by &lt;code&gt;Flags&lt;/code&gt;. The variation of &lt;code&gt;Item&lt;/code&gt; is listed below:</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 로 지정된 값에 따라 &lt;code&gt;Item&lt;/code&gt; 을 추적 합니다 . &lt;code&gt;Item&lt;/code&gt; 의 변형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d86b88eb80a4cb0c1e2e56d320a47a7c0a552ac" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특정 함수 호출을 추적합니다. &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 을 호출하여 추적 할 함수 호출을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6a38811b152556838705c34470f7050c3304700" translate="yes" xml:space="preserve">
          <source>Traces garbage collections of processes.</source>
          <target state="translated">가비지 프로세스 프로세스를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0bfeea5f77e5e80144fb5c69582ff8a4c4aa0a8c" translate="yes" xml:space="preserve">
          <source>Traces global function calls for the process according to the trace patterns set in the system (see tp/2).</source>
          <target state="translated">시스템에 설정된 추적 패턴에 따라 프로세스에 대한 전역 함수 호출을 추적합니다 (tp / 2 참조).</target>
        </trans-unit>
        <trans-unit id="7b9365396596fa47926ca8347796645d68615fc5" translate="yes" xml:space="preserve">
          <source>Traces port related events to the port.</source>
          <target state="translated">포트 관련 이벤트를 포트로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="9984d03ffd8c79d353ed1035134b4b78d308578d" translate="yes" xml:space="preserve">
          <source>Traces port-related events.</source>
          <target state="translated">포트 관련 이벤트를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="53c6e4ac66fc9e05350a56f9ce0407168d386402" translate="yes" xml:space="preserve">
          <source>Traces process related events to the process.</source>
          <target state="translated">프로세스 관련 이벤트를 프로세스로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="29908912e6fff8dc5249509363a4412791547f21" translate="yes" xml:space="preserve">
          <source>Traces process-related events.</source>
          <target state="translated">프로세스 관련 이벤트를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="5fea32fcd1026ba95b7747cfa7687d7877ce29fa" translate="yes" xml:space="preserve">
          <source>Traces receiving of messages.</source>
          <target state="translated">메시지 수신을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="cc07cb20090b0accf4d5bc83ba241371cabc9b3a" translate="yes" xml:space="preserve">
          <source>Traces scheduling of exiting processes.</source>
          <target state="translated">종료 프로세스의 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="67d22b046457a4e977f4835a302c705d01e90b51" translate="yes" xml:space="preserve">
          <source>Traces scheduling of ports.</source>
          <target state="translated">포트 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="2f48a05431b99fc7b0ddcdfbdc7ffb069ba16117" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes just like &lt;code&gt;running&lt;/code&gt;. However, this option also includes schedule events when the process executes within the context of a port without being scheduled out itself.</source>
          <target state="translated">&lt;code&gt;running&lt;/code&gt; 과 같은 프로세스의 스케줄링을 추적 합니다 . 그러나이 옵션에는 프로세스가 자체적으로 스케줄되지 않고 포트 컨텍스트 내에서 실행될 때 스케줄 이벤트도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce958853f2f4b0ef08e9d0a61efd87ba237714e" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes.</source>
          <target state="translated">프로세스 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c4c7172939e3bf7fce3abeb0aee363e0caeecf04" translate="yes" xml:space="preserve">
          <source>Traces sending of messages.</source>
          <target state="translated">메시지 전송을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="47adf62bbb5b7db2ff2d321ec8c4e3902e48036a" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives and sends.</source>
          <target state="translated">프로세스 또는 포트가 수신 및 전송하는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="139350008a2a0843c976fc5033dee778dfce8767" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives.</source>
          <target state="translated">프로세스 또는 포트가 수신하는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="bd14c1efd1ddeca64fe6450f80e57e6c1564eaab" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port sends.</source>
          <target state="translated">프로세스 또는 포트가 보내는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c82c46612470fc95ddd9cc9407e733f834757c70" translate="yes" xml:space="preserve">
          <source>Tracing. Trace flags can still be set for the process, but no trace messages of any kind are generated. (If flag &lt;code&gt;sensitive&lt;/code&gt; is turned off, trace messages are again generated if any trace flags are set.)</source>
          <target state="translated">트레이싱. 프로세스에 대해 추적 플래그를 계속 설정할 수 있지만 어떤 종류의 추적 메시지도 생성되지 않습니다. 플래그 &lt;code&gt;sensitive&lt;/code&gt; 이 해제되면 추적 플래그가 설정되면 추적 메시지가 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47fc4ea1f09f1ee696b546f14553f696094e6dba" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph.</source>
          <target state="translated">트레이싱; 이전 단락에서 언급 한 바와 같이</target>
        </trans-unit>
        <trans-unit id="41e7b60cc9f2be5dd1ce4620f59c4b34f7bff5d2" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph. The trace contains entries for function calls, returns to function, process scheduling, other process related (spawn, etc) events, and garbage collection. All trace entries are timestamped.</source>
          <target state="translated">트레이싱; 이전 단락에서 언급 한 바와 같이 추적에는 함수 호출, 함수 리턴, 프로세스 스케줄링, 기타 프로세스 관련 (스폰 등) 이벤트 및 가비지 콜렉션에 대한 항목이 포함됩니다. 모든 추적 항목이 타임 스탬프됩니다.</target>
        </trans-unit>
        <trans-unit id="8fe0486a60ee6a3c01827363742db14787a69569" translate="yes" xml:space="preserve">
          <source>Traditionally the Presented IDs were found in the &lt;code&gt;Subject&lt;/code&gt; certificate field as &lt;code&gt;CN&lt;/code&gt; names. This is still quite common. When printing a certificate they show up as:</source>
          <target state="translated">전통적으로 제시된 ID는 &lt;code&gt;Subject&lt;/code&gt; 인증서 필드에서 &lt;code&gt;CN&lt;/code&gt; 이름 으로 발견되었습니다 . 이것은 여전히 ​​흔합니다. 인증서를 인쇄 할 때 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6a9e832dedaac8dfc95165be3ac0b240579c52" translate="yes" xml:space="preserve">
          <source>Transaction properties, which include atomicity, consistency, isolation, and durability</source>
          <target state="translated">원 자성, 일관성, 격리 및 내구성을 포함한 트랜잭션 속성</target>
        </trans-unit>
        <trans-unit id="0c055699e2752b762bcaa8253255fc14b9bef9a9" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; are both true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">트랜잭션 발신자 시간 초과 시간 두 가지 기능이 있습니다. 먼저, 값이 0이면 트랜잭션이 누적되지 않습니다 (예 : 트랜잭션 발신자 프로세스가 시작되지 않음). 둘째, 값이 0보다 크고 &lt;code&gt;auto_ack&lt;/code&gt; 및 &lt;code&gt;trans_ack&lt;/code&gt; 이 모두 true이거나 &lt;code&gt;trans_req&lt;/code&gt; 가 true 인 경우 트랜잭션 발신자가 시작되고 트랜잭션 ( &lt;code&gt;auto_ack&lt;/code&gt; , &lt;code&gt;trans_ack&lt;/code&gt; 및 &lt;code&gt;trans_req&lt;/code&gt; 값에 따라 다름 )이 나중에 누적됩니다. 배상.</target>
        </trans-unit>
        <trans-unit id="269959a97a6fb575e49d0eca74353214adfc6c11" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; is true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">트랜잭션 발신자 시간 초과 시간 두 가지 기능이 있습니다. 먼저 값이 0이면 트랜잭션이 누적되지 않습니다 (예 : 트랜잭션 발신자 프로세스가 시작되지 않음). 둘째, 값이 0보다 크고 &lt;code&gt;auto_ack&lt;/code&gt; 및 &lt;code&gt;trans_ack&lt;/code&gt; 이 true이거나 &lt;code&gt;trans_req&lt;/code&gt; 가 true 인 경우 트랜잭션 발신자가 시작되고 트랜잭션 ( &lt;code&gt;auto_ack&lt;/code&gt; , &lt;code&gt;trans_ack&lt;/code&gt; 및 &lt;code&gt;trans_req&lt;/code&gt; 값에 따라 다름 )이 나중에 전송되도록 누적됩니다. .</target>
        </trans-unit>
        <trans-unit id="8663c67ab2c24806fdfac1e594f2b7c4880ae74b" translate="yes" xml:space="preserve">
          <source>Transaction-protected updates of counter records are not possible.</source>
          <target state="translated">카운터 레코드의 트랜잭션 보호 업데이트는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="92857e4acd00ac4a82a3a5846abb0210105c9b13" translate="yes" xml:space="preserve">
          <source>Transactions are important when designing fault-tolerant, distributed systems. A &lt;code&gt;Mnesia&lt;/code&gt; transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete &lt;code&gt;Mnesia&lt;/code&gt; records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</source>
          <target state="translated">내결함성 분산 시스템을 설계 할 때는 트랜잭션이 중요합니다. &lt;code&gt;Mnesia&lt;/code&gt; 의 트랜잭션은 데이터베이스의 일련의 동작을 하나 개의 기능 블록으로 수행 할 수있는 메커니즘이다. 트랜잭션으로 실행되는 기능 블록을 기능 개체 (Fun)라고 &lt;code&gt;Mnesia&lt;/code&gt; 코드는 Mnesia 레코드를 읽고 쓰고 삭제할 수 있습니다. Fun은 커밋 또는 종료되는 트랜잭션으로 평가됩니다. 트랜잭션이 Fun 실행에 성공하면 관련된 모든 노드에서 조치를 복제하거나 오류가 발생하면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb9104f2b09d1b5d4b87d82abb898d1890e970f" translate="yes" xml:space="preserve">
          <source>Transactions can be assigned the property of being executed on all nodes in the system, or on none. Transactions can also be bypassed in favor of running &quot;dirty operations&quot;, which reduce overheads and run fast.</source>
          <target state="translated">트랜잭션은 시스템의 모든 노드에서 실행되는 속성을 할당하거나 전혀 할당하지 않을 수 있습니다. 오버 헤드를 줄이고 빠르게 실행되는 &quot;더러운 작업&quot;을 실행하기 위해 트랜잭션을 무시할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a91a6387bdeb5a997e5106ce0eb7dbddb3fbc79e" translate="yes" xml:space="preserve">
          <source>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value &lt;code&gt;{aborted, Reason}&lt;/code&gt; and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</source>
          <target state="translated">트랜잭션은 임의의 방식으로 중첩 될 수 있습니다. 하위 트랜잭션은 상위 트랜잭션과 동일한 프로세스에서 실행해야합니다. 하위 트랜잭션이 종료되면 하위 트랜잭션의 호출자는 리턴 값 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 을 받고 하위에서 수행 한 모든 작업이 지워집니다. 자식 트랜잭션이 커밋되면 자식이 작성한 레코드가 부모에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c5e2dea68a50fc96da311191d6565ac73e322c" translate="yes" xml:space="preserve">
          <source>Transactions that update the definition of a table requires that &lt;code&gt;Mnesia&lt;/code&gt; is started on all nodes where the storage type of the schema is &lt;code&gt;disc_copies&lt;/code&gt;. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</source>
          <target state="translated">테이블 정의를 업데이트하는 트랜잭션 에서는 스키마의 스토리지 유형이 &lt;code&gt;disc_copies&lt;/code&gt; 인 모든 노드에서 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작 해야합니다 . 이 노드에있는 테이블의 모든 복제본도로드해야합니다. 이러한 가용성 규칙에는 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8042cfa4648048958e1595a0cff5bd3d748ab7d" translate="yes" xml:space="preserve">
          <source>Transcodes an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;URIString&lt;/code&gt;, where &lt;code&gt;Options&lt;/code&gt; is a list of tagged tuples, specifying the inbound (&lt;code&gt;in_encoding&lt;/code&gt;) and outbound (&lt;code&gt;out_encoding&lt;/code&gt;) encodings. &lt;code&gt;in_encoding&lt;/code&gt; and &lt;code&gt;out_encoding&lt;/code&gt; specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 호환 &lt;code&gt;URIString&lt;/code&gt; 을 트랜스 코딩합니다 . 여기서 &lt;code&gt;Options&lt;/code&gt; 는 인바운드 ( &lt;code&gt;in_encoding&lt;/code&gt; ) 및 아웃 바운드 ( &lt;code&gt;out_encoding&lt;/code&gt; ) 인코딩을 지정하여 태그가 지정된 튜플의 목록입니다 . &lt;code&gt;in_encoding&lt;/code&gt; 및 &lt;code&gt;out_encoding&lt;/code&gt; 은 입력 및 출력 데이터에 대한 이진 인코딩 및 백분율 인코딩을 모두 지정합니다. 이진 인코딩이 퍼센트 인코딩과 동일하지 않은 혼합 인코딩은 지원되지 않습니다. 인수가 유효하지 않으면 오류 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0276c8258f3ca2236ded67dcb45cec51cdd4d087" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; into the file &lt;code&gt;RemoteFile&lt;/code&gt; at the remote server.</source>
          <target state="translated">전송 바이너리 &lt;code&gt;Bin&lt;/code&gt; 파일로 &lt;code&gt;RemoteFile&lt;/code&gt; 을 원격 서버에서.</target>
        </trans-unit>
        <trans-unit id="a31be82768a8a14fe4e45c8c31cc87a5a005d692" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; to the remote server and appends it to the file &lt;code&gt;RemoteFile&lt;/code&gt;. If the file does not exist, it is created.</source>
          <target state="translated">전송 바이너리 &lt;code&gt;Bin&lt;/code&gt; 원격 서버와 파일에 추가합니다 &lt;code&gt;RemoteFile&lt;/code&gt; 을 . 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="96ecc5026b0a2d6e144a5dcc9d3d15bc2637fba5" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which appends it to the file specified in the call to &lt;code&gt;append_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">전송 청크 &lt;code&gt;Bin&lt;/code&gt; 에 대한 호출에 지정된 파일에 추가합니다 원격 서버에 &lt;code&gt;append_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d777ccd8cf743ce8e8b1db94238262ce12eba79" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which writes it into the file specified in the call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">전송 청크 &lt;code&gt;Bin&lt;/code&gt; 에 대한 호출에 지정된 파일로 기록하는 원격 서버에 &lt;code&gt;send_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78ac497764b60c7c85e8349f223a68fe68089947" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LocalFile&lt;/code&gt; 파일 을 원격 서버로 전송 합니다. 경우 &lt;code&gt;RemoteFile&lt;/code&gt; 을가 지정되어, 원격 파일의 이름으로 설정되어 &lt;code&gt;RemoteFile&lt;/code&gt; 을 그렇지 않은 경우에, &lt;code&gt;LocalFile&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="aec29636456fbdaa72ac911c194e9cb134c0de35" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file that the file is appended to is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;. If the file does not exists, it is created.</source>
          <target state="translated">&lt;code&gt;LocalFile&lt;/code&gt; 파일 을 원격 서버로 전송 합니다. 경우 &lt;code&gt;RemoteFile&lt;/code&gt; 을가 지정되어, 원격 파일의 이름 파일이 설정되어 추가되는 &lt;code&gt;RemoteFile&lt;/code&gt; 을 그렇지 않은 경우에, &lt;code&gt;LocalFile&lt;/code&gt; 에 . 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="90ba80cf80c63c0d2c8f02175aa1e10f13204467" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server and receives it as a binary.</source>
          <target state="translated">원격 서버에서 &lt;code&gt;RemoteFile&lt;/code&gt; 파일을 전송하고 이진 파일로 수신합니다.</target>
        </trans-unit>
        <trans-unit id="ef6a6bd4453d0b36a0f55436c56df830215430fd" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server to the file system of the local client. If &lt;code&gt;LocalFile&lt;/code&gt; is specified, the local file will be &lt;code&gt;LocalFile&lt;/code&gt;, otherwise &lt;code&gt;RemoteFile&lt;/code&gt;.</source>
          <target state="translated">원격 서버에서 로컬 클라이언트의 파일 시스템으로 &lt;code&gt;RemoteFile&lt;/code&gt; 파일을 전송합니다 . 경우 &lt;code&gt;LocalFile&lt;/code&gt; 에가 지정되어, 로컬 파일이있을 것입니다 &lt;code&gt;LocalFile&lt;/code&gt; 에 , 그렇지 않으면 &lt;code&gt;RemoteFile&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f0ad6ecb9ddaf64bd66989047cba27a4d5603ff1" translate="yes" xml:space="preserve">
          <source>Transform a alias-name to its oid.</source>
          <target state="translated">별명을 해당 이름으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="36c585abe302937d577b48572bd7c0e3655c0630" translate="yes" xml:space="preserve">
          <source>Transform a oid to its aliasname.</source>
          <target state="translated">OID를 별명으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5829db0e03928c4e7cde6f753299a051ba3577" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, appending &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of the specified string.</source>
          <target state="translated">지정된 문자열의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 를 추가하여 컴파일하기 전에 입력 사전을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b3111884f3054cc372ba38df92c0a135c770202" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, setting &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; to the specified string.</source>
          <target state="translated">&lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 를 지정된 문자열로 설정하여 컴파일하기 전에 입력 사전을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4f1d57f141d31ace69a30793395cb3994e3e4b6" translate="yes" xml:space="preserve">
          <source>Transforming URIs into a normalized form</source>
          <target state="translated">URI를 정규화 된 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="52a09e92d39be036799f55f3466102e3964c9981" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (that is, it cannot be sent to a process on another node and still remain a valid compiled match specification, nor can it be stored on disk). To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 을 이후의 &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 호출에서 사용할 수있는 내부 표현으로 변환합니다 . 내부 표현은 불투명하며 외부 용어 형식으로 변환 한 다음 속성을 잃지 않고 다시 되돌릴 수 없습니다 (즉, 다른 노드의 프로세스로 전송 될 수없고 유효한 컴파일 된 일치 스펙으로 남아 있거나 저장 될 수 없음). 디스크). 컴파일 된 일치 스펙의 유효성을 확인하려면 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="29484fe337b3af71da5ca7a2dac4e696f5f79d47" translate="yes" xml:space="preserve">
          <source>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for &lt;code&gt;Node&lt;/code&gt;, as produced by the given &lt;code&gt;Printer&lt;/code&gt; function. Each line of the comment is prefixed by the string &lt;code&gt;Prefix&lt;/code&gt; (this does not include the initial &quot;&lt;code&gt;%&lt;/code&gt;&quot; character of the comment line).</source>
          <target state="translated">구문 트리를 추상 주석으로 변환합니다. 주석의 행 에는 주어진 &lt;code&gt;Printer&lt;/code&gt; 함수에 의해 생성 된 &lt;code&gt;Node&lt;/code&gt; 텍스트가 포함 됩니다. 주석의 각 줄은 문자열로 접두사 &lt;code&gt;Prefix&lt;/code&gt; (이 초기 &quot;에 포함되지 않습니다 &lt;code&gt;%&lt;/code&gt; 주석 라인의&quot;문자).</target>
        </trans-unit>
        <trans-unit id="0cbb6e0e6a14a90b777a9f90d55d975cb9b29ca2" translate="yes" xml:space="preserve">
          <source>Transforms addresses from internal MIB format to one more useful to &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부 MIB 형식의 주소를 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt; 에 더 유용한 주소로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dec43f85ac93650f89af6686bc1b1b60f6b9599f" translate="yes" xml:space="preserve">
          <source>Transforms an &lt;code&gt;URI&lt;/code&gt; into a normalized form using Syntax-Based Normalization as defined by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 에 의해 정의 된 구문 기반 정규화를 사용하여 &lt;code&gt;URI&lt;/code&gt; 를 정규화 된 양식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d9a9fd8f3259ae9990008a8a6bec24b152a43a" translate="yes" xml:space="preserve">
          <source>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</source>
          <target state="translated">SNMP 색인을 해당 Mnesia 키로 변환합니다. SNMP 테이블에 여러 키가있는 경우 키는 키 열의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="187ea5deff287a5504fddf1b7e36cd0f09e23500" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;person&lt;/code&gt; table from a RAM table into a disc-based table at &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 테이블을 RAM 테이블에서 &lt;code&gt;Node&lt;/code&gt; 의 디스크 기반 테이블로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e599fefddd1839d024d114d1fae1e8b80cf9332c" translate="yes" xml:space="preserve">
          <source>Transforms trace data and makes an event record out of it.</source>
          <target state="translated">추적 데이터를 변환하고 그로부터 이벤트 레코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="dae87e24dc1095e84bcbb6fcaaaa2c5136770260" translate="yes" xml:space="preserve">
          <source>Transient Failures</source>
          <target state="translated">일시적 실패</target>
        </trans-unit>
        <trans-unit id="340b8d86a3623f3b21be6c18b845921955f1271a" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the state transition. Here are the sequence of steps for a state transition:</source>
          <target state="translated">전환 옵션은 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 으로 설정 하고 상태 전환을 수정할 수 있습니다 . 상태 전이 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f68e1d1cfad7a14a47ac7096b71655133e8d261" translate="yes" xml:space="preserve">
          <source>Translates an SCTP error number from, for example, &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; or &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; into an explanatory string, or one of the atoms &lt;code&gt;ok&lt;/code&gt; for no error or &lt;code&gt;undefined&lt;/code&gt; for an unrecognized error.</source>
          <target state="translated">, SCTP에서 에러 수를 변환 예 &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; 또는 &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; 설명 문자열 또는 원자 중 하나에 &lt;code&gt;ok&lt;/code&gt; 없음 에러 또는 &lt;code&gt;undefined&lt;/code&gt; 미정 에러.</target>
        </trans-unit>
        <trans-unit id="6fca7eec0c5c2c402ec9feaf20fb1cf586209144" translate="yes" xml:space="preserve">
          <source>Translates signature algorithm OID to Erlang digest and signature types.</source>
          <target state="translated">서명 알고리즘 OID를 Erlang 다이제스트 및 서명 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2dd26e871e1b0c6741054f66f2c8c6fd1ff461e9" translate="yes" xml:space="preserve">
          <source>Translates the binary trace logs into something readable. By default, &lt;code&gt;ttb&lt;/code&gt; presents each trace message as a line of text, but you can also write your own handler to make more complex interpretations of the trace information. A trace log can also be presented graphically with application Event Tracer (ET).</source>
          <target state="translated">이진 추적 로그를 읽을 수있는 것으로 변환합니다. 기본적으로 &lt;code&gt;ttb&lt;/code&gt; 는 각 추적 메시지를 한 줄의 텍스트로 표시하지만 추적 정보에 대한보다 복잡한 해석을 위해 자체 핸들러를 작성할 수도 있습니다. 응용 프로그램 이벤트 추적기 (ET)를 사용하여 추적 로그를 그래픽으로 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="247b327869ef6106bf80329969b8c8bd5956cb2a" translate="yes" xml:space="preserve">
          <source>Translation Agents</source>
          <target state="translated">번역 에이전트</target>
        </trans-unit>
        <trans-unit id="c10d76c9a4b81c39c13a3bbf7cdb7a157dfb1551" translate="yes" xml:space="preserve">
          <source>Transport</source>
          <target state="translated">Transport</target>
        </trans-unit>
        <trans-unit id="b374a75b21ba249e1509b4f849a514f5f64e23f6" translate="yes" xml:space="preserve">
          <source>Transport Failure Algorithm</source>
          <target state="translated">전송 실패 알고리즘</target>
        </trans-unit>
        <trans-unit id="67ca25bf09fe1a4bc0aa43dea06a3fcf06720b9d" translate="yes" xml:space="preserve">
          <source>Transport Failure Detection</source>
          <target state="translated">운송 실패 감지</target>
        </trans-unit>
        <trans-unit id="c24199b7fc627de79e3a1c89011039b836457577" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) and its predecessor, the Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. The protocols use X.509 certificates and hence public key (asymmetric) cryptography to authenticate the counterpart with whom they communicate, and to exchange a symmetric key for payload encryption. The protocol provides data/message confidentiality (encryption), integrity (through message authentication code checks) and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that is based on TLS but datagram oriented instead of stream oriented.</source>
          <target state="translated">TLS (Transport Layer Security) 및 그 이전 버전 인 SSL (Secure Sockets Layer)은 컴퓨터 네트워크를 통한 통신 보안을 제공하도록 설계된 암호화 프로토콜입니다. 프로토콜은 X.509 인증서와 공개 키 (비대칭) 암호화를 사용하여 통신하는 상대방을 인증하고 페이로드 암호화를 위해 대칭 키를 교환합니다. 이 프로토콜은 데이터 / 메시지 기밀성 (암호화), 무결성 (메시지 인증 코드 검사를 통한) 및 호스트 확인 (인증서 경로 확인을 통한)을 제공합니다. TLS를 기반으로하지만 스트림 지향 대신 데이터 그램 지향 DTLS (Datagram Transport Layer Security).</target>
        </trans-unit>
        <trans-unit id="784cd0f786d540e1df407cfe0bdede50bd4a091f" translate="yes" xml:space="preserve">
          <source>Transpose characters</source>
          <target state="translated">문자 조바꿈</target>
        </trans-unit>
        <trans-unit id="6e192302cce69f9e090d601f54b7e73e6fdccdad" translate="yes" xml:space="preserve">
          <source>Traverses &lt;code&gt;Dirs&lt;/code&gt; and adds each &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. This means that the order of &lt;code&gt;Dirs&lt;/code&gt; is reversed in the resulting code path. For example, if you add &lt;code&gt;[Dir1,Dir2]&lt;/code&gt;, the resulting path will be &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dirs&lt;/code&gt; 를 트래버스 하고 각 &lt;code&gt;Dir&lt;/code&gt; 을 코드 경로의 시작 부분에 추가 합니다. 이것은 &lt;code&gt;Dirs&lt;/code&gt; 의 순서가 결과 코드 경로에서 역전 됨을 의미합니다 . 예를 들어 &lt;code&gt;[Dir1,Dir2]&lt;/code&gt; 를 추가 하면 결과 경로는 &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="137a357a519bf577c3a49eea20ac865057de4ba8" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise the function returns a key that can be used to read the actual record.</source>
          <target state="translated">테이블을 탐색하고 테이블의 모든 레코드에 대한 작업을 수행합니다. 테이블 끝에 도달하면 특수 키 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. 그렇지 않으면이 함수는 실제 레코드를 읽는 데 사용할 수있는 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d196f97744321413a11b3f30616c9f2f4eec01c6" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;.</source>
          <target state="translated">테이블을 탐색하고 테이블의 모든 레코드에 대한 작업을 수행합니다. 테이블 끝에 도달하면 특수 키 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. 그렇지 않으면이 함수는 실제 레코드를 읽는 데 사용할 수있는 키를 반환합니다. 다른 Erlang 프로세스가 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 함수로 트래버스되는 동안 테이블에서 쓰기 작업을 수행하는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8dc9f15de712d9d574738e5b2e0901706f6adc90" translate="yes" xml:space="preserve">
          <source>Traverses a table in a manner similar to the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;. A table has a number of slots that range from 0 (zero) to an unknown upper bound. The function &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; returns the special atom &lt;code&gt;'$end_of_table'&lt;/code&gt; when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 함수와 유사한 방식으로 테이블을 탐색 합니다. 테이블에는 0에서 알 수없는 상한 범위의 슬롯이 있습니다. 함수 &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; 반환 특별한 원자 &lt;code&gt;'$end_of_table'&lt;/code&gt; 테이블의 끝에 도달했을 때. 트래버스되는 동안 테이블에서 쓰기 작업이 수행되면이 함수의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5bce8436ec86270c2bccf19db4667aa0c4b7a23" translate="yes" xml:space="preserve">
          <source>Traversing the set of modules, it then recompiles every module for which at least one of the following conditions apply:</source>
          <target state="translated">그런 다음 모듈 세트를 순회하면 다음 조건 중 하나 이상이 적용되는 모든 모듈을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="c0c84ee4b222403ef3c2a2f6e4a34ab18cd985d5" translate="yes" xml:space="preserve">
          <source>Tries to create directory &lt;code&gt;Dir&lt;/code&gt;. Missing parent directories are &lt;strong&gt;not&lt;/strong&gt; created. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리를 작성하려고합니다 . 누락 된 상위 디렉토리가 작성 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="7539b9bc23bf1a63079b6009b66e55de1f511775" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the &lt;code&gt;NULL&lt;/code&gt;-terminated C-string &lt;code&gt;name&lt;/code&gt; with encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩 &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;NULL&lt;/code&gt; 종료 C- 문자열 &lt;code&gt;name&lt;/code&gt; 에서 이미 존재하는 원자의 항을 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="d956aa4d45e626e33feccc52c2e668a01e46c2de" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the string &lt;code&gt;name&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; and encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; characters are treated as any other characters.</source>
          <target state="translated">length &lt;code&gt;len&lt;/code&gt; 및 encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열 &lt;code&gt;name&lt;/code&gt; 에서 이미 존재하는 원자의 용어를 작성하려고합니다 . &lt;code&gt;NULL&lt;/code&gt; 문자는 다른 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="c7380de8914d3d9d8e70fd1f6c74d924099655d6" translate="yes" xml:space="preserve">
          <source>Tries to delete directory &lt;code&gt;Dir&lt;/code&gt;. The directory must be empty before it can be deleted. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">디렉토리 &lt;code&gt;Dir&lt;/code&gt; 을 삭제하려고합니다 . 삭제하기 전에 디렉토리가 비어 있어야합니다. 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="0694587d26aecfbb0a43b20ea81eab04225a2a67" translate="yes" xml:space="preserve">
          <source>Tries to delete file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 파일을 삭제하려고합니다 . 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="917cb6bdcab3e4dcc84eba06ed763b346415331e" translate="yes" xml:space="preserve">
          <source>Tries to find a &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 정점 &lt;code&gt;V1&lt;/code&gt; 에서 정점 &lt;code&gt;V2&lt;/code&gt; 까지 의 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 를 찾으려고 시도합니다 . 경로를 꼭짓점 의 목록 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 로 반환 하거나, 길이 가 &lt;code&gt;V1&lt;/code&gt; 에서 &lt;code&gt;V2&lt;/code&gt; 이상인 간단한 경로가 없으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6d56eefae6afa713ee58d8d532711a39f9d00e8" translate="yes" xml:space="preserve">
          <source>Tries to find an application downgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a previous version &lt;code&gt;OldVsn&lt;/code&gt; located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">현재 버전 에서 &lt;code&gt;Dir&lt;/code&gt; 에 있는 이전 버전의 &lt;code&gt;OldVsn&lt;/code&gt; 으로 &lt;code&gt;App&lt;/code&gt; 용 애플리케이션 다운 그레이드 스크립트를 찾으려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5b3cdb4b87509cbcdcf3943a3bdad2d3f9b6d987" translate="yes" xml:space="preserve">
          <source>Tries to find an application upgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">현재 버전에서 &lt;code&gt;Dir&lt;/code&gt; 에있는 새 버전으로 &lt;code&gt;App&lt;/code&gt; 의 애플리케이션 업그레이드 스크립트를 찾으려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="63810144427574ddc18730d454daf02c43dd8338" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; through vertex &lt;code&gt;V&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the cycle as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple cycle through &lt;code&gt;V&lt;/code&gt; exists. Notice that a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; is returned as list &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt;.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 꼭짓점 &lt;code&gt;V&lt;/code&gt; 를 통해 가능한 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 을 찾으려고 시도합니다 . 반환 목록으로주기 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 정점으로, 또는 &lt;code&gt;false&lt;/code&gt; 을 통해 간단한 사이클 경우 &lt;code&gt;V&lt;/code&gt; 는 존재하지 않는다. 알 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;V&lt;/code&gt; 가 리스트로서 반환한다 &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd32105e9ea9dba4a3239b99d2841486b3f987d" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 정점 &lt;code&gt;V1&lt;/code&gt; 에서 정점 &lt;code&gt;V2&lt;/code&gt; 까지 가능한 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 를 찾으려고 시도합니다 . 경로를 꼭짓점 의 목록 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 로 반환 하거나, 길이 가 &lt;code&gt;V1&lt;/code&gt; 에서 &lt;code&gt;V2&lt;/code&gt; 이상인 간단한 경로가 없으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f904e656f227e2a584648e9091f6b33093af20b3" translate="yes" xml:space="preserve">
          <source>Tries to load a module in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;, unless the module is already loaded. However, in embedded mode it does not load a module that is not already loaded, but returns &lt;code&gt;{error, embedded}&lt;/code&gt; instead. See &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; for a description of other possible error reasons.</source>
          <target state="translated">모듈이 이미로드되어 있지 않으면 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 과 같은 방식으로 모듈을로드하려고 시도합니다 . 그러나 임베디드 모드에서는 아직로드되지 않은 모듈을로드하지 않고 대신 &lt;code&gt;{error, embedded}&lt;/code&gt; 를 리턴 합니다. 다른 가능한 오류 이유에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; 대한 오류 이유를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec25834fa1b726007249264a0c7c78aaaf71538e" translate="yes" xml:space="preserve">
          <source>Tries to load all of the modules in the list &lt;code&gt;Modules&lt;/code&gt; atomically. That means that either all modules are loaded at the same time, or none of the modules are loaded if there is a problem with any of the modules.</source>
          <target state="translated">목록 &lt;code&gt;Modules&lt;/code&gt; 모든 모듈을 원자 적으로 로드하려고 시도합니다 . 즉, 모든 모듈이 동시에로드되거나 모듈에 문제가있는 경우 어떤 모듈도로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1aaf9b09924ea99accd919111039be58e3e4e9fc" translate="yes" xml:space="preserve">
          <source>Tries to load and restore Debugger settings from a file previously saved using &lt;strong&gt;Save Settings...&lt;/strong&gt; (see below). Any errors are silently ignored.</source>
          <target state="translated">&lt;strong&gt;Save Settings ...&lt;/strong&gt; (아래 참조)를 사용하여 이전에 저장된 파일에서 디버거 설정을로드하고 복원하려고합니다 . 모든 오류는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc1b21fc8af03b36192dd6ac14e4e4450744f7e" translate="yes" xml:space="preserve">
          <source>Tries to load any modules not already loaded in the list &lt;code&gt;Modules&lt;/code&gt; in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 과 같은 방식으로 목록 &lt;code&gt;Modules&lt;/code&gt; 에 아직로드되지 않은 모듈을로드하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="b645a31575ab3155bc8f781878d4d3b627bae342" translate="yes" xml:space="preserve">
          <source>Tries to load code for all modules that have been previously prepared by &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt;. The loading occurs atomically, meaning that either all modules are loaded at the same time, or none of the modules are loaded.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 에 의해 준비된 모든 모듈에 대한 코드를로드하려고 시도합니다 . 로드는 원자 적으로 발생하므로 모든 모듈이 동시에로드되거나로드 된 모듈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4b988df2289cf719529adabbdd5889a80ea66c6" translate="yes" xml:space="preserve">
          <source>Tries to load the Erlang module &lt;code&gt;Module&lt;/code&gt;, using the code path. It looks for the object code file with an extension corresponding to the Erlang machine used, for example, &lt;code&gt;Module.beam&lt;/code&gt;. The loading fails if the module name found in the object code differs from the name &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; must be used to load object code with a module name that is different from the file name.</source>
          <target state="translated">코드 경로를 사용하여 Erlang 모듈 &lt;code&gt;Module&lt;/code&gt; 을로드하려고합니다 . Erlang 시스템에 해당하는 확장자 (예 : &lt;code&gt;Module.beam&lt;/code&gt; ) 를 가진 오브젝트 코드 파일을 찾습니다 . 모듈 이름은 이름에서 오브젝트 코드 다릅니다에있는 경우로드가 실패 &lt;code&gt;Module&lt;/code&gt; . 파일 이름과 다른 모듈 이름으로 오브젝트 코드를로드하려면 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b49e8d37404b75156cbbeb1637eb4e0c68260be5" translate="yes" xml:space="preserve">
          <source>Tries to lock a mutex. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same mutex again.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 현재 뮤텍스를 잠근 스레드 는 동일한 뮤텍스를 다시 잠그려고 시도 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="369d095339d331183fd1de82b70ca1f958ce57f3" translate="yes" xml:space="preserve">
          <source>Tries to read &lt;code&gt;String&lt;/code&gt; in accordance with the control sequences in &lt;code&gt;Format&lt;/code&gt;. For a detailed description of the available formatting options, see &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt;. It is assumed that &lt;code&gt;String&lt;/code&gt; contains whole lines.</source>
          <target state="translated">&lt;code&gt;Format&lt;/code&gt; 의 제어 순서에 따라 &lt;code&gt;String&lt;/code&gt; 을 읽으려고 합니다. 사용 가능한 포맷 옵션에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;String&lt;/code&gt; 에 전체 줄이 포함되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="b5361d5cdb192bb80b006486e2deeb6e3a86a448" translate="yes" xml:space="preserve">
          <source>Tries to read lock an rwlock.</source>
          <target state="translated">rwlock을 읽기 위해 시도합니다.</target>
        </trans-unit>
        <trans-unit id="078c41228c821f4992dac3d604b1f36b0a4cc3ba" translate="yes" xml:space="preserve">
          <source>Tries to read/write lock an rwlock. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same rwlock again.</source>
          <target state="translated">rwlock을 읽고 쓰기 시도합니다. 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠그려고 시도 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="542b3a8d434cdeb35d54c993e320baf91923b244" translate="yes" xml:space="preserve">
          <source>Tries to rename the file &lt;code&gt;Source&lt;/code&gt; to &lt;code&gt;Destination&lt;/code&gt;. It can be used to move files (and directories) between directories, but it is not sufficient to specify the destination only. The destination filename must also be specified. For example, if &lt;code&gt;bar&lt;/code&gt; is a normal file and &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are directories, &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; returns an error, but &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; succeeds. Returns &lt;code&gt;ok&lt;/code&gt; if it is successful.</source>
          <target state="translated">시도는 파일 이름을 바꾸려면 &lt;code&gt;Source&lt;/code&gt; 에 &lt;code&gt;Destination&lt;/code&gt; . 디렉토리간에 파일 (및 디렉토리)을 이동하는 데 사용할 수 있지만 대상 만 지정하는 것만으로는 충분하지 않습니다. 대상 파일 이름도 지정해야합니다. 예를 들어, &lt;code&gt;bar&lt;/code&gt; 가 일반 파일이고 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 가 디렉토리 인 경우 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; 은 오류를 반환하지만 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; 는 성공합니다. 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b69799527904c5b0f81a27b2394603c188136973" translate="yes" xml:space="preserve">
          <source>Tries to set the scheduler bind type. The same as flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; except how some errors are handled. For more information, see &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러 바인드 유형을 설정하려고합니다. 일부 오류를 처리하는 방법을 제외하고 플래그 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3739b1427af771c5c5c521a0baa015d6c8471836" translate="yes" xml:space="preserve">
          <source>Tries to suspend all processes using a module &lt;code&gt;Mod&lt;/code&gt;. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no &lt;code&gt;Timeout&lt;/code&gt; is specified or &lt;code&gt;default&lt;/code&gt; is specified, the default value for &lt;code&gt;sys:suspend&lt;/code&gt; is used.</source>
          <target state="translated">모듈 &lt;code&gt;Mod&lt;/code&gt; 를 사용하여 모든 프로세스를 일시 중지하려고합니다 . 프로세스가 응답하지 않으면 무시됩니다. 이로 인해 프로세스가 자발적으로 새 코드로 전환 될 때 충돌이 발생하거나 제거 작업의 결과로 프로세스가 종료 될 수 있습니다. &lt;code&gt;Timeout&lt;/code&gt; 을 지정 하지 않거나 &lt;code&gt;default&lt;/code&gt; 을 지정하면 &lt;code&gt;sys:suspend&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f07a25fbd2993e4438fecb34b5a2a265898a4510" translate="yes" xml:space="preserve">
          <source>Trigger the user-probe &lt;code&gt;user_trace_i4s4&lt;/code&gt; in the NIF library &lt;code&gt;dyntrace.so&lt;/code&gt; by calling &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt;.</source>
          <target state="translated">트리거 사용자 프로브 &lt;code&gt;user_trace_i4s4&lt;/code&gt; NIF 라이브러리에 &lt;code&gt;dyntrace.so&lt;/code&gt; 호출하여 &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b4e339fc739fe569582f228faed311550ce6f3" translate="yes" xml:space="preserve">
          <source>Triggers garbage collection of requested type. Default value is &lt;code&gt;'major'&lt;/code&gt;, which would trigger a fullsweep GC. The option &lt;code&gt;'minor'&lt;/code&gt; is considered a hint and may lead to either minor or major GC run.</source>
          <target state="translated">요청 된 유형의 가비지 수집을 트리거합니다. 기본값은 &lt;code&gt;'major'&lt;/code&gt; 이며 풀 스윕 GC를 트리거합니다. 옵션 &lt;code&gt;'minor'&lt;/code&gt; 은 힌트로 간주되며 사소한 GC 실행으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce7d4bc5bdcfee52b94b55561a6aeaf81f157f5" translate="yes" xml:space="preserve">
          <source>Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.</source>
          <target state="translated">스트리밍 할 다음 메시지, 즉 소켓의 활성 메시지와 동일한 동작을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a0f37655e58e53f4d21a5d5b772a98970d6a45b9" translate="yes" xml:space="preserve">
          <source>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by &lt;code&gt;sbrk&lt;/code&gt;) that is kept by &lt;code&gt;malloc&lt;/code&gt; (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, &lt;code&gt;malloc&lt;/code&gt; releases it (by calling &lt;code&gt;sbrk&lt;/code&gt;). Trim threshold is specified in kilobytes. Defaults to &lt;code&gt;128&lt;/code&gt;.</source>
          <target state="translated">트림 임계 값 크기 (KB). 이것은 &lt;code&gt;malloc&lt;/code&gt; (운영 체제로 릴리스되지 않음)에 의해 유지되는 힙 맨 위의 사용 가능한 최대 메모리 양 ( &lt;code&gt;sbrk&lt;/code&gt; 에 의해 할당 됨 )입니다. 힙 상단의 사용 가능한 메모리 양이 트림 임계 값을 초과하면 &lt;code&gt;malloc&lt;/code&gt; 은이를 해제합니다 ( &lt;code&gt;sbrk&lt;/code&gt; 호출 ). 트림 임계 값은 킬로바이트로 지정됩니다. 기본값은 &lt;code&gt;128&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95ec715dc8ff6a5284221ec8f9868a8798be9478" translate="yes" xml:space="preserve">
          <source>Trivial FTP.</source>
          <target state="translated">사소한 FTP.</target>
        </trans-unit>
        <trans-unit id="4ba00956ec7cf24ae072a34b8ff599479668e012" translate="yes" xml:space="preserve">
          <source>Trivial example (beep on anything except empty line, which is expanded to &lt;code&gt;&quot;quit&quot;&lt;/code&gt;):</source>
          <target state="translated">간단한 예 ( &lt;code&gt;&quot;quit&quot;&lt;/code&gt; 로 확장 된 빈 줄 이외의 경고음 ) :</target>
        </trans-unit>
        <trans-unit id="c64384e3540118ebd85f8e8adda7b3a0d9d9d577" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a binary.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 이진수 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="2184451194ed3a9022be648eb665e2e8303c78bb" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a floating point number.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 부동 소수점 숫자 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="739f16017ed1c1b0d52375a346e88d29489f5f4c" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with at least one element.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 하나 이상의 요소가있는 목록 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="4dc6a0f22eecbe39d3b7bafca6d0ecf3f15fab72" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with zero or more elements.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 0 개 이상의 요소가있는 목록 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="7e4dec6465a412dda92c461f8f7e72cba72e9ec3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a pid (process identifier).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 pid (프로세스 식별자) 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="ca9f92d44502347305071d3028c3415ccc6539b0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a port.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 포트 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="63b81f24f20e74b9964fd68165f42bbd5f102696" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a reference.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 참조 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="369ae59368966778ddc2fa05ef42ca484213f640" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a tuple.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 튜플 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="200e8169564499251662fa489120aa02ef56f5b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an atom.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 원자 이면 참 .</target>
        </trans-unit>
        <trans-unit id="d2096948a91663a352916722e0007725da8866ba" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an empty list.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 빈 목록 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="7cf519e4319be41a9707146ad88931f2320203e5" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 정수 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="58de67beda24834e524aecdc74c16cbb945cf7c3" translate="yes" xml:space="preserve">
          <source>Truncates the file referenced by &lt;code&gt;IoDevice&lt;/code&gt; at the current position. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">현재 위치에서 &lt;code&gt;IoDevice&lt;/code&gt; 가 참조하는 파일을 자릅니다 . 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="37023c65abd347268bb58c87d2fb0048749a483a" translate="yes" xml:space="preserve">
          <source>Try out the new function &lt;code&gt;mult&lt;/code&gt;:</source>
          <target state="translated">새로운 기능 &lt;code&gt;mult&lt;/code&gt; 를 사용해보십시오 :</target>
        </trans-unit>
        <trans-unit id="8ff47aa173fda0968a762374da8240dfe8b55c52" translate="yes" xml:space="preserve">
          <source>Trying to evaluate a &lt;code&gt;throw&lt;/code&gt;outside a &lt;code&gt;catch&lt;/code&gt;. &lt;code&gt;V&lt;/code&gt; is the thrown term.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 밖의 &lt;code&gt;throw&lt;/code&gt; 를 평가하려고합니다 . &lt;code&gt;V&lt;/code&gt; 는 던진 용어입니다.</target>
        </trans-unit>
        <trans-unit id="cae5dd25bf19639aecf488ad3d7ba57e76736991" translate="yes" xml:space="preserve">
          <source>Trying to link to a non-existing process.</source>
          <target state="translated">존재하지 않는 프로세스에 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f4134e3f0fb2b5c47f2d5517769378391de080f4" translate="yes" xml:space="preserve">
          <source>Tunes the compression algorithm. Use the following values:</source>
          <target state="translated">압축 알고리즘을 조정합니다. 다음 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="83ed105f4df89ed36299f9fd59a044cb698807f7" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error, error_info()}&lt;/code&gt; and &lt;code&gt;{warning, error_info()}&lt;/code&gt;, denoting syntactically incorrect forms and warnings, and &lt;code&gt;{eof, line()}&lt;/code&gt;, denoting an end-of-stream encountered before a complete form had been parsed.</source>
          <target state="translated">문법적으로 잘못된 양식 및 경고를 나타내는 &lt;code&gt;{error, error_info()}&lt;/code&gt; 및 &lt;code&gt;{warning, error_info()}&lt;/code&gt; 튜플 은 완전한 양식이 구문 분석되기 전에 발생한 스트림 끝을 나타내는 &lt;code&gt;{eof, line()}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ffa679969428a6c8a5fbef9da583b1339b8f137" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error,E}&lt;/code&gt; and &lt;code&gt;{warning,W}&lt;/code&gt;, denoting syntactically incorrect forms and warnings.</source>
          <target state="translated">문법적으로 잘못된 형식과 경고를 나타내는 튜플 &lt;code&gt;{error,E}&lt;/code&gt; 및 &lt;code&gt;{warning,W}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4a5e32a69d4a4da5b271ce1389ce7de27bf6be9" translate="yes" xml:space="preserve">
          <source>Tuples and string formats accepted by versions before ssl-8.2.4 will be converted for backwards compatibility</source>
          <target state="translated">ssl-8.2.4 이전 버전에서 허용되는 튜플 및 문자열 형식은 이전 버전과의 호환성을 위해 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1ed151ede62f70799b920d57a42f17bd5fb2581" translate="yes" xml:space="preserve">
          <source>Tuples can have more than two parts, in fact as many parts as you want, and contain any valid Erlang &lt;strong&gt;term&lt;/strong&gt;. For example, to represent the temperature of various cities of the world:</source>
          <target state="translated">튜플은 실제로 원하는 수의 부품을 두 개 이상 가질 수 있으며 유효한 Erlang &lt;strong&gt;항을&lt;/strong&gt; 포함 할 수 있습니다 . 예를 들어 세계 여러 도시의 온도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef0f5b8ef4ff33f41dc26081793feb3c120d0be9" translate="yes" xml:space="preserve">
          <source>Tuples have a fixed number of items in them. Each item in a tuple is called an &lt;strong&gt;element&lt;/strong&gt;. In the tuple &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt;, element 1 is &lt;code&gt;moscow&lt;/code&gt; and element 2 is &lt;code&gt;{c,-10}&lt;/code&gt;. Here &lt;code&gt;c&lt;/code&gt; represents Celsius and &lt;code&gt;f&lt;/code&gt; Fahrenheit.</source>
          <target state="translated">튜플에는 고정 된 개수의 항목이 있습니다. 튜플의 각 항목을 &lt;strong&gt;요소&lt;/strong&gt; 라고합니다 . 튜플 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 에서 요소 1은 &lt;code&gt;moscow&lt;/code&gt; 이고 요소 2는 &lt;code&gt;{c,-10}&lt;/code&gt; 입니다. 여기서 &lt;code&gt;c&lt;/code&gt; 섭씨 나타내고 &lt;code&gt;f&lt;/code&gt; 를 화씨.</target>
        </trans-unit>
        <trans-unit id="6af244d55aef38e6c2274514e3d2ab60c94ed28b" translate="yes" xml:space="preserve">
          <source>Tuples in the template express if-exist tests for metadata keys. For example, the following tuple says that if &lt;code&gt;key1&lt;/code&gt; exists in the metadata map, print &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the value that &lt;code&gt;key1&lt;/code&gt; is associated with in the metadata map. If &lt;code&gt;key1&lt;/code&gt; does not exist, print nothing.</source>
          <target state="translated">템플릿의 튜플은 메타 데이터 키에 대한 기존 테스트를 나타냅니다. 예를 들어, 다음 튜플은 &lt;code&gt;key1&lt;/code&gt; 이 메타 데이터 맵에 존재 하는 경우 &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt; 를 인쇄합니다 . 여기서 &lt;code&gt;Value&lt;/code&gt; 는 &lt;code&gt;key1&lt;/code&gt; 이 메타 데이터 맵에서 연관된 값입니다 . 경우 &lt;code&gt;key1&lt;/code&gt; 존재하지 않는, 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243da839e833dcd6a7348ba4d1efa268f8e8a3ec" translate="yes" xml:space="preserve">
          <source>Tuples, maps, and lists (except strings, see below) are built in reverse polish notation, so that to build a tuple, the elements are specified first, and then the tuple term, with a count. Likewise for lists and maps.</source>
          <target state="translated">튜플, 맵 및 목록 (문자열 제외, 아래 참조)은 리버스 폴리쉬 표기법으로 빌드되므로 튜플을 빌드하기 위해 요소가 먼저 지정된 다음 튜플 용어가 개수와 함께 지정됩니다. 목록과지도도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8d71459c65d809aa4497f4a28bfc896fb1085c9c" translate="yes" xml:space="preserve">
          <source>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt;. If the input is already a template, it is not modified further.</source>
          <target state="translated">구문 트리 나 트리 목록을 템플릿으로 바꿉니다. &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 템플릿을 인스턴스화하거나 일치시키고 일반 구문 트리로 되돌릴 수 있습니다 . 입력이 이미 템플릿 인 경우 더 이상 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8971cba7199bca87b23c2ec538c7121c59edc40" translate="yes" xml:space="preserve">
          <source>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., &lt;code&gt;_@Foo&lt;/code&gt; in the template becomes the variable &lt;code&gt;Foo&lt;/code&gt; in the meta-template. Furthermore, variables ending with &lt;code&gt;@&lt;/code&gt; are automatically wrapped in a call to merl:term/1, so e.g. &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; in the meta-template.</source>
          <target state="translated">템플릿을 템플릿을 나타내는 구문 트리로 바꿉니다. 템플릿의 메타 변수는 이름 (메타 변수 접두사 문자 뒤)이 대문자로 시작하면 일반 얼랭 변수로 바뀝니다. 예를 들어 템플릿의 &lt;code&gt;_@Foo&lt;/code&gt; 는 메타 템플릿 의 변수 &lt;code&gt;Foo&lt;/code&gt; 가됩니다 . 또한 &lt;code&gt;@&lt;/code&gt; 로 끝나는 변수 는 merl : term / 1을 호출 할 때 자동으로 래핑되므로 &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; 는 메타 템플릿에서 `merl : term (Foo)가 됩니다.</target>
        </trans-unit>
        <trans-unit id="f11fdfc294615cd6feba1dc471497bd296595a74" translate="yes" xml:space="preserve">
          <source>Turn an error reason returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; into a readable string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 반환 한 오류 이유를 읽을 수있는 문자열로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0a32475174f92b9fb2f8542dc37a90aaa235a8d8" translate="yes" xml:space="preserve">
          <source>Turn off monitoring of the SNMP manager.</source>
          <target state="translated">SNMP 관리자의 모니터링을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="1596e715102816d11edb68278af146f787525ee2" translate="yes" xml:space="preserve">
          <source>Turn on and pare down debugging</source>
          <target state="translated">디버깅 설정 및 해제</target>
        </trans-unit>
        <trans-unit id="8d0273b96fc2970b3bd22f825df50106f57a4d5f" translate="yes" xml:space="preserve">
          <source>Turn on distribution tracing on the Erlang node.</source>
          <target state="translated">Erlang 노드에서 분배 추적을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="4b6673d76d88179b888141748a220ac4df22b7da" translate="yes" xml:space="preserve">
          <source>Turn on global tracing</source>
          <target state="translated">글로벌 추적 사용</target>
        </trans-unit>
        <trans-unit id="b5fd46c0414339fbc6a9a1e9bcad5db789cc32cf" translate="yes" xml:space="preserve">
          <source>Turning the scrollable_cursors option off is noted to make old odbc-drivers able to connect that will otherwhise fail.</source>
          <target state="translated">scrollable_cursors 옵션을 끄면 오래된 odbc 드라이버를 연결하여 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3754a20c309fb4bee5151fc9185df3eb19690cf" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;Expr&lt;/code&gt; into a &quot;test object&quot;, by wrapping it in a fun-expression and a source line number. Technically, this is the same as &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt;.</source>
          <target state="translated">켜 &lt;code&gt;Expr&lt;/code&gt; 재미있는 표현과 소스 줄 번호에 포장하여, &quot;테스트 개체&quot;로. 기술적으로 이것은 &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f90beb2441a8b6db181aba2d7f261f9f114ad008" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the net kernel was started using &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;{error, not_allowed}&lt;/code&gt; is returned. Returns &lt;code&gt;{error, not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">분산 노드를 비 분산 노드로 전환합니다. 네트워크의 다른 노드의 경우 이는 노드가 다운되는 것과 같습니다. net 커널이 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 시작된 경우에만 가능합니다 . 그렇지 않으면 &lt;code&gt;{error, not_allowed}&lt;/code&gt; 가 리턴됩니다. 로컬 노드가 &lt;code&gt;{error, not_found}&lt;/code&gt; 가 아닌 경우 {error, not_found}를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d9857baf63bd4ff78f8a1416e9cce2328191833c" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node by starting &lt;code&gt;net_kernel&lt;/code&gt; and other necessary processes.</source>
          <target state="translated">&lt;code&gt;net_kernel&lt;/code&gt; 및 기타 필요한 프로세스를 시작하여 비 분산 노드를 분산 노드로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="3f5c74d445a6ff38a1d1a5a031b9bc86b2fedd78" translate="yes" xml:space="preserve">
          <source>Turns a parsed dictionary, as returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt;, back into the dictionary format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 에서 반환 한 구문 분석 된 사전을 사전 형식으로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="e92b0eef302a90ddf93e3d3b8a0765906432d6ac" translate="yes" xml:space="preserve">
          <source>Turns an ordered list &lt;code&gt;List&lt;/code&gt; of key-value tuples into a tree. The list must not contain duplicate keys.</source>
          <target state="translated">정렬 된 목록 키-값 튜플 &lt;code&gt;List&lt;/code&gt; 을 트리로 바꿉니다. 이 목록에는 중복 키가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="8629e653fd2bdd0ad7cbe844c08311477772efcc" translate="yes" xml:space="preserve">
          <source>Turns an ordered-set list &lt;code&gt;List&lt;/code&gt; into a set. The list must not contain duplicates.</source>
          <target state="translated">정렬 된 세트리스트 켜 &lt;code&gt;List&lt;/code&gt; 세트로. 목록에는 중복 항목이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9373344ff9c8b8d02dd03592aeaf47c2fd0e64a6" translate="yes" xml:space="preserve">
          <source>Turns off all debugging for the process. This includes functions that are installed explicitly with function &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt;, for example, triggers.</source>
          <target state="translated">프로세스에 대한 모든 디버깅을 끕니다. 여기에는 &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt; 기능으로 명시 적으로 설치된 기능 ( 예 : 트리거)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d36edf7582655f75400ba16943847aa4c6aa0271" translate="yes" xml:space="preserve">
          <source>Turns off warnings for &quot;fresh&quot; variables in functional objects or list comprehensions with the same name as some already defined variable. Default is to emit warnings for such variables.</source>
          <target state="translated">기능 객체의 &quot;새로 고침&quot;변수에 대한 경고를 끄거나 이미 정의 된 변수와 이름이 같은 목록 이해를 표시합니다. 이러한 변수에 대한 기본값은 경고입니다.</target>
        </trans-unit>
        <trans-unit id="c093c691688f1f921a86e4bb9a9da3d6975d7358" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions like &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; does, but only for the mentioned functions. &lt;code&gt;MFAs&lt;/code&gt; is a tuple &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">&lt;code&gt;nowarn_deprecated_function&lt;/code&gt; 과 같이 더 이상 사용되지 않는 함수 호출에 대한 경고를 끄지 만 언급 된 함수에 대해서만 경고를 끕니다 . &lt;code&gt;MFAs&lt;/code&gt; 는 튜플 &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; 또는 이러한 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="31c129b33c46ffb547299340b27a43f495c00d43" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions. Default is to emit warnings for every call to a function known by the compiler to be deprecated. Notice that the compiler does not know about attribute &lt;code&gt;-deprecated()&lt;/code&gt;, but uses an assembled list of deprecated functions in Erlang/OTP. To do a more general check, the Xref tool can be used. See also &lt;code&gt;xref(3)&lt;/code&gt; and the function &lt;code&gt;xref:m/1&lt;/code&gt;, also accessible through the function &lt;code&gt;c:xm/1&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 함수 호출에 대한 경고를 끕니다. 기본값은 컴파일러가 사용하지 않는 것으로 알려진 함수를 호출 할 때마다 경고를 표시하는 것입니다. 컴파일러는 속성 &lt;code&gt;-deprecated()&lt;/code&gt; 에 대해 알지 못하지만 Erlang / OTP에서 더 이상 사용되지 않는 함수의 조합 된 목록을 사용합니다. 보다 일반적인 점검을 위해 외부 참조 도구를 사용할 수 있습니다. 참고 &lt;code&gt;xref(3)&lt;/code&gt; 와 기능 &lt;code&gt;xref:m/1&lt;/code&gt; , 기능을 통해 또한 액세스 &lt;code&gt;c:xm/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8643ee4d5408ecde9d2dfad0ec79316bb062403" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to old type testing BIFs, such as &lt;code&gt;pid/1&lt;/code&gt; and &lt;code&gt;list/1&lt;/code&gt;. See the &lt;code&gt;Erlang Reference Manual&lt;/code&gt; for a complete list of type testing BIFs and their old equivalents. Default is to emit warnings for calls to old type testing BIFs.</source>
          <target state="translated">&lt;code&gt;pid/1&lt;/code&gt; 및 &lt;code&gt;list/1&lt;/code&gt; 과 같은 이전 유형 테스트 BIF에 대한 호출에 대한 경고를 끕니다 . 형식 테스트 BIF 및 이전 버전의 전체 목록은 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 을 참조 하십시오 . 기본값은 이전 유형 테스트 BIF 호출에 대한 경고를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="858be8f3bcf091fa061e46059bd3158726b548e6" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions like &lt;code&gt;nowarn_unused_function&lt;/code&gt; does, but only for the mentioned local functions. &lt;code&gt;FAs&lt;/code&gt; is a tuple &lt;code&gt;{Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">&lt;code&gt;nowarn_unused_function&lt;/code&gt; 과 같이 사용하지 않는 로컬 함수에 대한 경고를 끄고 언급 된 로컬 함수에 대해서만 경고를 끕니다 . &lt;code&gt;FAs&lt;/code&gt; 는 튜플 &lt;code&gt;{Name,Arity}&lt;/code&gt; 또는 이러한 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c5e54f68af28f7baa91e0a423d6d647a5b8f257e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions. Default is to emit warnings for all local functions that are not called directly or indirectly by an exported function. The compiler does not include unused local functions in the generated beam file, but the warning is still useful to keep the source code cleaner.</source>
          <target state="translated">사용하지 않는 로컬 기능에 대한 경고를 끕니다. 기본값은 내 보낸 함수에 의해 직접 또는 간접적으로 호출되지 않은 모든 로컬 함수에 대해 경고를 발생시키는 것입니다. 컴파일러는 생성 된 빔 파일에 사용되지 않은 로컬 함수를 포함하지 않지만 소스 코드를 깨끗하게 유지하는 데 여전히 경고가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8756279a371f2c74c71bfe9ea11d8fce882bd7ef" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused record types. Default is to emit warnings for unused locally defined record types.</source>
          <target state="translated">사용하지 않는 레코드 유형에 대한 경고를 끕니다. 기본적으로 사용되지 않는 로컬로 정의 된 레코드 유형에 대한 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40e660b8f492c229e1e8f807933c1bba4d2abc6f" translate="yes" xml:space="preserve">
          <source>Turns off warnings for use of deprecated types. Default is to emit warnings for every use of a type known by the compiler to be deprecated.</source>
          <target state="translated">더 이상 사용되지 않는 유형 사용에 대한 경고를 끕니다. 기본값은 컴파일러가 사용하지 않는 것으로 알려진 유형을 사용할 때마다 경고를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="176262640a2c391f662fb5a4f78d832cbe27740e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for uses of the &lt;code&gt;export_all&lt;/code&gt; option. Default is to emit a warning if option &lt;code&gt;export_all&lt;/code&gt; is also given.</source>
          <target state="translated">&lt;code&gt;export_all&lt;/code&gt; 옵션 사용에 대한 경고를 끕니다 . &lt;code&gt;export_all&lt;/code&gt; 옵션 도 제공된 경우 기본값은 경고를 표시하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="849c8f41403b31c687964c8f844bbdc3100c6d15" translate="yes" xml:space="preserve">
          <source>Turns on (if &lt;code&gt;How == true&lt;/code&gt;) or off (if &lt;code&gt;How == false&lt;/code&gt;) the trace flags in &lt;code&gt;FlagList&lt;/code&gt; for the process or processes represented by &lt;code&gt;PidPortSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PidPortSpec&lt;/code&gt; 로 표시되는 프로세스에 대해 &lt;code&gt;FlagList&lt;/code&gt; 의 추적 플래그를 켜거나 ( &lt;code&gt;How == true&lt;/code&gt; ) 끄십시오 ( &lt;code&gt;How == false&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="90d4fea9a9eccae1bb6537b80425ce163c0e0e56" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for all types of function calls. Trace messages are sent whenever any of the specified functions are called, regardless of how they are called. If flag &lt;code&gt;return_to&lt;/code&gt; is set for the process, a &lt;code&gt;return_to&lt;/code&gt; message is also sent when this function returns to its caller.</source>
          <target state="translated">모든 유형의 함수 호출에 대한 호출 추적을 켜거나 끕니다. 추적 메시지는 호출 방법에 관계없이 지정된 함수가 호출 될 때마다 전송됩니다. 플래그 경우 &lt;code&gt;return_to&lt;/code&gt; 이 과정을 위해 설정하는 &lt;code&gt;return_to&lt;/code&gt; 의 메시지는 호출자에 때이 함수가 반환 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9cdc9034760c5ba6cf5f548250769a126c6a5dc8" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for global function calls (that is, calls specifying the module explicitly). Only exported functions match and only global calls generate trace messages. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">글로벌 함수 호출 (즉, 모듈을 명시 적으로 지정하는 호출)에 대한 호출 추적을 켜거나 끕니다. 내 보낸 함수 만 일치하고 전역 호출 만 추적 메시지를 생성합니다. &lt;strong&gt;이것이 기본값&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbac06dc38fd14ffc69474d6cefe052fcc1e6496" translate="yes" xml:space="preserve">
          <source>Turns on or off meta-tracing for all types of function calls. Trace messages are sent to the tracer whenever any of the specified functions are called. If no tracer is specified, &lt;code&gt;self()&lt;/code&gt; is used as a default tracer process.</source>
          <target state="translated">모든 유형의 함수 호출에 대한 메타 추적을 켜거나 끕니다. 지정된 함수가 호출 될 때마다 추적 메시지가 추적 프로그램으로 전송됩니다. 추적자를 지정하지 않으면 &lt;code&gt;self()&lt;/code&gt; 가 기본 추적 프로그램 프로세스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a9e6071c635a8a8f47c7128d5e27fbe6794aa8" translate="yes" xml:space="preserve">
          <source>Turns on or off scheduler wall time measurements.</source>
          <target state="translated">스케줄러 월 시간 측정을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="6491707b6fbdad098acea3fe30f8bc3c9caeff41" translate="yes" xml:space="preserve">
          <source>Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.</source>
          <target state="translated">소액 회계 계산 측정을 켜거나 끕니다. 재설정을 통과하면 모든 카운터가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="49209b989e6c3ee063b36215b5a4316a9a7be144" translate="yes" xml:space="preserve">
          <source>Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is &lt;code&gt;AF_INET6&lt;/code&gt;).</source>
          <target state="translated">IPv4 주소를 IPv6 주소로 자동 매핑을 해제합니다 (소켓 주소 패밀리가 &lt;code&gt;AF_INET6&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="f85ecd85cea1de6466fad134e2d2f8f716405e71" translate="yes" xml:space="preserve">
          <source>Turns on|off the Nagle algorithm for merging small packets into larger ones. This improves throughput at the expense of latency.</source>
          <target state="translated">작은 패킷을 큰 패킷으로 병합하기위한 Nagle 알고리즘을 켭니다. 이는 대기 시간을 희생하여 처리량을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1f9ac44326e752574b33a1f14907aa1c45d24f1" translate="yes" xml:space="preserve">
          <source>Turns the logging of system events on or off. If on, a maximum of &lt;code&gt;N&lt;/code&gt; events are kept in the debug structure (default is 10).</source>
          <target state="translated">시스템 이벤트 로깅을 켜거나 끕니다. 설정하면 최대 &lt;code&gt;N&lt;/code&gt; 개의 이벤트가 디버그 구조에 유지됩니다 (기본값은 10).</target>
        </trans-unit>
        <trans-unit id="23c458441c0867d8269280b70644bb94df142cbd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are supported:</source>
          <target state="translated">두 가지 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6e3d52e5b54fd0236c6fd5f3a13294fee0ddff15" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;code&gt;match&lt;/code&gt; if they are of the same type and have the same value, so that &lt;code&gt;1&lt;/code&gt; matches &lt;code&gt;1&lt;/code&gt;, but not &lt;code&gt;1.0&lt;/code&gt; (as &lt;code&gt;1.0&lt;/code&gt; is a &lt;code&gt;float()&lt;/code&gt; and not an &lt;code&gt;integer()&lt;/code&gt;).</source>
          <target state="translated">두 얼랑 용어 &lt;code&gt;match&lt;/code&gt; 가 동일한 유형이고 같은 값이 있다면, 그래서 &lt;code&gt;1&lt;/code&gt; 경기 &lt;code&gt;1&lt;/code&gt; 있지만 &lt;code&gt;1.0&lt;/code&gt; (AS &lt;code&gt;1.0&lt;/code&gt; A는 &lt;code&gt;float()&lt;/code&gt; 아닌 &lt;code&gt;integer()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d09b25abb2a2cc4ca463f856d47434d8b27efd72" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;strong&gt;compare equal&lt;/strong&gt; if they either are of the same type and value, or if both are numeric types and extend to the same value, so that &lt;code&gt;1&lt;/code&gt; compares equal to both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">두 얼랑 용어는 &lt;strong&gt;동일한 비교&lt;/strong&gt; 가하거나 동일한 유형 및 값 인 경우, 또는 모두가 수치 형이며 따라서, 동일한 값으로 확장하는 경우 있음 &lt;code&gt;1&lt;/code&gt; 모두 동일한 비교 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe9db2aa68d2fec9c04e8f17ebd9155b9b06ccb7" translate="yes" xml:space="preserve">
          <source>Two adjacent &lt;code&gt;*&lt;/code&gt; used as a single pattern match all files and zero or more directories and subdirectories.</source>
          <target state="translated">단일 패턴으로 사용되는 두 개의 인접한 &lt;code&gt;*&lt;/code&gt; 는 모든 파일과 0 개 이상의 디렉토리 및 하위 디렉토리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b24fbae83d83ea5cfa4199071718c20f64dd2575" translate="yes" xml:space="preserve">
          <source>Two adjacent string literals are concatenated into one. This is done in the compilation, thus, does not incur any runtime overhead.</source>
          <target state="translated">두 개의 인접한 문자열 리터럴이 하나로 연결됩니다. 이는 컴파일에서 수행되므로 런타임 오버 헤드가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cec8b2ac60b473ad30ad5a9539e9b27a87fdf3d" translate="yes" xml:space="preserve">
          <source>Two are containers for binary data and are called:</source>
          <target state="translated">이진 데이터를위한 컨테이너는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00afe0b16fc4b5dc8fb5d2b5e5c18c2ad4f6f71e" translate="yes" xml:space="preserve">
          <source>Two are merely references to a part of a binary and are called:</source>
          <target state="translated">두 개는 이진의 일부에 대한 참조 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="98533a56936d4841968d6378e92444f0f102a983" translate="yes" xml:space="preserve">
          <source>Two cases can occur:</source>
          <target state="translated">두 가지 경우가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f177120050db74caa4e744ec6cff39212557e9" translate="yes" xml:space="preserve">
          <source>Two different methods for opening a connection using the support functions in, for example, &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; follows:</source>
          <target state="translated">지원 기능을 사용하여 연결을 여는 두 가지 방법 (예 : &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8398755c3e867c12fc5deb0d9e53ba2d8bf52d0" translate="yes" xml:space="preserve">
          <source>Two different names cannot define the same OBJECT IDENTIFIER.</source>
          <target state="translated">서로 다른 두 이름으로 동일한 개체 ID를 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e330ec8353880267f056d94838df302f660f82d1" translate="yes" xml:space="preserve">
          <source>Two formats of the log files are supported:</source>
          <target state="translated">두 가지 형식의 로그 파일이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a4eef9b92d56df50918b227071f569535a9d01e3" translate="yes" xml:space="preserve">
          <source>Two forms have special meaning:</source>
          <target state="translated">두 가지 형태는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd82c68ad98788490ce7310efdb097df7571def" translate="yes" xml:space="preserve">
          <source>Two forms of &lt;code&gt;--inherits&lt;/code&gt; have special meaning:</source>
          <target state="translated">두 가지 형태의 &lt;code&gt;--inherits&lt;/code&gt; 은 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7200659e5edf764a36bafabfdd35b2bc1867bbcb" translate="yes" xml:space="preserve">
          <source>Two functions (modules, applications, releases) belong to the same strongly connected component if they call each other (in)directly. The interpretation of the &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; operator is the set of strongly connected components of a set of calls. The &lt;code&gt;condensation&lt;/code&gt; of a set of calls is a new set of calls between the strongly connected components such that there is an edge between two components if there is some constant of the first component that calls some constant of the second component.</source>
          <target state="translated">두 개의 기능 (모듈, 응용 프로그램, 릴리스)은 서로 직접 호출하는 경우 동일한 강력하게 연결된 구성 요소에 속합니다. &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; 연산자에 대한 해석은 일련의 통화 집합에 강력하게 연결된 구성 요소 집합입니다. 일련의 호출 의 &lt;code&gt;condensation&lt;/code&gt; 은 강력하게 연결된 구성 요소 사이의 새로운 호출 집합이므로 두 번째 구성 요소의 일부 상수를 호출하는 첫 번째 구성 요소의 상수가있는 경우 두 구성 요소 사이에 가장자리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8330baa5a8c7712027a0d478bca1ae0572b758a5" translate="yes" xml:space="preserve">
          <source>Two guard BIFs handle maps:</source>
          <target state="translated">두 개의 가드 BIF가 맵을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0b0d7874fec4ed30ad6e8758caa4fe777cac7d9b" translate="yes" xml:space="preserve">
          <source>Two interoperability mechanisms are built into the Erlang runtime system, &lt;strong&gt;distributed Erlang&lt;/strong&gt; and &lt;strong&gt;ports&lt;/strong&gt;. A variation of ports is &lt;strong&gt;linked-in drivers&lt;/strong&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에는 두 가지 상호 운용성 메커니즘 인 &lt;strong&gt;분산 Erlang&lt;/strong&gt; 및 &lt;strong&gt;포트&lt;/strong&gt; 가 내장되어 &lt;strong&gt;있습니다&lt;/strong&gt; . 포트의 변형은 &lt;strong&gt;링크 된 드라이버&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5dedccf2b4c340ae3513b7f5da6ce218b6889bec" translate="yes" xml:space="preserve">
          <source>Two keys are considered equal if they match (&lt;code&gt;=:=&lt;/code&gt;). That is, numbers are compared literally rather than by value, so that, for example, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; are different keys.</source>
          <target state="translated">두 개의 키가 일치하면 ( &lt;code&gt;=:=&lt;/code&gt; ) 동일한 것으로 간주됩니다 . 즉, 숫자는 값이 아닌 문자 그대로 비교되므로 예를 들어 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;1.0&lt;/code&gt; 은 다른 키입니다.</target>
        </trans-unit>
        <trans-unit id="211827ea828fd59c26ecf8cc7423a3ab35588d32" translate="yes" xml:space="preserve">
          <source>Two methods are available for writing database queries:</source>
          <target state="translated">데이터베이스 쿼리 작성에 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad65263f8565f810c97115c267d8c4735088c82" translate="yes" xml:space="preserve">
          <source>Two more examples, both selecting Latin-1 as default encoding:</source>
          <target state="translated">기본 인코딩으로 Latin-1을 선택하는 두 가지 예 :</target>
        </trans-unit>
        <trans-unit id="310abdb2aa2e0aae49bd84e931c4347743cefcc7" translate="yes" xml:space="preserve">
          <source>Two old applications are of interest regarding interoperability. Both have been replaced by IC and are mentioned here for reference only:</source>
          <target state="translated">상호 운용성과 관련하여 두 가지 이전 응용 프로그램이 중요합니다. 둘 다 IC로 대체되었으며 참조 용으로 만 여기에 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ee15f30d25e865ebb91626574306b0a361ae12" translate="yes" xml:space="preserve">
          <source>Two processes can be &lt;strong&gt;linked&lt;/strong&gt; to each other. A link between two processes &lt;code&gt;Pid1&lt;/code&gt; and &lt;code&gt;Pid2&lt;/code&gt; is created by &lt;code&gt;Pid1&lt;/code&gt; calling the BIF &lt;code&gt;link(Pid2)&lt;/code&gt; (or conversely). There also exist a number of &lt;code&gt;spawn_link&lt;/code&gt; BIFs, which spawn and link to a process in one operation.</source>
          <target state="translated">두 프로세스가 서로 &lt;strong&gt;연결될&lt;/strong&gt; 수 있습니다 . 두 프로세스 간의 링크 &lt;code&gt;Pid1&lt;/code&gt; 및 &lt;code&gt;Pid2&lt;/code&gt; 에 의해 생성된다 &lt;code&gt;Pid1&lt;/code&gt; BIF의 전화 &lt;code&gt;link(Pid2)&lt;/code&gt; (또는 역으로). 또한 한 번의 작업으로 프로세스를 생성하고 연결 하는 많은 &lt;code&gt;spawn_link&lt;/code&gt; BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5608c70162089e189da4df1a1b5bf134008a262e" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal iff they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 개의 자원 용어는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 로 전달 될 때 동일한 자원 객체 포인터를 생성 할 경우 동일한 비교를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="af30a2501d3290d8d47d226b3a9dd6e2917631b1" translate="yes" xml:space="preserve">
          <source>Two sets are &lt;strong id=&quot;disjoint&quot;&gt;disjoint&lt;/strong&gt; if their intersection is the empty set.</source>
          <target state="translated">교차점이 빈 세트이면 두 세트가 &lt;strong id=&quot;disjoint&quot;&gt;분리&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ebc9faf237e0b7af0081118908fcbec68ae6ca" translate="yes" xml:space="preserve">
          <source>Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">메타 문자의 두 세트가 존재합니다. 대괄호를 제외하고 패턴의 모든 위치에서 인식되는 문자와 대괄호 내에서 인식되는 메타 문자입니다. 대괄호 외부에서 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca80cfab8caa7daafc007467d281bddd65b58bec" translate="yes" xml:space="preserve">
          <source>Two simple implementation(s) is provided with the toolkit; the modules &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; which is the default and &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">툴킷에는 두 가지 간단한 구현이 제공됩니다. &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; 모듈 이며 기본값은 &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8aad91307995a202add0f48ff4e5e1745721276" translate="yes" xml:space="preserve">
          <source>Two subterms are supported, &lt;code&gt;node_start&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;node_start&lt;/code&gt; 및 &lt;code&gt;eval&lt;/code&gt; 의 두 가지 하위 용어가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a86bc9ecf16a74feace03ab8af025d243363cf6" translate="yes" xml:space="preserve">
          <source>Two terms &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; compare equal if &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. They match if &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 두 항 &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 가 동일하게 비교됩니다 . &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="319ab96ab6a94c595bf510dc2b6df202a2c7e4fb" translate="yes" xml:space="preserve">
          <source>Two time types are defined within ASN.1: Generalized Time and Universal Time Coordinated (UTC). Both are assigned a value as an ordinary string within double quotes, for example, &quot;19820102070533.8&quot;.</source>
          <target state="translated">ASN.1에는 두 가지 시간 유형이 정의되어 있습니다 : 일반화 시간 및 표준시 (UTC). 둘 다 큰 따옴표 안에 일반 문자열로 값이 지정됩니다 (예 : &quot;19820102070533.8&quot;).</target>
        </trans-unit>
        <trans-unit id="5cbed6cd9f648062eb5c7c60f1a880bc94c83866" translate="yes" xml:space="preserve">
          <source>Two trace drivers are currently implemented, the &lt;code&gt;file&lt;/code&gt; and the &lt;code&gt;ip&lt;/code&gt; trace drivers. The file driver sends all trace messages into one or several binary files, from where they later can be fetched and processed with the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; function. The ip driver opens a TCP/IP port where it listens for connections. When a client (preferably started by calling &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; on another Erlang node) connects, all trace messages are sent over the IP network for further processing by the remote client.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 과 &lt;code&gt;ip&lt;/code&gt; 추적 드라이버 라는 두 가지 추적 드라이버가 현재 구현되어 있습니다. 파일 드라이버는 모든 추적 메시지를 하나 또는 여러 개의 이진 파일로 전송합니다.이 파일은 나중에 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 함수 로 페치 및 처리 할 수 ​​있습니다 . ip 드라이버는 TCP / IP 포트를 열어 연결을 수신합니다. 클라이언트 ( 다른 Erlang 노드에서 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 시작하는 것이 바람직 함 )가 연결되면 원격 클라이언트가 추가 처리 할 수 ​​있도록 모든 추적 메시지가 IP 네트워크를 통해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c70732f422ad9f7dd9ec37500b2c8c51a72ca7dd" translate="yes" xml:space="preserve">
          <source>Two types of funs have slightly different semantics:</source>
          <target state="translated">두 가지 유형의 재미에는 의미가 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c611be8ba1da86ea53fc2e7c1dde0be77787929a" translate="yes" xml:space="preserve">
          <source>Two types of logs are supported:</source>
          <target state="translated">두 가지 유형의 로그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="95838f01360f14fad0ac2ded66819bb7c9468ffa" translate="yes" xml:space="preserve">
          <source>Two upgrade instructions restart the emulator:</source>
          <target state="translated">두 가지 업그레이드 지침이 에뮬레이터를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4806b67c077ea8929e31609963501c8a6fe89444" translate="yes" xml:space="preserve">
          <source>Two values are supported for &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; 에는 두 가지 값이 지원됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
