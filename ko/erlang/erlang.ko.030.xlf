<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="6279ffa4297b30182dc5202b001cb1dfc83a3bb5" translate="yes" xml:space="preserve">
          <source>Strategy: Find the block with the lowest address satisfying the requested block size.</source>
          <target state="translated">전략 : 요청 된 블록 크기를 만족하는 가장 낮은 주소의 블록을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="fd04785e47c956a9f5fba602264a5dd14a34605a" translate="yes" xml:space="preserve">
          <source>Strategy: Find the smallest block satisfying the requested block size.</source>
          <target state="translated">전략 : 요청 된 블록 크기를 만족하는 가장 작은 블록을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="44a887b6549779200c93196b47117dc9e9fd22f9" translate="yes" xml:space="preserve">
          <source>Strategy: Find the smallest block satisfying the requested block size. If multiple blocks are found, choose the one with the lowest address.</source>
          <target state="translated">전략 : 요청 된 블록 크기를 만족하는 가장 작은 블록을 찾으십시오. 여러 블록이 발견되면 가장 낮은 주소를 가진 블록을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="657b8318e9423de7a8d3e2e9ef2f190f7d6a01fe" translate="yes" xml:space="preserve">
          <source>Strategy: Try to find the best fit, but settle for the best fit found during a limited search.</source>
          <target state="translated">전략 : 가장 적합한 것을 찾으십시오. 그러나 제한된 검색 중에 찾은 가장 적합한 것을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="5fcdff9196474123b66108d821dc8c835b72a528" translate="yes" xml:space="preserve">
          <source>Stream number (0-base) within the association to send the messages through;</source>
          <target state="translated">메시지를 전송하기 위해 연관 내의 스트림 번호 (0-base);</target>
        </trans-unit>
        <trans-unit id="032322e337daa5362eff97379f0768caa1c4a70b" translate="yes" xml:space="preserve">
          <source>Stream,</source>
          <target state="translated">Stream,</target>
        </trans-unit>
        <trans-unit id="14c7fe8eb4bedf847bae92f16bee1373dae3ee7d" translate="yes" xml:space="preserve">
          <source>Streams the body of a 200 or 206 response to the calling process or to a file. When streaming to the calling process using option &lt;code&gt;self&lt;/code&gt;, the following stream messages are sent to that process: &lt;code&gt;{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}}&lt;/code&gt;.</source>
          <target state="translated">200 또는 206 응답의 본문을 호출 프로세스 또는 파일로 스트리밍합니다. &lt;code&gt;self&lt;/code&gt; 옵션을 사용하여 호출 프로세스로 스트리밍하면 &lt;code&gt;{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}}&lt;/code&gt; 같은 스트림 메시지가 해당 프로세스로 전송됩니다. , stream_end, 헤더}} .</target>
        </trans-unit>
        <trans-unit id="9a376bfef88f4a5837ec22e75ca9bb2ad71a85ca" translate="yes" xml:space="preserve">
          <source>Strict version control, i.e. when a message is received, verify that the version is that which was negotiated.</source>
          <target state="translated">엄격한 버전 제어 (예 : 메시지 수신시) 버전이 협상 된 버전인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="48c954c05304b9e81c5d975679386755a836c64c" translate="yes" xml:space="preserve">
          <source>Strictly as it appears in the &lt;code&gt;boot script&lt;/code&gt;, or</source>
          <target state="translated">&lt;code&gt;boot script&lt;/code&gt; 에 표시된대로 엄격하게 또는</target>
        </trans-unit>
        <trans-unit id="9c8e1fe6c3b86d4950a4f14e9e1b7a58807d6feb" translate="yes" xml:space="preserve">
          <source>Strictly monotonically increasing values are inherently quite expensive to generate and scales poorly. This is because the values need to be synchronized between CPU cores. That is, do not pass the &lt;code&gt;monotonic&lt;/code&gt; modifier unless you really need strictly monotonically increasing values.</source>
          <target state="translated">엄격하게 단조 증가하는 값은 본질적으로 생성하는 데 비용이 많이 들고 스케일이 잘못됩니다. CPU 코어간에 값을 동기화해야하기 때문입니다. 즉, 단조 증가하는 값이 꼭 필요한 경우가 아니면 &lt;code&gt;monotonic&lt;/code&gt; 수정자를 전달하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="34e63cef9636b51db449734a3cb5f4c085f07fd5" translate="yes" xml:space="preserve">
          <source>String (is the same as a list of integers)</source>
          <target state="translated">문자열 (정수 목록과 동일)</target>
        </trans-unit>
        <trans-unit id="d118085e29d4750504557a8145b47af2cb2659cf" translate="yes" xml:space="preserve">
          <source>String containing the user's password. Only used if the private keyfile is password-protected.</source>
          <target state="translated">사용자 비밀번호가 포함 된 문자열입니다. 개인 키 파일이 비밀번호로 보호 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59ef56804edeb88e3ae1bcc6b7e688b7402b030a" translate="yes" xml:space="preserve">
          <source>String does &lt;strong&gt;not&lt;/strong&gt; have a corresponding Erlang representation, but is an optimization for sending lists of bytes (integer in the range 0-255) more efficiently over the distribution. As field &lt;code&gt;Length&lt;/code&gt; is an unsigned 2 byte integer (big-endian), implementations must ensure that lists longer than 65535 elements are encoded as &lt;code&gt;&lt;a href=&quot;#LIST_EXT&quot;&gt;LIST_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 상응하는 얼랑 표현을 가지고 있지만, 유통을 통해보다 효율적으로 (0 ~ 255의 범위에서 정수) 바이트의 목록을 보내기위한 최적화입니다. 필드 &lt;code&gt;Length&lt;/code&gt; 는 부호없는 2 바이트 정수 (빅 엔디안)이므로 구현시 65535보다 긴 요소가 &lt;code&gt;&lt;a href=&quot;#LIST_EXT&quot;&gt;LIST_EXT&lt;/a&gt;&lt;/code&gt; 로 인코딩되도록 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="059d063f4edd2896cbea701659c169723f6c691b" translate="yes" xml:space="preserve">
          <source>String handling can be slow if done improperly. In Erlang, you need to think a little more about how the strings are used and choose an appropriate representation. If you use regular expressions, use the &lt;code&gt;re&lt;/code&gt; module in STDLIB instead of the obsolete &lt;code&gt;regexp&lt;/code&gt; module.</source>
          <target state="translated">잘못 처리하면 문자열 처리가 느려질 수 있습니다. Erlang에서는 문자열이 어떻게 사용되는지에 대해 조금 더 생각하고 적절한 표현을 선택해야합니다. 정규식을 사용하는 경우 사용되지 않는 &lt;code&gt;regexp&lt;/code&gt; 모듈 대신 STDLIB 에서 &lt;code&gt;re&lt;/code&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab7791e7c77db49941bf49b683f3c9df1fec0bac" translate="yes" xml:space="preserve">
          <source>String processing functions.</source>
          <target state="translated">문자열 처리 기능.</target>
        </trans-unit>
        <trans-unit id="7073c72847419cc61b613d7b0ddbaa7534b00711" translate="yes" xml:space="preserve">
          <source>String | Binary (configurable)</source>
          <target state="translated">문자열 | 이진 (구성 가능)</target>
        </trans-unit>
        <trans-unit id="74d55dbdca8b484ae2bf6a9ace6819676c736d3c" translate="yes" xml:space="preserve">
          <source>Strings are enclosed in double quotes (&quot;), but is not a data type in Erlang. Instead, a string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; is shorthand for the list &lt;code&gt;[$h,$e,$l,$l,$o]&lt;/code&gt;, that is, &lt;code&gt;[104,101,108,108,111]&lt;/code&gt;.</source>
          <target state="translated">문자열은 큰 따옴표 ( &quot;)로 묶지 만 Erlang의 데이터 유형은 아닙니다. 대신 문자열 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 는 목록 &lt;code&gt;[$h,$e,$l,$l,$o]&lt;/code&gt; 줄임말 입니다. , &lt;code&gt;[104,101,108,108,111]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38229828f5ce707e9c637d7e4f9c75370c8f2483" translate="yes" xml:space="preserve">
          <source>Strings in the template are printed literally.</source>
          <target state="translated">템플릿의 문자열은 그대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f9dab1696115bedd1587cdcd962fbaa87eb8dd52" translate="yes" xml:space="preserve">
          <source>Strings starting with &lt;code&gt;&quot;'@&lt;/code&gt;, for example &lt;code&gt;&quot;'@File&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;'@&lt;/code&gt; 시작하는 문자열 ( 예 &lt;code&gt;&quot;'@File&quot;&lt;/code&gt; &quot;'@ File &quot;</target>
        </trans-unit>
        <trans-unit id="57df87fb39970ecfe64667610e08517b0f8ba060" translate="yes" xml:space="preserve">
          <source>Strings, other than &lt;code&gt;&quot;Z&quot;&lt;/code&gt;, &lt;code&gt;&quot;z&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt;, must be on the form &lt;code&gt;&amp;plusmn;[hh]:[mm]&lt;/code&gt;, for example &lt;code&gt;&quot;-02:00&quot;&lt;/code&gt; or &lt;code&gt;&quot;+00:00&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;Z&quot;&lt;/code&gt; , &lt;code&gt;&quot;z&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이외의 문자열 은 &lt;code&gt;&amp;plusmn;[hh]:[mm]&lt;/code&gt; 형식이어야합니다 ( 예 &lt;code&gt;&quot;-02:00&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;+00:00&quot;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="b5570cbce59d54b3e8e89f954758052e0ea23cd1" translate="yes" xml:space="preserve">
          <source>Stub module files are created for those modules that are to be exported by the target module (see options &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;stubs&lt;/code&gt; and &lt;code&gt;stub_dir&lt;/code&gt;).</source>
          <target state="translated">스텁 모듈 파일은 대상 모듈에서 내보낼 모듈에 대해 작성됩니다 ( &lt;code&gt;export&lt;/code&gt; , &lt;code&gt;stubs&lt;/code&gt; 및 &lt;code&gt;stub_dir&lt;/code&gt; 옵션 참조 ).</target>
        </trans-unit>
        <trans-unit id="db2cf9d107c5a79e75ca3fa12c082098b033a749" translate="yes" xml:space="preserve">
          <source>Stub modules will automatically be created (see the &lt;code&gt;stubs&lt;/code&gt; and &lt;code&gt;stub_dir&lt;/code&gt; options below) for each module that is renamed. These can be used to redirect any calls still using the old module names. The stub files are created in the same directory as the source file (typically overwriting the original file).</source>
          <target state="translated">이름이 바뀐 각 모듈에 대해 스텁 모듈이 자동으로 작성됩니다 ( 아래 &lt;code&gt;stubs&lt;/code&gt; 및 &lt;code&gt;stub_dir&lt;/code&gt; 옵션 참조). 이전 모듈 이름을 사용하는 통화를 재전송하는 데 사용할 수 있습니다. 스텁 파일은 소스 파일과 동일한 디렉토리에 작성됩니다 (일반적으로 원본 파일을 겹쳐 씁니다).</target>
        </trans-unit>
        <trans-unit id="4ca257e1525674f4f984164e97623ebf24612def" translate="yes" xml:space="preserve">
          <source>Style sheets can also be installed on a per suite and per test case basis.</source>
          <target state="translated">스타일 시트는 스위트 및 테스트 사례별로 설치할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3cd3b3663e36b6010fa328e4878eaf1bb09c78" translate="yes" xml:space="preserve">
          <source>Sub-agents and dependencies</source>
          <target state="translated">서브 에이전트 및 종속성</target>
        </trans-unit>
        <trans-unit id="90d7d767804a80af239bef8ee766d71a4944c07e" translate="yes" xml:space="preserve">
          <source>Sub-agents are only needed if your application requires special support for distribution from the SNMP toolkit. A sub-agent can also be used if the application requires a more complex set transaction scheme than is found in the master agent.</source>
          <target state="translated">서브 에이전트는 응용 프로그램에 SNMP 툴킷에서 분배를위한 특별한 지원이 필요한 경우에만 필요합니다. 응용 프로그램이 마스터 에이전트에서 발견되는 것보다 더 복잡한 세트 트랜잭션 체계를 요구하는 경우 서브 에이전트를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5055cc4d96f14720694a56d07a68ee7980c81af5" translate="yes" xml:space="preserve">
          <source>Sub-agents are used for the following reasons:</source>
          <target state="translated">하위 에이전트는 다음과 같은 이유로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6045ebe7d947335fe83f7f64672894d696d0bd" translate="yes" xml:space="preserve">
          <source>Sub-agents can also have sub-agents. Each sub-agent can have an arbitrary number of child sub-agents registered, forming a hierarchy.</source>
          <target state="translated">하위 에이전트는 하위 에이전트를 가질 수도 있습니다. 각 하위 에이전트는 임의의 수의 하위 하위 에이전트를 등록하여 계층을 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac63ce8e1d74adcfdfbe2ca29ab772206b57ae0" translate="yes" xml:space="preserve">
          <source>Subpatterns are delimited by parentheses (round brackets), which can be nested. Turning part of a pattern into a subpattern does two things:</source>
          <target state="translated">하위 패턴은 괄호 (둥글 대괄호)로 구분되며 중첩 될 수 있습니다. 패턴의 일부를 서브 패턴으로 바꾸는 것은 두 가지 일을합니다 :</target>
        </trans-unit>
        <trans-unit id="a820e243668b15a93364d75cb27a52bf2716a1a1" translate="yes" xml:space="preserve">
          <source>Subscribe to &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; messages from a service.</source>
          <target state="translated">서비스의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 메시지를 구독하십시오 .</target>
        </trans-unit>
        <trans-unit id="49f060764145c09021e9ae846a9e90442c5fb5e4" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for both visible and hidden nodes. The tuple &lt;code&gt;{node_type, visible | hidden}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">보이는 노드와 숨겨진 노드 모두에 대한 노드 상태 변경 메시지를 구독합니다. 튜플 &lt;code&gt;{node_type, visible | hidden}&lt;/code&gt; 이 &lt;code&gt;InfoList&lt;/code&gt; 에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="928a7f14face133bf1a5d5c5ab3ba7234d171192" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for hidden nodes only. The tuple &lt;code&gt;{node_type, hidden}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">숨겨진 노드에 대해서만 노드 상태 변경 메시지를 구독하십시오. 튜플 &lt;code&gt;{node_type, hidden}&lt;/code&gt; 은 &lt;code&gt;InfoList&lt;/code&gt; 에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e29b065f6418ba8f113a030561ebffc2353317d" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for visible nodes only. The tuple &lt;code&gt;{node_type, visible}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">보이는 노드에 대해서만 노드 상태 변경 메시지를 구독하십시오. 튜플 &lt;code&gt;{node_type, visible}&lt;/code&gt; 은 &lt;code&gt;InfoList&lt;/code&gt; 에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eeb3cfb3316bcf069c616fd3d9feb459ed3e566" translate="yes" xml:space="preserve">
          <source>Subscriptions are not triggered and no checkpoints are updated, but this operation is blindingly fast. Disc resident tables are not to be updated with the &lt;code&gt;ets&lt;/code&gt; function, as the disc is not updated.</source>
          <target state="translated">구독이 트리거되지 않고 체크 포인트가 업데이트되지 않지만이 작업은 맹목적으로 빠릅니다. 디스크가 업데이트되지 않기 때문에 디스크 상주 테이블은 &lt;code&gt;ets&lt;/code&gt; 기능으로 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="433c536aabeab0d4376379abd1511ea5ccc8273f" translate="yes" xml:space="preserve">
          <source>Subsequent calls to &lt;code&gt;allow/1&lt;/code&gt; will add the specified nodes to the list of allowed nodes. It is not possible to remove nodes from the list.</source>
          <target state="translated">&lt;code&gt;allow/1&lt;/code&gt; 에 대한 후속 호출 은 지정된 노드를 허용 된 노드 목록에 추가합니다. 목록에서 노드를 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b5948f4a8c2efd083dca1a5d8f87dd377c41053" translate="yes" xml:space="preserve">
          <source>Subsequent calls to this function overwrites previous data set. To update existing data instead of overwriting it, see &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 대한 후속 호출은 이전 데이터 세트를 겹쳐 씁니다. 기존 데이터를 덮어 쓰지 않고 업데이트하려면 &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b62f60ecebed480c0f7cf1234a4d74b31ff5ce6" translate="yes" xml:space="preserve">
          <source>Subsequently, these types can be used to specify types of record fields and also the argument and return types of functions.</source>
          <target state="translated">결과적으로 이러한 유형을 사용하여 레코드 필드 유형과 인수 및 리턴 유형 함수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb7698f2ce2f777969263d3a8ba0cef76e027f42" translate="yes" xml:space="preserve">
          <source>Subsets of test cases, called test case groups, can also be defined. A test case group can have execution properties associated with it. Execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is to be repeated. Test case groups can also be nested (that is, a group can, besides test cases, contain subgroups).</source>
          <target state="translated">테스트 사례 그룹이라고하는 테스트 사례의 하위 집합도 정의 할 수 있습니다. 테스트 케이스 그룹에는 연관된 실행 특성이있을 수 있습니다. 실행 속성은 그룹의 테스트 사례를 임의의 순서로, 병렬 또는 순서대로 실행할지 여부와 그룹의 실행을 반복할지 여부를 지정합니다. 테스트 사례 그룹을 중첩 할 수도 있습니다 (즉, 테스트 사례 외에 그룹에 하위 그룹을 포함 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2a8724dcdb51c1cfe957da926417b908e509eba3" translate="yes" xml:space="preserve">
          <source>Substitute metavariables in a pattern or list of patterns, yielding a syntax tree or list of trees as result. Both for normal metavariables and glob metavariables, the substituted value may be a single element or a list of elements. For example, if a list representing &lt;code&gt;1, 2, 3&lt;/code&gt; is substituted for &lt;code&gt;var&lt;/code&gt; in either of &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; or &lt;code&gt;[foo, _@var, bar]&lt;/code&gt;, the result represents &lt;code&gt;[foo, 1, 2, 3, bar]&lt;/code&gt;.</source>
          <target state="translated">패턴 또는 패턴 목록에서 메타 변수를 대체하여 구문 트리 또는 트리 목록을 생성합니다. 정규 메타 변수와 glob 메타 변수의 경우 대체 값은 단일 요소 또는 요소 목록 일 수 있습니다. 예를 들어, &lt;code&gt;1, 2, 3&lt;/code&gt; 나타내는 목록 이 &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; 또는 &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; 중 하나에서 &lt;code&gt;var&lt;/code&gt; 로 대체 되면 결과는 &lt;code&gt;[foo, 1, 2, 3, bar]&lt;/code&gt; 나타냅니다 . , 바] .</target>
        </trans-unit>
        <trans-unit id="05ffcb976452c5c75ac29c7a75347990e68c424b" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;%FINAL_ROOTDIR%&lt;/code&gt; and &lt;code&gt;%EMU%&lt;/code&gt; for &lt;code&gt;/usr/local/erl-target&lt;/code&gt; and &lt;code&gt;beam&lt;/code&gt;, respectively, in the files &lt;code&gt;erl.src&lt;/code&gt;, &lt;code&gt;start.src&lt;/code&gt;, and &lt;code&gt;start_erl.src&lt;/code&gt; of the target &lt;code&gt;erts-5.10.4/bin&lt;/code&gt; directory, and puts the resulting files &lt;code&gt;erl&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;run_erl&lt;/code&gt; in the target &lt;code&gt;bin&lt;/code&gt; directory.</source>
          <target state="translated">대체품 &lt;code&gt;%FINAL_ROOTDIR%&lt;/code&gt; 및 &lt;code&gt;%EMU%&lt;/code&gt; 대 &lt;code&gt;/usr/local/erl-target&lt;/code&gt; 과 &lt;code&gt;beam&lt;/code&gt; 각각의 파일에 &lt;code&gt;erl.src&lt;/code&gt; , &lt;code&gt;start.src&lt;/code&gt; 및 &lt;code&gt;start_erl.src&lt;/code&gt; 대상의 &lt;code&gt;erts-5.10.4/bin&lt;/code&gt; 디렉토리 및 결과 파일 &lt;code&gt;erl&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;run_erl&lt;/code&gt; 을 대상 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="bc3669ecd23d63b80d0c44dfa313091853f8eced" translate="yes" xml:space="preserve">
          <source>Substitutes keys of boolean-valued properties and simultaneously negates their values. For each entry in &lt;code&gt;ListIn&lt;/code&gt;, if it is associated with some key &lt;code&gt;K1&lt;/code&gt; such that &lt;code&gt;{K1, K2}&lt;/code&gt; occurs in &lt;code&gt;Negations&lt;/code&gt;: if the entry was &lt;code&gt;{K1, true}&lt;/code&gt;, it is replaced with &lt;code&gt;{K2, false}&lt;/code&gt;, otherwise with &lt;code&gt;{K2, true}&lt;/code&gt;, thus changing the name of the option and simultaneously negating the value specified by &lt;code&gt;&lt;a href=&quot;#get_bool-2&quot;&gt;get_bool(Key,ListIn)&lt;/a&gt;&lt;/code&gt;. If the same &lt;code&gt;K1&lt;/code&gt; occurs more than once in &lt;code&gt;Negations&lt;/code&gt;, only the first occurrence is used.</source>
          <target state="translated">부울 값 속성의 키를 대체하고 동시에 해당 값을 무시합니다. &lt;code&gt;ListIn&lt;/code&gt; 의 각 항목에 대해 일부 키 &lt;code&gt;K1&lt;/code&gt; 과 연관되어 &lt;code&gt;{K1, K2}&lt;/code&gt; 가 &lt;code&gt;Negations&lt;/code&gt; 에서 발생하는 경우 : 항목이 &lt;code&gt;{K1, true}&lt;/code&gt; &lt;code&gt;{K2, false}&lt;/code&gt; 로 대체되고 그렇지 않으면 &lt;code&gt;{K2, true}&lt;/code&gt; 이므로 옵션 이름을 변경하고 &lt;code&gt;&lt;a href=&quot;#get_bool-2&quot;&gt;get_bool(Key,ListIn)&lt;/a&gt;&lt;/code&gt; 의해 지정된 값을 동시에 무시합니다 . &lt;code&gt;Negations&lt;/code&gt; 에서 동일한 &lt;code&gt;K1&lt;/code&gt; 이 두 번 이상 발생하면 첫 번째 항목 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e27236324c145734276c060f10c3123a295b532" translate="yes" xml:space="preserve">
          <source>Substitutes keys of properties. For each entry in &lt;code&gt;ListIn&lt;/code&gt;, if it is associated with some key &lt;code&gt;K1&lt;/code&gt; such that &lt;code&gt;{K1, K2}&lt;/code&gt; occurs in &lt;code&gt;Aliases&lt;/code&gt;, the key of the entry is changed to &lt;code&gt;K2&lt;/code&gt;. If the same &lt;code&gt;K1&lt;/code&gt; occurs more than once in &lt;code&gt;Aliases&lt;/code&gt;, only the first occurrence is used.</source>
          <target state="translated">속성 키를 대체합니다. &lt;code&gt;ListIn&lt;/code&gt; 의 각 항목에 대해 &lt;code&gt;{K1, K2}&lt;/code&gt; 가 &lt;code&gt;Aliases&lt;/code&gt; 에서 발생 하도록 일부 키 &lt;code&gt;K1&lt;/code&gt; 과 연관되어 있으면 항목 의 키가 &lt;code&gt;K2&lt;/code&gt; 로 변경됩니다 . &lt;code&gt;Aliases&lt;/code&gt; 에서 동일한 &lt;code&gt;K1&lt;/code&gt; 이 두 번 이상 발생하면 첫 번째 항목 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42a8f651d79fd005eeac0612df6442b983a01184" translate="yes" xml:space="preserve">
          <source>Success</source>
          <target state="translated">Success</target>
        </trans-unit>
        <trans-unit id="80c7261dc13f63e8ac3c5ef932b61d4d0f95604d" translate="yes" xml:space="preserve">
          <source>Success | {error, term()}</source>
          <target state="translated">성공 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="8a0a4ea66889be40114ddfe9594dd7d12e174b44" translate="yes" xml:space="preserve">
          <source>Successful evaluations of the timer functions give return values containing a timer reference, denoted &lt;code&gt;TRef&lt;/code&gt;. By using &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;, the returned reference can be used to cancel any requested action. A &lt;code&gt;TRef&lt;/code&gt; is an Erlang term, which contents must not be changed.</source>
          <target state="translated">타이머 함수의 성공적인 평가는 &lt;code&gt;TRef&lt;/code&gt; 로 표시된 타이머 참조를 포함하는 리턴 값을 제공합니다 . &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 을 사용 하면 리턴 된 참조를 사용하여 요청 된 조치를 취소 할 수 있습니다. &lt;code&gt;TRef&lt;/code&gt; 내용을 변경할 수 없습니다되어야하는 얼랑 용어입니다.</target>
        </trans-unit>
        <trans-unit id="06863fc24f520b1140c18c4fa8cbe27b0b51428c" translate="yes" xml:space="preserve">
          <source>Such an application is called a &lt;strong&gt;distributed application&lt;/strong&gt;. Notice that it is the control of the application that is distributed. All applications can be distributed in the sense that they, for example, use services on other nodes.</source>
          <target state="translated">이러한 응용 프로그램을 &lt;strong&gt;분산 응용 프로그램&lt;/strong&gt; 이라고합니다 . 배포 된 응용 프로그램의 제어입니다. 예를 들어 다른 노드의 서비스를 사용한다는 의미에서 모든 응용 프로그램을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3074117af859e520c7cb63eb135640878edd509" translate="yes" xml:space="preserve">
          <source>Such an argument line must start with &lt;code&gt;%%!&lt;/code&gt; and the remaining line is interpreted as arguments to the emulator.</source>
          <target state="translated">이러한 인수 행은 &lt;code&gt;%%!&lt;/code&gt; 시작해야합니다 ! 나머지 줄은 에뮬레이터에 대한 인수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0798de14385866f626c39da2456b2b12c915aee8" translate="yes" xml:space="preserve">
          <source>Such code is difficult to read and understand, and errors occur if the numbering of the elements in the tuple is wrong. If the data representation of the fields is changed, by re-ordering, adding, or removing fields, all references to the person tuple must be checked and possibly modified.</source>
          <target state="translated">이러한 코드는 읽고 이해하기 어렵고 튜플의 요소 번호가 잘못되면 오류가 발생합니다. 필드의 순서를 바꾸거나 추가 또는 제거하여 필드의 데이터 표시가 변경되면 개인 튜플에 대한 모든 참조를 확인하고 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f433654caeb1dadceed6f988cc45cba92d4659f9" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for dirty CPU scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 40 kilowords.</source>
          <target state="translated">더티 CPU 스케줄러 스레드에 권장되는 스택 크기 (KB)입니다. 유효한 범위는 20-8192 킬로 워드입니다. 기본 제안 된 스택 크기는 40 킬로 워드입니다.</target>
        </trans-unit>
        <trans-unit id="af6be2dcf5716a0725659c157d5e2c536263c156" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for dirty IO scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 40 kilowords.</source>
          <target state="translated">더티 IO 스케줄러 스레드에 권장되는 스택 크기 (KB)입니다. 유효한 범위는 20-8192 킬로 워드입니다. 기본 제안 된 스택 크기는 40 킬로 워드입니다.</target>
        </trans-unit>
        <trans-unit id="bcf432451d4daca2de4246fc100508b99bcd1023" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 128 kilowords.</source>
          <target state="translated">스케줄러 스레드에 권장되는 스택 크기 (KB)입니다. 유효한 범위는 20-8192 킬로 워드입니다. 기본 제안 된 스택 크기는 128 킬로 워드입니다.</target>
        </trans-unit>
        <trans-unit id="b8bd14d1892c2129895ed57dfa2db4ceb46d0dc7" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for threads in the async thread pool. Valid range is 16-8192 kilowords. The default suggested stack size is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the number of async threads can be large. The default size is enough for drivers delivered with Erlang/OTP, but might not be large enough for other dynamically linked-in drivers that use the &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;driver_async()&lt;/a&gt;&lt;/code&gt; functionality. Notice that the value passed is only a suggestion, and it can even be ignored on some platforms.</source>
          <target state="translated">비동기 스레드 풀의 스레드에 권장되는 스택 크기 (킬로 워드)입니다. 유효한 범위는 16-8192 킬로 워드입니다. 기본 제안 된 스택 크기는 16 킬로 워드, 즉 32 비트 아키텍처에서 64 킬로바이트입니다. 비동기 스레드 수가 클 수 있으므로이 작은 기본 크기가 선택되었습니다. 기본 크기는 Erlang / OTP와 함께 제공되는 드라이버에는 충분하지만 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;driver_async()&lt;/a&gt;&lt;/code&gt; 기능 을 사용하는 다른 동적으로 링크 된 드라이버에는 충분하지 않을 수 있습니다 . 전달 된 값은 제안 일 뿐이며 일부 플랫폼에서는 무시 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da7ae3ce7097a50ecd686c674729f1c7303f10ff" translate="yes" xml:space="preserve">
          <source>Suite level configuration function, executed after the last test case. (Optional)</source>
          <target state="translated">마지막 테스트 사례 이후에 실행 된 스위트 레벨 구성 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="2b05185a141699c8f8fb351934189959847a1edf" translate="yes" xml:space="preserve">
          <source>Suite level configuration function, executed before the first test case. (Optional)</source>
          <target state="translated">첫 번째 테스트 케이스 전에 실행 된 스위트 레벨 구성 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="04518d1a0192d1131132db139b0e5008f6d17e70" translate="yes" xml:space="preserve">
          <source>Suite-related information is sent to the major log file.</source>
          <target state="translated">스위트 관련 정보는 주요 로그 파일로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a27f3edcde9ae36844a365f84f2f1240d62f6e" translate="yes" xml:space="preserve">
          <source>Suites (&lt;code&gt;*_SUITE.erl&lt;/code&gt;) files must be stored in &lt;code&gt;TestDir&lt;/code&gt; or &lt;code&gt;TestDir/test&lt;/code&gt;. All suites are compiled when the test is run.</source>
          <target state="translated">스위트 ( &lt;code&gt;*_SUITE.erl&lt;/code&gt; ) 파일은 &lt;code&gt;TestDir&lt;/code&gt; 또는 &lt;code&gt;TestDir/test&lt;/code&gt; 에 저장해야합니다 . 테스트가 실행될 때 모든 스위트가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="378fda76844d25f760b8a3232570c6811c1f60f2" translate="yes" xml:space="preserve">
          <source>Summary of options not previously described for function &lt;code&gt;run/3&lt;/code&gt;:</source>
          <target state="translated">함수 &lt;code&gt;run/3&lt;/code&gt; 에 대해 이전에 설명되지 않은 옵션 요약 :</target>
        </trans-unit>
        <trans-unit id="2270dca3d5a482193570efd95b8b721376d2e899" translate="yes" xml:space="preserve">
          <source>Summary of options:</source>
          <target state="translated">옵션 요약 :</target>
        </trans-unit>
        <trans-unit id="f1ea23086ee2ae5acc3750e0b83a8ad5e05aec73" translate="yes" xml:space="preserve">
          <source>Summary of the options:</source>
          <target state="translated">옵션 요약 :</target>
        </trans-unit>
        <trans-unit id="68214c5d6d790a263205249ceaedff42f792b42f" translate="yes" xml:space="preserve">
          <source>Summing the elements in a list and double them at the same time:</source>
          <target state="translated">목록에서 요소를 합산하고 동시에 두 배로 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="03121a488934e060630fcbde75ce3dedf8aac8f2" translate="yes" xml:space="preserve">
          <source>Sun's Java JDK 1.6.0 or later. Our Java code (jinterface, ic) is written for JDK 1.6.0. Get it for Windows and install it, the JRE is not enough. If you don't care about Java, you can skip this step. The result will be that jinterface is not built.</source>
          <target state="translated">Sun의 Java JDK 1.6.0 이상 Java 코드 (jinterface, ic)는 JDK 1.6.0 용으로 작성되었습니다. Windows 용으로 가져 와서 설치하십시오 .JRE로는 충분하지 않습니다. Java에 관심이 없으면이 단계를 건너 뛸 수 있습니다. 결과적으로 jinterface가 빌드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14bb55d7d7430a4e707657bbba24d20d9e03a1c8" translate="yes" xml:space="preserve">
          <source>Sundanese</source>
          <target state="translated">Sundanese</target>
        </trans-unit>
        <trans-unit id="80226badb4fe578fcd3821c9a1fd88e31eb75b5b" translate="yes" xml:space="preserve">
          <source>Supervision of Erlang/OTP</source>
          <target state="translated">Erlang / OTP 감독</target>
        </trans-unit>
        <trans-unit id="829f8d39f75c9bc9f969226bb510126e3c23e139" translate="yes" xml:space="preserve">
          <source>Supervision of a node being started using internal callback functions. Used to prevent hanging nodes. (Configurable.)</source>
          <target state="translated">내부 콜백 함수를 사용하여 시작된 노드의 감독 중단 노드를 방지하는 데 사용됩니다. (구성 가능)</target>
        </trans-unit>
        <trans-unit id="924f7769a101580d991ad9414eee8efcbffebbdb" translate="yes" xml:space="preserve">
          <source>Supervisor - skeleton for the OTP supervisor behavior</source>
          <target state="translated">수퍼바이저-OTP 수퍼바이저 동작의 골격</target>
        </trans-unit>
        <trans-unit id="323811135ee8c95f4855f00e4ef8542d2be8796b" translate="yes" xml:space="preserve">
          <source>Supervisor Bridge - skeleton for the OTP supervisor bridge behavior</source>
          <target state="translated">수퍼바이저 브리지-OTP 수퍼바이저 브리지 동작의 골격</target>
        </trans-unit>
        <trans-unit id="da3aea84a47845aadb4debb823b5071baf475b58" translate="yes" xml:space="preserve">
          <source>Supervisor report</source>
          <target state="translated">감독자 보고서</target>
        </trans-unit>
        <trans-unit id="87df9f02b7ab7494841fbdf4d8bc6ea62d2782fd" translate="yes" xml:space="preserve">
          <source>Supervisor reports and crash reports are issued as &lt;code&gt;error&lt;/code&gt; level log events, and are logged through the default handler started by Kernel.</source>
          <target state="translated">감독자 보고서 및 충돌 보고서는 &lt;code&gt;error&lt;/code&gt; 수준 로그 이벤트 로 발행 되며 커널에서 시작한 기본 처리기를 통해 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8134165a77d04e2d6551122c49e5bdd280bc54b0" translate="yes" xml:space="preserve">
          <source>Supervisor reports, crash reports, and progress reports are no longer connected to the SASL application.</source>
          <target state="translated">감독자 보고서, 충돌 보고서 및 진행률 보고서가 더 이상 SASL 응용 프로그램에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9969a639fd5f6ed1ac8b07340d0c05f6c0b8953c" translate="yes" xml:space="preserve">
          <source>Supervisors are processes that monitor the behaviour of workers. A supervisor can restart a worker if something goes wrong.</source>
          <target state="translated">감독자는 근로자의 행동을 모니터링하는 프로세스입니다. 문제가 발생하면 감독자가 작업자를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b867b17045f3842a273db8cba0550b3d1ac6614" translate="yes" xml:space="preserve">
          <source>Support all platforms that implement DTrace: OS X, Solaris, and (I hope) FreeBSD and NetBSD.</source>
          <target state="translated">DTrace를 구현하는 모든 플랫폼 (OS X, Solaris 및 FreeBSD 및 NetBSD)을 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="69fe8cf7ba05f1cc818c0855d845cf60eed872f5" translate="yes" xml:space="preserve">
          <source>Support for CGI-1.1 is implemented in accordance with &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;RFC 3875&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CGI-1.1에 대한 지원은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;RFC 3875&lt;/a&gt;&lt;/code&gt; 에 따라 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="cab27f867ed7b84d1da4274c9b4c8a517efc3269" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 encoded atoms in the external format has been available since ERTS 5.10 (OTP R16). This abillity allows such old nodes to decode, store and encode any Unicode atoms received from a new OTP 20 node.</source>
          <target state="translated">외부 형식의 UTF-8 인코딩 원자에 대한 지원은 ERTS 5.10 (OTP R16) 이후에 사용 가능합니다. 이러한 어빌리티는 그러한 오래된 노드가 새로운 OTP 20 노드로부터 수신 된 모든 유니 코드 원자를 디코딩, 저장 및 인코딩 할 수있게한다.</target>
        </trans-unit>
        <trans-unit id="193baef9a2c52722bfd0c24ca1ca0d35adeafcf4" translate="yes" xml:space="preserve">
          <source>Support for Unicode is increasing throughout the world of computing, as the benefits of one common character set are overwhelming when programs are used in a global environment. Along with the base of the standard, the code points for all the scripts, some &lt;strong&gt;encoding standards&lt;/strong&gt; are available.</source>
          <target state="translated">프로그램이 글로벌 환경에서 사용될 때 하나의 공통 문자 세트의 이점이 압도적이므로 유니 코드에 대한 지원은 컴퓨팅 세계에서 점차 증가하고 있습니다. 표준의 기초와 함께 모든 스크립트의 코드 포인트와 함께 일부 &lt;strong&gt;인코딩 표준&lt;/strong&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1a1f5f1f39e75130f9a4b8fb8862e77cf4de40" translate="yes" xml:space="preserve">
          <source>Support for alternative service discovery mechanisms was added in Erlang/OTP 21.</source>
          <target state="translated">대체 서비스 검색 메커니즘에 대한 지원이 Erlang / OTP 21에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1d962630c5d6ce765c1eae0f7d5dc468e364cb4b" translate="yes" xml:space="preserve">
          <source>Support for the following encoding rules:</source>
          <target state="translated">다음 인코딩 규칙을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cf1c782df2c96e8282de7b476d79cc67e49828fb" translate="yes" xml:space="preserve">
          <source>Support for time measurement in NIF libraries:</source>
          <target state="translated">NIF 라이브러리에서 시간 측정 지원 :</target>
        </trans-unit>
        <trans-unit id="4c3f03f63be41e2febacf4326efd1546b9941350" translate="yes" xml:space="preserve">
          <source>Support for time measurement in drivers:</source>
          <target state="translated">드라이버에서 시간 측정 지원 :</target>
        </trans-unit>
        <trans-unit id="dc296a0486ec5f87002aad7f28ba0562ca867666" translate="yes" xml:space="preserve">
          <source>Support functions for property lists.</source>
          <target state="translated">속성 목록에 대한 지원 기능.</target>
        </trans-unit>
        <trans-unit id="93baf438b0613f3c74f0fdc2ba5aba73338aaf24" translate="yes" xml:space="preserve">
          <source>Support functions for test suite authors</source>
          <target state="translated">테스트 스위트 작성자를위한 지원 기능</target>
        </trans-unit>
        <trans-unit id="76ec5026dd3939812f4e93c176c2a0f384d8c0e6" translate="yes" xml:space="preserve">
          <source>Support libraries contain functions that are useful for all test suites, or for test suites in a specific functional area or subsystem. In addition to the general support libraries provided by the &lt;code&gt;Common Test&lt;/code&gt; framework, and the various libraries and applications provided by Erlang/OTP, there can also be a need for customized (user specific) support libraries.</source>
          <target state="translated">지원 라이브러리에는 모든 테스트 스위트 또는 특정 기능 영역 또는 서브 시스템의 테스트 스위트에 유용한 기능이 있습니다. &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크에서 제공하는 일반 지원 라이브러리 와 Erlang / OTP에서 제공하는 다양한 라이브러리 및 응용 프로그램 외에도 사용자 정의 된 (사용자 별) 지원 라이브러리가 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0362ec0d097a5a157104529b450e00204f9cbbb5" translate="yes" xml:space="preserve">
          <source>Support library for abstract Erlang syntax trees.</source>
          <target state="translated">추상 Erlang 구문 트리를위한 지원 라이브러리.</target>
        </trans-unit>
        <trans-unit id="e9eea1dd92def1101125de3b37a7409d58a3f281" translate="yes" xml:space="preserve">
          <source>Support the &lt;code&gt;sys&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#debug&quot;&gt;debug facilities&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#debug&quot;&gt;debug facilities&lt;/a&gt;&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="95c22864cfced2306503ecdcaa13a389468c1121" translate="yes" xml:space="preserve">
          <source>Support was added for normalizations forms in &lt;code&gt;unicode&lt;/code&gt; and the &lt;code&gt;string&lt;/code&gt; module now handles utf8-encoded binaries.</source>
          <target state="translated">지원에 정상화 양식에 추가 된 &lt;code&gt;unicode&lt;/code&gt; 와 &lt;code&gt;string&lt;/code&gt; 모듈은 이제 UTF8 인코딩 된 바이너리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8c3d6e2b0c4b55646256fe3e98da277b50ee5de3" translate="yes" xml:space="preserve">
          <source>Supported cipher suites. The function &lt;code&gt;cipher_suites/0&lt;/code&gt; can be used to find all ciphers that are supported by default. &lt;code&gt;cipher_suites(all)&lt;/code&gt; can be called to find all available cipher suites. Pre-Shared Key (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4279.txt&quot;&gt;RFC 4279&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5487.txt&quot;&gt;RFC 5487&lt;/a&gt;&lt;/code&gt;), Secure Remote Password (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5054.txt&quot;&gt;RFC 5054&lt;/a&gt;&lt;/code&gt;), RC4 cipher suites, and anonymous cipher suites only work if explicitly enabled by this option; they are supported/enabled by the peer also. Anonymous cipher suites are supported for testing purposes only and are not be used when security matters.</source>
          <target state="translated">지원되는 암호 제품군. &lt;code&gt;cipher_suites/0&lt;/code&gt; 기능을 사용하여 기본적으로 지원되는 모든 암호를 찾을 수 있습니다. 사용 가능한 모든 암호 스위트를 찾기 위해 &lt;code&gt;cipher_suites(all)&lt;/code&gt; 를 호출 할 수 있습니다. 사전 공유 키 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4279.txt&quot;&gt;RFC 4279&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5487.txt&quot;&gt;RFC 5487&lt;/a&gt;&lt;/code&gt; ), 보안 원격 비밀번호 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5054.txt&quot;&gt;RFC 5054&lt;/a&gt;&lt;/code&gt; ), RC4 암호 제품군 및 익명 암호 제품군은이 옵션으로 명시 적으로 활성화 된 경우에만 작동합니다. 또한 피어가 지원 / 활성화합니다. 익명 암호 스위트는 테스트 목적으로 만 지원되며 보안이 중요한 경우에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ace0dceed0dc79156d544bb1e740bd6e2e4245f" translate="yes" xml:space="preserve">
          <source>Supported option: &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8862943cc8300abfb1bde27326d75dc9a30f07d9" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-D&lt;/code&gt; , &lt;code&gt;-v&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18222290f4691ea2e1803f27d33f984dc4fed35" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="611e3fc6659a77f464d1ef09b1a3f966abeee562" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13af750ddec082e015f88004babe3e1a9cbf2249" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">지원되는 옵션 : &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee8aa3fc6cd2da1cc08dd61046fb6b0ad0efa14b" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-v&lt;/code&gt; , &lt;code&gt;-I&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9956c47dfedf732cac76d6c7cf8152d9c9559ea6" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;.</source>
          <target state="translated">지원 옵션 : &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6162eeb9b9f8ad636a290938543b85a83786b99" translate="yes" xml:space="preserve">
          <source>Supported options: same as for &lt;code&gt;.erl&lt;/code&gt;.</source>
          <target state="translated">지원되는 옵션 : &lt;code&gt;.erl&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="002fcc7d4fbae71f711cdd87becc1cce73be8aaf" translate="yes" xml:space="preserve">
          <source>Supported time unit representations:</source>
          <target state="translated">지원되는 시간 단위 표현 :</target>
        </trans-unit>
        <trans-unit id="ae00ef55d1dcfbb028df51241440b188a57ac58d" translate="yes" xml:space="preserve">
          <source>Supported-Vendor-Id AVP</source>
          <target state="translated">지원되는 공급 업체 ID AVP</target>
        </trans-unit>
        <trans-unit id="e769daffee112f18015a5281f7f10cc6e2232070" translate="yes" xml:space="preserve">
          <source>Supports automatic repair of log files that are not properly closed and enables efficient reading of logged items in &lt;strong&gt;chunks&lt;/strong&gt; using a set of functions defined in this module. This is the only way to read internally formatted logs. An item logged to an internally formatted log must not occupy more than 4 GB of disk space (the size must fit in 4 bytes).</source>
          <target state="translated">올바르게 닫히지 않은 로그 파일의 자동 복구를 지원 하고이 모듈에 정의 된 기능 세트를 사용하여 &lt;strong&gt;덩어리&lt;/strong&gt; 로 기록 된 항목을 효율적으로 읽을 수 있습니다 . 내부 형식의 로그를 읽는 유일한 방법입니다. 내부 형식의 로그에 기록 된 항목은 4GB 이상의 디스크 공간을 차지하지 않아야합니다 (크기는 4 바이트 여야합니다).</target>
        </trans-unit>
        <trans-unit id="cbbfa591a4b290b4ae62ef1ecc1698736ec6299b" translate="yes" xml:space="preserve">
          <source>Supports calling Erlang functions on remote nodes. &lt;code&gt;ei_rpc_to()&lt;/code&gt; sends an RPC request to a remote node and &lt;code&gt;ei_rpc_from()&lt;/code&gt; receives the results of such a call. &lt;code&gt;ei_rpc()&lt;/code&gt; combines the functionality of these two functions by sending an RPC request and waiting for the results. See also &lt;code&gt;rpc:call/4&lt;/code&gt; in Kernel.</source>
          <target state="translated">원격 노드에서 Erlang 함수 호출을 지원합니다. &lt;code&gt;ei_rpc_to()&lt;/code&gt; 는 RPC 요청을 원격 노드로 &lt;code&gt;ei_rpc_from()&lt;/code&gt; 은 이러한 호출의 결과를받습니다. &lt;code&gt;ei_rpc()&lt;/code&gt; 는 RPC 요청을 보내고 결과를 기다리 면서이 두 함수의 기능을 결합합니다. 커널의 &lt;code&gt;rpc:call/4&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa8c650384582fade821d1435197dd4d799e10f6" translate="yes" xml:space="preserve">
          <source>Supports calling Erlang functions on remote nodes. &lt;code&gt;erl_rpc_to()&lt;/code&gt; sends an RPC request to a remote node and &lt;code&gt;erl_rpc_from()&lt;/code&gt; receives the results of such a call. &lt;code&gt;erl_rpc()&lt;/code&gt; combines the functionality of these two functions by sending an RPC request and waiting for the results. See also &lt;code&gt;rpc:call/4&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">원격 노드에서 Erlang 함수 호출을 지원합니다. &lt;code&gt;erl_rpc_to()&lt;/code&gt; 는 RPC 요청을 원격 노드로 &lt;code&gt;erl_rpc_from()&lt;/code&gt; 은 이러한 호출의 결과를 수신합니다. &lt;code&gt;erl_rpc()&lt;/code&gt; 는 RPC 요청을 보내고 결과를 기다리 면서이 두 함수의 기능을 결합합니다. 참조 &lt;code&gt;rpc:call/4&lt;/code&gt; 의 &lt;code&gt;Kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3811292723c6d7a387a20acab2375d3a48075ff" translate="yes" xml:space="preserve">
          <source>Suppose now that &lt;code&gt;cp2&lt;/code&gt; goes also down and does not restart within 5 seconds. &lt;code&gt;myapp&lt;/code&gt; is now restarted on &lt;code&gt;cp3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cp2&lt;/code&gt; 도 다운되고 5 초 내에 다시 시작되지 않는다고 가정하십시오 . &lt;code&gt;myapp&lt;/code&gt; 는 이제 &lt;code&gt;cp3&lt;/code&gt; 에서 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2a35d6565243a0a37ae621d98c111036eb6b54a" translate="yes" xml:space="preserve">
          <source>Suppose now that we call &lt;code&gt;set_lock_button&lt;/code&gt; while the door is open, and we have already postponed a button event that was the new lock button:</source>
          <target state="translated">문이 열린 상태에서 &lt;code&gt;set_lock_button&lt;/code&gt; 을 호출 하고 새로운 잠금 버튼 인 버튼 이벤트를 이미 연기했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4f259e320457b94f7101d49c931d3f7e53c48f31" translate="yes" xml:space="preserve">
          <source>Suppose our client expects to connect to the web server https://www.example.net. This URI is therefore the Reference IDs of the client. The call will be:</source>
          <target state="translated">클라이언트가 웹 서버 https://www.example.net에 연결한다고 가정합니다. 따라서이 URI는 클라이언트의 참조 ID입니다. 전화는 :</target>
        </trans-unit>
        <trans-unit id="f86d7a4fa0c16e05b4083974f68f3f6c6ca32ef5" translate="yes" xml:space="preserve">
          <source>Suppose you have the following private key and a corresponding public key:</source>
          <target state="translated">다음 개인 키와 해당 공개 키가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="161e2a3301f56050bd72a9a234717ac0bdcee365" translate="yes" xml:space="preserve">
          <source>Suppress erl and hrl generation, respectively.</source>
          <target state="translated">erl 및 hrl 생성을 각각 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="fd85d4a3e5b009ade7267fa909dd246107f8cd7a" translate="yes" xml:space="preserve">
          <source>Suppress warnings about behavior callbacks that drift from the published recommended interfaces.</source>
          <target state="translated">게시 된 권장 인터페이스에서 벗어난 동작 콜백에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="658d4e7b1b098b27aa4e9901e6a6a91fde3e7e4d" translate="yes" xml:space="preserve">
          <source>Suppress warnings about behaviors that have no &lt;code&gt;-callback&lt;/code&gt; attributes for their callbacks.</source>
          <target state="translated">더없는 행동에 대한 억제 경고 &lt;code&gt;-callback&lt;/code&gt; 자신의 콜백의 속성을.</target>
        </trans-unit>
        <trans-unit id="99d8fcbfb989e4e7fda7c9452d49bb803228dd19" translate="yes" xml:space="preserve">
          <source>Suppress warnings about calls to missing functions.</source>
          <target state="translated">누락 된 함수 호출에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5f104449e97fb4d3d9fd5d369f54de49da0d189" translate="yes" xml:space="preserve">
          <source>Suppress warnings about invalid contracts.</source>
          <target state="translated">유효하지 않은 계약에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="896f6537b177bdb199d5aeaf1e91ac70a0c3690d" translate="yes" xml:space="preserve">
          <source>Suppress warnings for construction of improper lists.</source>
          <target state="translated">부적절한 목록 구성에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e5a8003fe113325954491747d862630cd7a5e51" translate="yes" xml:space="preserve">
          <source>Suppress warnings for failing calls.</source>
          <target state="translated">통화 실패에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03070bddd1c1713fe09504f3e04390b0f76857ef" translate="yes" xml:space="preserve">
          <source>Suppress warnings for fun applications that will fail.</source>
          <target state="translated">실패 할 재미있는 응용 프로그램에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e363bcef03fbcf4ab0a513ebe34c444e24468b1f" translate="yes" xml:space="preserve">
          <source>Suppress warnings for functions that will never return a value.</source>
          <target state="translated">값을 반환하지 않는 함수에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e7a409dd7e022c1a6f54bf31cd4e3da6ea87e20" translate="yes" xml:space="preserve">
          <source>Suppress warnings for patterns that are unused or cannot match.</source>
          <target state="translated">사용하지 않거나 일치 할 수없는 패턴에 대해서는 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38c67ecef5210cce75595b7c59b94ce46cbf5939" translate="yes" xml:space="preserve">
          <source>Suppress warnings for unused functions.</source>
          <target state="translated">사용하지 않는 기능에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e23a74a695d05be9cf7ca7b4cd92c59cd8c658c" translate="yes" xml:space="preserve">
          <source>Suppress warnings for violations of opacity of data types.</source>
          <target state="translated">데이터 유형의 불투명도 위반에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00dba67736694228fe581698490416aec0e4a248" translate="yes" xml:space="preserve">
          <source>Suppresses the call statistics for each process from the analysis.</source>
          <target state="translated">분석에서 각 프로세스의 통화 통계를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fe98e618f2833867a376cb98a815ac9ec990dd1" translate="yes" xml:space="preserve">
          <source>Suppresses the printing of callers and called information in the analysis.</source>
          <target state="translated">분석에서 발신자와 인쇄 된 정보의 인쇄를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="df8a60c08e48d602804f88560585bc9fbb66d14d" translate="yes" xml:space="preserve">
          <source>Suppresses the writing of a crash dump file entirely, thus rebooting the runtime system immediately. This is the same as not setting the environment variable.</source>
          <target state="translated">크래시 덤프 파일의 쓰기를 완전히 억제하여 런타임 시스템을 즉시 재부팅합니다. 이것은 환경 변수를 설정하지 않는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a988c8ef2b296fc0ea2e2d3047e7e09c23301de2" translate="yes" xml:space="preserve">
          <source>Supresses the totals section in the analysis, which is the default.</source>
          <target state="translated">분석에서 총계 섹션을 억제합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="0ef25d72e538682415b03c36a263df0107df3d7d" translate="yes" xml:space="preserve">
          <source>Surefire XML can, for example, be used by Jenkins to display test results.</source>
          <target state="translated">예를 들어 Jenkins는 Surefire XML을 사용하여 테스트 결과를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b793def872c04362cbd57644640b08e1bf84da10" translate="yes" xml:space="preserve">
          <source>Surefire reports for EUnit (Format used by Maven and Atlassian Bamboo for example to integrate test results).</source>
          <target state="translated">EUnit에 대한 Surefire 보고서 (예 : 테스트 결과를 통합하기 위해 Maven 및 Atlassian Bamboo에서 사용하는 형식)</target>
        </trans-unit>
        <trans-unit id="7631dc723852ac4b0bb4fd7d3058478eb65f5073" translate="yes" xml:space="preserve">
          <source>Surefire reports for EUnit (Format used by Maven and Atlassian Bamboo for example to integrate test results). Based on initial code from Paul Guyot.</source>
          <target state="translated">EUnit에 대한 Surefire 보고서 (예 : 테스트 결과를 통합하기 위해 Maven 및 Atlassian Bamboo에서 사용하는 형식) Paul Guyot의 초기 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="c948ea0246807256cf48a7cfaaf94b78e7b2095a" translate="yes" xml:space="preserve">
          <source>Surrogate</source>
          <target state="translated">Surrogate</target>
        </trans-unit>
        <trans-unit id="e9bce0f224084ad788d49010d7d7d29a8ae63144" translate="yes" xml:space="preserve">
          <source>Suspend the processes using the module (to avoid that they try to handle any requests before the code replacement is completed).</source>
          <target state="translated">코드 교체가 완료되기 전에 요청을 처리하지 않도록 모듈을 사용하여 프로세스를 일시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="d39141a48920c1be93a6f36d09eebe0906941a82" translate="yes" xml:space="preserve">
          <source>Suspends the process calling this function for &lt;code&gt;Time&lt;/code&gt; milliseconds and then returns &lt;code&gt;ok&lt;/code&gt;, or suspends the process forever if &lt;code&gt;Time&lt;/code&gt; is the atom &lt;code&gt;infinity&lt;/code&gt;. Naturally, this function does &lt;strong&gt;not&lt;/strong&gt; return immediately.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 밀리 초 동안이 함수를 호출하는 프로세스를 일시 중단 한 다음 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 &lt;code&gt;Time&lt;/code&gt; 이 원자 &lt;code&gt;infinity&lt;/code&gt; 경우 프로세스를 영원히 일시 중단합니다 . 당연히이 함수는 즉시 반환 되지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e824b6e4f75be4a07d7079e9c06b0752d0649c" translate="yes" xml:space="preserve">
          <source>Suspends the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. The same as calling &lt;code&gt;&lt;a href=&quot;#suspend_process-2&quot;&gt;erlang:suspend_process(Suspendee, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스를 일시 중단합니다 . &lt;code&gt;&lt;a href=&quot;#suspend_process-2&quot;&gt;erlang:suspend_process(Suspendee, [])&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d982fb65e6d52487c1ff358f3e710016d64e310b" translate="yes" xml:space="preserve">
          <source>Suspends the process. When the process is suspended, it only responds to other system messages, but not other messages.</source>
          <target state="translated">프로세스를 일시 중단합니다. 프로세스가 일시 중단되면 다른 시스템 메시지에만 응답하지만 다른 메시지에는 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4868e2fd51bda36328ddd3547e74c2e3f69d3c0e" translate="yes" xml:space="preserve">
          <source>Swaps places on &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space for ports and processes.</source>
          <target state="translated">포트 및 프로세스를 위해 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Id&lt;/code&gt; 공간의 위치를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="85a66af5fe9577ba36cb5dc160b5ab726c351f25" translate="yes" xml:space="preserve">
          <source>Switches off HTML enhancements that can be incompatible with older browsers.</source>
          <target state="translated">이전 브라우저와 호환되지 않는 HTML 향상 기능을 끕니다.</target>
        </trans-unit>
        <trans-unit id="f73cc71db4a1a943c0921fa8a5b8bb091227bf54" translate="yes" xml:space="preserve">
          <source>Syloti_Nagri</source>
          <target state="translated">Syloti_Nagri</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ff671c52be278a122290e8362f747edf95308739" translate="yes" xml:space="preserve">
          <source>Symbolic Links in --bindir</source>
          <target state="translated">--bindir의 심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="38614ef7ffaabdccf540bb23f1bf4109a9456e2e" translate="yes" xml:space="preserve">
          <source>Symbolic links are not supported on this platform.</source>
          <target state="translated">이 플랫폼에서는 기호 링크가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2db0c5c047d755597fe723f5b3906e0e790e5fa" translate="yes" xml:space="preserve">
          <source>Symbolic names must be unique within a MIB and within a system.</source>
          <target state="translated">기호 이름은 MIB 및 시스템 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc20e08aa6ee36e007fb8be42c9963c3987432d6" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the native time unit used by the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템이 사용하는 기본 시간 단위를 상징적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9c3de4c1d499b9c4d2940a999036876a992d4f1a" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the performance counter time unit used by the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템이 사용하는 성능 카운터 시간 단위의 상징적 표현.</target>
        </trans-unit>
        <trans-unit id="07800dda6fdaf0f476886edeef6a9aeb0d872f21" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000000000&lt;/code&gt;.</source>
          <target state="translated">시간 단위의 상징적 표현은 정수로 표현 &lt;code&gt;1000000000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2649cc9e01c228ec0f5a481c6b1745e523dc1efc" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000000&lt;/code&gt;.</source>
          <target state="translated">시간 단위의 상징적 표현은 정수로 표현 &lt;code&gt;1000000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b93ca2c4c24c9b54782ff7202cd91a428f51d3f7" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000&lt;/code&gt;.</source>
          <target state="translated">시간 단위의 상징적 표현은 정수로 표현 &lt;code&gt;1000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9196744d900f2593e47a8bb8e5453768b4547c96" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">시간 단위의 상징적 표현은 정수로 표현 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde31cc35fbdb6242bd81a4ff154a0d240c0fc6b" translate="yes" xml:space="preserve">
          <source>Symbols such as &lt;code&gt;'{'&lt;/code&gt;, &lt;code&gt;'.'&lt;/code&gt;, etc., have to be enclosed in single quotes when used as terminal or non-terminal symbols in grammar rules. The use of the symbols &lt;code&gt;'$empty'&lt;/code&gt;, &lt;code&gt;'$end'&lt;/code&gt;, and &lt;code&gt;'$undefined'&lt;/code&gt; should be avoided.</source>
          <target state="translated">&lt;code&gt;'{'&lt;/code&gt; , &lt;code&gt;'.'&lt;/code&gt; 와 같은 기호 등은 문법 규칙에서 터미널 또는 비 터미널 기호로 사용될 때 작은 따옴표로 묶어야합니다. 기호의 사용 &lt;code&gt;'$empty'&lt;/code&gt; , &lt;code&gt;'$end'&lt;/code&gt; , 그리고 &lt;code&gt;'$undefined'&lt;/code&gt; 피해야한다.</target>
        </trans-unit>
        <trans-unit id="e6c13be05542d397298f393613981e3279a425af" translate="yes" xml:space="preserve">
          <source>Symetric cipher algorithm used for the payload encryption. This algorithm will use the key calculated in the kex phase (together with other info) to genereate the actual key used. Examples are tripple-DES &lt;code&gt;'3des-cbc'&lt;/code&gt; and one of many AES variants &lt;code&gt;'aes192-ctr'&lt;/code&gt;.</source>
          <target state="translated">페이로드 암호화에 사용되는 Symetric 암호 알고리즘. 이 알고리즘은 kex 단계에서 계산 된 키 (다른 정보와 함께)를 사용하여 사용 된 실제 키를 생성합니다. 예는 tripple-DES &lt;code&gt;'3des-cbc'&lt;/code&gt; 및 많은 AES 변형 &lt;code&gt;'aes192-ctr'&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="87f15c5c25b82750fdbe6837aad13a797f701d1e" translate="yes" xml:space="preserve">
          <source>Synchronization error during chunk sending according to one of the following:</source>
          <target state="translated">다음 중 하나에 따라 청크 전송 중 동기화 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="32b88210af732b7fa6f0597cd05eb328619f14e7" translate="yes" xml:space="preserve">
          <source>Synchronize (write to disc, if possible) the mib-server data. This depends on the &lt;code&gt;mib_storage&lt;/code&gt; option, and will only have an effect if the mib-storage option has an actual disc component (such as dets, or ets with a file).</source>
          <target state="translated">mib 서버 데이터를 동기화 (가능한 경우 디스크에 기록)하십시오. 이는 &lt;code&gt;mib_storage&lt;/code&gt; 옵션 에 따라 다르며 mib-storage 옵션에 실제 디스크 구성 요소 (예 : det 또는 파일이있는 ets)가있는 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="312c1653b8bc7388af6f57b8ea1d1432ae577b59" translate="yes" xml:space="preserve">
          <source>Synchronize the mib-storage table.</source>
          <target state="translated">mib-storage 테이블을 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="e07fb72859a7d37936b725af7a1d5239adfbbe40" translate="yes" xml:space="preserve">
          <source>Synchronized code replacement of processes using module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;Mod&lt;/code&gt; 를 사용한 프로세스의 동기화 된 코드 교체 .</target>
        </trans-unit>
        <trans-unit id="01a1092f1791521fc50b0a1a453d3d4948b7f226" translate="yes" xml:space="preserve">
          <source>Synchronizes the global name server with all nodes known to this node. These are the nodes that are returned from &lt;code&gt;erlang:nodes()&lt;/code&gt;. When this function returns, the global name server receives global information from all nodes. This function can be called when new nodes are added to the network.</source>
          <target state="translated">글로벌 이름 서버를이 노드에 알려진 모든 노드와 동기화합니다. 이들은 &lt;code&gt;erlang:nodes()&lt;/code&gt; 에서 반환되는 노드입니다 . 이 함수가 반환되면 전역 이름 서버는 모든 노드에서 전역 정보를받습니다. 이 기능은 새로운 노드가 네트워크에 추가 될 때 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89fe354cd7884bf36eefa9b3c8217acccc91948e" translate="yes" xml:space="preserve">
          <source>Synchronizes the group nodes, that is, the global name servers on the group nodes. Also checks the names globally registered in the current global group and unregisters them on any known node not part of the group.</source>
          <target state="translated">그룹 노드, 즉 그룹 노드의 글로벌 이름 서버를 동기화합니다. 또한 현재 글로벌 그룹에 글로벌로 등록 된 이름을 확인하고 그룹의 일부가 아닌 알려진 노드에서 등록을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="07710d25b770f253a75d0aab226aa1ae135666c1" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">동기 &lt;code&gt;get-bulk-request&lt;/code&gt; (RFC1905 참조).</target>
        </trans-unit>
        <trans-unit id="f448ebbd4129a3291d4535aeab92c4cc47e4ddab" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">동기식 &lt;code&gt;get-next-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2b2fa27dbb4052bd3748ef0458bfd012b62beb" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">동기식 &lt;code&gt;get-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e513e56abe4ab6731c1a205d51fc5b5980806174" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">동기식 &lt;code&gt;set-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33a68e25327ecc51a99120fe1d23ee0e50bf0b8b" translate="yes" xml:space="preserve">
          <source>Synchronously appends a list of items to the log. It is more efficient to use these functions instead of functions &lt;code&gt;log/2&lt;/code&gt; and &lt;code&gt;blog/2&lt;/code&gt;. The specified list is split into as large sublists as possible (limited by the size of wrap log files), and each sublist is logged as one single item, which reduces the overhead.</source>
          <target state="translated">항목 목록을 동 기적으로 로그에 추가합니다. &lt;code&gt;log/2&lt;/code&gt; 및 &lt;code&gt;blog/2&lt;/code&gt; 함수 대신 이러한 함수를 사용하는 것이 더 효율적 입니다. 지정된 목록은 가능한 한 큰 하위 목록 (랩 로그 파일의 크기로 제한됨)으로 분할되며 각 하위 목록은 하나의 단일 항목으로 기록되므로 오버 헤드가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="089dc8c699a717858006211347bb6b82478e752b" translate="yes" xml:space="preserve">
          <source>Synchronously appends a term to a disk log. Returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, Reason}&lt;/code&gt; when the term is written to disk. If the log is distributed, &lt;code&gt;ok&lt;/code&gt; is returned, unless all nodes are down. Terms are written by the ordinary &lt;code&gt;write()&lt;/code&gt; function of the operating system. Hence, it is not guaranteed that the term is written to disk, it can linger in the operating system kernel for a while. To ensure that the item is written to disk, function &lt;code&gt;&lt;a href=&quot;#sync-1&quot;&gt;sync/1&lt;/a&gt;&lt;/code&gt; must be called.</source>
          <target state="translated">디스크 로그에 용어를 동 기적으로 추가합니다. 용어를 디스크에 쓸 때 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다. 로그가 분배되면 모든 노드가 작동 중지되지 않는 한 &lt;code&gt;ok&lt;/code&gt; 가 리턴됩니다. 용어는 운영 체제 의 일반적인 &lt;code&gt;write()&lt;/code&gt; 함수로 작성됩니다 . 따라서이 용어가 디스크에 기록된다고 보장 할 수 없으며 운영 체제 커널에 잠시 동안 머무를 수 있습니다. 항목이 디스크에 기록되도록하려면 &lt;code&gt;&lt;a href=&quot;#sync-1&quot;&gt;sync/1&lt;/a&gt;&lt;/code&gt; 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="34f5f72fe0e623ff3475c94b03480e1803098c61" translate="yes" xml:space="preserve">
          <source>Syntactic tests are used in the code associated with some rules, and an error is thrown (and caught by the generated parser to produce an error message) when a test fails. The same effect can be achieved with a call to &lt;code&gt;return_error(Error_line, Message_string)&lt;/code&gt;, which is defined in the &lt;code&gt;yeccpre.hrl&lt;/code&gt; default header file.</source>
          <target state="translated">구문 테스트는 일부 규칙과 관련된 코드에서 사용되며 테스트에 실패하면 오류가 발생합니다 (생성 된 구문 분석기가 오류 메시지를 생성하기 위해 발생 함). &lt;code&gt;yeccpre.hrl&lt;/code&gt; 기본 헤더 파일에 정의 된 &lt;code&gt;return_error(Error_line, Message_string)&lt;/code&gt; 호출로도 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ebec072eed621a03687383916a65b1244e3a80a" translate="yes" xml:space="preserve">
          <source>Syntactically QLCs have the same parts as ordinary list comprehensions:</source>
          <target state="translated">구문 적으로 QLC는 일반 목록 이해와 동일한 부분을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f8f94a7abd535bc567b210e7feb24b95dcc145dd" translate="yes" xml:space="preserve">
          <source>Syntax according to the URI definition in RFC 3986, for example, &quot;http://www.erlang.org/&quot;</source>
          <target state="translated">RFC 3986의 URI 정의에 따른 구문 (예 : &quot;http://www.erlang.org/&quot;</target>
        </trans-unit>
        <trans-unit id="3aef52650439fcc381066161b6a33ff26aa88627" translate="yes" xml:space="preserve">
          <source>Syntax errors are detected locally on this side of the protocol and may have many causes, e.g. a malfunctioning transport layer, wrong encoder/decoder selected, bad configuration of the selected encoder/decoder etc.</source>
          <target state="translated">구문 오류는 프로토콜의이 측면에서 로컬로 감지되며 전송 계층 오작동, 잘못된 인코더 / 디코더 선택, 선택한 인코더 / 디코더의 잘못된 구성 등 여러 가지 원인이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3b09d06cdfdc92cef412c5e43702c1e9bf45027" translate="yes" xml:space="preserve">
          <source>Syntax errors in these files are discovered and reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module at start-up.</source>
          <target state="translated">이러한 파일의 구문 오류는 시작시 오류 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 기능으로 감지 및보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc253a36e8ace3c94e28555bf56cc77650f265b" translate="yes" xml:space="preserve">
          <source>Syriac</source>
          <target state="translated">Syriac</target>
        </trans-unit>
        <trans-unit id="5131fe5695bc3ce3887d236a54747934336afaf8" translate="yes" xml:space="preserve">
          <source>System Information</source>
          <target state="translated">시스템 정보</target>
        </trans-unit>
        <trans-unit id="b35b204150b6742e0c35cf28de6a47c6519eee30" translate="yes" xml:space="preserve">
          <source>System events and table events are the two event categories that &lt;code&gt;Mnesia&lt;/code&gt; generates in various situations.</source>
          <target state="translated">시스템 이벤트 및 테이블 이벤트는 &lt;code&gt;Mnesia&lt;/code&gt; 가 다양한 상황에서 생성 하는 두 가지 이벤트 범주입니다 .</target>
        </trans-unit>
        <trans-unit id="7ca52b12819dad012ad5eb499f8d3b89db539ac8" translate="yes" xml:space="preserve">
          <source>System flags effecting specific allocators have an uppercase letter as &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. The following letters are used for the allocators:</source>
          <target state="translated">특정 할당 자에 영향을주는 시스템 플래그는 대문자가 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 입니다. 다음 문자는 할당 자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="906ee68749a5a73a7e6af2237eb2dee1edbbf171" translate="yes" xml:space="preserve">
          <source>System info - System wide information. Read only.</source>
          <target state="translated">시스템 정보-시스템 전체 정보. 읽기 전용.</target>
        </trans-unit>
        <trans-unit id="5474f690d82670c5da64f04996c609d92047ddb8" translate="yes" xml:space="preserve">
          <source>System messages are messages with a special meaning, used in the supervision tree. Typical system messages are requests for trace output, and requests to suspend or resume process execution (used during release handling). Processes implemented using standard behaviours automatically understand these messages.</source>
          <target state="translated">시스템 메시지는 감독 트리에서 사용되는 특별한 의미의 메시지입니다. 일반적인 시스템 메시지는 추적 출력 요청 및 프로세스 실행 일시 중지 또는 재개 요청 (릴리스 처리 중 사용)입니다. 표준 동작을 사용하여 구현 된 프로세스는 이러한 메시지를 자동으로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="1b4c8fad84bf9ee2ed69c28438abdf60dfd04975" translate="yes" xml:space="preserve">
          <source>System settings</source>
          <target state="translated">환경 설정</target>
        </trans-unit>
        <trans-unit id="97a5f85605eef008a7bb7f2a0d512d9d724526bc" translate="yes" xml:space="preserve">
          <source>SystemTap &amp;gt; 1.6</source>
          <target state="translated">SystemTap&amp;gt; 1.6</target>
        </trans-unit>
        <trans-unit id="5bf881dc1f558738602aecd490c360ffa2d35d9f" translate="yes" xml:space="preserve">
          <source>SystemTap is DTrace for Linux. In fact Erlang's SystemTap support is build using SystemTap's DTrace compatibility's layer. For an introduction to Erlang DTrace support read &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;$ERL_TOP/HOWTO/DTRACE.md&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SystemTap은 Linux 용 DTrace입니다. 실제로 Erlang의 SystemTap 지원은 SystemTap의 DTrace 호환성 계층을 사용하여 빌드됩니다. Erlang DTrace 지원에 대한 소개는 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;$ERL_TOP/HOWTO/DTRACE.md&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a67e86af30e598c1b8dd4410e063b04f3f531fa" translate="yes" xml:space="preserve">
          <source>SystemTap, unlike DTrace, needs to know what binary it is tracing and has to be able to read that binary before it starts tracing. Your probe script therefor has to reference the correct beam emulator and stap needs to be able to find that binary. The examples are written for &quot;beam&quot;, but other versions such as &quot;beam.smp&quot; or &quot;beam.debug.smp&quot; might exist (depending on your configuration). Make sure you either specify the full the path of the binary in the probe or your &quot;beam&quot; binary is in the search path.</source>
          <target state="translated">DTrace와 달리 SystemTap은 추적중인 바이너리를 알아야하며 추적을 시작하기 전에 해당 바이너리를 읽을 수 있어야합니다. 이를위한 프로브 스크립트는 올바른 빔 에뮬레이터를 참조해야하며 스태프가 해당 바이너리를 찾을 수 있어야합니다. 예제는 &quot;beam&quot;용으로 작성되었지만 &quot;beam.smp&quot;또는 &quot;beam.debug.smp&quot;와 같은 다른 버전이있을 수 있습니다 (구성에 따라 다름). 프로브에서 바이너리의 전체 경로를 지정하거나 &quot;빔&quot;바이너리가 검색 경로에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3890f6e1eeb7c8b9e6d4cda8af3654adab1e5a34" translate="yes" xml:space="preserve">
          <source>TCP over IPv4 (the default)</source>
          <target state="translated">IPv4를 통한 TCP (기본값)</target>
        </trans-unit>
        <trans-unit id="dd63ca133c7c9505341195d3fb66a2e4d3b97381" translate="yes" xml:space="preserve">
          <source>TCP over IPv6</source>
          <target state="translated">IPv6을 통한 TCP</target>
        </trans-unit>
        <trans-unit id="04ee2e323dc35fc805718ec013670729358e3a49" translate="yes" xml:space="preserve">
          <source>TLS protocol versions supported by started clients and servers. This option overrides the application environment option &lt;code&gt;protocol_version&lt;/code&gt; and &lt;code&gt;dtls_protocol_version&lt;/code&gt;. If the environment option is not set, it defaults to all versions, except SSL-3.0, supported by the SSL application. See also &lt;code&gt;ssl(6).&lt;/code&gt;</source>
          <target state="translated">시작된 클라이언트 및 서버가 지원하는 TLS 프로토콜 버전. 이 옵션은 애플리케이션 환경 옵션 &lt;code&gt;protocol_version&lt;/code&gt; 및 &lt;code&gt;dtls_protocol_version&lt;/code&gt; 을 대체합니다 . 환경 옵션이 설정되어 있지 않으면 SSL 응용 프로그램에서 지원하는 SSL-3.0을 제외한 모든 버전으로 기본 설정됩니다. &lt;code&gt;ssl(6).&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="981d4d11fc961a401155c4cc0aa1d985387ff5d6" translate="yes" xml:space="preserve">
          <source>TLS session cache API</source>
          <target state="translated">TLS 세션 캐시 API</target>
        </trans-unit>
        <trans-unit id="e297ce43abfa4341900c35352befe7e5a48a3921" translate="yes" xml:space="preserve">
          <source>TLS/TCP and DTLS/SCTP Usage</source>
          <target state="translated">TLS / TCP 및 DTLS / SCTP 사용법</target>
        </trans-unit>
        <trans-unit id="fe06eb6459c87f0e497ce1805f076f104bfecf78" translate="yes" xml:space="preserve">
          <source>Tab</source>
          <target state="translated">Tab</target>
        </trans-unit>
        <trans-unit id="d7f5ee722fd0ae504f8d3c4d7a205b2fef8a3d7f" translate="yes" xml:space="preserve">
          <source>Tab (hex 09)</source>
          <target state="translated">탭 (16 진수 09)</target>
        </trans-unit>
        <trans-unit id="ac4a8afcda713e36d6e9d6a34b43dbf38fa7e2cb" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Applications&lt;/strong&gt; presents application information. Select an application in the left list to display its supervisor tree. The right-click options in the tree are as follows:</source>
          <target state="translated">&lt;strong&gt;응용 프로그램&lt;/strong&gt; 탭 에는 응용 프로그램 정보가 표시됩니다. 왼쪽 목록에서 응용 프로그램을 선택하여 수퍼바이저 트리를 표시하십시오. 트리에서 마우스 오른쪽 버튼 클릭 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a99c25e3c4704f469b96b031da459e53abfe6fa8" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Atoms&lt;/strong&gt; lists all atoms found in the dump. By default the atoms are sorted in creation order from first to last. This is opposite of the raw crashdump where atoms are listed from last to first, meaning that if the dump was truncated in the middle of the atom list, only the last created atoms are visible in the &lt;strong&gt;Atoms&lt;/strong&gt; tab.</source>
          <target state="translated">탭 &lt;strong&gt;원자&lt;/strong&gt; 는 덤프에서 발견 된 모든 &lt;strong&gt;원자를&lt;/strong&gt; 나열합니다. 기본적으로 원자는 처음부터 끝까지 생성 순서대로 정렬됩니다. 원자가 마지막에서 처음으로 나열되는 원시 크래시 덤프와 반대입니다. 즉, 원자 목록의 중간에서 덤프가 잘린 경우 마지막으로 생성 된 원자 만 &lt;strong&gt;원자&lt;/strong&gt; 탭에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="33be1b6f25987c84258604714f597ef47abe12d6" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;ETS Tables&lt;/strong&gt; shows all ETS table information found in the dump. &lt;strong&gt;Id&lt;/strong&gt; is the same as the 'Table' field in the raw crashdump. &lt;strong&gt;Memory&lt;/strong&gt; is the 'Words' field from the raw crashdump translated into bytes. For tree tables, there is no value in the 'Objects' field.</source>
          <target state="translated">탭 &lt;strong&gt;ETS 테이블&lt;/strong&gt; 에는 덤프에서 찾은 모든 ETS 테이블 정보가 표시됩니다. &lt;strong&gt;ID&lt;/strong&gt; 는 원시 크래시 덤프의 '테이블'필드와 동일합니다. &lt;strong&gt;메모리&lt;/strong&gt; 는 원시 크래시 덤프의 '워드'필드로 바이트로 변환됩니다. 트리 테이블의 경우 '개체'필드에 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d086aaa9e2e638560ca52f2f78e7b03c35094870" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Funs&lt;/strong&gt; shows all fun information found in the dump.</source>
          <target state="translated">탭 &lt;strong&gt;기능&lt;/strong&gt; 은 덤프에서 발견 된 모든 기능 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="25121d69819c8efb4b19c73b31c386b78a1fdbb2" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;General&lt;/strong&gt; shows a short overview of the dump.</source>
          <target state="translated">&lt;strong&gt;일반&lt;/strong&gt; 탭 에는 덤프에 대한 간략한 개요가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="07e01288b5805bf1432af8b394a9b45442c593c3" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Load Charts&lt;/strong&gt; displays graphs of the current resource use on the active Erlang node.</source>
          <target state="translated">탭 &lt;strong&gt;로드 차트&lt;/strong&gt; 는 활성 Erlang 노드에서 현재 자원 사용 그래프를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="853f32a45947eb4c6d161de3626c9eaa0a83a4aa" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Memory Allocators&lt;/strong&gt; displays detailed information of the carrier size and current memory carriers. For details about memory carriers, see module &lt;code&gt;erts_alloc&lt;/code&gt; in application ERTS.</source>
          <target state="translated">탭 &lt;strong&gt;메모리 할당&lt;/strong&gt; 자는 캐리어 크기 및 현재 메모리 캐리어에 대한 자세한 정보를 표시합니다. 메모리 캐리어에 대한 자세한 내용은 애플리케이션 ERTS의 모듈 &lt;code&gt;erts_alloc&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc3b4b0a4502f9b7b7c51416e31fdfd021b9067e" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Memory&lt;/strong&gt; shows memory and allocator information. From the left-hand menu you can select the following:</source>
          <target state="translated">탭 &lt;strong&gt;메모리&lt;/strong&gt; 는 메모리 및 할당 자 정보를 보여줍니다. 왼쪽 메뉴에서 다음을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27ba8745969c8d5f12e6c931fd214d70f5efac15" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Modules&lt;/strong&gt; lists all modules loaded on the originating node, and the current code size. If old code exists, the old size is also shown.</source>
          <target state="translated">탭 &lt;strong&gt;모듈&lt;/strong&gt; 은 원래 노드에로드 된 모든 모듈과 현재 코드 크기를 나열합니다. 이전 코드가 존재하면 이전 크기도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eaf448913218cac98b494d3245a11c82d5371831" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Nodes&lt;/strong&gt; shows a list of all external Erlang nodes that are referenced from the crashdump.</source>
          <target state="translated">탭 &lt;strong&gt;노드&lt;/strong&gt; 는 크래시 덤프에서 참조되는 모든 외부 Erlang 노드 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80764d8faf4781bc8ce3e0b8874a18d7e0699dd0" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Ports&lt;/strong&gt; is similar to the &lt;strong&gt;Processes&lt;/strong&gt; tab, except it lists all ports found in the crashdump.</source>
          <target state="translated">탭 &lt;strong&gt;포트&lt;/strong&gt; 는 크래시 덤프에서 발견 된 모든 포트를 나열한다는 점을 제외하고 &lt;strong&gt;프로세스&lt;/strong&gt; 탭 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="76b66410e4f2402b3acc96cda65eec1371b79f1b" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Ports&lt;/strong&gt; lists port information in columns. For each port the following information is displayed:</source>
          <target state="translated">탭 &lt;strong&gt;포트&lt;/strong&gt; 는 포트 정보를 열로 나열합니다. 각 포트에 대해 다음 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5391882f31ea5c33386e235a2386ab3a7ce9b1" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Processes&lt;/strong&gt; lists process information in columns. For each process the following information is displayed:</source>
          <target state="translated">탭 &lt;strong&gt;프로세스&lt;/strong&gt; 는 프로세스 정보를 열로 나열합니다. 각 프로세스마다 다음 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="81e00bdbb07b70180cc90e9aaa68bf4d038cb024" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Processes&lt;/strong&gt; shows a list of all processes found in the crashdump, including brief information about each process. By default, the processes are sorted by their pids. To sort by another topic, click the desired column heading.</source>
          <target state="translated">탭 &lt;strong&gt;프로세스&lt;/strong&gt; 에는 각 프로세스에 대한 간단한 정보를 포함하여 크래시 덤프에서 발견 된 모든 프로세스의 목록이 표시됩니다. 기본적으로 프로세스는 pid로 정렬됩니다. 다른 주제별로 정렬하려면 원하는 열 제목을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="37ee8ff7801abf11d7bda8a37bc6cfc86f955eeb" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Schedulers&lt;/strong&gt; shows all scheduler information found in the dump.</source>
          <target state="translated">탭 &lt;strong&gt;스케줄러&lt;/strong&gt; 는 덤프에서 찾은 모든 스케줄러 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ae16dafe965fd6bba4b8e61efd1280d8b73f7cdd" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;System&lt;/strong&gt; displays general information about the active Erlang node and its runtime system, such as build configuration, system capabilities, and overall use statistics.</source>
          <target state="translated">탭 &lt;strong&gt;시스템&lt;/strong&gt; 은 빌드 구성, 시스템 기능 및 전체 사용 통계와 같은 활성 Erlang 노드 및 해당 런타임 시스템에 대한 일반 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2dc8b2d71fceee93b7ee5110352b556240629d35" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Table Viewer&lt;/strong&gt; lists tables. By default, ETS tables are displayed whereas unreadable private ETS tables and tables created by OTP applications are not diplayed. Use menu &lt;strong&gt;View&lt;/strong&gt; to view &quot;system&quot; ETS tables, unreadable ETS tables, or Mnesia tables.</source>
          <target state="translated">탭 &lt;strong&gt;테이블 뷰어&lt;/strong&gt; 는 테이블을 나열합니다. 기본적으로 ETS 테이블이 표시되는 반면 읽을 수없는 개인 ETS 테이블과 OTP 응용 프로그램에서 만든 테이블은 표시되지 않습니다. &quot;시스템&quot;ETS 테이블, 읽을 수없는 ETS 테이블 또는 Mnesia 테이블을 보려면 메뉴 &lt;strong&gt;보기&lt;/strong&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c749a9404534acc9874c4dddfbf96e28d745b82f" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Timers&lt;/strong&gt; shows all timer information found in the dump.</source>
          <target state="translated">탭 &lt;strong&gt;타이머&lt;/strong&gt; 는 덤프에서 찾은 모든 타이머 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="532adb7424e374188bddb153f94b5dffdd01a32b" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Trace Overview&lt;/strong&gt; handles tracing. Trace by selecting the processes or ports to be traced and how to trace them. For processes, you can trace messages, function calls, scheduling, garbage collections, and process-related events such as &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and many others. For ports, you can trace messages, scheduling and port-related events.</source>
          <target state="translated">탭 &lt;strong&gt;추적 개요&lt;/strong&gt; 는 추적을 처리합니다. 추적 할 프로세스 또는 포트와 추적 방법을 선택하여 추적하십시오. 프로세스의 경우, 메시지, 함수 호출, 스케줄링, 가비지 콜렉션 및 &lt;code&gt;spawn&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; 및 기타 여러 가지와 같은 프로세스 관련 이벤트를 추적 할 수 있습니다. 포트의 경우 메시지, 스케줄링 및 포트 관련 이벤트를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3b24916106c05d16fc45b26f326aea8327897c3" translate="yes" xml:space="preserve">
          <source>Tab.</source>
          <target state="translated">Tab.</target>
        </trans-unit>
        <trans-unit id="78e563ed4498b45afa55a612a7d50d8010f51d47" translate="yes" xml:space="preserve">
          <source>Table 1.1:</source>
          <target state="translated">표 1.1 :</target>
        </trans-unit>
        <trans-unit id="2ba8d01b5f4587ab25a8cf9806410e2f7f1f467f" translate="yes" xml:space="preserve">
          <source>Table 1.1: Configuration Parameters</source>
          <target state="translated">표 1.1 : 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="458a619e647863b2edbd583f53f1c4f27cc2c7fd" translate="yes" xml:space="preserve">
          <source>Table 1.1: File Types</source>
          <target state="translated">표 1.1 : 파일 형식</target>
        </trans-unit>
        <trans-unit id="d257f726296380c878ec40caabc8bee011031308" translate="yes" xml:space="preserve">
          <source>Table 10.1: Memory Size of Different Data Types</source>
          <target state="translated">표 10.1 : 다른 데이터 유형의 메모리 크기</target>
        </trans-unit>
        <trans-unit id="1177d151257b31d9c29f7aa373dc11ffece292c4" translate="yes" xml:space="preserve">
          <source>Table 10.2: System Limits</source>
          <target state="translated">표 10.2 : 시스템 제한</target>
        </trans-unit>
        <trans-unit id="fd59220c9b680aec464f9d24199fa3a8abdb16d2" translate="yes" xml:space="preserve">
          <source>Table 11.1: Exception Classes.</source>
          <target state="translated">표 11.1 : 예외 클래스</target>
        </trans-unit>
        <trans-unit id="d6b64accf1c2234e132511d0019f44d13d7aeb9f" translate="yes" xml:space="preserve">
          <source>Table 11.1: Tool Summary</source>
          <target state="translated">표 11.1 : 도구 요약</target>
        </trans-unit>
        <trans-unit id="f6169b398a7ff5ef27d299293d71cfddab2f0858" translate="yes" xml:space="preserve">
          <source>Table 11.2: Exit Reasons</source>
          <target state="translated">표 11.2 : 종료 이유</target>
        </trans-unit>
        <trans-unit id="b30a60a6dd809b8b57e40c37cb359be1d19a90fa" translate="yes" xml:space="preserve">
          <source>Table 12.10: SMALL_INTEGER_EXT</source>
          <target state="translated">표 12.10 : SMALL_INTEGER_EXT</target>
        </trans-unit>
        <trans-unit id="9866b94803a8e807cf22a1060604d66f72a8ea46" translate="yes" xml:space="preserve">
          <source>Table 12.11: INTEGER_EXT</source>
          <target state="translated">표 12.11 : INTEGER_EXT</target>
        </trans-unit>
        <trans-unit id="58ca896888c5b6bdb23917ab9d4badd52b5d9e0c" translate="yes" xml:space="preserve">
          <source>Table 12.12: FLOAT_EXT</source>
          <target state="translated">표 12.12 : FLOAT_EXT</target>
        </trans-unit>
        <trans-unit id="2fd6bbf622d7c5bf5fb9063eb1831d2717f4dd60" translate="yes" xml:space="preserve">
          <source>Table 12.13: REFERENCE_EXT</source>
          <target state="translated">표 12.13 : REFERENCE_EXT</target>
        </trans-unit>
        <trans-unit id="0578060eac8303938de8c878ec3873fcb4318376" translate="yes" xml:space="preserve">
          <source>Table 12.14: PORT_EXT</source>
          <target state="translated">표 12.14 : PORT_EXT</target>
        </trans-unit>
        <trans-unit id="96819e46fe9160b7684601591232299db1b36df4" translate="yes" xml:space="preserve">
          <source>Table 12.15: PID_EXT</source>
          <target state="translated">표 12.15 : PID_EXT</target>
        </trans-unit>
        <trans-unit id="929ef647be6942415e3f171358774bf82ec22c90" translate="yes" xml:space="preserve">
          <source>Table 12.16: SMALL_TUPLE_EXT</source>
          <target state="translated">표 12.16 : SMALL_TUPLE_EXT</target>
        </trans-unit>
        <trans-unit id="2bc9e7a9f0cdd26ab796e08ac173c9214cf33bb2" translate="yes" xml:space="preserve">
          <source>Table 12.17: LARGE_TUPLE_EXT</source>
          <target state="translated">표 12.17 : LARGE_TUPLE_EXT</target>
        </trans-unit>
        <trans-unit id="adb693dcc7fb1fd77fe8a58008cf68aa105437ec" translate="yes" xml:space="preserve">
          <source>Table 12.18: MAP_EXT</source>
          <target state="translated">표 12.18 : MAP_EXT</target>
        </trans-unit>
        <trans-unit id="0058992413b1a2072f46a8bef8849c819a9bd27c" translate="yes" xml:space="preserve">
          <source>Table 12.19: NIL_EXT</source>
          <target state="translated">표 12.19 : NIL_EXT</target>
        </trans-unit>
        <trans-unit id="8c7f1e0a03ffe076870e398ec25b8453d8eadb76" translate="yes" xml:space="preserve">
          <source>Table 12.1: Name Registration BIFs</source>
          <target state="translated">표 12.1 : 이름 등록 BIF</target>
        </trans-unit>
        <trans-unit id="ad64574492eb17bfd807110b90dea335f1c7aae2" translate="yes" xml:space="preserve">
          <source>Table 12.1: Term Format</source>
          <target state="translated">표 12.1 : 용어 형식</target>
        </trans-unit>
        <trans-unit id="0df8d7a0af860ca015d80e7243b43bef49703f4d" translate="yes" xml:space="preserve">
          <source>Table 12.20: STRING_EXT</source>
          <target state="translated">표 12.20 : STRING_EXT</target>
        </trans-unit>
        <trans-unit id="7c0155dab34e626428cf77c18f392f114ec8b923" translate="yes" xml:space="preserve">
          <source>Table 12.21: LIST_EXT</source>
          <target state="translated">표 12.21 : LIST_EXT</target>
        </trans-unit>
        <trans-unit id="aa41c1d8936052f161d20f526c915bdfa140ba72" translate="yes" xml:space="preserve">
          <source>Table 12.22: BINARY_EXT</source>
          <target state="translated">표 12.22 : BINARY_EXT</target>
        </trans-unit>
        <trans-unit id="36cf93a4b7064da1028c95fc5d153f969a05f23b" translate="yes" xml:space="preserve">
          <source>Table 12.23: SMALL_BIG_EXT</source>
          <target state="translated">표 12.23 : SMALL_BIG_EXT</target>
        </trans-unit>
        <trans-unit id="8b7dc77f03315b79ffa7b47922ecb22f0aa5f2e7" translate="yes" xml:space="preserve">
          <source>Table 12.24: LARGE_BIG_EXT</source>
          <target state="translated">표 12.24 : LARGE_BIG_EXT</target>
        </trans-unit>
        <trans-unit id="0bcc99ccfd58c2a94d4cf75fd172c14957bee41a" translate="yes" xml:space="preserve">
          <source>Table 12.25: NEW_REFERENCE_EXT</source>
          <target state="translated">표 12.25 : NEW_REFERENCE_EXT</target>
        </trans-unit>
        <trans-unit id="1b3e3a9c2a02cf90a00369084f14b0b26a667ff3" translate="yes" xml:space="preserve">
          <source>Table 12.26: FUN_EXT</source>
          <target state="translated">표 12.26 : FUN_EXT</target>
        </trans-unit>
        <trans-unit id="29a4858c0789b86f5465f8cb5db1421d2810276a" translate="yes" xml:space="preserve">
          <source>Table 12.27: NEW_FUN_EXT</source>
          <target state="translated">표 12.27 : NEW_FUN_EXT</target>
        </trans-unit>
        <trans-unit id="f399cbd0c09e84ad8dba436d6454ceb339fc9356" translate="yes" xml:space="preserve">
          <source>Table 12.28: EXPORT_EXT</source>
          <target state="translated">표 12.28 : EXPORT_EXT</target>
        </trans-unit>
        <trans-unit id="c4f8c6d2a98bb834eb44bbc5c62a5c56f9612215" translate="yes" xml:space="preserve">
          <source>Table 12.29: BIT_BINARY_EXT</source>
          <target state="translated">표 12.29 : BIT_BINARY_EXT</target>
        </trans-unit>
        <trans-unit id="9a7845dbd38fceef2f98e2021ad2db0a951f1f90" translate="yes" xml:space="preserve">
          <source>Table 12.2: Compressed Term Format</source>
          <target state="translated">표 12.2 : 압축 용어 형식</target>
        </trans-unit>
        <trans-unit id="69dd6d35b4f19964994f900ee8e129693a9ce6e5" translate="yes" xml:space="preserve">
          <source>Table 12.30: NEW_FLOAT_EXT</source>
          <target state="translated">표 12.30 : NEW_FLOAT_EXT</target>
        </trans-unit>
        <trans-unit id="39ba0ff930d671e34c458d513192e51e5782463c" translate="yes" xml:space="preserve">
          <source>Table 12.31: ATOM_UTF8_EXT</source>
          <target state="translated">표 12.31 : ATOM_UTF8_EXT</target>
        </trans-unit>
        <trans-unit id="71ae7d46f883a6cf5ca44c387bf96b8bf0304071" translate="yes" xml:space="preserve">
          <source>Table 12.32: SMALL_ATOM_UTF8_EXT</source>
          <target state="translated">표 12.32 : SMALL_ATOM_UTF8_EXT</target>
        </trans-unit>
        <trans-unit id="4f3e60db57ebf4f9ad1c8702519818c61269fd7b" translate="yes" xml:space="preserve">
          <source>Table 12.33: ATOM_EXT</source>
          <target state="translated">표 12.33 : ATOM_EXT</target>
        </trans-unit>
        <trans-unit id="d9763dcc196c99566fefe285bf27864c20b2a376" translate="yes" xml:space="preserve">
          <source>Table 12.34: SMALL_ATOM_EXT</source>
          <target state="translated">표 12.34 : SMALL_ATOM_EXT</target>
        </trans-unit>
        <trans-unit id="7f4f07bb52b5e0ac65f5c4b09be7c563c9af2a2a" translate="yes" xml:space="preserve">
          <source>Table 12.3: Compressed Data Format when Expanded</source>
          <target state="translated">표 12.3 : 확장시 압축 데이터 형식</target>
        </trans-unit>
        <trans-unit id="a1b25601d5798e4ada95d734eebfad09c3438475" translate="yes" xml:space="preserve">
          <source>Table 12.4: Distribution Header Format</source>
          <target state="translated">표 12.4 : 배포 헤더 형식</target>
        </trans-unit>
        <trans-unit id="7ae3242d88a1907427a116698d6e7daa006dee20" translate="yes" xml:space="preserve">
          <source>Table 12.5:</source>
          <target state="translated">표 12.5 :</target>
        </trans-unit>
        <trans-unit id="5a71917f82a2759e5a495c12c44a7eb3c885d967" translate="yes" xml:space="preserve">
          <source>Table 12.6:</source>
          <target state="translated">표 12.6 :</target>
        </trans-unit>
        <trans-unit id="7a6b6888acaa7d0157552bfe1d147e5f2ffc5c2a" translate="yes" xml:space="preserve">
          <source>Table 12.7:</source>
          <target state="translated">표 12.7 :</target>
        </trans-unit>
        <trans-unit id="d455469fa598129902ab217f6b876f8e08b0c329" translate="yes" xml:space="preserve">
          <source>Table 12.8:</source>
          <target state="translated">표 12.8 :</target>
        </trans-unit>
        <trans-unit id="7e4fc9ad71d6c65901eeebf5f25e8c4321f8fd5d" translate="yes" xml:space="preserve">
          <source>Table 12.9: ATOM_CACHE_REF</source>
          <target state="translated">표 12.9 : ATOM_CACHE_REF</target>
        </trans-unit>
        <trans-unit id="2b3c51ca48ed62a11f8f6b268d0cfb454be00ab2" translate="yes" xml:space="preserve">
          <source>Table 13.10: DUMP_RESP</source>
          <target state="translated">표 13.10 : DUMP_RESP</target>
        </trans-unit>
        <trans-unit id="a1268f8a739adc2dd0b6cf61f8bcf9b2c1a25af3" translate="yes" xml:space="preserve">
          <source>Table 13.11: KILL_REQ</source>
          <target state="translated">표 13.11 : KILL_REQ</target>
        </trans-unit>
        <trans-unit id="9924291901a5a0b8fe67cb8613a69112ee2d49ab" translate="yes" xml:space="preserve">
          <source>Table 13.12: KILL_RESP</source>
          <target state="translated">표 13.12 : KILL_RESP</target>
        </trans-unit>
        <trans-unit id="521337e4c6544841a20f88ecfc0c1ea60912a86c" translate="yes" xml:space="preserve">
          <source>Table 13.13: STOP_REQ</source>
          <target state="translated">표 13.13 : STOP_REQ</target>
        </trans-unit>
        <trans-unit id="0ff58a2b54089117b1d4d95d994b2ed678f3c4cf" translate="yes" xml:space="preserve">
          <source>Table 13.14: STOP_RESP</source>
          <target state="translated">표 13.14 : STOP_RESP</target>
        </trans-unit>
        <trans-unit id="a5cdc90bbaefb168ea142b2790c03070e154af9b" translate="yes" xml:space="preserve">
          <source>Table 13.15: STOP_NOTOK_RESP</source>
          <target state="translated">표 13.15 : STOP_NOTOK_RESP</target>
        </trans-unit>
        <trans-unit id="7b97daf857d1cf5519b64b59f2c01112e80fd279" translate="yes" xml:space="preserve">
          <source>Table 13.16: Format of Messages Passed between Nodes (as from ERTS 5.7.2)</source>
          <target state="translated">표 13.16 : 노드간에 전달 된 메시지 형식 (ERTS 5.7.2에서와 같이)</target>
        </trans-unit>
        <trans-unit id="0235810478165bd4a5414161e73679ab6e077e20" translate="yes" xml:space="preserve">
          <source>Table 13.17: Format of Messages Passed between Nodes (before ERTS 5.7.2)</source>
          <target state="translated">표 13.17 : 노드간에 전달 된 메시지 형식 (ERTS 5.7.2 이전)</target>
        </trans-unit>
        <trans-unit id="03bda7e932b3f1c5bed1e5d6d2070739f08eaf1c" translate="yes" xml:space="preserve">
          <source>Table 13.1: Distribution BIFs</source>
          <target state="translated">표 13.1 : 분포 BIF</target>
        </trans-unit>
        <trans-unit id="61638ac22a7cbdb6b5559917090de7497beade99" translate="yes" xml:space="preserve">
          <source>Table 13.1: Request Format</source>
          <target state="translated">표 13.1 : 요청 형식</target>
        </trans-unit>
        <trans-unit id="42e15dae13f3c331c9200d0729d1ddc9e0e50071" translate="yes" xml:space="preserve">
          <source>Table 13.2: ALIVE2_REQ (120)</source>
          <target state="translated">표 13.2 : ALIVE2_REQ (120)</target>
        </trans-unit>
        <trans-unit id="c6a77d421f864fb58dddfaf3e3633bdb241cbfda" translate="yes" xml:space="preserve">
          <source>Table 13.2: Distribution Command-Line Flags</source>
          <target state="translated">표 13.2 : 배포 명령 줄 플래그</target>
        </trans-unit>
        <trans-unit id="9aea119540385e38157e1b773684ae3d6cbe0ba8" translate="yes" xml:space="preserve">
          <source>Table 13.3: ALIVE2_RESP (121)</source>
          <target state="translated">표 13.3 : ALIVE2_RESP (121)</target>
        </trans-unit>
        <trans-unit id="94bfc83da20e2a496446d2150cfc714838620ceb" translate="yes" xml:space="preserve">
          <source>Table 13.3: Kernel Modules Useful For Distribution.</source>
          <target state="translated">표 13.3 : 배포에 유용한 커널 모듈.</target>
        </trans-unit>
        <trans-unit id="4aac3932070e2c73da7f9a23bb587d59bdb5f802" translate="yes" xml:space="preserve">
          <source>Table 13.4: PORT_PLEASE2_REQ (122)</source>
          <target state="translated">표 13.4 : PORT_PLEASE2_REQ (122)</target>
        </trans-unit>
        <trans-unit id="719629eb907013d0ec53e4c81e41dc5f23ae20a4" translate="yes" xml:space="preserve">
          <source>Table 13.4: STDLIB Modules Useful For Distribution.</source>
          <target state="translated">표 13.4 : 분배에 유용한 STDLIB 모듈.</target>
        </trans-unit>
        <trans-unit id="0f35a1a83b6107724dd65d19a2ced52d720d62b9" translate="yes" xml:space="preserve">
          <source>Table 13.5: PORT2_RESP (119) Response Indicating Error, Result &amp;gt; 0</source>
          <target state="translated">표 13.5 : PORT2_RESP (119) 응답 오류, 결과&amp;gt; 0</target>
        </trans-unit>
        <trans-unit id="d7346d09d095d6d89b7bb97b2f6f60397d92b506" translate="yes" xml:space="preserve">
          <source>Table 13.6: PORT2_RESP, Result = 0</source>
          <target state="translated">표 13.6 : PORT2_RESP, 결과 = 0</target>
        </trans-unit>
        <trans-unit id="7651664c52537de188b4793cbd87741bdb99dbbe" translate="yes" xml:space="preserve">
          <source>Table 13.7: NAMES_REQ (110)</source>
          <target state="translated">표 13.7 : NAMES_REQ (110)</target>
        </trans-unit>
        <trans-unit id="b2f285bf0e8f76155a1b2ba2e26572814a0b098a" translate="yes" xml:space="preserve">
          <source>Table 13.8: NAMES_RESP</source>
          <target state="translated">표 13.8 : NAMES_RESP</target>
        </trans-unit>
        <trans-unit id="4db4ef3f34f7a95b11e9b62f8eb6359c7f0c035b" translate="yes" xml:space="preserve">
          <source>Table 13.9: DUMP_REQ</source>
          <target state="translated">표 13.9 : DUMP_REQ</target>
        </trans-unit>
        <trans-unit id="a28dfe55e369b981e9989ca655f8070823b288d4" translate="yes" xml:space="preserve">
          <source>Table 14.1: Scope of a CTH</source>
          <target state="translated">표 14.1 : CTH의 범위</target>
        </trans-unit>
        <trans-unit id="6f346618d895fae04b070f63801d27512e0a114e" translate="yes" xml:space="preserve">
          <source>Table 15.1: Port Creation BIF</source>
          <target state="translated">표 15.1 : 포트 생성 BIF</target>
        </trans-unit>
        <trans-unit id="5702cda3079894261cf21470de9842cbf06107d1" translate="yes" xml:space="preserve">
          <source>Table 15.2: Messages Sent To a Port</source>
          <target state="translated">표 15.2 : 포트로 보낸 메시지</target>
        </trans-unit>
        <trans-unit id="d888dee5eb271a175c076f3da8428908d38f7a20" translate="yes" xml:space="preserve">
          <source>Table 15.3: Messages Received From a Port</source>
          <target state="translated">표 15.3 : 포트에서받은 메시지</target>
        </trans-unit>
        <trans-unit id="728ee03beb77f2dd0af6fd6ba498d0eba5ed22d9" translate="yes" xml:space="preserve">
          <source>Table 15.4: Port BIFs</source>
          <target state="translated">표 15.4 : 포트 BIF</target>
        </trans-unit>
        <trans-unit id="b27132ceaa20acb15aedc85775feadc97cf98c9c" translate="yes" xml:space="preserve">
          <source>Table 16.1: Error Messages</source>
          <target state="translated">표 16.1 : 오류 메시지</target>
        </trans-unit>
        <trans-unit id="5f4934e67a618cf41c7091ca6f0fc3ad49ab6cce" translate="yes" xml:space="preserve">
          <source>Table 2.1: Character Classes</source>
          <target state="translated">표 2.1 : 문자 클래스</target>
        </trans-unit>
        <trans-unit id="6eaaaa238c86c88e40d4df41a53e15cc0448911e" translate="yes" xml:space="preserve">
          <source>Table 2.1: Log Levels</source>
          <target state="translated">표 2.1 : 로그 수준</target>
        </trans-unit>
        <trans-unit id="4fc595026f67776148a8c9da2e83cff6c4e748e1" translate="yes" xml:space="preserve">
          <source>Table 2.1: Signature Algorithm OIDs</source>
          <target state="translated">표 2.1 : 서명 알고리즘 OID</target>
        </trans-unit>
        <trans-unit id="b559a4c56db17477d2000244623dc69a859d8ced" translate="yes" xml:space="preserve">
          <source>Table 2.2: Attribute OIDs</source>
          <target state="translated">표 2.2 : 속성 OID</target>
        </trans-unit>
        <trans-unit id="61329aaff17f9cdc353879f67a1b6c2c2ced1057" translate="yes" xml:space="preserve">
          <source>Table 2.3: Public-Key Algorithm OIDs</source>
          <target state="translated">표 2.3 : 공개 키 알고리즘 OID</target>
        </trans-unit>
        <trans-unit id="63c67e425d843f44c3ad3944ba2ea398bf3390ac" translate="yes" xml:space="preserve">
          <source>Table 2.4: Standard Certificate Extensions</source>
          <target state="translated">표 2.4 : 표준 인증서 확장</target>
        </trans-unit>
        <trans-unit id="1d07377a9b4d3d0fdc53c19f9b80541a838d71a0" translate="yes" xml:space="preserve">
          <source>Table 2.5: Key Purpose OIDs</source>
          <target state="translated">표 2.5 : 주요 목적 OID</target>
        </trans-unit>
        <trans-unit id="c9a0d1dbd63f25fa4cab07cb6e81975a5434e58c" translate="yes" xml:space="preserve">
          <source>Table 2.6: Private Internet Extensions</source>
          <target state="translated">도표 2.6 : 개인 인터넷 연장</target>
        </trans-unit>
        <trans-unit id="3c4523326210a6e49a84a168a517493f6b494085" translate="yes" xml:space="preserve">
          <source>Table 2.7: CRL Extensions</source>
          <target state="translated">표 2.7 : CRL 확장</target>
        </trans-unit>
        <trans-unit id="e599a4ff0cd3050fdc6bb940882734dade0ed796" translate="yes" xml:space="preserve">
          <source>Table 2.8: CRL Entry Extensions</source>
          <target state="translated">표 2.8 : CRL 항목 확장</target>
        </trans-unit>
        <trans-unit id="69a5a550952ff1d1582f1327251b38f6f3925307" translate="yes" xml:space="preserve">
          <source>Table 3.1: Mapping of ODBC data types to the Erlang data types returned to the Erlang application.</source>
          <target state="translated">표 3.1 : Erlang 응용 프로그램에 리턴 된 Erlang 데이터 유형에 ODBC 데이터 유형 맵핑</target>
        </trans-unit>
        <trans-unit id="f8612a65d1f97ebf0034cd75baf0addcfe1c0893" translate="yes" xml:space="preserve">
          <source>Table 3.1: Recognized Escape Sequences</source>
          <target state="translated">표 3.1 : 인식 된 탈출 시퀀스</target>
        </trans-unit>
        <trans-unit id="9809e96d44e0af0600d936e259f842538f07e64b" translate="yes" xml:space="preserve">
          <source>Table 3.1: Supported ASN.1 Types</source>
          <target state="translated">표 3.1 : 지원되는 ASN.1 유형</target>
        </trans-unit>
        <trans-unit id="02b78e9c5cb42c3363db65995522a67a8422f0e9" translate="yes" xml:space="preserve">
          <source>Table 3.1: employee Database Record</source>
          <target state="translated">표 3.1 : 직원 데이터베이스 레코드</target>
        </trans-unit>
        <trans-unit id="e2e04ae1720c523c09ad885d4bba619975d91dfd" translate="yes" xml:space="preserve">
          <source>Table 3.2: Mapping of extended ODBC data types to the Erlang data types returned to the Erlang application.</source>
          <target state="translated">표 3.2 : 확장 된 ODBC 데이터 유형을 Erlang 애플리케이션에 리턴 된 Erlang 데이터 유형으로 맵핑</target>
        </trans-unit>
        <trans-unit id="c8fbe8731442bcc46734767ff421f607aa0f0b93" translate="yes" xml:space="preserve">
          <source>Table 3.2: at_dep Database Record</source>
          <target state="translated">표 3.2 : at_dep 데이터베이스 레코드</target>
        </trans-unit>
        <trans-unit id="472618ae5b8faf29f64e6182f23e94d8e8d2b3ff" translate="yes" xml:space="preserve">
          <source>Table 3.3: in_proj Database Record</source>
          <target state="translated">표 3.3 : in_proj 데이터베이스 레코드</target>
        </trans-unit>
        <trans-unit id="bd55e55c0bac662bbb91c2dab6fadd4546456110" translate="yes" xml:space="preserve">
          <source>Table 4.1: Match target depending on context</source>
          <target state="translated">표 4.1 : 상황에 따른 일치 대상</target>
        </trans-unit>
        <trans-unit id="2d25688454b2bb5450c1309279e78263e6dbd7f4" translate="yes" xml:space="preserve">
          <source>Table 4.1: RFC 6733 Compliance</source>
          <target state="translated">표 4.1 : RFC 6733 준수</target>
        </trans-unit>
        <trans-unit id="732bc539aa9e2aceaab8c419c46c7186220b8351" translate="yes" xml:space="preserve">
          <source>Table 4.1: Results of Complete, Exclusive, and Selective Decode</source>
          <target state="translated">표 4.1 : 완전, 독점 및 선택적 디코딩 결과</target>
        </trans-unit>
        <trans-unit id="2f6119a0a2c06c96a45bed121e21994c92602dec" translate="yes" xml:space="preserve">
          <source>Table 4.2: Literals in MatchCondition/MatchBody Parts of a Match Specification</source>
          <target state="translated">표 4.2 : 일치 사양의 MatchCondition / MatchBody 부분에있는 리터럴</target>
        </trans-unit>
        <trans-unit id="03c941b5ad0f9163428dd761c1aa72825546017a" translate="yes" xml:space="preserve">
          <source>Table 4.2: Results of Complete, Exclusive + decode_part, and Selective + complete decodes</source>
          <target state="translated">표 4.2 : Complete, Exclusive + decode_part 및 Selective + complete 디코드 결과</target>
        </trans-unit>
        <trans-unit id="998575c4a113a89d67de8200527ab2f0671412a3" translate="yes" xml:space="preserve">
          <source>Table 7.1: Built-in types, predefined aliases</source>
          <target state="translated">표 7.1 : 내장 유형, 사전 정의 된 별명</target>
        </trans-unit>
        <trans-unit id="7a46d02c216b62f4c7966fc627277fbbd5dca1db" translate="yes" xml:space="preserve">
          <source>Table 7.2: Additional built-in types</source>
          <target state="translated">표 7.2 : 추가 내장형</target>
        </trans-unit>
        <trans-unit id="f425729931f6d1bdbaed18495dcda8f6c61e9665" translate="yes" xml:space="preserve">
          <source>Table 8.1: Codec performance</source>
          <target state="translated">표 8.1 : 코덱 성능</target>
        </trans-unit>
        <trans-unit id="f02b919abba6c2f9f7cea19a79d8563e91342705" translate="yes" xml:space="preserve">
          <source>Table 8.1: Term Comparison Operators.</source>
          <target state="translated">표 8.1 : 용어 비교 연산자.</target>
        </trans-unit>
        <trans-unit id="44dbfccf55391a47eda37e5337bceb5e6751ff98" translate="yes" xml:space="preserve">
          <source>Table 8.2: Arithmetic Operators.</source>
          <target state="translated">표 8.2 : 산술 연산자.</target>
        </trans-unit>
        <trans-unit id="80ab66478c80211ef28ea87ebf180af9badfa505" translate="yes" xml:space="preserve">
          <source>Table 8.3: Logical Operators.</source>
          <target state="translated">표 8.3 : 논리 연산자</target>
        </trans-unit>
        <trans-unit id="d1b590658d7f606934706fe12855a35158b7b9ae" translate="yes" xml:space="preserve">
          <source>Table 8.4: Type Test BIFs</source>
          <target state="translated">표 8.4 : 유형 테스트 BIF</target>
        </trans-unit>
        <trans-unit id="e2253a5b23eb77ff9aec768859a9f84ff6371656" translate="yes" xml:space="preserve">
          <source>Table 8.5: Other BIFs Allowed in Guard Expressions</source>
          <target state="translated">표 8.5 : 가드 식에서 허용되는 다른 BIF</target>
        </trans-unit>
        <trans-unit id="0053f71504d170421443aa2340e9bdc8a8bc2b06" translate="yes" xml:space="preserve">
          <source>Table 8.6: Operator Precedence</source>
          <target state="translated">표 8.6 : 운영자 우선 순위</target>
        </trans-unit>
        <trans-unit id="a654ccdbe37f52ad3e2371abec18594740d9d987" translate="yes" xml:space="preserve">
          <source>Table 9.1: tty Text Editing</source>
          <target state="translated">표 9.1 : tty 텍스트 편집</target>
        </trans-unit>
        <trans-unit id="785160c54069d8c0488a6885b676c3ed7ac94f33" translate="yes" xml:space="preserve">
          <source>Table attributes are specified when the table is created. For example, the following function creates a table with two RAM replicas:</source>
          <target state="translated">테이블 속성은 테이블이 생성 될 때 지정됩니다. 예를 들어 다음 함수는 두 개의 RAM 복제본이있는 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="920197fc8c7d9a17f9bba1e891a31f5e6bab2db5" translate="yes" xml:space="preserve">
          <source>Table events are events related to table updates. There are two types of table events, simple and detailed.</source>
          <target state="translated">테이블 이벤트는 테이블 업데이트와 관련된 이벤트입니다. 단순 및 상세의 두 가지 유형의 테이블 이벤트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2cbbd1fe71c50be54063ec6ec279f2e5068eec" translate="yes" xml:space="preserve">
          <source>Table fragmentation</source>
          <target state="translated">테이블 조각화</target>
        </trans-unit>
        <trans-unit id="b321d78d8188930584227fd683d25947228f5912" translate="yes" xml:space="preserve">
          <source>Table indexes can be used whenever the user wants to use frequently some other field than the key field to look up records. If this other field has an associated index, these lookups can occur in constant time and space. For example, if your application wishes to use field &lt;code&gt;age&lt;/code&gt; to find efficiently all persons with a specific age, it can be a good idea to have an index on field &lt;code&gt;age&lt;/code&gt;. This can be done with the following call:</source>
          <target state="translated">사용자가 키 필드 이외의 다른 필드를 자주 사용하여 레코드를 조회하려고 할 때마다 테이블 인덱스를 사용할 수 있습니다. 이 다른 필드에 관련 인덱스가있는 경우 이러한 조회는 일정한 시간과 공간에서 발생할 수 있습니다. 응용 프로그램 소원 필드의 사용 예를 들어, &lt;code&gt;age&lt;/code&gt; 효율적으로 특정 연령과 모든 사람을 찾기 위해,이 필드에 대한 인덱스가 좋은 아이디어가 될 수있는 &lt;code&gt;age&lt;/code&gt; . 다음과 같은 호출로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88fa77c87adc2265ab448874618640494fc6308" translate="yes" xml:space="preserve">
          <source>Table initialization is asynchronous. The function call &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the atom &lt;code&gt;ok&lt;/code&gt; and then starts to initialize the different tables. Depending on the size of the database, this can take some time, and the application programmer must wait for the tables that the application needs before they can be used. This is achieved by using the function &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt;, which suspends the caller until all tables specified in &lt;code&gt;TabList&lt;/code&gt; are properly initiated.</source>
          <target state="translated">테이블 초기화는 비동기 적입니다. 함수 호출 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 원자 반환 &lt;code&gt;ok&lt;/code&gt; 한 후 다른 테이블을 초기화하기 시작합니다. 데이터베이스의 크기에 따라 시간이 걸릴 수 있으며 응용 프로그램 프로그래머는 응용 프로그램이 사용하기 전에 필요한 테이블을 기다려야합니다. 이 함수를 이용함으로써 달성된다 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; 에서 지정된 모든 테이블까지 호출을 중단, &lt;code&gt;TabList&lt;/code&gt; 적절히 개시되어있다.</target>
        </trans-unit>
        <trans-unit id="3d3b49fdca0320ed3b3453c5ed3280cae1c7efa5" translate="yes" xml:space="preserve">
          <source>Table locations are transparent to the programmer. Programs address table names and the system itself keeps track of table locations.</source>
          <target state="translated">테이블 위치는 프로그래머에게 투명합니다. 프로그램은 테이블 이름을 지정하고 시스템 자체는 테이블 위치를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="866e46fb585eb175d52c33c7d9ae3c6b97b99178" translate="yes" xml:space="preserve">
          <source>Table replicas of type &lt;code&gt;ram_copies&lt;/code&gt; can be dumped to disc with the function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ram_copies&lt;/code&gt; 유형의 테이블 복제본은 &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 디스크에 덤프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af955ef17e57c071c4e89fa1503d4f412aa17a54" translate="yes" xml:space="preserve">
          <source>Table type &lt;code&gt;ordered_set&lt;/code&gt; is not affected by this option. Also, the memory consumption inflicted by both &lt;code&gt;write_concurrency&lt;/code&gt; and &lt;code&gt;read_concurrency&lt;/code&gt; is a constant overhead per table. This overhead can be especially large when both options are combined.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형 은이 옵션의 영향을받지 않습니다. 또한 &lt;code&gt;write_concurrency&lt;/code&gt; 와 &lt;code&gt;read_concurrency&lt;/code&gt; 에 의해 발생하는 메모리 소비 는 테이블 당 일정한 오버 헤드입니다. 이 옵션은 두 옵션을 결합 할 때 특히 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae7173fc695a7e90d392ed4e8e9a097c6a14f85" translate="yes" xml:space="preserve">
          <source>Tables are divided into four different types, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt;. A &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; table can only have one object associated with each key. A &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt; table can have many objects associated with each key.</source>
          <target state="translated">테이블은 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;ordered_set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 및 &lt;code&gt;duplicate_bag&lt;/code&gt; 의 네 가지 유형으로 나뉩니다 . &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; 표는 각 키와 연관된 하나의 개체를 가질 수 있습니다. &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 표는 각 키와 연관된 많은 개체를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d69fb54ae6920c0beb5343651ca15f5e6afaac" translate="yes" xml:space="preserve">
          <source>Tables can also have the following properties, where each attribute has a list of Erlang nodes as its value:</source>
          <target state="translated">테이블에는 다음과 같은 속성이있을 수 있습니다. 여기서 각 속성에는 값으로 Erlang 노드 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de93908f0780db239ff5e538fea7ea2e43c2dd38" translate="yes" xml:space="preserve">
          <source>Tables can be created and new replicas can be added without starting all the disc-full nodes.</source>
          <target state="translated">디스크 전체 노드를 모두 시작하지 않고도 테이블을 작성하고 새 복제본을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d07956b5358d935c57f6803cf4b6ad1ef2830cb4" translate="yes" xml:space="preserve">
          <source>Tables can be declared to have properties such as location, replication, and persistence.</source>
          <target state="translated">위치, 복제 및 지속성과 같은 속성을 갖도록 테이블을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f511e28cba4a01c743772e67af1ac7ec40828dab" translate="yes" xml:space="preserve">
          <source>Tables can be moved or deleted, and the layout of a table can be reconfigured in various ways. An important aspect of the implementation of these functions is that user programs can continue to use a table while it is being reconfigured. For example, it is possible to move a table and perform write operations to the table at the same time. This is important for many applications that require continuously available services. For more information, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#trans_prop&quot;&gt;Transactions and Other Access Contexts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블을 이동하거나 삭제할 수 있으며 테이블 레이아웃을 다양한 방식으로 재구성 할 수 있습니다. 이러한 기능 구현의 중요한 측면은 사용자 프로그램이 재구성되는 동안 테이블을 계속 사용할 수 있다는 것입니다. 예를 들어, 테이블을 이동하고 동시에 테이블에 대한 쓰기 작업을 수행 할 수 있습니다. 지속적으로 사용 가능한 서비스가 필요한 많은 응용 프로그램에 중요합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#trans_prop&quot;&gt;Transactions and Other Access Contexts&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d7bc03ffa55eb50ff02b4db69153553fd45996c" translate="yes" xml:space="preserve">
          <source>Tables can be moved or replicated to several nodes to improve fault tolerance. The rest of the system can still access the tables to read, write, and delete records.</source>
          <target state="translated">내결함성을 향상시키기 위해 테이블을 여러 노드로 이동하거나 복제 할 수 있습니다. 나머지 시스템은 여전히 ​​테이블에 액세스하여 레코드를 읽고 쓰고 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e957eb66e13f1765798b7a25ea084ce54f8043" translate="yes" xml:space="preserve">
          <source>Tables can be restored online from a backup without restarting &lt;code&gt;Mnesia&lt;/code&gt;. A restore is performed with the function &lt;code&gt;&lt;a href=&quot;mnesia#restore-2&quot;&gt;mnesia:restore(Opaque, Args)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; can contain the following tuples:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 다시 시작하지 않고도 백업에서 테이블을 온라인으로 복원 할 수 있습니다 . 복원은 &lt;code&gt;&lt;a href=&quot;mnesia#restore-2&quot;&gt;mnesia:restore(Opaque, Args)&lt;/a&gt;&lt;/code&gt; 함수로 수행 되며 &lt;code&gt;Args&lt;/code&gt; 는 다음 튜플을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57d67e1acfe0bf746b51a2068d14140f7e2255b" translate="yes" xml:space="preserve">
          <source>Tables must be written in the following order: &lt;code&gt;tableObject&lt;/code&gt;, &lt;code&gt;entryObject&lt;/code&gt;, &lt;code&gt;column1&lt;/code&gt;, ..., &lt;code&gt;columnN&lt;/code&gt; (in order).</source>
          <target state="translated">테이블은 &lt;code&gt;tableObject&lt;/code&gt; , &lt;code&gt;entryObject&lt;/code&gt; , &lt;code&gt;column1&lt;/code&gt; , ..., &lt;code&gt;columnN&lt;/code&gt; 순서대로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c69aeb6234da315154088828f3897ee8809919c" translate="yes" xml:space="preserve">
          <source>Tables of type &lt;code&gt;ram_copies&lt;/code&gt; are by definition stored in memory only. However, these tables can be dumped to disc, either at regular intervals or before the system is shut down. The function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; dumps all replicas of a set of RAM tables to disc. The tables can be accessed while being dumped to disc. To dump the tables to disc, all replicas must have the storage type &lt;code&gt;ram_copies&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ram_copies&lt;/code&gt; 유형의 테이블은 정의상 메모리에만 저장됩니다. 그러나 이러한 테이블은 정기적으로 또는 시스템이 종료되기 전에 디스크에 덤프 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; 함수 는 RAM 테이블 세트의 모든 복제본을 디스크에 덤프합니다. 디스크에 덤프되는 동안 테이블에 액세스 할 수 있습니다. 테이블을 디스크에 덤프하려면 모든 복제본에 스토리지 유형 &lt;code&gt;ram_copies&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f87c90bac9b358ab772324758ec3588f0e6d15" translate="yes" xml:space="preserve">
          <source>Tables that are created with these functions can be administered as all other Mnesia tables. They can be included in backups, replicas can be added, and so on. The tables are normal Mnesia tables owned by the user of the corresponding &lt;code&gt;erl_interface&lt;/code&gt; registries.</source>
          <target state="translated">이 기능으로 작성된 테이블은 다른 모든 Mnesia 테이블로 관리 할 수 ​​있습니다. 백업에 포함시킬 수 있고 복제본을 추가 할 수 있습니다. 테이블은 해당 &lt;code&gt;erl_interface&lt;/code&gt; 레지스트리 사용자가 소유 한 일반 Mnesia 테이블 입니다.</target>
        </trans-unit>
        <trans-unit id="743d28560816377de1f1a84b0e5ab1bcad9a2851" translate="yes" xml:space="preserve">
          <source>Tables that are only stored locally are initialized from the local &lt;code&gt;Mnesia&lt;/code&gt; directory.</source>
          <target state="translated">로컬로만 저장된 테이블은 로컬 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리 에서 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="15e17f79ab456ddb783d4d81329edb91056f584b" translate="yes" xml:space="preserve">
          <source>Tables that reside on remote nodes are available to other nodes as soon as they are loaded.</source>
          <target state="translated">원격 노드에 상주하는 테이블은 다른 노드가로드 되 자마자 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="982963c1c41cbed8cab073724749592fe35c532b" translate="yes" xml:space="preserve">
          <source>Tag</source>
          <target state="translated">Tag</target>
        </trans-unit>
        <trans-unit id="ecc1e9ce18cc1f51b207c2bdf13311e34431c5b1" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;ct_hooks&lt;/code&gt; specifies the &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; to be run with this suite.</source>
          <target state="translated">&lt;code&gt;ct_hooks&lt;/code&gt; 태그 는이 스위트에서 실행할 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="15ecb35628e9ad80298a11e2caca7262306b1658" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables required by test cases (or configuration functions) in the suite. If the required configuration variables are not found in any of the configuration files, all test cases are skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see funtion &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">태그 &lt;code&gt;require&lt;/code&gt; 는 스위트에서 테스트 케이스 (또는 구성 기능)에 필요한 구성 변수를 지정합니다. 필요한 구성 변수가 구성 파일에 없으면 모든 테스트 사례를 건너 뜁니다. &lt;code&gt;require&lt;/code&gt; 기능 에 대한 자세한 내용 은 funct &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2131aee1075ebd4d5a669ce0e3a2b0c83464a600" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables required by test cases (or configuration functions) in the suite. If the required configuration variables are not found in any of the configuration files, all test cases in this group are skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">태그 &lt;code&gt;require&lt;/code&gt; 는 스위트에서 테스트 케이스 (또는 구성 기능)에 필요한 구성 변수를 지정합니다. 필요한 구성 변수가 구성 파일에 없으면이 그룹의 모든 테스트 사례를 건너 뜁니다. &lt;code&gt;require&lt;/code&gt; 기능 에 대한 자세한 내용 은 함수 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f43fa665fa7746b66b55e1550ce1441ca788c63" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables that are required by the test case (or &lt;code&gt;init_per_testcase/2&lt;/code&gt; or &lt;code&gt;end_per_testcase/2&lt;/code&gt;). If the required configuration variables are not found in any of the configuration files, the test case is skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">태그 &lt;code&gt;require&lt;/code&gt; 는 테스트 케이스에 필요한 구성 변수 (또는 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 또는 &lt;code&gt;end_per_testcase/2&lt;/code&gt; )를 지정합니다. 필요한 구성 변수가 구성 파일에 없으면 테스트 사례를 건너 뜁니다. &lt;code&gt;require&lt;/code&gt; 기능 에 대한 자세한 내용 은 함수 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb7858b354350ab4f0327568ec7e4c4a738e1efd" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;timetrap&lt;/code&gt; sets the maximum time that each test case is allowed to execute (including &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt;). If the timetrap time is exceeded, the test case fails with reason &lt;code&gt;timetrap_timeout&lt;/code&gt;. A &lt;code&gt;TimeFunc&lt;/code&gt; function can be used to set a new timetrap by returning a &lt;code&gt;TimeVal&lt;/code&gt;. It can also be used to trigger a timetrap time-out by, at some point, returning a value other than a &lt;code&gt;TimeVal&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">태그 &lt;code&gt;timetrap&lt;/code&gt; 은 각 테스트 케이스가 실행될 수있는 최대 시간을 설정합니다 ( &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 포함 ). 타임 트랩 시간이 초과되면 &lt;code&gt;timetrap_timeout&lt;/code&gt; 이유로 테스트 케이스가 실패합니다 . &lt;code&gt;TimeFunc&lt;/code&gt; 의 함수는 반환하여 새로운 timetrap을 설정하는 데 사용할 수 있습니다 &lt;code&gt;TimeVal&lt;/code&gt; . 어떤 시점에서 &lt;code&gt;TimeVal&lt;/code&gt; 이외의 값을 반환하여 타임 트랩 시간 초과를 트리거하는 데 사용할 수도 있습니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22c64cb3bbc94cdf7758855dd0abf0e6e66c2d5d" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;timetrap&lt;/code&gt; sets the maximum time that the test case is allowed to execute. If the timetrap time is exceeded, the test case fails with reason &lt;code&gt;timetrap_timeout&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; are included in the timetrap time. A &lt;code&gt;TimeFunc&lt;/code&gt; function can be used to set a new timetrap by returning a &lt;code&gt;TimeVal&lt;/code&gt;. It can also be used to trigger a timetrap time-out by, at some point, returning a value other than a &lt;code&gt;TimeVal&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">태그 &lt;code&gt;timetrap&lt;/code&gt; 은 테스트 사례를 실행할 수있는 최대 시간을 설정합니다. 타임 트랩 시간이 초과되면 &lt;code&gt;timetrap_timeout&lt;/code&gt; 이유로 테스트 케이스가 실패합니다 . &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 는 타임 트랩 시간에 포함됩니다. &lt;code&gt;TimeFunc&lt;/code&gt; 의 함수는 반환하여 새로운 timetrap을 설정하는 데 사용할 수 있습니다 &lt;code&gt;TimeVal&lt;/code&gt; . 어떤 시점에서 &lt;code&gt;TimeVal&lt;/code&gt; 이외의 값을 반환하여 타임 트랩 시간 초과를 트리거하는 데 사용할 수도 있습니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89a60b10c6d51637e3c074271431727f5e04acf4" translate="yes" xml:space="preserve">
          <source>Tag = atom()</source>
          <target state="translated">태그 = atom ()</target>
        </trans-unit>
        <trans-unit id="68ddd91d0b9671a791224a07e7c4440e749e446a" translate="yes" xml:space="preserve">
          <source>Tagalog</source>
          <target state="translated">Tagalog</target>
        </trans-unit>
        <trans-unit id="d97ec9a0d0dd8012061bd1e25a018f7d246bc720" translate="yes" xml:space="preserve">
          <source>Tagbanwa</source>
          <target state="translated">Tagbanwa</target>
        </trans-unit>
        <trans-unit id="0ea98ee2966f1a8d2f98d0a5da489f41da74714d" translate="yes" xml:space="preserve">
          <source>Tags aprops (&lt;code&gt;tags-apropos&lt;/code&gt;) - Display list of all tags in tags table REGEXP matches.</source>
          <target state="translated">태그 aprops ( &lt;code&gt;tags-apropos&lt;/code&gt; )-태그 테이블 REGEXP와 일치하는 모든 태그 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4f0c99b831a4946575130ded67ce565cb0d708d" translate="yes" xml:space="preserve">
          <source>Tags are not mentioned any more in this User's Guide.</source>
          <target state="translated">이 사용자 안내서에는 더 이상 태그가 언급되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f82a46a5e411e593e3fc9e2da286865bcb2e4ed" translate="yes" xml:space="preserve">
          <source>Tags is a standard Emacs package used to record information about source files in large development projects. In addition to listing the files of a project, a tags file normally contains information about all functions and variables that are defined. By far, the most useful command of the tags system is its ability to find the definition of functions in any file in the project. However the Tags system is not limited to this feature, for example, it is possible to do a text search in all files in a project, or to perform a project-wide search and replace.</source>
          <target state="translated">태그는 대규모 개발 프로젝트에서 소스 파일에 대한 정보를 기록하는 데 사용되는 표준 Emacs 패키지입니다. 프로젝트 파일을 나열하는 것 외에도 태그 파일에는 일반적으로 정의 된 모든 함수 및 변수에 대한 정보가 포함됩니다. 태그 시스템의 가장 유용한 명령은 프로젝트의 모든 파일에서 함수의 정의를 찾는 기능입니다. 그러나 태그 시스템은이 기능으로 제한되지 않습니다. 예를 들어, 프로젝트의 모든 파일에서 텍스트 검색을 수행하거나 프로젝트 전체 검색 및 바꾸기를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e5cc17a9625b1ef996d5f041d154602dfcaa438" translate="yes" xml:space="preserve">
          <source>Tags other than the earlier mentioned are ignored by the test server.</source>
          <target state="translated">앞에서 언급 한 것 이외의 태그는 테스트 서버에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f4446936a2326a1b426b4bb095f8f0bc39469810" translate="yes" xml:space="preserve">
          <source>Tags used to be important for all users of ASN.1, because it was necessary to add tags manually to certain constructs in order for the ASN.1 specification to be valid. Example of an old-style specification:</source>
          <target state="translated">태그는 ASN.1 스펙이 유효하기 위해 특정 구문에 수동으로 태그를 추가해야했기 때문에 모든 ASN.1 사용자에게 중요했습니다. 구식 사양의 예 :</target>
        </trans-unit>
        <trans-unit id="7ce68ff3f210c997cf191cc3047dad75cfbe97db" translate="yes" xml:space="preserve">
          <source>Tai_Le</source>
          <target state="translated">Tai_Le</target>
        </trans-unit>
        <trans-unit id="30754c9b404b9f791325a342fd0c615c1607ad6a" translate="yes" xml:space="preserve">
          <source>Tai_Tham</source>
          <target state="translated">Tai_Tham</target>
        </trans-unit>
        <trans-unit id="d56a5ea60a6f1aee9d29df15fa3ff172f1ecef8f" translate="yes" xml:space="preserve">
          <source>Tai_Viet</source>
          <target state="translated">Tai_Viet</target>
        </trans-unit>
        <trans-unit id="712d7b0229a9c9b792d9ee5e5f566583688440d1" translate="yes" xml:space="preserve">
          <source>Take a look at the DTD and observe that the structure of an XML document that is conformant to this DTD must have one motorcycles element (the root element). The motorcycles element must have at least one bike element. After each bike element it may be a date element. The content of the date element is #PCDATA (Parsed Character DATA), i.e. raw text. Observe that if #PCDATA must have a &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; or a &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; character it must be written as &lt;code&gt;&quot;&amp;amp;lt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;amp;amp;&quot;&lt;/code&gt; respectively. Also other character entities exists similar to the ones in HTML and SGML.</source>
          <target state="translated">DTD를 살펴보고이 DTD를 준수하는 XML 문서의 구조에는 하나의 모터 사이클 요소 (루트 요소)가 있어야합니다. 모터 사이클 요소에는 하나 이상의 자전거 요소가 있어야합니다. 각 자전거 요소 다음에는 날짜 요소 일 수 있습니다. 날짜 요소의 내용은 #PCDATA (구문 분석 된 문자 데이터), 즉 원시 텍스트입니다. #PCDATA에 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 문자가 있어야하는 경우 &lt;code&gt;&quot;&amp;amp;lt;&quot;&lt;/code&gt; 로 작성해야합니다 . 및 &lt;code&gt;&quot;&amp;amp;amp;&quot;&lt;/code&gt; 각기. 또한 다른 문자 엔티티는 HTML 및 SGML의 문자 엔티티와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f1944ad3e238ccbfad283666266458fed59a2c12" translate="yes" xml:space="preserve">
          <source>Take care of &lt;code&gt;&lt;a href=&quot;#msg&quot;&gt;system messages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#msg&quot;&gt;system messages&lt;/a&gt;&lt;/code&gt; 관리하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5cb213c0c3fbc91fd264762706d8f4c2755430c" translate="yes" xml:space="preserve">
          <source>Take time stamps with &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time/0&lt;/a&gt;&lt;/code&gt; and calculate the time difference using ordinary subtraction. The result is in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt;. If you want to convert the result to another time unit, you can use &lt;code&gt;&lt;a href=&quot;erlang#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time/0&lt;/a&gt;&lt;/code&gt; 을 사용하여 타임 스탬프를 가져 와서 일반 빼기를 사용하여 시차를 계산하십시오. 결과는 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 입니다. 결과를 다른 시간 단위로 변환하려면 &lt;code&gt;&lt;a href=&quot;erlang#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9ada3a67eabb29a57989f4f801f3c2a4ec53a23" translate="yes" xml:space="preserve">
          <source>Take time stamps with &lt;code&gt;erlang:now/0&lt;/code&gt; and calculate the difference in time with &lt;code&gt;timer:now_diff/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 으로 타임 스탬프를 &lt;code&gt;timer:now_diff/2&lt;/code&gt; 로 시간 차이를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="aad56d0b07d8624ffdf8f3dd6234bf0a87980ba7" translate="yes" xml:space="preserve">
          <source>Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is &lt;code&gt;namelist&lt;/code&gt;, which returns the tuple &lt;code&gt;{namelist, [binary()]}&lt;/code&gt;, containing the names of all (unique) named subpatterns in the regular expression. For example:</source>
          <target state="translated">컴파일 된 정규식과 항목을 가져 와서 정규식에서 관련 데이터를 반환합니다. 유일하게 지원되는 항목은 &lt;code&gt;namelist&lt;/code&gt; 이며 , 정규 표현식에서 이름이 지정된 모든 서브 패턴의 이름을 포함하는 튜플 &lt;code&gt;{namelist, [binary()]}&lt;/code&gt; 을 리턴합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19bfeb3244c87dc7345b2a90b3a504725b9fc5d5" translate="yes" xml:space="preserve">
          <source>Takes a function from &lt;code&gt;A&lt;/code&gt;s to &lt;code&gt;B&lt;/code&gt;s, and a list of &lt;code&gt;A&lt;/code&gt;s and produces a list of &lt;code&gt;B&lt;/code&gt;s by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order depends on the implementation.</source>
          <target state="translated">함수를 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로 가져오고 &lt;code&gt;A&lt;/code&gt; 목록을 가져 오고 목록의 모든 요소에 함수를 적용하여 &lt;code&gt;B&lt;/code&gt; 목록을 생성 합니다. 이 함수는 반환 값을 얻는 데 사용됩니다. 평가 순서는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="55656bdc88d1b3d6dee5f6b3418d04f6d2a52efe" translate="yes" xml:space="preserve">
          <source>Takes a function from &lt;code&gt;A&lt;/code&gt;s to lists of &lt;code&gt;B&lt;/code&gt;s, and a list of &lt;code&gt;A&lt;/code&gt;s (&lt;code&gt;List1&lt;/code&gt;) and produces a list of &lt;code&gt;B&lt;/code&gt;s by applying the function to every element in &lt;code&gt;List1&lt;/code&gt; and appending the resulting lists.</source>
          <target state="translated">함수로부터 얻어 리스트에 S &lt;code&gt;B&lt;/code&gt; S 및 목록 S ( &lt;code&gt;List1&lt;/code&gt; 입니다 )과 목록 생성 &lt;code&gt;B&lt;/code&gt; 내의 각 요소에 함수를 적용함으로써들 &lt;code&gt;List1&lt;/code&gt; 이 생성 된 목록을 추가. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52fae012e5e055efc934f9ec9bd9253885a38340" translate="yes" xml:space="preserve">
          <source>Takes a list of child specification as argument and returns &lt;code&gt;ok&lt;/code&gt; if all of them are syntactically correct, otherwise &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">하위 스펙 목록을 인수로 사용하고 구문이 올 바르면 &lt;code&gt;ok&lt;/code&gt; 를 리턴하고 , 그렇지 않으면 &lt;code&gt;{error,Error}&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="506646efe2a13a3aaee03a7ed507effbc3b857f9" translate="yes" xml:space="preserve">
          <source>Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored.</source>
          <target state="translated">키-값 튜플 요소 목록을 가져 와서 맵을 만듭니다. 연관은 임의의 순서 일 수 있으며, 연관의 키 및 값 둘다는 임의의 용어 일 수있다. 동일한 키가 두 번 이상 나타나면 후자 (가장 오른쪽) 값이 사용되고 이전 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b5587ad9b89a81a22b94093c25712098169010e" translate="yes" xml:space="preserve">
          <source>Takes a pattern with &quot;don't care&quot; variables denoted as a &lt;code&gt;'_'&lt;/code&gt; parameter. This function returns a list of records that matched the pattern. Since the second element of a record in a table is considered to be the key for the record, the performance of this function depends on whether this key is bound or not.</source>
          <target state="translated">&lt;code&gt;'_'&lt;/code&gt; 매개 변수로 표시된 &quot;무정의&quot;변수가있는 패턴을 사용 합니다. 이 함수는 패턴과 일치하는 레코드 목록을 리턴합니다. 테이블에서 레코드의 두 번째 요소가 레코드의 키로 간주되므로이 기능의 성능은이 키의 바인드 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6aa0f10b3c4d20cfef7ffd9aac9c02c7e099a09b" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ErrorDesc&lt;/code&gt; returned by load, unload, or reload functions and returns a string that describes the error or warning.</source>
          <target state="translated">로드, 언로드 또는 재로드 기능에 의해 리턴 된 &lt;code&gt;ErrorDesc&lt;/code&gt; 를 가져 와서 오류 또는 경고를 설명하는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="57cbfc69dd180e338745075476b0f2367b010aeb" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when processing an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ErrorDescriptor&lt;/code&gt; 를 가져 와서 오류 또는 경고를 설명하는 문자열을 반환합니다. 이 함수는 일반적으로 &lt;code&gt;ErrorInfo&lt;/code&gt; 구조를 처리 할 때 암시 적으로 호출됩니다 (섹션 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="93bf5f96e7a486360d69cd80e7309017ce816941" translate="yes" xml:space="preserve">
          <source>Takes an additional parameter, which &lt;strong&gt;must&lt;/strong&gt; be the result of &lt;code&gt;record_info(size, &amp;lt;record_type&amp;gt;)&lt;/code&gt;, like in &lt;code&gt;{is_record, '$1', rectype, record_info(size, rectype)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{is_record, '$1', rectype, record_info(size, rectype)}&lt;/code&gt; 과 같이 &lt;code&gt;record_info(size, &amp;lt;record_type&amp;gt;)&lt;/code&gt; 의 결과 &lt;strong&gt;여야&lt;/strong&gt; 하는 추가 매개 변수를 사용 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6c1469847249171e76b7f608e5d60058ff04bd25" translate="yes" xml:space="preserve">
          <source>Takes an error code returned by one of the other functions in the module and creates a textual description of the error.</source>
          <target state="translated">모듈의 다른 함수 중 하나가 리턴 한 오류 코드를 사용하여 오류에 대한 텍스트 설명을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a79e919b8abfed5dd81802687c1118f9e75fc341" translate="yes" xml:space="preserve">
          <source>Takes care of any work that is not specifically assigned to a scheduler.</source>
          <target state="translated">스케줄러에 특별히 지정되지 않은 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b31c0f53fdbe49aa50563e165f4e3a62fb484ea0" translate="yes" xml:space="preserve">
          <source>Takes care of possible cleanup that is needed when the cache handling process terminates.</source>
          <target state="translated">캐시 처리 프로세스가 종료 될 때 필요한 가능한 정리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="46509e2dee350637229abb5245a0cb50da574d1e" translate="yes" xml:space="preserve">
          <source>Takes characters from &lt;code&gt;String&lt;/code&gt; as long as the characters are members of set &lt;code&gt;Characters&lt;/code&gt; or the complement of set &lt;code&gt;Characters&lt;/code&gt;. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt; or &lt;code&gt;trailing&lt;/code&gt;, indicates from which direction characters are to be taken.</source>
          <target state="translated">문자를 취 &lt;code&gt;String&lt;/code&gt; 긴 문자 세트의 구성원 인만큼 &lt;code&gt;Characters&lt;/code&gt; 또는 세트의 보완 &lt;code&gt;Characters&lt;/code&gt; . &lt;code&gt;leading&lt;/code&gt; 또는 &lt;code&gt;trailing&lt;/code&gt; 일 수있는 &lt;code&gt;Dir&lt;/code&gt; 은 어느 방향에서 문자를 가져갈지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e93b486ac5971a63d69d4eadcbdf142bace13b4a" translate="yes" xml:space="preserve">
          <source>Takes elements &lt;code&gt;Elem&lt;/code&gt; from &lt;code&gt;List1&lt;/code&gt; while &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate.</source>
          <target state="translated">&lt;code&gt;Pred(Elem)&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 동안 &lt;code&gt;List1&lt;/code&gt; 에서 요소 &lt;code&gt;Elem&lt;/code&gt; 을 가져 옵니다 . 즉, 함수는 모든 요소가 조건자를 만족하는 목록의 가장 긴 접두사를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbb4f090d8ca065719386cdc9464916982f88f35" translate="yes" xml:space="preserve">
          <source>Takes no argument and returns the value of the node's trace control word. The same is done by &lt;code&gt;erlang:system_info(trace_control_word)&lt;/code&gt;.</source>
          <target state="translated">인수를 취하지 않고 노드의 추적 제어 단어 값을 리턴합니다. 동일하여 수행됩니다 &lt;code&gt;erlang:system_info(trace_control_word)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7cf647d0f18821ebb79f5e2e860bbb7ec66c82" translate="yes" xml:space="preserve">
          <source>Takes one argument. If the argument is &lt;code&gt;true&lt;/code&gt;, the call trace message mode for the current process is set to silent for this call and all later calls, that is, call trace messages are inhibited even if &lt;code&gt;{message, true}&lt;/code&gt; is called in the &lt;code&gt;MatchBody&lt;/code&gt; part for a traced function.</source>
          <target state="translated">하나의 주장을 취합니다. 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 현재 프로세스의 통화 추적 메시지 모드는이 호출에 대해 자동으로 설정되며 이후의 모든 호출, 즉 &lt;code&gt;{message, true}&lt;/code&gt; 가 &lt;code&gt;MatchBody&lt;/code&gt; 파트에서 추적 기능.</target>
        </trans-unit>
        <trans-unit id="fd489e11a7379f3da46a8f5de6664950f616c21a" translate="yes" xml:space="preserve">
          <source>Takes one argument: the message. Returns &lt;code&gt;true&lt;/code&gt; and can only be used in the &lt;code&gt;MatchBody&lt;/code&gt; part and when tracing.</source>
          <target state="translated">메시지 하나의 인수를 취합니다. &lt;code&gt;true&lt;/code&gt; 반환 하며 &lt;code&gt;MatchBody&lt;/code&gt; 부분과 추적시 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30493b8e01e1c19322e9bf0b28ad578877d961a6" translate="yes" xml:space="preserve">
          <source>Takes one unsigned integer argument, sets the value of the node's trace control word to the value of the argument, and returns the previous value. The same is done by &lt;code&gt;erlang:system_flag(trace_control_word, Value)&lt;/code&gt;. It is only allowed to use &lt;code&gt;set_tcw&lt;/code&gt; in the &lt;code&gt;MatchBody&lt;/code&gt; part when tracing.</source>
          <target state="translated">부호없는 정수 인수 하나를 가져 와서 노드의 추적 제어 단어 값을 인수 값으로 설정 한 후 이전 값을 반환합니다. 동일은에 의해 이루어집니다 &lt;code&gt;erlang:system_flag(trace_control_word, Value)&lt;/code&gt; . 에만 사용할 수 있습니다 &lt;code&gt;set_tcw&lt;/code&gt; 을 에 &lt;code&gt;MatchBody&lt;/code&gt; 의 추적을 할 때 일부입니다.</target>
        </trans-unit>
        <trans-unit id="09da2fcd1e2efe51ebf24c738e905ab46e139be1" translate="yes" xml:space="preserve">
          <source>Takes over the distributed application &lt;code&gt;Application&lt;/code&gt;, which executes at another node &lt;code&gt;Node&lt;/code&gt;. At the current node, the application is restarted by calling &lt;code&gt;Module:start({takeover,Node},StartArgs)&lt;/code&gt;. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;StartArgs&lt;/code&gt; are retrieved from the loaded application specification. The application at the other node is not stopped until the startup is completed, that is, when &lt;code&gt;Module:start/2&lt;/code&gt; and any calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; have returned.</source>
          <target state="translated">다른 노드 &lt;code&gt;Node&lt;/code&gt; 에서 실행되는 분산 응용 프로그램 &lt;code&gt;Application&lt;/code&gt; 을 인계합니다 . 현재 노드에서 &lt;code&gt;Module:start({takeover,Node},StartArgs)&lt;/code&gt; 를 호출하여 애플리케이션을 다시 시작합니다 . 로드 된 애플리케이션 사양에서 &lt;code&gt;Module&lt;/code&gt; 및 &lt;code&gt;StartArgs&lt;/code&gt; 가 검색됩니다. 다른 노드의 응용 프로그램은 시작이 완료 될 때까지, 즉 &lt;code&gt;Module:start/2&lt;/code&gt; 및 &lt;code&gt;Module:start_phase/3&lt;/code&gt; 에 대한 호출 이 리턴 될 때까지 중지되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0a647ce123db14489ad591cd488d47d856711e8f" translate="yes" xml:space="preserve">
          <source>Takes the list of characters &lt;code&gt;String&lt;/code&gt; and tries to scan (tokenize) them. Returns one of the following:</source>
          <target state="translated">문자 목록 취 &lt;code&gt;String&lt;/code&gt; 스캔 (토큰 화)과 시도를. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d44d06fda277fec8865be5e542736e38ae54f97" translate="yes" xml:space="preserve">
          <source>Takri</source>
          <target state="translated">Takri</target>
        </trans-unit>
        <trans-unit id="86c2b6275f076b31c4be9812e835dab2a6f07ccf" translate="yes" xml:space="preserve">
          <source>Tamil</source>
          <target state="translated">Tamil</target>
        </trans-unit>
        <trans-unit id="efa2b1a6ae1600d5f4d3d0746df43e1f2e23a7fa" translate="yes" xml:space="preserve">
          <source>Tar files can be created in one operation using function &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#create-3&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Tar 파일은 &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#create-3&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 한 번의 조작으로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25d3b39619df66bdd0c7bc6d8ee96ee14afa2c24" translate="yes" xml:space="preserve">
          <source>Tear down a &quot;virtual&quot; connection</source>
          <target state="translated">&quot;가상&quot;연결을 해제</target>
        </trans-unit>
        <trans-unit id="82bd3966ddc98061bf824297ca3d00cb4214a988" translate="yes" xml:space="preserve">
          <source>Tell &lt;code&gt;dbg&lt;/code&gt; to trace function Calls</source>
          <target state="translated">&lt;code&gt;dbg&lt;/code&gt; 에게 함수 호출을 추적하도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="835e2ece47c360b333f1a47931eef30669499f1b" translate="yes" xml:space="preserve">
          <source>Tell Erlang to use another primitive TCP module than &lt;code&gt;inet_tcp&lt;/code&gt;.</source>
          <target state="translated">Erlang에게 &lt;code&gt;inet_tcp&lt;/code&gt; 이외의 다른 기본 TCP 모듈을 사용하도록 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cb70b65ff1780e8afb327f1a87fff375570f8ad" translate="yes" xml:space="preserve">
          <source>Tell Erlang to use another primitive UDP module than &lt;code&gt;inet_udp&lt;/code&gt;.</source>
          <target state="translated">Erlang에게 &lt;code&gt;inet_udp&lt;/code&gt; 이외의 다른 기본 UDP 모듈을 사용하도록 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b7ea6ec990e7644aa1c8797918e78fc5d49e152" translate="yes" xml:space="preserve">
          <source>Tell it specifically to trace the &lt;code&gt;et:trace_me/5&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 를 추적하도록 구체적으로 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="57dd041bbdd098628d1f020b85579436c5820b6e" translate="yes" xml:space="preserve">
          <source>Tell the release handler to use the &lt;code&gt;releases&lt;/code&gt; directory in our target structure instead of &lt;code&gt;$OTP_ROOT/releases&lt;/code&gt;. This is done by setting the SASL environment variable &lt;code&gt;releases_dir&lt;/code&gt;, either from the command line (&lt;code&gt;-sasl releases_dir &amp;lt;target-dir&amp;gt;/releases&lt;/code&gt;) or in &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">릴리스 핸들러에게 &lt;code&gt;$OTP_ROOT/releases&lt;/code&gt; 대신 대상 구조에서 &lt;code&gt;releases&lt;/code&gt; 디렉토리 를 사용하도록 지시하십시오 . 이 SASL는 환경 변수 설정에 의해 수행 &lt;code&gt;releases_dir&lt;/code&gt; 을 명령 행하거나, ( &lt;code&gt;-sasl releases_dir &amp;lt;target-dir&amp;gt;/releases&lt;/code&gt; ) 또는 &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572e18ff0add697584fb4ac9dc773051bb0e16f3" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests &lt;code&gt;n&lt;/code&gt; times (described later).</source>
          <target state="translated">지시 &lt;code&gt;Common Test&lt;/code&gt; 테스트 반복 &lt;code&gt;n&lt;/code&gt; 배 (나중에 설명 참조).</target>
        </trans-unit>
        <trans-unit id="e4b8cb1936cb9df69d4554104909777bb2678271" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests for duration of time (described later).</source>
          <target state="translated">지시 &lt;code&gt;Common Test&lt;/code&gt; 시간 동안 테스트를 반복 (나중에 설명).</target>
        </trans-unit>
        <trans-unit id="2898ea99fa920352a923e39692a4049acc36eb31" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests until &lt;code&gt;stop_time&lt;/code&gt; (described later).</source>
          <target state="translated">지시 &lt;code&gt;Common Test&lt;/code&gt; 테스트 할 때까지 반복 &lt;code&gt;stop_time&lt;/code&gt; (나중에 설명 참조).</target>
        </trans-unit>
        <trans-unit id="e085c8fd09860d3c0a7a2525ced06370c6aa9e09" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;erlsrv&lt;/code&gt; how to stop the Erlang emulator. Default is to kill it (Win32 TerminateProcess), but this action can specify any Erlang shell command that will be executed in the emulator to make it stop. The emulator is expected to stop within 30 seconds after the command is issued in the shell. If the emulator is not stopped, it reports a running state to the service manager.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; 에게 Erlang 에뮬레이터를 중지하는 방법을 알려줍니다 . 기본값은 강제 종료 (Win32 TerminateProcess)이지만이 조치는 에뮬레이터에서 실행될 Erlang 쉘 명령을 지정하여 중지시킬 수 있습니다. 에뮬레이터는 명령이 셸에서 실행 된 후 30 초 이내에 중지됩니다. 에뮬레이터가 중지되지 않은 경우 서비스 관리자에게 실행 상태를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c0b8c2f094ce49a65d1ca33bf7b4040a376bc6cf" translate="yes" xml:space="preserve">
          <source>Tells explicitly which XML Schema documents to use to validate the XML document. Used together with the &lt;code&gt;{validation,schema}&lt;/code&gt; option.</source>
          <target state="translated">XML 문서의 유효성을 검사하는 데 사용할 XML 스키마 문서를 명시 적으로 알려줍니다. &lt;code&gt;{validation,schema}&lt;/code&gt; 옵션 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0492b5903796ca58eb4f908e0044cfd75d4cdeda" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to delete the child specification identified by &lt;code&gt;Id&lt;/code&gt;. The corresponding child process must not be running. Use &lt;code&gt;&lt;a href=&quot;#terminate_child-2&quot;&gt;terminate_child/2&lt;/a&gt;&lt;/code&gt; to terminate it.</source>
          <target state="translated">감독자 &lt;code&gt;SupRef&lt;/code&gt; 에게 &lt;code&gt;Id&lt;/code&gt; 로 식별 된 하위 사양을 삭제하도록 지시 합니다 . 해당 하위 프로세스가 실행되고 있지 않아야합니다. &lt;code&gt;&lt;a href=&quot;#terminate_child-2&quot;&gt;terminate_child/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="854d6e6ea1b17fd3503e1214e269e4327574ba1f" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to restart a child process corresponding to the child specification identified by &lt;code&gt;Id&lt;/code&gt;. The child specification must exist, and the corresponding child process must not be running.</source>
          <target state="translated">감독자 &lt;code&gt;SupRef&lt;/code&gt; 에게 &lt;code&gt;Id&lt;/code&gt; 로 식별 된 하위 사양에 해당하는 하위 프로세스를 다시 시작하도록 지시 합니다 . 하위 스펙이 존재해야하며 해당 하위 프로세스가 실행되고 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="83cd5f49c19723bcbd4b9d8efb377bc645bf4fe0" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to terminate the specified child.</source>
          <target state="translated">감독자 &lt;code&gt;SupRef&lt;/code&gt; 에게 지정된 자식을 종료하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="caff595a530bcc59815e7fe18f59345b5ce49ff6" translate="yes" xml:space="preserve">
          <source>Tells the DNS client &lt;code&gt;inet_res(3)&lt;/code&gt; to look up IPv6 addresses. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">DNS 클라이언트 &lt;code&gt;inet_res(3)&lt;/code&gt; 에게 IPv6 주소를 찾도록 지시합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fdb6ce16675d8c8dd66ce3986070e67a82e2171" translate="yes" xml:space="preserve">
          <source>Tells the DNS client &lt;code&gt;inet_res(3)&lt;/code&gt; to use TCP (Virtual Circuit) instead of UDP. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">DNS 클라이언트 &lt;code&gt;inet_res(3)&lt;/code&gt; 에게 UDP 대신 TCP (Virtual Circuit)를 사용하도록 지시합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78c529a078634064f178098741caf31cb78a48a7" translate="yes" xml:space="preserve">
          <source>Tells the compiler to generate functions for conversion between names (as atoms) and numbers and conversely for the specified &lt;code&gt;EnumTypeName&lt;/code&gt;. There can be multiple occurrences of this option to specify several type names. The type names must be declared as &lt;code&gt;ENUMERATIONS&lt;/code&gt; in the ASN.1 specification.</source>
          <target state="translated">컴파일러에게 이름 (원자)과 숫자 사이의 변환 및 반대로 지정된 &lt;code&gt;EnumTypeName&lt;/code&gt; 에 대한 함수를 생성하도록 지시합니다 . 여러 유형 이름을 지정하기 위해이 옵션이 여러 번 나타날 수 있습니다. 유형 이름은 ASN.1 사양에서 &lt;code&gt;ENUMERATIONS&lt;/code&gt; 로 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a526775f5490371c812a9e90593190860b2feeb" translate="yes" xml:space="preserve">
          <source>Tells the process to change code. The process must be suspended to handle this message. Argument &lt;code&gt;Extra&lt;/code&gt; is reserved for each process to use as its own. Function &lt;code&gt;Module:system_code_change/4&lt;/code&gt; is called. &lt;code&gt;OldVsn&lt;/code&gt; is the old version of the &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">프로세스가 코드를 변경하도록 지시합니다. 이 메시지를 처리하려면 프로세스를 일시 중단해야합니다. 인수 &lt;code&gt;Extra&lt;/code&gt; 는 각 프로세스가 자체적으로 사용하도록 예약되어 있습니다. 함수 &lt;code&gt;Module:system_code_change/4&lt;/code&gt; 가 호출됩니다. &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;Module&lt;/code&gt; 의 이전 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="ea6c03461dc3a543514f149ca6bb793d0a9e158a" translate="yes" xml:space="preserve">
          <source>Telugu</source>
          <target state="translated">Telugu</target>
        </trans-unit>
        <trans-unit id="48a0458cda5329a0ce2df604a592dac2d33cdef2" translate="yes" xml:space="preserve">
          <source>Temporary error: Try again.</source>
          <target state="translated">일시적인 오류 : 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="c5c7003721dac5bbb05b8381d825683179e7de3e" translate="yes" xml:space="preserve">
          <source>Temporary files and the output file can be compressed. Defaults &lt;code&gt;false&lt;/code&gt;, which implies that written files are not compressed. Regardless of the value of option &lt;code&gt;compressed&lt;/code&gt;, compressed files can always be read. Notice that reading and writing compressed files are significantly slower than reading and writing uncompressed files.</source>
          <target state="translated">임시 파일과 출력 파일을 압축 할 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 이며, 이는 작성된 파일이 압축되지 않았 음을 나타냅니다. &lt;code&gt;compressed&lt;/code&gt; 옵션 옵션의 값에 관계없이 압축 파일을 항상 읽을 수 있습니다. 압축 파일을 읽고 쓰는 것이 압축되지 않은 파일을 읽고 쓰는 것보다 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="1532f885d5197fe3f8b41aeb41de89534d082e50" translate="yes" xml:space="preserve">
          <source>Term comparison operators return the Boolean value of the expression, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">용어 비교 연산자는 표현식의 부울 값 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30fd6857122636ec1a6eaf8d0167df27dbbc2068" translate="yes" xml:space="preserve">
          <source>Term comparisons</source>
          <target state="translated">용어 비교</target>
        </trans-unit>
        <trans-unit id="36df6bde5c18fe5e5d93fd385843cb7b8a0873f6" translate="yes" xml:space="preserve">
          <source>Term constructions/literals are translated as much as is needed to get them into valid match specification. This way tuples are made into match specification tuple constructions (a one element tuple containing the tuple) and constant expressions are used when importing variables from the environment. Records are also translated into plain tuple constructions, calls to element, and so on. The guard test &lt;code&gt;is_record/2&lt;/code&gt; is translated into match specification code using the three parameter version that is built into match specification, so that &lt;code&gt;is_record(A,t)&lt;/code&gt; is translated into &lt;code&gt;{is_record,'$1',t,5}&lt;/code&gt; if the record size of record type &lt;code&gt;t&lt;/code&gt; is 5.</source>
          <target state="translated">용어 구성 / 리터럴은 유효한 일치 사양으로 만드는 데 필요한만큼 번역됩니다. 이런 방식으로 튜플은 일치하는 튜플 구성 (튜플을 포함하는 하나의 요소 튜플)로 만들어지고 환경에서 변수를 가져올 때 상수 표현식이 사용됩니다. 레코드는 일반 튜플 구성, 요소 호출 등으로 변환됩니다. 가드 테스트 &lt;code&gt;is_record/2&lt;/code&gt; 는 일치 스펙에 내장 된 3 개의 매개 변수 버전을 사용하여 일치 스펙 코드 로 변환 되므로 레코드 크기 인 경우 &lt;code&gt;is_record(A,t)&lt;/code&gt; 는 &lt;code&gt;{is_record,'$1',t,5}&lt;/code&gt; 됩니다. 레코드 유형 &lt;code&gt;t&lt;/code&gt; 의 5는 5입니다.</target>
        </trans-unit>
        <trans-unit id="908579f030e6ac5e6a39f29bf0038f9182d1fd66" translate="yes" xml:space="preserve">
          <source>Term is not a binary.</source>
          <target state="translated">용어는 이진이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f9a73563feaeca50f714fb97a106cd148e6a35f" translate="yes" xml:space="preserve">
          <source>Term passed as the third argument to the &lt;code&gt;&lt;a href=&quot;diameter_transport#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; function of the relevant &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; in order to start a transport process. Defaults to the empty list.</source>
          <target state="translated">운송 프로세스를 시작하기 위해 관련 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;diameter_transport#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 기능에 세 번째 인수로 전달 된 용어 입니다. 빈 목록이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="dfe25b408798a81c28611f4d808102f77953debd" translate="yes" xml:space="preserve">
          <source>Term to be sent to &lt;code&gt;&lt;a href=&quot;gen_event#add_handler-3&quot;&gt;gen_event:add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gen_event#add_handler-3&quot;&gt;gen_event:add_handler/3&lt;/a&gt;&lt;/code&gt; 으로 전송되는 용어 .</target>
        </trans-unit>
        <trans-unit id="09f89796d08f4695c60595fc0a731d30d3e1ce2a" translate="yes" xml:space="preserve">
          <source>TermConstruct = {{}} | {{ ConditionExpression, ... }} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression, ...] | #{} | #{term() =&amp;gt; ConditionExpression, ...} | NonCompositeTerm | Constant</source>
          <target state="translated">TermConstruct = {{}} | {{ConditionExpression, ...}} | &lt;code&gt;[]&lt;/code&gt; | [조건식, ...] | # {} | # {term () =&amp;gt; ConditionExpression, ...} | 비 복합 용어 | 일정한</target>
        </trans-unit>
        <trans-unit id="301994d75fc00647fccf09f8223c73d02716a9f6" translate="yes" xml:space="preserve">
          <source>TermConstruct = {{}} | {{ ConditionExpression, ... }} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression, ...] | &lt;code&gt;#{}&lt;/code&gt; | #{term() =&amp;gt; ConditionExpression, ...} | NonCompositeTerm | Constant</source>
          <target state="translated">TermConstruct = {{}} | {{ConditionExpression, ...}} | &lt;code&gt;[]&lt;/code&gt; | [조건식, ...] | &lt;code&gt;#{}&lt;/code&gt; | # {term () =&amp;gt; ConditionExpression, ...} | 비 복합 용어 | 일정한</target>
        </trans-unit>
        <trans-unit id="317c27ee519ee48f9c75d7b40776395c672e14f6" translate="yes" xml:space="preserve">
          <source>Terminal I/O is slightly easier than file I/O. The output is meant for human reading and is usually Erlang syntax (for example, in the shell). There exists syntactic representation of any Unicode character without displaying the glyph (instead written as &lt;code&gt;\x&lt;/code&gt;{&lt;code&gt;HHH&lt;/code&gt;}). Unicode data can therefore usually be displayed even if the terminal as such does not support the whole Unicode range.</source>
          <target state="translated">터미널 I / O는 파일 I / O보다 약간 쉽습니다. 출력은 사람이 읽기위한 것이며 대개 Erlang 구문입니다 (예 : 셸). 글리프를 표시하지 않고 모든 유니 코드 문자의 구문 표현이 있습니다 (대신 &lt;code&gt;\x&lt;/code&gt; { &lt;code&gt;HHH&lt;/code&gt; }). 따라서 터미널이 전체 유니 코드 범위를 지원하지 않더라도 유니 코드 데이터는 일반적으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3782509534bdc8ecddfd675751de4bf801b681ec" translate="yes" xml:space="preserve">
          <source>Terminal categories may only appear in the right hand sides (= &lt;code&gt;rhs&lt;/code&gt;) of grammar rules.</source>
          <target state="translated">터미널 범주는 문법 규칙 의 오른쪽 (= &lt;code&gt;rhs&lt;/code&gt; ) 에만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="157aa94e1d362822c48f2dff41e099927c9cb618" translate="yes" xml:space="preserve">
          <source>Terminate the transport process without Disconnect-Peer-Request being sent to the peer.</source>
          <target state="translated">연결 끊기 피어 요청이 피어로 전송되지 않고 전송 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="86018e6ee1482838e5a0aeb6ac5e33225172df60" translate="yes" xml:space="preserve">
          <source>Terminate the traversal and return &lt;code&gt;[Value | Acc]&lt;/code&gt;.</source>
          <target state="translated">순회를 종료하고 &lt;code&gt;[Value | Acc]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef4447a97be9cdfc58e0bd40da8f22d111904fcd" translate="yes" xml:space="preserve">
          <source>Terminates &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;etop&lt;/code&gt; 을 종료 합니다 .</target>
        </trans-unit>
        <trans-unit id="baa4e4f2aee82c277b2987190bacf935eba00880" translate="yes" xml:space="preserve">
          <source>Terminates a test case with an error message specified by a format string and a list of values (used as arguments to &lt;code&gt;io_lib:format/2&lt;/code&gt;).</source>
          <target state="translated">형식 문자열과 값 목록 ( &lt;code&gt;io_lib:format/2&lt;/code&gt; 의 인수로 사용됨)으로 지정된 오류 메시지로 테스트 케이스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="5a0abbf285140ae9fd7bfbb3aeee2d59660f0146" translate="yes" xml:space="preserve">
          <source>Terminates a test case with the specified error &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">지정된 오류 &lt;code&gt;Reason&lt;/code&gt; 테스트 케이스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="2ab95c672b98796e32387d13d61b81abc40092fa" translate="yes" xml:space="preserve">
          <source>Terminates all processes listed in the window using &lt;code&gt;exit(Pid,kill)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exit(Pid,kill)&lt;/code&gt; 사용하여 창에 나열된 모든 프로세스를 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="004c6a43d05b92bb17dce6f779b63e9a29b1b7f4" translate="yes" xml:space="preserve">
          <source>Terminates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Reason&lt;/code&gt; and &lt;code&gt;NewData&lt;/code&gt;, if specified.</source>
          <target state="translated">지정된 경우 &lt;code&gt;Reason&lt;/code&gt; 및 &lt;code&gt;NewData&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;gen_statem&lt;/code&gt; 을 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="f271847fb13d7634791602927e994ef860fda84e" translate="yes" xml:space="preserve">
          <source>Terminates the Crashdump Viewer and closes all GUI windows.</source>
          <target state="translated">Crashdump Viewer를 종료하고 모든 GUI 창을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="519a117c3896c0663badf989d4b915309b17e65a" translate="yes" xml:space="preserve">
          <source>Terminates the calling thread with the exit value passed as argument. &lt;code&gt;exit_value&lt;/code&gt; is a pointer to an exit value or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">종료 값을 인수로 전달하여 호출 스레드를 종료합니다. &lt;code&gt;exit_value&lt;/code&gt; 는 종료 값에 대한 포인터 또는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f20f699b09860115b81d54774a7222feaffe4a96" translate="yes" xml:space="preserve">
          <source>Terminates the character class</source>
          <target state="translated">캐릭터 클래스를 종료합니다</target>
        </trans-unit>
        <trans-unit id="bbd0750c043e7f8c526d39a2181c885faf307424" translate="yes" xml:space="preserve">
          <source>Terminates the process using &lt;code&gt;exit(Pid,kill)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exit(Pid,kill)&lt;/code&gt; 사용하여 프로세스를 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="332a0cca120165a32d4b04552488dcf492ca6ec7" translate="yes" xml:space="preserve">
          <source>Terminating closing square bracket</source>
          <target state="translated">닫는 대괄호 종료</target>
        </trans-unit>
        <trans-unit id="0f64c2787dcc796a369590e14f97af233d6dfc3a" translate="yes" xml:space="preserve">
          <source>Termination of a process executing a dirty NIF can only be completed up to a certain point while it executes the dirty NIF. All Erlang resources, such as its registered name and its ETS tables, are released. All links and monitors are triggered. The execution of the NIF is, however, &lt;strong&gt;not&lt;/strong&gt; stopped. The NIF can safely continue execution, allocate heap memory, and so on, but it is of course better to stop executing as soon as possible. The NIF can check whether a current process is alive using &lt;code&gt;&lt;a href=&quot;#enif_is_current_process_alive&quot;&gt;enif_is_current_process_alive&lt;/a&gt;&lt;/code&gt;. Communication using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enif_port_command&quot;&gt;enif_port_command&lt;/a&gt;&lt;/code&gt; is also dropped when the sending process is not alive. Deallocation of certain internal resources, such as process heap and process control block, is delayed until the dirty NIF has completed.</source>
          <target state="translated">더티 NIF를 실행하는 프로세스의 종료는 더티 NIF를 실행하는 동안 특정 지점까지만 완료 할 수 있습니다. 등록 된 이름 및 ETS 테이블과 같은 모든 Erlang 자원이 해제됩니다. 모든 링크와 모니터가 트리거됩니다. 그러나 NIF의 실행은 중지 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . NIF는 안전하게 실행을 계속하고 힙 메모리를 할당하는 등의 작업을 수행 할 수 있지만 가능한 빨리 실행을 중지하는 것이 좋습니다. NIF는 &lt;code&gt;&lt;a href=&quot;#enif_is_current_process_alive&quot;&gt;enif_is_current_process_alive&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 프로세스가 활성 상태인지 확인할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enif_port_command&quot;&gt;enif_port_command&lt;/a&gt;&lt;/code&gt; 를 사용한 통신전송 프로세스가 활성화되지 않은 경우에도 삭제됩니다. 더티 NIF가 완료 될 때까지 프로세스 힙 및 프로세스 제어 블록과 같은 특정 내부 자원의 할당이 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="50961d0e1b820684d69e8aad3d9b1e96970dd946" translate="yes" xml:space="preserve">
          <source>Termination reason.</source>
          <target state="translated">해지 사유.</target>
        </trans-unit>
        <trans-unit id="e19bcb1a4afdcf2396c1810bc351a007a00a0314" translate="yes" xml:space="preserve">
          <source>Termination-Cause AVP</source>
          <target state="translated">종료 원인 AVP</target>
        </trans-unit>
        <trans-unit id="720015dea84e939f9657bdc05e78a8f484b53980" translate="yes" xml:space="preserve">
          <source>Termination-Cause AVP Values</source>
          <target state="translated">종료 원인 AVP 값</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="146c4bd146babe3998863abfd062b2ff20015f96" translate="yes" xml:space="preserve">
          <source>Terms are read from the disk log running on &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 실행되는 디스크 로그에서 용어를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f400db43c5a4bb9dcf24053b78382c5623a73df7" translate="yes" xml:space="preserve">
          <source>Terms in the current test specification (that is, the specification that has been used to configure and run the current test) can be looked up. The function &lt;code&gt;&lt;a href=&quot;ct#get_testspec_terms-0&quot;&gt;get_testspec_terms()&lt;/a&gt;&lt;/code&gt; returns a list of all test specification terms (both configuration terms and test terms), and &lt;code&gt;get_testspec_terms(Tags)&lt;/code&gt; returns the term (or a list of terms) matching the tag (or tags) in &lt;code&gt;Tags&lt;/code&gt;.</source>
          <target state="translated">현재 테스트 사양의 용어 (즉, 현재 테스트를 구성하고 실행하는 데 사용 된 사양)를 찾을 수 있습니다. 함수 &lt;code&gt;&lt;a href=&quot;ct#get_testspec_terms-0&quot;&gt;get_testspec_terms()&lt;/a&gt;&lt;/code&gt; 모든 테스트 사양 용어 (구성 규정 및 시험 기간 모두)의 목록을 반환하고 &lt;code&gt;get_testspec_terms(Tags)&lt;/code&gt; 의 태그 (또는 태그)에 일치하는 용어 (또는 용어 목록) 반환 &lt;code&gt;Tags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2258114625478405b0794d20feae7776bb952f1d" translate="yes" xml:space="preserve">
          <source>Terms of type binary are accessed with the help of struct type &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt;, which contains a pointer (&lt;code&gt;data&lt;/code&gt;) to the raw binary data and the length (&lt;code&gt;size&lt;/code&gt;) of the data in bytes. Both &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; are read-only and are only to be written using calls to API functions. Instances of &lt;code&gt;ErlNifBinary&lt;/code&gt; are, however, always allocated by the user (usually as local variables).</source>
          <target state="translated">이진 유형의 용어는 원시 이진 데이터에 대한 포인터 ( &lt;code&gt;data&lt;/code&gt; )와 데이터의 길이 ( &lt;code&gt;size&lt;/code&gt; )를 바이트 단위로 포함하는 struct type &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt; 의 도움으로 액세스 됩니다. 두 &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 읽기 전용 API 함수를 호출을 사용하여 기록 될 만하다 있습니다. 그러나 &lt;code&gt;ErlNifBinary&lt;/code&gt; 의 인스턴스는 항상 사용자가 할당합니다 (일반적으로 로컬 변수).</target>
        </trans-unit>
        <trans-unit id="920e01199bada94afb9a7c210700367bebf552cd" translate="yes" xml:space="preserve">
          <source>Test case groups can be nested so sets of groups can be configured with the same &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; functions. Nested groups can be defined by including a group definition, or a group name reference, in the test case list of another group.</source>
          <target state="translated">테스트 케이스 그룹을 중첩 할 수 있으므로 동일한 &lt;code&gt;init_per_group/2&lt;/code&gt; 및 &lt;code&gt;end_per_group/2&lt;/code&gt; 기능 으로 그룹 세트를 구성 할 수 있습니다 . 중첩 그룹은 다른 그룹의 테스트 사례 목록에 그룹 정의 또는 그룹 이름 참조를 포함하여 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bdbfab66783753cdeb866267c3e01eab16087f3" translate="yes" xml:space="preserve">
          <source>Test cases</source>
          <target state="translated">테스트 사례</target>
        </trans-unit>
        <trans-unit id="6ee68d1c38276f67012fb2a67884c914e7df88a5" translate="yes" xml:space="preserve">
          <source>Test cases are to restore as much of the execution environment as possible, so that subsequent test cases do not crash because of their execution order. The function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; is suitable for this.</source>
          <target state="translated">테스트 사례는 가능한 많은 실행 환경을 복원하여 후속 테스트 사례가 실행 순서로 인해 충돌하지 않도록해야합니다. &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 함수 가 이에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="eb3ed6107b568f9909300a05e389ccf37148b03c" translate="yes" xml:space="preserve">
          <source>Test cases can be executed individually or in batches. &lt;code&gt;Common Test&lt;/code&gt; also features a distributed testing mode with central control and logging. With this feature, multiple systems can be tested independently in one common session. This is useful, for example, when running automated large-scale regression tests.</source>
          <target state="translated">테스트 사례는 개별적으로 또는 일괄 적으로 실행될 수 있습니다. &lt;code&gt;Common Test&lt;/code&gt; 에는 중앙 제어 및 로깅 기능이있는 분산 테스트 모드도 있습니다. 이 기능을 사용하면 하나의 공통 세션에서 여러 시스템을 독립적으로 테스트 할 수 있습니다. 예를 들어 자동화 된 대규모 회귀 테스트를 실행할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b194be204295ad16e8f14aa0046caa585dd7fd0" translate="yes" xml:space="preserve">
          <source>Test cases can be skipped in the following ways:</source>
          <target state="translated">다음과 같은 방법으로 테스트 사례를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d965a3f15f28a4c03812e7925aaabc94f5d085e2" translate="yes" xml:space="preserve">
          <source>Test cases in a sequence are executed in order until all succeed or one fails. If one fails, all following cases in the sequence are skipped. The cases in the sequence that have succeeded up to that point are reported as successful in the log. Any number of sequences can be specified.</source>
          <target state="translated">순서대로 테스트 케이스는 모두 성공하거나 실패 할 때까지 순서대로 실행됩니다. 하나가 실패하면 시퀀스의 다음 모든 경우를 건너 뜁니다. 해당 시점까지 성공한 순서의 사례는 로그에서 성공한 것으로보고됩니다. 임의의 수의 시퀀스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d70b7f6a0f40937f01a2ea075f8ecd7645309e" translate="yes" xml:space="preserve">
          <source>Test install using &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;. The content of the &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; variable will prefix all installation paths when doing &lt;code&gt;make install&lt;/code&gt;. Note that &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; is similar to &lt;code&gt;DESTDIR&lt;/code&gt;, but it does &lt;strong&gt;not&lt;/strong&gt; have the same effect as &lt;code&gt;DESTDIR&lt;/code&gt;. The installation can and have to be run from the location specified by &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;. That is, it can be useful if you want to try the system out, running test suites, etc, before doing the real install without &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 를 사용하여 설치를 테스트하십시오 . &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 변수 의 내용은 &lt;code&gt;make install&lt;/code&gt; 을 수행 할 때 모든 설치 경로 앞에 붙습니다 . 참고 것을 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 은 유사하다 &lt;code&gt;DESTDIR&lt;/code&gt; 하지만 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 것과 같은 효과가 &lt;code&gt;DESTDIR&lt;/code&gt; 을 . &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 로 지정된 위치에서 설치를 실행해야합니다 . 즉, &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 없이 실제 설치를 수행하기 전에 시스템을 시험해보고 테스트 스위트를 실행하려는 경우에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09cd8634fdd2477138516ede0b407901933f6764" translate="yes" xml:space="preserve">
          <source>Test sets can be joined in the same way: if &lt;code&gt;S_1&lt;/code&gt;, ..., &lt;code&gt;S_K&lt;/code&gt; are test sets, then &lt;code&gt;[S_1, ..., S_K]&lt;/code&gt; is also a test set, where the tests of &lt;code&gt;S_i&lt;/code&gt; are ordered before those of &lt;code&gt;S_(i+1)&lt;/code&gt;, for each subset &lt;code&gt;S_i&lt;/code&gt;.</source>
          <target state="translated">테스트 세트는 같은 방식으로 결합 될 수 있습니다. &lt;code&gt;S_1&lt;/code&gt; , ..., &lt;code&gt;S_K&lt;/code&gt; 가 테스트 세트 인 경우 &lt;code&gt;[S_1, ..., S_K]&lt;/code&gt; 도 테스트 세트입니다. 여기서 &lt;code&gt;S_i&lt;/code&gt; 의 테스트 는 &lt;code&gt;S_(i+1)&lt;/code&gt; 각 서브 세트 &lt;code&gt;S_i&lt;/code&gt; 에 대해 i + 1) .</target>
        </trans-unit>
        <trans-unit id="c0476bc91790b91266bc97b686a581dbb9934797" translate="yes" xml:space="preserve">
          <source>Test specifications can be used to run tests both in a single test host environment and in a distributed &lt;code&gt;Common Test&lt;/code&gt; environment (Large Scale Testing). The node parameters in term &lt;code&gt;init&lt;/code&gt; are only relevant in the latter (see section &lt;code&gt;&lt;a href=&quot;ct_master_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in Large Scale Testing). For details about the various terms, see the corresponding sections in the User's Guide, for example, the following:</source>
          <target state="translated">테스트 사양은 단일 테스트 호스트 환경과 분산 &lt;code&gt;Common Test&lt;/code&gt; 환경 (대규모 테스트) 에서 테스트를 실행하는 데 사용할 수 있습니다 . &lt;code&gt;init&lt;/code&gt; 라는 용어의 노드 매개 변수 는 후자에만 관련이 있습니다 ( 대규모 &lt;code&gt;&lt;a href=&quot;ct_master_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 섹션 참조 ). 다양한 용어에 대한 자세한 내용은 다음과 같이 사용자 안내서의 해당 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30c41c15ebd68c9f73776e8a167fcaff4ee08b62" translate="yes" xml:space="preserve">
          <source>Test suites are organized in test directories and each test suite can have a separate data directory. Typically, these files and directories are version-controlled similar to other forms of source code (possibly by a version control system like GIT or Subversion). However, &lt;code&gt;Common Test&lt;/code&gt; does not itself put any requirements on (or has any awareness of) possible file and directory versions.</source>
          <target state="translated">테스트 스위트는 테스트 디렉토리로 구성되며 각 테스트 스위트는 별도의 데이터 디렉토리를 가질 수 있습니다. 일반적으로 이러한 파일 및 디렉토리는 다른 형식의 소스 코드와 유사하게 버전 제어됩니다 (GIT 또는 Subversion과 같은 버전 제어 시스템에 의해 가능함). 그러나 &lt;code&gt;Common Test&lt;/code&gt; 는 가능한 파일 및 디렉토리 버전에 대한 요구 사항을 제시하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="703b1b5effc82cad270e49b3081c9a0476a73290" translate="yes" xml:space="preserve">
          <source>Test the boot script. To do this, start Erlang with the &lt;code&gt;-boot&lt;/code&gt; command-line parameter specifying this boot script (with its full path, but without the &lt;code&gt;.boot&lt;/code&gt; suffix). In UNIX it can look as follows:</source>
          <target state="translated">부팅 스크립트를 테스트하십시오. 이렇게하려면 이 부트 스크립트를 지정 하는 &lt;code&gt;-boot&lt;/code&gt; 명령 줄 매개 변수를 사용하여 Erlang을 시작하십시오 (전체 경로는 있지만 &lt;code&gt;.boot&lt;/code&gt; 접미어는 사용 하지 않음 ). UNIX에서는 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1079562f698ab46db96db811ee51262354e5cae9" translate="yes" xml:space="preserve">
          <source>Test the function:</source>
          <target state="translated">기능을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="10e93232f5ee13cde5c73ae6c73ca6a57a250ad6" translate="yes" xml:space="preserve">
          <source>TestResult</source>
          <target state="translated">TestResult</target>
        </trans-unit>
        <trans-unit id="9ff287ce9b2c7f5d011b9dafc2c0e9b0834011d4" translate="yes" xml:space="preserve">
          <source>Testing can be turned off by defining the &lt;code&gt;NOTEST&lt;/code&gt; macro when compiling, for example as an option to &lt;code&gt;erlc&lt;/code&gt;, as in:</source>
          <target state="translated">다음 과 같이 컴파일 할 때 &lt;code&gt;NOTEST&lt;/code&gt; 매크로 를 정의하여 ( 예 : &lt;code&gt;erlc&lt;/code&gt; 옵션으로) 테스트를 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2585f55dae2dfcc3e47a81c069669b6106c8d569" translate="yes" xml:space="preserve">
          <source>Testing is performed by running test suites (sets of test cases) or individual test cases. A test suite is implemented as an Erlang module named &lt;code&gt;&amp;lt;suite_name&amp;gt;_SUITE.erl&lt;/code&gt; which contains a number of test cases. A test case is an Erlang function that tests one or more things. The test case is the smallest unit that the &lt;code&gt;Common Test&lt;/code&gt; test server deals with.</source>
          <target state="translated">테스트 스위트 (테스트 케이스 세트) 또는 개별 테스트 케이스를 실행하여 테스트를 수행합니다. 테스트 스위트는 여러 테스트 사례를 포함하는 &lt;code&gt;&amp;lt;suite_name&amp;gt;_SUITE.erl&lt;/code&gt; 이라는 Erlang 모듈로 구현됩니다 . 테스트 케이스는 하나 이상의 것을 테스트하는 Erlang 함수입니다. 테스트 케이스는 &lt;code&gt;Common Test&lt;/code&gt; 테스트 서버 가 처리하는 가장 작은 단위입니다 .</target>
        </trans-unit>
        <trans-unit id="cc6f17d3447c6fc66e6aa450b14b5cd25f941708" translate="yes" xml:space="preserve">
          <source>Testing that a complete system behaves according to its specification. Specifically, system testing should not require knowing any details about the implementation. It typically involves testing many different aspects of the system behaviour apart from the basic functionality, such as performance, usability, and reliability.</source>
          <target state="translated">전체 시스템이 사양에 따라 작동하는지 테스트 특히 시스템 테스트는 구현에 대한 세부 사항을 알 필요가 없습니다. 일반적으로 성능, 유용성 및 안정성과 같은 기본 기능 외에도 시스템 동작의 다양한 측면을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="20415ba2297f8ab20d67c7323905cf5ac08c6d83" translate="yes" xml:space="preserve">
          <source>Testing that a number of individually developed program units (assumed to already have been separately unit tested) work together as expected. Depending on the system being developed, integration testing may be as simple as &quot;just another level of unit testing&quot;, but might also involve other kinds of tests (compare &lt;strong&gt;system testing&lt;/strong&gt;).</source>
          <target state="translated">개별적으로 개발 된 여러 프로그램 단위 (이미 개별적으로 단위 테스트를 거친 것으로 가정) 테스트는 예상대로 함께 작동합니다. 개발중인 시스템에 따라 통합 테스트는 &quot;다른 수준의 단위 테스트&quot;처럼 간단 할 수 있지만 다른 종류의 테스트 ( &lt;strong&gt;시스템 테스트&lt;/strong&gt; 비교)도 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f22e406cc557d808f91d5ca40281d6d87b69e3f" translate="yes" xml:space="preserve">
          <source>Testing that a program unit behaves as it is supposed to do (in itself), according to its specifications. Unit tests have an important function as regression tests, when the program later is modified for some reason, since they check that the program still behaves according to specification.</source>
          <target state="translated">프로그램 단위가 사양에 따라 (자체적으로) 예상대로 동작하는지 테스트. 단위 테스트는 프로그램이 사양에 따라 여전히 작동하는지 확인하기 때문에 나중에 어떤 이유로 프로그램이 수정 될 때 회귀 테스트로서 중요한 기능을합니다.</target>
        </trans-unit>
        <trans-unit id="4edeec23b3417c02267c0c57b9ce61f0a5bdd89d" translate="yes" xml:space="preserve">
          <source>Testing the Application Configuration File</source>
          <target state="translated">응용 프로그램 구성 파일 테스트</target>
        </trans-unit>
        <trans-unit id="d049bb261c78990b7f3a05cead76ac7f2ab8f8d3" translate="yes" xml:space="preserve">
          <source>Testing this program gives:</source>
          <target state="translated">이 프로그램을 테스트하면 다음이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebcdae36a9b05a6e1ab46518e4e58eef26626f1" translate="yes" xml:space="preserve">
          <source>Tests a match specification used in calls to &lt;code&gt;ets:select/2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;. The function tests both a match specification for &quot;syntactic&quot; correctness and runs the match specification against the object. If the match specification contains errors, the tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">&lt;code&gt;ets:select/2&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 호출에 사용 된 일치 스펙을 테스트합니다 . 이 함수는 &quot;구문&quot;정확성에 대한 일치 스펙을 테스트하고 오브젝트에 대해 일치 스펙을 실행합니다. 일치 스펙에 오류가 포함 된 경우 튜플 &lt;code&gt;{error, Errors}&lt;/code&gt; 가 리턴됩니다. 여기서 &lt;code&gt;Errors&lt;/code&gt; 는 일치 스펙의 문제점에 대한 자연어 설명 목록입니다.</target>
        </trans-unit>
        <trans-unit id="20af8d3a638a732a9ca30d0034512653a2afc567" translate="yes" xml:space="preserve">
          <source>Tests are spawned on &lt;code&gt;Node&lt;/code&gt; according to &lt;code&gt;TestSpecs&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;TestSpecs&lt;/code&gt; 에 따라 &lt;code&gt;Node&lt;/code&gt; 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="25a350c07b1dc4870d3e5fe60df517c27f4d00ae" translate="yes" xml:space="preserve">
          <source>Tests are spawned on &lt;code&gt;Node&lt;/code&gt; using &lt;code&gt;ct:run_test/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ct:run_test/1&lt;/code&gt; 을 사용하여 &lt;code&gt;Node&lt;/code&gt; 에서 테스트가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9a6986bdc799652b1ed63c152d9475dfa79837d" translate="yes" xml:space="preserve">
          <source>Tests are spawned on the nodes as specified in &lt;code&gt;TestSpecs&lt;/code&gt;. Each specification in &lt;code&gt;TestSpec&lt;/code&gt; is handled separately. However, it is also possible to specify a list of specifications to be merged into one specification before the tests are executed. Any test without a particular node specification is also executed on the nodes in &lt;code&gt;InclNodes&lt;/code&gt;. Nodes in the &lt;code&gt;ExclNodes&lt;/code&gt; list are excluded from the test.</source>
          <target state="translated">&lt;code&gt;TestSpecs&lt;/code&gt; 에 지정된대로 노드에서 테스트가 생성됩니다 . &lt;code&gt;TestSpec&lt;/code&gt; 의 각 스펙 은 별도로 처리됩니다. 그러나 테스트를 실행하기 전에 하나의 사양으로 병합 할 사양 목록을 지정할 수도 있습니다. 특정 노드 지정이없는 테스트는 &lt;code&gt;InclNodes&lt;/code&gt; 의 노드에서도 실행됩니다 . &lt;code&gt;ExclNodes&lt;/code&gt; 목록의 노드 는 테스트에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="70b11f1992889a6b7c7c46cf1041e8db8225983d" translate="yes" xml:space="preserve">
          <source>Tests are started by calling &lt;code&gt;&lt;a href=&quot;ct_master#run-1&quot;&gt;ct_master:run(TestSpecs)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_master#run-3&quot;&gt;ct_master:run(TestSpecs, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_master#run-1&quot;&gt;ct_master:run(TestSpecs)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct_master#run-3&quot;&gt;ct_master:run(TestSpecs, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt; 를 호출하여 테스트를 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="ef16c9679cb63420148768ec48ac04c5d63e936c" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Expr&lt;/code&gt; is a legal guard test. &lt;code&gt;Expr&lt;/code&gt; is an Erlang term representing the abstract form for the expression. &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs(Tokens)&lt;/a&gt;&lt;/code&gt; can be used to generate a list of &lt;code&gt;Expr&lt;/code&gt;.</source>
          <target state="translated">경우 테스트 &lt;code&gt;Expr&lt;/code&gt; 법적 보호 테스트입니다. &lt;code&gt;Expr&lt;/code&gt; 은 표현식의 추상 형식을 나타내는 Erlang 용어입니다. &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs(Tokens)&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;Expr&lt;/code&gt; 목록을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8ad645a0fe48da2850f345d9fd12acf10e03596" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Key&lt;/code&gt; is contained in dictionary &lt;code&gt;Dict&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 가 사전 &lt;code&gt;Dict&lt;/code&gt; 에 포함되어 있는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="6804c0c8402a7f1d95110388290468af5380b366" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Key&lt;/code&gt; is contained in dictionary &lt;code&gt;Orddict&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 가 사전 &lt;code&gt;Orddict&lt;/code&gt; 에 포함되어 있는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="17470d32fe0b145b2fa6cac2598fec80f0fef633" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Q&lt;/code&gt; is empty and returns &lt;code&gt;true&lt;/code&gt; if so, otherwise otherwise.</source>
          <target state="translated">&lt;code&gt;Q&lt;/code&gt; 가 비어 있는지 테스트 하고, 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a356ab74ac86d19af634fb0738a567189848582f" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Term&lt;/code&gt; is a queue and returns &lt;code&gt;true&lt;/code&gt; if so, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Term&lt;/code&gt; 이 대기열 인지 테스트 하고, 그렇다면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="c37996f5d93af87f0cd3d137cfbd78cf77e1b111" translate="yes" xml:space="preserve">
          <source>Tests if the Actions argument is correctly composed.</source>
          <target state="translated">Actions 인수가 올바르게 구성되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="acacfb3b7cddace5d9eb1b40646553496edf16cd" translate="yes" xml:space="preserve">
          <source>Tests if the Reply argument is correctly composed.</source>
          <target state="translated">Reply 인수가 올바르게 구성되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="05fe70637fd8ca288c9016c0d2d69bc952a899ac" translate="yes" xml:space="preserve">
          <source>Text to the operator console.</source>
          <target state="translated">운영자 콘솔에 텍스트.</target>
        </trans-unit>
        <trans-unit id="54d4e6a8bdb666ab45d5ae6f0905988c6b9bdfe3" translate="yes" xml:space="preserve">
          <source>Textbook basic form Box-Muller standard normal deviate</source>
          <target state="translated">교과서 기본 형식 Box-Muller 표준 표준 편차</target>
        </trans-unit>
        <trans-unit id="2f72bba0ea07edaf4c51d66fc5bb6bab86a6ccd2" translate="yes" xml:space="preserve">
          <source>Thaana</source>
          <target state="translated">Thaana</target>
        </trans-unit>
        <trans-unit id="c32767e0541fe7038ff8d87e7b8aed17f49474f8" translate="yes" xml:space="preserve">
          <source>Thai</source>
          <target state="translated">Thai</target>
        </trans-unit>
        <trans-unit id="7c54512782f0b8a8a8ee3e013c2e8e72a5dedaa8" translate="yes" xml:space="preserve">
          <source>That EPMD is running</source>
          <target state="translated">EPMD가 실행 중입니다</target>
        </trans-unit>
        <trans-unit id="6d5dd72a57184dddefa9dbd040521e6e6341703b" translate="yes" xml:space="preserve">
          <source>That environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; is set correctly</source>
          <target state="translated">해당 환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 가 올바르게 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e3a97a56528bdf88e1b2051f20678cae41f8ace" translate="yes" xml:space="preserve">
          <source>That is an optimization. Most applications do not send messages with shared subterms.</source>
          <target state="translated">그것은 최적화입니다. 대부분의 응용 프로그램은 공유 하위 용어가있는 메시지를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c80baa8384a9b1de6a39a6f7088119999c1a237" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;Message&lt;/code&gt; (any Erlang term) is sent to the process with identity &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;Message&lt;/code&gt; (모든 Erlang 용어)가 ID &lt;code&gt;Pid&lt;/code&gt; 로 프로세스에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="45015129465c2268d074359ec5005e5d4d17b91b" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;filtermap&lt;/code&gt; behaves as if it had been defined as follows:</source>
          <target state="translated">즉, &lt;code&gt;filtermap&lt;/code&gt; 은 다음과 같이 정의 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="535867dd76e5b138e05f832dc9af825cc91d8cc3" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;flatmap&lt;/code&gt; behaves as if it had been defined as follows:</source>
          <target state="translated">즉, &lt;code&gt;flatmap&lt;/code&gt; 은 다음과 같이 정의 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="aad791da5a9f2ebf28101f220528f9b8d026646d" translate="yes" xml:space="preserve">
          <source>That is, a leap year. The next two &lt;code&gt;trunc&lt;/code&gt;-tests evaluate if the year is divisible by 100 or 4 in the same way. The first &lt;code&gt;if&lt;/code&gt; returns &lt;code&gt;leap&lt;/code&gt; or &lt;code&gt;not_leap&lt;/code&gt;, which lands up in the variable &lt;code&gt;Leap&lt;/code&gt;. This variable is used in the guard for &lt;code&gt;feb&lt;/code&gt; in the following &lt;code&gt;case&lt;/code&gt; that tells us how long the month is.</source>
          <target state="translated">즉, 윤년입니다. 다음 두 &lt;code&gt;trunc&lt;/code&gt; -tests는 연도가 같은 방식으로 100 또는 4로 나눌 수 있는지 평가합니다. 첫 번째 &lt;code&gt;if&lt;/code&gt; 는 &lt;code&gt;leap&lt;/code&gt; 또는 &lt;code&gt;not_leap&lt;/code&gt; 을 반환 하며 , 이는 &lt;code&gt;Leap&lt;/code&gt; 변수에 포함 됩니다. 이 변수는 다음의 &lt;code&gt;case&lt;/code&gt; &lt;code&gt;feb&lt;/code&gt; 의 가드에 사용되어 월이 얼마나 오래되었는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="61bd067e8a1df03751d1301ebc5a385097e1ecce" translate="yes" xml:space="preserve">
          <source>That is, a trace output, with both the function called and the resulting value.</source>
          <target state="translated">즉, 호출 된 함수와 결과 값이 모두있는 추적 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b1bb322ca91a6283f723e39d12e1d20ae13c765c" translate="yes" xml:space="preserve">
          <source>That is, all the bound variables in the match head as a list. If tuples are to be constructed, one has to write a tuple of arity 1 where the single element in the tuple is the tuple one wants to construct (as an ordinary tuple can be mistaken for a &lt;code&gt;Guard&lt;/code&gt;).</source>
          <target state="translated">즉, 일치 헤드의 모든 바운드 변수가 목록입니다. 튜플을 구성하려면 튜플의 단일 요소가 구성하려는 튜플 인 arity 1의 튜플을 작성해야합니다 (일반 튜플은 &lt;code&gt;Guard&lt;/code&gt; 로 오인 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">그건:</target>
        </trans-unit>
        <trans-unit id="7179c2c2c75b5324944355b82ad607b610b23c74" translate="yes" xml:space="preserve">
          <source>That should make it possible to rebuild any library without hassle...</source>
          <target state="translated">번거 로움없이 라이브러리를 다시 만들 수 있어야합니다 ...</target>
        </trans-unit>
        <trans-unit id="ff03a468de0d9ed380aa26940cb3d4ce174a3748" translate="yes" xml:space="preserve">
          <source>That the correct cookie was used</source>
          <target state="translated">올바른 쿠키가 사용되었습니다</target>
        </trans-unit>
        <trans-unit id="fbb73f156f2e40ae17a54d203d8b3537e9a4d680" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;ei&lt;/code&gt; library</source>
          <target state="translated">다른 쪽의 원격 Erlang 노드가 &lt;code&gt;ei&lt;/code&gt; 라이브러리 와 동일한 버전의 Erlang을 실행하고 있음</target>
        </trans-unit>
        <trans-unit id="43093885e0893ad901ee4b46bda00f5dc1d9a9d7" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;erl_interface&lt;/code&gt; library</source>
          <target state="translated">다른 쪽의 원격 Erlang 노드가 &lt;code&gt;erl_interface&lt;/code&gt; 라이브러리 와 동일한 버전의 Erlang을 실행하고 있음</target>
        </trans-unit>
        <trans-unit id="e3420600d759a760d25722c58727ef289f531b08" translate="yes" xml:space="preserve">
          <source>That was once true, but from R6B the BEAM compiler can see that a variable is not used.</source>
          <target state="translated">그것은 한 번 사실이지만 R6B에서 BEAM 컴파일러는 변수가 사용되지 않음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aefbfb778a6045a9feec711cee7f0b6bfe06745c" translate="yes" xml:space="preserve">
          <source>That was true to some extent before R12B. It was even more true before R7B. Today, not so much. A body-recursive function generally uses the same amount of memory as a tail-recursive function. It is generally not possible to predict whether the tail-recursive or the body-recursive version will be faster. Therefore, use the version that makes your code cleaner (hint: it is usually the body-recursive version).</source>
          <target state="translated">R12B 이전에는 어느 정도 사실이었습니다. R7B 이전에는 더욱 사실이었습니다. 오늘은 그렇게 많지 않습니다. body-recursive 함수는 일반적으로 tail-recursive 함수와 동일한 양의 메모리를 사용합니다. 꼬리 재귀 또는 신체 재귀 버전이 더 빠른지 여부를 예측하는 것은 일반적으로 불가능합니다. 따라서 코드를 더 깨끗하게 만드는 버전을 사용하십시오 (힌트 : 일반적으로 본문 재귀 버전 임).</target>
        </trans-unit>
        <trans-unit id="8ef05f15aa52cadeef34686e592834e1d7565d8c" translate="yes" xml:space="preserve">
          <source>That will copy the emulator executables.</source>
          <target state="translated">에뮬레이터 실행 파일이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b9697cd4f3baa91fdf236c77e1a263c60d4132" translate="yes" xml:space="preserve">
          <source>That's basically all you need to get going.</source>
          <target state="translated">이것이 기본적으로 필요한 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="82c971d45846792b2b886cdbb85418dc5903f332" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator has a complexity proportional to the product of the length of its operands. This means that the operator is very slow if both of its operands are long lists:</source>
          <target state="translated">&quot; &lt;code&gt;--&lt;/code&gt; &quot;연산자는 피연산자 길이의 곱에 비례하여 복잡성이 있습니다. 이는 두 피연산자가 모두 긴 목록 인 경우 연산자가 매우 느리다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff5589371f0dbe70e4139850cd24f1db48567113" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;strong&gt;state callback&lt;/strong&gt;&quot; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 특정 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 에 대한 &quot; &lt;strong&gt;상태 콜백&lt;/strong&gt; &quot; 은이 상태의 모든 이벤트에 대해 호출되는 콜백 함수입니다. 콜백 모듈이 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 으로 정의 하는 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 에 따라 선택 됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd11f0de519165a84c1b8fcc83fbb4913df33819" translate="yes" xml:space="preserve">
          <source>The &quot;Definitions.&quot;, &quot;Rules.&quot; and &quot;Erlang code.&quot; headings are mandatory and must occur at the beginning of a source line. The &amp;lt;Header&amp;gt;, &amp;lt;Macro Definitions&amp;gt; and &amp;lt;Erlang code&amp;gt; sections may be empty but there must be at least one rule.</source>
          <target state="translated">&quot;정의.&quot;, &quot;규칙.&quot; &quot;Erlang 코드&quot; 제목은 필수이며 소스 행의 시작 부분에 있어야합니다. &amp;lt;헤더&amp;gt;, &amp;lt;매크로 정의&amp;gt; 및 &amp;lt;Erlang 코드&amp;gt; 섹션은 비어있을 수 있지만 하나 이상의 규칙이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6c1c05be408f7e65aa7a987ce718ffc02949c2" translate="yes" xml:space="preserve">
          <source>The &quot;Okasaki API&quot; is inspired by &quot;Purely Functional Data Structures&quot; by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases.</source>
          <target state="translated">&quot;Okasaki API&quot;는 Chris Okasaki의 &quot;순전히 기능적인 데이터 구조&quot;에서 영감을 얻었습니다. 대기열을 목록으로 간주합니다. 이 API는 많은 사람들에게 이상하고 피할 수있는 것으로 간주됩니다. 예를 들어, 많은 리버스 연산에는 어휘 적으로 반대되는 이름이 있으며, 일부는 더 읽기 쉽지만 이해하기 어려운 별칭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe7eac7bdedf25d0494e04217d2e3132e60e367" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; and the &quot;Extended API&quot; both use the mental picture of a waiting line of items. Both have reverse operations suffixed &quot;_r&quot;.</source>
          <target state="translated">&quot;원래 API&quot;및 &quot;확장 API&quot;는 모두 대기중인 항목의 정신적 인 그림을 사용합니다. 둘 다 &quot;_r&quot;접미어 역 연산이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3887fa2b48cbded502d3da264fbe59b3f1883ab5" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; item removal functions return compound terms with both the removed item and the resulting queue. The &quot;Extended API&quot; contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the &quot;Okasaki API&quot; functions build less garbage.</source>
          <target state="translated">&quot;원래 API&quot;항목 제거 함수는 제거 된 항목과 결과 큐가 모두있는 복합 용어를 리턴합니다. &quot;확장 API&quot;에는 가비지가 적은 대체 기능과 대기열 끝을 검사하기위한 기능이 포함되어 있습니다. 또한 &quot;오카 사키 API&quot;기능은 쓰레기를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7a1a738b6242350a278b4cc4eaff19808c280faf" translate="yes" xml:space="preserve">
          <source>The &quot;Oxford Advanced Learners Dictionary of Current English&quot; says the following about the word &quot;indent&quot;:</source>
          <target state="translated">&quot;현재 영어 옥스포드 고급 학습자 사전&quot;은 &quot;들여 쓰기&quot;라는 단어에 대해 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="b71ca1b4095bae581a22c9bd4dc765543e310daa" translate="yes" xml:space="preserve">
          <source>The &quot;keep alive&quot; activity (that is, that &lt;code&gt;Common Test&lt;/code&gt; sends NOP to the server every 10 seconds if the connection is idle) can be enabled or disabled for one particular connection as described here. It can be disabled for all connections using &lt;code&gt;telnet_settings&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&quot;keep alive&quot;활동 (즉 , 연결이 유휴 상태 인 경우 &lt;code&gt;Common Test&lt;/code&gt; 가 10 초마다 NOP를 서버에 전송 함)은 여기에 설명 된대로 하나의 특정 연결에 대해 활성화 또는 비활성화 될 수 있습니다. &lt;code&gt;telnet_settings&lt;/code&gt; 를 사용하여 모든 연결에 대해 비활성화 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4fe589f8c1fff89269afb0db8e6111d61dec7b78" translate="yes" xml:space="preserve">
          <source>The &quot;private&quot; message &lt;code&gt;{From, rewind}&lt;/code&gt; results in the current position in the pseudo-file to be reset to &lt;code&gt;0&lt;/code&gt; (the beginning of the &quot;file&quot;). This is a typical example of I/O device-specific messages not being part of the I/O protocol. It is usually a bad idea to embed such private messages in &lt;code&gt;io_request&lt;/code&gt; tuples, as that can confuse the reader.</source>
          <target state="translated">&quot;private&quot;메시지 &lt;code&gt;{From, rewind}&lt;/code&gt; 는 의사 파일의 현재 위치가 &lt;code&gt;0&lt;/code&gt; ( &quot;파일&quot;의 시작) 으로 재설정됩니다 . 이는 I / O 장치 특정 메시지가 I / O 프로토콜의 일부가 아닌 일반적인 예입니다. 독자를 혼동시킬 수 &lt;code&gt;io_request&lt;/code&gt; 이러한 개인 메시지를 io_request 튜플 에 포함시키는 것은 일반적으로 나쁜 생각 입니다.</target>
        </trans-unit>
        <trans-unit id="e4a690e384b2d5a804cad58bd96420656c204892" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page includes a link to the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file in which information about imported configuration data and general test progress is written. This log file is useful to get snapshot information about the test run during execution. It can also be helpful when analyzing test results or debugging test suites.</source>
          <target state="translated">&quot;테스트 실행 색인&quot;페이지에는 가져온 구성 데이터 및 일반 테스트 진행에 대한 정보가 기록 되는 &lt;code&gt;Common Test&lt;/code&gt; Framework 로그 파일에 대한 링크가 포함되어 있습니다. 이 로그 파일은 실행 중 테스트 실행에 대한 스냅 샷 정보를 얻는 데 유용합니다. 테스트 결과를 분석하거나 테스트 스위트를 디버깅 할 때도 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3be9bfee853a4424aae3e9b08197fdb2f6acc7" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page indicates if a test has missing suites (that is, suites that &lt;code&gt;Common Test&lt;/code&gt; failed to compile). Names of the missing suites can be found in the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file.</source>
          <target state="translated">&quot;test run index&quot;페이지는 테스트에 누락 된 스위트 (즉, &lt;code&gt;Common Test&lt;/code&gt; 가 컴파일하지 못한 스위트)가 있는지 표시합니다 . 누락 된 제품군의 이름은 &lt;code&gt;Common Test&lt;/code&gt; Framework 로그 파일 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a60728f91de50a0cab75ed1bd09ee0c55638db56" translate="yes" xml:space="preserve">
          <source>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying &lt;code&gt;{parts,&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;:</source>
          <target state="translated">&quot;trim&quot;옵션이 말합니다. &quot;빈 부분을 제외하고 가능한 한 많은 부분을 알려주십시오&quot;. 때로는 유용 할 수 있습니다. &lt;code&gt;{parts,&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; 을 지정하여 원하는 부품 수를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8edde0db65ff7f9e25c8ce9f9ce0286b2ab0b7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;Regexp&amp;gt; must occur at the start of a line and not include any blanks; use &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; to include TAB and SPACE characters in the regular expression. If &amp;lt;Regexp&amp;gt; matches then the corresponding &amp;lt;Erlang code&amp;gt; is evaluated to generate a token. With the Erlang code the following predefined variables are available:</source>
          <target state="translated">&amp;lt;Regexp&amp;gt;는 줄의 시작 부분에 나타나야하며 공백을 포함하지 않아야합니다. &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\s&lt;/code&gt; 를 사용 하여 정규식에 TAB 및 SPACE 문자를 포함 시키십시오. &amp;lt;Regexp&amp;gt;가 일치하면 해당 &amp;lt;Erlang 코드&amp;gt;가 평가되어 토큰을 생성합니다. Erlang 코드를 사용하면 다음과 같은 사전 정의 된 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd6006060b360d3964e6301c70d62dfa6542605" translate="yes" xml:space="preserve">
          <source>The (*MARK) name is tagged with &quot;MK:&quot; in this output, and in this example it indicates which of the two alternatives matched. This is a more efficient way of obtaining this information than putting each alternative in its own capturing parentheses.</source>
          <target state="translated">이 출력에서 ​​(* MARK) 이름은 &quot;MK :&quot;로 태그가 지정되며이 예에서는 두 가지 대안 중 일치하는 것을 나타냅니다. 이는 각 대안을 자체 캡처 괄호 안에 넣는 것보다이 정보를 얻는보다 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7626cd8d4a95d16adbb501a045b70ff730bc3449" translate="yes" xml:space="preserve">
          <source>The (*UTF8) and (*UCP) leading sequences can be used to set UTF and Unicode property modes. They are equivalent to setting options &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;ucp&lt;/code&gt;, respectively. The (*UTF) sequence is a generic version that can be used with any of the libraries. However, the application can set option &lt;code&gt;never_utf&lt;/code&gt;, which locks out the use of the (*UTF) sequences.</source>
          <target state="translated">(* UTF8) 및 (* UCP) 선행 시퀀스를 사용하여 UTF 및 유니 코드 특성 모드를 설정할 수 있습니다. 옵션 &lt;code&gt;unicode&lt;/code&gt; 및 &lt;code&gt;ucp&lt;/code&gt; 를 각각 설정하는 것과 같습니다 . (* UTF) 시퀀스는 모든 라이브러리에서 사용할 수있는 일반 버전입니다. 그러나 응용 프로그램은 &lt;code&gt;never_utf&lt;/code&gt; 옵션을 설정 하여 (* UTF) 시퀀스 사용을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="0af8bbc7ab3d2447bd6a5d8520e9f3d0f277f0b4" translate="yes" xml:space="preserve">
          <source>The (built-in) &lt;code&gt;escript&lt;/code&gt; program first determines which Erlang runtime system to use and then starts it to execute your script. Usually the runtime system is located in the same Erlang installation as the &lt;code&gt;escript&lt;/code&gt; program itself. But for standalone systems with one or more escripts it may be the case that the &lt;code&gt;escript&lt;/code&gt; program in your path actually starts the runtime system bundled with the escript. This is intentional, and typically happens when the standalone system &lt;code&gt;bin&lt;/code&gt; directory is not in the execution path (as it may cause its &lt;code&gt;erl&lt;/code&gt; program to override the desired one) and the &lt;code&gt;escript&lt;/code&gt;(s) are referred to via symbolic links from a &lt;code&gt;bin&lt;/code&gt; directory in the path.</source>
          <target state="translated">내장 된 &lt;code&gt;escript&lt;/code&gt; 프로그램은 먼저 사용할 Erlang 런타임 시스템을 판별 한 후이를 시작하여 스크립트를 실행합니다. 일반적으로 런타임 시스템은 &lt;code&gt;escript&lt;/code&gt; 프로그램 자체 와 동일한 Erlang 설치에 있습니다. 그러나 하나 이상의 escript가있는 독립형 시스템의 경우 경로 의 &lt;code&gt;escript&lt;/code&gt; 프로그램이 실제로 escript와 번들로 제공되는 런타임 시스템을 시작하는 경우가 있습니다. 이것은 의도적 인 것이며 일반적으로 독립형 시스템 &lt;code&gt;bin&lt;/code&gt; 디렉토리가 실행 경로에 있지 않을 때 ( &lt;code&gt;erl&lt;/code&gt; 프로그램이 원하는 것을 대체 할 수 있기 때문에 ) &lt;code&gt;escript&lt;/code&gt; 는 &lt;code&gt;bin&lt;/code&gt; 디렉토리의 기호 링크를 통해 참조됩니다 . 경로.</target>
        </trans-unit>
        <trans-unit id="dfd9ff6975abbc395a9f98a9f0cbda02a2c72d28" translate="yes" xml:space="preserve">
          <source>The (compressed) tape archive file is to be extracted in the installation directory defined above.</source>
          <target state="translated">(압축 된) 테이프 아카이브 파일은 위에서 정의한 설치 디렉토리에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcfaa6a575093f30922fde0b326af66b1dc8369" translate="yes" xml:space="preserve">
          <source>The (hidden) node implements atom cache (obsolete).</source>
          <target state="translated">(숨겨진) 노드는 아톰 캐시 (구식)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="148d899ab108f6515349d4b01878d74abd02d0c9" translate="yes" xml:space="preserve">
          <source>The (host operating system) environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; can be used to give default compiler options. Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not a list, it is put into a list.</source>
          <target state="translated">(호스트 운영 체제) 환경 변수 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 를 사용하여 기본 컴파일러 옵션을 제공 할 수 있습니다. 값은 유효한 Erlang 용어 여야합니다. 값이 목록이면 그대로 사용됩니다. 목록이 아닌 경우 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f06fadd0b84d13f99d85c50cfc349e4a25addef3" translate="yes" xml:space="preserve">
          <source>The (possibly flattened) &lt;code&gt;Path&lt;/code&gt; parameter must be consistent throughout the system. A driver is to, by all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, be loaded using the same &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt;. The exception is when &lt;strong&gt;reloading&lt;/strong&gt; is requested, in which case &lt;code&gt;Path&lt;/code&gt; can be specified differently. Notice that all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; trying to load the driver later need to use the &lt;strong&gt;new&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; if &lt;code&gt;Path&lt;/code&gt; is changed using a &lt;code&gt;reload&lt;/code&gt; option. This is yet another reason to have &lt;strong&gt;only one loader&lt;/strong&gt; of a driver one wants to upgrade in a running system.</source>
          <target state="translated">(아마도 평평한) &lt;code&gt;Path&lt;/code&gt; 매개 변수는 시스템 전체에서 일관성이 있어야합니다. 모든 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 는 동일한 &lt;strong&gt;리터럴 &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 사용하여 드라이버를 로드해야합니다 . &lt;strong&gt;재로드&lt;/strong&gt; 가 요청 된 경우는 예외이며 ,이 경우 &lt;code&gt;Path&lt;/code&gt; 를 다르게 지정할 수 있습니다. 나중에 드라이버를로드하려는 모든 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;Path&lt;/code&gt; 가 &lt;code&gt;reload&lt;/code&gt; 옵션을 사용하여 변경 되면 &lt;strong&gt;새 &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 를 사용해야합니다 . 이것은 실행중인 시스템에서 업그레이드하려는 드라이버 &lt;strong&gt;로더&lt;/strong&gt; 가 &lt;strong&gt;하나만&lt;/strong&gt; 있어야하는 또 다른 이유 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c443fb128bea98f3149bd2df5d12047cad839bc" translate="yes" xml:space="preserve">
          <source>The 16 bytes MD5 of the significant parts of the Beam file.</source>
          <target state="translated">Beam 파일의 중요한 부분의 16 바이트 MD5</target>
        </trans-unit>
        <trans-unit id="7d39efdef71579d11fb25cc52651c18fba9a7537" translate="yes" xml:space="preserve">
          <source>The 3-tuple form additionally specifies an interval, in milliseconds, after which a started transport process should be terminated if it has not yet established a connection. For example, the following options on a connecting transport request a connection with one peer over SCTP or another (typically the same) over TCP.</source>
          <target state="translated">3 개의 튜플 형식은 또한 연결을 아직 설정하지 않은 경우 시작된 전송 프로세스를 종료해야하는 간격 (밀리 초)을 추가로 지정합니다. 예를 들어, 연결 전송의 다음 옵션은 SCTP를 통한 한 피어 또는 TCP를 통한 다른 피어 (일반적으로 동일한)와의 연결을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="acebf1a57043cf38ebb17933963dec066b1efb07" translate="yes" xml:space="preserve">
          <source>The 4-byte header is limited to 2Gb.</source>
          <target state="translated">4 바이트 헤더는 2Gb로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c54cda7cb6bfe2ffa1c818c4fe4b01c2c1e1b503" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; type consists of the following options:</source>
          <target state="translated">&lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; 유형은 다음의 옵션으로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="865c911e774746bccfef22abcc84f0e0893f4e7b" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; driver API functions need a port handle that identifies the driver instance (and the port in the emulator). This is only passed to the &lt;code&gt;start&lt;/code&gt; function, but not to the other functions. The &lt;code&gt;start&lt;/code&gt; function returns a driver-defined handle that is passed to the other functions. A common practice is to have the &lt;code&gt;start&lt;/code&gt; function allocate some application-defined structure and stash the &lt;code&gt;port&lt;/code&gt; handle in it, to use it later with the driver API functions.</source>
          <target state="translated">&lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 의 드라이버 API 기능은 드라이버 인스턴스를 식별하는 포트 핸들 (에뮬레이터의 포트)가 필요합니다. 이것은 &lt;code&gt;start&lt;/code&gt; 기능 에만 전달 되지만 다른 기능 에는 전달 되지 않습니다. &lt;code&gt;start&lt;/code&gt; 함수가 다른 함수에 전달되는 드라이버 정의 핸들을 반환합니다. 일반적인 관행은 &lt;code&gt;start&lt;/code&gt; 함수가 애플리케이션 정의 구조를 할당하고 &lt;code&gt;port&lt;/code&gt; 핸들을 숨겨서 나중에 드라이버 API 함수와 함께 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="418f98e4e66687632d887b26d161001270432df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; file contains all available cross configuration variables and can be used as a template when creating a cross compilation configuration. All &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; are also listed at the end of this document. For examples of working cross configurations see the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; file and the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; file. If the default behavior of a variable is satisfactory, the variable does not need to be set. However, the &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">&lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; 파일을 사용할 수있는 모든 크로스 구성 변수를 포함하고 크로스 컴파일 구성을 만들 때 템플릿으로 사용할 수 있습니다. 모든 &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; 도이 문서의 끝에 나와 있습니다. 크로스 구성 작업의 예는 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; 파일 및 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; 파일을 참조 하십시오. 변수의 기본 동작이 만족스러운 경우 변수를 설정할 필요가 없습니다. 그러나 기본값을 사용 하면 &lt;code&gt;configure&lt;/code&gt; 스크립트가 경고를 발행합니다. 변수가 설정되면 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8c049d3991b699c878b126ce3c6bdb33cc7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; directory is where new release packets are installed, and where the release handler keeps information about releases. For more information, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">&lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 디렉토리는 새 릴리스 패킷이 설치되어있는 곳이며, 출시 핸들러는 릴리스에 대한 정보를 유지 곳. 자세한 내용 은 SASL 의 &lt;code&gt;release_handler(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="927497bac1e3aacb4e090f1231bc5491dae42268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++&lt;/code&gt; operator has, somewhat undeservedly, got a bad reputation. It probably has something to do with code like the following, which is the most inefficient way there is to reverse a list:</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 의 연산자는 다소 부당, 나쁜 평판을 가지고있다. 아마도 다음과 같은 코드와 관련이있을 수 있습니다. 목록을 뒤집는 가장 비효율적 인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="42130a038f0aadad4f70fd60034fb79e9e360ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;#&lt;/code&gt; operators are defined for line number expressions, provided the operands are compatible. The LineOp operators are also defined for modules, applications, and releases; the operand is implicitly converted to functions. Similarly, the cast operator is defined for the interpretation of the LineOp operators.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 는 , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;#&lt;/code&gt; 의 연산자 줄 번호 식에 정의 된, 피연산자가 호환 제공. LineOp 연산자는 모듈, 응용 프로그램 및 릴리스에 대해서도 정의됩니다. 피연산자는 암시 적으로 함수로 변환됩니다. 마찬가지로 캐스트 연산자는 LineOp 연산자의 해석을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7d867665c4e36dd9997bf46a9f78b7c231955da1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fna&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt;. This has effect if the locale settings cause the behavior of &lt;code&gt;+fnu&lt;/code&gt; to be selected; see the description of &lt;code&gt;+fnu&lt;/code&gt; above. If the locale settings cause the behavior of &lt;code&gt;+fnl&lt;/code&gt; to be selected, then &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; have no effect.</source>
          <target state="translated">&lt;code&gt;+fna&lt;/code&gt; 스위치 뒤에 수 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , 또는 &lt;code&gt;e&lt;/code&gt; . 이것은 로케일 설정으로 인해 &lt;code&gt;+fnu&lt;/code&gt; 동작 이 선택 되는 경우 효과 가 있습니다. 위 의 &lt;code&gt;+fnu&lt;/code&gt; 에 대한 설명을 참조하십시오 . 로케일 설정으로 인해 &lt;code&gt;+fnl&lt;/code&gt; 동작 이 선택되면 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6133996f9262b8d90826837351bd3d8efee96b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fnu&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported:</source>
          <target state="translated">&lt;code&gt;+fnu&lt;/code&gt; 스위치 뒤에 수 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , 또는 &lt;code&gt;e&lt;/code&gt; 잘못 인코딩 된 파일 이름보고되어야하는 방법을 제어 :</target>
        </trans-unit>
        <trans-unit id="831e6d2347d95f44b19c16835a12096caa3382d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--enable-bootstrap-only&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt; isn't strictly necessary, but will speed things up. It will only run &lt;code&gt;configure&lt;/code&gt; in applications necessary for the bootstrap, and will disable a lot of things not needed by the bootstrap system. If you run &lt;code&gt;configure&lt;/code&gt; without &lt;code&gt;--enable-boostrap-only&lt;/code&gt; you also have to run make as &lt;code&gt;make bootstrap&lt;/code&gt;; otherwise, the whole system will be built.</source>
          <target state="translated">&lt;code&gt;--enable-bootstrap-only&lt;/code&gt; 에 인수 &lt;code&gt;configure&lt;/code&gt; 반드시 필요한 것은 아니지만, 일을 가속화 할 것이다. 부트 스트랩에 필요한 응용 프로그램 에서만 &lt;code&gt;configure&lt;/code&gt; 을 실행 하며 부트 스트랩 시스템에 필요하지 않은 많은 것들을 비활성화합니다. 당신이 실행하는 경우 &lt;code&gt;configure&lt;/code&gt; 하지 않고 &lt;code&gt;--enable-boostrap-only&lt;/code&gt; 당신은 또한 메이크업 실행해야 &lt;code&gt;make bootstrap&lt;/code&gt; ; 그렇지 않으면 전체 시스템이 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="f9606e2fd218b40d91d81e57470942cf1aec71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-error()&lt;/code&gt; and &lt;code&gt;-warning()&lt;/code&gt; directives were added in OTP 19.</source>
          <target state="translated">&lt;code&gt;-error()&lt;/code&gt; 및 &lt;code&gt;-warning()&lt;/code&gt; 지시어는 OTP (19)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c265860ecc1894d7ef2df5fb5a19bf0d362bff43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-on_load()&lt;/code&gt; directive names a function that is to be run automatically when a module is loaded.</source>
          <target state="translated">&lt;code&gt;-on_load()&lt;/code&gt; 모듈이로드 될 때입니다 지시어 이름의 함수가 자동으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="aa13e09e4d341c2108d3357512871ca10a0cc6bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; file for release may reside in the &lt;code&gt;ebin&lt;/code&gt;-directory in a development environment but it is encouraged that this is an artifact of the build step. By convention a &lt;code&gt;.app.src&lt;/code&gt; file is used, which resides in the &lt;code&gt;src&lt;/code&gt; directory. This file is nearly identical as the &lt;code&gt;.app&lt;/code&gt; file but certain fields may be replaced during the build step, such as the application version.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 릴리스에 대한 파일에 존재할 수 &lt;code&gt;ebin&lt;/code&gt; 개발 환경에서 -directory하지만이 빌드 단계의 이슈 것을 권장합니다. 일반적으로 &lt;code&gt;.app.src&lt;/code&gt; 파일이 사용되며 &lt;code&gt;src&lt;/code&gt; 디렉토리에 있습니다. 이 파일은 &lt;code&gt;.app&lt;/code&gt; 파일 과 거의 동일 하지만 응용 프로그램 버전과 같은 빌드 단계에서 특정 필드가 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817bfba9b560dd19b99757cc44790bf08dd077b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일</target>
        </trans-unit>
        <trans-unit id="e7a9a94b1b27ccedaac07d12dcc8d76dbbdc8458" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 의 다음과 같은 파일을 볼 수 :</target>
        </trans-unit>
        <trans-unit id="0f9944b699387d7c11ea7cd1be3bab23ba4afdef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 의 파일을 업그레이드하거나 응용 프로그램을 다운 그레이드하는 데 사용되는 지침을 정의하는 하나 개의 얼랑 용어가 포함되어 있습니다. 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a4e2f387f9c84aa65d3380a5a44029b602ea3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.erlang.cookie&lt;/code&gt; file is to contain a line with the same atom. For example, on Linux or UNIX, in the OS shell:</source>
          <target state="translated">&lt;code&gt;.erlang.cookie&lt;/code&gt; 의 파일이 동일한 원자와 함께 광고를 포함한다. 예를 들어 Linux 또는 UNIX의 OS 셸에서 :</target>
        </trans-unit>
        <trans-unit id="0032fcf48e0da685e59294f0a4f697a2db8dcacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcs&lt;/code&gt; file would look like:</source>
          <target state="translated">&lt;code&gt;.funcs&lt;/code&gt; 의 파일과 같을 것이다 :</target>
        </trans-unit>
        <trans-unit id="14e7547174b37977afa693aeffb001d289cd5a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hrl&lt;/code&gt; files are generated with &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt;. Include these files in your code as in the following example:</source>
          <target state="translated">&lt;code&gt;.hrl&lt;/code&gt; 파일이 생성됩니다 &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt; . 다음 예제와 같이 이러한 파일을 코드에 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="3f3c52adfe9451ed557d5cb72636a16ce9b8cff5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일</target>
        </trans-unit>
        <trans-unit id="f61412bcc5809a8e7db35485d4bc2ee4c582bd3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains information about the release: its name, version, and which ERTS and application versions it uses.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 이름, 버전, 어떤 ERTS 및 응용 프로그램 버전이 사용 : 파일이 릴리스에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba0dc5cd4e50a75950facea5ebefcde4b2c40d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains one single Erlang term, which is called a &lt;strong&gt;release specification&lt;/strong&gt;. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일은이라고 하나 개 얼랑 용어가 포함되어 &lt;strong&gt;출시 사양&lt;/strong&gt; . 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9be75095f9fcc28e6742d9c5c6b665ebdc21fd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file must also contain &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt;, as these applications are required by &lt;code&gt;ch_app&lt;/code&gt;. The file is called &lt;code&gt;ch_rel-1.rel&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 의 파일도 있어야합니다 &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;sasl&lt;/code&gt; 이러한 응용 프로그램이 요구하는대로, &lt;code&gt;ch_app&lt;/code&gt; . 파일 이름은 &lt;code&gt;ch_rel-1.rel&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="13be72d295c9d3a74b0ba266a8b6d753044e4f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.script&lt;/code&gt; file is generated by &lt;code&gt;systools&lt;/code&gt; from a &lt;code&gt;.rel&lt;/code&gt; file and from &lt;code&gt;.app&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.script&lt;/code&gt; 파일에 의해 생성되는 &lt;code&gt;systools&lt;/code&gt; A로부터 &lt;code&gt;.rel&lt;/code&gt; 의 파일에서 &lt;code&gt;.app&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="8952d3b159688281512664b4559315ca46a6b2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; in which the resolved process id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 가 있는 해결 프로세스 ID는 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0ba8ce42f3241f6f1e8ce8e3ec88bd285be952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; in which the resolved port id is stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; 가 있는 해결 포트 ID가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9be61e44d94622615ce4101938ee713afd7cdab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; has the same behavior as before, and the old API still works. Thus, you are not required to change anything unless you want to. However, &lt;strong&gt;you are strongly encouraged to use the new API&lt;/strong&gt; instead of the old API based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; is deprecated, as it is and will be a scalability bottleneck.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; 이전과 동일한 동작을 가지고 있으며, 기존의 API는 여전히 작동합니다. 따라서 원치 않는 한 아무것도 변경하지 않아도됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 기반의 기존 API 대신 &lt;strong&gt;새 API를 사용하는 것이 좋습니다&lt;/strong&gt; . &lt;code&gt;erlang:now/0&lt;/code&gt; 은 확장 성 병목 상태이므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18bf0f08971899dc4f16a1b00f5aad47c098d502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt; state transition action explicitly postpones one received event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 모델 선택적으로 수신하도록 설계되었습니다. 선택적 수신은 수신되지 않은 이벤트를 암시 적으로 연기하지만 &lt;code&gt;postpone&lt;/code&gt; 상태 전환 조치는 하나의 수신 이벤트를 명시 적으로 연기합니다.</target>
        </trans-unit>
        <trans-unit id="2e521122544eb6fa9ab0cd68ed9751d9d365e33f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of Erlang monotonic time heavily depends on the following:</source>
          <target state="translated">Erlang 단조 시간 의 &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 는 다음에 크게 좌우됩니다.</target>
        </trans-unit>
        <trans-unit id="6f631a391a9754e49e6ee1bde4ff6f90ac52a87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 함수가 호출 NIF의 길이에 대해 런타임 시스템에 통보 할 수있다. NIF가 매우 빠르게 실행되지 않는 한 일반적으로 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42203200dce5d30a841bfbad273ab03cca628668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; records below are defined in diameter.hrl, which can be included as follows.</source>
          <target state="translated">아래의 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 레코드는 diameter.hrl로 정의되며 다음과 같이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5443a5673cfdeb62b70cfaa66a1a4d05ea2c10ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; is displayed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64917e182873d825bb4118b082544cb5020d55ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; test is not completely foolproof. For a few special node types (e.g. &lt;code&gt;arity_qualifier&lt;/code&gt;), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if &lt;code&gt;Tree&lt;/code&gt; does not actually represent legal Erlang code.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 테스트가 완전히 고장이 아닙니다. 몇 가지 특수 노드 유형 (예 : &lt;code&gt;arity_qualifier&lt;/code&gt; )의 경우, 그러한 노드가 예상되지 않은 컨텍스트에서 발생하면 결과의 되 돌리지 않은 서브 트리로 변경되지 않습니다. &lt;code&gt;Tree&lt;/code&gt; 가 실제로 올바른 Erlang 코드를 나타내지 않는 경우에만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bdddf2d9e89b5afec27570549313f0a00dfb66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; is displayed with information about all debugged processes, interpreted modules, and selected options. Initially there are normally no debugged processes. First, it must be specified which modules that are to be &lt;strong&gt;debugged&lt;/strong&gt; (also called &lt;strong&gt;interpreted&lt;/strong&gt;). Proceed as follows:</source>
          <target state="translated">모든 디버그 된 프로세스, 해석 된 모듈 및 선택한 옵션에 대한 정보가 있는 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; 표시됩니다. 처음에는 일반적으로 디버깅 된 프로세스가 없습니다. 먼저 &lt;strong&gt;디버깅&lt;/strong&gt; 할 모듈을 지정해야합니다 ( &lt;strong&gt;interpret&lt;/strong&gt; 이라고도 함 ). 다음과 같이 진행하십시오 :</target>
        </trans-unit>
        <trans-unit id="d1371003c4109f45bb7c590d9e6bfcf741d3783e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; at the time when current Erlang runtime system instance started.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 시간에 현재 얼랑 런타임 시스템 인스턴스를 시작했을 때.</target>
        </trans-unit>
        <trans-unit id="c54a199fd4640b0c1f2d1a7d7f234a5d11ebf160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; syntax and semantics resemble that of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; 구문과 의미는 펄의 유사.</target>
        </trans-unit>
        <trans-unit id="7246167f3c09c6525874f60b11ba89db7e2744c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted as the next to present to the state callback. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 은 USING 이벤트를 삽입 할 수있는 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 를 이러한 이벤트는 상태 콜백 현재까지 다음과 같이 삽입된다. 즉, 가장 오래된 수신 이벤트 인 것처럼. 이러한 이벤트에 전용 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 를 사용하면 외부 이벤트로 착각 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d79b4de0faec73ea8a56c3d33b4728d0d0f13117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 처음 입력 할 때 실행되는 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 단지에 관해서 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 작업이 점을 제외하고 &lt;code&gt;postpone&lt;/code&gt; 에 강제 &lt;code&gt;false&lt;/code&gt; 연기 할 이벤트가 없기 때문이다.</target>
        </trans-unit>
        <trans-unit id="04249803fd25f8d18a129af7ec7559589758bac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; are associated with this list of keys.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; 키의 목록과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e395a27eee95c6082f8cf61222aaf962540cea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; must then be used in calls to &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 또는 연관된 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 호출에서 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3dc033ce6bd037856bac83ebd4f39855340ec51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; type also consist of the following &lt;strong&gt;deprecated&lt;/strong&gt; symbolic time units:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; 유형은 다음과 같이 구성 &lt;strong&gt;되지&lt;/strong&gt; 상징적 인 시간 단위 :</target>
        </trans-unit>
        <trans-unit id="88d76a69dffe86852b03f6f2771d64a235602ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is expected to know if reloading is demanded before creating a monitor for loading.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 다시로드로드에 대한 모니터를 작성하기 전에 요구되는 알고 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="4ef4e16c6d6043c0d934f6a3edee0c7cc5aa2fe6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; module provides the main interface for writing test cases. This includes for example, the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 모듈은 테스트 케이스 작성을위한 주요 인터페이스를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24d2428c5253a289420ac3c56a797aad5738f051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; function prints a string to the test case log file. The &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the string to screen. The &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the same string both to file and screen. The functions are described in module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 기능은 테스트 케이스 로그 파일에 문자열을 출력합니다. &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; 기능은 화면에 문자열을 출력합니다. &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; 기능은 모두 파일을 화면에 동일한 문자열을 인쇄합니다. 기능은 모듈 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2225a95d59e4a2a00a916261ffc2ac6e972545a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program can be used for running tests from the OS command line, for example, as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 의 다음 프로그램은, 예를 들면, OS의 명령 라인에서 테스트를 실행하기 위해 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="45351661ad4006c4669c2ebdd26490749b02b241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable &lt;code&gt;Age&lt;/code&gt;, which is included at two positions in the tuple. The pattern match is performed as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; 기능 수행 패턴 매칭. 패턴과 용어를 사용하여 일치 시키려고합니다. 부작용으로 패턴의 언 바운드 변수가 바인딩됩니다. 다음 예제에서는 변수 &lt;code&gt;Age&lt;/code&gt; 를 사용하여 패턴이 만들어지며 튜플의 두 위치에 포함됩니다. 패턴 일치는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5d913aee0ec20f5c99548c0d67120c8b7390405c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 이 구현에 많이 사용되는 콜백.</target>
        </trans-unit>
        <trans-unit id="e04d20c0a21a342accdbeea00bdc89554c9bbc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel. If the receiving channel is an Erlang process, the messages have the format &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; ssh 연결을 통해 통신하는 클라이언트와 서버이며, SSH 채널에 의해 사용된다. 이 모듈의 API 기능은 SSH 연결 프로토콜 이벤트를 전송하며 이는 원격 채널에서 메시지로 수신됩니다. 수신 채널이 Erlang 프로세스 인 경우 메시지의 형식은 &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 작동이 채널 프로세스를 구현하는 데 사용되는 경우 이러한 메시지는 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="29f892246d7df69546254cbfcc798654f3646997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; defines</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; 을 정의</target>
        </trans-unit>
        <trans-unit id="7dcb6a1e5d8b3f03deff03d3241d42eac28f4c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module makes it possible to map different parts of the host file system into the document tree, that is, creates aliases and redirections.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 가의 모듈은 가능하다 별칭과 리디렉션을 만들고 문서 트리로 호스트 파일 시스템의 다른 부분을 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc4b78316a4143698c35ef4043e086c3252f889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; module provides for basic user authentication using textual files, Dets databases as well as Mnesia databases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 모듈은 텍스트 파일, Dets 데이터베이스뿐만 아니라 Mnesia 데이터베이스를 사용하여 기본 사용자 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="461a1eaddbc542451f83c2ca184fe0b61bd2923e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; module implements the Erlang Server Interface (ESI) providing a tight and efficient interface to the execution of Erlang functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 모듈은 Erlang 서버 인터페이스 (ESI)를 구현하여 Erlang 함수 실행을 위한 강력 하고 효율적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="451822a0390939c5b7aa871766fbf59707a840eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; module serves as a filter for authenticated requests handled in &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt;. It provides a possibility to restrict users from access for a specified amount of time if they fail to authenticate several times. It logs failed authentication as well as blocking of users, and it calls a configurable callback module when the events occur.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; 와의 인증 요청에 대한 필터에서 처리 모듈로 제공 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; . 사용자가 여러 번 인증에 실패하면 지정된 시간 동안 사용자의 액세스를 제한 할 수 있습니다. 인증 실패 및 사용자 차단을 기록하고 이벤트가 발생하면 구성 가능한 콜백 모듈을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="41608b3a764923c262561e0c2d97e667f71e82d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; 가능한 시작 플래그의 개요 (대부분의 플래그는 해당 구성 용어를 가지고)</target>
        </trans-unit>
        <trans-unit id="8c2bdaafc19f8eda6fa7e095397c6b638b7731c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; module can be used for debugging a supervisor bridge.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 모듈 감독자 다리 디버깅을 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="1915b4761876d96adb7cfdaf20279417ba58c6b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 함수는 UDP 포트 패킷의 데몬 프로세스 듣기 시작한다. 읽기 또는 쓰기 요청을 받으면 전송을 처리하는 임시 서버 프로세스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8e817126baaf83dd2177ff4d3961b1bf92117ec3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="bac6d07dd79fabf515998a51c2c8ccd52cb9e6e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11b934f9948e4845a2b33851b5932f94d59f1d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="842d1fd61ccfd8c7f0a3b2ea51238f75d1a39f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; has examples and a &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 에는 예제와 &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7213ba1d558f14b69b4e8a3edef214d04ef9e98a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?Q&lt;/code&gt; macros turn the quoted code fragments into ASTs, and lifts metavariables such as &lt;code&gt;_@Tuple&lt;/code&gt; and &lt;code&gt;_@Number&lt;/code&gt; to the level of your Erlang code, so you can use the corresponding Erlang variables &lt;code&gt;Tuple&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</source>
          <target state="translated">&lt;code&gt;?Q&lt;/code&gt; 매크로하는 AST에 인용 된 코드 조각을 설정하고, 리프트 등 metavariables &lt;code&gt;_@Tuple&lt;/code&gt; 및 &lt;code&gt;_@Number&lt;/code&gt; 당신이 해당 얼랑 변수를 사용할 수 있도록, 당신의 얼랑 코드의 수준으로 &lt;code&gt;Tuple&lt;/code&gt; 및 &lt;code&gt;Number&lt;/code&gt; 직접. 이것은 Merl을 사용하는 가장 간단한 방법이며 많은 경우에 필요한 전부입니다.</target>
        </trans-unit>
        <trans-unit id="15c579f9adfb6704c3bcff309334cae348b5e5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?assert(Expression)&lt;/code&gt; macro will evaluate &lt;code&gt;Expression&lt;/code&gt;, and if that does not evaluate to &lt;code&gt;true&lt;/code&gt;, it will throw an exception; otherwise it just returns &lt;code&gt;ok&lt;/code&gt;. In the above example, the test will thus fail if the call to &lt;code&gt;length&lt;/code&gt; does not return 3.</source>
          <target state="translated">&lt;code&gt;?assert(Expression)&lt;/code&gt; 매크로 평가합니다 &lt;code&gt;Expression&lt;/code&gt; , 그리고 그로 평가하지 않는 경우 &lt;code&gt;true&lt;/code&gt; , 그것은 예외가 발생합니다; 그렇지 않으면 그냥 &lt;code&gt;ok&lt;/code&gt; 반환합니다 . 위 예제에서 &lt;code&gt;length&lt;/code&gt; 호출이 3을 반환하지 않으면 테스트가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="824fe9ddd06f6c4a1a05c0b0fcb9265f7a7b2017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASN.1&lt;/code&gt; application provides the following two separate user interfaces:</source>
          <target state="translated">&lt;code&gt;ASN.1&lt;/code&gt; 의 애플리케이션은 다음의 두 개의 분리 된 사용자 인터페이스를 제공한다 :</target>
        </trans-unit>
        <trans-unit id="ad1896e2fd3770f39ede02112fb63bbac81b7df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Address&lt;/code&gt; field is the second element.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; 필드는 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="e284c989131372b49e03051b62849870dd521425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to &quot;compact notation&quot;. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 형식은 &quot;소형 표기&quot;로 디코딩됩니다. &lt;strong&gt;이 옵션은 새 코드에는 권장되지 않습니다. &lt;/strong&gt;이 옵션은 옵션 &lt;code&gt;maps&lt;/code&gt; 과 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d727373c971108a708085cfa309ebdb4fa5bc28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to the legacy format, that is, a list of zeroes and ones. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 유형은 0과의 목록입니다 레거시 포맷 디코딩된다. &lt;strong&gt;이 옵션은 새 코드에는 권장되지 않습니다. &lt;/strong&gt;이 옵션은 옵션 &lt;code&gt;maps&lt;/code&gt; 과 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3c84e077a6dbf3c771cfd255a8a9895e6702d3a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bitstring&lt;/code&gt; variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default &lt;code&gt;unit&lt;/code&gt; for bitstrings is 1.</source>
          <target state="translated">&lt;code&gt;Bitstring&lt;/code&gt; 변수는 예컨대, 0, 1, 8, 11, 17, 42 등, 임의의 수의 비트들로 구성 될 수있다. 비트 열의 기본 &lt;code&gt;unit&lt;/code&gt; 는 1 이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="94a1488efe62c17d8ba98c01afd1b232f7321a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; argument indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Block&lt;/code&gt; 로그 변환시 차단해야하는 경우 인수를 나타냅니다. 큰 로그를 변환 할 때 유용합니다 (그렇지 않으면 변환 중에 로그가 랩핑 될 수있는 경우). 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ab5f211e8f18fd1c4ca859d11a5d3fcd218d631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Block&lt;/code&gt; 로그 변환시 차단해야하는 경우 옵션을 나타냅니다. 큰 로그를 변환 할 때 유용합니다 (그렇지 않으면 변환 중에 로그가 랩핑 될 수있는 경우). 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2acfbefe2ee37310ba387213e5e15aa6901a988c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Callback&lt;/code&gt; module should contain hook functions for all tags present in the data structure. A hook function must have the following format:</source>
          <target state="translated">&lt;code&gt;Callback&lt;/code&gt; 모든 태그 데이터 구조에 존재위한 모듈은 후크 함수를 포함한다. 후크 기능은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="883390db9451e13b3d5a5f85d744ec9ca06a2b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallbackMode&lt;/code&gt; is either just &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; or a list containing &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; and possibly the atom &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CallbackMode&lt;/code&gt; 는 하나 그냥 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 또는 목록 함유 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 및 가능한 원자 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e7a580d51d45e0183e4b31ffec1224002d11cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CharSpec&lt;/code&gt;&lt;code&gt;eof&lt;/code&gt; signals end of file. &lt;code&gt;LeftOverChars&lt;/code&gt; then takes the value &lt;code&gt;eof&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;CharSpec&lt;/code&gt; &lt;code&gt;eof&lt;/code&gt; 신호는 파일의 끝. &lt;code&gt;LeftOverChars&lt;/code&gt; 다음 LeftOverChars 는 &lt;code&gt;eof&lt;/code&gt; 값도 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="64d980b4c7c9584d2e8b4e055ab6694f99c89599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChildSpecs&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; is a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChildSpecs&lt;/code&gt; 의 반환 값의 변수 &lt;code&gt;init/1&lt;/code&gt; 의 목록 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5232c85e790e4f73652dc642ce50e6888594555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChunkSize&lt;/code&gt; defines the size of the &lt;code&gt;PlainBin&lt;/code&gt;s that &lt;code&gt;EncodeFun&lt;/code&gt; is applied to. If the &lt;code&gt;ChunkSize&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;ChunkSize&lt;/code&gt; is intended for block crypto. &lt;code&gt;ChunkSize&lt;/code&gt;s can be changed in the return from the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChunkSize&lt;/code&gt; 의 크기 정의 &lt;code&gt;PlainBin&lt;/code&gt; 의 그 &lt;code&gt;EncodeFun&lt;/code&gt; 에 적용됩니다. 경우] &lt;code&gt;ChunkSize&lt;/code&gt; 되는 &lt;code&gt;undefined&lt;/code&gt; 의 크기 &lt;code&gt;PlainBin&lt;/code&gt; 이것은 고정 된 반면, 스트림 암호화를 대상으로하기 때문에 S 다양 &lt;code&gt;ChunkSize&lt;/code&gt; 블록 암호화를 위해 의도된다. &lt;code&gt;ChunkSize&lt;/code&gt; 는 &lt;code&gt;EncryptFun&lt;/code&gt; 또는 &lt;code&gt;DecryptFun&lt;/code&gt; 에서 반환 될 때 변경 될 수 있습니다 . &lt;code&gt;pos_integer()&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 사이에서 값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a7a9966f0b85d64cc4feece108959a21b830fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; API does also allow you to save the collected &lt;code&gt;Events&lt;/code&gt; to file and later load them in a later session.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; API는 또한 수집 된 저장할 수 않는 &lt;code&gt;Events&lt;/code&gt; 파일을 나중에 나중에 세션을로드합니다.</target>
        </trans-unit>
        <trans-unit id="fceb8c2c1f65a97284385a3f23405d68267725fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; automatically registers itself to listen for trace &lt;code&gt;Events&lt;/code&gt;, so all you have to do is enable them.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; 자동으로 추적을 수신에 자신을 등록 &lt;code&gt;Events&lt;/code&gt; 당신이해야 할 모든이를 가능하게하므로,.</target>
        </trans-unit>
        <trans-unit id="ec20677889045987c82a0d9f6c4d053fcf85822c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; manages a key/value based dictionary, where the filters are stored. Updates of the dictionary is propagated to all subscribing processes. When a &lt;code&gt;Viewer&lt;/code&gt; is started it is registered as a subscriber of dictionary updates.</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; 필터가 저장되는 키 / 값 기반 사전을 관리합니다. 사전 업데이트가 모든 구독 프로세스에 전파됩니다. &lt;code&gt;Viewer&lt;/code&gt; 가 시작 되면 사전 업데이트의 구독자로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e368c10bff22300d3fab811f6f50a4674a69667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Framework Log page includes links to the Pre- and Post Test I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; and &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt;, as well as captured system error- and progress reports, which take place before, and after, the test run. Examples of this are printouts from a CT hook init- or terminate function, or progress reports generated when an OTP application is started from a CT hook init function. Another example is an error report generated because of a failure when an external application is stopped from a CT hook terminate function. All information in these examples ends up in the Pre- and Post Test I/O Log. For more information on how to synchronize test runs with external user applications, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그 페이지는 사전 및 사후 테스트 I / O 로그에 대한 링크가 포함되어 있습니다. 이 로그에서 &lt;code&gt;Common Test&lt;/code&gt; 는 &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 및 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 로 작성된 인쇄물을 저장합니다테스트 실행 전후에 발생한 시스템 오류 및 진행률 보고서를 캡처 할 수 있습니다. 예는 CT 후크 초기화 또는 종료 기능에서 출력되거나 OTP 응용 프로그램이 CT 후크 초기화 기능에서 시작될 때 생성 된 진행 보고서입니다. 또 다른 예는 외부 애플리케이션이 CT 후크 종료 기능에서 중지 될 때 실패로 인해 생성 된 오류 보고서입니다. 이 예제의 모든 정보는 사전 및 사후 테스트 I / O 로그에 있습니다. 테스트 실행을 외부 사용자 애플리케이션과 동기화하는 방법에 대한 자세한 정보는 공통 테스트 후크 섹션의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b15f94344ef9977a91750baa9dddf1dbad0746d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master API is exported by module &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 API는 모듈 내 보낸 &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1eb6fe3660c4d65491500f6426215f629639619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server runs on one dedicated Erlang node and uses distributed Erlang to communicate with any number of &lt;code&gt;Common Test&lt;/code&gt; test nodes, each hosting a regular &lt;code&gt;Common Test&lt;/code&gt; server. Test specifications are used as input to specify what to test on which test nodes, using what configuration.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 서버 하나 개의 전용 얼랑 노드에서 실행 및 사용은 임의의 수와 통신 할 수 얼랑 분산 &lt;code&gt;Common Test&lt;/code&gt; 테스트 노드, 각 호스팅 일반 &lt;code&gt;Common Test&lt;/code&gt; 서버. 테스트 스펙은 어떤 구성을 사용하여 어떤 테스트 노드에서 테스트 할 대상을 지정하는 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d910e14beb83938480f0c5db0900211c5bc5ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server writes progress information to HTML log files similarly to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The logs contain test statistics and links to the log files written by each independent &lt;code&gt;Common Test&lt;/code&gt; server.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 마스터 서버는 유사하게 일반에 HTML 로그 파일에 진행 정보를 기록 &lt;code&gt;Common Test&lt;/code&gt; 서버. 로그에는 테스트 통계 및 각 독립 &lt;code&gt;Common Test&lt;/code&gt; 서버가 작성한 로그 파일에 대한 링크가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e124139583e4b5d8918f07bb2c0c03bd8d6c703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application also includes other modules named &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt;, which provide various support, mainly simplified use of communication protocols such as RPC, SNMP, FTP, Telnet, and others.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 애플리케이션 명명 된 다른 모듈 포함 &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt; 다양한 지원 등 RPC, SNMP, FTP, 텔넷 등과 같은 통신 프로토콜의 간략화 주로 사용을 제공한다.</target>
        </trans-unit>
        <trans-unit id="03a84fce685f88578ce41de6a729049cb8fac0fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application is installed with the Erlang/OTP system. No extra installation step is required to start using &lt;code&gt;Common Test&lt;/code&gt; through the &lt;code&gt;ct_run&lt;/code&gt; executable program, and/or the interface functions in the &lt;code&gt;ct&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 응용 프로그램은 얼랑 / OTP 시스템에 설치됩니다. &lt;code&gt;ct_run&lt;/code&gt; 실행 프로그램 및 / 또는 &lt;code&gt;ct&lt;/code&gt; 모듈 의 인터페이스 기능을 통해 &lt;code&gt;Common Test&lt;/code&gt; 사용을 시작하기 위해 추가 설치 단계가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78a22725d0c7f0f676d4ba2a90661e795ebb56c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is a tool that supports implementation and automated execution of test cases to any types of target systems. &lt;code&gt;Common Test&lt;/code&gt; is the main tool being used in all testing- and verification activities that are part of Erlang/OTP system development and maintenance.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 구현 및 대상 시스템의 유형 테스트 케이스의 자동 실행을 지원하는 도구입니다. &lt;code&gt;Common Test&lt;/code&gt; 는 Erlang / OTP 시스템 개발 및 유지 관리의 일부인 모든 테스트 및 검증 활동에 사용되는 주요 도구입니다.</target>
        </trans-unit>
        <trans-unit id="18e9917f7eb0c975fe2d0bf461322b555cc56962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is an environment for implementing and performing automatic and semi-automatic execution of test cases.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 워크 구현 및 테스트 케이스 자동 및 반자동 실행을 수행하는 환경이다.</target>
        </trans-unit>
        <trans-unit id="c32a30ee7b6005326d0a472ffa1a54f5ce95df96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework provides a high-level operator interface for testing, providing the following features:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크는 다음과 같은 기능을 테스트하는 제공하는 높은 수준의 운영자 인터페이스를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="ad9b65cad13beffef2e82d575de6699dcf88a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; test server requires that the test suite defines and exports the following mandatory or optional callback functions:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 테스트 서버가 요구하는 테스트 스위트를 정의하고 수출 다음과 같은 필수 또는 선택적 콜백 기능 :</target>
        </trans-unit>
        <trans-unit id="b3f5974325a1f6adb2e7a53fd6b80b396429c849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database is now initialized and contains data.</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스는 이제 초기화와 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="84399fbfc3c32ddc0958865c1bc7e66e07f291b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database, introduced in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, has three tables that store records (&lt;code&gt;employee&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, &lt;code&gt;project&lt;/code&gt;), and three tables that store relationships (&lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, &lt;code&gt;in_proj&lt;/code&gt;). This is a normalized data model, which has some advantages over a non-normalized data model.</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 에 도입 데이터베이스, &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; , 세 개의 테이블이 저장하는 기록 ( &lt;code&gt;employee&lt;/code&gt; , &lt;code&gt;dept&lt;/code&gt; , &lt;code&gt;project&lt;/code&gt; ), 그리고 세 개의 표를 저장하는 관계 ( &lt;code&gt;manager&lt;/code&gt; , &lt;code&gt;at_dep&lt;/code&gt; , &lt;code&gt;in_proj&lt;/code&gt; ). 이것은 정규화 된 데이터 모델이며 비정규 화 된 데이터 모델에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4167561d4c9786e75acf722fa5255d76e1f375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ControlMessage&lt;/code&gt; is a tuple, where the first element indicates which distributed operation it encodes:</source>
          <target state="translated">&lt;code&gt;ControlMessage&lt;/code&gt; 는 첫번째 요소가 분산되는 인코딩 동작을 나타내는 튜플이다 :</target>
        </trans-unit>
        <trans-unit id="b53e02a747463b517e8ec15e14ceddfb049c6d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DAT&lt;/code&gt; files must always be opened with option &lt;code&gt;{repair, false}&lt;/code&gt;. This ensures that these files are not automatically repaired. Without this option, the database can become inconsistent, because &lt;code&gt;Mnesia&lt;/code&gt; can believe that the files were properly closed. For information about configuration parameter &lt;code&gt;auto_repair&lt;/code&gt;, see the Reference Manual.</source>
          <target state="translated">&lt;code&gt;DAT&lt;/code&gt; 의 파일은 항상 옵션을 열어야합니다 &lt;code&gt;{repair, false}&lt;/code&gt; . 이렇게하면 이러한 파일이 자동으로 복구되지 않습니다. 이 옵션을 사용하지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 가 파일이 올바르게 닫 혔음 을 믿을 수 있으므로 데이터베이스가 일치하지 않을 수 있습니다. 구성 매개 변수 &lt;code&gt;auto_repair&lt;/code&gt; 에 대한 정보 는 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5873af1928aed9c59ec2db4bf69bcbdd1c33d63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Data&lt;/code&gt; received can be a &lt;code&gt;binary()&lt;/code&gt; or a &lt;code&gt;list()&lt;/code&gt; of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP event.</source>
          <target state="translated">수신 된 &lt;code&gt;Data&lt;/code&gt; 는 소켓 모드 또는 SCTP 이벤트에 따라 &lt;code&gt;binary()&lt;/code&gt; 또는 바이트 &lt;code&gt;list()&lt;/code&gt; 0-255 범위의 정수) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f5b6911daa714868434e1a90189319187674c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DbgExtra&lt;/code&gt; options are described in section &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DbgExtra&lt;/code&gt; 의 옵션이 절에서 설명하는 &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16f5677b6ef24617d1e07a7aa94edc055731eaee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DiscoHandler&lt;/code&gt; module is used during the discovery process. See &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;DiscoHandler&lt;/code&gt; 의 모듈은 검색 프로세스 동안 사용된다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="510046e751218ed5f95a1059673c4d8fbf2a7fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dst&lt;/code&gt; map is updated with new channel values. The syntax for updating an existing key with a new value is with the &lt;code&gt;:=&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;Dst&lt;/code&gt; 지도는 새로운 채널 값으로 업데이트됩니다. 기존 키를 새로운 값으로 업데이트하는 구문은 &lt;code&gt;:=&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="d0e5af70acd62ed71f0140803a094eed25236db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">&lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 의 용어 유형으로 인코딩되는 용어 전달에 사용되는 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 이다 의해 부호화 된 용어 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; 등을. 예를 들어, &lt;code&gt;binp&lt;/code&gt; 에 대한 포인터입니다 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 용어가 들어 &lt;code&gt;{17, 4711}&lt;/code&gt; 로 인코딩 된 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; , 당신은 태그와 두 튜플에 포장 할 &lt;code&gt;my_tag&lt;/code&gt; 이며, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; 이면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0ac01302ce56a5538e783afbe86c0e3ca92aac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; term is a way to construct strings. It works differently from how &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; works. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; builds a string list in reverse order (as opposed to how &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; works), concatenating the strings added to a list. The tail must be specified before &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 의 용어는 문자열을 구성하는 방법입니다. &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; 의 작동 방식과 다르게 작동합니다. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 는 목록에 추가 된 문자열을 연결하여 문자열 목록을 역순으로 작성합니다 ( &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 작동 방식과 반대 ). 꼬리는 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 전에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe5603a0b688982ee095c5b6eb8b3abf301f57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_UINT&lt;/code&gt;, &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt;, and &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term types were introduced in ERTS 5.6.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_UINT&lt;/code&gt; , &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 및 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 의 용어 유형은 ERTS 5.6에 소개되었다.</target>
        </trans-unit>
        <trans-unit id="78c7a39595ca5fe9252d32999a603c6e910dd570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable can be used to store the complicated parameters in:</source>
          <target state="translated">&lt;code&gt;ERL_FLAGS&lt;/code&gt; 의 환경 변수에 복잡한 매개 변수를 저장하는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0a3584a359b0427b176ceaff9674304e574ffce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Emakefile&lt;/code&gt; (if it exists) in the current directory is searched for compiler options for each module. If a given module does not exist in &lt;code&gt;Emakefile&lt;/code&gt; or if &lt;code&gt;Emakefile&lt;/code&gt; does not exist, the module is still compiled.</source>
          <target state="translated">현재 디렉토리 의 &lt;code&gt;Emakefile&lt;/code&gt; (있는 경우)에서 각 모듈의 컴파일러 옵션을 검색합니다. 지정된 모듈이 &lt;code&gt;Emakefile&lt;/code&gt; 에 없거나 &lt;code&gt;Emakefile&lt;/code&gt; 이없는 경우 모듈은 여전히 ​​컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="da28c7ffe618c58fd36df47a840c22abe8ebdbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encoding&lt;/code&gt; says how the characters in the request are represented. We want to store the characters as lists in the ETS table, so we convert them to lists using function &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt;. The conversion function conveniently accepts the encoding types &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;latin1&lt;/code&gt;, so we can use &lt;code&gt;Encoding&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; 요청의 문자를 표현하는 방법을 말한다. 문자를 ETS 테이블에 목록으로 저장하려고하므로 &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt; 함수를 사용하여 문자 를 목록으로 변환합니다 . 변환 함수는 &lt;code&gt;unicode&lt;/code&gt; 및 &lt;code&gt;latin1&lt;/code&gt; 인코딩 유형을 편리하게 받아들이 므로 &lt;code&gt;Encoding&lt;/code&gt; 을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c694d3baa325d31ca5ef434295459f7fd84d35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvBinary&lt;/code&gt; structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when &lt;code&gt;driver_binary_free&lt;/code&gt; is called, the reference count is decremented, when it reaches zero, the binary is deallocated. &lt;code&gt;orig_size&lt;/code&gt; is the binary size and &lt;code&gt;orig_bytes&lt;/code&gt; is the buffer. &lt;code&gt;ErlDrvBinary&lt;/code&gt; has not a fixed size, its size is &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlDrvBinary&lt;/code&gt; 에뮬레이터와 드라이버 사이에서 전송로 구조는 바이너리이다. 모든 바이너리는 참조 카운트됩니다. 경우 &lt;code&gt;driver_binary_free&lt;/code&gt; 가 호출, 기준 카운트가 0이되면, 이진가 해제되어, 감소된다. &lt;code&gt;orig_size&lt;/code&gt; 는 이진 크기이고 &lt;code&gt;orig_bytes&lt;/code&gt; 는 버퍼입니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 크기는 고정되어 있지 않으며 크기는 &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c86b87f3b0b95eba095182c55f0fcc45cc6647fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvNowData&lt;/code&gt; structure holds a time stamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</source>
          <target state="translated">&lt;code&gt;ErlDrvNowData&lt;/code&gt; 의 구조는 과거에 어떤 임의의 지점에서 측정 한 세 값으로 이루어지는 타임 스탬프를 보유하고있다. 세 가지 구조 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89f846aa2a9d3bbb835eaa5c58e3ac257c0f2247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">&lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 의 구조 얼랑 런타임 시스템에 대한 정보의 저장을 위해 사용된다. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 구조에 대한 참조를 전달할 때 시스템 정보를 기록합니다 . 구조의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a097b8521d625c64b18dfa0ef6d0bb28ad84fb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library contains functions that help you integrate programs written in C and Erlang. The functions in &lt;code&gt;Erl_Interface&lt;/code&gt; support the following:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 라이브러리는 C와 얼랑로 작성된 프로그램을 통합 할 수 있도록 기능이 포함되어 있습니다. &lt;code&gt;Erl_Interface&lt;/code&gt; 의 기능 은 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c0bb8f936d4589865a80fe604ad9b594bedb70df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 의 라이브러리는이 활동을 지원합니다. Erlang 데이터 구조를 작성하고 조작하는 여러 C 함수가 있습니다. 라이브러리에는 인코딩 및 디코딩 기능도 포함되어 있습니다. 다음 예제는 Erlang 튜플 &lt;code&gt;{tobbe,3928}&lt;/code&gt; 을 만들고 인코딩하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="57a4e297c09c6f1e5049ba6a6a04c4f9715c1746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorDesc&lt;/code&gt; returned is an opaque value to be passed further on to function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. For more control over the operation, use the &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">반환 된 &lt;code&gt;ErrorDesc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 추가로 전달 될 불투명 한 값 입니다. 조작을 더 제어하려면 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a7a560a95e6aefba3bb607f84b70fa45da9fcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned earlier is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure, which is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; 앞서 언급 한 표준 &lt;code&gt;ErrorInfo&lt;/code&gt; 모든 I / O 모듈로부터 리턴 구조. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46cd6a74f6ad42247387aa8b77c1e43606850bb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned in this module is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure that is returned from all I/O modules. It has the following format:</source>
          <target state="translated">&lt;code&gt;ErrorInfo&lt;/code&gt; 이 모듈에서 언급 된 표준 &lt;code&gt;ErrorInfo&lt;/code&gt; 모든 I / O 모듈로부터 리턴 구조. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93b9c6c6a8848b5cb82997ba3624a2f0fabf1b76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Records&lt;/code&gt; in the Ets table are ordered by their timestamp. Which timestamp that should be used is controlled via the &lt;code&gt;event_order&lt;/code&gt; parameter. Default is &lt;code&gt;trace_ts&lt;/code&gt; which means the time when the trace data was generated. &lt;code&gt;event_ts&lt;/code&gt; means the time when the trace data was parsed (transformed into an &lt;code&gt;Event Record&lt;/code&gt;).</source>
          <target state="translated">Ets 테이블 의 &lt;code&gt;Event Records&lt;/code&gt; 는 타임 스탬프별로 정렬됩니다. 사용해야하는 타임 스탬프는 &lt;code&gt;event_order&lt;/code&gt; 매개 변수 를 통해 제어됩니다 . 기본값은 &lt;code&gt;trace_ts&lt;/code&gt; 이며 추적 데이터가 생성 된 시간을 의미합니다. &lt;code&gt;event_ts&lt;/code&gt; 는 추적 데이터가 구문 분석 된 ( &lt;code&gt;Event Record&lt;/code&gt; 로 변환 된) 시간을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="78b79ae16c44e1321dea0365d3ec779b8f949891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses named filters in various contexts. An Event Trace filter is an &lt;code&gt;Erlang fun&lt;/code&gt; that takes some trace data as input and returns a possibly modified version of it:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 다양한 상황에서 필터를 이름을 사용합니다. 이벤트 추적 필터는 일부 추적 데이터를 입력으로 사용하고 가능한 수정 된 버전을 리턴 하는 &lt;code&gt;Erlang fun&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="272a43aecd37d28c1a13622b7271bed26dc65387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 수집 및 추적 데이터의 그래픽보기를 위해 얼랑에 추적 장치 내장 및 제공 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7b3f5424185756e71f4988bcc6cd871d1c3dd01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expire&lt;/code&gt; time indicates for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">&lt;code&gt;Expire&lt;/code&gt; 시간 (이후 관리자가 삭제 무료입니다) 요청의 유효 기간에 대한 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e6c34cadce8690c6e2555787337ac8b727e225e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extra&lt;/code&gt; 파라미터로 필터를 추가 할 때 지정 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="229acf43839cafb043149ab1533fb570fa7aafb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;domain/2&lt;/code&gt; 함수에 대한 &lt;code&gt;Extra&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 를 통해 필터를 추가 할 때 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="52e94c11f02389a5bccbbedf86c2e899b3c665d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraArgument&lt;/code&gt; parameter is the empty list. For example, when the agent receives a get-request for the &lt;code&gt;ipAdr&lt;/code&gt; variable, a call will be made to &lt;code&gt;ip_access(get)&lt;/code&gt;. The value returned by this function is the answer to the get-request.</source>
          <target state="translated">&lt;code&gt;ExtraArgument&lt;/code&gt; 의 매개 변수는 빈 목록입니다. 예를 들어, 에이전트가 &lt;code&gt;ipAdr&lt;/code&gt; 변수에 대한 get-request를 받으면 &lt;code&gt;ip_access(get)&lt;/code&gt; 가 호출됩니다 . 이 함수에 의해 반환되는 값은 get-request에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="fb7a37656b5be6c6e17b2389894ea550dae8ed86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on from the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; 를의 인수는에서 전달되는 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="f30e53e02c0d2cd4e451fab992fbc868cf17c42e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on to the callback functions of the &lt;code&gt;DiscoHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExtraInfo&lt;/code&gt; 를의 인수는의 콜백 함수에 전달됩니다 &lt;code&gt;DiscoHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="289abc6fff4535554475e47566270dcbf6237037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Freeze&lt;/code&gt; button starts/stops the redrawing of the graph. &lt;code&gt;Reset&lt;/code&gt; moves the graph to the middle of the window and resets all graph settings to default, with the exception of deleted nodes.</source>
          <target state="translated">&lt;code&gt;Freeze&lt;/code&gt; 버튼 착공 / 그래프의 재기록을 멈춘다. &lt;code&gt;Reset&lt;/code&gt; 은 그래프를 창 가운데로 이동하고 삭제 된 노드를 제외하고 모든 그래프 설정을 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="bb27036c1560c4a25ff7bd106092a75ea724c349" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserPrivate&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 타르 기능이 파일에 블록을 기록처럼 낮은 수준의 작업을 할 경우에 불려갑니다. &lt;code&gt;Fun&lt;/code&gt; 라고한다 &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt; , &lt;code&gt;Op&lt;/code&gt; 연산 이름은이 &lt;code&gt;UserPrivate&lt;/code&gt; 가 에 첫 번째 인수로서 건네 용어 &lt;code&gt;init/1&lt;/code&gt; 과 &lt;code&gt;Parameters...&lt;/code&gt; 데이터가 추가되고 tar 함수는 저장 처리 기능으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5d186993003ed1ccd81976e2681cc3264ce79a2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as &lt;code&gt;add/3&lt;/code&gt;, &lt;code&gt;add/4&lt;/code&gt;, and &lt;code&gt;close/1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 다른 스토리지 동작 기능 함수 처리 높은 타르로부터 호출 될 때 수행 할 작업의 정의 (예로서 &lt;code&gt;add/3&lt;/code&gt; , &lt;code&gt;add/4&lt;/code&gt; 및 &lt;code&gt;close/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca0ec970a34ee33c7f128926a1e15f48a39b7957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;foldl/3&lt;/code&gt; returns the final accumulator value. &lt;code&gt;Acc0&lt;/code&gt; is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 다음 호출에 전달되는 새로운 축적을 반환해야합니다. &lt;code&gt;foldl/3&lt;/code&gt; 는 최종 누산기 값을 반환합니다. 아카이브가 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. 아카이브의 모든 파일을 반복 할 필요는 없습니다. 예외를 발생시켜 제어 된 방식으로 반복을 조기에 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="387a945d1ef3c3c3d8058c83966af63af2d4d8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt; section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang:</source>
          <target state="translated">&lt;code&gt;Guard&lt;/code&gt; 섹션은 다음 보호 시험 얼랑에 기록되도록, 로직 및 보호 시험 (접두사 표기)와 같은 구문 기록 연산을 포함 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="0ed2562e6fd2d312da06422aef22e77ebef5ba9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt;s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &lt;code&gt;'$1'&lt;/code&gt;, one would write the test as &lt;code&gt;{is_list, '$1'}&lt;/code&gt;. If the test fails, the object in the table does not match and the next &lt;code&gt;MatchFunction&lt;/code&gt; (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed &lt;code&gt;is_&lt;/code&gt; are allowed (&lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_atom&lt;/code&gt;, and so on).</source>
          <target state="translated">&lt;code&gt;Guard&lt;/code&gt; 들 첫 번째 요소는 시험 이름이고 나머지 요소는 테스트 파라미터이다 튜플로 구성된다. 일치 변수 &lt;code&gt;'$1'&lt;/code&gt; 바인딩 된 요소의 특정 유형 (예 : 목록)을 확인하기 위해 테스트를 &lt;code&gt;{is_list, '$1'}&lt;/code&gt; 합니다. 테스트가 실패하면 테이블의 오브젝트가 일치하지 않고 다음 &lt;code&gt;MatchFunction&lt;/code&gt; (있는 경우)이 시도됩니다. 얼랑에 존재하는 대부분의 가드 검사는 사용할 수 있지만 새로운 버전은 접두사 &lt;code&gt;is_&lt;/code&gt; (허용 &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_atom&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="3de2a50d3651924af28c65d29b6c75e407eb8165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HTTP&lt;/code&gt; version of the request, that is, &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;.</source>
          <target state="translated">요청 의 &lt;code&gt;HTTP&lt;/code&gt; 버전, 즉 &quot;HTTP / 0.9&quot;, &quot;HTTP / 1.0&quot;또는 &quot;HTTP / 1.1&quot;</target>
        </trans-unit>
        <trans-unit id="462a5eb6a4e1b7237b73c6e94eed8c647d921612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostName&lt;/code&gt; will also be used in the hostname verification of the peer certificate using &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HostName&lt;/code&gt; 도 사용 피어 인증서의 호스트 이름 검증에 사용됩니다 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fe5414d8d8a859939f8d4935fe18c2a11ba8b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Id&lt;/code&gt; identifies a CTH instance uniquely. If two CTHs return the same &lt;code&gt;Id&lt;/code&gt;, the second CTH is ignored and subsequent calls to the CTH are only made to the first instance. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Id&lt;/code&gt; 고유 CTH 인스턴스를 식별합니다. 두 개의 CTH가 동일한 &lt;code&gt;Id&lt;/code&gt; 를 리턴하면 두 번째 CTH는 무시되고 CTH에 대한 후속 호출은 첫 번째 인스턴스에만 수행됩니다. 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c260809e9afd9c349ba39adc0e706099bd4227f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InclNodes&lt;/code&gt; argument to &lt;code&gt;run/3&lt;/code&gt; is a list of node names. Function &lt;code&gt;run/3&lt;/code&gt; runs the tests in &lt;code&gt;TestSpecs&lt;/code&gt; just like &lt;code&gt;run/1&lt;/code&gt;, but also takes any test in &lt;code&gt;TestSpecs&lt;/code&gt;, which is not explicitly tagged with a particular node name, and execute it on the nodes listed in &lt;code&gt;InclNodes&lt;/code&gt;. By using &lt;code&gt;run/3&lt;/code&gt; this way, any test specification can be used, with or without node information, in a large-scale test environment.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 의 &lt;code&gt;InclNodes&lt;/code&gt; 인수 는 노드 이름 목록입니다. &lt;code&gt;run/3&lt;/code&gt; 함수 는 &lt;code&gt;run/1&lt;/code&gt; 과 같이 &lt;code&gt;TestSpecs&lt;/code&gt; 에서 테스트를 실행 하지만 &lt;code&gt;TestSpecs&lt;/code&gt; 에서 테스트를 수행합니다. TestSpecs 에서는 특정 노드 이름으로 명시 적으로 태그가 지정되지 않은 상태에서 &lt;code&gt;InclNodes&lt;/code&gt; 에 나열된 노드에서 테스트를 실행합니다 . 사용하여 &lt;code&gt;run/3&lt;/code&gt; 이런 식으로, 어떤 테스트 사양은 대규모 테스트 환경에서, 또는 노드 정보없이 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="728f2fde5e1be51dec6dbadf7fd8bb23ae8a8436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InfoTuple&lt;/code&gt;s with the following items are part of the result:</source>
          <target state="translated">다음 항목이 포함 된 &lt;code&gt;InfoTuple&lt;/code&gt; 은 결과의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="18a616360c14e89869b3ee8a191e8982efcb7c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InitFun&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The returned &lt;code&gt;CryptoState&lt;/code&gt; is then folded into repeated applications of the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the &lt;code&gt;CloseFun&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;CloseFun&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">&lt;code&gt;InitFun&lt;/code&gt; 는 임의의 다른 이전에 한번 적용되는 &lt;code&gt;crypto&lt;/code&gt; 동작. 리턴 된 &lt;code&gt;CryptoState&lt;/code&gt; 는 &lt;code&gt;EncryptFun&lt;/code&gt; 또는 &lt;code&gt;DecryptFun&lt;/code&gt; 의 반복 된 애플리케이션으로 접 힙니다 . 해당 기능에서 반환 된 바이너리는 원격 SFTP 서버로 더 전송됩니다. 마지막으로 암호화를 수행하면 &lt;code&gt;CloseFun&lt;/code&gt; 이 마지막 데이터에 적용됩니다. &lt;code&gt;CloseFun&lt;/code&gt; 은 마지막 부분의 패딩 (필요한 경우) 및 암호화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f831068a66059cf58bd10807a62c5026adc8c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; 는 (상위 디렉토리)에있는 디렉토리에 다음과 같이 스크립트는 현재 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="151c25d0c87229840b1a357c4265bc6b194406ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script used when installing Erlang/OTP requires common Unix tools such as &lt;code&gt;sed&lt;/code&gt; to be present in your &lt;code&gt;$PATH&lt;/code&gt;. If your target system does not have such tools, you need to run the &lt;code&gt;Install&lt;/code&gt; script on your build machine before packaging Erlang/OTP. The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">&lt;code&gt;Install&lt;/code&gt; 얼랑 / OTP를 설치할 때 사용되는 스크립트와 같은 일반적인 유닉스 도구를 필요로 &lt;code&gt;sed&lt;/code&gt; 당신에 존재하는 &lt;code&gt;$PATH&lt;/code&gt; . 대상 시스템에 이러한 도구가없는 경우 Erlang / OTP를 패키징하기 전에 빌드 시스템 에서 &lt;code&gt;Install&lt;/code&gt; 스크립트 를 실행해야합니다 . &lt;code&gt;Install&lt;/code&gt; 는 (상위 디렉토리)에있는 디렉토리에 다음과 같이 스크립트는 현재 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="63ceadf10aefd8db61da0846c16f50dd4c57bf68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Issuer&lt;/code&gt; argument contains the issuer name of the certificate to be checked. Normally the returned CRL should be issued by this issuer, except if the &lt;code&gt;cRLIssuer&lt;/code&gt; field of &lt;code&gt;DistributionPoint&lt;/code&gt; has a value, in which case that value should be used instead.</source>
          <target state="translated">&lt;code&gt;Issuer&lt;/code&gt; 인수는 인증서 발급자의 이름을 확인하기 위해 포함되어 있습니다. 일반적으로 반환 된 CRL은 &lt;code&gt;DistributionPoint&lt;/code&gt; 의 &lt;code&gt;cRLIssuer&lt;/code&gt; 필드에 값이있는 경우를 제외하고이 발행자가 발행해야합니다.이 경우 해당 값을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1df86fa6a13d4782f56f4b70368193619f74ccce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JCL&lt;/code&gt; commands have the following meaning:</source>
          <target state="translated">&lt;code&gt;JCL&lt;/code&gt; 의 명령은 다음과 같은 의미를 갖는다 :</target>
        </trans-unit>
        <trans-unit id="eb0d6b265bbd8a2ede63c784c4e76e0b9b25a09c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; setting are to be consistent with what the terminal is capable of. There is no portable way for Erlang to ask the terminal about its UTF-8 capacity, we have to rely on the language and character type settings.</source>
          <target state="translated">&lt;code&gt;LANG&lt;/code&gt; 또는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 의 설정은 단말이 가능한 것과 일치한다. Erlang이 터미널에 UTF-8 용량을 물어볼 수있는 휴대용 방법은 없습니다. 언어 및 문자 유형 설정에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dcd5eb8b8d30040b44118c19bb40f40ac2fd675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lin&lt;/code&gt; (&lt;code&gt;LLin&lt;/code&gt;, &lt;code&gt;XLin&lt;/code&gt;) operator assigns the lines where calls (local calls, external calls) are made. The &lt;code&gt;ELin&lt;/code&gt; operator assigns to each call (From, To), for which it is defined, every line L such that there is a chain of calls from From to To beginning with a call on line L.</source>
          <target state="translated">&lt;code&gt;Lin&lt;/code&gt; ( &lt;code&gt;LLin&lt;/code&gt; , &lt;code&gt;XLin&lt;/code&gt; ) 연산자 양수인 전화 (지역 전화, 외부 호출)에 만들어지는 선. &lt;code&gt;ELin&lt;/code&gt; 값이 정의되는 (에,에서) 각각의 호출로부터 내지 L. 라인의 통화로 시작 호출 체인이되도록 각 라인 L에 대입 연산자</target>
        </trans-unit>
        <trans-unit id="ddd6ecd801eba0297210dd779a386d2f9b34f307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListOfExtraArguments&lt;/code&gt; can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, &lt;code&gt;ipAdr&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt;, which will be in the MIB. The functions could be specified in a text file as follows:</source>
          <target state="translated">&lt;code&gt;ListOfExtraArguments&lt;/code&gt; 는 일반적인 함수를 작성하는 데 사용할 수 있습니다. 이 목록은 각 함수의 표준 인수에 추가됩니다. 개체 식별자가 각각 1.1.23.4 및 1.1.7 인 장치에 대해 &lt;code&gt;ipAdr&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 이라는 두 가지 읽기 전용 변수를 고려하십시오 . 이러한 변수에 액세스하기 위해 MIB에 있는 두 개의 Erlang 함수 &lt;code&gt;ip_access&lt;/code&gt; 및 &lt;code&gt;name_access&lt;/code&gt; 를 구현할 수 있습니다. 함수는 텍스트 파일에서 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1503197789ab51916ae2782b9a6115c1230e790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; argument will be the same as the &lt;code&gt;Listen&lt;/code&gt; handle part of the return value of the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback above. &lt;code&gt;accept/1&lt;/code&gt; is called only once when the distribution protocol is started.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; (가)로 인수가 동일합니다 &lt;code&gt;Listen&lt;/code&gt; 의 반환 값의 손잡이 부분 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 위의 콜백을. 분배 프로토콜이 시작될 때 &lt;code&gt;accept/1&lt;/code&gt; 이 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="431a15a498450f82a9cfae588ffa70427314b380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoadOrder&lt;/code&gt; priority is by default &lt;code&gt;0&lt;/code&gt; (zero) but can be set to any integer. The tables with the highest &lt;code&gt;LoadOrder&lt;/code&gt; priority are loaded first at startup.</source>
          <target state="translated">&lt;code&gt;LoadOrder&lt;/code&gt; 의 우선 순위는 디폴트로 &lt;code&gt;0&lt;/code&gt; (영)하지만, 정수로 설정할 수 있습니다. &lt;code&gt;LoadOrder&lt;/code&gt; 우선 순위가 가장 높은 테이블이 시작시 먼저로드됩니다.</target>
        </trans-unit>
        <trans-unit id="6ca1036527f7b7c9ab7ab8a36cae20db5fe67ec0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; configuration was as follows:</source>
          <target state="translated">&lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 는 다음과 같이 구성되었다 :</target>
        </trans-unit>
        <trans-unit id="d517f2a191b0a2929a426e74c5d9977a2a92791e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MIB.Object&lt;/code&gt; syntax is not implemented (since all objects must be unique anyway).</source>
          <target state="translated">&lt;code&gt;MIB.Object&lt;/code&gt; 의 (모든 개체에 고유 어쨌든해야하기 때문에) 구문은 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="636dca28dbd87863b36f206b257464a2e654c483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Max Carrier size&lt;/code&gt; column shows the maximum value seen by observer since the last node change or since the start of the application, i.e. switching nodes will reset the max column. Values are sampled so higher values may have existed than what is shown.</source>
          <target state="translated">&lt;code&gt;Max Carrier size&lt;/code&gt; 칼럼 쇼 마지막 노드 변화 이후 또는 프로그램의 시작 이후, 관찰자가 볼의 최대 값, 즉 스위칭 노드는 최대 열을 재설정한다. 값이 샘플링되어 표시된 값보다 높은 값이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6e05d560929a4a9cfa001cecdf62f1726f815c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the &lt;code&gt;Mnesia&lt;/code&gt; DBMS transaction system is not suitable for hard real-time applications. However, &lt;code&gt;Mnesia&lt;/code&gt; contains other features that have real-time properties.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 프로그래머는 실행 대기중인 다른 트랜잭션 전에 실행 한 특정 거래의 우선 순위를 할 수 없다. 결과적으로 &lt;code&gt;Mnesia&lt;/code&gt; DBMS 트랜잭션 시스템은 하드 실시간 애플리케이션에는 적합하지 않습니다. 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 에는 실시간 속성이있는 다른 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2398df613eed0972c6702e33c30169f57db4a6c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; record identifiers (&lt;code&gt;{Tab, Key}&lt;/code&gt;) can also be used as references. In this case, attribute &lt;code&gt;dept&lt;/code&gt; would be set to value &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; instead of &lt;code&gt;'B/SFR'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 기록 식별자 ( &lt;code&gt;{Tab, Key}&lt;/code&gt; )도 참조로 사용할 수 있습니다. 이 경우, 속성 &lt;code&gt;dept&lt;/code&gt; 값으로 설정된다 &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; 대신 &lt;code&gt;'B/SFR'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90246ca10a3686ec4547ee9155bf07c76827f547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 거래 시스템은 다음과 같은 중요한 특성을 제공하여 신뢰성, 분산 시스템의 구축을 용이 :</target>
        </trans-unit>
        <trans-unit id="05c05e9d6716d8728951521a8360d9cad3bf485c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transactions have four important properties, called &lt;strong&gt;A&lt;/strong&gt;tomicity, &lt;strong&gt;C&lt;/strong&gt;onsistency, &lt;strong&gt;I&lt;/strong&gt;solation, and &lt;strong&gt;D&lt;/strong&gt;urability (ACID). These properties are described in the following sections.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 거래는 네 가지 중요한 속성이라고해야 &lt;strong&gt;의&lt;/strong&gt; tomicity, &lt;strong&gt;C의&lt;/strong&gt; onsistency, &lt;strong&gt;I의&lt;/strong&gt; solation 및 &lt;strong&gt;D의&lt;/strong&gt; 가능성에 의한 (ACID)를. 이러한 속성은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="34969f65d94bd140bef4861a2be0633f1edd4059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Module:callback_mode()&lt;/code&gt; function may also return a list containing the callback mode and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; are activated for the callback mode.</source>
          <target state="translated">&lt;code&gt;Module:callback_mode()&lt;/code&gt; 함수는 콜백 모드와 원자 함유리스트 반환 할 &lt;code&gt;state_enter&lt;/code&gt; 경우있는 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; 콜백 모드가 활성화된다.</target>
        </trans-unit>
        <trans-unit id="40a0e269f3ccc50144dceff290b7ec1e5d3d30c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; 하나 바이너리 &quot;일반 텍스트&quot;데이터 또는 그것은 즉, 소화 &quot;일반 텍스트&quot;의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="aa7575828f011f723e11b39b2169db4b9db4b1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">&lt;code&gt;Msg&lt;/code&gt; 하나 서명 할 수있는 바이너리 &quot;일반 텍스트&quot;데이터 또는 그것은 즉, 소화 &quot;일반 텍스트&quot;의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="caed8c29d6ad9904a92815ee1e45441de9aec981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; parameters have exactly the same meaning as when calling the plain function &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 과 &lt;code&gt;Path&lt;/code&gt; 매개 변수는 일반 함수를 호출 할 때와 정확히 같은 의미가 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27916491cb8658a94525ccdce76cf8ccb4103b9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; field is the first element of the tuple.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 필드는 튜플의 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3ca819160319b409a2f4c421438e5784e6c81c13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; specified is to correspond to the filename of the dynamically loadable object file residing in the directory specified as &lt;code&gt;Path&lt;/code&gt;, but &lt;strong&gt;without&lt;/strong&gt; the extension (that is, &lt;code&gt;.so&lt;/code&gt;). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as Erlang module names correspond to the names of the &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 으로 지정된 디렉토리에있는 동적으로로드 가능한 오브젝트 파일의 파일 이름에 해당하는 지정된 &lt;code&gt;Path&lt;/code&gt; ,하지만 &lt;strong&gt;하지 않고&lt;/strong&gt; (즉, 확장 &lt;code&gt;.so&lt;/code&gt; ). 드라이버 초기화 루틴에서 제공되는 드라이버 이름은 파일 이름과 일치해야합니다. Erlang 모듈 이름이 &lt;code&gt;.beam&lt;/code&gt; 파일 이름과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a8577668ea7b4d3a7d25c6ddf13c9da38e01e030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegotiationTimeout&lt;/code&gt; is in milli-seconds. The default value is &lt;code&gt;infinity&lt;/code&gt;. For connection timeout, use the option &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NegotiationTimeout&lt;/code&gt; 는 밀리 초입니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다. 연결 시간 종료의 경우 &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25cf803e685b877b848b6e92d88b9c3e6c3210a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is an important type and it is widely used within different standards to identify various objects uniquely. Dubuisson: ASN.1 - Communication Between Heterogeneous Systems includes an easy-to-understand description of the use of &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 중요한 형태이며 널리 유일하게 다양한 개체를 식별하기 위해 다른 표준 내에서 사용된다. Dubuisson : ASN.1-이기종 시스템 간 통신에는 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 사용에 대한 이해하기 쉬운 설명이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d89a49f90db529d1a87ec8ebe643fd609dd3d3b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; value is simply a tuple with the consecutive values, which must be integers.</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 값은 단순히 정수이어야 연속 값을 가진 튜플이다.</target>
        </trans-unit>
        <trans-unit id="291813bf4581fd45b017cff8a605850835e5740d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 할 수 있습니다 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0de93bd973f344208a44803393d2336ed72a592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 할 수 있습니다 &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c435f50eeeff168b9ba4f24d7c44a547a62546d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; when only the &lt;code&gt;Module&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 기본값은 &lt;code&gt;[]&lt;/code&gt; 는 경우에만 &lt;code&gt;Module&lt;/code&gt; 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fb29cec4d8746b25b30ed76f21784b67fd7d4bbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Phone&lt;/code&gt; field is the third element.</source>
          <target state="translated">&lt;code&gt;Phone&lt;/code&gt; 필드는 세 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="9a36c74c23cadea74c3943787187639b86600b99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pid&lt;/code&gt; is the process handling the supervision of the SNMP manager start. When the manager has started a completion message will be sent to the client from this process: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt;. If the SNMP manager was not started in time, a timeout message will be sent to the client: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; SNMP 관리자 시작의 감독을 처리하는 과정입니다. 관리자가 시작되면 &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt; 프로세스에서 완료 메시지가 클라이언트로 전송됩니다 . SNMP 관리자가 제 시간에 시작되지 않은 경우 시간 종료 메시지가 클라이언트로 전송됩니다 : &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad1ec7b826ce17efed8a480d14fb2c2d7c83c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ProtocolVersion&lt;/code&gt; version is the version actually encoded in the reply message.</source>
          <target state="translated">&lt;code&gt;ProtocolVersion&lt;/code&gt; 의 버전은 실제로 응답 메시지로 인코딩 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cc15bf57b674de665a3aa4e09be58f12e93f6528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RELATIVE-OID&lt;/code&gt; type for relative object identifiers is fully supported.</source>
          <target state="translated">&lt;code&gt;RELATIVE-OID&lt;/code&gt; 상대 객체 식별자에 대한 유형을 완벽하게 지원한다.</target>
        </trans-unit>
        <trans-unit id="500392beab058916677f3be61233265c489d27bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; parameter in the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; user callback function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; 사용자 콜백 함수 의 &lt;code&gt;Reason&lt;/code&gt; 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="6b9fce90dd7e0310098f64ad13d29f2262c2551d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; returned value if any of the sync/async get/get-next/set/get-bulk functions returns &lt;code&gt;{error, Reason}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 값을 반환하는 경우 동기화의 / 비동기 GET / GET-다음 / 설정 / 얻을 벌크 기능 반환 &lt;code&gt;{error, Reason}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adaa6337c0136bccefb9d645f47ac7a3dea29f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReplyData&lt;/code&gt; defaults to &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt;, but may be explicitly overridden by a &lt;code&gt;megaco:cast/3&lt;/code&gt; option in order to forward info about the calling context of the originating process.</source>
          <target state="translated">&lt;code&gt;ReplyData&lt;/code&gt; 의 기본값 &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt; 하지만,이 명시 적으로 오버라이드 (override) 할 수 &lt;code&gt;megaco:cast/3&lt;/code&gt; 옵션 위해 원래 프로세스의 호출 컨텍스트에 대한 앞으로 정보에.</target>
        </trans-unit>
        <trans-unit id="5dcd8c369c6500e932ff1e1629f6fafbdc39108e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-Line&lt;/code&gt; 에 정의 된 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560f996f8e0b32b35d673e574bfba7c7f5732599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Request-URI&lt;/code&gt; 에 기재된 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; , 예를 들면, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cc862e08384f6496c068b1ef00d8543bcd2fea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request&lt;/code&gt; element can in itself contain many &lt;code&gt;Request&lt;/code&gt;s by using the following format:</source>
          <target state="translated">&lt;code&gt;Request&lt;/code&gt; 자체 요소 캔 많은 포함 &lt;code&gt;Request&lt;/code&gt; 은 다음 형식을 사용하여들 :</target>
        </trans-unit>
        <trans-unit id="df3736ae6d527f6dc758c7bc44a6f372a5715a61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Root directory&lt;/code&gt; can be edited by selecting the line where the path of the root directory is displayed and clicking the right mouse button. Choose edit in the menu that pops up.</source>
          <target state="translated">&lt;code&gt;Root directory&lt;/code&gt; 루트 디렉토리의 경로가 표시되는 선을 선택하고 마우스 오른쪽 버튼을 클릭하여 편집 할 수 있습니다. 팝업 메뉴에서 편집을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="84770d839ef4e410e85af06b8af1e00bd08e41e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RowIndex&lt;/code&gt; argument may refer to an existing row or a non-existing row, or it may be unspecified. The &lt;code&gt;Cols&lt;/code&gt; list may refer to inaccessible columns or non-existing columns. For each column in the &lt;code&gt;Cols&lt;/code&gt; list, the corresponding next instance is determined, and the last part of its OBJECT IDENTIFIER and its value is returned.</source>
          <target state="translated">&lt;code&gt;RowIndex&lt;/code&gt; 인수는 기존 행하거나 존재하지 않는 행을 참조 할 수 있거나, 지정 될 수있다. &lt;code&gt;Cols&lt;/code&gt; 목록에 액세스 할 열 또는 존재하지 않는 열을 참조 할 수 있습니다. &lt;code&gt;Cols&lt;/code&gt; 목록의 각 열에 대해 해당하는 다음 인스턴스가 결정되고 OBJECT IDENTIFIER 및 해당 값의 마지막 부분이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d86bbb9ebe74c2dccf692588c950366f9986be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SecurityCallbackModule&lt;/code&gt; is a user-written module that can receive events from the &lt;code&gt;mod_security&lt;/code&gt; Erlang web server API module. This module only exports the functions event/[4,5] which are described here.</source>
          <target state="translated">&lt;code&gt;SecurityCallbackModule&lt;/code&gt; 은 로부터 이벤트를 수신 할 수있는 사용자가 작성한 모듈 &lt;code&gt;mod_security&lt;/code&gt; 얼랑 웹 서버 API 모듈을. 이 모듈은 여기에 설명 된 event / [4,5] 기능 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6af65a9600faa054b3af4ac9bf04b32c2eda0702" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SeqCnt&lt;/code&gt; values in the filenames are all in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;WrapCnt&lt;/code&gt; with a gap in the circular sequence. The gap is needed to find the end of the trace.</source>
          <target state="translated">파일 이름 의 &lt;code&gt;SeqCnt&lt;/code&gt; 값은 모두 원형 시퀀스에 간격이있는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;WrapCnt&lt;/code&gt; 범위 입니다. 추적의 끝을 찾으려면 간격이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c2214d4ed634c1087714e34b7518b2efdc6127b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; or the &lt;code&gt;TypeSpecifier&lt;/code&gt;, or both, can be omitted. Thus, the following variants are allowed:</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 또는 &lt;code&gt;TypeSpecifier&lt;/code&gt; , 또는 둘 모두를 생략 할 수있다. 따라서 다음과 같은 변형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4401af203194a6b8a2b7ece91e21c535b2bfb4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; part of the segment multiplied by the unit in &lt;code&gt;TypeSpecifierList&lt;/code&gt; (described later) gives the number of bits for the segment. In construction, &lt;code&gt;Size&lt;/code&gt; is any expression that evaluates to an integer. In matching, &lt;code&gt;Size&lt;/code&gt; must be a constant expression or a variable.</source>
          <target state="translated">세그먼트 의 &lt;code&gt;Size&lt;/code&gt; 부분에 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 의 단위 (나중에 설명)를 곱한 값은 세그먼트 의 비트 수를 나타냅니다. 구성에서 &lt;code&gt;Size&lt;/code&gt; 는 정수로 평가되는 표현식입니다. 일치하는 &lt;code&gt;Size&lt;/code&gt; 는 상수 표현식 또는 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fa124ccd13ea8b5e4811fb40dda4e89bf8e0ab6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Socket&lt;/code&gt; shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; 정의되지이 함수 또는 다른 함수의 동작을 호출하기 전에 수동 모드 ({활성 거짓})로한다.</target>
        </trans-unit>
        <trans-unit id="7eae7e5127eb1df08b89e0018b0917cb18f30c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SupFlags&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; represents the &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SupFlags&lt;/code&gt; 의 반환 값에 변수 &lt;code&gt;init/1&lt;/code&gt; 대표 &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2315a984f49c0998e8d5af6001ef3acd45c41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TEST&lt;/code&gt; macro can also be used to override the &lt;code&gt;NOTEST&lt;/code&gt; macro. If &lt;code&gt;TEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included (even if &lt;code&gt;NOTEST&lt;/code&gt; is also defined), then the code will be compiled with EUnit enabled.</source>
          <target state="translated">&lt;code&gt;TEST&lt;/code&gt; 매크로도 무시할 수 있습니다 &lt;code&gt;NOTEST&lt;/code&gt; 매크로. 경우 &lt;code&gt;TEST&lt;/code&gt; 가 정의 &lt;strong&gt;되기 전에&lt;/strong&gt; EUNIT 헤더 파일이 포함되어 있습니다 (경우에도 &lt;code&gt;NOTEST&lt;/code&gt; 이 또한 정의), 다음 코드를 사용할 수 EUNIT로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="838665ed4c5367a2b5c2a4be4ad60949587a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; 의 용어는 파일 기술자가 아니다. 이 모듈에 더 많은 기능이 추가되면 향후 Erlang / OTP 릴리스에서 변경 될 수 있으므로이 용어의 특정 내용에 의존하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="465bc37c25caf4b34efb2c4086ab264294ebb922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module..</source>
          <target state="translated">&lt;code&gt;TarDescriptor&lt;/code&gt; 의 용어는 파일 기술자가 아니다. 이 모듈에 더 많은 기능이 추가되면 향후 Erlang / OTP 릴리스에서 변경 될 수 있으므로이 용어의 특정 내용에 의존하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0454f0125983aa193be8922f905a4526ad0af9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; is the time the request is valid. The value has to be greater then zero.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 요청이 유효한 시간입니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7d17ac7ee8e9756a5bbf3de834214c031df9a61a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; parameter is for the actual tls upgrade (phase 2) while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for the initial negotiation about upgrade (phase 1).</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 실제 TLS가 시간 초과 동안 (단계 2) 업그레이드를위한 파라미터는 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 업그레이드 (단계 1)에 대한 초기 협상에 이용된다.</target>
        </trans-unit>
        <trans-unit id="7e76487200ab118ffd183bce3e76d073d0b42eca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Trace Pattern&lt;/code&gt; is basically a tuple of a &lt;code&gt;module&lt;/code&gt; and a &lt;code&gt;detail level&lt;/code&gt; (either an integer or the atom max for full detail). In most cases the &lt;code&gt;Trace Pattern&lt;/code&gt;&lt;code&gt;{et,max}&lt;/code&gt; does suffice. But if you do not want any runtime dependency of &lt;code&gt;et&lt;/code&gt; you can implement your own &lt;code&gt;trace_me/5&lt;/code&gt; function in some module and refer to that module in the &lt;code&gt;Trace Pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Trace Pattern&lt;/code&gt; 기본적의 튜플 &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;detail level&lt;/code&gt; (정수 또는 전체 디테일 원자 중 최대). 대부분의 경우 &lt;code&gt;Trace Pattern&lt;/code&gt; &lt;code&gt;{et,max}&lt;/code&gt; 로 충분합니다. 그러나 &lt;code&gt;et&lt;/code&gt; 의 런타임 종속성을 원하지 않으면 일부 모듈에서 자체 &lt;code&gt;trace_me/5&lt;/code&gt; 함수를 구현 하고 해당 &lt;code&gt;Trace Pattern&lt;/code&gt; 에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f49e5bd7c0b07a911f5147dffd68a5a99e4dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceStartOption&lt;/code&gt; is any option allowed for &lt;code&gt;trace/1&lt;/code&gt;. The options &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; are given to &lt;code&gt;trace/1&lt;/code&gt;, where &lt;code&gt;OptList&lt;/code&gt; is &lt;code&gt;OptionList&lt;/code&gt; with &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;{procs, _}&lt;/code&gt; options removed.</source>
          <target state="translated">&lt;code&gt;TraceStartOption&lt;/code&gt; 은 허용 모든 옵션 &lt;code&gt;trace/1&lt;/code&gt; . 옵션 &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; 는 &lt;code&gt;trace/1&lt;/code&gt; 에 제공되며, 여기서 &lt;code&gt;OptList&lt;/code&gt; 는 &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;{procs, _}&lt;/code&gt; 옵션이 제거 된 &lt;code&gt;OptionList&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d2aed641ea18d80129eeabfddfeb6dc4dea97713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceTag&lt;/code&gt;&lt;code&gt;seq_trace&lt;/code&gt; is handled slightly differently. There is no &lt;code&gt;Tracee&lt;/code&gt; for &lt;code&gt;seq_trace&lt;/code&gt;, instead the &lt;code&gt;Label&lt;/code&gt; associated with the &lt;code&gt;seq_trace&lt;/code&gt; event is specified.</source>
          <target state="translated">&lt;code&gt;TraceTag&lt;/code&gt; 의 &lt;code&gt;seq_trace&lt;/code&gt; 는 약간 다르게 처리됩니다. &lt;code&gt;seq_trace&lt;/code&gt; 에 대한 &lt;code&gt;Tracee&lt;/code&gt; 가 없으며 &lt;code&gt;seq_trace&lt;/code&gt; 이벤트 와 연관된 &lt;code&gt;Label&lt;/code&gt; 이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7aee8b9587689f8640e087123cb9269b76c67d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeSpecifierList&lt;/code&gt; is a list of type specifiers separated by hyphens.</source>
          <target state="translated">&lt;code&gt;TypeSpecifierList&lt;/code&gt; 은 하이픈으로 구분 타입 지시자의 목록이다.</target>
        </trans-unit>
        <trans-unit id="cf30b67e2b9d6eefe96e2a44b56b701c3a71843b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Value&lt;/code&gt; part is any expression, when used in binary construction. Used in binary matching, the &lt;code&gt;Value&lt;/code&gt; part must be a literal or a variable. For more information about the &lt;code&gt;Value&lt;/code&gt; part, see &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Value&lt;/code&gt; 진 건설에 사용하면 부분은 어떤 식입니다. 이진 일치에 사용되는 &lt;code&gt;Value&lt;/code&gt; 부분은 리터럴 또는 변수 여야합니다. &lt;code&gt;Value&lt;/code&gt; 부분 에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db41e1083994609150ba03a58467ce1564f93559" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will automatically pull events from the &lt;code&gt;Collector&lt;/code&gt; and display them on the screen.</source>
          <target state="translated">&lt;code&gt;Viewer&lt;/code&gt; 자동으로 이벤트를 끌어 &lt;code&gt;Collector&lt;/code&gt; 하고 화면에 표시.</target>
        </trans-unit>
        <trans-unit id="8afb3e18be8e7e2fb56c7adc4a8999ad88a05635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will by default create a &lt;code&gt;Collector&lt;/code&gt; for you. With a few options and some configuration settings you can start collecting &lt;code&gt;Events&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Viewer&lt;/code&gt; 기본적으로 생성됩니다 &lt;code&gt;Collector&lt;/code&gt; 당신을 위해. 몇 가지 옵션과 일부 구성 설정으로 &lt;code&gt;Events&lt;/code&gt; 수집을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12a1a53435b86d328cae136152477d1bdb078001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XXL&lt;/code&gt; operator is defined for the interpretation of any of the LineOp operators applied to a set of function calls. The result is that of replacing the function call with a line numbered function call, that is, each of the two functions of the call is replaced by a pair of the function and the line where the function is defined. The effect of the &lt;code&gt;XXL&lt;/code&gt; operator can be undone by the LineOp operators. For instance, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; is equivalent to &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XXL&lt;/code&gt; 연산자는 함수 호출들의 세트에인가 LineOp 사업자 임의의 해석에 대해 정의된다. 그 결과 함수 호출을 행 번호가 매겨진 함수 호출로 교체 한 것입니다. 즉, 호출의 두 함수 각각은 함수 쌍과 함수가 정의 된 행으로 대체됩니다. LineOp 연산자 는 &lt;code&gt;XXL&lt;/code&gt; 연산자 의 효과를 취소 할 수 있습니다. 예를 들어, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; 동일하다 &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f8eacbf90d517d7610d94842c0bab01a3934c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ZipHandle&lt;/code&gt; is closed if the process that originally opened the archive dies.</source>
          <target state="translated">&lt;code&gt;ZipHandle&lt;/code&gt; 는 과정 원래 아카이브 다이를 열었다 경우 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6a10f4396b335e787b9182ce75a8ccae749ae857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_test&lt;/code&gt; macro takes any expression (the &quot;body&quot;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</source>
          <target state="translated">&lt;code&gt;_test&lt;/code&gt; 매크로는 인자로 표현식 (이하 &quot;몸&quot;)를 취하고, (몇 가지 추가 정보와 함께) 재미있는 표현 내에 배치합니다. 본문은 간단한 테스트 함수의 본문과 마찬가지로 모든 종류의 테스트 표현이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e2f2fedc48b32638d6fb2b72fe74559f091a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call does &lt;strong&gt;not&lt;/strong&gt; have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 호출 않습니다 &lt;strong&gt;되지&lt;/strong&gt; 소켓 소유자 과정에서 발행되어야한다. 버전 5.5.3 이상의 에뮬레이터를 사용하면 여러 프로세스에서 여러 동시 수락 호출을 발행 할 수 있으므로 들어오는 연결을 처리하는 수락 자 프로세스 풀이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b97c48085c09e86337df00a4b0a18e9e9f983484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apread/4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;apread/4&lt;/code&gt; 의 함수를 조합 한, 소정 위치로부터 판독 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="6e1ba830557bf0975fcfe18ee483f0f3bec5d278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apwrite/4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;apwrite/4&lt;/code&gt; 의 함수를 조합 한, 소정 위치에 기록 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="00d3c3634428cbc77b5aceea9f983ec649758967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert&lt;/code&gt; macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 매크로는 사전 / 사후 및 불변을 확인뿐만 아니라 단위 테스트에서 프로그램에 사용 어디서나 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="108ceadd98496de12d8902f0058bac96f4aa9204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is passed to the &lt;code&gt;do_perm&lt;/code&gt; function. We do not use a &lt;code&gt;async_free&lt;/code&gt; function (the last argument to &lt;code&gt;driver_async&lt;/code&gt;), it is only used if the task is cancelled programmatically.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; 은 받는 사람 전달 &lt;code&gt;do_perm&lt;/code&gt; 의 기능. &lt;code&gt;async_free&lt;/code&gt; 함수 ( &lt;code&gt;driver_async&lt;/code&gt; 의 마지막 인수 ) 는 사용하지 않으며 , 프로그래밍 방식으로 작업이 취소 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd04a38dd6fcdc2cd251ae665b899f10977e42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is the argument to the functions &lt;code&gt;async_invoke&lt;/code&gt; and &lt;code&gt;async_free&lt;/code&gt;. It is typically a pointer to a structure containing a pipe or event that can be used to signal that the async operation completed. The data is to be freed in &lt;code&gt;async_free&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_data&lt;/code&gt; 는 기능에 대한 인수입니다 &lt;code&gt;async_invoke&lt;/code&gt; 및 &lt;code&gt;async_free&lt;/code&gt; . 일반적으로 비동기 작업이 완료되었음을 알리는 데 사용할 수있는 파이프 또는 이벤트를 포함하는 구조에 대한 포인터입니다. 데이터는 &lt;code&gt;async_free&lt;/code&gt; 에 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="61c5f2724e8a89f933cb80bf3b2eb6cc8b3b6977" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;avg1/0&lt;/code&gt;, &lt;code&gt;avg5/0&lt;/code&gt;, and &lt;code&gt;avg15/0&lt;/code&gt; functions can be used for retrieving system load values, and the &lt;code&gt;util/0&lt;/code&gt; and &lt;code&gt;util/1&lt;/code&gt; functions can be used for retrieving CPU utilization values.</source>
          <target state="translated">&lt;code&gt;avg1/0&lt;/code&gt; , &lt;code&gt;avg5/0&lt;/code&gt; 및 &lt;code&gt;avg15/0&lt;/code&gt; 함수는 시스템 부하 값을 검색에 이용 될 수 &lt;code&gt;util/0&lt;/code&gt; 및 &lt;code&gt;util/1&lt;/code&gt; 기능은 CPU 사용률 값을 검색하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="a43d2dcf5e0e967eda5efa53bd70665dc5d59efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blog()&lt;/code&gt; functions can also be used for internally formatted logs, but in this case they must be called with binaries constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; and automatic repair functions fail. The corresponding terms (not the binaries) are returned when &lt;code&gt;chunk/2,3&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;blog()&lt;/code&gt; 함수는 내부적으로 포맷 된 로그를 사용할 수 있지만,이 경우 그들은 호출로 구성 바이너리로 호출 할 필요가 &lt;code&gt;term_to_binary/1&lt;/code&gt; . 이를 확인하기위한 점검은 없으며, 전적으로 호출자의 책임입니다. Erlang 용어와 일치하지 않는 이진으로 이러한 함수를 호출하면 &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; 및 자동 복구 기능이 실패합니다. &lt;code&gt;chunk/2,3&lt;/code&gt; 을 호출 하면 해당 항 (2 진이 아님)이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="37d74f76daa8e51f123951ddaf373680517fc012" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel_callback&lt;/code&gt; is the module that implements the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour in the daemon. See the section &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information and an example.</source>
          <target state="translated">&lt;code&gt;channel_callback&lt;/code&gt; 는 모듈입니다 구현하는 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 데몬에서 (을 대체의 ssh_daemon_channel) 행동. 자세한 정보와 예제는 사용자 안내서에서 &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8493f2b264f76e709a289fe048f59895e05cdc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; above makes the &lt;code&gt;.erlang.cookie&lt;/code&gt; file accessible only by the owner of the file. This is a requirement.</source>
          <target state="translated">위 의 &lt;code&gt;chmod&lt;/code&gt; 는 &lt;code&gt;.erlang.cookie&lt;/code&gt; 파일을 파일 소유자 만 액세스 할 수있게합니다. 이것은 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="067ed8257f3ed48d1dd77d1c82e5f73c03791be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;client_directory&lt;/code&gt; in the directory structure of the master nodes must be specified.</source>
          <target state="translated">&lt;code&gt;client_directory&lt;/code&gt; 마스터 노드의 디렉토리 구조를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="97ad2677bec8a2ec1b2eaf275491aa26823e6cdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clients&lt;/code&gt; directory is to have one subdirectory per supported client node. The name of each client directory is to be the name of the corresponding client node. As a minimum, each client directory is to contain the &lt;code&gt;bin&lt;/code&gt; and &lt;code&gt;releases&lt;/code&gt; subdirectories. These directories are used to store information about installed releases and to appoint the current release to the client. The &lt;code&gt;$ROOT&lt;/code&gt; directory thus contains the following:</source>
          <target state="translated">&lt;code&gt;clients&lt;/code&gt; 디렉토리는 지원되는 클라이언트 노드 당 하나 개의 하위 디렉토리를하는 것입니다. 각 클라이언트 디렉토리의 이름은 해당 클라이언트 노드의 이름입니다. 최소한 각 클라이언트 디렉토리는 포함하는 &lt;code&gt;bin&lt;/code&gt; 과 &lt;code&gt;releases&lt;/code&gt; 하위 디렉토리를. 이 디렉토리는 설치된 릴리스에 대한 정보를 저장하고 현재 릴리스를 클라이언트에 지정하는 데 사용됩니다. 따라서 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fef0ac1b98cce64ffd1d82b4509565a3e18b84ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code_change&lt;/code&gt; method must also be implemented.</source>
          <target state="translated">&lt;code&gt;code_change&lt;/code&gt; 의 방법은 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfba9577e3cba70bb212c1548338d8d33c8f09a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combined&lt;/code&gt; format is one line looking like this: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combined&lt;/code&gt; 형식은 다음 과 같은 한 줄입니다. &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b60f349fe6a82d8f3ab2d525a727ef964290939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process does the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; 프로세스는 다음과 같은 작업을 수행합니다</target>
        </trans-unit>
        <trans-unit id="ceca332ed5fece3a22bbc2b65250bbdfb9575097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process performs the following:</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; 프로세스는 다음을 수행합니다 :</target>
        </trans-unit>
        <trans-unit id="3748b6dda37726d1886cb8a28dacde2fa7798fe9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; macro is defined in &lt;code&gt;ct.hrl&lt;/code&gt;. This macro is to be used to retrieve information from the &lt;code&gt;Config&lt;/code&gt; variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the &lt;code&gt;Config&lt;/code&gt; variable supplied to the test case.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 매크로에 정의되어 &lt;code&gt;ct.hrl&lt;/code&gt; . 이 매크로는 모든 테스트 사례로 전송 된 &lt;code&gt;Config&lt;/code&gt; 변수 에서 정보를 검색하는 데 사용됩니다 . 두 개의 인수와 함께 사용됩니다. 첫 번째는 검색 할 구성 변수의 이름이고 두 번째는 테스트 케이스에 제공된 &lt;code&gt;Config&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="3402fd646c2b066512d58aeec8dd8cb2dfa256aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 기본값을 사용하는 경우 스크립트는 경고를 발행합니다. 변수가 설정되면 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6288c90b6c5e2f3d2b468cb02b51d6affc24bf92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; scripts are generated by invoking &lt;code&gt;./otp_build autoconf&lt;/code&gt; in the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. The &lt;code&gt;configure&lt;/code&gt; scripts also have to be regenerated when a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file has been modified. Note that when checking out a branch a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file may change content, and you may therefore have to regenerate the &lt;code&gt;configure&lt;/code&gt; scripts when checking out a branch. Regenerated &lt;code&gt;configure&lt;/code&gt; scripts imply that you have to run &lt;code&gt;configure&lt;/code&gt; and build again.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트 호출에 의해 생성되는 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 에 &lt;code&gt;$ERL_TOP&lt;/code&gt; 디렉토리. &lt;code&gt;configure&lt;/code&gt; 스크립트는 또한 때 다시 생성 할 필요가 &lt;code&gt;configure.in&lt;/code&gt; 또는 &lt;code&gt;aclocal.m4&lt;/code&gt; 의 파일이 수정되었습니다. 분기를 체크 아웃 할 때 &lt;code&gt;configure.in&lt;/code&gt; 또는 &lt;code&gt;aclocal.m4&lt;/code&gt; 파일이 내용을 변경할 수 있으므로 분기를 체크 아웃 할 때 &lt;code&gt;configure&lt;/code&gt; 스크립트 를 다시 생성해야 할 수도 있습니다 . 재생성 된 &lt;code&gt;configure&lt;/code&gt; 스크립트는 &lt;code&gt;configure&lt;/code&gt; 를 실행 하고 다시 빌드 해야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="208c163b5d9b18adfd658c53d3afa3ceb105c168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; function looks a bit different too. We connect using the asynchronous &lt;code&gt;PQconnectStart&lt;/code&gt; function. After the connection is started, we retrieve the socket for the connection with &lt;code&gt;PQsocket&lt;/code&gt;. This socket is used with the &lt;code&gt;driver_select&lt;/code&gt; function to wait for connection. When the socket is ready for input or for output, the &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 기능도 조금 다른 보인다. 비동기 &lt;code&gt;PQconnectStart&lt;/code&gt; 기능을 사용하여 연결 합니다. 연결이 시작되면 &lt;code&gt;PQsocket&lt;/code&gt; 과의 연결을위한 소켓을 검색합니다 . 이 소켓은 &lt;code&gt;driver_select&lt;/code&gt; 함수 와 함께 사용하여 연결을 기다립니다. 소켓이 입력 또는 출력 준비가되면 &lt;code&gt;ready_io&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="72241940e6969f3882cb2063d805e933d9f13162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; option is &lt;strong&gt;not&lt;/strong&gt; intended for production. It is &lt;strong&gt;only&lt;/strong&gt; a convenient way to debug Erlang services during development.</source>
          <target state="translated">&lt;code&gt;console&lt;/code&gt; 옵션이되어 &lt;strong&gt;있지&lt;/strong&gt; 생산을위한 것. 그것은입니다 &lt;strong&gt;만&lt;/strong&gt; 개발하는 동안 얼랑 서비스를 디버깅 할 수있는 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="09d03cd7b2afda946d29b4dfa4871ca45c957a3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content&lt;/code&gt; field of the top element is a list of records that shows the structure and data of the document. If it is a simple document like:</source>
          <target state="translated">상단 요소 의 &lt;code&gt;content&lt;/code&gt; 필드는 문서의 구조와 데이터를 보여주는 레코드 목록입니다. 다음과 같은 간단한 문서 인 경우 :</target>
        </trans-unit>
        <trans-unit id="838c0fd05d2d1deb4094b06de0e616a5af7c6e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; option inhibits the call to &lt;code&gt;trace(stop)&lt;/code&gt; and leaves it up to the caller to stop tracing at a suitable time.</source>
          <target state="translated">는 &lt;code&gt;continue&lt;/code&gt; 옵션 억제를 호출 &lt;code&gt;trace(stop)&lt;/code&gt; 적절한 시간에 추적을 중지 발신자와 잎을 위로.</target>
        </trans-unit>
        <trans-unit id="5e5e4cf83680d9fc0726d1fa4e444a1ac9be072e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;control&lt;/code&gt; entry is called from the emulator when the Erlang code calls &lt;code&gt;port_control/3&lt;/code&gt;, to do the actual work. We have defined a simple set of commands: &lt;code&gt;connect&lt;/code&gt; to log in to the database, &lt;code&gt;disconnect&lt;/code&gt; to log out, and &lt;code&gt;select&lt;/code&gt; to send a SQL-query and get the result. All results are returned through &lt;code&gt;rbuf&lt;/code&gt;. The library &lt;code&gt;ei&lt;/code&gt; in &lt;code&gt;erl_interface&lt;/code&gt; is used to encode data in binary term format. The result is returned to the emulator as binary terms, so &lt;code&gt;binary_to_term&lt;/code&gt; is called in Erlang to convert the result to term form.</source>
          <target state="translated">&lt;code&gt;control&lt;/code&gt; 얼랭 코드를 호출 할 때 항목은 에뮬레이터에서 호출 &lt;code&gt;port_control/3&lt;/code&gt; 실제 작업을 수행. : 우리는 명령의 간단한 세트 정의 &lt;code&gt;connect&lt;/code&gt; 데이터베이스에 로그인 할 수 &lt;code&gt;disconnect&lt;/code&gt; 로그 아웃하고 &lt;code&gt;select&lt;/code&gt; 하여 SQL 쿼리를 전송하고 결과를 얻을 수 있습니다. 모든 결과는 &lt;code&gt;rbuf&lt;/code&gt; 를 통해 반환됩니다 . &lt;code&gt;erl_interface&lt;/code&gt; 의 라이브러리 &lt;code&gt;ei&lt;/code&gt; 는 이진 용어 형식으로 데이터를 인코딩하는 데 사용됩니다. 결과는 이진 용어로 에뮬레이터에 반환되므로 Erlang에서 &lt;code&gt;binary_to_term&lt;/code&gt; 을 호출하여 결과를 용어 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="26bab11093554a028ef86c3afb6f974cfc496b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert_to_c&lt;/code&gt; function is the same as before, but here it is used as a fun:</source>
          <target state="translated">&lt;code&gt;convert_to_c&lt;/code&gt; 기능은 이전과 동일하지만, 여기가 재미로 사용된다 :</target>
        </trans-unit>
        <trans-unit id="77c0725ecb5968616addeb9bf220dfefe059032f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cprof&lt;/code&gt; module is used to profile a program to find out how many times different functions are called. Breakpoints similar to local call trace, but containing a counter, are used to minimise runtime performance impact.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 의 모듈은 다른 기능을 호출하는 방법을 여러 번 찾아 프로그램을 프로파일 링하는 데 사용됩니다. 로컬 호출 추적과 유사하지만 카운터를 포함하는 중단 점은 런타임 성능 영향을 최소화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9716455d32bb78ba694b642a2f677996c5c94a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 모드 옵션은 SFTP 서버로 전송하기 전에 바이트 생성 된 스트림에 적용됩니다. 이것은 암호화 용이지만 다른 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05085fc1befe3aa6ba53fe6204755e8c7f0ad8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_hooks&lt;/code&gt; statement must look as follows:</source>
          <target state="translated">&lt;code&gt;ct_hooks&lt;/code&gt; 에 다음과 같이 문 찾아야합니다 :</target>
        </trans-unit>
        <trans-unit id="195e3e1b4f16da2ed99752167d29e762d1e2035f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program is automatically installed with Erlang/OTP and the &lt;code&gt;Common Test&lt;/code&gt; application (for more information, see section &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; in the User's Guide). The program accepts different start flags. Some flags trigger &lt;code&gt;ct_run&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt; and pass on data to it. Some flags start an Erlang node prepared for running &lt;code&gt;Common Test&lt;/code&gt; in a particular mode.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 의 프로그램이 자동으로 얼랑 / OTP와 함께 설치되는 &lt;code&gt;Common Test&lt;/code&gt; (섹션 참조 자세한 내용은 응용 프로그램 &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; 사용자 설명서 참조). 프로그램은 다른 시작 플래그를 허용합니다. 일부 플래그는 &lt;code&gt;ct_run&lt;/code&gt; 을 트리거 하여 &lt;code&gt;Common Test&lt;/code&gt; 를 시작 하고 데이터를 전달합니다. 일부 플래그 는 특정 모드에서 &lt;code&gt;Common Test&lt;/code&gt; 를 실행할 준비가 된 Erlang 노드를 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="0bead0eeaff46c7e466e0712fc0054654e293c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program sets the exit status before shutting down. The following values are defined:</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 의 프로그램이 종료하기 전에 종료 상태를 설정합니다. 다음과 같은 값이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5e688bf44ef358ec92d20ce42ff6bf380d1fb9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cth_conn_log&lt;/code&gt; hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log.</source>
          <target state="translated">&lt;code&gt;cth_conn_log&lt;/code&gt; 후크 수행 별도의 텍스트 파일로 텔넷 데이터 로깅 형식화. 서버에서 전송 된 모든 데이터를 포함하여 모든 Telnet 통신이 캡처 및 인쇄됩니다. 이 텍스트 파일에 대한 링크는 테스트 케이스 HTML 로그의 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a68179b6708f261780e3204a93ccf67ebff3b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; module is primarily targeted towards tracing through the &lt;code&gt;erlang:trace/3&lt;/code&gt; function. It is sometimes desired to trace messages in a more delicate way, which can be done with the help of the &lt;code&gt;seq_trace&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;dbg&lt;/code&gt; 모듈은 주로 통해 추적 대상으로되는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 기능. &lt;code&gt;seq_trace&lt;/code&gt; 모듈 을 사용하여보다 정교한 방식으로 메시지를 추적하는 것이 바람직한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec06ab24b2bef8a81af6b12d4353768a1844399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; server keeps a list of nodes where tracing should be performed. Whenever a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; call or a &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; call is made, it is executed for all nodes in this list including the local node (except for &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; with a specific &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; as first argument, in which case the command is executed only on the node where the designated process or port resides).</source>
          <target state="translated">&lt;code&gt;dbg&lt;/code&gt; 서버는 추적이 수행되어야 노드의 목록을 유지합니다. &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 호출 또는 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 호출이 수행 될 때마다 로컬 노드 ( 특정 &lt;code&gt;pid()&lt;/code&gt; 또는 &lt;code&gt;port()&lt;/code&gt; 를 첫 번째 인수로 사용하는 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 제외)를 포함하여이 목록의 모든 노드에 대해 실행 됩니다. 지정된 명령이나 포트가있는 노드에서만 명령이 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="c217008a9ef77e9f7c9c82997e3edae1e2b0a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for &lt;code&gt;ets:fun2ms/1&lt;/code&gt; returns the result without side effects. As matching (&lt;code&gt;=&lt;/code&gt;) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction.</source>
          <target state="translated">일치 사양 의 &lt;code&gt;dbg&lt;/code&gt; 변형에는 일치 사양 본문에 대한 필수 접근 방식이 있지만 ETS 언어는 그렇지 않습니다. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 의 fun body는 부작용없이 결과를 반환합니다. 일치 스펙 본문에서 일치 ( &lt;code&gt;=&lt;/code&gt; )가 허용되지 않기 때문에 (성능상의 이유로) 남은 것은 용어 구성입니다.</target>
        </trans-unit>
        <trans-unit id="8b1d45e514e2b4bb0f72c0e576b456b901110516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; option ensures that the BEAM file contains debug information, which makes it possible to find unused local functions.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 의 옵션 보장 BEAM 파일은 가능한 사용하지 않는 지역의 기능을 찾을 수 있도록 디버그 정보를 포함하고있다.</target>
        </trans-unit>
        <trans-unit id="f272f87848e9520c4164ada69cea273706e63692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; parameter controls whether the debug information in the beam file should be kept (&lt;code&gt;keep&lt;/code&gt;) or stripped &lt;code&gt;strip&lt;/code&gt; when the file is copied to the target system.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 의 빔 파일에 디버그 정보 (보관되어야 하는지를 제어 파라미터 &lt;code&gt;keep&lt;/code&gt; ) 또는 박리 &lt;code&gt;strip&lt;/code&gt; 파일을 타겟 시스템으로 복사 할 때.</target>
        </trans-unit>
        <trans-unit id="6fb823bf619fb63ef67310a79ad7a561ee4d0a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 기능은 반드시 테이블이 파괴되어야한다는 것을 의미하지 않는 MIB을 언로드하기 때문에 데이터베이스에서 테이블을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bb6d436299249f5caa30b07b29030812a609536" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the variable from the database.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 기능은 데이터베이스에서 변수를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7056e5309dbe8cb35a67254e724ea1561fd3590e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; operation is considered successful if the element was not present in the table. Hence all attempts to check that the element is present in the Ets/Mnesia table before deletion are unnecessary. Here follows an example for Ets tables:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 요소가 테이블에 존재 아니었다면 작업이 성공적으로 간주됩니다. 따라서 삭제하기 전에 요소가 Ets / Mnesia 테이블에 있는지 확인하려는 모든 시도는 필요하지 않습니다. 다음은 Ets 테이블의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3ec29833516e95ca8c52bcd06ca0329b6a9912b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disc_copies&lt;/code&gt; tables are stored on disk with &lt;code&gt;.DCL&lt;/code&gt; and &lt;code&gt;.DCD&lt;/code&gt; files, which are standard &lt;code&gt;disk_log&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;disc_copies&lt;/code&gt; 의 테이블과 디스크에 저장된 &lt;code&gt;.DCL&lt;/code&gt; 및 &lt;code&gt;.DCD&lt;/code&gt; 표준 파일, &lt;code&gt;disk_log&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="0566aa9127b7a16298ed02e87fbca3df443437c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disk_log&lt;/code&gt; module does not report errors to the &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; module. It is up to the caller to decide whether to employ the error logger. Function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; can be used to produce readable messages from error replies. However, information events are sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks.</source>
          <target state="translated">&lt;code&gt;disk_log&lt;/code&gt; 모듈은 오류를보고하지 않습니다 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 의 모듈. 오류 로거의 사용 여부를 결정하는 것은 호출자의 책임입니다. &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 오류 응답에서 읽을 수있는 메시지를 생성 할 수 있습니다. 그러나 정보 이벤트는 두 가지 상황, 즉 로그가 복구되거나 청크를 읽는 동안 파일이 누락 된 경우 오류 로거로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="cfcfef3897d14b434ad165428853c39b5f2890f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; and &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; functions takes a &lt;code&gt;#hs_data{}&lt;/code&gt; record as argument. There are quite a lot of fields in this record that you need to set. The record is defined in &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt;. Not documented fields should not be set, i.e., should be left as &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; 및 &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; 기능은 얻어 &lt;code&gt;#hs_data{}&lt;/code&gt; 인수로 기록. 이 레코드에는 설정해야 할 필드가 많이 있습니다. 레코드는 &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt; 에 정의되어 있습니다. 문서화되지 않은 필드는 설정하지 않아야합니다. 즉, &lt;code&gt;undefined&lt;/code&gt; 로 두어야합니다 .</target>
        </trans-unit>
        <trans-unit id="83c7e0ed34c372831d8c8f2866d0a4d8b8af47d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_select&lt;/code&gt; function initiates a select, and returns if there is no immediate error. The result is returned when &lt;code&gt;ready_io&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;do_select&lt;/code&gt; 의 즉각적인 오류가없는 경우 함수는 선택 시작하고 돌아갑니다. &lt;code&gt;ready_io&lt;/code&gt; 가 호출 되면 결과가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e898d68f399dcaad71bedb473b4e1db27a86822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver_entry&lt;/code&gt; structure is a C struct that all Erlang drivers define. It contains entry points for the Erlang driver, which are called by the Erlang emulator when Erlang code accesses the driver.</source>
          <target state="translated">&lt;code&gt;driver_entry&lt;/code&gt; 의 구조는 모든 얼랑 드라이버를 정의하는 C 구조체이다. Erlang 코드가 드라이버에 액세스 할 때 Erlang 에뮬레이터가 호출하는 Erlang 드라이버의 진입 점을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e2f343471e0cd9e732eb94fa594ad01445d525d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="translated">&lt;code&gt;entity-Body&lt;/code&gt; 에서 정의한 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 는 , 예를 들어, 데이터는 POST 방법을 사용하여 CGI 스크립트로부터 전송.</target>
        </trans-unit>
        <trans-unit id="8485e195c6ca973415a83d30d66c767c905bacbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epmd&lt;/code&gt; daemon accepts messages from both the local host and remote hosts. However, only the query commands are answered (and acted upon) if the query comes from a remote host. It is always an error to try to register a node name if the client is not a process on the same host as the &lt;code&gt;epmd&lt;/code&gt; instance is running on. Such requests are considered hostile and the connection is closed immediately.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 데몬은 로컬 호스트와 원격 호스트 모두에서 메시지를 받아들입니다. 그러나 쿼리가 원격 호스트에서 온 경우 쿼리 명령 만 응답 (및 조치)됩니다. 클라이언트가 &lt;code&gt;epmd&lt;/code&gt; 인스턴스가 실행중인 동일한 호스트에서 프로세스가 아닌 경우 노드 이름을 등록하려고하면 항상 오류 입니다. 이러한 요청은 적대적인 것으로 간주되며 연결이 즉시 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1a8cdcc41303bad80d1836231fd657575e8b7da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl&lt;/code&gt; program starts an Erlang runtime system. The exact details (for example, whether &lt;code&gt;erl&lt;/code&gt; is a script or a program and which other programs it calls) are system-dependent.</source>
          <target state="translated">&lt;code&gt;erl&lt;/code&gt; 프로그램은 얼랑 런타임 시스템을 시작합니다. 정확한 세부 사항 (예 : &lt;code&gt;erl&lt;/code&gt; 이 스크립트 또는 프로그램 인지 여부 및 호출하는 기타 프로그램)은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="23033c746a70348dcd7ee413398f764a041fafc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_boot_server&lt;/code&gt; can read regular files and files in archives. See &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; in ERTS.</source>
          <target state="translated">&lt;code&gt;erl_boot_server&lt;/code&gt; 은 보관소에 일반 파일 및 파일을 읽을 수 있습니다. ERTS의 &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc1db4ac366acb55e5dbd23b870fee87dcf6984d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_prim_loader&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">&lt;code&gt;erl_prim_loader&lt;/code&gt; 의 모듈은 다음과 같은 명령 줄 플래그를 해석합니다 :</target>
        </trans-unit>
        <trans-unit id="9c8443a325361f346c54c5b5b79ecfd176dc3cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF is equivalent to:</source>
          <target state="translated">&lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF는 동등하다 :</target>
        </trans-unit>
        <trans-unit id="674c071fef1bb6c50be069bf2fac5cfa5b02ddff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; commands can be used to compile SNMP MIBs. Example:</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 의 명령은 SNMP MIB를 컴파일하는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="62bad1fda35fe8631456e7f852e564c8e9c8e268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides a common way to run all compilers in the Erlang system. Depending on the extension of each input file, &lt;code&gt;erlc&lt;/code&gt; invokes the appropriate compiler. Regardless of which compiler is used, the same flags are used to provide parameters, such as include paths and output directory.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 프로그램은 얼랑 시스템의 모든 컴파일러를 실행하는 일반적인 방법을 제공합니다. 각 입력 파일의 확장자에 따라 &lt;code&gt;erlc&lt;/code&gt; 는 적절한 컴파일러를 호출합니다. 사용되는 컴파일러에 관계없이 동일한 경로를 사용하여 경로 및 출력 디렉토리 포함과 같은 매개 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04a181b53380c41c65d2013dd7fbc831073b3697" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides an even better way to compile modules from the shell, see the &lt;code&gt;erlc(1)&lt;/code&gt; manual page in ERTS. It understands a number of flags that can be used to define macros, add search paths for include files, and more.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 의 프로그램은 참조 셀에서 모듈을 컴파일 할 수있는 더 나은 방법을 제공합니다 &lt;code&gt;erlc(1)&lt;/code&gt; ERTS의 매뉴얼 페이지를. 매크로를 정의하고 포함 파일에 대한 검색 경로를 추가하는 데 사용할 수있는 많은 플래그를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="cd3c7d4f5dac617c7aad52a992257a0165d9e724" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger&lt;/code&gt; API still exists, but should only be used by legacy code. It will be removed in a later release.</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 의 API는 여전히 존재하지만 레거시 코드에 의해 사용되어야한다. 이후 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d68556b2eb1fae2f09bd4af885781dca52da64d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt;deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">&lt;code&gt;error_logger_format_depth&lt;/code&gt; 의 변수입니다 &lt;code&gt;deprecated&lt;/code&gt; 이후 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 얼랑 / OTP 21.0 년에 도입되었다. 변수 및이 함수는 레거시 보고서 처리기에서 여전히 사용될 수 있으므로 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7c78dbc6e06eb7032ca1037abf4bb7cf984ec4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 공구는 생성 돕기 위해 사용될 수있다 &lt;code&gt;erts_alloc&lt;/code&gt; 의 런타임 시나리오 제한된 수의 적합한 구성.</target>
        </trans-unit>
        <trans-unit id="6d445f376d6f420d187f6eefce3f926292a91d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;et&lt;/code&gt; module is not like other modules. It contains a function called &lt;code&gt;et:trace_me/5&lt;/code&gt;. Which is a function that does not do any useful stuff at all. Its sole purpose is to be a function that is easy to trace. A call to it may be something like:</source>
          <target state="translated">&lt;code&gt;et&lt;/code&gt; 모듈은 다른 모듈과 같지 않다. &lt;code&gt;et:trace_me/5&lt;/code&gt; 라는 함수를 포함합니다 . 유용한 기능을 전혀 수행하지 않는 기능입니다. 그것의 유일한 목적은 추적하기 쉬운 기능입니다. 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bed59c1de102975ce15ed3e675ac3119209f047d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; program of fairly modern versions of Emacs and XEmacs has native support for Erlang. To check if your version does include this support, issue the command &lt;code&gt;etags --help&lt;/code&gt; at a the command line prompt. At the end of the help text there is a list of supported languages. Unless Erlang is a member of this list I suggest that you should upgrade to a newer version of Emacs.</source>
          <target state="translated">&lt;code&gt;etags&lt;/code&gt; 매우 현대 이맥스 버전과 이맥스의 프로그램은 얼랑에 대한 기본 지원합니다. 버전에이 지원이 포함되어 있는지 확인하려면 명령 행 프롬프트에서 &lt;code&gt;etags --help&lt;/code&gt; 명령을 실행하십시오. 도움말 텍스트 끝에 지원되는 언어 목록이 있습니다. Erlang이이 목록에 속하지 않으면 최신 버전의 Emacs로 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47e6f553b59c8cd440ae6bcf427e51798ed42721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; utility can also read a list of files from its standard input by supplying a single dash in place of the file names. This feature is useful when a project consists of a large number of files. The standard UNIX command &lt;code&gt;find&lt;/code&gt; can be used to generate the list of files, e.g:</source>
          <target state="translated">&lt;code&gt;etags&lt;/code&gt; 유틸리티는 파일 이름 대신에 단일 대시를 제공하여 표준 입력에서 파일 목록을 읽을 수 있습니다. 이 기능은 프로젝트가 많은 파일로 구성된 경우에 유용합니다. 표준 UNIX 명령 &lt;code&gt;find&lt;/code&gt; 를 사용하여 파일 목록을 생성 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e41a30417c9eb9b7fd9125a0948a761a185309da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ets:select/2&lt;/code&gt; call conceptually looks like this in the resulting code:</source>
          <target state="translated">&lt;code&gt;ets:select/2&lt;/code&gt; 호출은 개념적 결과 코드에 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c0a28f71fbf02463cf528426b0591cc67a7a02b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;example_drv_start&lt;/code&gt;, is the only function that is called with a handle to the port instance, so this must be saved. It is customary to use an allocated driver-defined structure for this one, and to pass a pointer back as a reference.</source>
          <target state="translated">&lt;code&gt;example_drv_start&lt;/code&gt; 는 포트 인스턴스에 대한 핸들로 호출되는 전용 기능입니다, 그래서 이것은 저장해야합니다. 이를 위해 할당 된 드라이버 정의 구조를 사용하고 포인터를 참조로 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="d0356d1c5d4e8ef894f1ca0204010b1f0f916038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extended_errors&lt;/code&gt; option enables extended ODBC error information when an operation fails. Rather than returning &lt;code&gt;{error, Reason}&lt;/code&gt;, the failing function will reutrn &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt;. Note that this information is probably of little use when writing database-independent code, but can be of assistance in providing more sophisticated error handling when dealing with a known underlying database.</source>
          <target state="translated">&lt;code&gt;extended_errors&lt;/code&gt; 의 작업이 실패 할 때 옵션은 ODBC 오류 정보를 확장 할 수 있습니다. 보다 오히려 복귀 &lt;code&gt;{error, Reason}&lt;/code&gt; , 실패한 기능 reutrn 것 &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt; . 이 정보는 데이터베이스 독립 코드를 작성할 때 거의 사용되지 않지만 알려진 기본 데이터베이스를 처리 할 때보다 정교한 오류 처리를 제공하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c59051a0d238b0abf7c9e7050c91b5361d579937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra&lt;/code&gt; info is not normally interpreted by the agent, instead it is passed through to the &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; process. It is up to the implementor of that process to make use of this data.</source>
          <target state="translated">&lt;code&gt;extra&lt;/code&gt; 정보는 일반적으로 통해 대신이 전달되는 에이전트에 의해 해석되지 않습니다 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; 공정. 이 데이터를 사용하는 것은 해당 프로세스의 구현 자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9363097de66681822e14d18a16cae53b07a71b33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module accepts raw filenames as input. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; also accepts them. As mentioned earlier, the arguments specified in the option list to &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; undergo the same conversion as the filenames, meaning that the executable is provided with arguments in UTF-8 as well. This translation is avoided consistently with how the filenames are treated, by giving the argument as a binary.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 모듈은 입력 원시 파일명을 받아 들인다. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 도 허용합니다. 앞에서 언급했듯이 옵션 목록에 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 지정된 인수 는 파일 이름과 동일한 변환을 거치므로 실행 파일에도 UTF-8의 인수가 제공됩니다. 이 변환은 인수를 2 진으로 제공하여 파일 이름이 처리되는 방식과 일관되게 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56811d8968fc7cff92a38ee6c1b86759f5455dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module already spread's tags, so there is noo need to manually call these function to get user tags spread to the efile driver through that module.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이 이미 모듈 확산의 태그, 수동으로 해당 모듈을 통해 efile 드라이버로 사용자 태그의 확산을 얻기 위해이 함수를 호출에 NOO 필요가있다.</target>
        </trans-unit>
        <trans-unit id="d1888f67852ce013eb515b48a1f7e3f5fb2b5677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foo&lt;/code&gt; table is replicated on the two nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 테이블은 두 개의 노드에 복제 &lt;code&gt;N1&lt;/code&gt; 과 &lt;code&gt;N2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58cb0b27674de03ef7e6aa8a782a3f05022f6202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fprof&lt;/code&gt; module uses tracing to collect profiling data, hence there is no need for special compilation of any module to be profiled. When it starts tracing, &lt;code&gt;fprof&lt;/code&gt; will erase all previous tracing in the node and set the necessary trace flags on the profiling target processes as well as local call trace on all functions in all loaded modules and all modules to be loaded. &lt;code&gt;fprof&lt;/code&gt; erases all tracing in the node when it stops tracing.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 의 추적 모듈 사용은 따라서 프로파일 링 할 모든 모듈의 특별한 컴파일 필요가 없다, 프로파일 링 데이터를 수집합니다. 추적을 시작하면 &lt;code&gt;fprof&lt;/code&gt; 는 노드에서 이전의 모든 추적을 지우고 프로파일 링 대상 프로세스에서 필요한 추적 플래그와로드 된 모든 모듈 및로드 할 모든 모듈의 모든 함수에 대한 로컬 호출 추적을 설정합니다. &lt;code&gt;fprof&lt;/code&gt; 는 추적을 중지하면 노드의 모든 추적을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2499ac11d982c28fc125b257bd3bdd2fea444c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fqdn_fun&lt;/code&gt; extracts hostnames (Fully Qualified Domain Names) from uri_id or other ReferenceIDs that are not pre-defined in the public_key function. Suppose you have some URI with a very special protocol-part: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt;. Since this a non-standard URI there will be no hostname extracted for matching CN-names in the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fqdn_fun&lt;/code&gt; 의 PUBLIC_KEY 기능에 미리 정의되지 않은 다른 uri_id있는 referenceIds 추출물 호스트 이름 (완전한 도메인 이름). 매우 특별한 protocol-part : &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt; 이있는 URI가 있다고 가정하십시오 . 이것은 비표준 URI이므로 &lt;code&gt;Subject&lt;/code&gt; 에서 CN 이름과 일치하는 호스트 이름이 추출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="122806faca6d67fa7fa167376a0e47c2c49bcb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;message&lt;/code&gt; parameters are exactly what they sound like. &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are visualized in the &lt;code&gt;Viewer&lt;/code&gt; as &quot;lifelines&quot;, with the message passing from one to the other. If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same value, then it is displayed next to the lifeline as an &quot;action&quot;. The &lt;code&gt;extra_stuff&lt;/code&gt;value is simply data that you can attach that will be displayed when someone actually clicks on the action or message in the &lt;code&gt;Viewer&lt;/code&gt; window.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; , 그리고 &lt;code&gt;message&lt;/code&gt; 매개 변수는이 같은 소리 정확히입니다. &lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;to&lt;/code&gt; 메시지 가 &lt;code&gt;Viewer&lt;/code&gt; 에서 &quot;라이프 라인&quot;으로 표시되고 메시지가 서로 전달됩니다. 경우 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 같은 값이며, 다음은 &quot;조치&quot;로 옆 생명선에 표시됩니다. &lt;code&gt;extra_stuff&lt;/code&gt; 의 값은 단순히 누군가가 실제로에서 작업 또는 메시지를 클릭 할 때 표시됩니다 당신이 첨부 할 수있는 데이터입니다 &lt;code&gt;Viewer&lt;/code&gt; 창을여십시오.</target>
        </trans-unit>
        <trans-unit id="87548be67a9ff93c1ef1ff4d3cbb19180b6403f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ftp&lt;/code&gt; module normally accesses the tar file on disk using the &lt;code&gt;file&lt;/code&gt; module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 모듈은 일반적으로 사용하여 디스크에 tar 파일에 액세스 &lt;code&gt;file&lt;/code&gt; 모듈을. 다른 요구가 발생할 경우 저장 매체에서 쓰기 및 읽기를 수행하기 위해 자체 저수준 Erlang 기능을 정의 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="601051b0fdf8cf4c5f5015c05c1f7676f5366f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; is very restricted, it can take only a single parameter (the parameter list to match), a sole variable or a list. It needs to use the &lt;code&gt;is_&lt;/code&gt;XXX guard tests and one cannot use language constructs that have no representation in a match_spec (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; etc). The return value from the fun will be the return value of the resulting match_spec.</source>
          <target state="translated">&lt;code&gt;fun()&lt;/code&gt; 매우 그것은 단지 하나의 매개 변수 (일치하는 매개 변수 목록), 단독 변수 또는 목록을 취할 수 제한됩니다. &lt;code&gt;is_&lt;/code&gt; XXX guard 테스트 를 사용해야하며 match_spec에 표현이없는 언어 구문 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 등)을 사용할 수 없습니다 . fun의 반환 값은 결과 match_spec의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="000806ecedbeddab2e6bf12ee5fe07ca1e33c2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun/2&lt;/code&gt; in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom &lt;code&gt;default&lt;/code&gt;, if the default matching rules shall apply. This makes it possible to augment the tests with a special case:</source>
          <target state="translated">이 옵션 의 &lt;code&gt;fun/2&lt;/code&gt; 는 기본 호스트 이름 일치 규칙을 대체합니다. 재미는 참조 ID와 제시된 ID가 일치하는지 여부를 알리기 위해 부울을 반환해야합니다. 기본 일치 규칙이 적용되는 경우 재미는 세 번째 값인 원자 &lt;code&gt;default&lt;/code&gt; 반환 할 수도 있습니다. 이를 통해 특별한 경우에 테스트를 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52884fca2fcf6439eaac6506d404d211516c579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functions&lt;/code&gt; filter shows each function as a vertical line in the sequence diagram. A function calling itself is shown as an activity within a function, and all other function calls are shown as interactions between functions.</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; 필터는 시퀀스 다이어그램의 수직 라인과 같은 각 기능을 나타낸다. 함수 호출 자체는 함수 내의 활동으로 표시되며 다른 모든 함수 호출은 함수 간의 상호 작용으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f981dcbf4ac48552e64e421603989d6797ca936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;garbage_collect&lt;/code&gt; pseudo function has not got an OWN time of zero like &lt;code&gt;suspend&lt;/code&gt;, instead it is equal to the ACC time.</source>
          <target state="translated">&lt;code&gt;garbage_collect&lt;/code&gt; 의 의사 기능과 같은 제로의 자신의 시간을 가지고하지 않은 &lt;code&gt;suspend&lt;/code&gt; 대신은 ACC 시간과 동일하다.</target>
        </trans-unit>
        <trans-unit id="044322659b6e8af2be19d4c036e45080be4df433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 핸들러 모듈 지정에 콜백 함수 경우) &lt;code&gt;hibernate&lt;/code&gt; 의 리턴 값. 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최대 두 개의 가비지 콜렉션 (최대 절전 모드 및 깨어 난 직후)을 의미하므로 바쁜 이벤트 관리자가 처리하는 각 이벤트간에 수행하려는 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="26a989bcc28ed3e808b806405714b19049fd235b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 초기화 할 수 있습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/3,4&lt;/code&gt; 는 &lt;code&gt;Module:init/1&lt;/code&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fa0125aacc8a9ef2d0db488477563acd091e114f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 절전 모드에 들어갈 수있는 프로세스 (참조 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 콜백 함수를 나타내는 경우에) &lt;code&gt;'hibernate'&lt;/code&gt; 대신에 타임 아웃 값. 서버가 오랫동안 유휴 상태 일 것으로 예상되는 경우 유용 할 수 있습니다. 그러나 최대 절전 모드는 최대 두 개의 가비지 콜렉션 (최대 절전 모드 및 깨어 난 직후)을 의미하므로 사용중인 서버에 대한 각 호출간에 수행하려는 작업이 아니므로이 기능을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93b11bb8bc3cc58fae8df0b4cde4e2b1b7508719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process has been set to trap exit signals.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 처리가 종료 트랩 신호로 설정되었다.</target>
        </trans-unit>
        <trans-unit id="1a0a8f650014835d8fac6303db526f6a6997059c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 비정상적으로 종료되고 오류를 기록합니다. &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a177f7b03da7ce677026ac74a7f1eaf2f38ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior can if this is enabled, regardless of callback mode, automatically &lt;code&gt;call the state callback&lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the state transition rules. It typically looks like this:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 에 이 옵션을 사용하는 경우 동작에 관계없이 콜백 모드, 자동 수 &lt;code&gt;call the state callback&lt;/code&gt; 이 상태를 쓸 수 있도록 상태 변경은 상태 전이 규칙의 나머지 부분에 가까운 동작을 입력 할 때마다 특별한 인수를. 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bed0fd34af6e417a5ed2971b378b4cefa2ed46b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior supports two callback modes:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 동작은 두 개의 콜백 모드를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="17680806ff10db88faa8089ccb57cda1bbf46d1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로 상태 천이하지 &lt;code&gt;NextState&lt;/code&gt; (현재 상태와 동일 할 수있다)을 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b1ba800b2bd8eddab3c29205a82310973e51fec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;State&lt;/code&gt;, which has to be the current state, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 가 에 대한 상태 전이 않는 &lt;code&gt;State&lt;/code&gt; 현재 상태이어야한다, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ff91dbdb67dc0752a1cb136935a70afdac9c712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 자동으로 전문 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 새로운 상태가 입력 될 때마다; &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 모든 상태 항목에 공통적 인 코드를 작성하기위한 것입니다. 이를 수행하는 또 다른 방법은 상태 전이에서 이벤트를 삽입하거나 전용 상태 전이 기능을 사용하는 것입니다. 그러나 모든 상태 전이에서 필요한 상태로 전환 할 때 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="609a55f5722ed6b61803cc1734f944814dbce653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; enqueues incoming events in order of arrival and presents these to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in that order. The state callback can postpone an event so it is not retried in the current state. After a state change the queue restarts with the postponed events.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 받는 도착 선물이 순서대로 들어오는 이벤트를 큐에 넣 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 순서입니다. 상태 콜백은 현재 상태에서 재 시도되지 않도록 이벤트를 연기 할 수 있습니다. 상태 변경 후 연기 된 이벤트와 함께 큐가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="63345530db17175adac9ec3a019543d210266d03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이벤트 큐 모델 선택 수신하여 정상 프로세스 메시지 큐를 에뮬레이트하기에 충분하다. 이벤트 연기는 receive 문에서 이벤트와 일치하지 않는 것에 해당하며 상태 변경은 새 receive 문 입력에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="641237d979ff0a2d03c26c3ad66f07cb507fd0a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; has been set to trap exit signals.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 트랩 출구 신호로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="154bbf6641ffd5663c5aefea121dd325520717a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is globally registered in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 전 세계적으로 등록 된 &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b6a4a7c1fd3b7590f8afba5f3bf9c9be4abb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered on another node.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로컬 다른 노드에 등록된다.</target>
        </trans-unit>
        <trans-unit id="85f1bfb26c1bebdbfe3ea8eee17c7ba7fcaa85f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 로컬로 등록된다.</target>
        </trans-unit>
        <trans-unit id="dff17e2a1fe994c2de42244386fbbe29172ce5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is registered in an alternative process registry. The registry callback module &lt;code&gt;RegMod&lt;/code&gt; is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is the same as &lt;code&gt;{global,GlobalName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 다른 프로세스 레지스트리에 등록됩니다. 레지스트리 콜백 모듈 &lt;code&gt;RegMod&lt;/code&gt; 는 &lt;code&gt;global&lt;/code&gt; 에서 해당 함수처럼 동작하는 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; 및 &lt;code&gt;send/2&lt;/code&gt; 함수를 내보내는 것 입니다. 따라서 &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 은 &lt;code&gt;{global,GlobalName}&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f744ffe4f5b7b57ef92ebf70203f5d38f475257a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state and data, or does a state transition to the current state if you like, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state_and_data&lt;/code&gt; is the same as &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 현재 상태와 데이터를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행하고, 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . 이것은 &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt; 와 동일 합니다. 는 IF &lt;code&gt;gen_statem&lt;/code&gt; 의 와 실행 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , 상태는, 호출이 반복 입력 타입 참조 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , 그렇지 않으면, &lt;code&gt;repeat_state_and_data&lt;/code&gt; 은 동일하다 &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d475ad84f6e39a68e71be16a98a5f4760d76809d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state or does a state transition to the current state if you like, keeps the current server data, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지하거나 만약 당신이 좋아하면, 현재의 상태로 상태 전이를 수행, 현재 서버의 데이터를 유지하고, 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6668d570fa47d65dc6496ac8a7e26666fa0a0e00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . 는 IF &lt;code&gt;gen_statem&lt;/code&gt; 의 와 실행 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , 상태는, 호출이 반복 입력 타입 참조 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;repeat_state&lt;/code&gt; 과 동일 &lt;code&gt;keep_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d700edd0442a4b2cb750903fd91d19af04ce58f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 은 현재 상태를 유지, 또는 당신이 좋아하는 경우에 현재의 상태로 상태 전이를 수행, 설정 &lt;code&gt;NewData&lt;/code&gt; , 모든 실행 &lt;code&gt;Actions&lt;/code&gt; . &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8501d306024ff238059935aefd0de35838afe886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize the server. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; has returned.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 프로세스를 호출 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 서버를 초기화 할 수 있습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/3,4&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a3de78075e1ead85abb08c9961b0132a2121787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 최대 절전 모드로 갈 수있는 공정; &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 이 리턴 된 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 목록 에서 &lt;code&gt;hibernate&lt;/code&gt; 를 지정 하면 완료됩니다 . 이 기능은 서버가 오랫동안 유휴 상태 인 동안 프로세스 힙 메모리를 회수하는 데 유용 할 수 있습니다. 그러나 최대 절전 모드는 모든 이벤트 후에 사용하기에는 너무 많은 비용이들 수 있으므로이 기능을주의해서 사용하십시오. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="881ead844dbebfad51980a814a9a4905aa6bf4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 가 비정상적으로 종료하고 오류를 기록합니다. 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="98d014159aa311c58e42eb49a30b95ce56872c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get-bulk&lt;/code&gt; operation for transferring large amounts of data.</source>
          <target state="translated">&lt;code&gt;get-bulk&lt;/code&gt; 많은 양의 데이터를 전송하기위한 작업.</target>
        </trans-unit>
        <trans-unit id="ca7aa99a53f77bb03e023a14cb8a5dfa322719fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;realm&lt;/code&gt; filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, and assuming at most one of each AVP. If this is not the case then the &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; filters must be used to achieve the desired result. An empty &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (which should not be typical) matches all hosts/realms for the purposes of filtering.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;realm&lt;/code&gt; 목적지 호스트 및 목적지 - 영역의 AVPs 원인 필터 발신 요구로부터 추출 그것이 기록 - 또는 목록 값으로 가정 할 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; , 각 AVP 많아야 하나 가정. 그렇지 않은 경우 원하는 결과를 얻으려면 &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; 필터를 사용해야합니다. 비어있는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (일반적이어서는 안 됨)는 필터링을 위해 모든 호스트 / 영역과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d366d9713f6b9c72596126187499371839fd52b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, the Erlang interpreter.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 모듈은 그래픽 디버거에 의해 사용되는 일부 기능 및 모듈의 기능 중 일부에 대한 단문 제공 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; , 얼랑 인터프리터.</target>
        </trans-unit>
        <trans-unit id="56dd7d3b9f60436a9a9021776dba220b9a35a843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; header represents the number of unique identifiers under a class when the option &lt;code&gt;{combine, true}&lt;/code&gt; is used (which is on by default). It will otherwise show the specific identifier. The &lt;code&gt;db_tab&lt;/code&gt; listing shows 722287 unique locks, it is one for each ets-table created and Mnesia creates one for each transaction.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 헤더는 옵션 클래스에서 고유 식별자의 수를 나타냅니다 &lt;code&gt;{combine, true}&lt;/code&gt; (기본적으로 설정되어 있습니다) 사용됩니다. 그렇지 않으면 특정 식별자가 표시됩니다. &lt;code&gt;db_tab&lt;/code&gt; 쇼에게 722,287 독특한 잠금 목록, 그것은 만든 각 ETS-테이블 하나입니다 Mnesia는 각 거래에 대해 하나 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0fc657f0d7c1adea0e37abaf50e5955d09748ddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="543a86a9dbb014f2154dac485e637aa4987d5f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; type denotes an snmp index structure.</source>
          <target state="translated">&lt;code&gt;index()&lt;/code&gt; 유형은 SNMP의 인덱스 구조를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="9e43b2120ef1641713607a20d5663b50e4bfd154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; field of a &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; record. Can have one of the following types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; 레코드 의 &lt;code&gt;info&lt;/code&gt; 필드 다음 유형 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3e0c6a3b85d7da20be620618cd94e4069d8c32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; functions return information as a list of pairs {Tag, term()} in some order about the state and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 기능 쌍 상태에 대한 어떤 순서로 {태그, 용어 ()}와 목록 등의 정보를 반환 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1b7238dd78cc738fd7a6138cfed66a0946104d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init:get_arguments()&lt;/code&gt; call verifies that the correct arguments are supplied to the emulator.</source>
          <target state="translated">&lt;code&gt;init:get_arguments()&lt;/code&gt; 올바른 인수가 에뮬레이터에 공급되는 통화 확인합니다.</target>
        </trans-unit>
        <trans-unit id="de26f216cc9cb8c745717da43fc15ae4239618cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 모듈 해석 다음 명령 줄 플래그 :</target>
        </trans-unit>
        <trans-unit id="9159e5b3d2da59b16c5905eba93189ce3aa15286" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; process itself interprets some of these flags, the &lt;strong&gt;init flags&lt;/strong&gt;. It also stores any remaining flags, the &lt;strong&gt;user flags&lt;/strong&gt;. The latter can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 과정 자체는 이러한 플래그 중 일부는 해석 &lt;strong&gt;초기화하기 플래그&lt;/strong&gt; . 또한 나머지 플래그 인 &lt;strong&gt;사용자 플래그&lt;/strong&gt; 도 저장합니다 . 후자는 &lt;code&gt;init:get_argument/1&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00463fc2a7f182be0da0183c5213eee9fd19f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert_emp/3&lt;/code&gt; arguments are as follows:</source>
          <target state="translated">&lt;code&gt;insert_emp/3&lt;/code&gt; 다음과 같이 인수는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="35e63d83642fa80f496dd6056b90a430ea6b3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; module has been extended along with the actual I/O protocol to handle Unicode data. This means that many functions require binaries to be in UTF-8, and there are modifiers to format control sequences to allow for output of Unicode strings.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈은 유니 코드 데이터를 처리하기위한 실제 I / O 프로토콜에 따라 연장되고있다. 이것은 많은 함수들이 바이너리가 UTF-8이어야한다는 것을 의미하며, 유니 코드 문자열의 출력을 허용하기 위해 제어 시퀀스를 포맷팅하기위한 수정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc6624cbf5af8be037d2670ec76b72f4b7f1113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip&lt;/code&gt; Reference ID takes an &lt;code&gt;inet:ip_address()&lt;/code&gt; or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element.</source>
          <target state="translated">&lt;code&gt;ip&lt;/code&gt; 기준 ID가 얻어 &lt;code&gt;inet:ip_address()&lt;/code&gt; 또는 문자열 포맷 (예 : &quot;10.0.1.1&quot;또는 &quot;1234 : 5678 : 9012 ')의 IP 주소 등을 제 소자.</target>
        </trans-unit>
        <trans-unit id="a7ee8c582d46917ec81790ab0ac53e2589a28393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is_set_ok&lt;/code&gt; function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</source>
          <target state="translated">&lt;code&gt;is_set_ok&lt;/code&gt; 의 기능 검사 수정 또는 삭제하고자하는 행이 존재하는 것으로하고, 형성되어야 할 행이 존재하지 않음.</target>
        </trans-unit>
        <trans-unit id="ff7f1bbdc59c16a06c62efdccc8b7854b7407424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key()&lt;/code&gt; type correlates to the &lt;code&gt;key_types()&lt;/code&gt; type. If the &lt;code&gt;key_types()&lt;/code&gt; is a single atom, the corresponding &lt;code&gt;key()&lt;/code&gt; is a single type as well, but if the &lt;code&gt;key_types()&lt;/code&gt; is a tuple, &lt;code&gt;key&lt;/code&gt; must be a tuple of the same size.</source>
          <target state="translated">&lt;code&gt;key()&lt;/code&gt; 받는 유형의 상관 관계 &lt;code&gt;key_types()&lt;/code&gt; 형입니다. 경우] &lt;code&gt;key_types()&lt;/code&gt; 단일 원자이고, 해당 &lt;code&gt;key()&lt;/code&gt; 뿐만 아니라 하나의 형태이지만, 경우 &lt;code&gt;key_types()&lt;/code&gt; 튜플이고, &lt;code&gt;key&lt;/code&gt; 크기가 같은 튜플이어야한다.</target>
        </trans-unit>
        <trans-unit id="5cac72dd809c7185a7dcb83183f4f89c08277c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type defines the types of the SNMP INDEX columns for the table. If the table has one single INDEX column, this type should be a single atom, but if the table has multiple INDEX columns, it should be a tuple with atoms.</source>
          <target state="translated">&lt;code&gt;key_types()&lt;/code&gt; 유형은 테이블에 대한 SNMP INDEX 컬럼의 유형을 정의합니다. 테이블에 단일 INDEX 열이있는 경우이 유형은 단일 원자 여야하지만 테이블에 여러 INDEX 열이있는 경우 원자가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a81df154de4b4c4f859872829034600f9ab7e463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type is used when creating the index structure, and the &lt;code&gt;key()&lt;/code&gt; type is used when inserting and deleting items from the structure.</source>
          <target state="translated">&lt;code&gt;key_types()&lt;/code&gt; 인덱스 구조를 생성 할 때 입력이 사용되고, &lt;code&gt;key()&lt;/code&gt; 삽입 한 구조의 항목 유형을 삭제할 때 사용된다.</target>
        </trans-unit>
        <trans-unit id="555d2dccfadbf0b7e5219e84813fd3bd45eaaf5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypos&lt;/code&gt; of the table dumped to file, which is used when loading the table again.</source>
          <target state="translated">테이블 의 키 &lt;code&gt;keypos&lt;/code&gt; 는 파일에 덤프되어 테이블을 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7afe180cd162bc0e597b4a20726157b5ac4e0bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;killproc&lt;/code&gt; procedure is not to be removed. The purpose is here to move from run level 3 (multi-user mode with networking resources) to run level 2 (multi-user mode without such resources), in which Erlang is not to run.</source>
          <target state="translated">&lt;code&gt;killproc&lt;/code&gt; 의 절차는 제거 할 수 없습니다. Erlang이 실행되지 않는 실행 레벨 3 (네트워킹 자원이있는 다중 사용자 모드)에서 실행 레벨 2 (이러한 자원이없는 다중 사용자 모드)로 이동하는 것이 목적입니다.</target>
        </trans-unit>
        <trans-unit id="03c484e3840400c5a5e9dd6a195fc19b5d1faa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, &lt;code&gt;label&lt;/code&gt; is used to identify the separate traces. Default is 0.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 구성 요소는 동일한 연속 추적에 속하는 모든 이벤트를 식별하는 용어입니다. 여러 순차 추적을 동시에 활성화 할 수있는 경우 &lt;code&gt;label&lt;/code&gt; 을 사용하여 개별 추적을 식별합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="8ada4b47638c77da9291a9bd47140e9b15fe504a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_free&lt;/code&gt; and &lt;code&gt;number_of_free&lt;/code&gt; tags are currently only returned on a VxWorks system.</source>
          <target state="translated">&lt;code&gt;largest_free&lt;/code&gt; 및 &lt;code&gt;number_of_free&lt;/code&gt; 태그는 현재 만 Vx 웍스 시스템에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47c985889700e94be33eba8b924bf9a3dfed0540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lcnt&lt;/code&gt; module is used to profile the internal ethread locks in the Erlang Runtime System. With &lt;code&gt;lcnt&lt;/code&gt; enabled, internal counters in the runtime system are updated each time a lock is taken. The counters stores information about the number of acquisition tries and the number of collisions that has occurred during the acquisition tries. The counters also record the waiting time a lock has caused for a blocked thread when a collision has occurred.</source>
          <target state="translated">&lt;code&gt;lcnt&lt;/code&gt; 의 모듈 얼랑 런타임 시스템의 내부 ETHREAD 잠금 프로파일 사용된다. 함께 &lt;code&gt;lcnt&lt;/code&gt; 이 활성화 런타임 시스템 내부 카운터는 잠금이 수행 될 때마다 업데이트됩니다. 카운터에는 획득 시도 횟수 및 획득 시도 중에 발생한 충돌 횟수에 대한 정보가 저장됩니다. 카운터는 충돌이 발생할 때 차단 된 스레드에 대해 잠금이 발생한 대기 시간도 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b187fc5e5c5e9c948af3fd95dc59f5d10e6fe566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list_in&lt;/code&gt; 의 용어는 환경에 속해야합니다 &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2831975c1bbe04314d3d0e20134569769f4c8e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_mf_h&lt;/code&gt; handler writes all reports to a report logging directory, which is specified when configuring the SASL application.</source>
          <target state="translated">&lt;code&gt;log_mf_h&lt;/code&gt; 의 핸들러는 SASL 응용 프로그램을 구성 할 때 지정 보고서 로깅 디렉토리로 모든 보고서를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c42c9a83ba0cfd927135745afcf8a51d16e0e657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_in&lt;/code&gt; 의 용어는 환경에 속해야합니다 &lt;code&gt;env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4596e3e12adaafb27a37675223c89e5e8290b48e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match_fun&lt;/code&gt; takes two arguments and returns either &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;. The value &lt;code&gt;default&lt;/code&gt; will invoke the default match function.</source>
          <target state="translated">&lt;code&gt;match_fun&lt;/code&gt; 는 두 개의 인수 및 반환 소요 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; . 값 &lt;code&gt;default&lt;/code&gt; 기본 match 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8b940d5eaace9d3d7a8384b7f450246290a324ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_path_length&lt;/code&gt; is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if &lt;code&gt;max_path_length&lt;/code&gt; is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.</source>
          <target state="translated">&lt;code&gt;max_path_length&lt;/code&gt; 는 유효한 인증 경로에서 피어 인증서를 따를 수 자기 발행이 아닌 중간 인증서의 최대 수입니다. 따라서 &lt;code&gt;max_path_length&lt;/code&gt; 가 0이면 신뢰할 수있는 ROOT-CA가 PEER에 직접 서명해야합니다. 1 인 경우 경로는 PEER, CA, ROOT-CA 일 수 있습니다. 2 인 경우 경로는 PEER, CA, CA, ROOT-CA 등</target>
        </trans-unit>
        <trans-unit id="38b7f85ec648548ce222a27921a129e6b78760bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mib_to_hrl&lt;/code&gt; generator can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.bin&lt;/code&gt;, and invokes this function for files with that extension.</source>
          <target state="translated">&lt;code&gt;mib_to_hrl&lt;/code&gt; 의 발생기는 명령을 사용하여 OS 명령 라인에서 호출 할 수 &lt;code&gt;erlc&lt;/code&gt; 를 . &lt;code&gt;erlc&lt;/code&gt; 는 확장자 &lt;code&gt;.bin&lt;/code&gt; 을 인식하고 해당 확장자를 가진 파일에 대해이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8c1d578ccfe04ced0a4858e6e98da0fd19d29b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mods_and_procs&lt;/code&gt; and &lt;code&gt;funcs_and_procs&lt;/code&gt; filters are equivalent to the &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;functions&lt;/code&gt; filters respectively, except that each module or function can have many vertical lines, one for each process it resides on.</source>
          <target state="translated">&lt;code&gt;mods_and_procs&lt;/code&gt; 및 &lt;code&gt;funcs_and_procs&lt;/code&gt; 의 필터는 동등한 &lt;code&gt;modules&lt;/code&gt; 및 &lt;code&gt;functions&lt;/code&gt; 각 모듈 또는 기능이 다양한 수직선이 상주하는 각 공정을 가질 수 있다는 것을 제외하고는, 각각의 필터.</target>
        </trans-unit>
        <trans-unit id="629670db402f7cde732ec01282578c7159f3daad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; functions of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 옵션은 가능한 사용자가 자신의 콜백 모듈을 제공 할 수 있습니다. 이 모듈 의 &lt;code&gt;receive_message/4&lt;/code&gt; 또는 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수는 새 메시지가 수신 될 때 호출됩니다 (메시지의 크기에 따라 다릅니다. small-receive_message, large-process_received_message). 기본값은 &lt;strong&gt;megaco&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4039dc8c38a872b706a72298a0693bdeed53b2b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The functions &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 옵션은 가능한 사용자가 자신의 콜백 모듈을 제공 할 수 있습니다. 이 모듈의 &lt;code&gt;receive_message/4&lt;/code&gt; 또는 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수 는 새 메시지가 수신 될 때 호출됩니다 (메시지 크기에 따라 다릅니다. small-receive_message, large-process_received_message). 기본값은 &lt;strong&gt;megaco&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1fa747bd68db4bc817397fca349049b0c0c2bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_info/0&lt;/code&gt; function in each module, returns a list of &lt;code&gt;{Key,Value}&lt;/code&gt; tuples with information about the module. Currently, the list contain tuples with the following &lt;code&gt;Key&lt;/code&gt;s: &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt;, &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;. The order and number of tuples may change without prior notice.</source>
          <target state="translated">각 모듈 의 &lt;code&gt;module_info/0&lt;/code&gt; 함수는 모듈에 대한 정보와 함께 &lt;code&gt;{Key,Value}&lt;/code&gt; 튜플 목록을 리턴 합니다. 현재 목록은 다음과 튜플 포함 &lt;code&gt;Key&lt;/code&gt; : S &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; , &lt;code&gt;compile&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; , &lt;code&gt;md5&lt;/code&gt; 및 &lt;code&gt;native&lt;/code&gt; . 튜플의 순서와 수는 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c3af4d94c692779fc270d51ec8836243a76c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; filter shows each module as a vertical line in the sequence diagram. External function calls/returns are shown as interactions between modules, and internal function calls/returns are shown as activities within a module.</source>
          <target state="translated">는 &lt;code&gt;modules&lt;/code&gt; 필터 프로그램을 시퀀스 다이어그램 수직선 각 모듈. 외부 함수 호출 / 반환은 모듈 간의 상호 작용으로 표시되고 내부 함수 호출 / 반환은 모듈 내 활동으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="220a661131b4c202e09615fa7794089d54019aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not given, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;[M]&lt;/code&gt; 이며, 여기서 &lt;code&gt;M&lt;/code&gt; 은 자녀의 시작 &lt;code&gt;{M,F,A}&lt;/code&gt; 에서옵니다 .</target>
        </trans-unit>
        <trans-unit id="3890e0d50c45d6e12a18dbc1aec19b335349f526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 키는 선택 사항입니다. 지정되지 않은 경우 기본값은 &lt;code&gt;[M]&lt;/code&gt; 이며 여기서 &lt;code&gt;M&lt;/code&gt; 은 자식의 시작 &lt;code&gt;{M,F,A}&lt;/code&gt; 에서옵니다 .</target>
        </trans-unit>
        <trans-unit id="b73b08f6879f5bf7ade5d9880f8cf1f512709fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native&lt;/code&gt; time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the &lt;code&gt;native&lt;/code&gt; time unit of the new runtime system instance can differ from the &lt;code&gt;native&lt;/code&gt; time unit of the old runtime system instance.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 시간 단위는 런타임 시스템 시작시에 결정되고, 런타임 시스템이 종료 될 때까지 동일하게 유지된다. 런타임 시스템이 정지하고 (심지어 동일한 시스템에) 다시 시작하면, &lt;code&gt;native&lt;/code&gt; 새로운 런타임 시스템 인스턴스의 시간 단위는 다를 수 있습니다 &lt;code&gt;native&lt;/code&gt; 이전 런타임 시스템 인스턴스의 시간 단위.</target>
        </trans-unit>
        <trans-unit id="e77d232e74f552cf373975f9713b96716de00e8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_kernel&lt;/code&gt; process terminated.</source>
          <target state="translated">&lt;code&gt;net_kernel&lt;/code&gt; 의 프로세스가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="33c94a1185ccb7943d79b55ac568ef3bf3963cc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_ticktime&lt;/code&gt; changes must be initiated on all nodes in the network (with the same &lt;code&gt;NetTicktime&lt;/code&gt;) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</source>
          <target state="translated">&lt;code&gt;net_ticktime&lt;/code&gt; 의 변화가 (과 동일한 네트워크의 모든 노드에서 시작되어야 &lt;code&gt;NetTicktime&lt;/code&gt; 노드에서 임의의 천이 기간이 종료하기 전에); 그렇지 않으면 연결이 잘못 끊어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d35276b805d419b7b2b451eec9f43dfbe3fb9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;reuse&lt;/code&gt; options might seem convenient in a production system, but consider that the logs grow indefinitely during the system lifetime and cannot be truncated, except if the service is restarted.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;reuse&lt;/code&gt; 옵션은 생산 시스템에 편리하게 보이지만, 로그는 서비스를 다시 시작하는 경우를 제외하고, 시스템 수명 기간 동안 무한정 성장하고 절단 될 수 없음을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffcaa93ee15ba09c39cb246f4b83efb0388fde54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates a new variable in the database with a default value as defined in the MIB, or a zero value (depending on the type).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 기능은 MIB에 정의 된 바와 같은 디폴트 값 또는 0 값 (유형에 따라)와 데이터베이스에서 새로운 변수를 생성한다.</target>
        </trans-unit>
        <trans-unit id="2000d16d511f7d3865cad4dec402c68d50d75e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates the table if it does not exist, but only if the database is the SNMP internal db.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 존재하지 않는 경우 기능은 테이블을 생성하지만 경우에만 데이터베이스는 SNMP 내부 dB이다.</target>
        </trans-unit>
        <trans-unit id="fe241cbaac0cb96b60c93ae96dc9889cf2b5f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">&lt;code&gt;nteventlog&lt;/code&gt; 모듈을 구현하는 데 사용됩니다 &lt;code&gt;os_sup&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;nteventlog&lt;/code&gt; 의 시작 기능을 사용할 필요는 없습니다.이 경우 프로세스는 OS_Mon 감독 트리의 일부로 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e2bfdbeebfa5a9fe7cf75fe729c76e05070db8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 인수는 자원에 대한 포인터입니다. 소멸자의 리소스에 허용되는 유일한 용도는 마지막으로 사용자 데이터에 액세스하는 것입니다. 소멸자는 리소스 할당이 해제되기 전에 마지막 콜백이되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7ceb6922f1bc2b55a11a196aefd83fd27d2d6cd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; if no chain of calls between the given constants can be found.</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; 운영자는 반환 &lt;code&gt;false&lt;/code&gt; 주어진 상수 사이의 호출에는 체인이 발견되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="edc8f1a9759344cda2be6a01281eb7cf8541e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;after&lt;/code&gt; sections are all optional, as long as there is at least a &lt;code&gt;catch&lt;/code&gt; or an &lt;code&gt;after&lt;/code&gt; section. So the following are valid &lt;code&gt;try&lt;/code&gt; expressions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , 그리고 &lt;code&gt;after&lt;/code&gt; 섹션은 한 적어도이있는 한, 모든 선택 사항 &lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;after&lt;/code&gt; 섹션. 따라서 다음은 유효한 &lt;code&gt;try&lt;/code&gt; 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ebc057ad457a36d0493c7c4827deec0d89f9db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid()&lt;/code&gt; type is used to represent an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">&lt;code&gt;oid()&lt;/code&gt; 유형은 ASN.1 객체 식별자를 나타내는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="c317ddfbc946c81f789ac77305cd9d495bd67257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordered_set&lt;/code&gt; works on the &lt;strong&gt;Erlang term order&lt;/strong&gt; and no defined order exists between an &lt;code&gt;integer()&lt;/code&gt; and a &lt;code&gt;float()&lt;/code&gt; that extends to the same value. Hence the key &lt;code&gt;1&lt;/code&gt; and the key &lt;code&gt;1.0&lt;/code&gt; are regarded as equal in an &lt;code&gt;ordered_set&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; 온 작동 &lt;strong&gt;얼랑 용어 위해&lt;/strong&gt; 어떠한 정의 된 순서는 존재하지 사이 &lt;code&gt;integer()&lt;/code&gt; 및 &lt;code&gt;float()&lt;/code&gt; 와 동일한 값으로 연장한다. 따라서 키 &lt;code&gt;1&lt;/code&gt; 과 키 &lt;code&gt;1.0&lt;/code&gt; 은 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 에서 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="23f84a949184c1de5bc030233161e9c4c0b92121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;originating&lt;/code&gt; options effects discovery initiated by this agent.</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 이 에이전트에 의해 시작 옵션 효과 발견.</target>
        </trans-unit>
        <trans-unit id="ccd973135b90cc097810c0c2b724141ea8487e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; syntax:</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 구문 :</target>
        </trans-unit>
        <trans-unit id="8bdd7004ea407fa82763663af39ba15a0e1f25f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; tool utilizes the &lt;code&gt;runtime_dependencies&lt;/code&gt; tag in the &lt;code&gt;application resource file&lt;/code&gt;. This information is used to determine if the patch can be installed in the given Erlang/OTP installation directory.</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 도구는 사용 &lt;code&gt;runtime_dependencies&lt;/code&gt; 의 태그 &lt;code&gt;application resource file&lt;/code&gt; . 이 정보는 패치가 지정된 Erlang / OTP 설치 디렉토리에 설치 될 수 있는지 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8315d03358900e027c0447a981ac995840fffee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; function allocates the work area of the asynchronous function. As we use C++, we use a struct, and stuff the data in it. We must copy the original data, it is not valid after we have returned from the &lt;code&gt;output&lt;/code&gt; function, and the &lt;code&gt;do_perm&lt;/code&gt; function is called later, and from another thread. We return no data here, instead it is sent later from the &lt;code&gt;ready_async&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 함수는 함수의 비동기 작업 영역을 할당한다. C ++을 사용할 때 구조체를 사용하고 그 안에 데이터를 넣습니다. 원래 데이터를 복사해야합니다. &lt;code&gt;output&lt;/code&gt; 함수 에서 리턴 된 후에는 유효하지 않으며 &lt;code&gt;do_perm&lt;/code&gt; 함수는 나중에 호출되며 다른 스레드에서 호출됩니다. 여기서는 데이터를 반환하지 않으며 대신 &lt;code&gt;ready_async&lt;/code&gt; 콜백 에서 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="71aa4ffe227f9aa33da51854c389c54a822efeef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; format is an internal representation that can be passed to &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;forms&lt;/code&gt; format can be passed to &lt;code&gt;compile:forms/2&lt;/code&gt;. The &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;hrl&lt;/code&gt; formats are returned as iolists.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; 형식으로 전달 될 수있는 내부 표현 &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt; 그동안, &lt;code&gt;forms&lt;/code&gt; 형식으로 전달 될 수 &lt;code&gt;compile:forms/2&lt;/code&gt; . &lt;code&gt;erl&lt;/code&gt; 과 &lt;code&gt;hrl&lt;/code&gt; 형식 iolists로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9ac6e1b83188e6ba00253b80c4e4e283b31e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option is used for pointing out the old version of all applications. (The new versions are already in the code path - assuming of course that the Erlang node on which this is executed is running the correct version of Erlang/OTP.)</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 옵션은 모든 응용 프로그램의 이전 버전을 지적하는 데 사용됩니다. (이 버전이 실행되는 Erlang 노드가 올바른 버전의 Erlang / OTP를 실행하고 있다고 가정하면 새 버전은 이미 코드 경로에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="24e00a9507fa707a286aad7abe3e3cd07325080a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pending_driver&lt;/code&gt;&lt;code&gt;MonitorOption&lt;/code&gt; is by far the most useful. It must be used to ensure that the driver really is unloaded and the ports closed whenever option &lt;code&gt;kill_ports&lt;/code&gt; is used, or the driver can have been loaded with driver option &lt;code&gt;kill_ports&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pending_driver&lt;/code&gt; 의 &lt;code&gt;MonitorOption&lt;/code&gt; 는 지금까지 가장 유용한 것입니다. &lt;code&gt;kill_ports&lt;/code&gt; 옵션을 사용하거나 드라이버 옵션 &lt;code&gt;kill_ports&lt;/code&gt; 로 드라이버를로드 할 수있을 때마다 드라이버가 실제로 언로드되고 포트가 닫히 도록해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f36e06928220660615452de6fef2258f5362fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt;os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perf_counter&lt;/code&gt; 의 시간 단위는 거의 같은 방식으로 동작 &lt;code&gt;native&lt;/code&gt; 시간 단위. 즉, 런타임 재시작마다 다를 수 있습니다. 이 유형의 값을 얻으려면 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ff6f3b7d18bc68a03a8f098e3306bea8afa3388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pread/3,4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;pread/3,4&lt;/code&gt; - 함수는 결합, 소정 위치로부터 판독 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="8ade504b785b0942df35eaf3b82afa6476a54cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended it does so in a structured manner.</source>
          <target state="translated">&lt;code&gt;priv&lt;/code&gt; 디렉토리는 응용 프로그램을 실행하는 동안 필요로하는 자산을 보유하고 있습니다. 실행 파일은 &lt;code&gt;priv/bin&lt;/code&gt; 에 있어야 하고 동적으로 연결된 라이브러리는 &lt;code&gt;priv/lib&lt;/code&gt; 에 있어야합니다 . 다른 자산은 내 상주 자유롭게 &lt;code&gt;priv&lt;/code&gt; 디렉토리 있지만이 구조화 된 방식으로 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a744587962b51e3c606263db57ff07f274e44a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processes&lt;/code&gt; filter is the only filter showing all trace messages from a trace log. Each vertical line in the sequence diagram represents a process. Erlang messages, spawn, and link/unlink are typical interactions between processes. Function calls, scheduling, and garbage collection, are typical activities within a process. &lt;code&gt;processes&lt;/code&gt; is the default filter.</source>
          <target state="translated">&lt;code&gt;processes&lt;/code&gt; 필터는 추적 로그에서 모든 추적 메시지를 보여주는 유일한 필터입니다. 시퀀스 다이어그램의 각 세로선은 프로세스를 나타냅니다. Erlang 메시지, 스폰 및 링크 / 링크 해제는 프로세스 간의 일반적인 상호 작용입니다. 함수 호출, 스케줄링 및 가비지 콜렉션은 프로세스 내의 일반적인 활동입니다. &lt;code&gt;processes&lt;/code&gt; 는 기본 필터입니다.</target>
        </trans-unit>
        <trans-unit id="3861f99e16c84fe5707ca3129e815480d2eca579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwrite/3,4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;pwrite/3,4&lt;/code&gt; 함수는 결합, 소정 위치에 기록 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="a4939b64de1d53ed04f7d5997288438bc45d2be8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module evaluates this differently depending on the query handles &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;. If, for example, &lt;code&gt;X2&lt;/code&gt; is matched against the key of a QLC table, the lookup join method traverses the objects of &lt;code&gt;QH2&lt;/code&gt; while looking up key values in the table. However, if not &lt;code&gt;X2&lt;/code&gt; or &lt;code&gt;Y2&lt;/code&gt; is matched against the key or an indexed position of a QLC table, the merge join method ensures that &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; are both sorted on position 2 and next do the join by traversing the objects one by one.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈 평가하여이 다른 쿼리에 따라 핸들 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 을 . 예를 들어 &lt;code&gt;X2&lt;/code&gt; 가 QLC 테이블의 키와 일치하는 경우, 조회 조인 메소드 는 테이블에서 키 값을 찾는 동안 &lt;code&gt;QH2&lt;/code&gt; 의 오브젝트를 순회 합니다. 그러나 &lt;code&gt;X2&lt;/code&gt; 또는 &lt;code&gt;Y2&lt;/code&gt; 가 QLC 테이블의 키 또는 인덱싱 된 위치와 일치 하지 않으면 , 병합 조인 방법은 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 가 위치 2에서 정렬되고 다음으로 오브젝트를 하나씩 순회하여 결합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7bdc283a4e0d387d9b4fe3c9cce9b3813bddfd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module supports fast join of two query handles. Fast join is possible if some position &lt;code&gt;P1&lt;/code&gt; of one query handler and some position &lt;code&gt;P2&lt;/code&gt; of another query handler are tested for equality. Two fast join methods are provided:</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈을 지원하는 빠른 두 개의 쿼리 핸들의 결합. 일부 고속 위치한다면 가능 가입 &lt;code&gt;P1&lt;/code&gt; 한 쿼리 처리기 및 일부의 위치 &lt;code&gt;P2&lt;/code&gt; 다른 쿼리 핸들러가 어떤지를 시험한다. 두 가지 빠른 결합 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc69ce9649099f1a16568929e4dca5a9ec4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 같은 방법 점에서 QLC 수확기 쿼리 핸들 많은 사람이 참여보다 가능한 경우 모듈은 컴파일시에 경고합니다. 즉, 가능한 조인 작업간에 적절한 순서를 선택할 수있는 쿼리 플래너가 제공되지 않습니다. 쿼리 핸들을 도입하여 조인을 주문하는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="1ac4329d09995d8cc50dafbae48fcd60ee3ef172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re&lt;/code&gt; module allows for matching Unicode strings as a special option. As the library is centered on matching in binaries, the Unicode support is UTF-8-centered.</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 모듈은 특별한 옵션으로 유니 코드 문자열을 일치 수 있습니다. 라이브러리가 바이너리에서 일치하는 것을 중심으로하기 때문에 유니 코드 지원은 UTF-8 중심입니다.</target>
        </trans-unit>
        <trans-unit id="412cfcfb79171f8451db72dbfc6769aeeae48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_ahead&lt;/code&gt; buffer is also highly used by function &lt;code&gt;read_line/1&lt;/code&gt; in &lt;code&gt;raw&lt;/code&gt; mode, therefore this option is recommended (for performance reasons) when accessing raw files using that function.</source>
          <target state="translated">&lt;code&gt;read_ahead&lt;/code&gt; 버퍼는 높은 기능에 의해 사용된다 &lt;code&gt;read_line/1&lt;/code&gt; 에서 &lt;code&gt;raw&lt;/code&gt; 그 함수를 사용하여 원시 파일을 액세스 할 때, 따라서이 옵션은 (성능의 이유로) 권장 모드.</target>
        </trans-unit>
        <trans-unit id="1d7e68fecfc79e8020cc09ac14cad9865216cb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_io&lt;/code&gt; function is called when the socket we got from postgres is ready for input or output. Here we first check if we are connecting to the database. In that case, we check connection status and return OK if the connection is successful, or error if it is not. If the connection is not yet established, we simply return; &lt;code&gt;ready_io&lt;/code&gt; is called again.</source>
          <target state="translated">&lt;code&gt;ready_io&lt;/code&gt; 우리가 포스트 그레스에서 가져온 소켓의 입력 또는 출력을위한 준비가되면 함수가 호출됩니다. 먼저 데이터베이스에 연결되어 있는지 확인합니다. 이 경우 연결 상태를 확인하고 연결에 성공하면 확인을 반환하고 연결에 실패하면 오류를 반환합니다. 연결이 아직 설정되지 않은 경우 간단히 반환합니다. &lt;code&gt;ready_io&lt;/code&gt; 가 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f336c46236fef6d33a9737fecfbc45848cc85a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; construct is used to allow processes to wait for messages from other processes. It has the following format:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 구조는 프로세스가 다른 프로세스의 메시지를 기다릴 수 있도록하는 데 사용됩니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37481113af1fc6bf67ec51a1b4573b5766d4940d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; expression can be augmented with a timeout:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 발현은 타임 아웃을 통해 확장 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="42725fa1b02c7390bf310c7b5f650def33047bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receiver&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; 먼저 전송한다 &lt;code&gt;snmp_targets&lt;/code&gt; 의 각 주소에 대한 다음 메시지 및 &lt;code&gt;Addresses&lt;/code&gt; 리스트, 이들의 하나 &lt;code&gt;snmp_notification&lt;/code&gt; 된 메시지.</target>
        </trans-unit>
        <trans-unit id="e35f7f5fad0e5d56316957219823696de6e6786c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refc&lt;/code&gt; 필드가 제거되었습니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 카운트 가 이제 다른 곳에 저장됩니다. &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 참조 카운트는 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="660ed54d5ac1fcd2169600b38b40bd925d66cf86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_handler&lt;/code&gt; copies these files to the &lt;code&gt;bin&lt;/code&gt; directory in the client directory at the master nodes whenever a new release is made permanent.</source>
          <target state="translated">&lt;code&gt;release_handler&lt;/code&gt; 복사 이러한 파일 &lt;code&gt;bin&lt;/code&gt; 새로운 버전을 영구적으로 될 때마다 마스터 노드에서 클라이언트 디렉토리에 디렉토리를.</target>
        </trans-unit>
        <trans-unit id="56830d582041a2d058cd8b9ca80ec725e5c3e287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reload&lt;/code&gt; option can be either of the following:</source>
          <target state="translated">&lt;code&gt;reload&lt;/code&gt; 옵션 중 하나를 다음 중 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="207c0a4a6dd7d54555e6c470a0c170ec46378f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains instructions for how to upgrade to, or downgrade from, this version of the release.</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; 의 파일로 업그레이드하거나 릴리스 버전에서 다운 그레이드하는 방법에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb051013f36a233ac41b404b8075c071558087a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade the release. The file has the following syntax:</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; 의 파일은 릴리스로 업그레이드하는 데 사용되는 지침을 정의하는 하나 개의 얼랑 용어가 포함되어 있습니다. 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d56076bd8991e00d489d3da464bc1ef66915e244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply_timer&lt;/code&gt; eventually times out.</source>
          <target state="translated">&lt;code&gt;reply_timer&lt;/code&gt; 은 결국 시간 초과.</target>
        </trans-unit>
        <trans-unit id="3918ee266b06587588695e693fc72ac650418ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;permanent&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 &lt;code&gt;permanent&lt;/code&gt; 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa12db49496616557ec440b620daa191bf27cdc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;restart&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;permanent&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6a92effc8d3efc4277861eec34f0f1caed07816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction must always be the first instruction in a relup. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">&lt;code&gt;restart_new_emulator&lt;/code&gt; 의 명령은 항상 relup의 첫 번째 명령해야합니다. reltools가 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성되면 자동으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="11d3f640ffec2cfdf0c8a6e928ab7cecff319eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_erl&lt;/code&gt; program is specific to Unix systems. This program redirects the standard input and standard output streams so that all output can be logged. It also lets the program &lt;code&gt;to_erl&lt;/code&gt; connect to the Erlang console, making it possible to monitor and debug an embedded system remotely.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; 의 프로그램은 유닉스 시스템에만 적용됩니다. 이 프로그램은 모든 출력을 기록 할 수 있도록 표준 입력 및 표준 출력 스트림을 리디렉션합니다. 또한 프로그램 &lt;code&gt;to_erl&lt;/code&gt; 을 Erlang 콘솔에 연결하여 임베디드 시스템을 원격으로 모니터링하고 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750c30ae5ba824b2f2aab4a171c99b419364a053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime_dependencies&lt;/code&gt; key was introduced in OTP 17.0. The type of its value might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;runtime_dependencies&lt;/code&gt; 의 키는 OTP 17.0 년에 도입되었다. 해당 값의 유형은 OTP 17 릴리스 중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d8491d2a1375817a9cf2b814c2646acf960284" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sasl&lt;/code&gt; 애플리케이션은 예 얼랑 모듈 포함 &lt;code&gt;target_system.erl&lt;/code&gt; 만들고 타겟 시스템을 설치하기위한 기능을 포함. 이 모듈은 다음 예에서 사용됩니다. 모듈의 소스 코드 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 나열되어 있습니다</target>
        </trans-unit>
        <trans-unit id="3906ed9fb14f8072e02da2d35e2b47f21b0a6292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; expression matches all entries in table employee with the field &lt;code&gt;sex&lt;/code&gt; set to &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 표현식은 필드와 테이블 직원의 모든 항목과 일치 &lt;code&gt;sex&lt;/code&gt; 으로 설정 &lt;code&gt;female&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5c2c9e1f5cbdb80c6a7e6b52821b6b12fa676f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; flags enable tracing of all messages sent and received by the process/port. Trace patterns set with &lt;code&gt;tpe&lt;/code&gt; may limit traced messages based on the message content, the sender, and/or the receiver.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;'receive'&lt;/code&gt; 플래그는 모든 메시지의 추적을하는 것은 전송 프로세스 / 포트에서 수신 할 수 있습니다. &lt;code&gt;tpe&lt;/code&gt; 로 설정된 추적 패턴 은 메시지 내용, 발신자 및 / 또는 수신자에 따라 추적 된 메시지를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0233a943ab6f52106ec90bb0ab714ed2cd9deb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; call does not accept a time-out option because time-outs on send is handled through socket option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with no receiver is mainly defined by the underlying TCP stack and the network infrastructure. To write code that handles a hanging receiver that can eventually cause the sender to hang on a &lt;code&gt;send&lt;/code&gt; do like the following.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 전송에 시간 제한이 소켓 옵션을 통해 처리되기 때문에 통화 시간 제한 옵션을 허용하지 않습니다 &lt;code&gt;send_timeout&lt;/code&gt; . 수신기가없는 전송 작업의 동작은 주로 기본 TCP 스택과 네트워크 인프라에 의해 정의됩니다. 코드를 작성하려면 결국 보낸 사람이에 중단 될 수있는 매달려 수신기 처리하는 &lt;code&gt;send&lt;/code&gt; 다음과 같이 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bdcf831f5f9a895f78c5ead8d39eb67c53d11a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_notification/6&lt;/code&gt; function is the most general version of the function. A &lt;code&gt;ContextName&lt;/code&gt; must be specified, from which the notification will be sent. If this parameter is not specified, the default context (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">&lt;code&gt;send_notification/6&lt;/code&gt; 함수는 함수의 가장 일반적인 버전이다. &lt;code&gt;ContextName&lt;/code&gt; 는 알림이 전송됩니다되는, 지정해야합니다. 이 매개 변수를 지정하지 않으면 기본 컨텍스트 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e10004941e2f7c2be1fb735798912ba806d773f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_out_queue&lt;/code&gt; routine is as follows:</source>
          <target state="translated">&lt;code&gt;send_out_queue&lt;/code&gt; 다음과 같이 루틴은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="843b939f65952e899d6ea657ca1ebe102c72dbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; module corresponds, greatly simplified, to the Erlang/OTP behaviour &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 모듈의 대응은 크게 얼랑 / OTP 행동에, 간단하게 &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eede287bf30328bbe010a8372b63b7607963a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; commands modifies or adds an Erlang service, respectively. The simplest form of an &lt;code&gt;add&lt;/code&gt; command is without any options in which case all default values (described above) apply. The service name is mandatory.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; 각각 수정 명령 또는 얼랑 서비스를 추가합니다. &lt;code&gt;add&lt;/code&gt; 명령 의 가장 간단한 형식은 옵션이없는 경우 (위에서 설명한) 모든 기본값이 적용됩니다. 서비스 이름은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7d5aec8c53556f4c4632141415f220fd68b8daa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function checks if it has enough information to make the row change its status from &lt;code&gt;notReady&lt;/code&gt; to &lt;code&gt;notInService&lt;/code&gt; (when a row has been been set to &lt;code&gt;createAndWait&lt;/code&gt;). If a row is set to &lt;code&gt;createAndWait&lt;/code&gt;, columns without a value are set to &lt;code&gt;noinit&lt;/code&gt;. If Mnesia is used, the set functionality is handled within a transaction.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 기능 검사는 행 상태에서 변경할 수 있도록하는 충분한 정보가 있으면 &lt;code&gt;notReady&lt;/code&gt; 을 에 &lt;code&gt;notInService&lt;/code&gt; 을 (a 행으로 설정되었을 때 &lt;code&gt;createAndWait&lt;/code&gt; ). 행이 &lt;code&gt;createAndWait&lt;/code&gt; 로 설정된 경우 값이없는 열은 &lt;code&gt;noinit&lt;/code&gt; 로 설정됩니다 . Mnesia를 사용하면 설정된 기능이 트랜잭션 내에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dffce6a86883fb98a441ee618f3e33a10bd8dd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_on_spawn&lt;/code&gt; option will active call time tracing for all processes spawned by processes in the rootset. This is the default behaviour.</source>
          <target state="translated">&lt;code&gt;set_on_spawn&lt;/code&gt; 의 옵션은 활성 통화 시간 rootset의 프로세스에 의해 만들어지는 모든 프로세스에 대한 추적을 할 것이다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d7ea8237fdbb6c1e6e9cad779100829368078340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not given, and the child is of type &lt;code&gt;worker&lt;/code&gt;, the default value &lt;code&gt;5000&lt;/code&gt; will be used; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;, the default value &lt;code&gt;infinity&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 키는 선택 사항입니다. 제공되지 않고 하위 유형이 &lt;code&gt;worker&lt;/code&gt; 인 경우 기본값 &lt;code&gt;5000&lt;/code&gt; 이 사용됩니다. 자식이 &lt;code&gt;supervisor&lt;/code&gt; 유형 인 경우 기본값 &lt;code&gt;infinity&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb49de51c4b23fb4081f3a3f48b32fd97395704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;5000&lt;/code&gt; if the child is of type &lt;code&gt;worker&lt;/code&gt; and it defaults to &lt;code&gt;infinity&lt;/code&gt; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 키는 선택 사항입니다. 지정되지 않은 경우 하위 유형이 &lt;code&gt;worker&lt;/code&gt; 유형 인 경우 기본값은 &lt;code&gt;5000&lt;/code&gt; 이고 하위 유형이 &lt;code&gt;supervisor&lt;/code&gt; 유형 인 경우 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38a6562eb72c50374e4148dda56f4f2798a51836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silent&lt;/code&gt; trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function &lt;code&gt;{silent,Bool}&lt;/code&gt;, giving a high degree of control of which functions with which arguments that trigger the trace.</source>
          <target state="translated">&lt;code&gt;silent&lt;/code&gt; 추적 플래그는 시스템의 많은 또는 모든 프로세스에 대한 추적을 설정하는 용이하게합니다. 그런 다음 일치 스펙 함수 &lt;code&gt;{silent,Bool}&lt;/code&gt; 을 사용하여 추적을 활성화 및 비활성화하여 추적을 트리거하는 인수와 함께 어떤 기능을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57bdb45fe915c31143be502180221ee741783591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field changed from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 변경 필드는 부호에 서명했다. 예를 들어, 장소 전체에서 유형 만 변경하면 루프 종료 조건이나 오류 조건에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240a989a5bf707c990bcb78e115aed91f3f04714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field in &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; has been changed to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from &lt;code&gt;int&lt;/code&gt;. Check all code that use that field.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 필드 &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; 이 변경되었습니다 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; . 해당 필드를 사용하는 모든 코드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a337f162f4c8e035168099f55089fef2894d81f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; directory could be useful to release for debugging purposes but is not required. The &lt;code&gt;include&lt;/code&gt; directory should only be released if the applications has public include files.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 디렉토리는 디버깅 목적으로하지만 필요하지 않습니다에 대한 해제하는 것이 유용 할 수 있습니다. &lt;code&gt;include&lt;/code&gt; 하는 응용 프로그램은 대중이 파일이 포함되어있는 경우 디렉토리는 공개되어야한다.</target>
        </trans-unit>
        <trans-unit id="fc13993adad718eae8701221afde4693b532449e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; application is an implementation of the SSH Transport, Connection and Authentication Layer Protocols in Erlang. It provides the following:</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 응용 프로그램은 전송 SSH, 얼랑에 연결 및 인증 계층 프로토콜의 구현이다. 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f65d2a2ea4f4fd44a5c098586ac285ac95cdefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; commands communicates with the service manager for starting and stopping a service. The commands wait until the service is started or stopped. When disabling a service, it is not stopped, the disabled state does not take effect until the service is stopped. Enabling a service sets it in automatic mode, which is started at boot. This command cannot set the service to manual.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 시작하고 서비스를 중지에 대한 서비스 관리자와 명령을 전달한다. 서비스가 시작되거나 중지 될 때까지 명령이 대기합니다. 서비스를 비활성화하면 서비스가 중지되지 않으며 서비스가 중지 될 때까지 비활성화 된 상태가 적용됩니다. 서비스를 활성화하면 부팅시 시작되는 자동 모드로 설정됩니다. 이 명령은 서비스를 수동으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1f3d732c30aec74a57c16dda04003bb1543c716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; entry is called when the driver is opened as a port with &lt;code&gt;open_port/2&lt;/code&gt;. Here we allocate memory for a user data structure. This user data is passed every time the emulator calls us. First we store the driver handle, as it is needed in later calls. We allocate memory for the connection handle that is used by LibPQ. We also set the port to return allocated driver binaries, by setting flag &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, calling &lt;code&gt;set_port_control_flags&lt;/code&gt;. (This is because we do not know if our data will fit in the result buffer of &lt;code&gt;control&lt;/code&gt;, which has a default size, 64 bytes, set up by the emulator.)</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 드라이버가있는 포트로 열 때 항목이라고 &lt;code&gt;open_port/2&lt;/code&gt; . 여기서 우리는 사용자 데이터 구조를위한 메모리를 할당합니다. 이 사용자 데이터는 에뮬레이터가 호출 할 때마다 전달됩니다. 먼저 나중에 호출 할 때 필요하므로 드라이버 핸들을 저장합니다. LibPQ에서 사용하는 연결 핸들에 메모리를 할당합니다. 또한 플래그 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 를 설정하고 &lt;code&gt;set_port_control_flags&lt;/code&gt; 를 호출 하여 할당 된 드라이버 바이너리를 반환하도록 포트를 설정했습니다 . (이는 데이터가 에뮬레이터에서 설정 한 기본 크기가 64 바이트 인 &lt;code&gt;control&lt;/code&gt; 의 결과 버퍼에 맞는지 알 수 없기 때문 입니다.)</target>
        </trans-unit>
        <trans-unit id="f756fe51eb87c21305c2536fa74b5434575da4c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; key is mandatory.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7a89df12694a55231dbe9df289731067f34bf0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; program is called when the machine is started.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 기계가 시작될 때 프로그램이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="34d8bb2f8c095328e05b319382abf621840539e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is an example script on how to start up the Erlang system in embedded mode on Unix.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 스크립트는 유닉스에 포함 된 모드에서 얼랑 시스템을 시작하는 방법에 대한 예제 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c9b5982012fe67cdfffd9b71b0eeb41c6d062f31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is to be edited accordingly.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 스크립트는 이에 따라 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e73008fe878f9797af9d091c4fba4b24889e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_disabled&lt;/code&gt; command operates on a service regardless of if it is enabled/disabled or started/stopped. It does this by first enabling it (regardless of if it is enabled or not), then starting it (if not already started), and then disabling it. The result is a disabled but started service, regardless of its earlier state. This is useful for starting services temporarily during a release upgrade. The difference between using &lt;code&gt;start_disabled&lt;/code&gt; and the sequence &lt;code&gt;enable&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;disable&lt;/code&gt; is that all other &lt;code&gt;erlsrv&lt;/code&gt; commands are locked out during the sequence of operations in &lt;code&gt;start_disable&lt;/code&gt;, making the operation atomic from an &lt;code&gt;erlsrv&lt;/code&gt; user's point of view.</source>
          <target state="translated">&lt;code&gt;start_disabled&lt;/code&gt; 명령 관계없이 활성화 / 비활성화 또는 시작되었는지의 서비스에서 작동 / 정지. 먼저 활성화 여부에 관계없이 활성화 한 다음 시작 (아직 시작하지 않은 경우) 한 다음 비활성화하여이를 수행합니다. 결과는 이전 상태에 관계없이 비활성화되었지만 서비스가 시작된 것입니다. 릴리스 업그레이드 중에 서비스를 임시로 시작하는 데 유용합니다. &lt;code&gt;start_disabled&lt;/code&gt; 사용 과 시퀀스 &lt;code&gt;enable&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;disable&lt;/code&gt; 의 차이점은 start_disable 의 작업 순서 중에 다른 모든 &lt;code&gt;erlsrv&lt;/code&gt; 명령이 잠기 &lt;code&gt;start_disable&lt;/code&gt; 에서 작업을 &lt;code&gt;erlsrv&lt;/code&gt; 사용자의 관점.</target>
        </trans-unit>
        <trans-unit id="fc0272cbbd8f9392623927de4cb2fc5730b48880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program in its original form recognizes the following options:</source>
          <target state="translated">원래 형식 의 &lt;code&gt;start_erl&lt;/code&gt; 프로그램은 다음 옵션을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a046e5227b7bb73b869f5bee562322400ca78ede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program is specific to Windows NT/2000/XP (and later versions of Windows). Although there are programs with the same name on other platforms, their functionality is different.</source>
          <target state="translated">&lt;code&gt;start_erl&lt;/code&gt; 의 프로그램은 윈도우 NT / 2000 / XP (및 이후 버전의 Windows)에 따라 다릅니다. 다른 플랫폼에는 동일한 이름의 프로그램이 있지만 기능은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dbb5a322b443d443c9f79ed8f50a8ce9c3dd4066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; shell script is normally not to be altered by the user.</source>
          <target state="translated">&lt;code&gt;start_erl&lt;/code&gt; 의 쉘 스크립트는 사용자에 의해 변경 될 수 일반적으로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f114d80543f043efa956ef10b8b8d871f223052b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stop&lt;/code&gt; entry is called when the port is closed.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 포트를 닫을 때 항목이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d04747a932902a65b42336d22f13d3d5bc78329f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strategy&lt;/code&gt; key is optional in this map. If it is not given, it defaults to &lt;code&gt;one_for_one&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 핵심이지도에서 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;one_for_one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac46c7648d961485339da72bde9519efe243649a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string&lt;/code&gt; module works perfectly for Unicode strings and ISO Latin-1 strings, except the language-dependent functions &lt;code&gt;string:uppercase/1&lt;/code&gt; and &lt;code&gt;string:lowercase/1&lt;/code&gt;. These two functions can never function correctly for Unicode characters in their current form, as there are language and locale issues to consider when converting text between cases. Converting case in an international environment is a large subject not yet addressed in OTP.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 모듈은 언어 별 기능을 제외하고 유니 코드 문자열 및 ISO 라틴어 1 문자열을 완벽하게 작동 &lt;code&gt;string:uppercase/1&lt;/code&gt; 및 &lt;code&gt;string:lowercase/1&lt;/code&gt; . 이 두 함수는 텍스트를 변환 할 때 고려해야 할 언어 및 로캘 문제가 있으므로 현재 형식의 유니 코드 문자에 대해 올바르게 기능 할 수 없습니다. 국제 환경에서 사례를 변환하는 것은 아직 OTP에서 다루지 않은 큰 주제입니다.</target>
        </trans-unit>
        <trans-unit id="bbf0fa4cdfc9cb3b3a98e97fea86cc7766872258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subsystem_name&lt;/code&gt; is the name that a client requests to start with for example &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;subsystem_name&lt;/code&gt; 는 클라이언트 요청이 예제를 위해 함께 시작하는 이름입니다 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09767c0926afa55480ccd26075dea864841952af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suspend&lt;/code&gt; pseudo function has got an OWN time of zero. This is to prevent the process total OWN time from including time in suspension. Whether suspend time is really ACC or OWN time is more of a philosophical question.</source>
          <target state="translated">는 &lt;code&gt;suspend&lt;/code&gt; 의사 함수가 0 인 자신의 시간을 가지고있다. 이는 프로세스 총 소유 시간이 일시 중단 시간을 포함하지 않도록하기위한 것입니다. 일시 중단 시간이 실제로 ACC인지 아니면 자신의 시간인지는 철학적 인 질문에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="56fd6933946b063ca50f26b9fde4abf8abbc8167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. It also has functions that, together with functions in the &lt;code&gt;proc_lib&lt;/code&gt; module, can be used to implement a &lt;strong&gt;special process&lt;/strong&gt; that complies to the OTP design principles without using a standard behaviour. These functions can also be used to implement user-defined (non-standard) behaviours.</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 모듈 동작을 사용하여 구현 프로세스의 단순한 디버깅 기능을 갖는다. 또한 &lt;code&gt;proc_lib&lt;/code&gt; 모듈의 함수와 함께 표준 동작을 사용하지 않고 OTP 설계 원칙을 준수 하는 &lt;strong&gt;특수 프로세스&lt;/strong&gt; 를 구현하는 데 사용할 수있는 함수가 있습니다. 이러한 기능은 사용자 정의 (비표준) 동작을 구현하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f881a797bfc4fbe38f558b9ae2256b6de4f52c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. The &lt;code&gt;code_lock&lt;/code&gt; example from &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; is used to illustrate this:</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 모듈 동작을 사용하여 구현 프로세스의 단순한 디버깅 기능을 갖는다. &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;code_lock&lt;/code&gt; 예제는 이를 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d80e46d29a3b09620c79d01dfafc6546d08b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; value is not complete. Some allocated memory that is to be part of this value is not.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 값이 완료되지 않았습니다. 이 값의 일부가 될 일부 할당 된 메모리는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e392c3cf2f0ef617cba237c6220075b3ea4b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system_dir&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;system_dir&lt;/code&gt; 의 옵션은 호스트 키 파일이 들어있는 디렉토리하고 기본값으로합니다 &lt;code&gt;/etc/ssh&lt;/code&gt; . 자세한 내용은 &lt;code&gt;ssh(6)&lt;/code&gt; 구성 파일 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dc4b52b4a1a8766ffe6fbf819d4319fd568e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; function takes a &lt;code&gt;.rel&lt;/code&gt; file as input and creates a zipped tar file with the code for the specified applications, a &lt;strong&gt;release package&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;systools:make_tar/1,2&lt;/code&gt; 기능은 얻어 &lt;code&gt;.rel&lt;/code&gt; 의 파일을 입력으로하고, 지정된 애플리케이션 A에 대한 코드와 함께 압축 된 tar 파일 생성 &lt;strong&gt;릴리스 패키지&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="301c4b01094f4be3c122bd03d67de7a461179ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_info/2&lt;/code&gt; function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</source>
          <target state="translated">&lt;code&gt;table_info/2&lt;/code&gt; 함수는 두 개의 인수를 취합니다. 첫 번째는 Mnesia 테이블의 이름입니다. 두 번째는 다음 키 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cc6490531af30f5ced0c442f4ca5f18223c8f2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag_receiver()&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;tag_receiver()&lt;/code&gt; 먼저 송신한다 &lt;code&gt;snmp_targets&lt;/code&gt; 의 각 주소에 대한 다음 메시지 및 &lt;code&gt;Addresses&lt;/code&gt; 리스트, 이들의 하나 &lt;code&gt;snmp_notification&lt;/code&gt; 된 메시지.</target>
        </trans-unit>
        <trans-unit id="05b2bd26a182333de1bd8075c792a7cf0885382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term&lt;/code&gt; structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 구조는 바이너리 스트링, 또는 원자에 대한 터플 또는리스트 크기에 대한 인수에 대응를 포함한다. 정수, 부동 소수점, 원자, pid, 포트 또는 참조 중 하나 인 경우 용어를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="414ded4046829ee348e2029f26b1f968edf7170d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminating&lt;/code&gt; options effects discovery initiated by a manager.</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 관리자에 의해 시작 옵션 효과 발견.</target>
        </trans-unit>
        <trans-unit id="7e88c128d4034b8d31e143d58083f1b627d669f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; functions use the &lt;code&gt;*.asn1db&lt;/code&gt; files for all included modules. If they are located in a different directory than the current working directory, use the &lt;code&gt;include&lt;/code&gt; option to add paths. This is only needed when automatically generating values. For static values using &lt;code&gt;Value&lt;/code&gt; no options are needed.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 기능은 사용 &lt;code&gt;*.asn1db&lt;/code&gt; 포함 된 모든 모듈 파일을. 이들이 현재 작업 디렉토리와 다른 디렉토리에있는 경우, &lt;code&gt;include&lt;/code&gt; 옵션을 사용하여 경로를 추가하십시오. 이것은 자동으로 값을 생성 할 때 필요합니다. 사용하지 않는 정적 값의 &lt;code&gt;Value&lt;/code&gt; 어떤 옵션이 필요하다.</target>
        </trans-unit>
        <trans-unit id="83b7e0837f597d64ddcc824925c5e1f6e2d7ce99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tftp&lt;/code&gt; application implements the following IETF standards:</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 응용 프로그램 구현 다음 IETF 표준 :</target>
        </trans-unit>
        <trans-unit id="4bd16215e29bac88188ec05db9e000d6b25c2a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;time_unit/0&lt;/code&gt; 타입은 확장 할 수 있습니다. 시간 단위 사이의 시간 값을 변환하려면 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d6b5da79accb971f070469104b62f5de13468c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; option in the &lt;code&gt;SearchOptions&lt;/code&gt; is for the ldap server, while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for each individual request in the search operation.</source>
          <target state="translated">&lt;code&gt;SearchOptions&lt;/code&gt; 의 &lt;code&gt;timeout&lt;/code&gt; 옵션 은 ldap 서버에 대한 것이고, &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 의 시간 초과 는 검색 작업의 각 개별 요청에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3469f460bad51d15abfb716bef8439dd19f5713d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the &lt;code&gt;total&lt;/code&gt; value is &lt;strong&gt;not&lt;/strong&gt; supposed to be equal to the total size of all pages mapped to the emulator.</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; 값은 동적 에뮬레이터에 의해 할당 된 메모리의 총량 가정된다. 공유 라이브러리, 에뮬레이터 자체의 코드 및 에뮬레이터 스택은 포함되지 않아야합니다. 즉, &lt;code&gt;total&lt;/code&gt; 값이되어 &lt;strong&gt;있지&lt;/strong&gt; 에뮬레이터에 매핑 된 모든 페이지의 전체 크기와 동일해야하는데.</target>
        </trans-unit>
        <trans-unit id="855a90cd384864cf599ca9011960a53bac88f853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trim&lt;/code&gt; behavior corresponds exactly to the Perl default. &lt;code&gt;{parts,N}&lt;/code&gt;, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of &lt;code&gt;split/3&lt;/code&gt; corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</source>
          <target state="translated">&lt;code&gt;trim&lt;/code&gt; 동작은 정확히 펄의 기본에 해당합니다. &lt;code&gt;{parts,N}&lt;/code&gt; (여기서 N은 양의 정수임)은 양의 세 번째 매개 변수를 사용하여 Perl 동작에 정확히 해당합니다. &lt;code&gt;split/3&lt;/code&gt; 의 기본 동작은 음수 정수가 Perl 루틴의 세 번째 매개 변수로 지정된 경우 Perl 동작에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="503ae720e5d8f3760c374c5a7724a46be581ffb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can also be augmented with an &lt;code&gt;after&lt;/code&gt; section, intended to be used for cleanup with side effects:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 발현도 함께 증대 될 수 있습니다 &lt;code&gt;after&lt;/code&gt; 섹션 부작용 정리에 사용하기위한 것 :</target>
        </trans-unit>
        <trans-unit id="9aa8fddb846b9b7abd8af53c04dc022f8bbdb56d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can have an &lt;code&gt;of&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 표현은 할 수 &lt;code&gt;of&lt;/code&gt; 섹션 :</target>
        </trans-unit>
        <trans-unit id="874e9960e26401a3b617a3b1e2c19da394373ec5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;worker&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값 &lt;code&gt;worker&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce30d2f89579b051b36741023e812a759179d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;worker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키는 선택 사항입니다. 지정하지 않으면 기본값은 &lt;code&gt;worker&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c8f1c69ed96b83a679b6a1461cadd4cb592d2117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_command&lt;/code&gt; routine is the routine called when an Erlang process sends data to the port. This routine handles all asynchronous commands when the port is in &lt;code&gt;command&lt;/code&gt; mode and the sending of all data when the port is in &lt;code&gt;data&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;uds_command&lt;/code&gt; 의 루틴은 얼랑 프로세스가 포트로 데이터를 보낼 때 호출 루틴입니다. 이 루틴은 포트가 &lt;code&gt;command&lt;/code&gt; 모드 에있을 때 모든 비동기 명령을 처리 하고 포트가 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 모든 데이터를 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="12d38078aadeb17f73f6143b46507ced220c8b0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine handles other input events (like non-blocking &lt;code&gt;accept&lt;/code&gt;), but most importantly handle data arriving at the socket by calling &lt;code&gt;do_recv&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;uds_input&lt;/code&gt; 의 (비 차단과 같은 일상적인 핸들 다른 입력 이벤트 &lt;code&gt;accept&lt;/code&gt; 하지만, 가장 중요한 것은 호출하여 소켓에 도착하는 데이터를 처리) &lt;code&gt;do_recv&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="202a772c2bbbb0c73373b15e1d87ffd28aa29133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine is called when data is available on a file descriptor previously passed to the &lt;code&gt;driver_select&lt;/code&gt; routine. This occurs typically when a read command is issued and no data is available. The &lt;code&gt;do_recv&lt;/code&gt; routine is as follows:</source>
          <target state="translated">&lt;code&gt;uds_input&lt;/code&gt; 의 루틴은 데이터가 이전에 전달되는 파일 기술자로 볼 때 호출되는 &lt;code&gt;driver_select&lt;/code&gt; 의 일상. 일반적으로 읽기 명령이 발행되고 사용 가능한 데이터가 없을 때 발생합니다. &lt;code&gt;do_recv&lt;/code&gt; 의 다음과 같은 루틴은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="afe5ea4f80f83ad57ad0aad31e10486a4f2bf930" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_start&lt;/code&gt; routine is called when a port is opened from Erlang. In this case, we only allocate a structure and initialize it. Creating the actual socket is left to the &lt;code&gt;uds_command&lt;/code&gt; routine.</source>
          <target state="translated">&lt;code&gt;uds_start&lt;/code&gt; 의 포트가 얼랑에서 열릴 때 루틴 호출된다. 이 경우 구조 만 할당하고 초기화합니다. 실제 소켓 작성은 &lt;code&gt;uds_command&lt;/code&gt; 루틴 에 맡겨집니다 .</target>
        </trans-unit>
        <trans-unit id="8bfbb24810f0c5b15e0b6448d90f972fe31a6386" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undo&lt;/code&gt; function does nothing.</source>
          <target state="translated">&lt;code&gt;undo&lt;/code&gt; 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7969bdd4f7e8e8283016abfb83b747e28e6525e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unicode&lt;/code&gt; module is clearly Unicode-aware. It contains functions for conversion between different Unicode formats and some utilities for identifying byte order marks. Few programs handling Unicode data survive without this module.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 모듈은 명확하게 유니 코드 인식이다. 여기에는 다른 유니 코드 형식과 바이트 순서 표시를 식별하기위한 일부 유틸리티 간 변환 기능이 포함되어 있습니다. 이 모듈 없이는 유니 코드 데이터를 처리하는 프로그램이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="45fc4ab31edeed78de6dcc133ce43fa458252958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; function is an alternative for updating module data of recompiled modules.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 함수 컴파일 모듈의 모듈 데이터를 업데이트하는 대안이다.</target>
        </trans-unit>
        <trans-unit id="e7a993cc2041a3a5e4126cbf7ea824172decdb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; instruction must contain the tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;. The instruction makes the special process call the callback function &lt;code&gt;system_code_change/4&lt;/code&gt;, a function the user must implement. The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to &lt;code&gt;system_code_change/4&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령은 튜플 있어야합니다 &lt;code&gt;{advanced,Extra}&lt;/code&gt; . 이 명령은 특수 프로세스가 콜백 함수 인 &lt;code&gt;system_code_change/4&lt;/code&gt; 를 호출하도록 합니다.이 함수는 사용자가 구현해야합니다. &lt;code&gt;Extra&lt;/code&gt; 라는 용어 는이 경우 &lt;code&gt;[]&lt;/code&gt; 로 &lt;code&gt;system_code_change/4&lt;/code&gt; 로 그대로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="55a52d1bdeacd91af756556ef9395d795b7ce705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user_args&lt;/code&gt; configuration parameter which may be used to extend the argument list of the callback functions. For example, the handle_connect function takes by default two arguments:</source>
          <target state="translated">&lt;code&gt;user_args&lt;/code&gt; 의 콜백 함수의 인수 목록을 확장하는데 사용될 수있다 구성 파라미터. 예를 들어 handle_connect 함수는 기본적으로 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c15ed8631e7be541ad2f112cab6d63b078785dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmAccessTable&lt;/code&gt; maps the &lt;code&gt;groupName&lt;/code&gt; (found in &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;), &lt;code&gt;contextName&lt;/code&gt;, &lt;code&gt;securityModel&lt;/code&gt;, and &lt;code&gt;securityLevel&lt;/code&gt; to an MIB view for each type of operation (read, write, or notify). The MIB view is represented as a &lt;code&gt;viewName&lt;/code&gt;. The definition of the MIB view represented by the &lt;code&gt;viewName&lt;/code&gt; is found in the &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vacmAccessTable&lt;/code&gt; 는 지도 &lt;code&gt;groupName&lt;/code&gt; 을 (검색된 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ) &lt;code&gt;contextName&lt;/code&gt; , &lt;code&gt;securityModel&lt;/code&gt; 및 &lt;code&gt;securityLevel&lt;/code&gt; 동작의 각 유형 (기록을 판독 또는 통지)에 대한 MIB 뷰로. MIB보기는 &lt;code&gt;viewName&lt;/code&gt; 으로 표시됩니다 . &lt;code&gt;viewName&lt;/code&gt; 으로 표시되는 MIB보기의 정의 는 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70d16c49aee0ecab7697bd61b2b47a75fed9fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmContextTable&lt;/code&gt; is a read-only table that lists all available contexts.</source>
          <target state="translated">&lt;code&gt;vacmContextTable&lt;/code&gt; 은 읽기 전용 테이블 그 목록을 사용할 수있는 모든 상황이다.</target>
        </trans-unit>
        <trans-unit id="ef9aac3e2a8987ec6dd80992e0534a1b71403af1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; maps a &lt;code&gt;securityModel&lt;/code&gt; and a &lt;code&gt;securityName&lt;/code&gt; to a &lt;code&gt;groupName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; 는 매핑 &lt;code&gt;securityModel&lt;/code&gt; 과 &lt;code&gt;securityName&lt;/code&gt; A와 &lt;code&gt;groupName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28801f1623b234b9de96cc740a98bd5f85c06c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; is indexed by the &lt;code&gt;viewName&lt;/code&gt;, and defines which objects are included in the MIB view.</source>
          <target state="translated">&lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 는 에 의해 인덱싱 &lt;code&gt;viewName&lt;/code&gt; 과 물체가 MIB 뷰에 포함되고, 정의한다.</target>
        </trans-unit>
        <trans-unit id="1870424a39adeddc9df6d1301607365bb578c850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vfs&lt;/code&gt; layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older versions did this by refusing to create non-UTF-8 conforming filenames, while newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the original character in hexadecimal notation. As Unicode translation is enabled by default on MacOS X, the only way to come up against this is to either start the VM with flag &lt;code&gt;+fnl&lt;/code&gt; or to use a raw filename in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. If using a raw filename, with a bytewise encoding containing characters from 127 through 255, to create a file, the file cannot be opened using the same name as the one used to create it. There is no remedy for this behavior, except keeping the filenames in the correct encoding.</source>
          <target state="translated">MacOS X 의 &lt;code&gt;vfs&lt;/code&gt; 레이어는 공격적인 방식으로 UTF-8 파일 이름을 적용합니다. 이전 버전은 UTF-8이 아닌 호환 파일 이름을 만드는 것을 거부함으로써이 작업을 수행했지만 최신 버전은 문제가되는 바이트를 시퀀스 &quot;% HH&quot;로 대체합니다. 여기서 HH는 16 진 표기법의 원래 문자입니다. MacOS X에서 유니 코드 변환이 기본적으로 활성화되어 있기 때문에이 문제를 &lt;code&gt;+fnl&lt;/code&gt; 있는 유일한 방법은 플래그 + fnl로 VM을 시작 하거나 원시 파일 이름을 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩으로 사용하는 것입니다. 127에서 255까지의 문자를 포함하는 바이트 단위 인코딩으로 원시 파일 이름을 사용하여 파일을 작성하는 경우 파일을 작성하는 데 사용 된 것과 동일한 이름으로 파일을 열 수 없습니다. 파일 이름을 올바른 인코딩으로 유지하는 것을 제외하고는이 동작에 대한 해결책이 없습니다.</target>
        </trans-unit>
        <trans-unit id="831df5545d1b1c7760cea7009d162230198cc0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;werl&lt;/code&gt; window is in many ways modeled after the &lt;code&gt;xterm&lt;/code&gt; window present on other platforms, as the &lt;code&gt;xterm&lt;/code&gt; model fits well with line-oriented command-based interaction. This means that selecting text is line-oriented rather than rectangle-oriented.</source>
          <target state="translated">&lt;code&gt;werl&lt;/code&gt; 의 창은 모델로 여러 가지 방법에 &lt;code&gt;xterm&lt;/code&gt; 은 AS, 다른 플랫폼에서 창 현재 &lt;code&gt;xterm&lt;/code&gt; 모델 라인 지향 명령 기반 상호 작용과 잘 맞습니다. 즉, 텍스트 선택은 사각형이 아니라 선이됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0a24e0ba3c71a8aad37252c9a038696dacac35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;whereis&lt;/code&gt; function-call verifies that the SSL application is started.</source>
          <target state="translated">&lt;code&gt;whereis&lt;/code&gt; 기능 - 통화를 검증은 SSL 응용 프로그램이 시작된다.</target>
        </trans-unit>
        <trans-unit id="a6d05af96ec0e7231d4e09ddd7a1fc622f5621cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; is defined by the user and is passed to the &lt;code&gt;match_fun&lt;/code&gt;, if defined. If the term in &lt;code&gt;OtherRefId&lt;/code&gt; is a binary, it will be converted to a string.</source>
          <target state="translated">&lt;code&gt;{OtherRefId,term()}&lt;/code&gt; 사용자에 의해 정의되며에 전달 &lt;code&gt;match_fun&lt;/code&gt; 정의 경우. &lt;code&gt;OtherRefId&lt;/code&gt; 의 용어 가 이진이면 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="19e1b6293cd5c62e374c8457e4fbd9d95a253158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; option must be included. This option is used to find the callback module &lt;code&gt;Module&lt;/code&gt; of the application. &lt;code&gt;StartArgs&lt;/code&gt; is ignored, as &lt;code&gt;Module:start/2&lt;/code&gt; is called only for the primary application.</source>
          <target state="translated">&lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; 옵션이 포함되어야합니다. 이 옵션은 응용 프로그램 의 콜백 모듈 &lt;code&gt;Module&lt;/code&gt; 을 찾는 데 사용됩니다 . 기본 애플리케이션에 대해서만 &lt;code&gt;Module:start/2&lt;/code&gt; 가 호출되므로 &lt;code&gt;StartArgs&lt;/code&gt; 는 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="4668f1fd645c2ffa2dba60de3db8016985e65bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ok,tut}&lt;/code&gt; means that the compilation is OK. If it says &quot;error&quot; it means that there is some mistake in the text that you entered. Additional error messages gives an idea to what is wrong so you can modify the text and then try to compile the program again.</source>
          <target state="translated">&lt;code&gt;{ok,tut}&lt;/code&gt; 컴파일이 확인되는 것을 의미한다. &quot;오류&quot;라고 표시되면 입력 한 텍스트에 오류가 있음을 의미합니다. 추가 오류 메시지는 무엇이 잘못되었는지에 대한 아이디어를 제공하므로 텍스트를 수정 한 다음 프로그램을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c82dec6529acb72fb125b0bac4fda347c61081" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{packet, N}&lt;/code&gt; and &lt;code&gt;{line, L}&lt;/code&gt; settings are mutually exclusive.</source>
          <target state="translated">&lt;code&gt;{packet, N}&lt;/code&gt; 및 &lt;code&gt;{line, L}&lt;/code&gt; 의 설정은 서로 배타적이다.</target>
        </trans-unit>
        <trans-unit id="971d55e17028d3606b6c283922622f2c0932a483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{port,PortNum}&lt;/code&gt; tuple is optional and if omitted, default Telnet port 23 is used. Also the &lt;code&gt;keep_alive&lt;/code&gt; tuple is optional, and the value defauls to &lt;code&gt;true&lt;/code&gt; (enabled).</source>
          <target state="translated">&lt;code&gt;{port,PortNum}&lt;/code&gt; 튜플는 선택 사항이며 생략하는 경우, 기본 텔넷 포트 (23)가 사용된다. 또한 &lt;code&gt;keep_alive&lt;/code&gt; 튜플은 선택 사항이며 값은 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 (활성화 됨).</target>
        </trans-unit>
        <trans-unit id="fa6ece2cc8b2e8dafa07d4e08292eb70bec23c2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</source>
          <target state="translated">&lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; 옵션을 포함해야하며, 지정된 위상의 세트는 기본 애플리케이션에 대해 지정된 단계들의 세트의 서브 세트이어야한다.</target>
        </trans-unit>
        <trans-unit id="ff25bb9b46c77ee1bd1587510f1046fea71955a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; &quot;such that&quot; and the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; is read as &quot;taken from&quot;.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; &quot;그런&quot;및 화살표 &lt;code&gt;&amp;lt;-&lt;/code&gt; 는 &quot;취득한&quot;것으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8950a73316b6b3766c9706406f02f3f2dda35162" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;Cartesian_product&quot;&gt;Cartesian product&lt;/strong&gt; of two sets X and Y, denoted X &amp;times; Y, is the set {a : a = (x, y) for some x in X and for some y in Y}.</source>
          <target state="translated">X &amp;times; Y로 표시된 두 세트 X와 Y 의 &lt;strong id=&quot;Cartesian_product&quot;&gt;데카르트 곱은&lt;/strong&gt; X의 일부 x와 Y의 일부 y에 대한 집합 {a : a = (x, y)입니다.</target>
        </trans-unit>
        <trans-unit id="97f5043ae782de1e349c1f4e82a07bd359c0964c" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;converse&quot;&gt;converse&lt;/strong&gt; of R is the set {a : a = (y, x) for some (x, y) in R}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;converse&quot;&gt;반대&lt;/strong&gt; 는 R의 일부 (x, y)에 대한 집합 {a : a = (y, x)입니다.</target>
        </trans-unit>
        <trans-unit id="c74f91b2df651d6f1d918e8b3fa79c423cad5e1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;difference&quot;&gt;difference&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that do not belong to B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;difference&quot;&gt;차이&lt;/strong&gt; 는 B에 속하지 않는 A의 모든 요소를 ​​포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="efd11e10dc9bffd3ce00966684d96fd8a122cb0d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;domain&quot;&gt;domain&lt;/strong&gt; of R is the set {x : x R y for some y in Y}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;domain&quot;&gt;도메인&lt;/strong&gt; 은 세트 {x : x R y in Y의 일부 y}입니다.</target>
        </trans-unit>
        <trans-unit id="377184fb47eff2618a884d3371438181861419a0" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;field&quot;&gt;field&lt;/strong&gt; of a relation R in X is the union of the domain of R and the range of R.</source>
          <target state="translated">X에서 관계 R 의 &lt;strong id=&quot;field&quot;&gt;필드&lt;/strong&gt; 는 R 도메인과 R 범위의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="1a9617de87db1af0121da59eba19d31a6b757eff" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;in_degree&quot;&gt;in-degree&lt;/strong&gt; of a vertex is the number of edges incident on that vertex.</source>
          <target state="translated">&lt;strong id=&quot;in_degree&quot;&gt;에서도&lt;/strong&gt; 정점의 정점은 그 가장자리에 입사하는 숫자이다.</target>
        </trans-unit>
        <trans-unit id="4c0e00f79ce45926299ee2f3508020fdf2f45df9" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection&quot;&gt;intersection&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that belong to B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;intersection&quot;&gt;교집합&lt;/strong&gt; 은 B에 속하는 A의 모든 요소를 ​​포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="3f1d912f47b338c33084d89f0c15a5a316197ecb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection_n&quot;&gt;intersection&lt;/strong&gt; of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</source>
          <target state="translated">비어 있지 않은 세트의 집합 의 &lt;strong id=&quot;intersection_n&quot;&gt;교차점&lt;/strong&gt; 은 모든 컬렉션 집합에 속하는 모든 요소를 ​​포함하는 집합입니다.</target>
        </trans-unit>
        <trans-unit id="429f2c89c9e807577354da0b8e15a8e248018d77" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;length&quot;&gt;length&lt;/strong&gt; of path P is k-1.</source>
          <target state="translated">경로 P 의 &lt;strong id=&quot;length&quot;&gt;길이&lt;/strong&gt; 는 k-1입니다.</target>
        </trans-unit>
        <trans-unit id="abc21b67f672b304bee1db7701b820f9b24de3c6" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;natural_join&quot;&gt;natural join&lt;/strong&gt; of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</source>
          <target state="translated">좌표 i 및 j에서 n-ary 관계 R과 m-ary 관계 S 의 &lt;strong id=&quot;natural_join&quot;&gt;자연 결합&lt;/strong&gt; 은 집합 {z : z = (x [1], ..., x [n], y [ R에서 일부 (x [1], ..., x [n])에 대해 1], ..., y [j-1], y [j + 1], ..., y [m]) x [i] = y [j]}가되도록 S의 일부 (y [1], ..., y [m])에 대해.</target>
        </trans-unit>
        <trans-unit id="adf6489e3c93a13ca7fd19239f3939863c02f11d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;out_degree&quot;&gt;out-degree&lt;/strong&gt; of a vertex is the number of edges emanating from that vertex.</source>
          <target state="translated">정점 의 &lt;strong id=&quot;out_degree&quot;&gt;바깥 쪽 정도&lt;/strong&gt; 는 해당 정점에서 나오는 가장자리 수입니다.</target>
        </trans-unit>
        <trans-unit id="7c6a3c4f02bedbb63c4000218f9eaa4b3029b656" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;projection&quot;&gt;projection&lt;/strong&gt; of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &amp;lt;= j &amp;lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively.</source>
          <target state="translated">&lt;strong id=&quot;projection&quot;&gt;투영&lt;/strong&gt; 좌표 상에 n 진 관계 R의 i는 집합 {x는 [I] (X [1], ..., X [I], ..., X [N])에 대한 약간의 X R에 X [j]에서 [j], 1 &amp;lt;= j &amp;lt;= n이고 i = j} 아님. 제 1 및 제 2 좌표에 대한 이진 관계 R의 투영은 각각 도메인 및 R의 범위이다.</target>
        </trans-unit>
        <trans-unit id="928618861a3a7864fa16dc6571d48344039643c2" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;range&quot;&gt;range&lt;/strong&gt; of R is the set {y : x R y for some x in X}.</source>
          <target state="translated">R 의 &lt;strong id=&quot;range&quot;&gt;범위&lt;/strong&gt; 는 세트 {y : x R y in x in X}입니다.</target>
        </trans-unit>
        <trans-unit id="a0513ff69692a7179c5c24f4ad25a5aa23d84d71" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;restriction&quot;&gt;restriction&lt;/strong&gt; of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y.</source>
          <target state="translated">R에 대한 A 의 &lt;strong id=&quot;restriction&quot;&gt;제한&lt;/strong&gt; 은 x에 해당하는 요소 x가 존재하는 경우에만 x S y가되도록 정의 된 세트 S이다.</target>
        </trans-unit>
        <trans-unit id="53dd8e97ddf5e81c0a22de5f228a88721f6ccc8d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;symmetric_difference&quot;&gt;symmetric difference&lt;/strong&gt; of two sets is the set that contains those element that belong to either of the two sets, but not both.</source>
          <target state="translated">두 세트 의 &lt;strong id=&quot;symmetric_difference&quot;&gt;대칭 적 차이&lt;/strong&gt; 는 두 세트 중 하나에 속하는 요소를 포함하는 세트입니다.</target>
        </trans-unit>
        <trans-unit id="baf0cfcddb027f4d4f3dff2390047419348137ab" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union&quot;&gt;union&lt;/strong&gt; of two sets A and B is the smallest set that contains all elements of A and all elements of B.</source>
          <target state="translated">두 세트 A와 B 의 &lt;strong id=&quot;union&quot;&gt;합집합&lt;/strong&gt; 은 A의 모든 요소와 B의 모든 요소를 ​​포함하는 가장 작은 세트입니다.</target>
        </trans-unit>
        <trans-unit id="81d4f87a2b598bff542bef7879776b07f0f811bb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union_n&quot;&gt;union&lt;/strong&gt; of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection.</source>
          <target state="translated">집합 집합 의 &lt;strong id=&quot;union_n&quot;&gt;합집합&lt;/strong&gt; 은 하나 이상의 집합 집합에 속하는 모든 요소를 ​​포함하는 가장 작은 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5d51e506fb7ebd09e0439b577c3665c859bbc0bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Auto Attach&lt;/strong&gt; boxes, &lt;strong&gt;Stack Trace&lt;/strong&gt; label, &lt;strong&gt;Back Trace Size&lt;/strong&gt; label, and &lt;strong&gt;Strings&lt;/strong&gt; box display some options set. For details about these options, see section &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;자동 부착&lt;/strong&gt; 상자, &lt;strong&gt;스택 추적&lt;/strong&gt; 라벨, &lt;strong&gt;역 추적 크기&lt;/strong&gt; 레이블 및 &lt;strong&gt;문자열&lt;/strong&gt; 상자 디스플레이 설정 몇 가지 옵션. 이러한 옵션에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abcaf1a971590700133b8016539b636c71ba876f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Break&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">&lt;strong&gt;브레이크&lt;/strong&gt; , &lt;strong&gt;윈도우&lt;/strong&gt; 및 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴는에서와 동일 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; 것을 제외하고, &lt;strong&gt;브레이크의&lt;/strong&gt; 메뉴는 현지 중단 점에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a10eb03f19350fbdf85025a9eab01c5153042f77" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Breaks&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">&lt;strong&gt;브레이크&lt;/strong&gt; , &lt;strong&gt;윈도우&lt;/strong&gt; 및 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴는에서와 동일 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; 것을 제외하고, &lt;strong&gt;휴식의&lt;/strong&gt; 메뉴는 현지 중단 점에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="81208a589d29fcc1ae9246757bcbbd412aee1292" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; by callbacks before and after all test suite calls. It is intended for advanced users of &lt;code&gt;Common Test&lt;/code&gt; who want to abstract out behavior that is common to multiple test suites.</source>
          <target state="translated">&lt;strong&gt;일반적인 테스트 훅 (CTH)&lt;/strong&gt; 프레임 워크의 기본 동작의 확장 할 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 전에 모든 테스트 스위트 통화 후 콜백으로합니다. 여러 테스트 스위트에 공통적 인 동작을 추상화하려는 &lt;code&gt;Common Test&lt;/code&gt; 의 고급 사용자를위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e6fc5c94241e7e52f12a5fd7bd3416eff9018efa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; using hooks before and after all test suite calls. CTHs allow advanced &lt;code&gt;Common Test&lt;/code&gt; users to abstract out behavior that is common to multiple test suites without littering all test suites with library calls. This can be used for logging, starting, and monitoring external systems, building C files needed by the tests, and so on.</source>
          <target state="translated">&lt;strong&gt;일반적인 테스트 훅 (CTH)&lt;/strong&gt; 프레임 워크의 기본 동작의 확장 할 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 전에 모든 테스트 스위트 통화 후 후크를 사용합니다. CTH를 사용하면 고급 &lt;code&gt;Common Test&lt;/code&gt; 사용자는 모든 테스트 스위트를 라이브러리 호출로 어지럽히 지 않고 여러 테스트 스위트에 공통적 인 동작을 추출 할 수 있습니다. 이것은 외부 시스템의 로깅, 시작 및 모니터링, 테스트에 필요한 C 파일 작성 등에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18cdc049609d4e15a26ab891a990c31ae80de460" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; and &lt;strong&gt;Edit&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 및 &lt;strong&gt;편집&lt;/strong&gt; 메뉴는과 동일 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4e15bb4c0b2061b264590ff96d04af89b93805" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; menu includes options to save the contents of the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window. Simply choose the options and enter the file to save the contents in.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 메뉴의 내용을 저장하는 옵션이 포함되어 &lt;strong&gt;로그&lt;/strong&gt; 창 및 &lt;strong&gt;경고&lt;/strong&gt; 창을여십시오. 옵션을 선택하고 파일을 입력하여 내용을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="370a6214852f8fdbb6373c8997912c0758173f20" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; window displays a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 창이 표시는 현재 디렉토리의 목록. 추가하려는 디렉토리 / 모듈로가는 길을 클릭하거나 항목에 올바른 경로를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8e3940de2fcf0c6b61297d85ec453fc7187e592a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;OTP design principles&lt;/strong&gt; define how to structure Erlang code in terms of processes, modules, and directories.</source>
          <target state="translated">&lt;strong&gt;OTP 설계 원칙은&lt;/strong&gt; 프로세스, 모듈 및 디렉토리의 측면에서 얼랑 코드를 구성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ce6dbe8f8ec89aa3b4f8a5fbd8bce3df7dce0384" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;anonymous variable&lt;/strong&gt; is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</source>
          <target state="translated">&lt;strong&gt;익명 변수&lt;/strong&gt; 밑줄 (_)을 표시하고, 변수가 필요하지만, 그 값은 무시 될 수있을 때 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="a6798179458a851b9ebec479cdde3c475bff4cbb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application resource file&lt;/strong&gt; specifies the resources an application uses, and how the application is started. There must always be one application resource file called &lt;code&gt;Application.app&lt;/code&gt; for each application &lt;code&gt;Application&lt;/code&gt; in the system.</source>
          <target state="translated">&lt;strong&gt;응용 프로그램의 리소스 파일은&lt;/strong&gt; 응용 프로그램이 사용하는 자원을 지정하고, 응용 프로그램이 어떻게 시작됩니다. 시스템의 각 응용 &lt;code&gt;Application&lt;/code&gt; 응용 프로그램 마다 &lt;code&gt;Application.app&lt;/code&gt; 라는 응용 프로그램 리소스 파일이 항상 하나 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f6e14a23d7c2ef8d516ebeb71a889d63ab7e5e5f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application upgrade file&lt;/strong&gt; defines how an application is upgraded or downgraded in a running system.</source>
          <target state="translated">&lt;strong&gt;응용 프로그램 업그레이드 파일의&lt;/strong&gt; 응용 프로그램 업그레이드 또는 실행중인 시스템에서 다운 그레이드하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2db57b7456855f2efbc5591cfd1f43a7d95e2566" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;boot script&lt;/strong&gt; describes how the Erlang runtime system is started. It contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">&lt;strong&gt;부팅 스크립트는&lt;/strong&gt; 얼랭 런타임 시스템이 시작하는 방법에 대해 설명합니다. 로드 할 코드와 시작할 프로세스 및 응용 프로그램에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5741097334e8b8597284eb3550244c5de695e977" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백 모드가&lt;/strong&gt; 개시 될 때 선택 &lt;code&gt;gen_statem&lt;/code&gt; 를 코드 변화 후에 반환 값을 사용 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010c2dfc5017e7774d251ec3e8505c4cdafc0e30" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;detailed table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;자세한 테이블 이벤트는&lt;/strong&gt; 같은 튜플이다 &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="60cb531fb67c541100e62d6289d443a02cba5fa3" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty set&lt;/strong&gt; contains no elements.</source>
          <target state="translated">&lt;strong&gt;빈 세트&lt;/strong&gt; 에 요소가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="529d8e8336cfdf10118ffc9b093a47018a9c6171" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;mstone2&lt;/strong&gt; is similar to the &lt;strong&gt;mstone1&lt;/strong&gt; tool, but in this case, each created process makes only &lt;strong&gt;one&lt;/strong&gt; run through the messages and then exits. A soon as a process exits, a new process (with the same config and messages) is created to takes its place. The number of messages processed in total is the mstone2(1) value.</source>
          <target state="translated">&lt;strong&gt;mstone2는&lt;/strong&gt; 받는 사람과 유사 &lt;strong&gt;mstone1의&lt;/strong&gt; 도구지만,이 경우 생성 된 각각의 프로세스는 만드는 &lt;strong&gt;하나의&lt;/strong&gt; 메시지와 다음 종료를 통해 실행. 프로세스가 종료 되 자마자 동일한 구성 및 메시지를 가진 새 프로세스가 생성됩니다. 총 처리 된 메시지 수는 mstone2 (1) 값입니다.</target>
        </trans-unit>
        <trans-unit id="b927187f56617f5aef02c9b312ff36f409a08649" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ordered pair&lt;/strong&gt; of a and b, with first &lt;strong&gt;coordinate&lt;/strong&gt; a and second coordinate b, is denoted (a, b). An ordered pair is an &lt;strong&gt;ordered set&lt;/strong&gt; of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements.</source>
          <target state="translated">제 1 &lt;strong&gt;좌표&lt;/strong&gt; a 및 제 2 좌표 b 를 갖는 &lt;strong&gt;순서화&lt;/strong&gt; 된 a 및 b의 &lt;strong&gt;쌍&lt;/strong&gt; 은 (a, b)로 표시된다. 순서 쌍은 순서가 &lt;strong&gt;지정된&lt;/strong&gt; 두 요소 &lt;strong&gt;집합&lt;/strong&gt; 입니다. 이 모듈에서 순서 집합은 하나, 둘 또는 그 이상의 요소를 포함 할 수 있으며 괄호는 요소를 묶는 데 사용됩니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83c801cd635dbe318e9132115de7b55b1599720" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;receiver&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which expects a response (for example Get, GetNext, Get-Bulk, Set or Inform PDU).</source>
          <target state="translated">&lt;strong&gt;수신기&lt;/strong&gt; 이고 &lt;strong&gt;신뢰할&lt;/strong&gt; 응답 예상 함유 메시지 페이로드 (예를 얻기위한, GETNEXT는 벌크 - 위젯 설정 또는 PDU 알린다).</target>
        </trans-unit>
        <trans-unit id="ac92db4f0e00aaa89bb19e432441af806acad352" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release handler&lt;/strong&gt; process belongs to the SASL application, which is responsible for &lt;strong&gt;release handling&lt;/strong&gt;, that is, unpacking, installation, and removal of release packages.</source>
          <target state="translated">&lt;strong&gt;릴리스 핸들러&lt;/strong&gt; 과정을 담당하는 SASL 응용 프로그램에 속하는 &lt;strong&gt;자료 처리&lt;/strong&gt; 풀고,이다, 설치 및 릴리스 패키지의 제거.</target>
        </trans-unit>
        <trans-unit id="91dc52a591c8ca51fdb38124dea4daf9b7e6ea32" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release resource file&lt;/strong&gt; specifies which applications are included in a release (system) based on Erlang/OTP.</source>
          <target state="translated">&lt;strong&gt;릴리스 리소스 파일&lt;/strong&gt; 얼랑 / OTP에 기반 응용 프로그램 릴리스 (시스템)에 포함되어 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ad1a94e9c3dc7a7604b7beecc0ad4192b022ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release upgrade file&lt;/strong&gt; describes how a release is upgraded in a running system.</source>
          <target state="translated">&lt;strong&gt;버전 업그레이드 파일은&lt;/strong&gt; 릴리스가 실행중인 시스템에서 업그레이드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="df96a6a378319ab14151f9909dca99424881e367" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;sender&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which does &lt;strong&gt;not&lt;/strong&gt; expect a response (for example SNMPv2-Trap, Response or Report PDU).</source>
          <target state="translated">&lt;strong&gt;발신자&lt;/strong&gt; 이고 &lt;strong&gt;신뢰할&lt;/strong&gt; 않는 페이로드를 포함한 메시지 &lt;strong&gt;없다&lt;/strong&gt; (예 트랩은 SNMPv2 응답 또는 보고서 PDU를위한)에 대한 응답을 예상한다.</target>
        </trans-unit>
        <trans-unit id="4ac925cddc8d38d70b14e09284795baa1f665f91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simple table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;간단한 테이블 이벤트는&lt;/strong&gt; 같은 튜플이다 &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2fcc34c431d064d6d4c4085640be13ac8df36a55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;system tracer&lt;/strong&gt; for sequential tracing is automatically initiated by &lt;code&gt;ttb&lt;/code&gt; when a trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;시스템 추적&lt;/strong&gt; 순차적 인 추적을위한이 자동으로 시작됩니다 &lt;code&gt;ttb&lt;/code&gt; 추적 포트가 시작되면 &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33df7c3d6f3cf265ee046f5bbcec06d7fee2046" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;unordered set&lt;/strong&gt; containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples.</source>
          <target state="translated">&lt;strong&gt;순서화 세트&lt;/strong&gt; A, B 및 C로 표시되는 요소 {A, B, C를 함유}. 이 표기법은 튜플과 혼동되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="338f2ff3d932d37a0203031cf3c8ecd12e555100" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;xmerl&lt;/strong&gt; XML parser is able to parse XML documents according to the XML 1.0 standard. As default it performs well-formed parsing, (syntax checks and checks of well-formed constraints). Optionally one can also use xmerl as a validating parser, (validate according to referenced DTD and validating constraints). By means of for example the xmerl_xs module it is possible to transform the parsed result to other formats, e.g. text, HTML, XML etc.</source>
          <target state="translated">&lt;strong&gt;xmerl의&lt;/strong&gt; XML 파서는 XML 1.0 표준에 따라 구문 분석 XML 문서를 할 수 있습니다. 기본적으로 올바른 형식의 구문 분석 (구문 검사 및 올바른 형식의 제약 조건 검사)을 수행합니다. 선택적으로 xmerl을 유효성 검사 파서로 사용할 수도 있습니다 (참조 된 DTD 및 유효성 검사 제약 조건에 따라 유효성 검사). 예를 들어 xmerl_xs 모듈을 사용하면 구문 분석 된 결과를 다른 형식 (예 : 텍스트, HTML, XML 등)으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="639ddc138940995a6e19ca0db97584c255b5e3c9" translate="yes" xml:space="preserve">
          <source>The ACC time calculation is sometimes difficult to make correct, since it is difficult to define. This happens especially when a function occurs in several instances in the call stack, for example by calling itself perhaps through other functions and perhaps even non-tail recursively.</source>
          <target state="translated">ACC 시간 계산은 정의하기가 어렵 기 때문에 때때로 정확하기가 어렵습니다. 이것은 특히 호출 스택의 여러 인스턴스에서 함수가 발생할 때 발생합니다 (예 : 다른 함수를 통해 자체적으로 또는 비 꼬리 재귀 적으로 호출).</target>
        </trans-unit>
        <trans-unit id="57e2a8ffba28b7446bf70cbc1663f4839a28353c" translate="yes" xml:space="preserve">
          <source>The AND intersection of the list &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt; is also easily defined:</source>
          <target state="translated">리스트 &lt;code&gt;L1&lt;/code&gt; 과 &lt;code&gt;L2&lt;/code&gt; 의 AND 교차점 도 쉽게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="79ddb999f667f09a910e3689c6469b160527272a" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로깅 용 API는 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 세트 와 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 형식의 함수 세트로 구성되며 ,이 함수 는 모두 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 바로 가기입니다 . .</target>
        </trans-unit>
        <trans-unit id="9d41ee39dfc3d3300eef2e7cc4120a5fd8d4f83d" translate="yes" xml:space="preserve">
          <source>The API is simple:</source>
          <target state="translated">API는 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="d4aca81b201537abe8dedf009dd68114d62d46d3" translate="yes" xml:space="preserve">
          <source>The API provided by Windows.</source>
          <target state="translated">Windows에서 제공하는 API.</target>
        </trans-unit>
        <trans-unit id="ea6764678e9074dc87171f45bcd4511b8aa2d4d8" translate="yes" xml:space="preserve">
          <source>The ASN.1 application provides the following:</source>
          <target state="translated">ASN.1 애플리케이션은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9c1b6316b531e843db6912095bad2d7449901534" translate="yes" xml:space="preserve">
          <source>The ASN.1 code, the Erlang source code, and the generated &lt;code&gt;.hrl&lt;/code&gt; files for them are provided in the distribution and are placed in the directories &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, and &lt;code&gt;include&lt;/code&gt;, respectively, in the &lt;code&gt;snmp&lt;/code&gt; application.</source>
          <target state="translated">의 ASN 코드, 얼랭 소스 코드 및 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 의 그들을 위해 파일 배포에 제공되며, 디렉토리에 배치 &lt;code&gt;mibs&lt;/code&gt; , &lt;code&gt;src&lt;/code&gt; , 그리고 &lt;code&gt;include&lt;/code&gt; 에 각각 &lt;code&gt;snmp&lt;/code&gt; 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="c4c076a03aaf6d1e948523fb216ccde0cc05b7f7" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler can be started directly from the command line by the &lt;code&gt;erlc&lt;/code&gt; program. This is convenient when compiling many ASN.1 files from the command line or when using Makefiles. Some examples of how the &lt;code&gt;erlc&lt;/code&gt; command can be used to start the ASN.1 compiler:</source>
          <target state="translated">ASN.1 컴파일러는 &lt;code&gt;erlc&lt;/code&gt; 프로그램에 의해 명령 행에서 직접 시작할 수 있습니다 . 명령 줄에서 많은 ASN.1 파일을 컴파일하거나 Makefile을 사용할 때 편리합니다. &lt;code&gt;erlc&lt;/code&gt; 명령을 사용하여 ASN.1 컴파일러를 시작하는 방법에 대한 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="fb22058cd698b91ccb24c3e367daf392b4a590e1" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can encode and decode the specified data types. Alternatively, the compiler takes a specification module specifying all input modules, and generates a module with encode/decode functions. In addition, some generic functions can be used during development of applications that handles ASN.1 data (encoded as &lt;code&gt;BER&lt;/code&gt; or &lt;code&gt;PER&lt;/code&gt;).</source>
          <target state="translated">ASN.1 컴파일러는 ASN.1 모듈을 입력으로 받아서 해당 Erlang 모듈을 생성하여 지정된 데이터 유형을 인코딩하고 디코딩 할 수 있습니다. 또는 컴파일러는 모든 입력 모듈을 지정하는 사양 모듈을 가져 와서 인코딩 / 디코딩 기능이있는 모듈을 생성합니다. 또한 ASN.1 데이터를 처리하는 애플리케이션을 개발하는 동안 일부 일반 기능을 사용할 수 있습니다 ( &lt;code&gt;BER&lt;/code&gt; 또는 &lt;code&gt;PER&lt;/code&gt; 로 인코딩 됨 ).</target>
        </trans-unit>
        <trans-unit id="c60d4a11ddc52b500d299eda7e6852a95f2bae35" translate="yes" xml:space="preserve">
          <source>The ASN.1 specifications in the test were compiled with options &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; and &lt;code&gt;asn1config&lt;/code&gt;. Omitting option &lt;code&gt;driver&lt;/code&gt; gives higher values for &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;decode_part&lt;/code&gt;. These tests have not been rerun using NIFs, but are expected to perform about 5% better than the linked-in driver.</source>
          <target state="translated">테스트의 ASN.1 스펙은 &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; 및 &lt;code&gt;asn1config&lt;/code&gt; 옵션으로 컴파일 되었습니다 . 옵션 &lt;code&gt;driver&lt;/code&gt; 를 생략 하면 &lt;code&gt;decode&lt;/code&gt; 및 &lt;code&gt;decode_part&lt;/code&gt; 에 더 높은 값이 제공 됩니다. 이 테스트는 NIF를 사용하여 다시 실행되지 않았지만 링크 된 드라이버보다 약 5 % 더 나은 성능을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="2f22980605315f568d967ab23f6f0f04c10f0db4" translate="yes" xml:space="preserve">
          <source>The ASN.1 to Erlang compiler does not determine the correct interpretation of each BER string octet value with different character strings. The application is responsible for interpretation of octets. Therefore, from the BER string point of view, octets are very similar to character strings and are compiled in the same way.</source>
          <target state="translated">ASN.1 대 Erlang 컴파일러는 서로 다른 문자열로 각 BER 문자열 옥텟 값의 올바른 해석을 결정하지 않습니다. 응용 프로그램은 옥텟의 해석을 담당합니다. 따라서 BER 문자열 관점에서 옥텟은 문자열과 매우 유사하며 동일한 방식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="e882c6bd57a43305a3640939f477df3d4ead459d" translate="yes" xml:space="preserve">
          <source>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</source>
          <target state="translated">ASN.1 유형은 'Certificate', 'OTPCertificate'또는 하위 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a7f7547a93bea8b589e07f519f153c18f157b7" translate="yes" xml:space="preserve">
          <source>The AVPs of the message. Ignored for an outgoing message if the &lt;code&gt;msg&lt;/code&gt; field is set to a value other than &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">메시지의 AVP &lt;code&gt;msg&lt;/code&gt; 필드가 &lt;code&gt;undefined&lt;/code&gt; 이외의 값으로 설정된 경우 발신 메시지에 대해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbe283419a75e9a012fbd1970d31d2b4f451187c" translate="yes" xml:space="preserve">
          <source>The Adler checksum of the dictionary is returned.</source>
          <target state="translated">사전의 Adler 체크섬이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c87eb8ebe47038b4ccdd22aaa97c4f88f2c5c087" translate="yes" xml:space="preserve">
          <source>The Application Id is set in the Diameter Header of outgoing messages of the application, and the value in the header of an incoming message is used to identify the relevant dictionary module.</source>
          <target state="translated">애플리케이션 ID는 애플리케이션의 발신 메시지 직경 헤더에 설정되며 수신 메시지 헤더의 값은 관련 사전 모듈을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5de0091f6607fa5ed052b8880c8cef363f44808" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to do the actual changing of the type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제로 유형을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ffaae1f3e0b8fd90d36e73237642154e3434485" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to retrieve the actual log-type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제 로그 유형을 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="56bc2b11b64e2a80365e104579b5470c818d8f1f" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to return the actual log-type.</source>
          <target state="translated">감사 추적 로그는 네트워크 인터페이스 프로세스에 의해 관리됩니다. 따라서이 프로세스는 실제 로그 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb9967052a764c3afae20ad96d6a28a3fa28a91f" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to &lt;code&gt;true&lt;/code&gt;, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</source>
          <target state="translated">BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 은 함수에 일치 스펙을 추가 할 수도 있습니다. 일치 스펙은 함수 인수가 일치해야하는 패턴, &lt;code&gt;true&lt;/code&gt; 로 평가되어야하는 가드 표현식 및 수행 할 조치로 구성됩니다. 기본 조치는 추적 메시지를 보내는 것입니다. 패턴이 일치하지 않거나 가드가 실패하면 조치가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e87dd32697c643963810be073120b237d9b1c65" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;open_port/2&lt;/code&gt; is documented in the &lt;code&gt;erlang&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">BIF &lt;code&gt;open_port/2&lt;/code&gt; 는 ERTS 의 &lt;code&gt;erlang&lt;/code&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="102d447ee7d66bcdc64a15b95caa727b7d5ec384" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system.</source>
          <target state="translated">BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; 는 향후로드를 추정하는 데 사용됩니다. Erlang 런타임 시스템에서 프로세스를 실행할 준비가 된 대기열의 길이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a6a407c55efe87e4b70f70a1f8c95515dc9b4791" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;throw(Any)&lt;/code&gt; can be used for non-local return from a function. It must be evaluated within a &lt;code&gt;catch&lt;/code&gt;, which returns the value &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;throw(Any)&lt;/code&gt; 는 함수에서 로컬이 아닌 리턴으로 사용될 수 있습니다. &lt;code&gt;catch&lt;/code&gt; 내에서 평가되어야하며 이는 &lt;code&gt;Any&lt;/code&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="30ca995f69db34040dadf8f4fb8f2daa8f294d98" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; checks if a registered process of name &lt;code&gt;RegisteredName&lt;/code&gt; exists. If it exists, the pid of that process is returned. If it does not exist, the atom &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; 은 &lt;code&gt;RegisteredName&lt;/code&gt; 이라는 이름의 등록 된 프로세스가 존재 하는지 확인 합니다. 존재하는 경우 해당 프로세스의 pid가 리턴됩니다. 존재하지 않는 경우, 원자 &lt;code&gt;undefined&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
