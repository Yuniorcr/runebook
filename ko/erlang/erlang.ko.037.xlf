<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="d651b987b0a7139ea05af6dee8d526234f2fc5bb" translate="yes" xml:space="preserve">
          <source>Type &quot;2 + 5.&quot; in the shell and then press Enter (carriage return). Notice that you tell the shell you are done entering code by finishing with a full stop &quot;.&quot; and a carriage return.</source>
          <target state="translated">&quot;2 + 5&quot;를 입력하십시오. 셸에서 Enter 키를 누릅니다 (캐리지 리턴). 쉼표 ( &quot;)&quot;로 마무리하면 코드 입력이 완료되었음을 쉘에 알 수 있습니다. 캐리지 리턴.</target>
        </trans-unit>
        <trans-unit id="58364f896fc728f993e560667ecfb60de4f30fa0" translate="yes" xml:space="preserve">
          <source>Type &quot;a&quot; to leave the Erlang system.</source>
          <target state="translated">Erlang 시스템을 종료하려면 &quot;a&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="bb5acf833432a1b10201899b4168eeb24706098c" translate="yes" xml:space="preserve">
          <source>Type ::= &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</source>
          <target state="translated">유형 :: = &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca7274bab6669941602b10cce52d6006cb9d4c5" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt;, that is, the HTTP method.</source>
          <target state="translated">&lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt; 유형 | &quot;POST&quot;| &quot;헤드&quot;| &quot;TRACE&quot; 즉, HTTP 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="7b17bb0639b15e0f667e2fd419629250d1fac8bc" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt;. &lt;code&gt;parsed_header&lt;/code&gt; contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; for a listing of all header fields. For example, the date field is stored as &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt;. RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. &lt;code&gt;httpd&lt;/code&gt; ensures that all header field names are in lower case.</source>
          <target state="translated">유형 &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt; . &lt;code&gt;parsed_header&lt;/code&gt; 는 목록에 키-값 튜플로 저장된 HTTP 요청의 모든 HTTP 헤더 필드를 포함합니다. 모든 헤더 필드 목록은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 예를 들어, 날짜 필드는 &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt; 됩니다. RFC 2616은 HTTP가 대소 문자를 구분하지 않는 프로토콜이며 헤더 필드는 소문자 또는 대문자 일 수 있다고 정의합니다. &lt;code&gt;httpd&lt;/code&gt; 는 모든 헤더 필드 이름이 소문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="88ea934d5b010cb0dc7ac9b9cf16bdd13e544370" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; is used to propagate data between modules. Depicted &lt;code&gt;interaction_data()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">&lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; 유형 은 모듈간에 데이터를 전파하는 데 사용됩니다. 함수 타입 선언에서 &lt;code&gt;interaction_data()&lt;/code&gt; 를 묘사했습니다 .</target>
        </trans-unit>
        <trans-unit id="1a1f7e9e5b0f8e672e72370d1ca9a97b0c0c8e01" translate="yes" xml:space="preserve">
          <source>Type UTF8String is represented as a UTF-8 encoded binary in Erlang. Such binaries can be created directly using the binary syntax or by converting from a list of Unicode code points using function &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">UTF8String 유형은 Erlang에서 UTF-8로 인코딩 된 이진으로 표시됩니다. 이러한 이진은 이진 구문을 사용하거나 &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt; 함수를 사용하여 유니 코드 코드 포인트 목록에서 변환하여 직접 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b347ce4e1bb3f750a45e84a0eec8e47bcbc5d1c" translate="yes" xml:space="preserve">
          <source>Type declarations can also be parameterized by including type variables between the parentheses. The syntax of type variables is the same as Erlang variables, that is, starts with an upper-case letter. Naturally, these variables can - and is to - appear on the RHS of the definition. A concrete example follows:</source>
          <target state="translated">괄호 사이에 유형 변수를 포함시켜 유형 선언을 매개 변수화 할 수도 있습니다. 변수 유형의 구문은 Erlang 변수와 동일합니다. 즉 대문자로 시작합니다. 당연히 이러한 변수는 정의의 RHS에 나타날 수 있습니다. 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6300b103de258ff822aa6629b9e4238dd2a5ce7d" translate="yes" xml:space="preserve">
          <source>Type definitions related to HTTP:</source>
          <target state="translated">HTTP 관련 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="833b41c81d15ae09af14347e83ccba5147adbd10" translate="yes" xml:space="preserve">
          <source>Type definitions that are related to URI:</source>
          <target state="translated">URI와 관련된 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="b644ccc50476a72e86f7c39296fad76704713706" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</source>
          <target state="translated">이 모듈에서 두 번 이상 사용되는 유형 정의 또는 데이터 유형의 의도 된 사용을 나타내는 추상화 또는 둘 다 :</target>
        </trans-unit>
        <trans-unit id="d2cf34335496de985396b3065117c3a7c2a8fa2b" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module:</source>
          <target state="translated">이 모듈에서 두 번 이상 사용되는 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="dfb0b5d119973a2ca756d65efb3094aa7a2749aa" translate="yes" xml:space="preserve">
          <source>Type information can be used for the following:</source>
          <target state="translated">유형 정보는 다음에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebeb58712dc090b9f1c0c555b88300efc0c9f1b" translate="yes" xml:space="preserve">
          <source>Type makensis at the bash prompt and you should get a list of options if everything is OK.</source>
          <target state="translated">bash 프롬프트에서 makensis를 입력하면 모든 것이 정상이면 옵션 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e5d444f8eae5fc410e04ffff9e480446db812725" translate="yes" xml:space="preserve">
          <source>Type of lock: &lt;code&gt;rw_mutex&lt;/code&gt;, &lt;code&gt;mutex&lt;/code&gt;, &lt;code&gt;spinlock&lt;/code&gt;, &lt;code&gt;rw_spinlock&lt;/code&gt; or &lt;code&gt;proclock&lt;/code&gt;.</source>
          <target state="translated">잠금의 종류 : &lt;code&gt;rw_mutex&lt;/code&gt; , &lt;code&gt;mutex&lt;/code&gt; , &lt;code&gt;spinlock&lt;/code&gt; , &lt;code&gt;rw_spinlock&lt;/code&gt; 또는 &lt;code&gt;proclock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ab1c2b1113b129c21326cea282b309a413da68f9" translate="yes" xml:space="preserve">
          <source>Type tests: &lt;code&gt;is_atom&lt;/code&gt;, &lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_integer&lt;/code&gt;, &lt;code&gt;is_list&lt;/code&gt;, &lt;code&gt;is_number&lt;/code&gt;, &lt;code&gt;is_pid&lt;/code&gt;, &lt;code&gt;is_port&lt;/code&gt;, &lt;code&gt;is_reference&lt;/code&gt;, &lt;code&gt;is_tuple&lt;/code&gt;, &lt;code&gt;is_binary&lt;/code&gt;, &lt;code&gt;is_function&lt;/code&gt;, &lt;code&gt;is_record&lt;/code&gt;</source>
          <target state="translated">유형 테스트 : &lt;code&gt;is_atom&lt;/code&gt; , &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_integer&lt;/code&gt; , &lt;code&gt;is_list&lt;/code&gt; , &lt;code&gt;is_number&lt;/code&gt; , &lt;code&gt;is_pid&lt;/code&gt; , &lt;code&gt;is_port&lt;/code&gt; , &lt;code&gt;is_reference&lt;/code&gt; , &lt;code&gt;is_tuple&lt;/code&gt; , &lt;code&gt;is_binary&lt;/code&gt; , &lt;code&gt;is_function&lt;/code&gt; , &lt;code&gt;is_record&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca8a72020b7154672a01a7e0906d7d4fb8f5305d" translate="yes" xml:space="preserve">
          <source>Type variables can be used in specifications to specify relations for the input and output arguments of a function. For example, the following specification defines the type of a polymorphic identity function:</source>
          <target state="translated">사양에서 유형 변수를 사용하여 함수의 입력 및 출력 인수에 대한 관계를 지정할 수 있습니다. 예를 들어 다음 사양은 다형성 항등 함수의 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="d9cf88052e09b9cf4919f33ab2053b176aa31518" translate="yes" xml:space="preserve">
          <source>Types corresponding to RFC 6733 AVP Data Formats. Defined in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">RFC 6733 AVP 데이터 형식에 해당하는 유형입니다. &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19b63cf79ea9c163682784b133c791343ee64d2c" translate="yes" xml:space="preserve">
          <source>Types declared as &lt;code&gt;opaque&lt;/code&gt; represent sets of terms whose structure is not supposed to be visible from outside of their defining module. That is, only the module defining them is allowed to depend on their term structure. Consequently, such types do not make much sense as module local - module local types are not accessible by other modules anyway - and is always to be exported.</source>
          <target state="translated">&lt;code&gt;opaque&lt;/code&gt; 선언 된 유형은 정의 모듈 외부에서 구조를 볼 수없는 용어 집합을 나타냅니다. 즉, 그것들을 정의하는 모듈 만이 용어 구조에 의존 할 수 있습니다. 결과적으로 이러한 유형은 모듈 로컬-모듈 로컬 유형은 다른 모듈에서 액세스 할 수 없으며 항상 내 보내야하므로 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="535782a993effddbcbcaf96e815b800bf2866b08" translate="yes" xml:space="preserve">
          <source>Types describe sets of Erlang terms. Types consist of, and are built from, a set of predefined types, for example, &lt;code&gt;integer()&lt;/code&gt;, &lt;code&gt;atom()&lt;/code&gt;, and &lt;code&gt;pid()&lt;/code&gt;. Predefined types represent a typically infinite set of Erlang terms that belong to this type. For example, the type &lt;code&gt;atom()&lt;/code&gt; denotes the set of all Erlang atoms.</source>
          <target state="translated">유형은 Erlang 용어 세트를 설명합니다. 유형은 사전 정의 된 유형 세트 &lt;code&gt;integer()&lt;/code&gt; 예 : integer () , &lt;code&gt;atom()&lt;/code&gt; 및 &lt;code&gt;pid()&lt;/code&gt; 유형에서 빌드됩니다 . 미리 정의 된 유형은이 유형에 속하는 일반적으로 무한한 Erlang 용어 집합을 나타냅니다. 예를 들어, &lt;code&gt;atom()&lt;/code&gt; 유형 은 모든 Erlang 원자 세트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4826f9f1cd21548c629153b4f8bdd98bd55b49d6" translate="yes" xml:space="preserve">
          <source>Types that refer to themselves are called recursive types. Example:</source>
          <target state="translated">자신을 참조하는 유형을 재귀 유형이라고합니다. 예:</target>
        </trans-unit>
        <trans-unit id="1c02047b4473ab1d57fc7225f4164216e6bcfaf2" translate="yes" xml:space="preserve">
          <source>Types:</source>
          <target state="translated">Types:</target>
        </trans-unit>
        <trans-unit id="2f711f90b7022e079d8d5f49cef08ad4c28d080c" translate="yes" xml:space="preserve">
          <source>Typical &lt;code&gt;Reasons&lt;/code&gt;s:</source>
          <target state="translated">일반적인 &lt;code&gt;Reasons&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">일반적인 오류 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">일반적인 오류 이유 :</target>
        </trans-unit>
        <trans-unit id="a875996fe6fd67197a25c652eb601e185ed5cc23" translate="yes" xml:space="preserve">
          <source>Typical error reasons: as for &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; if a file had to be opened, and as for &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 오류 이유 : 파일 을 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 하는 경우 open / 2 및 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 와 같은 경우 .</target>
        </trans-unit>
        <trans-unit id="fc74151b7056fe15fd99a84d554133408c7c5852" translate="yes" xml:space="preserve">
          <source>Typical usage when writing to a file descriptor looks like this:</source>
          <target state="translated">파일 디스크립터에 쓸 때의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="fa0583dc7b5aaef5f34ea3fa51cd6e026a525fd0" translate="yes" xml:space="preserve">
          <source>Typically high &lt;code&gt;time&lt;/code&gt; values are bad and this is often the thing to look for. However, one should also look for high lock acquisition frequencies (#tries) since locks generate overhead and because high frequency could become problematic if they begin to have conflicts even if it is not shown in a particular test.</source>
          <target state="translated">일반적으로 높은 &lt;code&gt;time&lt;/code&gt; 값은 좋지 않으며 이는 종종 찾아야 할 사항입니다. 그러나 잠금은 오버 헤드를 생성하고 특정 테스트에 표시되지 않더라도 충돌이 발생하면 높은 주파수가 문제가 될 수 있으므로 높은 잠금 획득 주파수 (#tries)를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="2c47ac130c9d90117072288c85fcf5d65c5fe895" translate="yes" xml:space="preserve">
          <source>Typically the operator, possibly running hundreds or thousands of test cases, does not want to fill the console with details about, or printouts from, specific test cases. By default, the operator only sees the following:</source>
          <target state="translated">일반적으로 수백 또는 수천 개의 테스트 사례를 실행하는 운영자는 특정 테스트 사례에 대한 세부 정보 또는 출력물로 콘솔을 채우고 싶지 않습니다. 기본적으로 운영자에게는 다음 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97e9960729125226aaee305f3d87924465b5abf5" translate="yes" xml:space="preserve">
          <source>Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists.</source>
          <target state="translated">일반적으로 부정을 먼저 대체 한 다음 별칭을 사용한 다음 하나 이상의 확장을 수행합니다 (주 확장을 수행하기 전에 특정 항목을 미리 확장하려는 경우가 있음). 별칭 및 확장 목록의 오른쪽에 이러한 양식을 허용하기 위해 부정 및 / 또는 별칭을 반복해서 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4535970fd788996603de7fcae8b5b1132c50cf1f" translate="yes" xml:space="preserve">
          <source>Typically, OpenSSL engines provide a hardware implementation of specific cryptographic operations. The hardware implementation usually offers improved performance over its software-based counterpart, which is known as cryptographic acceleration.</source>
          <target state="translated">일반적으로 OpenSSL 엔진은 특정 암호화 작업의 하드웨어 구현을 제공합니다. 하드웨어 구현은 일반적으로 암호화 가속이라고하는 소프트웨어 기반 제품보다 향상된 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c81772f74c1a9d8da4ff099d810781ce160aacf0" translate="yes" xml:space="preserve">
          <source>Typographic conventions:</source>
          <target state="translated">활자체 규약 :</target>
        </trans-unit>
        <trans-unit id="0d3d0996d3543e832deef4b0344dd80b1d22ba4d" translate="yes" xml:space="preserve">
          <source>UDP packets from the network</source>
          <target state="translated">네트워크의 UDP 패킷</target>
        </trans-unit>
        <trans-unit id="50aa3ec0f92e35711e8ffb982901d2c7f9850924" translate="yes" xml:space="preserve">
          <source>UDP queries are used unless resolver option &lt;code&gt;usevc&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which forces TCP queries. If the query is too large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.</source>
          <target state="translated">리졸버 옵션 &lt;code&gt;usevc&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아닌 경우 UDP 쿼리가 사용 되어 TCP 쿼리를 강제합니다. 쿼리가 UDP에 비해 너무 큰 경우 TCP가 대신 사용됩니다. 일반 DNS 쿼리의 경우 크기 제한은 512 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="486c66a0286294375958525f91cdfdb3f82c9cb3" translate="yes" xml:space="preserve">
          <source>URI processing functions.</source>
          <target state="translated">URI 처리 기능</target>
        </trans-unit>
        <trans-unit id="1d057bddb70164b040386e82de4c64661e29e8f2" translate="yes" xml:space="preserve">
          <source>URI to filename translation.</source>
          <target state="translated">URI를 파일 이름으로 변환</target>
        </trans-unit>
        <trans-unit id="52c3521da24366089045fe93222bbbea327aa8ee" translate="yes" xml:space="preserve">
          <source>URI utility module</source>
          <target state="translated">URI 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="2497da8c1e8f3017cb461e9ead3580ed94a9004a" translate="yes" xml:space="preserve">
          <source>URL Aliasing</source>
          <target state="translated">URL 별칭</target>
        </trans-unit>
        <trans-unit id="f09d741a3ad78a10aeac235b7eda60b472c1c7ea" translate="yes" xml:space="preserve">
          <source>URL aliasing.</source>
          <target state="translated">URL 별명</target>
        </trans-unit>
        <trans-unit id="284501aa026d810fca5e30ec3e6fbb8b907a7d92" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2390079739ca194b6adba26faaa714759aa93368" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d52349cc271c6019348a86ea4c491c0478f8cdd3" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0133be96d80a337735afdf94d4b6d5617e90e15" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a52ac449904e56f2f8f4257d980b456503a1c2" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b683663e96daabab32de2bda24157392f5a1dc1c" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="276871ba1190025d3a896ad5f2648a68709c0037" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53f076fb21dd236ea02ee81db09d3c6d1a9c2d70" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c130e8186817488b08e47f250bc88b4918c57145" translate="yes" xml:space="preserve">
          <source>URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c0cd56da21e982f4424f294a92af6cffab886e5" translate="yes" xml:space="preserve">
          <source>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can usually use heuristics to determine if a file is in UTF-8 or if it is encoded in ISO Latin-1 (one byte per character). The &lt;code&gt;unicode&lt;/code&gt; module can be used to determine if data can be interpreted as UTF-8:</source>
          <target state="translated">UTF-8은 7 비트 ASCII 범위를 초과하는 숫자를 가진 ISO Latin-1 문자가 UTF-8로 디코딩 될 때 거의 유효한 것으로 간주되지 않도록 설계되었습니다. 따라서 일반적으로 휴리스틱을 사용하여 파일이 UTF-8인지 또는 ISO Latin-1 (문자 당 1 바이트)로 인코딩되었는지 확인할 수 있습니다. &lt;code&gt;unicode&lt;/code&gt; 데이터는 UTF-8로 해석 될 수 있는지 결정하는 모듈을 사용할 수있다 :</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="7a2f970d37032e17cb13a44bc956fa4e60bba4ed" translate="yes" xml:space="preserve">
          <source>Unary +</source>
          <target state="translated">단항 +</target>
        </trans-unit>
        <trans-unit id="898ecd6a265af9abef6adb306b4c0c9c0e00c767" translate="yes" xml:space="preserve">
          <source>Unary + - bnot not</source>
          <target state="translated">단항 +-하지 않습니다</target>
        </trans-unit>
        <trans-unit id="684c6ddd5eb8c278f83bc5399212042f5f7e16e9" translate="yes" xml:space="preserve">
          <source>Unary -</source>
          <target state="translated">단항-</target>
        </trans-unit>
        <trans-unit id="637d4f607a8fd2105b314306ae4c76ef4925ad36" translate="yes" xml:space="preserve">
          <source>Unary bitwise NOT</source>
          <target state="translated">단항 비트 NOT</target>
        </trans-unit>
        <trans-unit id="c9d35054fa41b42db47e25b9d91e662cc93e9f89" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;FormatFun&lt;/code&gt; is used by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; for displaying the call that created the query handle of the table. Defaults to &lt;code&gt;undefined&lt;/code&gt;, which means that &lt;code&gt;info/1,2&lt;/code&gt; displays a call to &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt;. It is up to &lt;code&gt;FormatFun&lt;/code&gt; to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by &lt;code&gt;info/1,2&lt;/code&gt; though).</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;FormatFun&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 에서 테이블의 쿼리 핸들을 작성한 호출을 표시하는 데 사용됩니다 . 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다. 즉, &lt;code&gt;info/1,2&lt;/code&gt; 는 &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt; 대한 호출을 표시합니다 . 테이블의 선택된 개체를 적절한 방식으로 표시 하는 것은 &lt;code&gt;FormatFun&lt;/code&gt; 에 달려 있습니다. 그러나 프리젠 테이션을 위해 문자 목록을 선택한 경우 스캔하고 구문 분석 할 수있는 Erlang 표현식이어야합니다 (마지막 점은 &lt;code&gt;info/1,2&lt;/code&gt; 로 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="8a8cf6ea70815c5c8dc6febb5bc34ace0255c96a" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;InfoFun&lt;/code&gt; is to return information about the table. &lt;code&gt;undefined&lt;/code&gt; is to be returned if the value of some tag is unknown:</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;InfoFun&lt;/code&gt; 은 테이블에 대한 정보를 반환하는 것입니다. 일부 태그의 값을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1442c4ded70572e00f428d9108e7ae55df7a65b5" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;PreFun&lt;/code&gt; is called once before the table is read for the first time. If the call fails, the query evaluation fails.</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;PreFun&lt;/code&gt; 은 테이블을 처음 읽기 전에 한 번 호출됩니다. 호출이 실패하면 쿼리 평가가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a92175579f60db68a9c361cc251147f8debf6b0" translate="yes" xml:space="preserve">
          <source>Unary logical NOT</source>
          <target state="translated">단항 논리 NOT</target>
        </trans-unit>
        <trans-unit id="27bb4c7fe8d37999952aa5b0af1c3595bd259bdb" translate="yes" xml:space="preserve">
          <source>UnaryGraphOp ::= &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</source>
          <target state="translated">UnaryGraphOp :: = &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01c0a17c153449bd9a04099f8971f3292a601fb" translate="yes" xml:space="preserve">
          <source>UnarySetOp ::= &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">UnarySetOp :: = &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="8707e2ffeef5fa8b41de5e679969a877cb9db6f0" translate="yes" xml:space="preserve">
          <source>Unblocks a log. A log can only be unblocked by the blocking process.</source>
          <target state="translated">로그를 차단 해제합니다. 차단 프로세스를 통해서만 로그를 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe39591d424d43f7cc9d6d4ca1303c1c24c48eab" translate="yes" xml:space="preserve">
          <source>Unbound and unsafe variables</source>
          <target state="translated">언 바운드 및 안전하지 않은 변수</target>
        </trans-unit>
        <trans-unit id="b13fe86cfdf1fdbc7031b4349a4b6f2fc354ab38" translate="yes" xml:space="preserve">
          <source>Uncompressed Size</source>
          <target state="translated">압축되지 않은 크기</target>
        </trans-unit>
        <trans-unit id="0a4c7b6c3e87ff86f41e836e792f67b6c2bdf902" translate="yes" xml:space="preserve">
          <source>Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded:</source>
          <target state="translated">압축되지 않은 크기 (빅 엔디안 바이트 순서의 부호없는 32 비트 정수)는 압축되기 전의 데이터 크기입니다. 압축 된 데이터는 확장되었을 때 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="848b92d8de0252bd79df355552090abc0668ced9" translate="yes" xml:space="preserve">
          <source>Uncompresses data with gz headers and checksum.</source>
          <target state="translated">gz 헤더와 체크섬이있는 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="79897564d08477a4d49effa829f40061f9569280" translate="yes" xml:space="preserve">
          <source>Uncompresses data with zlib headers and checksum.</source>
          <target state="translated">zlib 헤더와 체크섬이있는 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="6ad0694c3152ef1643cde8ba2d996a0323a6b4d2" translate="yes" xml:space="preserve">
          <source>Uncompresses data without zlib headers and checksum.</source>
          <target state="translated">zlib 헤더 및 체크섬없이 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="a1c0570481ff7f3e6ed039d51cc86442ea076a33" translate="yes" xml:space="preserve">
          <source>Undefined thread that is not a scheduler thread.</source>
          <target state="translated">스케줄러 스레드가 아닌 정의되지 않은 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="f7aa71224a65884ef564916a9d0da2f89835d7d4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;$ROOT/releases&lt;/code&gt;, a new directory &lt;code&gt;B&lt;/code&gt; is created, containing &lt;code&gt;ch_rel-2.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ROOT/releases&lt;/code&gt; 아래에 &lt;code&gt;ch_rel-2.rel&lt;/code&gt; , &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;sys.config&lt;/code&gt; 및 &lt;code&gt;relup&lt;/code&gt; 을 포함 하는 새 디렉토리 &lt;code&gt;B&lt;/code&gt; 가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="9db2e4f4f838b5c44fe9cf387c90abe7108283e8" translate="yes" xml:space="preserve">
          <source>Under Windows, batch file &lt;code&gt;etop.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Windows에서는 배치 파일 &lt;code&gt;etop.bat&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3264cd9d9eb75df44ac7458f032202c1c187eb3e" translate="yes" xml:space="preserve">
          <source>Under Windows, the batch file &lt;code&gt;cdv.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Windows에서는 배치 파일 &lt;code&gt;cdv.bat&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c9e5a121880663dee4769e1af65faa7b494736" translate="yes" xml:space="preserve">
          <source>Under a key, any number of named values can be stored. They have names, types, and data.</source>
          <target state="translated">키 아래에 이름이 지정된 값을 얼마든지 저장할 수 있습니다. 이름, 유형 및 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8f3b0e81b0f054de52ff314e53658c55941c1a" translate="yes" xml:space="preserve">
          <source>Under certain circumstances incompatible changes might be introduced even in parts of the system that should be compatible between releases. Things that might trigger incompatible changes like this are:</source>
          <target state="translated">특정 환경에서는 릴리스간에 호환되어야하는 시스템의 일부에서도 호환되지 않는 변경이 발생할 수 있습니다. 다음과 같이 호환되지 않는 변경을 유발할 수있는 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="572aa08aba747d5d8b7a4a50d789147e2afaec76" translate="yes" xml:space="preserve">
          <source>Under the &lt;strong&gt;Warnings&lt;/strong&gt; pull-down menu, there are buttons that control which discrepancies are reported to the user in the &lt;strong&gt;Warnings&lt;/strong&gt; window. By clicking these buttons, you can enable/disable a whole class of warnings. Information about the classes of warnings is found on the &quot;Warnings&quot; item under the &lt;strong&gt;Help&lt;/strong&gt; menu (in the rightmost top corner).</source>
          <target state="translated">언더 &lt;strong&gt;경고&lt;/strong&gt; 풀다운 메뉴, 불일치가있는 사용자에게보고 제어하는 것을 버튼이 있습니다 &lt;strong&gt;경고&lt;/strong&gt; 창. 이 버튼을 클릭하면 전체 경고 클래스를 활성화 / 비활성화 할 수 있습니다. 경고 클래스에 대한 정보는 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴 (맨 위 오른쪽 모서리) 의 &quot;경고&quot;항목에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6ad23ca12e3d31111c9342b18cb40e19aa690d" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocated_areas&lt;/strong&gt; 태그 아래에는 &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사한 정보가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4c5641fd04e324ff84f71ed58f45687d78170d8" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocator : &amp;lt;A&amp;gt;&lt;/strong&gt; 태그 아래 에 할당 자 &amp;lt;A&amp;gt;에 대한 다양한 정보가 표시됩니다. 이 정보는 &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d37cd225e87fcc610bec30b5a05911619436d89" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtainted on a living node with &lt;code&gt;erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">태그 아래에 &lt;strong&gt;= memory&lt;/strong&gt; 는 &lt;code&gt;erlang:memory()&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사한 정보를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="63ce4685b2bc584945411c035f09d36043b054a2" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=scheduler&lt;/strong&gt; is shown information about the current state and statistics of the schedulers in the runtime system. On operating systems that allow suspension of other threads, the data within this section reflects what the runtime system looks like when a crash occurs.</source>
          <target state="translated">&lt;strong&gt;= scheduler&lt;/strong&gt; 태그 아래에는 런타임 시스템에서 스케줄러의 현재 상태 및 통계에 대한 정보가 표시됩니다. 다른 스레드를 일시 중단 할 수있는 운영 체제에서이 섹션의 데이터는 충돌 발생시 런타임 시스템의 모습을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="c4dc6bd20baf250db6e40693e866b1962ff4e8bc" translate="yes" xml:space="preserve">
          <source>Under the tags &lt;strong&gt;=hash_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; and &lt;strong&gt;=index_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; is shown internal tables. These are mostly of interest for runtime system developers.</source>
          <target state="translated">태그 아래에 &lt;strong&gt;= hash_table : &amp;lt;table_name&amp;gt;&lt;/strong&gt; 및 &lt;strong&gt;= index_table : &amp;lt;table_name&amp;gt;&lt;/strong&gt; 이 내부 테이블로 표시됩니다. 이들은 주로 런타임 시스템 개발자에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc501eac2fcb3163225e3af20fdf997e537c7a6" translate="yes" xml:space="preserve">
          <source>Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before.</source>
          <target state="translated">문서화되지 않은 (구형) 알고리즘은 더 이상 사용되지 않지만 여전히 구현되어있어 이전 코드와 동일한 의사 난수 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="87e34279dd28e6f111c12cefa204d1bbe4761338" translate="yes" xml:space="preserve">
          <source>Undocumented functions in this module are not to be used.</source>
          <target state="translated">이 모듈의 문서화되지 않은 기능은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="196d8f0f66ad490a457b6fb5d6806ec3993a5c10" translate="yes" xml:space="preserve">
          <source>Unfolds all occurrences of atoms in &lt;code&gt;ListIn&lt;/code&gt; to tuples &lt;code&gt;{Atom, true}&lt;/code&gt;.</source>
          <target state="translated">ListIn에서 모든 원자를 &lt;code&gt;ListIn&lt;/code&gt; 하여 &lt;code&gt;{Atom, true}&lt;/code&gt; 튜플 합니다 .</target>
        </trans-unit>
        <trans-unit id="3ab34ddc2bf3b987c39e2558abfd1de510704f88" translate="yes" xml:space="preserve">
          <source>Unicode binary encoded as UTF16 little endian.</source>
          <target state="translated">UTF16 리틀 엔디안으로 인코딩 된 유니 코드 이진.</target>
        </trans-unit>
        <trans-unit id="9476616408be8ddee79977abc7989cebfe910910" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows and MacOS X, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">switch &lt;code&gt;+fnu&lt;/code&gt; 로 유니 코드 파일 이름 변환이 설정됩니다 . Linux에서 파일 이름 변환 모드를 명시 적으로 지정하지 않고 시작한 VM 은 기본 파일 이름 인코딩 으로 &lt;code&gt;latin1&lt;/code&gt; 이 기본값 입니다. Windows 및 MacOS X에서 기본 동작은 유니 코드 파일 이름 변환입니다. 따라서 기본적으로 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 해당 시스템에서 &lt;code&gt;utf8&lt;/code&gt; 을 리턴 합니다 (Windows는 파일 시스템 레벨에서 UTF-8을 사용하지 않지만 Erlang 프로그래머는 무시해도됩니다). 앞에서 언급했듯이 기본 동작은 &lt;code&gt;+fnu&lt;/code&gt; 또는 &lt;code&gt;+fnl&lt;/code&gt; 옵션을 사용 하여 VM 으로 변경할 수 있습니다 ( &lt;code&gt;erl&lt;/code&gt; 프로그램 참조) . VM이 유니 코드 파일 이름 변환 모드에서 시작된 경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 atom &lt;code&gt;utf8&lt;/code&gt; 을 반환합니다 . Switch &lt;code&gt;+fnu&lt;/code&gt; 다음에 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 가 올 바르면 인코딩 된 파일 이름이 잘못보고되는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988784de449d7b8cbc0704eff09bcd0c69371d5a" translate="yes" xml:space="preserve">
          <source>Unicode is a standard defining code points (numbers) for all known, living or dead, scripts. In principle, every symbol used in any language has a Unicode code point. Unicode code points are defined and published by the Unicode Consortium, which is a non-profit organization.</source>
          <target state="translated">유니 코드는 모든 알려진 스크립트, 살아있는 스크립트 또는 죽은 스크립트에 대한 표준 정의 코드 포인트 (숫자)입니다. 원칙적으로 모든 언어에서 사용되는 모든 기호에는 유니 코드 코드 포인트가 있습니다. 유니 코드 코드 포인트는 비영리 조직인 유니 코드 컨소시엄에서 정의하고 게시합니다.</target>
        </trans-unit>
        <trans-unit id="753a9fc18dc38abc9e40310e1511762a587d6d68" translate="yes" xml:space="preserve">
          <source>Unicode metadata stored in PAX headers is preserved</source>
          <target state="translated">PAX 헤더에 저장된 유니 코드 메타 데이터가 유지됩니다</target>
        </trans-unit>
        <trans-unit id="717d423333854e072ef433389e96fff5bd03e76d" translate="yes" xml:space="preserve">
          <source>Unicode support is basically UTF-8 based. To use Unicode characters, you either call &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; with option &lt;code&gt;unicode&lt;/code&gt;, or the pattern must start with one of these special sequences:</source>
          <target state="translated">유니 코드 지원은 기본적으로 UTF-8 기반입니다. 유니 코드 문자를 사용하려면 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 옵션을 &lt;code&gt;unicode&lt;/code&gt; 옵션으로 호출 하거나 패턴이 다음 특수 시퀀스 중 하나로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="9619f5cd0ede72c7dc62df2d3b5ff34d2c75b610" translate="yes" xml:space="preserve">
          <source>Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced.</source>
          <target state="translated">균일 한 플로트는 균일하지 않은 밀도를 가졌기 때문에 작은 값, 즉 0.5보다 작은 값은 생성 된 값이 0.0에 가까워 질수록 간격이 줄어든다. 새로운 알고리즘은 N * 2.0 ^ (-53) 형식으로 균일하게 분포 된 플로트를 생성하므로 간격이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4488ef1f56a2d01fb6e741f79e8378c71279a1d3" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high.</source>
          <target state="translated">균일 한 정수 범위는 확률 분포에서 작은 범위에서는 눈에 띄지 않지만 발생기의 정밀도보다 작은 넓은 범위에서는 비대칭으로 낮은 수를 생성 할 확률은 높은 확률의 두 배가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adabbdf2f0cec9c6d0d246d5a204f96b7e74b355" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce.</source>
          <target state="translated">생성기의 정밀도보다 크거나 같은 균일 한 정수 범위는 요청 된 범위보다 작은 52 비트로 만 계산 된 부동 소수점 폴백을 사용하므로 요청 된 범위의 모든 숫자가 생성 할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="36e839dc7592fa37041cd55253f794215f4f6c06" translate="yes" xml:space="preserve">
          <source>Union of &lt;code&gt;rsa_digest_type()&lt;/code&gt;, &lt;code&gt;dss_digest_type()&lt;/code&gt;, and &lt;code&gt;ecdsa_digest_type()&lt;/code&gt;.</source>
          <target state="translated">연합 &lt;code&gt;rsa_digest_type()&lt;/code&gt; , &lt;code&gt;dss_digest_type()&lt;/code&gt; , 및 &lt;code&gt;ecdsa_digest_type()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a878275b775589505d998070ad22ad6d0081609" translate="yes" xml:space="preserve">
          <source>Unique Integers on a Runtime System Instance</source>
          <target state="translated">런타임 시스템 인스턴스의 고유 정수</target>
        </trans-unit>
        <trans-unit id="a2cc5144e25dba2fec68e539fbd788a730b7301a" translate="yes" xml:space="preserve">
          <source>Unique References on a Runtime System Instance</source>
          <target state="translated">런타임 시스템 인스턴스의 고유 참조</target>
        </trans-unit>
        <trans-unit id="a306f316fd3f985303c362b8053185a26f2e0d45" translate="yes" xml:space="preserve">
          <source>Unique identifier for the application in the scope of the service. Defaults to the value of the &lt;code&gt;dictionary&lt;/code&gt; option.</source>
          <target state="translated">서비스 범위 내에서 응용 프로그램의 고유 식별자입니다. &lt;code&gt;dictionary&lt;/code&gt; 옵션 값이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="5724b00a081ae3e8a4cc6f50314a3e776bc6f0d2" translate="yes" xml:space="preserve">
          <source>Unit Testing is testing of individual program &quot;units&quot; in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</source>
          <target state="translated">단위 테스트는 개별 프로그램 &quot;단위&quot;를 상대적으로 격리하여 테스트하는 것입니다. 특정 크기 요구 사항은 없습니다. 단위는 기능, 모듈, 프로세스 또는 전체 응용 프로그램 일 수 있지만 가장 일반적인 테스트 단위는 개별 기능 또는 모듈입니다. 단위를 테스트하려면 개별 테스트 세트를 지정하고 해당 테스트를 실행할 수있는 가장 작은 환경을 설정하고 (종종 전혀 설정을 수행 할 필요가 없음) 테스트를 실행하고 수집합니다. 결과는 마지막으로 테스트를 나중에 다시 실행할 수 있도록 필요한 정리를 수행합니다. 단위 테스팅 프레임 워크는이 프로세스의 각 단계에서 도움을주기 위해 테스트를 작성하고, 실행하기 쉽고, 실패한 테스트를 쉽게 확인할 수 있도록합니다 (버그를 수정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9caddb3cd5b7265345df4fab350e48f214540b46" translate="yes" xml:space="preserve">
          <source>Universal Time. UT1 is based on the rotation of the earth and conceptually means solar time at 0&amp;deg; longitude.</source>
          <target state="translated">세계시. UT1은 지구의 회전을 기반으로하며 개념적으로 0 &amp;deg; 경도에서의 태양 시간을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="67fdab77a1c02655cb90e9076adda573749aee76" translate="yes" xml:space="preserve">
          <source>Universaltime</source>
          <target state="translated">Universaltime</target>
        </trans-unit>
        <trans-unit id="f0fd69818de3f9565ba68951c5c09c08312d1123" translate="yes" xml:space="preserve">
          <source>Unix 'tar' utility for reading and writing tar archives.</source>
          <target state="translated">tar 아카이브를 읽고 쓰는 유닉스 'tar'유틸리티.</target>
        </trans-unit>
        <trans-unit id="c497be34c3d12775e6c6e249a2bb96e5096e4688" translate="yes" xml:space="preserve">
          <source>Unix example: &lt;code&gt;/usr/local/bin&lt;/code&gt;</source>
          <target state="translated">유닉스 예제 : &lt;code&gt;/usr/local/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52db1f36f26e76a3a2c634008d80678e33f56bbd" translate="yes" xml:space="preserve">
          <source>Unknown Functions.</source>
          <target state="translated">알 수없는 기능.</target>
        </trans-unit>
        <trans-unit id="b20270332ab7fc1d7887105b864abda119f91200" translate="yes" xml:space="preserve">
          <source>Unknown Modules.</source>
          <target state="translated">알 수없는 모듈.</target>
        </trans-unit>
        <trans-unit id="42c65364e9fb4489250a3ae7948a13788521c35e" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns a list containing object &lt;code&gt;I&lt;/code&gt; in Erlang term order.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블이 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 보호 되지 않으면 테이블을 동시에 업데이트하면 순회가 실패 할 수 있습니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형의 경우 함수는 Erlang 용어 순서로 오브젝트 &lt;code&gt;I&lt;/code&gt; 를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="efdfb6336f1dc28fe44fc86849dcd9997db099f2" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the next key in order, even if the object does no longer exist.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블이 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 보호 되지 않으면 테이블을 동시에 업데이트하면 순회가 실패 할 수 있습니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형의 경우, 함수는 오브젝트가 더 이상 존재하지 않더라도 다음 키를 순서대로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="743984ff40a29e25f3a91777282531a480bea68e" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified by the options, all modules are assumed to be at least &quot;static&quot;, and all except the target module are assumed to be &quot;safe&quot;. See the &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; options for details.</source>
          <target state="translated">옵션으로 달리 지정하지 않는 한 모든 모듈은 &quot;정적&quot;인 것으로 가정하고 대상 모듈을 제외한 모든 모듈은 &quot;안전한&quot;것으로 간주됩니다. 자세한 내용은 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;safe&lt;/code&gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6fd12a82bf92d67e237725f9648f0226fb3bb44f" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output.</source>
          <target state="translated">달리 지정하지 않는 한 반환 값 유형 및 인코딩은 입력 유형 및 인코딩과 동일합니다. 즉, 이진 입력은 이진 출력을 반환하고 목록 입력은 목록 출력을 반환하지만 혼합 입력은 목록 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2452df07cb8ca79cfe0600811352c2e7e3686be8" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output.</source>
          <target state="translated">달리 지정하지 않는 한 반환 값 유형은 입력 유형과 동일합니다. 즉, 이진 입력은 이진 출력을 반환하고 목록 입력은 목록 출력을 반환하며 혼합 입력은 혼합 출력을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3df395f5cdf2fa36eee4743206fa60a6a1a66c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.</source>
          <target state="translated">달리 지정하지 않으면 모든 제어 시퀀스에서 선행 공백이 무시됩니다. 입력 필드의 너비는 한 줄을 넘을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a1cc2b0ee63b4df93cb4cef8c16bee9110c56a5" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, the order of the registered filters will be the order in which they are registered.</source>
          <target state="translated">달리 지정하지 않는 한 등록 된 필터의 순서는 등록 된 순서입니다.</target>
        </trans-unit>
        <trans-unit id="336e16f5b15c1bb3924a2d4ee1f281da2f5d2f39" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</source>
          <target state="translated">달리 명시되지 않는 한, 모든 기능은 위치 번호 매기기가 1에서 시작한다고 가정합니다. 즉, 목록의 첫 번째 요소는 위치 1에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5744f08804fbcbd546e4dfc2b0e6fcafee559f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_server&lt;/code&gt; process does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 존재하지 않거나 잘못된 인수가 지정 되면이 모듈의 모든 기능이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="33f0b9bf676eb2bfd97e1ca14eb9192d3876198f" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_statem&lt;/code&gt; does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 &lt;code&gt;gen_statem&lt;/code&gt; 이 존재하지 않거나 잘못된 인수가 지정 되면이 모듈의 모든 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="2130ed65fd03b5efa6f9266bb204f3dc0f269a98" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시하지 않는 한, 지정된 이벤트 관리자가 없거나 잘못된 인수가 지정되면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="94ecf2431ac506145df210d3f762df7ef9ac568e" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 수퍼바이저 브리지가 없거나 잘못된 인수를 지정하면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ce6e960d5712a50515c10d0e5588263e19e9ce6b" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시하지 않는 한 지정된 수퍼바이저가 없거나 잘못된 인수를 지정하면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c7ee08644b98d18eca27766dd86d186eaca4f73" translate="yes" xml:space="preserve">
          <source>Unless specified by the user when the array is created, the default value is the atom &lt;code&gt;undefined&lt;/code&gt;. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt;). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries.</source>
          <target state="translated">배열을 만들 때 사용자가 지정하지 않으면 기본값은 atom &lt;code&gt;undefined&lt;/code&gt; 입니다. 설정되지 않은 항목과 기본 항목과 동일한 값으로 명시 적으로 설정된 항목 ( &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt; 비교)에는 차이가 없습니다 . 설정되지 않은 항목과 설정 한 항목을 구별해야하는 경우 기본값을 설정 한 항목의 값과 혼동 할 수 없도록하십시오.</target>
        </trans-unit>
        <trans-unit id="dd13caf6027b189cef2a36a20e0fd13e56485aad" translate="yes" xml:space="preserve">
          <source>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (&lt;code&gt;code:get_path()&lt;/code&gt;). This means that the names of typical &quot;app&quot; files can be used directly, without a path, e.g., &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt;.</source>
          <target state="translated">파일 이름이 절대적인 경우가 아니면 먼저 현재 디렉토리를 기준으로 파일을 검색 한 다음 일반 검색 경로 ( &lt;code&gt;code:get_path()&lt;/code&gt; )를 사용합니다. 즉, &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt; 와 같이 경로없이 일반적인 &quot;app&quot;파일의 이름을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07a837b10265d2be2c9f800bf253594222b1cdf6" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, calls to &lt;code&gt;bchunk/2&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">테이블을 사용하여 보호하지 않는 한 &lt;code&gt;safe_fixtable/2&lt;/code&gt; 에 전화를 &lt;code&gt;bchunk/2&lt;/code&gt; 동시 업데이트가 테이블을 변경하면 예상대로 가능성이 일을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec243991d25d3f676894294544e13f5bc4cfeae2" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, subsequent calls to &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">&lt;code&gt;safe_fixtable/2&lt;/code&gt; 를 사용하여 테이블을 보호하지 않으면 테이블에 대한 동시 업데이트가 수행 되면 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출이 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c55317241e5b2c59b25e3b0df5f88453b5f333" translate="yes" xml:space="preserve">
          <source>Unless the value is &lt;code&gt;none&lt;/code&gt;, the given function is called for each node whose list of annotations is not empty; see below for details. The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;none&lt;/code&gt; 이 아닌 한 주석 목록이 비어 있지 않은 각 노드에 대해 지정된 함수가 호출됩니다. 자세한 내용은 아래를 참조하십시오. 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cdff867eb339963be03bd21021856778c904302c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt;, Ifname is encoded a binary. In the unlikely case that a system is using non-7-bit-ASCII characters in network device names, special care has to be taken when encoding this argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; 과 달리 Ifname은 이진으로 인코딩됩니다. 시스템이 네트워크 장치 이름에 7 비트가 아닌 ASCII 문자를 사용하는 경우에는이 인수를 인코딩 할 때 특별한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ae5c0bd0a60e997d1705e91f30f45cde14782afc" translate="yes" xml:space="preserve">
          <source>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</source>
          <target state="translated">데이터 테이블과 달리 스키마 테이블의 정보는이 섹션에서 설명하는 스키마 관련 기능을 사용해야 만 액세스하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="315fbdc2014934db1db457f44c68e1cf848dbeb6" translate="yes" xml:space="preserve">
          <source>Unlike in &quot;plain Erlang&quot;, &lt;code&gt;proc_lib&lt;/code&gt; processes will not generate &lt;strong&gt;error reports&lt;/strong&gt;, which are written to the terminal by the emulator. All exceptions are converted to &lt;strong&gt;exits&lt;/strong&gt; which are ignored by the default &lt;code&gt;logger&lt;/code&gt; handler.</source>
          <target state="translated">&quot;plain Erlang&quot;과 달리 &lt;code&gt;proc_lib&lt;/code&gt; 프로세스는 에뮬레이터에 의해 터미널에 기록되는 &lt;strong&gt;오류 보고서를&lt;/strong&gt; 생성하지 않습니다 . 모든 예외는 기본 &lt;code&gt;logger&lt;/code&gt; 핸들러 에서 무시되는 &lt;strong&gt;엑시트&lt;/strong&gt; 로 변환 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0b46a073145149fc17e2f042255d68220cd4a4" translate="yes" xml:space="preserve">
          <source>Unload &lt;code&gt;Mibs&lt;/code&gt; from an agent. If it cannot unload all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where unloading was aborted.</source>
          <target state="translated">에이전트에서 &lt;code&gt;Mibs&lt;/code&gt; 를 언로드 하십시오 . 모든 MIB를 언로드 할 수없는 경우 ( &lt;code&gt;Force&lt;/code&gt; 인수 의 기본값 은 &lt;code&gt;false&lt;/code&gt; ) 언로드가 중단 된 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b2dca21a4f55d7d0fa16561ba72c0a5a938d9c" translate="yes" xml:space="preserve">
          <source>Unload a &lt;code&gt;Mib&lt;/code&gt; from the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">관리자에서 &lt;code&gt;Mib&lt;/code&gt; 를 언로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="318d9f4d5f03a67d10200c73fcad432663d2f29b" translate="yes" xml:space="preserve">
          <source>Unload a single &lt;code&gt;Mib&lt;/code&gt; from an agent.</source>
          <target state="translated">에이전트에서 단일 &lt;code&gt;Mib&lt;/code&gt; 를 언로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="769b903ce1d90a72efda3ccafb33dcd1f3d777a4" translate="yes" xml:space="preserve">
          <source>Unload the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument from the mib-server.</source>
          <target state="translated">mib-server에서 &lt;code&gt;Filename&lt;/code&gt; 인수로 지정된 mib를 언로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddd4c00f912e6ef2189a832da23d9650d2872c8c" translate="yes" xml:space="preserve">
          <source>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (that is, this &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;) no longer needs the driver. That can, if there are no other users, trigger unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed.</source>
          <target state="translated">언로드는이 특정 프로세스에서 코드의이 특정 부분 (즉,이 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; )이 더 이상 드라이버를 필요로하지 않는다고 에뮬레이터에 알리는 프로세스로 설명 할 수 있습니다 . 즉, 다른 사용자가 없으면 드라이버 언로드를 트리거 할 수 있습니다.이 경우 드라이버 이름이 시스템에서 사라지고 드라이버 실행 가능 코드가 차지하는 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="7779518675ffce53110af3008d7744e065e1a5f3" translate="yes" xml:space="preserve">
          <source>Unloads the MIBs from agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">에이전트 &lt;code&gt;snmp_master_agent&lt;/code&gt; 에서 MIB를 언로드합니다 .</target>
        </trans-unit>
        <trans-unit id="f4a3d6a062d2d5ee9eda88a5ecd1085fce084994" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-MIB.</source>
          <target state="translated">OTP-MIB를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="c48f8e606621c6fa11b525d4c336815899ff648e" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-OS-MON-MIB.</source>
          <target state="translated">OTP-OS-MON-MIB를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="38ed8242b3b1b71902fb9d376310f5c95786abfe" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 가 제공 한 OpenSSL 엔진을 언로드합니다 . 엔진을 언로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5cff9e0ced01393a829b38eaa7e0451df21ea9d5" translate="yes" xml:space="preserve">
          <source>Unloads the application specification for &lt;code&gt;Application&lt;/code&gt; from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</source>
          <target state="translated">언로드에 대한 응용 프로그램 사양 &lt;code&gt;Application&lt;/code&gt; 응용 프로그램 컨트롤러에서. 또한 포함 된 모든 응용 프로그램의 응용 프로그램 사양을 언로드합니다. 이 함수는 Erlang 오브젝트 코드를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="351a6f889a5ded537e77bca6799737838e6f4f76" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, all remaining open ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; and the driver eventually gets unloaded.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이라는 드라이버를 언로드하거나 최소한 역 참조합니다 . 호출자가 드라이버 의 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;driver_unloaded&lt;/code&gt; 이유로 드라이버를 사용하여 남아있는 모든 열린 포트가 종료 되고 결국 드라이버가 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="2061febf2aa265ba0d12f05d42293814e13d57b8" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and no more open ports use the driver, the driver gets unloaded. Otherwise, unloading is delayed until all ports are closed and no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; remain.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이라는 드라이버를 언로드하거나 최소한 역 참조합니다 . 호출자가 드라이버 의 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 이고 열려있는 포트가 더 이상 드라이버를 사용하지 않으면 드라이버가 언로드됩니다. 그렇지 않으면 모든 포트가 닫히고 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 남아 있지 않을 때까지 언로드가 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="38ad66e7caef87bb85f8df32ab5caabf7bf35995" translate="yes" xml:space="preserve">
          <source>Unlocks a mutex. The mutex currently must be locked by the calling thread.</source>
          <target state="translated">뮤텍스를 잠금 해제합니다. 뮤텍스는 현재 호출 스레드에 의해 잠겨 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b9b1fba9416c1278f7484dce6e469b9ce20199f" translate="yes" xml:space="preserve">
          <source>Unlocks the configuration target.</source>
          <target state="translated">구성 대상을 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="19786a83cc46632e0d13d564e393de3e1de085fe" translate="yes" xml:space="preserve">
          <source>Unlocks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금을 잠금 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9e529736ebba8b22ec528fcbede64fa669b39cc8" translate="yes" xml:space="preserve">
          <source>Unordered sending is configurable in &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt;. There is no special handling of DPR/DPA: since a user that cares about pending answers should wait for them before initiating DPR.</source>
          <target state="translated">정렬되지 않은 전송은 &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt; 에서 구성 할 수 있습니다 . 보류중인 응답에 관심이있는 사용자는 DPR을 시작하기 전에 기다려야하므로 DPR / DPA에 대한 특별한 처리는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cdfeac47c5892b6d5954da0f63cd683192cebcee" translate="yes" xml:space="preserve">
          <source>Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</source>
          <target state="translated">정렬되지 않은 세트와 정렬 된 세트는이 모듈에서 다시 직교합니다. 정렬되지 않은 세트는 정렬 된 세트와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0315bcb1361b2c68fa29fded47a0e3b15d0b5028" translate="yes" xml:space="preserve">
          <source>Unpacking and Installation of Release Packages</source>
          <target state="translated">릴리스 패키지 포장 풀기 및 설치</target>
        </trans-unit>
        <trans-unit id="3b45b03b4626e1a53bac859dec0524861ec0a57e" translate="yes" xml:space="preserve">
          <source>Unpacks a release package &lt;code&gt;Name.tar.gz&lt;/code&gt; located in the &lt;code&gt;releases&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;releases&lt;/code&gt; 디렉토리 에 있는 릴리스 패키지 &lt;code&gt;Name.tar.gz&lt;/code&gt; 를 압축 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="1a99a056cf6ecaf575d784978bf9746e5f0db64d" translate="yes" xml:space="preserve">
          <source>Unrecognized options are ignored.</source>
          <target state="translated">인식 할 수없는 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e8f759a055d6a9097dc478f2320ca3772d6837" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored but are returned unmodified by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; and can be referred to in predicate functions passed to &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인식 할 수없는 옵션은 자동으로 무시되지만 &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; 에 의해 수정되지 않은 상태로 리턴 되며 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 에 전달 된 술어 함수에서 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcf136da00ab173645906b6446844bfeeb401e42" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored.</source>
          <target state="translated">인식 할 수없는 옵션은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="db0b20da3e0471bc484aaa9c62ebfd991d58e416" translate="yes" xml:space="preserve">
          <source>Unregister a notification filter.</source>
          <target state="translated">알림 필터를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="4e280e10a8485894674391e4d6645db6545aff52" translate="yes" xml:space="preserve">
          <source>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in &lt;code&gt;Agent&lt;/code&gt;.</source>
          <target state="translated">하위 에이전트를 등록 취소하십시오. 두 번째 인수가 pid 인 경우 해당 하위 에이전트는 &lt;code&gt;Agent&lt;/code&gt; 의 모든 트리에서 등록 취소됩니다 .</target>
        </trans-unit>
        <trans-unit id="f03ca80c8e4fbe50cea94aadfa5356b1cefa6ea2" translate="yes" xml:space="preserve">
          <source>Unregister the agent.</source>
          <target state="translated">에이전트를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f3dba02392fc14b01a49c5237fb9ba133abd12" translate="yes" xml:space="preserve">
          <source>Unregister the subagent, handling part of the mib-tree, as specified by the &lt;code&gt;oid()&lt;/code&gt; or &lt;code&gt;pid()&lt;/code&gt; (&lt;code&gt;PidOrOid&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;oid()&lt;/code&gt; 또는 &lt;code&gt;pid()&lt;/code&gt; ( &lt;code&gt;PidOrOid&lt;/code&gt; )에 지정된대로 mib-tree의 일부를 처리하는 서브 에이전트를 등록 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f8277a7a1c1b3585ee2c7d6442d480190db4efc" translate="yes" xml:space="preserve">
          <source>Unregister the user.</source>
          <target state="translated">사용자를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a27c51fcd7b00626a6adb2154cd8c213ef4ec1" translate="yes" xml:space="preserve">
          <source>Unregister this USM user.</source>
          <target state="translated">이 USM 사용자를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d7b4bee0a41ee99a7b5f42eb631d46c2797262" translate="yes" xml:space="preserve">
          <source>Unregisters a name from &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 에서 이름을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="778ebac023e85b1f0510378d21c9e5c1fcf345ea" translate="yes" xml:space="preserve">
          <source>Unregisters all USM users.</source>
          <target state="translated">모든 USM 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3c58e843a4c38141952ae3478058bdba2218974e" translate="yes" xml:space="preserve">
          <source>Unregisters all managed agents.</source>
          <target state="translated">모든 관리 에이전트를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="246367dd21663f20ce31444da8332f55bea35d97" translate="yes" xml:space="preserve">
          <source>Unregisters all users.</source>
          <target state="translated">모든 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="32c40ce96fa1e83b3bd9616363397a86b832aa70" translate="yes" xml:space="preserve">
          <source>Unregisters the crypto key fun and terminates the process holding it, started by &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 로 시작하여 암호화 키 기능을 등록 취소하고이를 보유하는 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="7c5ba8d70542c76fd25b8d56f14442cbc2255390" translate="yes" xml:space="preserve">
          <source>Unregisters the specified USM users.</source>
          <target state="translated">지정된 USM 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="01d1e628f578a9203fd5dd6ce46d237fc06cee37" translate="yes" xml:space="preserve">
          <source>Unregisters the specified managed agents.</source>
          <target state="translated">지정된 관리 에이전트를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="b35f5d367e4318dedf6e9eecba89fb487eb5ab44" translate="yes" xml:space="preserve">
          <source>Unregisters the specified users.</source>
          <target state="translated">지정된 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="39827e01c383c5bfbd3766c32b34efde1bf35451" translate="yes" xml:space="preserve">
          <source>Unresolved Calls. Empty in &lt;code&gt;modules&lt;/code&gt; mode.</source>
          <target state="translated">해결되지 않은 통화. &lt;code&gt;modules&lt;/code&gt; 모드 에서 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f30d44760477c48d3263ea185339929d64ed8c" translate="yes" xml:space="preserve">
          <source>Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.</source>
          <target state="translated">확인되지 않은 호출은 모듈 데이터를 불완전하게 만들어 분석 결과가 유효하지 않을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d813c57ac643b33b15704ddfaac2f69f436d7ab" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer.</source>
          <target state="translated">부호없는 8 비트 정수</target>
        </trans-unit>
        <trans-unit id="c196c4cb59b173e8333c1a8a5df703d2addbca5b" translate="yes" xml:space="preserve">
          <source>Unspecified connection shutdown.</source>
          <target state="translated">지정되지 않은 연결 종료</target>
        </trans-unit>
        <trans-unit id="23ba21b928bd868bd499fdc4e16f1fbae6b293bf" translate="yes" xml:space="preserve">
          <source>Unsticks a directory that is marked as sticky.</source>
          <target state="translated">고정으로 표시된 디렉토리를 고정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2277446510c2f9009fdeac95bbe80a1168ba956b" translate="yes" xml:space="preserve">
          <source>Unsubscribe to event messages from a service.</source>
          <target state="translated">서비스의 이벤트 메시지를 수신 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf5dcc3da0cf64b87e972ea01a22a51c15d8495" translate="yes" xml:space="preserve">
          <source>Unused Functions (*). All local and exported functions of analyzed modules that have not been used.</source>
          <target state="translated">사용하지 않은 기능 (*). 사용되지 않은 분석 된 모듈의 모든 로컬 및 내 보낸 기능.</target>
        </trans-unit>
        <trans-unit id="48532263f2300b60babe28fff5fbbc91ed7d708c" translate="yes" xml:space="preserve">
          <source>Unused functions and imports</source>
          <target state="translated">사용하지 않은 함수 및 가져 오기</target>
        </trans-unit>
        <trans-unit id="e9b3d935e2fe5c05c6efefdff41786dcbb306041" translate="yes" xml:space="preserve">
          <source>Unused variables</source>
          <target state="translated">사용하지 않은 변수</target>
        </trans-unit>
        <trans-unit id="b7745c954ca016fa895b408f407a03e565617f6b" translate="yes" xml:space="preserve">
          <source>Up to five log files at maximum 100 KB each with the content of the standard streams from and to the command. (Both the number of logs and sizes can be changed by environment variables, see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; below.)</source>
          <target state="translated">표준 스트림의 내용과 함께 최대 100KB의 로그 파일 최대 5 개 (로그 및 크기의 수는 환경 변수에 의해 변경 될 수 있습니다 . 아래의 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9dd274c7d6098a1a4d8932d92e9e158a8e9dd4b8" translate="yes" xml:space="preserve">
          <source>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the &lt;strong&gt;simplest&lt;/strong&gt;&lt;code&gt;Mnesia&lt;/code&gt; functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing &lt;code&gt;Mnesia&lt;/code&gt; activity) exists, they all fail.</source>
          <target state="translated">지금까지 트랜잭션 내부에서 사용할 수있는 여러 함수의 예가 나와 있습니다. 다음 목록은 트랜잭션과 함께 작동 하는 &lt;strong&gt;가장 간단한 &lt;/strong&gt; &lt;code&gt;Mnesia&lt;/code&gt; 함수를 보여줍니다 . 이러한 기능은 트랜잭션에 포함되어야합니다. 엔 클로징 트랜잭션 (또는 기타 엔 클로징 &lt;code&gt;Mnesia&lt;/code&gt; 활동)이 없으면 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="01b4c751d26980e5035738b359c986debcfcf4b4" translate="yes" xml:space="preserve">
          <source>Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (&lt;code&gt;fun&lt;/code&gt;s in process context), and references to literals in the code.</source>
          <target state="translated">ERTS 버전 8. *까지 점검 프로세스 코드 조작은 이전 코드에 대한 모든 유형의 참조를 점검합니다. , 직접 참조 (프로세스 스택에 예를 들어, 반환 주소), 간접 참조 (즉 &lt;code&gt;fun&lt;/code&gt; 코드에서 리터럴에 대한 프로세스 컨텍스트에서 S), 및 참조.</target>
        </trans-unit>
        <trans-unit id="4c2624bab6b3cfd68919c56a6d5e5cfd349d334b" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. An exception &lt;code&gt;{badkey,Key}&lt;/code&gt; is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the map.</source>
          <target state="translated">새 값을 얻으려면 이전 값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 &lt;code&gt;Key&lt;/code&gt; 와 연관된 &lt;code&gt;Map1&lt;/code&gt; 의 값을 업데이트하십시오 . &lt;code&gt;Key&lt;/code&gt; 가 맵에 없으면 &lt;code&gt;{badkey,Key}&lt;/code&gt; 예외 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="1c9b1268f0c338627a3b15658c74da637dde057f" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in &lt;code&gt;Map1&lt;/code&gt; then &lt;code&gt;Init&lt;/code&gt; will be associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">새 값을 얻으려면 이전 값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 &lt;code&gt;Key&lt;/code&gt; 와 연관된 &lt;code&gt;Map1&lt;/code&gt; 의 값을 업데이트하십시오 . 경우 &lt;code&gt;Key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;Map1&lt;/code&gt; 다음 &lt;code&gt;Init&lt;/code&gt; 연결됩니다 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2fca097e563aa25bfd5fb033663686a751ded2" translate="yes" xml:space="preserve">
          <source>Update agent config. The function &lt;code&gt;update_agent_info/3&lt;/code&gt; should be used when several values needs to be updated atomically.</source>
          <target state="translated">에이전트 구성을 업데이트하십시오. 여러 값을 원자 적으로 업데이트해야하는 경우 &lt;code&gt;update_agent_info/3&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e65320d77653af5410845622a9ee939279e72f69" translate="yes" xml:space="preserve">
          <source>Update an MD5 &lt;code&gt;Context&lt;/code&gt; with &lt;code&gt;Data&lt;/code&gt; and returns a &lt;code&gt;NewContext&lt;/code&gt;.</source>
          <target state="translated">MD5 &lt;code&gt;Context&lt;/code&gt; 를 &lt;code&gt;Data&lt;/code&gt; 로 업데이트 하고 &lt;code&gt;NewContext&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="15c23ed960405748d119e2cf48c12e3dfbd628b3" translate="yes" xml:space="preserve">
          <source>Update configuration data for the specified handler. This function behaves as if it was implemented as follows:</source>
          <target state="translated">지정된 핸들러의 구성 데이터를 업데이트하십시오. 이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fe58a4200c84c77e18dad55e69d7d322faa4c745" translate="yes" xml:space="preserve">
          <source>Update information about a user</source>
          <target state="translated">사용자 정보 업데이트</target>
        </trans-unit>
        <trans-unit id="312c6091d8eac0e5b07d6cd16487ac2bd404f20a" translate="yes" xml:space="preserve">
          <source>Update information about an active connection</source>
          <target state="translated">활성 연결에 대한 정보 업데이트</target>
        </trans-unit>
        <trans-unit id="1fe0611d972ddd201356bf6556896ed52b2f48ec" translate="yes" xml:space="preserve">
          <source>Update primary configuration data for Logger. This function behaves as if it was implemented as follows:</source>
          <target state="translated">로거의 기본 구성 데이터를 업데이트하십시오. 이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="764a554dd6a058f4ee8b2a49aff080d148edb108" translate="yes" xml:space="preserve">
          <source>Update the application version number in the &lt;code&gt;.app&lt;/code&gt; file and write an &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일 에서 애플리케이션 버전 번호를 업데이트하고 &lt;code&gt;.appup&lt;/code&gt; 파일을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="df2e0eab67dde01477b9adecadae6f860b5f68c2" translate="yes" xml:space="preserve">
          <source>Update the connection info protocol_version.</source>
          <target state="translated">연결 정보 protocol_version을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="1ae0552d56ac843dfab3a0e0e90394739c437be4" translate="yes" xml:space="preserve">
          <source>Update the formatter configuration for the specified handler.</source>
          <target state="translated">지정된 핸들러의 포맷터 구성을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="e12a74739554e4908ca08a51e98ff68b92ec211d" translate="yes" xml:space="preserve">
          <source>Update the receive handle of the control process (e.g. after having changed protocol version).</source>
          <target state="translated">제어 프로세스의 수신 핸들을 업데이트하십시오 (예 : 프로토콜 버전을 변경 한 후).</target>
        </trans-unit>
        <trans-unit id="4ff8cf55883e7040256c251d18a9776b47973fa6" translate="yes" xml:space="preserve">
          <source>Update the receive handle with the encoding-config (the &lt;code&gt;encoding_config&lt;/code&gt; field).</source>
          <target state="translated">encoding-config ( &lt;code&gt;encoding_config&lt;/code&gt; 필드)로 수신 핸들을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4e75d0ad461333a3e5a1fa13055100c26a0e7bc" translate="yes" xml:space="preserve">
          <source>Update usm user config.</source>
          <target state="translated">usm 사용자 구성을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="5ff39bab1bf1708cca0909e3396800e9779cd838" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree.</source>
          <target state="translated">&lt;code&gt;Tree1&lt;/code&gt; 의 &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; 를 업데이트 하고 새 트리를 반환합니다. 키가 트리에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ce52fdc3093dff8fef11813ce4ce3d448b0c6f2e" translate="yes" xml:space="preserve">
          <source>Updates a running Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에 대해 실행중인 Adler-32 체크섬을 업데이트합니다 . 경우 &lt;code&gt;Data&lt;/code&gt; 빈 바이너리 또는 빈 iolist이며,이 기능은 검사에 필요한 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39a616ffbea893cd0d7caf81f5c475e558b40da3" translate="yes" xml:space="preserve">
          <source>Updates a running CRC checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</source>
          <target state="translated">에 대한 실행 CRC 체크섬 업데이트 &lt;code&gt;Data&lt;/code&gt; . 경우 &lt;code&gt;Data&lt;/code&gt; 빈 바이너리 또는 빈 iolist이며,이 기능은 CRC에 필요한 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8d39f7d480179f5db485862d26b6c6e7aed7b81" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. An exception is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary.</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. &lt;code&gt;Key&lt;/code&gt; 가 사전에 없으면 예외가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab59d74f46080461c39369f0019171f2f23af955" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as follows:</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Initial&lt;/code&gt; 처음 값으로 저장된다. 예를 들어, &lt;code&gt;append/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6a761f1dc7fcd9496ff0fc00ba409b036ce20c" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as:</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Initial&lt;/code&gt; 처음 값으로 저장된다. 예를 들어, &lt;code&gt;append/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c90a4670b3f9486158db598e8de0114e5577be" translate="yes" xml:space="preserve">
          <source>Updates an accumulator by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt;. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The final value of the accumulator is returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">&lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 의 각 주석 콜렉션에 &lt;code&gt;Fun&lt;/code&gt; 을 적용하여 누산기를 업데이트합니다 . &lt;code&gt;Fun&lt;/code&gt; 에 대한 첫 번째 호출 은 인수로 &lt;code&gt;AccIn&lt;/code&gt; 을 가지며 반환 된 누산기 &lt;code&gt;AccOut&lt;/code&gt; 은 다음 호출로 전달됩니다. 누산기의 최종 값이 반환됩니다. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ebcf826afc7224f3463dd215eb5352561a6434" translate="yes" xml:space="preserve">
          <source>Updates information about debugged processes. Information about all terminated processes are removed from the window. All Attach Process windows for terminated processes are closed.</source>
          <target state="translated">디버깅 된 프로세스에 대한 정보를 업데이트합니다. 종료 된 모든 프로세스에 대한 정보가 창에서 제거됩니다. 종료 된 프로세스에 대한 모든 프로세스 첨부 창이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a4db32f627e995a84c52631b1bbbde821d611764" translate="yes" xml:space="preserve">
          <source>Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using an HMAC init function (such as &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt; or to one of the functions &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">지정된 &lt;code&gt;Data&lt;/code&gt; 를 사용해 &lt;code&gt;Context&lt;/code&gt; 로 나타내지는 HMAC를 갱신합니다 . &lt;code&gt;Context&lt;/code&gt; 는 HMAC init 함수 (예 : &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt; )를 사용하여 생성되어야합니다 . &lt;code&gt;Data&lt;/code&gt; 는 임의의 길이 일 수 있습니다. &lt;code&gt;NewContext&lt;/code&gt; 에 다음 호출에 전달해야 &lt;code&gt;hmac_update&lt;/code&gt; 또는 기능 중 하나가 &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cc7f14f3a3fed19f2f8c9a020605209d8a12c68" translate="yes" xml:space="preserve">
          <source>Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Data&lt;/code&gt; 를 사용해 &lt;code&gt;Context&lt;/code&gt; 로 나타내지는 다이제스트를 갱신합니다 . &lt;code&gt;Context&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; 또는이 함수에 대한 이전 호출을 사용하여 생성되어야합니다 . &lt;code&gt;Data&lt;/code&gt; 는 임의의 길이 일 수 있습니다. &lt;code&gt;NewContext&lt;/code&gt; 는 다음 번 &lt;code&gt;hash_update&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt; 호출로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a37f581698786fafdf7275742d9f7c793868104" translate="yes" xml:space="preserve">
          <source>Updates the hook function field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 후크 기능 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c2e71d06680882c2ec32b2dc6bea400636a79824" translate="yes" xml:space="preserve">
          <source>Updates the line widh field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 line widh 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="06a0436ed02af4ad242287fe8c27e31aafc0067b" translate="yes" xml:space="preserve">
          <source>Updates the object with key &lt;code&gt;Key&lt;/code&gt; stored in table &lt;code&gt;Name&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at the &lt;code&gt;Pos&lt;/code&gt;:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</source>
          <target state="translated">&lt;code&gt;Pos&lt;/code&gt; : th 위치 의 요소에 &lt;code&gt;Incr&lt;/code&gt; 을 추가하여 &lt;code&gt;set&lt;/code&gt; 유형 &lt;code&gt;Name&lt;/code&gt; 테이블에 키 &lt;code&gt;Key&lt;/code&gt; 로 오브젝트를 업데이트합니다 . 새로운 카운터 값이 반환됩니다. 위치를 지정하지 않으면 키 바로 다음의 요소가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="74b81e579810979a583fac3a15071ea6d7e0648e" translate="yes" xml:space="preserve">
          <source>Updates the operator precedence field of the prettyprinter context. See the &lt;code&gt;erl_parse(3)&lt;/code&gt; module for operator precedences.</source>
          <target state="translated">prettyprinter 컨텍스트의 연산자 우선 순위 필드를 업데이트합니다. 연산자 우선 순위 는 &lt;code&gt;erl_parse(3)&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63d2d102522483d5460d1744c9d5282ecfc3df2b" translate="yes" xml:space="preserve">
          <source>Updates the paper widh field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 paper widh 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1f9326e8e858c536ca9e794bc54c6e439dd4f44b" translate="yes" xml:space="preserve">
          <source>Updates the user data field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 사용자 데이터 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="eb57e471df554364292c825fe5e79967d1cd792b" translate="yes" xml:space="preserve">
          <source>Updating a map has a similar syntax as constructing it.</source>
          <target state="translated">지도를 업데이트하는 것은지도를 만드는 것과 비슷한 구문을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ccacf954181a7d1504665a82641050052eb900" translate="yes" xml:space="preserve">
          <source>Upgrade the connection associated with &lt;code&gt;Handle&lt;/code&gt; to a tls connection if possible.</source>
          <target state="translated">가능한 경우 &lt;code&gt;Handle&lt;/code&gt; 과 연관된 연결 을 tls 연결로 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca4651bcfd7cc66e9b643622e9b6fa5cf9be97fb" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 또는 이와 동등한 연결 소켓을 TLS 소켓으로 업그레이드합니다. 즉 , 클라이언트 측 TLS 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0885a1400bd730b033aa9a97c94e31cdcc2976c9" translate="yes" xml:space="preserve">
          <source>Upgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 파일 에 따라 응용 프로그램 &lt;code&gt;App&lt;/code&gt; 을 현재 버전에서 &lt;code&gt;Dir&lt;/code&gt; 에 있는 새 버전으로 업그레이드 합니다.</target>
        </trans-unit>
        <trans-unit id="fe465284017475712d39dd7e9e97f804a2375abf" translate="yes" xml:space="preserve">
          <source>Upon failure to reopen the log, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">로그를 다시 열지 못하면 EXIT 메시지 &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt; 와 함께 디스크 로그 프로세스가 종료됩니다 . 요청이 대기중인 다른 프로세스는 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="313cdf1a747cf13f7fb3ba0b75e218a96c2914cd" translate="yes" xml:space="preserve">
          <source>Uppercase letter</source>
          <target state="translated">대문자</target>
        </trans-unit>
        <trans-unit id="655dc371ef84593d2a9260f8648168e35e59595a" translate="yes" xml:space="preserve">
          <source>Uppercase letters</source>
          <target state="translated">대문자</target>
        </trans-unit>
        <trans-unit id="42df97f2f6a736b6736486799c452f7ab2ae5c74" translate="yes" xml:space="preserve">
          <source>Uppercase letters signify real identifiers and lowercase letters signify fake identifiers only used for description of the topology. Identifiers passed as real identifiers can be used by the runtime system when trying to access specific hardware; if they are incorrect the behavior is undefined. Faked logical CPU identifiers are not accepted, as there is no point in defining the CPU topology without real logical CPU identifiers. Thread, core, processor, and node identifiers can be omitted. If omitted, the thread ID defaults to &lt;code&gt;t0&lt;/code&gt;, the core ID defaults to &lt;code&gt;c0&lt;/code&gt;, the processor ID defaults to &lt;code&gt;p0&lt;/code&gt;, and the node ID is left undefined. Either each logical processor must belong to only one NUMA node, or no logical processors must belong to any NUMA nodes.</source>
          <target state="translated">대문자는 실제 식별자를 나타내며 소문자는 토폴로지 설명에 사용 된 가짜 식별자를 나타냅니다. 실제 식별자로 전달 된 식별자는 특정 하드웨어에 액세스하려고 할 때 런타임 시스템에서 사용할 수 있습니다. 이들이 올바르지 않으면 동작이 정의되지 않습니다. 실제 논리적 CPU 식별자없이 CPU 토폴로지를 정의 할 필요가 없으므로 결함이있는 논리적 CPU 식별자는 허용되지 않습니다. 스레드, 코어, 프로세서 및 노드 식별자는 생략 할 수 있습니다. 생략하면 스레드 ID의 기본값은 &lt;code&gt;t0&lt;/code&gt; 이고 코어 ID의 기본값은 &lt;code&gt;c0&lt;/code&gt; 이고 프로세서 ID의 기본값은 &lt;code&gt;p0&lt;/code&gt; 이며 노드 ID는 정의되지 않은 상태로 남아 있습니다. 각 논리 프로세서는 하나의 NUMA 노드에만 속하거나 논리 프로세서는 NUMA 노드에 속하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="19370c86dcca239b2f891f36eb2a0c4f475f930f" translate="yes" xml:space="preserve">
          <source>Uri data types</source>
          <target state="translated">Uri 데이터 유형</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="2c9af3bf645c9bf6cb6b56eedb88807aad3f66ae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; with an absolute path after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 후 절대 경로로 &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c47962432a46afd10354bf7faf78b77ebd176482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; together with &lt;code&gt;enif_select&lt;/code&gt; to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;enif_select&lt;/code&gt; 를 enif_select 와 함께 사용 하여 실패한 Erlang 프로세스를 감지하고 자원 및 포함 된 OS 이벤트 오브젝트의 영구 누출을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="f81221a29d13782207a78cbfa816c0cbf3c464d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; 더 이상 데이터가 전송 될 소켓의 읽기 측에 대한 대기가 폐쇄 될 수 없다는 것을 알리기 위해.</target>
        </trans-unit>
        <trans-unit id="71bd29e8e106825432b11d0f4aa2b931f6f8bf79" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 선택한 &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 로 현재 Erlang 시스템 시간을 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6d38128136d372de87b2cca11fa0fc14d3b6dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="611de99bd7fd476bf937c72c0e0fd5671d5f5338" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; to see the content of the history buffer and &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; to re-execute one of the entries.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; 을 사용 하여 히스토리 버퍼의 내용을보고 &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 항목 중 하나를 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="03a0a6dcdb4bb774d1d742179139e2e450523f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made.</source>
          <target state="translated">사용 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 같은 &lt;code&gt;mode&lt;/code&gt; 로 전달되어 안전하게 가까운 이벤트 객체 위해 &lt;code&gt;enif_select&lt;/code&gt; . 이벤트 객체를 닫는 것이 안전 할 때 리소스 &lt;code&gt;obj&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 콜백이 호출됩니다. 모든 알림이 수신되고 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 추가 호출이없는 경우에도 이벤트 객체를 안전하게 닫는이 방법을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4dbf19e8e181869d7824e230cc259b4296e049dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;M-x compile&lt;/code&gt; to compile an MIB from inside Emacs, and enter:</source>
          <target state="translated">사용 &lt;code&gt;M-x compile&lt;/code&gt; 이맥스 내부에서 MIB를 컴파일하고 입력합니다 :</target>
        </trans-unit>
        <trans-unit id="43487582b9c31bb61fd048104c15adf5df0fcbcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:is_compiled/1&lt;/code&gt; or &lt;code&gt;code:which/1&lt;/code&gt; to see if a module is Cover compiled (and still loaded) or not.</source>
          <target state="translated">사용 &lt;code&gt;cover:is_compiled/1&lt;/code&gt; 또는 &lt;code&gt;code:which/1&lt;/code&gt; 모듈이 커버 컴파일 (여전히로드) 가능 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7f85d8a08505e2b0a869a54c5dd45740db5b3406" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:start/1&lt;/code&gt; and &lt;code&gt;cover:stop/1&lt;/code&gt; to add or remove nodes. The same Cover compiled code will be loaded on each node, and analysis will collect and sum up coverage data results from all nodes.</source>
          <target state="translated">사용 &lt;code&gt;cover:start/1&lt;/code&gt; 및 &lt;code&gt;cover:stop/1&lt;/code&gt; 추가하거나 제거 할 노드합니다. 동일한 Cover 컴파일 코드가 각 노드에로드되고 분석은 모든 노드에서 Coverage 데이터 결과를 수집하고 요약합니다.</target>
        </trans-unit>
        <trans-unit id="5b51e4203eb742f5eb4fc26e38e7eb765f543077" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;driver_alloc_binary()&lt;/code&gt; to allocate a binary.</source>
          <target state="translated">바이너리를 할당 하려면 &lt;code&gt;driver_alloc_binary()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c95131c00c47173f141a21936f6eef73f82cca9f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:get_cookie()&lt;/code&gt; in ERTS instead.</source>
          <target state="translated">대신 ERTS에서 &lt;code&gt;erlang:get_cookie()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c041275bff1db161bb6bcf06b8c664a175f0746" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:now/0&lt;/code&gt; to retrieve the current Erlang system time.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 을 사용 하여 현재 Erlang 시스템 시간을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="de069253a09bf6a9eebbd010c198840f5e87a703" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">사용 &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="4290f2a7a214d1f9ba5e3a266d300f53024ef971" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;hipe:help_options/0&lt;/code&gt; to print out the available options.</source>
          <target state="translated">사용 가능한 옵션을 인쇄 하려면 &lt;code&gt;hipe:help_options/0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae0a3e8fb6ea6a46c1431393956ad0cdb131d016" translate="yes" xml:space="preserve">
          <source>Use Compiler option &lt;code&gt;{debug_info_key,Key}&lt;/code&gt;, see &lt;code&gt;compile(3)&lt;/code&gt; and function &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; to register a fun that returns the key whenever &lt;code&gt;beam_lib&lt;/code&gt; must decrypt the debug information.</source>
          <target state="translated">컴파일러 옵션 &lt;code&gt;{debug_info_key,Key}&lt;/code&gt; 를 사용하고 , &lt;code&gt;compile(3)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 함수를 참조 하여 &lt;code&gt;beam_lib&lt;/code&gt; 가 디버그 정보를 해독해야 할 때마다 키를 리턴하는 재미를 등록 하십시오.</target>
        </trans-unit>
        <trans-unit id="cf76996b770b568aba2d669a4a4c375802561542" translate="yes" xml:space="preserve">
          <source>Use Dialyzer from the command line to detect defects in the specified files or directories containing &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.beam&lt;/code&gt; files, depending on the type of the analysis.</source>
          <target state="translated">명령 유형에서 Dialyzer를 사용 하여 분석 유형에 따라 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.beam&lt;/code&gt; 파일을 포함하는 지정된 파일 또는 디렉토리의 결함을 감지 하십시오.</target>
        </trans-unit>
        <trans-unit id="52ecd59359aa11823ae3489c4b92ca323d2f8686" translate="yes" xml:space="preserve">
          <source>Use Mnesia with the following types of applications:</source>
          <target state="translated">다음과 같은 유형의 응용 프로그램에서 Mnesia를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd0851048c67fb91d296c17c79d984235168aa8a" translate="yes" xml:space="preserve">
          <source>Use STDLIB application variable &lt;code&gt;restricted_shell&lt;/code&gt; and specify, as its value, the name of the callback module. Example (with callback functions implemented in &lt;code&gt;callback_mod.erl&lt;/code&gt;): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt;.</source>
          <target state="translated">사용 STDLIB 응용 프로그램 변수는 &lt;code&gt;restricted_shell&lt;/code&gt; 값, 콜백 모듈의 이름으로, 그리고 지정합니다. 예 (구현 콜백 기능 &lt;code&gt;callback_mod.erl&lt;/code&gt; ) : &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9de9466c5fd84c1497ee031330a8bf3182295b3" translate="yes" xml:space="preserve">
          <source>Use a parameterized query to insert many rows in one go.</source>
          <target state="translated">한 번에 많은 행을 삽입하려면 매개 변수화 된 쿼리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4246bdbd0514a46c24c66d6a824bf38823f49b83" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm with a constant seed:</source>
          <target state="translated">상수 시드와 함께 지정된 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98d7bed7136a80ee2a1f391e37af7b4e25791949" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm:</source>
          <target state="translated">지정된 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef43eef2287dfb39d5045b73777b94383dd1809" translate="yes" xml:space="preserve">
          <source>Use active mode only if your high-level protocol provides its own flow control (for example, acknowledging received messages) or the amount of data exchanged is small. &lt;code&gt;{active, false}&lt;/code&gt; mode, use of the &lt;code&gt;{active, once}&lt;/code&gt; mode, or &lt;code&gt;{active, N}&lt;/code&gt; mode with values of &lt;code&gt;N&lt;/code&gt; appropriate for the application provides flow control. The other side cannot send faster than the receiver can read.</source>
          <target state="translated">고급 프로토콜이 자체 흐름 제어 (예 : 수신 된 메시지 확인)를 제공하거나 교환되는 데이터 양이 적은 경우에만 활성 모드를 사용하십시오. &lt;code&gt;{active, false}&lt;/code&gt; 모드, 응용 프로그램에 적합한 &lt;code&gt;N&lt;/code&gt; 값을 가진 &lt;code&gt;{active, once}&lt;/code&gt; 모드 또는 &lt;code&gt;{active, N}&lt;/code&gt; 모드 사용 은 흐름 제어를 제공합니다. 상대방이 읽을 수있는 것보다 빨리 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0cb9f5afdf0431967f44f8bc5907c7bc9106a55e" translate="yes" xml:space="preserve">
          <source>Use batch file &lt;code&gt;etop.bat&lt;/code&gt;, for example, &lt;code&gt;etop -node tiger@durin&lt;/code&gt;.</source>
          <target state="translated">배치 파일 &lt;code&gt;etop.bat&lt;/code&gt; 를 사용하십시오 ( 예 : &lt;code&gt;etop -node tiger@durin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804cbb37615425c1f58bef26b23df4ccbb998e2d" translate="yes" xml:space="preserve">
          <source>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like &lt;code&gt;==&lt;/code&gt;, as that may cause your application to stop working.</source>
          <target state="translated">비트 AND를 사용하여 반환 값에서 특정 비트를 테스트합니다. 실패한 통화와 성공적인 통화 모두에 대한 자세한 정보를 제공하기 위해 향후 릴리스에 새로운 중요 비트가 추가 될 수 있습니다. &lt;code&gt;==&lt;/code&gt; 와 같은 동등성 테스트를 사용하지 마십시오 . 응용 프로그램 작동이 중지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d05d6e3c0c6496475b27e170aa3c9890b934a6" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 테이블의 모든 레코드와 일치하는 기본 패턴을 얻거나 레코드 작성시 기본값을 사용하십시오. 패턴을 하드 코딩하지 마십시오. 레코드 정의의 향후 변경에 코드가 더 취약 해집니다.</target>
        </trans-unit>
        <trans-unit id="36fef5f536ab55188b5441adeba6150367c3ff02" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; to list all loaded reports:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여로드 된 모든 보고서를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b28b25ff39058f6138bbe1ff3ebce8f3b6ccb94a" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; to show details of a specific report:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 특정 보고서의 세부 사항을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a0eac0e99e0695efffadbf6a76c731707faeeeea" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; to stop the &lt;code&gt;rb_server&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;rb_server&lt;/code&gt; (stop) 함수를 사용 하여 rb_server 를 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="012887c588a915c59771e087bcd639512c6a8489" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; to get all flags for features that require strict order delivery.</source>
          <target state="translated">&lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 함수를 사용 하여 엄격한 주문 전달이 필요한 기능에 대한 모든 플래그를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="7f83ae95c5e5857514f24ca4885f3294c1f168dd" translate="yes" xml:space="preserve">
          <source>Use its graphical interface to investigate the state of the current test case.</source>
          <target state="translated">그래픽 인터페이스를 사용하여 현재 테스트 사례의 상태를 조사하십시오.</target>
        </trans-unit>
        <trans-unit id="66df33ce491bfcd444a606b910f4cb9ff07688b9" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 유형 을 나타내려면 레코드 대신 맵을 사용하십시오 . &lt;code&gt;.hrl&lt;/code&gt; 파일이 생성 되지 않습니다 . 자세한 정보 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 대한 섹션 맵 표현 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d6e7a5bbaac2fe1d22a38124df53d79bef29a950" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;killproc&lt;/code&gt; procedure in the above script can be combined with a call to &lt;code&gt;erl_call&lt;/code&gt;, for example:</source>
          <target state="translated">의 사용 &lt;code&gt;killproc&lt;/code&gt; 의 위의 스크립트에서 절차에 대한 호출과 결합 될 수 &lt;code&gt;erl_call&lt;/code&gt; 예를 들어, :</target>
        </trans-unit>
        <trans-unit id="b3ca6ef9bc0eb0fd175268e16b224fb66ca6f3fe" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to receive messages:</source>
          <target state="translated">다음 두 기능 중 하나를 사용하여 메시지를 수신하십시오.</target>
        </trans-unit>
        <trans-unit id="889a7015472f4f91d80360afa19301c38e311202" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to send messages:</source>
          <target state="translated">다음 두 기능 중 하나를 사용하여 메시지를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="4154e7c45ed1c09b28a8e036ce840111c118baa6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; to name directories to be searched for application files (equivalent to the &lt;code&gt;path&lt;/code&gt; in the option list for &lt;code&gt;systools:make_script/2&lt;/code&gt;).</source>
          <target state="translated">응용 프로그램 파일을 검색 할 디렉토리 이름을 지정 하려면 &lt;code&gt;-I&lt;/code&gt; 옵션을 사용하십시오 ( &lt;code&gt;systools:make_script/2&lt;/code&gt; 의 옵션 목록에 있는 &lt;code&gt;path&lt;/code&gt; 와 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="0c5e91c4910f51c44ca054a05924c3387fce83e6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; with the name of a file to use that file as a customized prologue file (option &lt;code&gt;includefile&lt;/code&gt;).</source>
          <target state="translated">해당 파일을 사용자 정의 된 프롤로그 파일 (옵션 &lt;code&gt;includefile&lt;/code&gt; ) 로 사용하려면 파일 이름과 함께 &lt;code&gt;-I&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d55bb82b3630e22429844da6211b0339bba98ea8" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;strong_validation&lt;/code&gt; to generate all warnings that the compiler would generate.</source>
          <target state="translated">컴파일러가 생성 할 모든 경고를 생성 하려면 &lt;code&gt;strong_validation&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7937b3339663cb4514ac276573d7e2c9e0dfd606" translate="yes" xml:space="preserve">
          <source>Use relaxed command checking only on systems with very limited interactive usage.</source>
          <target state="translated">대화식 사용이 매우 제한된 시스템에서만 완화 된 명령 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8be1e3581d1297371b0474f66ebe7774bd9957" translate="yes" xml:space="preserve">
          <source>Use script &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">스크립트 &lt;code&gt;etop&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecdd13a57f7a43ae5c5be43fc2ede21e975f620a" translate="yes" xml:space="preserve">
          <source>Use selective decode instead of exclusive decode if you are interested in only a single subvalue.</source>
          <target state="translated">단일 하위 값에만 관심이있는 경우 배타적 디코딩 대신 선택적 디코딩을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="edc8ad2b93f84080dbc37116f7108a665d7b55ac" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SEND_SENDER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; instead of the &lt;code&gt;SEND&lt;/code&gt; control message and use the &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message instead of the &lt;code&gt;SEND_TT&lt;/code&gt; control message.</source>
          <target state="translated">사용 &lt;code&gt;SEND_SENDER&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;SEND&lt;/code&gt; 의 제어 메시지를과 사용 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 의 의 대신 제어 메시지를 &lt;code&gt;SEND_TT&lt;/code&gt; 의 제어 메시지.</target>
        </trans-unit>
        <trans-unit id="0eb13f68ed22ba4a08751c4363250d2b2b3fba90" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bin_opt_info&lt;/code&gt; option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bin_opt_info&lt;/code&gt; 옵션을 사용하여 컴파일러가 이진 최적화에 대한 많은 정보를 인쇄하게하십시오. 컴파일러 또는 &lt;code&gt;erlc&lt;/code&gt; 에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c30d8bd130bb93833dc88f2efb2369af2066111" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;file&lt;/code&gt; module for files opened for bytewise access (&lt;code&gt;{encoding,latin1}&lt;/code&gt;).</source>
          <target state="translated">바이트 단위 액세스를 위해 열린 &lt;code&gt;file&lt;/code&gt; 모듈을 사용하십시오 ( &lt;code&gt;{encoding,latin1}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cec2d14858ca56aa4886d5cb596e4d1c4389bb5d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;io&lt;/code&gt; module when accessing files with any other encoding (for example &lt;code&gt;{encoding,uf8}&lt;/code&gt;).</source>
          <target state="translated">다른 인코딩으로 파일에 액세스 할 때는 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하십시오 (예 : &lt;code&gt;{encoding,uf8}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e21bc6d17c5f3138b318feb1664293ef1335717" translate="yes" xml:space="preserve">
          <source>Use the GUI.</source>
          <target state="translated">GUI를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3f1aa1f6c936dd4bbcc665fff827922973d80d2" translate="yes" xml:space="preserve">
          <source>Use the following command to generate a .hrl file from an MIB:</source>
          <target state="translated">MIB에서 .hrl 파일을 생성하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="285645e77ad81adce8bdc1256d83d49b2f715165" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</source>
          <target state="translated">다음 include 지시문을 사용하여 여기 및 사용자 안내서에 설명 된 레코드 및 상수 매크로에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="26340e5bfdecd44f5d627a8bf499337d449c9b39" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described in the following sections:</source>
          <target state="translated">다음 include 지시문을 사용하여 다음 섹션에 설명 된 레코드 및 상수 매크로에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="eaf38e520f81f823bc5c2944fc89ede2ea27b2c7" translate="yes" xml:space="preserve">
          <source>Use the function &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; to add new fragments and apply the usual schema manipulation functions (such as &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt;) on each fragment to perform the actual redistribution.</source>
          <target state="translated">&lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; 함수를 사용하여 새 단편을 추가하고 각 단편에 대해 일반적인 스키마 조작 기능 (예 : &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; )을 적용하여 실제 재분배를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="81d58859492a0e6cf67a695fecde344397df4fa0" translate="yes" xml:space="preserve">
          <source>Use the function describe_table/[2,3] to find out which ODBC data type that is expected for each column of that table. If a column has a data type that is described with capital letters, alas it is not currently supported by the param_query function. Too know which Erlang data type corresponds to an ODBC data type see the Erlang to ODBC data type &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">describe_table / [2,3] 함수를 사용하여 해당 테이블의 각 열에 예상되는 ODBC 데이터 유형을 찾으십시오. 열에 대문자로 설명 된 데이터 유형이있는 경우 슬래 스는 현재 param_query 함수에서 지원하지 않습니다. 어떤 Erlang 데이터 유형이 ODBC 데이터 유형에 해당하는지 너무 알면 사용자 안내서 의 Erlang 대 ODBC 데이터 유형 &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e938f8eaaf7a2fb5db93a5741c75b6c3d2b1e56" translate="yes" xml:space="preserve">
          <source>Use the functional API with a non-constant seed:</source>
          <target state="translated">상수가 아닌 시드와 함께 기능 API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="541ddc36dcd95bdf4f3b7b106057bafcf839da79" translate="yes" xml:space="preserve">
          <source>Use the map in the ssl key option:</source>
          <target state="translated">SSL 키 옵션에서 맵을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8bedd4105b0c918e36403c94a86cea217070bfac" translate="yes" xml:space="preserve">
          <source>Use the same Erlang types to represent &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; as in OTP R16.</source>
          <target state="translated">OTP R16에서 와 동일한 Erlang 유형을 사용하여 &lt;code&gt;BIT STRING&lt;/code&gt; 및 &lt;code&gt;OCTET STRING&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="203bf7370538dd892cf94b38b1e17b25aedb4cc9" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="translated">소켓 옵션 &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (또는 이와 유사한 것)을 사용하면 모든 데이터를 수신 한 것으로 알려진 수신자가 연결을 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d720aadc70a1b56241025a699cc74ef9ea249d" translate="yes" xml:space="preserve">
          <source>Use the specified PLT as the initial PLT. If the PLT was built during setup, the files are checked for consistency.</source>
          <target state="translated">지정된 PLT를 초기 PLT로 사용하십시오. 설치 중에 PLT가 작성된 경우 파일의 일관성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0ad77542229ec1d771e4e02b6524ee184d641040" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; 에서 리턴 된 값을 사용하여 현재 런타임 시스템 인스턴스에서 고유 한 이름을 작성하십시오. 양의 정수만 원하면 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e36f8f2cb8b647a47cca517ff03d541469491a2" translate="yes" xml:space="preserve">
          <source>Use the values returned from &lt;code&gt;erlang:now/0&lt;/code&gt; to create a name unique on the current runtime system instance.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 에서 리턴 된 값을 사용하여 현재 런타임 시스템 인스턴스에서 고유 한 이름을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1a3d93db801fcbd6f501d39eac8cc569d5150c" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure, and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">시스템 호출이 실패한 후에이 기능을 사용하십시오. 호출자가 제공 한 메시지 다음에 실패 이유를 설명하는 문자열이 인쇄되고 프로세스는 종료 값 &lt;code&gt;1&lt;/code&gt; 로 종료 됩니다. 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60cd4eee7b91477f96873aee8f0c08a0e1659942" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure.</source>
          <target state="translated">시스템 호출이 실패한 후에이 기능을 사용하십시오. 호출자가 제공 한 메시지 다음에 실패 이유를 설명하는 문자열이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3be946393c47f35eede2756d19558abc69e73e" translate="yes" xml:space="preserve">
          <source>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</source>
          <target state="translated">수행중인 작업, 즉 자신의 응용 프로그램을 알고있는 경우에만이 기능을 사용하십시오. 응용 프로그램에서 값을 읽는시기와 빈도는 응용 프로그램에 따라 다르고 구성 매개 변수에 따라 다릅니다. 이 기능을 부주의하게 사용하면 응용 프로그램이 이상하고 일관성이없고 작동하지 않는 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d1a6a43cff399c18914850f099af42f99ff52a6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; a specific match specification saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 호출 중에 저장된 특정 일치 스펙을 &quot;잊어 버리려면&quot;이 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6bca535e578b8f96edf192f36e88f0568555ba6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; all match specifications saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. This is useful when one wants to restore other match specifications from a file with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; to delete specific saved match specifications.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 호출 중에 저장된 모든 일치 스펙을 &quot;잊어 버리려면&quot;이 기능을 사용하십시오 . 이것은 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 파일에서 다른 일치 스펙을 복원하려는 경우에 유용합니다 . 특정 저장된 일치 스펙을 삭제 하려면 &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d051de59e60744864ad96b5d4970120ccdf3ce13" translate="yes" xml:space="preserve">
          <source>Use this function to recall all match specifications previously used in the session (i. e. previously saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, and built-in match specifications. This is very useful, as a complicated match_spec can be quite awkward to write. Note that the match specifications are lost if &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">이 함수를 사용하면 세션에서 이전에 사용 된 모든 일치 사양 (예 : &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 호출 중에 저장 되고 내장 된 일치 사양)을 호출 할 수 있습니다. 복잡한 match_spec을 작성하기가 매우 어려울 수 있으므로 매우 유용합니다. &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; 이 호출 되면 일치 스펙이 유실됩니다 .</target>
        </trans-unit>
        <trans-unit id="c941b9c92bccb005e3755850980e1a4c93df1aed" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="translated">이 기능을 사용하여 로깅 범주의 상세 레벨을 설정하거나 수정하십시오. 자세한 내용은 사용 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 를 참조하십시오. 값 사용하여 &lt;code&gt;default&lt;/code&gt; 일반 상세 레벨을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4f981450d616f53002b2dbe1a22bf77c775fe2" translate="yes" xml:space="preserve">
          <source>Use this function when a fatal error has occurred that is not because of a system call. The message provided by the caller is printed and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">시스템 호출이 아닌 치명적인 오류가 발생한 경우이 기능을 사용하십시오. 호출자가 제공 한 메시지가 인쇄되고 프로세스는 종료 값 &lt;code&gt;1&lt;/code&gt; 로 종료 됩니다. 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="927c6ba6b883da5a944bc17195e2455b95cac07d" translate="yes" xml:space="preserve">
          <source>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</source>
          <target state="translated">기존 영구 데이터가 더 이상 사용되지 않으므로이 기능을 매우주의해서 사용하십시오. 사용하기 전에 두 번 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="03f95d87f375280efaeeb6fe8cafb649410d718d" translate="yes" xml:space="preserve">
          <source>Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use &lt;code&gt;ct_telnet&lt;/code&gt; and configure connections, specifically for UNIX hosts, see the &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">이 모듈을 사용하여 Telnet 연결을 설정하고 명령을 전송하며 결과에서 문자열 일치를 수행하십시오. &lt;code&gt;ct_telnet&lt;/code&gt; 을 사용 하고 특히 UNIX 호스트에 대한 연결을 구성 하는 방법에 대한 정보 는 &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5d50bad282c0804f9a7e02550f10159ee185809" translate="yes" xml:space="preserve">
          <source>Use this option when receiving binaries from an untrusted source.</source>
          <target state="translated">신뢰할 수없는 소스에서 바이너리를 수신 할 때이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01f5382feca2bb4947c345ec5297001b4439de6e" translate="yes" xml:space="preserve">
          <source>Use with extreme care.</source>
          <target state="translated">매우주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="926a25ba00ec3f71fce83c4ae2a582227ec44542" translate="yes" xml:space="preserve">
          <source>Used BIFs. &lt;code&gt;B&lt;/code&gt; is empty if &lt;code&gt;builtins&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all analyzed modules.</source>
          <target state="translated">중고 BIF. 모든 분석 모듈에 대해 &lt;code&gt;builtins&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 이면 &lt;code&gt;B&lt;/code&gt; 는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11ee9255f50f3fa3a1ac060817b8601274af33d" translate="yes" xml:space="preserve">
          <source>Used Library Modules.</source>
          <target state="translated">사용 된 라이브러리 모듈.</target>
        </trans-unit>
        <trans-unit id="aaea96d1f0adade7428605a5b6a71a977e21c17f" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; 에서 런타임 시스템에 대한 정보를 리턴하는 데 사용됩니다 . &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; 와 동일한 내용을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="42d74dbb12b0fb1f6ea1d95300289917f6910dc7" translate="yes" xml:space="preserve">
          <source>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</source>
          <target state="translated">프로세스에서 정의되지 않은 함수 호출 및 정의되지 않은 등록 된 프로세스에 대한 오류 핸들러를 재정의하는 데 사용됩니다. 코드 자동 로딩은 오류 처리 모듈의 올바른 작동에 의존하므로 경험이없는 사용자는이 플래그를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="021e8894d4cd8efeb3800e902cce4283561eaa59" translate="yes" xml:space="preserve">
          <source>Used by a server process to accept a connection from a client process.</source>
          <target state="translated">서버 프로세스가 클라이언트 프로세스로부터의 연결을 승인하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c49623f58e59d8735fea69dd29c4f20e63decdd" translate="yes" xml:space="preserve">
          <source>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">서버 프로세스에서 로컬 이름 서버 EPMD에 등록하여 다른 프로세스가 등록 된 이름을 사용하여 메시지를 보낼 수 있습니다. 이 함수 중 하나를 호출하기 전에 프로세스는 열린 소켓에서 &lt;code&gt;bind()&lt;/code&gt; 및 &lt;code&gt;listen()&lt;/code&gt; 을 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5f5237d3789fea5df1f7ffca0fba9777e1547c1e" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Size&lt;/code&gt; is an expression that is to evaluate to an integer.</source>
          <target state="translated">비트 열 구조에서 사용되는 &lt;code&gt;Size&lt;/code&gt; 는 정수로 평가되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="a7cde552a3551769508a6d34af2b5b84e289881d" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Value&lt;/code&gt; is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</source>
          <target state="translated">비트 열 구성에 사용되는 &lt;code&gt;Value&lt;/code&gt; 는 정수, 부동 또는 비트 열로 평가되는 표현식입니다. 표현식이 단일 리터럴 또는 변수가 아닌 경우 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="e7fa51f6619aef90e556b2317c4e8c8b56b58094" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be an integer, or a variable bound to an integer.</source>
          <target state="translated">비트 문자열 일치에 사용되는 &lt;code&gt;Size&lt;/code&gt; 는 정수이거나 정수에 바인딩 된 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a2ea25edea36db50d30cde55ba8333dc776429fb" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Value&lt;/code&gt; must be a variable, or an integer, float, or string.</source>
          <target state="translated">비트 문자열 일치에 사용되는 &lt;code&gt;Value&lt;/code&gt; 는 변수이거나 정수, 부동 또는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="00b8635528024d62633ce26ebc8ade8bf9cf1f13" translate="yes" xml:space="preserve">
          <source>Used in socket close message.</source>
          <target state="translated">소켓 닫기 메시지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37771a4a8b87640f401b1b514090e62c25bfd4a6" translate="yes" xml:space="preserve">
          <source>Used in socket data message.</source>
          <target state="translated">소켓 데이터 메시지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94de0e417f3f0b14c77f33a57c9b9d9d4a4e16c3" translate="yes" xml:space="preserve">
          <source>Used to perform codec measurements. That is, to see what kind of performance can be expected by the different codecs provided by the megaco application.</source>
          <target state="translated">코덱 측정을 수행하는 데 사용됩니다. 즉, megaco 응용 프로그램에서 제공하는 다양한 코덱에서 어떤 종류의 성능을 기대할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4ea4aa7eefddb763ba10cb9daaf61feb433c13d7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">분배에서 추적을 설정하는 데 사용됩니다. 레벨은 다른 상세 레벨입니다. 높은 수준은 더 많은 정보를 의미합니다. &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt; 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e0558fbc4bfc3f98f9c0aff78f8bf8c889c7ae8" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;uniquely identifies the HTTP server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; 와 함께 사용하여 HTTP 서버를 고유하게 식별합니다. 이는 bind_address 및 포트가 동일한 서버가 둘 이상있을 수있는 가상화 된 환경에서 유용 할 수 있습니다. 이 특성을 명시 적으로 설정하지 않으면 &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; 가 HTTP 서버를 고유하게 식별 한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="770e0b9f1dc73dcbf183dcbbbc53e3cf5e4375d4" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;. If this property is not explicitly set, it is assumed that the the &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; uniquely identifies the SSH daemon.</source>
          <target state="translated">&lt;code&gt;ip-address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 와 함께 사용하여 ssh 데몬을 고유하게 식별합니다. 이는 &lt;code&gt;ip-address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 가 동일한 서버가 둘 이상있을 수있는 가상화 된 환경에서 유용 할 수 있습니다 . 이 등록 정보를 명시 적으로 설정하지 않으면 &lt;code&gt;ip-address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 가 SSH 데몬을 고유하게 식별 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="adce6622f9543e73767624ada8f13763e382d86b" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;send_timeout&lt;/code&gt; to specify whether the socket is to be automatically closed when the send operation returns &lt;code&gt;{error,timeout}&lt;/code&gt;. The recommended setting is &lt;code&gt;true&lt;/code&gt;, which automatically closes the socket. Defaults to &lt;code&gt;false&lt;/code&gt; because of backward compatibility.</source>
          <target state="translated">&lt;code&gt;send_timeout&lt;/code&gt; 과 함께 사용 하여 보내기 조작이 &lt;code&gt;{error,timeout}&lt;/code&gt; 을 리턴 할 때 소켓을 자동으로 닫을 지 여부를 지정합니다 . 권장 설정은 &lt;code&gt;true&lt;/code&gt; 이며 소켓을 자동으로 닫습니다. 이전 버전과의 호환성으로 인해 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07eb868bef5aa368e19bb894ec05dbc37d91a59f" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;{verify, verify_peer}&lt;/code&gt; by an TLS/DTLS server. If set to &lt;code&gt;true&lt;/code&gt;, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to &lt;code&gt;false&lt;/code&gt;, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</source>
          <target state="translated">TLS / DTLS 서버 에서 &lt;code&gt;{verify, verify_peer}&lt;/code&gt; 와 함께 사용 합니다. &lt;code&gt;true&lt;/code&gt; 로 설정 하면 클라이언트에 보낼 인증서가없는 경우, 즉 빈 인증서를 보내면 서버가 실패합니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 클라이언트가 유효하지 않은 인증서를 보내는 경우에만 실패합니다 (빈 인증서는 유효한 것으로 간주 됨). 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="5ec279a6fe9dd1161f2aa08b6ed9eb431c51ce40" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; has called &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; and has a trace token with flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; set to &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">프로세스 &lt;code&gt;From&lt;/code&gt; 이 &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; 호출 하고 플래그 &lt;code&gt;print&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되고 &lt;code&gt;label&lt;/code&gt; 이 &lt;code&gt;Label&lt;/code&gt; 로 설정된 추적 토큰이있는 경우 에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec8ed9ea4c0a02770b19230ee831fc7eabc65212" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent a message.</source>
          <target state="translated">추적 토큰 플래그 &lt;code&gt;print&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 프로세스 &lt;code&gt;From&lt;/code&gt; 이 메시지를 보낼 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f532ecd45390412a4c37f8eaaaf1dd3a2bc7a9e4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives a message with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">프로세스 &lt;code&gt;'receive'&lt;/code&gt; 플래그 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 추적 토큰이있는 메시지 &lt;code&gt;To&lt;/code&gt; 수신 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed866b317195673cc57f0bfced4e8f18f9deb039" translate="yes" xml:space="preserve">
          <source>Used when a restart of the emulator is required after all other upgrade instructions are executed. For more information about this instruction, see restart_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 모든 업그레이드 지침이 실행 된 후 에뮬레이터를 다시 시작해야 할 때 사용됩니다. 이 명령어에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_emulator (낮은 수준)를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b51ce444943f18b5b406c12d5de312dd469de6a1" translate="yes" xml:space="preserve">
          <source>Used when connection is up.</source>
          <target state="translated">연결시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98f3f0d6b5fe552d6fdd9e8a1ac4b1dbc95a1e0a" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. &lt;code&gt;{M, F, Arity}&lt;/code&gt; is specified instead of &lt;code&gt;{M, F, Args}&lt;/code&gt; in call trace messages.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 추적 플래그 와 함께 사용됩니다 . 통화 추적 메시지에서 &lt;code&gt;{M, F, Args}&lt;/code&gt; 대신 &lt;code&gt;{M, F, Arity}&lt;/code&gt; 가 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="35c8c1e7148c094e7f1037898138a703736b5c71" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. The &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return_from&lt;/code&gt;, and &lt;code&gt;return_to&lt;/code&gt; trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 추적 플래그 와 함께 사용됩니다 . &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;return_from&lt;/code&gt; 및 &lt;code&gt;return_to&lt;/code&gt; 의 이 플래그가 설정되어있는 경우 추적 메시지는 억제되지만, 경기 규격이있는 경우 그들은 정상적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="35f97b1230868a1d952f070b44e014ae71c9b348" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 추적 플래그 와 함께 사용됩니다 . 추적 된 함수에서 호출자로의 리턴을 추적합니다. &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;local&lt;/code&gt; 옵션 을 사용하여 추적 된 함수에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0771df2c0469ced91bfba340e5621231c3eb3f97" translate="yes" xml:space="preserve">
          <source>Useful for debugging. Prints the arguments sent to the emulator.</source>
          <target state="translated">디버깅에 유용합니다. 에뮬레이터로 전송 된 인수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bda40ec80a6280d040ae6cb2132464ae8868382d" translate="yes" xml:space="preserve">
          <source>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</source>
          <target state="translated">성능 조정에만 유용합니다. 실행 시간 또는 메모리 소비에 문제가 있음을 알고 옵션이 문제를 개선하는지 확인하지 않는 한이 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1b5232bbae53583af327fbf580fd761e961eb1ae" translate="yes" xml:space="preserve">
          <source>Useful options for the ASN.1 compiler:</source>
          <target state="translated">ASN.1 컴파일러에 유용한 옵션 :</target>
        </trans-unit>
        <trans-unit id="108800af422d061f509679723cbd223daa96eb6e" translate="yes" xml:space="preserve">
          <source>User Authentication (using Mnesia, Dets or plain text database)</source>
          <target state="translated">사용자 인증 (Mnesia, Dets 또는 일반 텍스트 데이터베이스 사용)</target>
        </trans-unit>
        <trans-unit id="b6d7d2ae9aeff0edfea9298508c33c3156394dee" translate="yes" xml:space="preserve">
          <source>User authentication using text files, Dets, or Mnesia database.</source>
          <target state="translated">텍스트 파일, Det 또는 Mnesia 데이터베이스를 사용한 사용자 인증</target>
        </trans-unit>
        <trans-unit id="fdf44c259444d43d89a931e2c5f009d59f5246ec" translate="yes" xml:space="preserve">
          <source>User does not have privileges to create symbolic links (&lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; on Windows).</source>
          <target state="translated">사용자에게는 기호 링크를 작성할 권한이 없습니다 ( Windows의 경우 &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfa1d0c7af0339d4d928dbeac41cc561fc954a37" translate="yes" xml:space="preserve">
          <source>User info - Information related to megaco users. Read/Write.</source>
          <target state="translated">사용자 정보-megaco 사용자와 관련된 정보입니다. 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="5943eb1d1f04ded83e3e46ef3224b51f634ef059" translate="yes" xml:space="preserve">
          <source>User is not logged in.</source>
          <target state="translated">사용자가 로그인하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ad777a4590258aa35737d9328314ce537d2c9cb8" translate="yes" xml:space="preserve">
          <source>User login information</source>
          <target state="translated">사용자 로그인 정보</target>
        </trans-unit>
        <trans-unit id="6fb1ac68e43ee6fa885af993d59c13a42fa4cd33" translate="yes" xml:space="preserve">
          <source>User owning the public key.</source>
          <target state="translated">공개 키를 소유 한 사용자</target>
        </trans-unit>
        <trans-unit id="ba07b0c96db1af8dcefb2d9162e61ba1cb1cc53b" translate="yes" xml:space="preserve">
          <source>User's private key(s)</source>
          <target state="translated">사용자의 개인 키</target>
        </trans-unit>
        <trans-unit id="31f9f489aed30f7126e13ae2a6c8aa3e1dfb69c4" translate="yes" xml:space="preserve">
          <source>User's public key</source>
          <target state="translated">사용자의 공개 키</target>
        </trans-unit>
        <trans-unit id="38a1ad1d15fcc5f9e499bc1732d0978996617997" translate="yes" xml:space="preserve">
          <source>User-Name AVP</source>
          <target state="translated">사용자 이름 AVP</target>
        </trans-unit>
        <trans-unit id="12d9701932fd2b8fbf1ff963e66877b3fb9d5041" translate="yes" xml:space="preserve">
          <source>User-defined entries can also be written to a configuration file by calling function &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt;, where &lt;code&gt;ConfigList&lt;/code&gt; is a list of &lt;code&gt;{Module,Function,Args}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt; 함수를 호출하여 구성 파일에 사용자 정의 항목을 쓸 수도 있습니다 . 여기서 &lt;code&gt;ConfigList&lt;/code&gt; 는 &lt;code&gt;{Module,Function,Args}&lt;/code&gt; 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="56ea86a7fa1494da2715a81abce4cab0c8f4eb29" translate="yes" xml:space="preserve">
          <source>User-defined event handlers can be added to handle application-specific events.</source>
          <target state="translated">응용 프로그램 특정 이벤트를 처리하기 위해 사용자 정의 이벤트 핸들러를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44e29b83c2f61db1703ca0d31d257ddfa7ed010" translate="yes" xml:space="preserve">
          <source>User-specific data for use in hook functions. The default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">후크 기능에 사용하기위한 사용자 별 데이터. 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18e7327216976d6005c52f79eedee5271cbeaf73" translate="yes" xml:space="preserve">
          <source>User-specific event handlers can be plugged into a &lt;code&gt;Common Test&lt;/code&gt; event manager, either by telling &lt;code&gt;Common Test&lt;/code&gt; to install them before the test run (described later), or by adding the handlers dynamically during the test run using &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; or &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt;. In the latter scenario, the reference of the &lt;code&gt;Common Test&lt;/code&gt; event manager is required. To get it, call &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; or (on the &lt;code&gt;Common Test&lt;/code&gt; Master node) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 별 이벤트 핸들러는 &lt;code&gt;Common Test&lt;/code&gt; 에게 테스트 실행 전에 설치하도록 지시하거나 (나중에 설명 함) &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; 또는 &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt; 사용하여 테스트 실행 중에 동적으로 핸들러를 추가하여 &lt;code&gt;Common Test&lt;/code&gt; 이벤트 관리자에 연결될 수 있습니다 . : add_sup_handler / 3 . 후자의 시나리오에서는 &lt;code&gt;Common Test&lt;/code&gt; 이벤트 관리자 의 참조 가 필요합니다. 이를 얻으려면 &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; 또는 ( &lt;code&gt;Common Test&lt;/code&gt; 마스터 노드에서) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca5c1acac21d9a3b6102ae9dadcfac83499ca32" translate="yes" xml:space="preserve">
          <source>UserMod:handle_connect/2</source>
          <target state="translated">UserMod:handle_connect/2</target>
        </trans-unit>
        <trans-unit id="f0d3fd03fc3def42c8da5fe622ad791ccaa1a0ea" translate="yes" xml:space="preserve">
          <source>UserMod:handle_message_error/3</source>
          <target state="translated">UserMod:handle_message_error/3</target>
        </trans-unit>
        <trans-unit id="a3bdb9436158799687b4418588b8647662e27155" translate="yes" xml:space="preserve">
          <source>UserMod:handle_syntax_error/3</source>
          <target state="translated">UserMod:handle_syntax_error/3</target>
        </trans-unit>
        <trans-unit id="7e0a148d93ed9e16bd5599754876deca380f643d" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_ack/4</source>
          <target state="translated">UserMod:handle_trans_ack/4</target>
        </trans-unit>
        <trans-unit id="d345f713a7834aaf56186658aec2115bcc13351b" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_reply/4</source>
          <target state="translated">UserMod:handle_trans_reply/4</target>
        </trans-unit>
        <trans-unit id="3884319e28f9e311d120dba2fbc454b53cead5a4" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_request/3</source>
          <target state="translated">UserMod:handle_trans_request/3</target>
        </trans-unit>
        <trans-unit id="3f6d997ef0e4d563bff3ecdcaff66971fd6b9762" translate="yes" xml:space="preserve">
          <source>Users are advised not to unregister system processes.</source>
          <target state="translated">시스템 프로세스를 등록 취소하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d7d513ec1d0fa107e592cfc1c6289d5e8f86f88" translate="yes" xml:space="preserve">
          <source>Users are not allowed to define types with the same names as the predefined or built-in ones. This is checked by the compiler and its violation results in a compilation error.</source>
          <target state="translated">사용자는 사전 정의되거나 내장 된 것과 동일한 이름을 가진 유형을 정의 할 수 없습니다. 이것은 컴파일러에 의해 확인되며 위반으로 인해 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="259b250e47199fdb387584511bbacec343b879b8" translate="yes" xml:space="preserve">
          <source>Users may either explicitly be registered with megaco:start_user/2 and/or be statically configured by setting the application environment variable 'users' to a list of {UserMid, Config} tuples. See the function megaco:start_user/2 for details.</source>
          <target state="translated">사용자는 megaco : start_user / 2에 명시 적으로 등록되거나 애플리케이션 환경 변수 'users'를 {UserMid, Config} 튜플 목록으로 설정하여 정적으로 구성 될 수 있습니다. 자세한 내용은 megaco : start_user / 2 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="944ad3a48b1f08bbcf2fb59d662131185d4fa39c" translate="yes" xml:space="preserve">
          <source>Uses a separate log file for every invocation of the service (&amp;lt;servicename&amp;gt;&lt;code&gt;.debug.&lt;/code&gt;&amp;lt;N&amp;gt;).</source>
          <target state="translated">서비스를 호출 할 때마다 별도의 로그 파일을 사용합니다 (&amp;lt;servicename&amp;gt; &lt;code&gt;.debug.&lt;/code&gt; &amp;lt;N&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="66ba2c7044af64caa2e9580c9ae81af796b430d1" translate="yes" xml:space="preserve">
          <source>Uses a sequence of wrap log files of limited size. As a wrap log file is filled up, further items are logged on to the next file in the sequence, starting all over with the first file when the last file is filled up.</source>
          <target state="translated">제한된 크기의 일련의 랩 로그 파일을 사용합니다. 랩 로그 파일이 채워지면 마지막 파일이 채워질 때 첫 번째 파일부터 시작하여 추가 항목이 순서대로 다음 파일에 로그온됩니다.</target>
        </trans-unit>
        <trans-unit id="63cc551f28fdc9de0a6c288edb557951e593faa7" translate="yes" xml:space="preserve">
          <source>Uses a specific or customised prologue file instead of default &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; which is otherwise included.</source>
          <target state="translated">&lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; 기본 lib / parsetools / include / leexinc.hrl 대신 특정 또는 사용자 정의 된 프롤로그 파일을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="cfb35a958a3524ef916a2dee520c654de0d97728" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a deep list of characters that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (described in section &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;) is processed.</source>
          <target state="translated">&lt;code&gt;ErrorDescriptor&lt;/code&gt; 를 사용 하고 오류를 설명하는 자세한 문자 목록을 반환합니다. 이 함수는 일반적으로 &lt;code&gt;ErrorInfo&lt;/code&gt; 구조 ( &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있음 )가 처리 될 때 암시 적으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4139194e768c251d84b03abf5cd321d1df4d02c" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ErrorDescriptor&lt;/code&gt; 를 사용 하고 오류 또는 경고를 설명하는 문자열을 반환합니다. 이 함수는 일반적으로 &lt;code&gt;ErrorInfo&lt;/code&gt; 구조가 처리 될 때 암시 적으로 호출 됩니다 (섹션 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c93cef9ab961b13c52c3ee1286af209a4ef5d08b" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ErrorDescriptor&lt;/code&gt; 를 사용 하고 오류를 설명하는 문자열을 반환합니다. 이 함수는 일반적으로 &lt;code&gt;ErrorInfo&lt;/code&gt; 구조가 처리 될 때 암시 적으로 호출 됩니다 (섹션 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4e240ed0f46a0e7052bee5a3dec802b98fe462d1" translate="yes" xml:space="preserve">
          <source>Uses test specification as input (described later).</source>
          <target state="translated">테스트 사양을 입력으로 사용합니다 (나중에 설명).</target>
        </trans-unit>
        <trans-unit id="713999a06cadf66964b72d923b13701c303aa173" translate="yes" xml:space="preserve">
          <source>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it to use a specific value from the session security parameters.</source>
          <target state="translated">TLS 세션의 PPR (Pseudo-Random Function)을 사용하여 추가 키 자료를 생성합니다. &lt;code&gt;Secret&lt;/code&gt; 및 &lt;code&gt;Seed&lt;/code&gt; 에 대한 사용자 생성 값 또는 세션 보안 매개 변수의 특정 값을 사용하도록 지시하는 atom을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="29fb0bd5ac8937f75326b05d56a7b9c426068b8d" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang Web Server API interaction data:</source>
          <target state="translated">다음 Erlang 웹 서버 API 상호 작용 데이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6542021570e55732848d7c4ecf584a9f1fce4a50" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang web server API interaction data:</source>
          <target state="translated">다음 Erlang 웹 서버 API 상호 작용 데이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c87b085bc59aac65ced245c43dfb66c0a327d57" translate="yes" xml:space="preserve">
          <source>Uses the return value of command &lt;code&gt;N&lt;/code&gt; in the current command, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the return value of the &lt;code&gt;N&lt;/code&gt;th previous command is used (that is, &lt;code&gt;v(-1)&lt;/code&gt; uses the value of the previous command).</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 이 양수인 경우 현재 명령에서 명령 &lt;code&gt;N&lt;/code&gt; 의 반환 값을 사용합니다 . 음수 인 경우, &lt;code&gt;N&lt;/code&gt; 번째 이전 명령 의 리턴 값 이 사용됩니다 (즉, &lt;code&gt;v(-1)&lt;/code&gt; 은 이전 명령의 값을 사용합니다).</target>
        </trans-unit>
        <trans-unit id="d7825c5becf2a7bc58af7be09180ec50f46648e4" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="translated">지정된 디렉토리를 현재 디렉토리로 사용합니다. zip 아카이브에서 파일 이름을 추출 할 때 파일 이름 앞에 붙습니다. ( 커널에서 &lt;code&gt;file:set_cwd/1&lt;/code&gt; 과 같이 작동 하지만 전역 &lt;code&gt;cwd&lt;/code&gt; 속성 은 변경하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="f356880e1a29c6875ae88d729105f2618d77c27f" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="translated">지정된 디렉토리를 현재 작업 디렉토리 ( &lt;code&gt;cwd&lt;/code&gt; )로 사용합니다. zip 아카이브에는 없지만 파일 이름을 추가 할 때 파일 이름 앞에 붙습니다 ( 커널의 &lt;code&gt;file:set_cwd/1&lt;/code&gt; 과 같지만 전역 &lt;code&gt;cwd&lt;/code&gt; 속성 은 변경하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="3b24dbe95482357a59b64bc1da6d8ac53437250c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-group top1 top2&lt;/code&gt;, or &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; gives the same result.</source>
          <target state="translated">사용 &lt;code&gt;-group top1 top2&lt;/code&gt; 또는 &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; 동일한 결과를 제공한다.</target>
        </trans-unit>
        <trans-unit id="88f4f21380171a61e0164a29d94211d35a1afc8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; enables this transform, unless the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined first.</source>
          <target state="translated">사용 &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; 매크로 가 먼저 정의 되지 않은 경우이 변환을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="c20e26276eb3aeb9f802837228801c44d2e93f19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; instead, but the &lt;code&gt;ets:select/2&lt;/code&gt; call is far more efficient. Without the translation provided by &lt;code&gt;ms_transform&lt;/code&gt;, one must struggle with writing match specifications terms to accommodate this.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; 과 일치 사양은 하나의 테이블의 행을 필터링 이들 행의 데이터의 관련 부분을 포함하는 튜플들의 목록을 구축 할 수있다. 대신 &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있지만 &lt;code&gt;ets:select/2&lt;/code&gt; 호출이 훨씬 더 효율적입니다. &lt;code&gt;ms_transform&lt;/code&gt; 에서 제공하는 번역이 없으면 이를 충족시키기 위해 일치 사양 용어를 작성하는 데 어려움을 겪어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c82c027de482fad19a39ea9d254bbafa02b405e5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cprof:analyse()&lt;/code&gt; in this example also shows approximately the same background work as in the first example.</source>
          <target state="translated">이 예제에서 &lt;code&gt;cprof:analyse()&lt;/code&gt; 를 사용 하면 첫 번째 예제와 거의 동일한 백그라운드 작업이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0e8375352b28a80765ea773ca843308851404f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ct_run -step [opts]&lt;/code&gt;, or by passing option &lt;code&gt;{step,Opts}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the following is possible:</source>
          <target state="translated">사용 &lt;code&gt;ct_run -step [opts]&lt;/code&gt; , 또는 옵션을 전달하여 &lt;code&gt;{step,Opts}&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; , 다음이 가능하다 :</target>
        </trans-unit>
        <trans-unit id="8f64a2837eaf7b8603ee4f3b40320c612c90d80f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;erl_drv_output_term()&lt;/code&gt; or &lt;code&gt;erl_drv_send_term()&lt;/code&gt;, a binary can be included in an Erlang term.</source>
          <target state="translated">사용 &lt;code&gt;erl_drv_output_term()&lt;/code&gt; 또는 &lt;code&gt;erl_drv_send_term()&lt;/code&gt; 이진은 얼랑 용어에 포함될 수있다.</target>
        </trans-unit>
        <trans-unit id="22c339dd691e6a37b987bcf7700c90e985445f81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, we can combine the ease of use of the &lt;code&gt;ets:foldr/3&lt;/code&gt; and the efficiency of the pure &lt;code&gt;ets:select/2&lt;/code&gt; example:</source>
          <target state="translated">사용 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; , 우리는 사용의 용이성을 결합 할 수 있습니다 &lt;code&gt;ets:foldr/3&lt;/code&gt; 와 순수의 효율성 &lt;code&gt;ets:select/2&lt;/code&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="8d06eaee0affa1e9d7ed35b71b0a99a0f3c00b54" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;list_to_atom/1&lt;/code&gt; to construct an atom that is passed to &lt;code&gt;apply/3&lt;/code&gt; as follows, is quite expensive and not recommended in time-critical code:</source>
          <target state="translated">&lt;code&gt;list_to_atom/1&lt;/code&gt; 을 사용하여 다음과 같이 &lt;code&gt;apply/3&lt;/code&gt; 를 적용 하도록 전달 된 원자를 구성하는 것은 비용이 많이 들고 시간이 중요한 코드에서는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81394dd93922176e47458d5f3c15c2b0804bd134" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;scheduler_wall_time&lt;/code&gt; to calculate scheduler utilization:</source>
          <target state="translated">&lt;code&gt;scheduler_wall_time&lt;/code&gt; 을 사용하여 스케줄러 활용도 계산 :</target>
        </trans-unit>
        <trans-unit id="862378469cf87dc0f0b44de7c775b81caef36dd4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;skip_suites&lt;/code&gt; and &lt;code&gt;skip_cases&lt;/code&gt; terms in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;skip_suites&lt;/code&gt; 및 &lt;code&gt;skip_cases&lt;/code&gt; 의 에서 조건을 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf508ced4ee281be2348cd08d12f83a3f75cac1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes SSL or TLS vulnerable to the BEAST attack.</source>
          <target state="translated">사용 &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; 짐승의 공격에 SSL이나 TLS 취약합니다.</target>
        </trans-unit>
        <trans-unit id="8e8a3b96a977f8581a203f0cc7479a4fa622cf64" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; makes TLS vulnerable to the Poodle attack.</source>
          <target state="translated">사용 &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; 푸들 공격에 TLS가 취약합니다.</target>
        </trans-unit>
        <trans-unit id="12c74ea67a8bf514e98bacaa08d939dc388ff2c9" translate="yes" xml:space="preserve">
          <source>Using HiPE</source>
          <target state="translated">HiPE 사용</target>
        </trans-unit>
        <trans-unit id="787b8b2ecfeeac0dc6c8b30eb4f29ae6e32df930" translate="yes" xml:space="preserve">
          <source>Using Mnesia Functions</source>
          <target state="translated">Mnesia 기능 사용</target>
        </trans-unit>
        <trans-unit id="69b70d7925c3d595457eb50569e18e9253b0f84e" translate="yes" xml:space="preserve">
          <source>Using Mnesia tables as SNMP tables</source>
          <target state="translated">Mnesia 테이블을 SNMP 테이블로 사용</target>
        </trans-unit>
        <trans-unit id="d4556d3a05908d3a2fd5b120b9264ae977bdd001" translate="yes" xml:space="preserve">
          <source>Using QLC</source>
          <target state="translated">QLC 사용</target>
        </trans-unit>
        <trans-unit id="eb75491192cbec18ddc3193ff609070567e4f298" translate="yes" xml:space="preserve">
          <source>Using QLC can be more expensive than using &lt;code&gt;Mnesia&lt;/code&gt; functions directly but offers a nice syntax.</source>
          <target state="translated">QLC를 사용하면 &lt;code&gt;Mnesia&lt;/code&gt; 함수를 직접 사용하는 것보다 비용이 많이 들지만 좋은 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b888e7581a06a39525c04389ba7f49f831878208" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;msg_env&lt;/code&gt; of &lt;code&gt;NULL&lt;/code&gt; is an optimization, which groups together calls to &lt;code&gt;enif_alloc_env&lt;/code&gt;, &lt;code&gt;enif_make_copy&lt;/code&gt;, &lt;code&gt;enif_port_command&lt;/code&gt;, and &lt;code&gt;enif_free_env&lt;/code&gt; into one call. This optimization is only useful when a majority of the terms are to be copied from &lt;code&gt;env&lt;/code&gt; to &lt;code&gt;msg_env&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;msg_env&lt;/code&gt; 의 &lt;code&gt;NULL&lt;/code&gt; 은 그룹이 함께 호출 최적화입니다 &lt;code&gt;enif_alloc_env&lt;/code&gt; , &lt;code&gt;enif_make_copy&lt;/code&gt; , &lt;code&gt;enif_port_command&lt;/code&gt; 및 &lt;code&gt;enif_free_env&lt;/code&gt; 하나의 호출에. 이 최적화는 대부분의 용어가 &lt;code&gt;env&lt;/code&gt; 에서 &lt;code&gt;msg_env&lt;/code&gt; 로 복사 될 때만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6e05aace796b827cc7de5108dc65985d67668971" translate="yes" xml:space="preserve">
          <source>Using a bridge that maps control messages in a proprietary protocol to a standardized management protocol and conversely</source>
          <target state="translated">독점 프로토콜의 제어 메시지를 표준화 된 관리 프로토콜과 반대로 매핑하는 브리지 사용</target>
        </trans-unit>
        <trans-unit id="23f87dc632b3b3a497eda26d1e0fd7f024ede833" translate="yes" xml:space="preserve">
          <source>Using a configuration target name (an alias) as reference.</source>
          <target state="translated">구성 대상 이름 (별명)을 참조로 사용.</target>
        </trans-unit>
        <trans-unit id="1bd7819b4238a75d18eacbc298988f60839565ee" translate="yes" xml:space="preserve">
          <source>Using a driver binary instead of a normal buffer is often faster, as the emulator needs not to copy the data, only the pointer is used.</source>
          <target state="translated">에뮬레이터가 데이터를 복사 할 필요가 없으므로 포인터 만 사용되므로 일반 버퍼 대신 드라이버 바이너리를 사용하는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5a4f00d83853b9a89087a2b4d34b93f85e90b8b4" translate="yes" xml:space="preserve">
          <source>Using a proprietary control protocol</source>
          <target state="translated">독점적 제어 프로토콜 사용</target>
        </trans-unit>
        <trans-unit id="8e93a7f8043acf2f93881fdb114964f55246a652" translate="yes" xml:space="preserve">
          <source>Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network.</source>
          <target state="translated">순수한 암호 기반 인증 체계를 사용합니다. 여기서 일반 텍스트 비밀번호는 네트워크를 통해 전송되기 전에 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="b61ea81dc7d1d41a9c00c2e18e56e9bb004eb512" translate="yes" xml:space="preserve">
          <source>Using a trace port significantly lowers the overhead imposed by using tracing.</source>
          <target state="translated">추적 포트를 사용하면 추적을 사용하여 부과되는 오버 헤드가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ef1a11e39ee5139ba5f2dcc235a18443f44a0583" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;Timeout&lt;/code&gt; less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; are used), can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same &lt;code&gt;Socket&lt;/code&gt; (that is, source address and port), as the controlling process blocks until &lt;code&gt;connect/*&lt;/code&gt; returns. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; provides an alternative without this limitation.</source>
          <target state="translated">OS가 연결을 설정하는 데 걸리는 최대 시간보다 적은 &lt;code&gt;Timeout&lt;/code&gt; 값을 사용하면 ( &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; 의 기본값을 사용하는 경우 약 4.5 분 ) 반환 값이 일치하지 않거나 올바르지 않을 수 있습니다. 이는 &lt;code&gt;connect/*&lt;/code&gt; 가 리턴 될 때까지 제어 프로세스 블록과 동일한 &lt;code&gt;Socket&lt;/code&gt; (즉, 소스 주소 및 포트)을 공유하는 연관에 특히 관련이 있습니다. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; 는이 제한없이 대안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5ba9ca7df52061ff3c5b19d7603144639874aa7f" translate="yes" xml:space="preserve">
          <source>Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand.</source>
          <target state="translated">비헤이비어를 사용하면 다른 프로그래머가 작성한 코드를보다 쉽게 ​​읽고 이해할 수 있습니다. 개선 된 프로그래밍 구조는 더 효율적이지만 항상 이해하기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="be49034820244435a044e90d7061836773df04c0" translate="yes" xml:space="preserve">
          <source>Using binaries is faster if more than a few bytes are returned.</source>
          <target state="translated">몇 바이트 이상이 반환되면 바이너리를 사용하는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="86c27bef1bf11875cf4524858dc2b5b6d1f57e8f" translate="yes" xml:space="preserve">
          <source>Using global names</source>
          <target state="translated">전역 이름 사용</target>
        </trans-unit>
        <trans-unit id="83523a7442b26b6b81628c22227c3e6adc4deb1a" translate="yes" xml:space="preserve">
          <source>Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard.</source>
          <target state="translated">키보드 대화식 인증 사용 클라이언트 측에서 특별한 소프트웨어 지원이 필요없는 대화식 인증 방법에 적합합니다. 대신 모든 인증 데이터가 키보드에서 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="1a390fb32c6eae4e12e20eb0d4d9a4b34d640e2f" translate="yes" xml:space="preserve">
          <source>Using one of the latter three requires good knowledge about the protocol and is not covered by this tutorial. See the SNMP, Inets, and Orber applications, respectively.</source>
          <target state="translated">후자의 세 가지 중 하나를 사용하려면 프로토콜에 대해 잘 알고 있어야하며이 자습서에서는 다루지 않습니다. SNMP, Inets 및 Orber 응용 프로그램을 각각 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5809e3cc4f955b265b3823ad9d7e5a15c18140e7" translate="yes" xml:space="preserve">
          <source>Using public key technology. RSA and DSA, X509-certificates are not supported.</source>
          <target state="translated">공개 키 기술 사용 RSA 및 DSA, X509 인증서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0f94a2e35a5586c99778544bf1babebc9b68874" translate="yes" xml:space="preserve">
          <source>Using raw socket options requires detailed knowledge about the current operating system and TCP stack.</source>
          <target state="translated">원시 소켓 옵션을 사용하려면 현재 운영 체제 및 TCP 스택에 대한 자세한 지식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c43bcf358f1478cc031c03e30ad078b80a07cfdf" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">생성 옵션 &lt;code&gt;monitor&lt;/code&gt; 를 사용할 수 &lt;code&gt;badarg&lt;/code&gt; 이유와 함께 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="35f019fb91f46510f8e2ab9ec3e19f04bc02403c" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes this function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">스폰 옵션 &lt;code&gt;monitor&lt;/code&gt; 를 사용할 수 &lt;code&gt;badarg&lt;/code&gt; 이유와 함께이 기능이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5a580b4208da4e796317767a96b5a26cf22e6b99" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed. It causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">스폰 옵션 &lt;code&gt;monitor&lt;/code&gt; 은 허용되지 않습니다. reason &lt;code&gt;badarg&lt;/code&gt; 로 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="43a9c674a9710324d1b88cb77d06f6cc4e6cfec2" translate="yes" xml:space="preserve">
          <source>Using state functions:</source>
          <target state="translated">상태 함수 사용 :</target>
        </trans-unit>
        <trans-unit id="d6a2d079afcf63d89e623e699169fa524219390a" translate="yes" xml:space="preserve">
          <source>Using the &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator to delete an element from a list is not a performance problem:</source>
          <target state="translated">&quot; &lt;code&gt;--&lt;/code&gt; &quot;연산자를 사용하여 목록에서 요소를 삭제하는 것은 성능 문제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2b4f7382590545933da8c1a5ca844a0b2dbf266e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, the size of the deep list can be calculated if sharing is ignored. It becomes the size of the list when it has been sent to another process or stored in an Ets table:</source>
          <target state="translated">&lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF를 사용하여 공유가 무시되는 경우 딥 목록의 크기를 계산할 수 있습니다. 다른 프로세스로 전송되거나 Ets 테이블에 저장 될 때 목록의 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="f45d11e06ad9c8b5b97c2a1d3733d7810b2b6a1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, it can be seen that the deep list only requires 22 words of heap space:</source>
          <target state="translated">은 Using &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, 깊은 목록은 힙 공간 (22) 말을 필요로 함을 알 수있다 :</target>
        </trans-unit>
        <trans-unit id="69d1d8837258e11d9f37b8093e934034d0224323" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;match_object&lt;/code&gt; functions for traversing all table objects is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">모든 테이블 객체를 순회하기 위해 &lt;code&gt;match_object&lt;/code&gt; 함수를 사용하면 &lt;code&gt;first/1&lt;/code&gt; 및 &lt;code&gt;next/2&lt;/code&gt; 또는 &lt;code&gt;slot/2&lt;/code&gt; 를 호출하는 것보다 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="88489091684544e2ce31ba031314c433818b9650" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;select&lt;/code&gt; functions for traversing all objects of a table is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">테이블의 모든 객체를 순회하기 위해 &lt;code&gt;select&lt;/code&gt; 함수를 사용하는 것이 &lt;code&gt;first/1&lt;/code&gt; 및 &lt;code&gt;next/2&lt;/code&gt; 또는 &lt;code&gt;slot/2&lt;/code&gt; 를 호출하는 것보다 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="61a624a4dabba21043f9ab83195b8048f47a13d2" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;Options&lt;/strong&gt; menu, you can set which areas to be displayed. By default, all areas except the Trace area are displayed.</source>
          <target state="translated">&lt;strong&gt;옵션&lt;/strong&gt; 메뉴를 사용하여 표시 할 영역을 설정할 수 있습니다. 기본적으로 추적 영역을 제외한 모든 영역이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="deaaf3fd831f16ebe5c78cc725732bfa850f0ae7" translate="yes" xml:space="preserve">
          <source>Using the BIFs &lt;code&gt;tuple_size/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</source>
          <target state="translated">BIF &lt;code&gt;tuple_size/1&lt;/code&gt; 및 &lt;code&gt;byte_size/1&lt;/code&gt; 을 사용하면 컴파일러와 런타임 시스템에 더 많은 최적화 기회가 제공됩니다. 다른 장점은 BIF가 Dialyzer에 더 많은 유형 정보를 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ffd8340dfb4e279ea5e33db1e4fc34776f3431f" translate="yes" xml:space="preserve">
          <source>Using the Erlang Port Mapper Daemon (EPMD)</source>
          <target state="translated">EPMD (Erlang Port Mapper Daemon) 사용</target>
        </trans-unit>
        <trans-unit id="74a23b01b4aba69b50c3d95e7b04c3987e9060d6" translate="yes" xml:space="preserve">
          <source>Using the Kernel configuration parameters above, one can set default options for all TCP sockets on a node, but use this with care. Options such as &lt;code&gt;{delay_send,true}&lt;/code&gt; can be specified in this way. The following is an example of starting an Erlang node with all sockets using delayed send:</source>
          <target state="translated">위의 커널 구성 매개 변수를 사용하면 노드의 모든 TCP 소켓에 대한 기본 옵션을 설정할 수 있지만주의해서 사용해야합니다. &lt;code&gt;{delay_send,true}&lt;/code&gt; 와 같은 옵션 을 이런 방식으로 지정할 수 있습니다. 다음은 지연 전송을 사용하여 모든 소켓에서 Erlang 노드를 시작하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="c13013135bcccdcdbbd4af4075c0fbd41fe4a1df" translate="yes" xml:space="preserve">
          <source>Using the configuration variable as reference.</source>
          <target state="translated">구성 변수를 참조로 사용.</target>
        </trans-unit>
        <trans-unit id="6387e670864aedf383cf907c6d29480da77d049e" translate="yes" xml:space="preserve">
          <source>Using the erlc program, write like this</source>
          <target state="translated">erlc 프로그램을 사용하여 다음과 같이 작성하십시오</target>
        </trans-unit>
        <trans-unit id="48fe6335c37dc35de5485bc852958929b084eb85" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;broadcast&lt;/code&gt; becomes:</source>
          <target state="translated">함수를 사용하여 &lt;code&gt;foreach&lt;/code&gt; 문을 , 함수 &lt;code&gt;broadcast&lt;/code&gt; 된다 :</target>
        </trans-unit>
        <trans-unit id="3bd90c46e2dfc7b2e3d344d9519f155f341267df" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;print_list&lt;/code&gt; becomes:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 함수를 사용하면 &lt;code&gt;print_list&lt;/code&gt; 함수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b09520015307c351db8684a091c45386c6ce9fb4" translate="yes" xml:space="preserve">
          <source>Using the monitor triggers in the call to &lt;code&gt;try_unload&lt;/code&gt; ensures that the monitor is added before the unloading is executed, meaning that the monitor is always properly triggered, which is not the case if &lt;code&gt;monitor/2&lt;/code&gt; is called separately.</source>
          <target state="translated">&lt;code&gt;try_unload&lt;/code&gt; 호출에서 모니터 트리거를 사용하면 언로드가 실행되기 전에 모니터가 추가됩니다. 즉, 모니터가 항상 올바르게 트리거됩니다. 이는 &lt;code&gt;monitor/2&lt;/code&gt; 가 별도로 호출되는 경우에는 해당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e7fa3b27587f43d236bfc06bb5036ddb2f4e6201" translate="yes" xml:space="preserve">
          <source>Using the registry</source>
          <target state="translated">레지스트리 사용</target>
        </trans-unit>
        <trans-unit id="ffb1c5489112873955c3175cf9ad9aba4db225d6" translate="yes" xml:space="preserve">
          <source>Using the same snapshots to calculate a total scheduler utilization:</source>
          <target state="translated">동일한 스냅 샷을 사용하여 총 스케줄러 사용량을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="a20644602b05608c2ad01e03c87f70e3ffe5b61d" translate="yes" xml:space="preserve">
          <source>Using the single time warp mode, the time offset is handled in two phases:</source>
          <target state="translated">단일 시간 왜곡 모드를 사용하면 시간 오프셋이 두 단계로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8eee4ea386e884fcda7fe99030e661fbbf1aa947" translate="yes" xml:space="preserve">
          <source>Using the specific path &lt;code&gt;-group [sub121]&lt;/code&gt; or &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; gives the same result in this example.</source>
          <target state="translated">이 예에서 특정 경로 &lt;code&gt;-group [sub121]&lt;/code&gt; 또는 &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; 을 사용하면 동일한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5c52f9666d83bbf64ddaeeafc9ca31c5700aca1b" translate="yes" xml:space="preserve">
          <source>Using these facts, the two small circles in the picture below can be combined.</source>
          <target state="translated">이러한 사실을 사용하여 아래 그림에서 두 개의 작은 원을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86aadd39c7dc4683cf62fc0ed24ee58375d7f5d3" translate="yes" xml:space="preserve">
          <source>Using transactions is a way to guarantee that the distributed Mnesia database remains consistent, even when many different processes update it in parallel. However, if you have real-time requirements it is recommended to use &lt;code&gt;dirty&lt;/code&gt; operations instead of transactions. When using &lt;code&gt;dirty&lt;/code&gt; operations, you lose the consistency guarantee; this is usually solved by only letting one process update the table. Other processes must send update requests to that process.</source>
          <target state="translated">트랜잭션을 사용하면 분산 된 Mnesia 데이터베이스가 여러 프로세스가 동시에 업데이트하더라도 일관성을 유지하는 방법입니다. 그러나 실시간 요구 사항이있는 경우 트랜잭션 대신 &lt;code&gt;dirty&lt;/code&gt; 작업 을 사용하는 것이 좋습니다 . &lt;code&gt;dirty&lt;/code&gt; 작업을 사용 하면 일관성 보증이 손실됩니다. 이것은 일반적으로 하나의 프로세스 만 테이블을 업데이트하도록하여 해결됩니다. 다른 프로세스는 해당 프로세스에 업데이트 요청을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb7bee577205f37d65f9821375accf63f59b42f" translate="yes" xml:space="preserve">
          <source>Usually a few managers communicate with many agents.</source>
          <target state="translated">일반적으로 몇 명의 관리자가 많은 에이전트와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="cdaebc21aedbdaa85649f3457b904bb990d3b2ea" translate="yes" xml:space="preserve">
          <source>Usually a line is added that is to state:</source>
          <target state="translated">일반적으로 다음과 같은 줄이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f7c9ebf9950b5eb0782b3cd23c9a753ea0c5e533" translate="yes" xml:space="preserve">
          <source>Usually it suffices to detect time-outs on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, option &lt;code&gt;send_timeout&lt;/code&gt; comes in handy.</source>
          <target state="translated">대부분의 프로토콜에는 서버의 일종의 승인이 포함되어 있기 때문에 일반적으로 수신시 시간 초과를 감지하면 충분하지만 프로토콜이 단방향 일 경우 &lt;code&gt;send_timeout&lt;/code&gt; 옵션 이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="72f960a27f294ee8a3a2af0d51fbe8531fe5bf1b" translate="yes" xml:space="preserve">
          <source>Usually one of &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;Application&quot;&lt;/code&gt; or &lt;code&gt;&quot;Security&quot;&lt;/code&gt;. Note that the NT eventlog viewer has another notion of category, which in most cases is totally meaningless and therefore not imported into Erlang. What is called a category here is one of the main three types of events occurring in a normal NT system.</source>
          <target state="translated">일반적으로 &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;Application&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;Security&quot;&lt;/code&gt; 중 하나입니다 . NT 이벤트 로그 뷰어에는 또 다른 범주의 개념이 있으며, 대부분의 경우 완전히 의미가 없으므로 Erlang으로 가져 오지 않습니다. 여기서 범주라고하는 것은 일반적인 NT 시스템에서 발생하는 주요 세 가지 유형의 이벤트 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="eaa3a8b7b3a6f1f39061eab776dd864c04df5840" translate="yes" xml:space="preserve">
          <source>Usually, the entities defined in the MIB are called &lt;strong&gt;Managed Objects (MOs)&lt;/strong&gt;, although they do not have to be objects in the object-oriented way. For example, a simple scalar variable defined in a MIB is called an MO. The MOs are logical objects, not necessarily with a one-to-one mapping to the resources.</source>
          <target state="translated">MIB에 정의 된 엔티티는 일반적으로 오브젝트 지향 방식의 오브젝트 일 필요는 없지만 &lt;strong&gt;관리 오브젝트 (MO)&lt;/strong&gt; 라고 합니다. 예를 들어 MIB에 정의 된 간단한 스칼라 변수를 MO라고합니다. MO는 논리적 개체이며 반드시 리소스에 일대일로 매핑 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="34333d124dba7ee56119ecbb8915169706ed629f" translate="yes" xml:space="preserve">
          <source>Utility for reading and creating 'zip' archives.</source>
          <target state="translated">'zip'아카이브를 읽고 작성하는 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="4587d8ae182b07cd6c5ddcc7013d5c9b99960884" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;BITS&lt;/code&gt; to &lt;code&gt;OCTET-STRING&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BITS&lt;/code&gt; 유형의 값 을 &lt;code&gt;OCTET-STRING&lt;/code&gt; 으로 변환하기위한 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="0e44844d0966f1f6069d31b91bf4a8abdb72b4d1" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;OCTET-STRING&lt;/code&gt; to &lt;code&gt;BITS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OCTET-STRING&lt;/code&gt; 유형의 값 을 &lt;code&gt;BITS&lt;/code&gt; 로 변환하기위한 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="4388b46bdace9a8dd94930d061cd808992ffbdfc" translate="yes" xml:space="preserve">
          <source>Utility function that starts the applications &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;. Default type is &lt;code&gt;temporary&lt;/code&gt;. For more information, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">응용 프로그램 &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; 를 시작하는 유틸리티 기능 . 기본 유형은 &lt;code&gt;temporary&lt;/code&gt; 입니다. 자세한 내용 은 커널 의 &lt;code&gt;application(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c7f90797d67794eeec5a51cfe794b557e3c3507" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formated printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;versions1&lt;/code&gt; 및 &lt;code&gt;versions2&lt;/code&gt; 기능으로 생성 된 버전 정보의 형식화 된 출력물을 생성하는 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="0bbbc215beb617665e30c05f1df892f3ab385b7d" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;versions1&lt;/code&gt; 및 &lt;code&gt;versions2&lt;/code&gt; 기능으로 생성 된 버전 정보의 형식화 된 출력물을 생성하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e9ca3adcd5764dc7d65f56277bec220d9992d1f5" translate="yes" xml:space="preserve">
          <source>Utility function(s) to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;versions1&lt;/code&gt; 기능으로 생성 된 버전 정보의 형식화 된 출력물을 생성하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="b9d38534bb1763cd2ba3d18a6d7ecd6c0ae55401" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the agent config files.</source>
          <target state="translated">에이전트 구성 파일을 처리하기위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="2afa581e37f140ef78590e09404a9aae431c2390" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the manager config files.</source>
          <target state="translated">관리자 구성 파일을 처리하기위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="6433ab0ec2c7394b801c26a999984771d7a0ae8b" translate="yes" xml:space="preserve">
          <source>Utility functions used to retrieve some system and application info.</source>
          <target state="translated">일부 시스템 및 응용 프로그램 정보를 검색하는 데 사용되는 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="aa9f46ccd3ba41c02d70b7e973f34c959fc38d56" translate="yes" xml:space="preserve">
          <source>VACM is described in detail in RFC2275. Here is only a brief description given.</source>
          <target state="translated">VACM은 RFC2275에 자세히 설명되어 있습니다. 다음은 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="c8a5c44daefed8fa60457df49456ebe3ace77f95" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BackupItems&lt;/code&gt; are the following tuples:</source>
          <target state="translated">유효한 &lt;code&gt;BackupItems&lt;/code&gt; 는 다음 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="8f005ec226ccd5bd77580fd1619b366495013be6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BindType&lt;/code&gt;s:</source>
          <target state="translated">유효한 &lt;code&gt;BindType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3768a7ccfdefa3ace61d00f77e188549db26cf0f" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;InfoTuple&lt;/code&gt;s with corresponding &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">해당 &lt;code&gt;Item&lt;/code&gt; 유효한 &lt;code&gt;InfoTuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc05afbe09b2e8c8117fcc39f7f35cc60250e0d4" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for functions:</source>
          <target state="translated">기능에 유효한 &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cf53d05dcad2f68d3d2da7de03839fc48e89fb6c" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for ports and processes:</source>
          <target state="translated">포트 및 프로세스에 유효한 &lt;code&gt;Item&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="267195f93799c6c9557e8b18de85ebfc710db9e1" translate="yes" xml:space="preserve">
          <source>Valid Erlang expressions and guard sequences are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유효한 Erlang 표현식 및 가드 시퀀스는 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b338a1ad5b1c7b18820779179ab41de826744b2b" translate="yes" xml:space="preserve">
          <source>Valid Return Values</source>
          <target state="translated">유효한 반환 값</target>
        </trans-unit>
        <trans-unit id="efbf48a6212e82d31e363fa76b710eb93043cb0c" translate="yes" xml:space="preserve">
          <source>Valid categories are:</source>
          <target state="translated">유효한 카테고리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1cdb0f6fd9b5c7ae6270cdbd6aa6489ff170a68" translate="yes" xml:space="preserve">
          <source>Valid limits are values in the range &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt;. Limits are automatically adjusted to be sane. That is, the system adjusts values so that the low limit used is lower than or equal to the high limit used. By default the high limit is 8 kB and the low limit is 4 kB.</source>
          <target state="translated">유효한 한계는 &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt; 범위의 값입니다 . 한계는 제정신으로 자동 조정됩니다. 즉, 시스템은 사용 된 하한이 사용 된 상한보다 낮거나 같도록 값을 조정합니다. 기본적으로 상한은 8kB이고 하한은 4kB입니다.</target>
        </trans-unit>
        <trans-unit id="ead2bf03d6fc68d606be1689e0611b409e03bb2a" translate="yes" xml:space="preserve">
          <source>Valid option:</source>
          <target state="translated">유효한 옵션 :</target>
        </trans-unit>
        <trans-unit id="2c6356256194f4dacdd3ceac883fb104c7079f63" translate="yes" xml:space="preserve">
          <source>Valid options &lt;code&gt;set_options&lt;/code&gt; are:</source>
          <target state="translated">유효한 옵션 &lt;code&gt;set_options&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="850c962c3f063b586578621ee12bbb84d6f38bb7" translate="yes" xml:space="preserve">
          <source>Valid options:</source>
          <target state="translated">유효한 옵션 :</target>
        </trans-unit>
        <trans-unit id="e4f1c0729761400496e047f8f256412e68cceee0" translate="yes" xml:space="preserve">
          <source>Valid return values</source>
          <target state="translated">유효한 반환 값</target>
        </trans-unit>
        <trans-unit id="1630b32c9530f31c96e521c8cf0ccc55338fbbc7" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;NodeType&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NodeType&lt;/code&gt; 에 유효한 값 :</target>
        </trans-unit>
        <trans-unit id="82b8127698b8ef2cfa8edc57143af42260620903" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element (Element).</source>
          <target state="translated">구문 분석 된 올바른 XML 요소 (요소)를 유효성 검증합니다.</target>
        </trans-unit>
        <trans-unit id="b239d15c1167b7afc50fb4ba90a070cafbcead1e" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element towards an XML schema.</source>
          <target state="translated">구문 분석 된 올바른 형식의 XML 요소를 XML 스키마로 검증합니다.</target>
        </trans-unit>
        <trans-unit id="30aa57af8387dd9dda72f74225d0c83ea7830682" translate="yes" xml:space="preserve">
          <source>Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema.</source>
          <target state="translated">두 단계로 검증합니다. 먼저 스키마를 처리하고 유형 및 구조 정보를 ets 테이블에 저장 한 다음 스키마를 향한 요소의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="d81dc9238e6ae4be4cef7714f7fca70a30cc0272" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;default&lt;/code&gt; states that the predefined properties are to be used.</source>
          <target state="translated">값 &lt;code&gt;default&lt;/code&gt; 은 사전 정의 된 특성이 사용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f4b4232752a2d39d8445512cde28d28668f7d1f" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;force&lt;/code&gt; means that a reparation is made even if the table is properly closed. This is a seldom needed option.</source>
          <target state="translated">값 &lt;code&gt;force&lt;/code&gt; 수단은 배상 테이블이 제대로 닫히지 되더라도 제조된다. 이것은 거의 필요한 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9fbeacf98f8026e5fab1b1d01a773952a1337a76" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables burst control and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 값 은 버스트 제어를 활성화 하고 &lt;code&gt;false&lt;/code&gt; 는 버스트 제어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e3e5e9f151e03304f82baa34e7f4f70c22fcd0d8" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables the feature and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 기능이 활성화되고 &lt;code&gt;false&lt;/code&gt; 이면 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="54db79fce832cc1178c718ad9c79945056373188" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;undefined&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; (the argument list) is only to be used internally in &lt;code&gt;supervisor&lt;/code&gt;. If the restart type of the child is &lt;code&gt;temporary&lt;/code&gt;, the process is never to be restarted and therefore there is no need to store the real argument list. Value &lt;code&gt;undefined&lt;/code&gt; is then stored instead.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; (인수 목록)에 대해 &lt;code&gt;undefined&lt;/code&gt; 값 은 내부적으로 &lt;code&gt;supervisor&lt;/code&gt; 에서 사용됩니다 . 하위의 재시작 유형이 &lt;code&gt;temporary&lt;/code&gt; 경우 프로세스가 재시작되지 않으므로 실제 인수 목록을 저장할 필요가 없습니다. &lt;code&gt;undefined&lt;/code&gt; 값 이 대신 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c13cbe61dee9b68ffaef6134995ebd910fbd5e" translate="yes" xml:space="preserve">
          <source>Value = IOString | atom() | integer()</source>
          <target state="translated">값 = IOString | atom () | 정수()</target>
        </trans-unit>
        <trans-unit id="1bbca064dbc2becbd7d3555273dcd4ac5b367fab" translate="yes" xml:space="preserve">
          <source>Value of a configuration parameter.</source>
          <target state="translated">구성 매개 변수의 값.</target>
        </trans-unit>
        <trans-unit id="384e64d4c66abb9cfb384072bb26c3dd0bab6612" translate="yes" xml:space="preserve">
          <source>Value to convert time unit for.</source>
          <target state="translated">시간 단위를 변환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="768d2b954af31866b6e32d7a85e19622323f08f3" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;atom()&lt;/code&gt;</source>
          <target state="translated">값 : &lt;code&gt;atom()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97045cfdad33dd3dba2b9ed63a6c87874f526b4d" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">값 : &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a052394fb5d5289ec24690454284914e11a61275" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;integer()&lt;/code&gt;</source>
          <target state="translated">값 : &lt;code&gt;integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813cf4fbeafa5124c59029940c3b8ba23a170cb6" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;on | off&lt;/code&gt;</source>
          <target state="translated">값 : &lt;code&gt;on | off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65c8d38d0b9fb94d17867d4881ce4e1d9d89030a" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</source>
          <target state="translated">값 : &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6970e248833158e8e073b58247bd68dcfc9cbf85" translate="yes" xml:space="preserve">
          <source>Values can be assigned in Erlang as follows:</source>
          <target state="translated">Erlang에서 다음과 같이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb45cee19fe1842c7fe4075c27f3b1076ddd053" translate="yes" xml:space="preserve">
          <source>Values can be assigned to an ASN.1 type within the ASN.1 code itself, as opposed to the actions in the previous section where a value was assigned to an ASN.1 type in Erlang. The full value syntax of ASN.1 is supported and X.680 describes in detail how to assign values in ASN.1. A short example:</source>
          <target state="translated">Erlang의 ASN.1 유형에 값이 지정된 이전 섹션의 조치와 ​​달리 ASN.1 코드 자체 내에서 ASN.1 유형에 값을 지정할 수 있습니다. ASN.1의 전체 값 구문이 지원되며 X.680은 ASN.1에 값을 할당하는 방법을 자세히 설명합니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="0cebf5af2c916d50162daf2371942434d298c322" translate="yes" xml:space="preserve">
          <source>Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</source>
          <target state="translated">직경 헤더의 R (요청), P (근사 가능), E (rror) 및 T (잠재적으로 재전송 된 메시지) 플래그에 해당하는 값.</target>
        </trans-unit>
        <trans-unit id="96ef06f93f26e99ce4292fa7f5fd3f23d636c4eb" translate="yes" xml:space="preserve">
          <source>Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than &lt;code&gt;undefined&lt;/code&gt; implies a set V flag.</source>
          <target state="translated">AVP 코드, M 플래그, P 플래그 및 공급 업체 ID에 해당하는 AVP 헤더의 값입니다. &lt;code&gt;undefined&lt;/code&gt; 벤더 ID 는 V 플래그 설정을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a0444f2cacebf8b2705dc3aa6c687df85244bfd3" translate="yes" xml:space="preserve">
          <source>Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</source>
          <target state="translated">직경 헤더의 버전, 메시지 길이, 명령 코드, 응용 프로그램 ID, 홉별 식별자 및 엔드-투-엔드 식별자 필드 값.</target>
        </trans-unit>
        <trans-unit id="25b7b3117ec67f563a385f6a6bbb3fc464310423" translate="yes" xml:space="preserve">
          <source>Values of these types are not currently parsed by diameter.</source>
          <target state="translated">이러한 유형의 값은 현재 직경으로 구문 분석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d14186fcac41fa3af58224092399d938dd7267c2" translate="yes" xml:space="preserve">
          <source>Values of this type can be assigned a value as an ordinary string as follows:</source>
          <target state="translated">이 유형의 값은 다음과 같이 일반 문자열로 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="297576f454c4d00030676aa9862a2b6c6efbd141" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;Emb&lt;/code&gt; can be assigned as follows:</source>
          <target state="translated">&lt;code&gt;Emb&lt;/code&gt; 유형의 값은 다음과 같이 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee70396c85e9d16e65df42fd317982706258e73" translate="yes" xml:space="preserve">
          <source>Variable ::= - same as Erlang variables -</source>
          <target state="translated">변수 :: =-Erlang 변수와 동일-</target>
        </trans-unit>
        <trans-unit id="748e5ba4cc296f39b4935e55b1705fc8ee581ce2" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;A&lt;/code&gt; is bound to the evaluated value of the list comprehension (&lt;code&gt;[1,2]&lt;/code&gt;). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a &lt;code&gt;badarg&lt;/code&gt; reason.</source>
          <target state="translated">변수 &lt;code&gt;A&lt;/code&gt; 는 목록 이해의 평가 된 값 ( &lt;code&gt;[1,2]&lt;/code&gt; )에 바인딩됩니다 . 컴파일러는 오류 메시지를 표시합니다 ( &quot;인수는 쿼리 목록 이해가 아닙니다&quot;). 쉘 프로세스는 &lt;code&gt;badarg&lt;/code&gt; 이유 때문에 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a90e8a96c62ffb5d1cd6f65922e2fc9c80f1799" translate="yes" xml:space="preserve">
          <source>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</source>
          <target state="translated">사용자 표현식에서 생성 된 변수 바인딩 및 로컬 프로세스 사전 변경 사항은 유지되며 이후 명령에서 변수를 사용하여 해당 값에 액세스 할 수 있습니다. 변수를 재사용 할 수 있도록 바인딩을 잊어 버릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a8ee25c863aa2419107fceb204e47f57f1db36" translate="yes" xml:space="preserve">
          <source>Variable key length from 32 bits up to 448 bits</source>
          <target state="translated">32 비트에서 448 비트까지 가변 키 길이</target>
        </trans-unit>
        <trans-unit id="bfc036b2b9309c7bdc08e56f286b100a63accced" translate="yes" xml:space="preserve">
          <source>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</source>
          <target state="translated">8 비트에서 최대 2048 비트까지의 가변 키 길이 (일반적으로 40-256)</target>
        </trans-unit>
        <trans-unit id="98c3d8899ac90eda2399d72ac989d5a5b85bf50c" translate="yes" xml:space="preserve">
          <source>Variables are bound to values through the &lt;strong&gt;pattern matching&lt;/strong&gt; mechanism. Pattern matching occurs when evaluating a function call, &lt;code&gt;case&lt;/code&gt;- &lt;code&gt;receive&lt;/code&gt;- &lt;code&gt;try&lt;/code&gt;- expressions and match operator (=) expressions.</source>
          <target state="translated">변수는 &lt;strong&gt;패턴 일치&lt;/strong&gt; 메커니즘을 통해 값에 바인딩됩니다 . 패턴 일치는 함수 호출, &lt;code&gt;case&lt;/code&gt; - &lt;code&gt;receive&lt;/code&gt; - &lt;code&gt;try&lt;/code&gt; -표현식 및 일치 연산자 (=) 표현식을 평가할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2184e01d1f22737f67295ee5c99577b7f02640c4" translate="yes" xml:space="preserve">
          <source>Variables are bound to values using &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt;. Erlang uses &lt;strong&gt;single assignment&lt;/strong&gt;, that is, a variable can only be bound once.</source>
          <target state="translated">변수는 &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt; 사용하여 값에 바인딩됩니다 . Erlang은 &lt;strong&gt;단일 할당을&lt;/strong&gt; 사용 &lt;strong&gt;합니다&lt;/strong&gt; . 즉, 변수는 한 번만 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1686696b0da48d910d4a99c77d1e302b425bc7" translate="yes" xml:space="preserve">
          <source>Variables can also be used to improve the readability of programs. For example, in function &lt;code&gt;list_max/2&lt;/code&gt; above, you can write:</source>
          <target state="translated">변수는 또한 프로그램의 가독성을 향상시키기 위해 사용될 수 있습니다. 예를 들어 위의 &lt;code&gt;list_max/2&lt;/code&gt; 함수 에서 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e040ee86e634cf4aa0be3ce9492a2d6be860d5dc" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a fun.</source>
          <target state="translated">재미에서 변수를 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c57858e4cc8b9cf7467d2261e8b3c42734717f8" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a list comprehension.</source>
          <target state="translated">목록 이해에서 변수를 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8d2854195ed04278e5b7b15a33240c69501a326" translate="yes" xml:space="preserve">
          <source>Variables exported from &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;case&lt;/code&gt; / &lt;code&gt;receive&lt;/code&gt; 에서 내 보낸 변수</target>
        </trans-unit>
        <trans-unit id="5eb952951e49a9b2fcfc380fe82f3b23f85123e9" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that the following works:</source>
          <target state="translated">환경에서 변수를 가져올 수 있으므로 다음이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ed92f2d37abdcb00aafc2e8c807cfc991b6f8842" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that this works:</source>
          <target state="translated">환경에서 변수를 가져올 수 있으므로 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e88c0b53ad71637f25dfbd793cc2441d427e3881" translate="yes" xml:space="preserve">
          <source>Variables imported into matches</source>
          <target state="translated">일치로 가져온 변수</target>
        </trans-unit>
        <trans-unit id="1b2ab1f9eb238cbc2cccee8878b2d4f07a335e18" translate="yes" xml:space="preserve">
          <source>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</source>
          <target state="translated">펀 헤드의 변수는 함수 이름과 펑션 표현식을 둘러싼 함수 절의 두 섀도 변수를 음영 처리합니다. 펀 바디에 묶인 변수는 펀 바디에 국한됩니다.</target>
        </trans-unit>
        <trans-unit id="18d218f35a2e3577a6c500538445abcceb060b64" translate="yes" xml:space="preserve">
          <source>Variables in this section are only used, when configuring Erlang/OTP for cross compilation using &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt;.</source>
          <target state="translated">이 섹션의 변수는 &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt; 사용하여 교차 컴파일을 위해 Erlang / OTP를 구성 할 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="08df3acc57d3675cf908a2f26030ccd4ae2beb38" translate="yes" xml:space="preserve">
          <source>Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment &lt;code&gt;fun({A,B,C})&lt;/code&gt; is replaced by &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt;, and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; is translated into &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt;.</source>
          <target state="translated">fun의 헤드에서 발생하는 변수는 발생 순서대로 일치 스펙 변수로 대체되므로 단편 &lt;code&gt;fun({A,B,C})&lt;/code&gt; 은 &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt; 대체됩니다 . 등등. 일치 스펙에서 이러한 변수가 발생할 때마다 동일한 방식으로 일치 스펙 변수로 대체되므로 &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; 가 &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt; 로 변환 될 때 의 fun fun ({A, B}) $ 1 ','$ 2 '}, [{is_atom,'$ 1 '}], ['$ 2 ']}] .</target>
        </trans-unit>
        <trans-unit id="f0ae0e8be972f79e65125dff2b6c4f9cdfb890f0" translate="yes" xml:space="preserve">
          <source>Variables of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;s belong to an environment (&lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;). A term cannot be destructed individually, it is valid until its environment is destructed.</source>
          <target state="translated">&lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 유형의 변수는 Erlang 용어를 참조 할 수 있습니다. 이것은 불투명 한 유형이며 API 함수의 인수 또는 NIF의 반환 값으로 만 사용할 수 있습니다. 모든 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 은 환경 ( &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; )에 속합니다 . 용어는 개별적으로 파괴 될 수 없으며 환경이 파괴 될 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="debd1f76422a0d8de3199d01bf29f5e66c2af413" translate="yes" xml:space="preserve">
          <source>Variables shadowed in funs and list comprehensions</source>
          <target state="translated">재미와 목록 이해에 그림자가있는 변수</target>
        </trans-unit>
        <trans-unit id="d19ebfb8e1f3e97056afbbe53540cc96bcfb11ed" translate="yes" xml:space="preserve">
          <source>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">변수는 대문자 또는 밑줄 (_)로 시작합니다. 변수는 영숫자, 밑줄 및 &lt;code&gt;@&lt;/code&gt; 를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09f862d436d21532b455bff8e767c989deff6bc5" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;_@&lt;/code&gt;, for example &lt;code&gt;_@bar&lt;/code&gt; or &lt;code&gt;_@Bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_@&lt;/code&gt; 로 시작하는 변수 ( 예 : &lt;code&gt;_@bar&lt;/code&gt; 또는 &lt;code&gt;_@Bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1225854353b77d49f7cc40d13247de7c80827209" translate="yes" xml:space="preserve">
          <source>Variables starting with underscore (_), for example, &lt;code&gt;_Height&lt;/code&gt;, are normal variables, not anonymous. They are however ignored by the compiler in the sense that they do not generate any warnings for unused variables.</source>
          <target state="translated">밑줄 (_)로 시작하는 변수 (예 : &lt;code&gt;_Height&lt;/code&gt; )는 익명이 아닌 일반 변수입니다. 그러나 사용되지 않는 변수에 대한 경고를 생성하지 않는다는 점에서 컴파일러는이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="024d797490e6edf809ed5b6c2e34f4bc4f3bebd1" translate="yes" xml:space="preserve">
          <source>Variables take the form &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt;, where &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is &lt;strong&gt;undefined&lt;/strong&gt;. In the &lt;code&gt;MatchHead&lt;/code&gt; part, the special variable &lt;code&gt;'_'&lt;/code&gt; matches anything, and never gets bound (like &lt;code&gt;_&lt;/code&gt; in Erlang).</source>
          <target state="translated">변수는 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 형식을 취합니다 . 여기서 &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; 는 0과 100,000,000 (1e + 8) 사이의 정수입니다. 숫자가이 한계를 벗어난 경우 동작은 &lt;strong&gt;정의되지 않습니다&lt;/strong&gt; . 에서 &lt;code&gt;MatchHead&lt;/code&gt; 의 일부 특수 변수 &lt;code&gt;'_'&lt;/code&gt; 는 모든 항목과 일치, 결코 (같은 바인딩됩니다 &lt;code&gt;_&lt;/code&gt; 얼랑에서).</target>
        </trans-unit>
        <trans-unit id="00bf9ad78f5cec1dd65d66ced1104921a78f995a" translate="yes" xml:space="preserve">
          <source>Variables that are defined before the fun, and that occur in function calls or guard tests within the fun, have the values they had outside the fun.</source>
          <target state="translated">fun 전에 정의되고 fun 내의 함수 호출 또는 가드 테스트에서 발생하는 변수는 fun 외부에있는 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bf0dcb58581abd4fe80849d394380c5cd405dc3e" translate="yes" xml:space="preserve">
          <source>Variables that are not included in the head are imported from the environment and made into match specification &lt;code&gt;const&lt;/code&gt; expressions. Example from the shell:</source>
          <target state="translated">헤드에 포함되지 않은 변수는 환경에서 가져 와서 일치 사양 &lt;code&gt;const&lt;/code&gt; 표현식으로 작성됩니다. 쉘의 예 :</target>
        </trans-unit>
        <trans-unit id="55df9f3ef32c412357dbc3a18bd56c7d4ce619de" translate="yes" xml:space="preserve">
          <source>Variance :: number(),</source>
          <target state="translated">분산 :: 숫자 (),</target>
        </trans-unit>
        <trans-unit id="0e31c4461c806559eaf12528c8fe9a9d293a746d" translate="yes" xml:space="preserve">
          <source>Various &quot;isolate&quot;s</source>
          <target state="translated">다양한 &quot;분리&quot;</target>
        </trans-unit>
        <trans-unit id="a1d64fcf9bb61fad40e3871e66b33e563f5b1f28" translate="yes" xml:space="preserve">
          <source>Various Erlang net administration routines.</source>
          <target state="translated">다양한 Erlang net 관리 루틴.</target>
        </trans-unit>
        <trans-unit id="f6b924712003f40d3f2878b1cac363cf1976078c" translate="yes" xml:space="preserve">
          <source>Vendor-Id AVP</source>
          <target state="translated">공급 업체 ID AVP</target>
        </trans-unit>
        <trans-unit id="48eb606505901d94f78b31e43f73e095bdf04786" translate="yes" xml:space="preserve">
          <source>Vendor-Specific-Application-Id AVP</source>
          <target state="translated">공급 업체별 응용 프로그램 ID AVP</target>
        </trans-unit>
        <trans-unit id="e96f73110a27dcecf42e3942850fdb9a84214cad" translate="yes" xml:space="preserve">
          <source>Verbose = &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">상세 = &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="adb0c527629b97acddda692f399e9ccb978796eb" translate="yes" xml:space="preserve">
          <source>Verbosity for a SNMP process. This specifies now much debug info is printed.</source>
          <target state="translated">SNMP 프로세스에 대한 자세한 정보 이것은 이제 많은 디버그 정보가 인쇄되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fee450697a5689ff92f9f50edecbf9c5c91da171" translate="yes" xml:space="preserve">
          <source>Verifies PKIX x.509 certificate signature.</source>
          <target state="translated">PKIX x.509 인증서 서명을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4326ee1947d5233b0586b451628ad661e97a0e04" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature</source>
          <target state="translated">디지털 서명을 확인합니다</target>
        </trans-unit>
        <trans-unit id="d9ade396ed77dbd522a02203fe6942326134914f" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature.</source>
          <target state="translated">디지털 서명을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b9525ebe014b53689fa4e11b528180aae4abeb4b" translate="yes" xml:space="preserve">
          <source>Verifies that the current location of the execution is visible in the code area.</source>
          <target state="translated">코드 영역에 현재 실행 위치가 표시되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1dc4741dffd06fe660bc6cd57000623888541a03" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;Cert&lt;/code&gt; is the &lt;code&gt;CRL&lt;/code&gt; signer.</source>
          <target state="translated">&lt;code&gt;Cert&lt;/code&gt; 가 &lt;code&gt;CRL&lt;/code&gt; 서명자 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5417e5a99f86d22c5664ec343d3a6c2609ec65a" translate="yes" xml:space="preserve">
          <source>Version 1.6.10 or later of the &lt;strong&gt;asn1&lt;/strong&gt; application.</source>
          <target state="translated">&lt;strong&gt;asn1&lt;/strong&gt; 애플리케이션 의 버전 1.6.10 이상</target>
        </trans-unit>
        <trans-unit id="a661417de642bc6b468d76fe5b3c6bc8775de7ac" translate="yes" xml:space="preserve">
          <source>Version 3.11 or later of &lt;strong&gt;this&lt;/strong&gt; application.</source>
          <target state="translated">&lt;strong&gt;이&lt;/strong&gt; 응용 프로그램 의 버전 3.11 이상 .</target>
        </trans-unit>
        <trans-unit id="56e5ca082097444de77af1c9fd7d0a5134aed383" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="translated">버전 관리가 설정 한 드라이버를 사용할 수 &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; 의 자신의 분야 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 을 . &lt;code&gt;erl_driver.h&lt;/code&gt; 는 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="21b8714f6e355164babd4f77276d9b70c8b55f19" translate="yes" xml:space="preserve">
          <source>Version numbers in general are only partially ordered. However, normal version numbers (with three parts) as of OTP 17.0 have a total or linear order. This applies both to normal OTP versions and normal application versions.</source>
          <target state="translated">일반적으로 버전 번호는 부분적으로 만 주문됩니다. 그러나 OTP 17.0 기준 일반 버전 번호 (3 개 부품 포함)는 전체 또는 선형 순서입니다. 이는 일반 OTP 버전과 일반 응용 프로그램 버전 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e126978ac6222c855c920d79411bed5cf12c2966" translate="yes" xml:space="preserve">
          <source>Version of an application included in the release.</source>
          <target state="translated">릴리스에 포함 된 응용 프로그램의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="473be10b81925976c7e4903e9b43ac593c8ae1c5" translate="yes" xml:space="preserve">
          <source>Version of the application.</source>
          <target state="translated">응용 프로그램의 버전.</target>
        </trans-unit>
        <trans-unit id="9a7876f7a0f780d649e426501cf895ebbd7b0903" translate="yes" xml:space="preserve">
          <source>Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</source>
          <target state="translated">세로 막대 문자는 대체 패턴을 구분하는 데 사용됩니다. 예를 들어 다음 패턴은 &quot;gilbert&quot;또는 &quot;sullivan&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">세로 탭</target>
        </trans-unit>
        <trans-unit id="5fd82a7e8d422aaa4b53ae82c82d9414739c27a0" translate="yes" xml:space="preserve">
          <source>Vertical tab (VT)</source>
          <target state="translated">수직 탭 (VT)</target>
        </trans-unit>
        <trans-unit id="089b74a153ec7d14e48cc1b72fe57aef02d54503" translate="yes" xml:space="preserve">
          <source>Vertical tab.</source>
          <target state="translated">수직 탭.</target>
        </trans-unit>
        <trans-unit id="29e9914d64c8384c209127eaf16006134a978f22" translate="yes" xml:space="preserve">
          <source>Very similar to &lt;code&gt;portTypeAcceptor&lt;/code&gt;, an intermediate stage between the request for a connect operation and that the socket is connected to an accepting ditto in the other end. When the sockets are connected, the port switches type to &lt;code&gt;portTypeCommand&lt;/code&gt;.</source>
          <target state="translated">연결 작업에 대한 요청과 소켓이 다른 쪽 끝을 수용하는 데 연결되는 중간 단계 인 &lt;code&gt;portTypeAcceptor&lt;/code&gt; 와 매우 유사합니다 . 소켓이 연결되면 포트 스위치 유형이 &lt;code&gt;portTypeCommand&lt;/code&gt; 로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e64e0bec8b57844c72ad51fbe4f769f2b726868" translate="yes" xml:space="preserve">
          <source>Viewer menu:</source>
          <target state="translated">뷰어 메뉴 :</target>
        </trans-unit>
        <trans-unit id="a76c37f0a0334ff643407ad5eae8341e4157dd19" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 (Visual Studio 12.0). Download and run the web installer from:</source>
          <target state="translated">Visual Studio 2013 (Visual Studio 12.0). 다음에서 웹 설치 프로그램을 다운로드하여 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c915e18af7a75d3dbbd7d92286c7e2d9ac312998" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="translated">짜잔! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; 은 Erlang Windows 쉘을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="716dd3292ee085b4712046407eb276268b149ea2" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="translated">다른 프로세스 (있는 경우)가 자발적으로 실행되도록합니다. 이 함수를 사용 하는 것은 &lt;code&gt;yield()&lt;/code&gt; 가 더 빠르다는 점을 제외하고 &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="5ebf20f8d1333c6ed323b151df8d0b75baeab5a0" translate="yes" xml:space="preserve">
          <source>Wait for an ack.</source>
          <target state="translated">ack를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="4d14f3abfec373cbe89f6626aa814e6ca203b696" translate="yes" xml:space="preserve">
          <source>Wait for reply after having received a pending message.</source>
          <target state="translated">보류중인 메시지를받은 후 회신을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="03a3dd1877c6b650ce26278dad8e2fb191a587d5" translate="yes" xml:space="preserve">
          <source>Wait for reply.</source>
          <target state="translated">응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="2c5a9ccfb857e48896b332926f19499a3bf34466" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive...after&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;receive...after&lt;/code&gt; 대기 중 ... 후 .</target>
        </trans-unit>
        <trans-unit id="15e59facfb286b560b3bd7e76028f43e2127a06c" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 대기 중입니다 .</target>
        </trans-unit>
        <trans-unit id="e3d6ef3cb84dde159db4dc284cfdc308ccef71dd" translate="yes" xml:space="preserve">
          <source>Waiting. This state is currently only identified on Solaris.</source>
          <target state="translated">기다리는. 이 상태는 현재 Solaris에서만 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="7c806137ff16518173274ba603d62ffafc3bdf63" translate="yes" xml:space="preserve">
          <source>Waits for a reply.</source>
          <target state="translated">회신을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="bd2ac24407b3f1c35309d00d94c7cf3be1ef6a8a" translate="yes" xml:space="preserve">
          <source>Waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked, it unlocks the mutex passed as argument. When the calling thread is woken, it locks the same mutex before returning. That is, the mutex currently must be locked by the calling thread when calling this function.</source>
          <target state="translated">조건 변수를 기다립니다. 호출 스레드는 다른 스레드가 조건 변수에서 신호를 보내거나 브로드 캐스트하여 스레드를 깨울 때까지 차단됩니다. 호출 스레드가 차단되기 전에 인수로 전달 된 뮤텍스를 잠금 해제합니다. 호출 스레드가 깨어날 때 리턴하기 전에 동일한 뮤텍스를 잠급니다. 즉, 현재이 함수를 호출 할 때 호출하는 스레드가 뮤텍스를 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="ab9651595cb08f88e44fd940126d1c71dd69f853" translate="yes" xml:space="preserve">
          <source>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">데이터가 커밋되고 모든 관련 노드에서 디스크에 사용 (디스크가 사용 된 경우) 될 때까지 기다립니다. 그렇지 않으면 &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="7d95099fabbff08dd069c5c4ee916cb8f9b1a506" translate="yes" xml:space="preserve">
          <source>Wallclock_Time_Since_Last_Call}</source>
          <target state="translated">Wallclock_Time_Since_Last_Call}</target>
        </trans-unit>
        <trans-unit id="c3b288f7da975708a0f5e331c0f162ed064cf7c2" translate="yes" xml:space="preserve">
          <source>Warang_Citi</source>
          <target state="translated">Warang_Citi</target>
        </trans-unit>
        <trans-unit id="73cea05d9ab0a2033c2e880c88d16336c1ad4134" translate="yes" xml:space="preserve">
          <source>Warn about overspecified functions (the specification is strictly less allowing than the success typing).</source>
          <target state="translated">과도하게 지정된 기능에 대해 경고하십시오 (사양은 입력 성공보다 엄격하게 허용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="09d2b974a5e842f51243b3499495df6bdd13bcaa" translate="yes" xml:space="preserve">
          <source>Warn about underspecified functions (the specification is strictly more allowing than the success typing).</source>
          <target state="translated">지정되지 않은 기능에 대해 경고하십시오 (사양이 성공 입력보다 엄격하게 허용됩니다).</target>
        </trans-unit>
        <trans-unit id="6cccd5dcb30984a83e1ff196e1800d93a16fd24a" translate="yes" xml:space="preserve">
          <source>Warn when the specification is different than the success typing.</source>
          <target state="translated">사양이 성공 입력과 다를 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="83bd22f6ddfb4c6af6ec49ac28fc7020e55db1cb" translate="yes" xml:space="preserve">
          <source>Warning events were introduced in Erlang/OTP R9C and are enabled by default as from Erlang/OTP 18.0. To retain backwards compatibility with existing user-defined event handlers, the warning events can be tagged as &lt;code&gt;errors&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt; using command-line flag &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt;, thus showing up as &lt;code&gt;ERROR REPORT&lt;/code&gt; or &lt;code&gt;INFO REPORT&lt;/code&gt; in the logs.</source>
          <target state="translated">경고 이벤트는 Erlang / OTP R9C에 도입되었으며 Erlang / OTP 18.0에서와 같이 기본적으로 활성화되어 있습니다. 기존의 사용자 정의 이벤트 핸들러와의 하위 호환성을 유지하려면 경고 이벤트로 태그 할 수 있습니다 &lt;code&gt;errors&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; 명령 줄 플래그를 사용하여 &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt; 이므로 로그에 &lt;code&gt;ERROR REPORT&lt;/code&gt; 또는 &lt;code&gt;INFO REPORT&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c71f2eab8af60b63ce0e407c87968c7af135f73" translate="yes" xml:space="preserve">
          <source>Warning option &lt;code&gt;-Wrace_conditions&lt;/code&gt; has no effect when set in source files.</source>
          <target state="translated">소스 파일에서 설정 될 때 경고 옵션 &lt;code&gt;-Wrace_conditions&lt;/code&gt; 는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b855954419a97257855c46e228014ea8104ff80a" translate="yes" xml:space="preserve">
          <source>Warning options can be restricted to functions:</source>
          <target state="translated">경고 옵션은 기능으로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="350f98fe7365f5591c6175d100ed10f345354502" translate="yes" xml:space="preserve">
          <source>Warning: you wanted to visit the site www.example.com, but the certificate is for shop.example.com. Accept anyway (yes/no)?&quot;</source>
          <target state="translated">경고 : www.example.com 사이트를 방문하려고했지만 인증서는 shop.example.com에 대한 것입니다. 어쨌든 수락 하시겠습니까 (예 / 아니요)? &quot;</target>
        </trans-unit>
        <trans-unit id="bfa481bc1014e68bf8d7481ee0ba5e89fda097c2" translate="yes" xml:space="preserve">
          <source>We add &lt;code&gt;-heart&lt;/code&gt; to &lt;code&gt;bin/start&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bin/start&lt;/code&gt; 에 &lt;code&gt;-heart&lt;/code&gt; 를 추가 합니다 :</target>
        </trans-unit>
        <trans-unit id="73b280a7b7aba8731e641abebde7cc0face25615" translate="yes" xml:space="preserve">
          <source>We already have the data as (Unicode) lists and therefore only split the list in runs of a predefined size and put each run in the table at the current position (and forward). Functions &lt;code&gt;split_data/3&lt;/code&gt; and &lt;code&gt;apply_update/2&lt;/code&gt; are implemented below.</source>
          <target state="translated">우리는 이미 데이터를 (유니 코드) 목록으로 가지고 있으므로 미리 정의 된 크기의 런으로 만 목록을 분할하고 각 런을 현재 위치 (및 앞으로)의 테이블에 넣습니다. &lt;code&gt;split_data/3&lt;/code&gt; 및 &lt;code&gt;apply_update/2&lt;/code&gt; 함수 가 아래에 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5226f0d44c399be112d6e2c67714235696a1e7cd" translate="yes" xml:space="preserve">
          <source>We also see that the call to &lt;code&gt;file:write/2&lt;/code&gt; that writes 1/4 of the file contents takes very little time in itself. What takes time is to build the data (&lt;code&gt;lists:seq/2&lt;/code&gt; and &lt;code&gt;lists:map/2&lt;/code&gt;).</source>
          <target state="translated">또한 파일 내용의 1/4을 쓰는 &lt;code&gt;file:write/2&lt;/code&gt; 에 대한 호출 자체에는 시간이 거의 걸리지 않습니다. 시간이 걸리는 것은 데이터를 작성하는 것입니다 ( &lt;code&gt;lists:seq/2&lt;/code&gt; 및 &lt;code&gt;lists:map/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d49ee7e4ad5636419e727eed1a3416350054ba7c" translate="yes" xml:space="preserve">
          <source>We always strive to remain as compatible as possible even in the cases where we give no compatibility guarantees.</source>
          <target state="translated">우리는 호환성 보증을 제공하지 않는 경우에도 항상 가능한 한 호환성을 유지하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="62c06b23c2a34df45341a353c1d6915221b4316d" translate="yes" xml:space="preserve">
          <source>We belive that the truth finally has caught with the following, retired myths.</source>
          <target state="translated">우리는 진실이 마침내 다음과 같은 은퇴 한 신화에 걸렸다는 것을 믿습니다.</target>
        </trans-unit>
        <trans-unit id="a21d18a0aa2c147b58a169cb973ed1ce3338cf1f" translate="yes" xml:space="preserve">
          <source>We call a set of ordered sets (x[1], ..., x[n]) an &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) relation&lt;/strong&gt;, and say that the relation is a subset of the Cartesian product X[1] &amp;times; ... &amp;times; X[n], where x[i] is an element of X[i], 1 &amp;lt;= i &amp;lt;= n.</source>
          <target state="translated">우리는 일련의 순서 집합 (x [1], ..., x [n])을 &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) 관계&lt;/strong&gt; 라고 부르고 그 관계는 데카르트 곱 X [1] &amp;times; ...의 부분 집합이라고 말합니다. &amp;times; X [n], 여기서 x [i]는 X [i]의 원소이며, 1 &amp;lt;= i &amp;lt;= n이다.</target>
        </trans-unit>
        <trans-unit id="413c823c35b15bc9d9bba19b8e901ed4a84786b5" translate="yes" xml:space="preserve">
          <source>We call disconnect to log out from the database. (This should have been done from Erlang, but just in case.)</source>
          <target state="translated">데이터베이스에서 로그 아웃하기 위해 disconnect를 호출합니다. (이것은 Erlang에서했을 것이지만, 만일을 위해서입니다.)</target>
        </trans-unit>
        <trans-unit id="a622cc685c06ebc1847f597b7b757bf135bf65a2" translate="yes" xml:space="preserve">
          <source>We can also start a distributed system (requires &lt;code&gt;bin/epmd&lt;/code&gt;).</source>
          <target state="translated">분산 시스템을 시작할 수도 있습니다 ( &lt;code&gt;bin/epmd&lt;/code&gt; 필요 ).</target>
        </trans-unit>
        <trans-unit id="d27be01791833f5e7361c562bc0586ab7a53f67b" translate="yes" xml:space="preserve">
          <source>We can in this example hibernate in the &lt;code&gt;{open,_}&lt;/code&gt; state, because what normally occurs in that state is that the state time-out after a while triggers a transition to &lt;code&gt;{locked,_}&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 &lt;code&gt;{open,_}&lt;/code&gt; 상태 에서 최대 절전 모드를 수행 할 수 있습니다. 해당 상태에서 일반적으로 발생하는 것은 잠시 후 상태 시간 초과가 &lt;code&gt;{locked,_}&lt;/code&gt; 로의 전환을 트리거하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="723ac72181a0f65089e1039932052a9e46e076de" translate="yes" xml:space="preserve">
          <source>We can now continue with further analyses, or we can delete the Xref server:</source>
          <target state="translated">이제 추가 분석을 계속하거나 외부 참조 서버를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256ebb1297d3c5168e6d4942a26c829b8f6be203" translate="yes" xml:space="preserve">
          <source>We continue trying to write until the queue is empty or the writing blocks.</source>
          <target state="translated">우리는 대기열이 비어 있거나 쓰기 블록이 될 때까지 계속 쓰기를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="598054eadf14bd6e3fc4f983c0ea4bf5d2acfe0d" translate="yes" xml:space="preserve">
          <source>We could find the size of the closure of the module graph with a loop similar to one used for the function graph, but since the module graph is so much smaller, a more direct method is feasible.</source>
          <target state="translated">함수 그래프에 사용 된 것과 비슷한 루프로 모듈 그래프의 폐쇄 크기를 찾을 수 있지만, 모듈 그래프가 훨씬 작기 때문에 더 직접적인 방법이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1991f07b9f9058aea6db1e8f77c1b4a56e270edc" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a state change and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="translated">버튼이 너무 빨리 눌려서 잠금 버튼으로 인식되지 않을 수 있습니다. 또는 잠금 버튼을 상태의 일부로 만들 수 있으므로 잠금 상태에서 잠금 버튼을 변경하면 변경이 상태 변경이되고 연기 된 모든 이벤트가 재 시도되므로 잠금이 즉시 잠 깁니다!</target>
        </trans-unit>
        <trans-unit id="5a9ed4b8c10518737f16e11ac495badece57b9c4" translate="yes" xml:space="preserve">
          <source>We create the table using:</source>
          <target state="translated">다음을 사용하여 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="32473b5c4698fb40d28c5576c29bf1a8447287f7" translate="yes" xml:space="preserve">
          <source>We define the state as &lt;code&gt;{StateName,LockButton}&lt;/code&gt;, where &lt;code&gt;StateName&lt;/code&gt; is as before and &lt;code&gt;LockButton&lt;/code&gt; is the current lock button:</source>
          <target state="translated">상태를 &lt;code&gt;{StateName,LockButton}&lt;/code&gt; 으로 정의합니다 . 여기서 &lt;code&gt;StateName&lt;/code&gt; 은 이전과 &lt;code&gt;LockButton&lt;/code&gt; 은 현재 잠금 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="7e5b4ef345a93f5049df742fe31287578cf4c7e2" translate="yes" xml:space="preserve">
          <source>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing.</source>
          <target state="translated">각 테이블 홀더마다 하위 에이전트가 필요하지 않습니다. 일반적으로 통신을 관리하려면 하위 에이전트가 필요하지만 Distributed Erlang에서는 일반 메시지 전달을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3dcce44305924654369f1be725b80d831eab3129" translate="yes" xml:space="preserve">
          <source>We execute a query and encode the result. Encoding is done in another C module, &lt;code&gt;pg_encode.c&lt;/code&gt;, which is also provided as sample code.</source>
          <target state="translated">쿼리를 실행하고 결과를 인코딩합니다. 인코딩은 다른 C 모듈 &lt;code&gt;pg_encode.c&lt;/code&gt; 에서 수행 되며 샘플 코드로도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c0fc2d127a89f720c3128d44e169672e74e15c80" translate="yes" xml:space="preserve">
          <source>We fill the table with randomly chosen data:</source>
          <target state="translated">무작위로 선택한 데이터로 테이블을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="3c1b0d2fdb890ab43ab70bb52624aa632e05a8ee" translate="yes" xml:space="preserve">
          <source>We find no particulary long suspend times, so no function seems to have waited in a receive statement. Actually, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contains a receive statement, but in this test program, the message lies in the process receive buffer when the receive statement is entered. We also see that the total suspend time for the test run is small.</source>
          <target state="translated">특히 긴 일시 중단 시간이 없으므로 receive 문에서 함수가 대기하지 않은 것 같습니다. 실제로 &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 에는 receive 문이 포함되어 있지만이 테스트 프로그램에서는 receive 문이 입력 될 때 메시지가 프로세스 수신 버퍼에 있습니다. 또한 테스트 실행의 총 일시 중단 시간이 짧다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539abdc8c79a99e16a54fd4c1353932c38835c6d" translate="yes" xml:space="preserve">
          <source>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on.</source>
          <target state="translated">내결함성, 영구 데이터 저장, 복제 등과 같은 Mnesia의 모든 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162b9af34243f4c75d056a06375ee57f22d03768" translate="yes" xml:space="preserve">
          <source>We handle the requests for retrieving data:</source>
          <target state="translated">데이터 검색 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="82bb167cd1f1aaced33ce89ec08193896c8c8861" translate="yes" xml:space="preserve">
          <source>We have a structure to store state needed by the driver, in this case we only need to keep the database connection:</source>
          <target state="translated">드라이버에 필요한 상태를 저장하는 구조가 있습니다.이 경우 데이터베이스 연결 만 유지하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f2ae2c27d8d0a5f2644b532540797a414ff961" translate="yes" xml:space="preserve">
          <source>We have included some simple tool(s) for codec measurement (meas), performance tests (mstone1 and mstone2) and message transformation.</source>
          <target state="translated">코덱 측정 (meas), 성능 테스트 (mstone1 및 mstone2) 및 메시지 변환을위한 몇 가지 간단한 도구가 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d35a0217a0c4d25516c55c6b13eeb0ee82ce246" translate="yes" xml:space="preserve">
          <source>We have instrumented our code in order to enable tracing. Running the application with tracing deactivated, causes a negligible performance overhead (an external call to a function which returns an atom). Activation of tracing does not require any recompilation of the code, since we rely on Erlang/OTP's built in support for dynamic trace activation. In our case tracing of calls to a given external function.</source>
          <target state="translated">추적을 가능하게하기 위해 코드를 계측했습니다. 추적이 비활성화 된 상태에서 응용 프로그램을 실행하면 무시할만한 성능 오버 헤드 (아톰을 반환하는 함수에 대한 외부 호출)가 발생합니다. Erlang / OTP의 동적 추적 활성화 지원 기능에 의존하기 때문에 추적 활성화에는 코드를 다시 컴파일 할 필요가 없습니다. 우리의 경우 주어진 외부 함수에 대한 호출 추적.</target>
        </trans-unit>
        <trans-unit id="19f3224f897b7485ee092aee943fad0f50d468c0" translate="yes" xml:space="preserve">
          <source>We have introduced the term &quot;user&quot; as a generic term for either an MG or an MGC, since most of the functionality we support, is common for both MG's and MGC's. A (local) user may be configured in various ways and it may establish any number of connections to its counterpart, the remote user. Once a connection has been established, the connection is supervised and it may be used for the purpose of sending messages. N.B. according to the standard an MG is connected to at most one MGC, while an MGC may be connected to any number of MG's.</source>
          <target state="translated">우리는 &quot;사용자&quot;라는 용어를 MG 또는 MGC에 대한 일반적인 용어로 도입했습니다. 지원하는 대부분의 기능은 MG 및 MGC에 공통이기 때문입니다. (로컬) 사용자는 다양한 방식으로 구성 될 수 있으며, 원격 사용자에 대한 임의의 수의 연결을 확립 할 수있다. 연결이 설정되면 연결이 감독되고 메시지 전송 목적으로 사용될 수 있습니다. 표준에 따라 NB는 MG가 최대 하나의 MGC에 연결되는 반면, MGC는 임의의 수의 MG에 연결될 수있다.</target>
        </trans-unit>
        <trans-unit id="877518c89585383e3076c104aa3cd7f7e23bc498" translate="yes" xml:space="preserve">
          <source>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</source>
          <target state="translated">우리는 다른 인코더 / 디코더를 비교하기 위해 Megaco / H.248 프로토콜 스택의 Erlang / OTP 구현에 대해 4 가지 다른 측정을 수행했습니다. 각 결과는 아래 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e594586e3be21133f5db0b9bde85bb9f42084bb6" translate="yes" xml:space="preserve">
          <source>We have sometimes experienced problems with Oracle's &lt;code&gt;java&lt;/code&gt; running out of memory when running &lt;code&gt;fop&lt;/code&gt;. Increasing the amount of memory available as follows has in our case solved the problem.</source>
          <target state="translated">&lt;code&gt;fop&lt;/code&gt; 을 실행할 때 Oracle의 &lt;code&gt;java&lt;/code&gt; 메모리 부족 문제가 가끔 발생했습니다 . 다음과 같이 사용 가능한 메모리 양을 늘리면 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="0bc0044e17c922875d4350027f6b2f290ff7821f" translate="yes" xml:space="preserve">
          <source>We include &lt;code&gt;FromPid&lt;/code&gt; just in case we want to trace this.</source>
          <target state="translated">우리는 &lt;code&gt;FromPid&lt;/code&gt; 추적하기 위해 FromPid를 포함 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="62c14d96eb9053e2cc8b3f1d2c457d07c9567687" translate="yes" xml:space="preserve">
          <source>We loop through the requests one at the time, stopping when we either encounter an error or the list is exhausted. The last return value is sent back to the client (it is first returned to the main loop and then sent back by function &lt;code&gt;io_reply&lt;/code&gt;).</source>
          <target state="translated">한 번에 하나씩 요청을 반복하여 오류가 발생하거나 목록이 소진되면 중지합니다. 마지막 반환 값은 클라이언트로 다시 전송됩니다 (먼저 기본 루프로 반환 된 다음 &lt;code&gt;io_reply&lt;/code&gt; 함수에 의해 다시 전송 됨 ).</target>
        </trans-unit>
        <trans-unit id="a36c7a61f34ba2a33c8e34b5446fa5e93cb80751" translate="yes" xml:space="preserve">
          <source>We match on the top element and embed the inner parts in an HTML body. Then we extract the string values of all motorcycle brands, sort them and removes duplicates by &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt;. We also process the substructure of the top element and pass it to a function that sorts all motorcycle information by brand according to the task formulation in the beginning of this example.</source>
          <target state="translated">상단 요소와 일치하고 내부 부분을 HTML 본문에 포함시킵니다. 그런 다음 모든 모터 사이클 브랜드의 문자열 값을 추출하여 정렬하고 &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt; 중복을 제거합니다 . 또한 상단 요소의 하위 구조를 처리하고이 예제의 시작 부분에서 작업 구성에 따라 모든 오토바이 정보를 브랜드별로 정렬하는 기능으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7fc0e2937cea34ba0f1d5aa2eb64c711b2673f69" translate="yes" xml:space="preserve">
          <source>We need to handle backward compatibility and the &lt;code&gt;file&lt;/code&gt; module (which uses the old requests until backward compatibility with pre-R13 nodes is no longer needed). Notice that the I/O server does not work with a simple &lt;code&gt;file:write/2&lt;/code&gt; if these are not added:</source>
          <target state="translated">이전 버전과의 호환성 및 &lt;code&gt;file&lt;/code&gt; 모듈 (R13 이전 노드와의 하위 호환성이 더 이상 필요하지 않을 때까지 이전 요청을 사용함) 을 처리해야합니다 . I / O 서버는 간단한 &lt;code&gt;file:write/2&lt;/code&gt; 추가되지 않은 경우)로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4d6ac95529809d2ef950ae107e48095fe8aabd08" translate="yes" xml:space="preserve">
          <source>We need to handle some requests. First the requests for writing characters:</source>
          <target state="translated">일부 요청을 처리해야합니다. 먼저 문자 쓰기 요청 :</target>
        </trans-unit>
        <trans-unit id="65164610102defaf9d5b21fb95ba5620406fc14d" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;-callback&lt;/code&gt; attribute rather than the &lt;code&gt;behaviour_info()&lt;/code&gt; function. The reason is that the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">&lt;code&gt;behaviour_info()&lt;/code&gt; 함수 대신 &lt;code&gt;-callback&lt;/code&gt; 속성을 사용하는 것이 좋습니다 . 도구에서 추가 유형 정보를 사용하여 문서를 작성하거나 불일치를 찾을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="346c9aa8780b8aa277233c8030ef3ce8528b2a4f" translate="yes" xml:space="preserve">
          <source>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;_@Foo@&lt;/code&gt;, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</source>
          <target state="translated">이를 &quot;자동 메타 변수&quot;라고합니다. 또한 이름이 &lt;code&gt;_@Foo@&lt;/code&gt; 에서 와 같이 &lt;code&gt;@&lt;/code&gt; 로 끝나는 경우 Erlang 용어 인 변수 값은 더 큰 트리를 구성하는 데 사용될 때 해당 추상 구문 트리로 자동 변환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16a9f8a4bc23ba990af592e409f5c51b8ea523ef" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;file:write/2&lt;/code&gt; only calls &lt;code&gt;prim_file:write/2&lt;/code&gt;, but let us refrain from digging into the internals of the kernel application.</source>
          <target state="translated">우리는 볼 &lt;code&gt;file:write/2&lt;/code&gt; 만 호출 &lt;code&gt;prim_file:write/2&lt;/code&gt; ,하지만 우리가 커널 응용 프로그램의 내부로 파고 자제하자.</target>
        </trans-unit>
        <trans-unit id="8c3b22518344463198707dd795380094d0c8925a" translate="yes" xml:space="preserve">
          <source>We see that the new release version is &lt;code&gt;permanent&lt;/code&gt;, so it would be safe to restart the node.</source>
          <target state="translated">새 릴리스 버전은 &lt;code&gt;permanent&lt;/code&gt; 이므로 노드를 다시 시작하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b50565a62199c6c141d92fc8afb4546283ef2fd4" translate="yes" xml:space="preserve">
          <source>We simply pick out an I/O vector from the queue (which is the whole queue as a &lt;code&gt;SysIOVec&lt;/code&gt;). If the I/O vector is too long (&lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; is defined to 16), the vector length is decreased (line 15), otherwise the &lt;code&gt;writev&lt;/code&gt; call (line 17) fails. Writing is tried and anything written is dequeued (line 27). If the write fails with &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (notice that all sockets are in non-blocking mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_output&lt;/code&gt; routine be called when there is space to write again.</source>
          <target state="translated">큐 ( &lt;code&gt;SysIOVec&lt;/code&gt; 로서 전체 큐)에서 I / O 벡터를 선택합니다 . I / O 벡터가 너무 길면 ( &lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; 가 16으로 정의 됨) 벡터 길이가 줄어든 (15 행) 그렇지 않으면 &lt;code&gt;writev&lt;/code&gt; 호출 (17 행)이 실패합니다. 글쓰기가 시도되고 쓰인 내용이 대기열에서 제외됩니다 (27 행). &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 으로 쓰기에 실패하면 (모든 소켓이 비 블로킹 모드에 있음에 &lt;code&gt;driver_select&lt;/code&gt; ), 다시 쓸 공간이있을 때 &lt;code&gt;uds_output&lt;/code&gt; 루틴 이 호출되도록 driver_select 가 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0ada7dbfa4e9b0738c600e7e0aaa004c64d9416" translate="yes" xml:space="preserve">
          <source>We specify the filter, we want to view calls that resemble &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt;:</source>
          <target state="translated">필터를 지정하고 &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt; 과 유사한 호출을 보려고합니다 .</target>
        </trans-unit>
        <trans-unit id="1235892250491b3de3e5ff2495a68e9d2682e8e0" translate="yes" xml:space="preserve">
          <source>We start a &lt;strong&gt;simple target system&lt;/strong&gt; as above. The only difference is that also the file &lt;code&gt;releases/RELEASES&lt;/code&gt; is present for code replacement in runtime to work.</source>
          <target state="translated">위와 같이 &lt;strong&gt;간단한 대상 시스템&lt;/strong&gt; 을 시작합니다 . 유일한 차이점은 파일 &lt;code&gt;releases/RELEASES&lt;/code&gt; 가 런타임의 코드 교체를 위해 존재한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c601e5855e0a64b0a4dc2997f72bc0154a5ac01a" translate="yes" xml:space="preserve">
          <source>We start writing the example Unix domain sockets driver by declaring prototypes and filling in a static &lt;code&gt;ErlDrvEntry&lt;/code&gt; structure:</source>
          <target state="translated">프로토 타입을 선언하고 정적 &lt;code&gt;ErlDrvEntry&lt;/code&gt; 구조를 작성하여 예제 Unix 도메인 소켓 드라이버 작성을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="644c408e343363fe6260f95a6a30cda576bd3ce6" translate="yes" xml:space="preserve">
          <source>We store the &lt;code&gt;creation&lt;/code&gt; serial number in the file. The &lt;code&gt;creation&lt;/code&gt; is a number that is to change between different instances of different Erlang emulators with the same name, so that process identifiers from one emulator do not become valid when sent to a new emulator with the same distribution name. The creation can be from 0 through 3 (two bits) and is stored in every process identifier sent to another node.</source>
          <target state="translated">파일에 &lt;code&gt;creation&lt;/code&gt; 일련 번호를 저장 합니다. &lt;code&gt;creation&lt;/code&gt; 동일한 분포 이름으로 새로운 에뮬레이터에 전송 한 때부터 그 프로세스 식별자 에뮬레이터 유효하게하지 않아도, 동일한 이름을 가진 다른 얼랑 에뮬레이터의 다른 인스턴스간에 변화하는 수이다. 작성은 0-3 (2 비트) 일 수 있으며 다른 노드로 전송 된 모든 프로세스 ID에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="63a6ffdb62bb132307bcc5f5fe297a041b9ec3d7" translate="yes" xml:space="preserve">
          <source>We strongly encourage the use of the &lt;code&gt;RowStatus&lt;/code&gt; convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used.</source>
          <target state="translated">새로 설계된 SNMPv1 MIB의 경우에도 관리자에서 수정할 수있는 모든 테이블 에 대해 &lt;code&gt;RowStatus&lt;/code&gt; 규칙을 사용하는 것이 좋습니다 . SNMPv1에서는 모든 사람이 테이블 작업 에뮬레이션을위한 고유 한 체계를 개발하여 수많은 불일치가 발생했습니다. SNMPv2의 규칙은 유연하고 강력하며 성공적으로 테스트되었습니다. 테이블이 읽기 전용이면 RowStatus 열을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="508ccb34921947b5beb2005777369f595ad7c8a8" translate="yes" xml:space="preserve">
          <source>We study the state that is needed for the ports. Notice that not all fields are used for all types of ports. Some space could be saved by using unions, but that would clutter the code with multiple indirections, so here is used one struct for all types of ports, for readability:</source>
          <target state="translated">우리는 포트에 필요한 상태를 연구합니다. 모든 필드가 모든 유형의 포트에 사용되는 것은 아닙니다. 일부 공간은 공용체를 사용하여 절약 할 수 있지만 여러 간접 코드로 코드를 복잡하게 만들 수 있으므로 여기에서는 가독성을 위해 모든 유형의 포트에 대해 하나의 구조체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0570780114e9fc609087371872169fccbd297f49" translate="yes" xml:space="preserve">
          <source>We suspect the &lt;code&gt;ets:new/2&lt;/code&gt; call, as we match hard on the return value, but want only the particular &lt;code&gt;new/2&lt;/code&gt; call with &lt;code&gt;toy_table&lt;/code&gt; as first parameter. So we start a default tracer on the node:</source>
          <target state="translated">우리는 &lt;code&gt;ets:new/2&lt;/code&gt; 호출을 의심합니다 . 리턴 값에서 열심히 일치하지만 &lt;code&gt;toy_table&lt;/code&gt; 을 첫 번째 매개 변수로 사용 하여 특정 &lt;code&gt;new/2&lt;/code&gt; 호출 만 원합니다 . 따라서 노드에서 기본 추적 프로그램을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f5bbffab7f95f81cee247421bd092ab29a87848d" translate="yes" xml:space="preserve">
          <source>We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):</source>
          <target state="translated">모든 프로세스에 대해 통화 추적을 설정하고 매우 제한적인 추적 패턴을 만들고 싶기 때문에 몇 개의 프로세스 만 추적 할 필요가 없습니다 (보통 그렇지 않음).</target>
        </trans-unit>
        <trans-unit id="59f43c3a056dd53d064433399740ce5398c03179" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;dbg:tpl/3&lt;/code&gt; to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing.</source>
          <target state="translated">우리는 사용 &lt;code&gt;dbg:tpl/3&lt;/code&gt; (모듈이 작은 버전 이후 성장과 원자의 삽입이 로컬로 수행되지 않은 경우 우리가 알 수없는 가정) 지역 통화를 잡을 수 있도록. 확실하지 않은 경우 항상 로컬 통화 추적을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3db459c71765166584b222966eebe056c8bcb451" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;port_control/3&lt;/code&gt; function for all calls into the driver. The result from the driver is returned immediately and converted to terms by calling &lt;code&gt;binary_to_term/1&lt;/code&gt;. (We trust that the terms returned from the driver are well-formed, otherwise the &lt;code&gt;binary_to_term&lt;/code&gt; calls could be contained in a &lt;code&gt;catch&lt;/code&gt;.)</source>
          <target state="translated">우리 는 드라이버에 대한 모든 호출에 &lt;code&gt;port_control/3&lt;/code&gt; 함수를 사용합니다 . 드라이버의 결과는 즉시 리턴되고 &lt;code&gt;binary_to_term/1&lt;/code&gt; 을 호출하여 용어로 변환됩니다 . (우리는 드라이버에서 반환 된 용어의 형식이 양호하다고 생각합니다. 그렇지 않으면 &lt;code&gt;binary_to_term&lt;/code&gt; 호출이 &lt;code&gt;catch&lt;/code&gt; 에 포함될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="02fb426878fcef94b8e18d9576286ad65ac4ed4a" translate="yes" xml:space="preserve">
          <source>We use the binary format only to return data to the emulator; input data is a string parameter for &lt;code&gt;connect&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;. The returned data consists of Erlang terms.</source>
          <target state="translated">이진 형식을 사용하여 에뮬레이터에 데이터를 반환합니다. 입력 데이터는 &lt;code&gt;connect&lt;/code&gt; 및 &lt;code&gt;select&lt;/code&gt; 위한 문자열 매개 변수입니다 . 반환 된 데이터는 Erlang 용어로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="014d84a4d3abb1236ee92db9f5f0d5547ff6a186" translate="yes" xml:space="preserve">
          <source>We use the function &lt;code&gt;Rep&lt;/code&gt; to denote the mapping from an Erlang source construct &lt;code&gt;C&lt;/code&gt; to its abstract format representation &lt;code&gt;R&lt;/code&gt;, and write &lt;code&gt;R = Rep(C)&lt;/code&gt;.</source>
          <target state="translated">우리는 함수를 사용하여 &lt;code&gt;Rep&lt;/code&gt; 얼랑 소스 구조에의 매핑을 표시하기 위해 &lt;code&gt;C&lt;/code&gt; 를 자사의 추상적 인 형식의 표현에 &lt;code&gt;R&lt;/code&gt; , 및 쓰기 &lt;code&gt;R = Rep(C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b955b8cc53f04946e7906d8bccd83ad77bc547a4" translate="yes" xml:space="preserve">
          <source>We use the same internal form for both the binary and text encoding. Our internal form of Megaco/H.248 messages is heavily influenced by the internal format used by ASN.1 encoders/decoders:</source>
          <target state="translated">바이너리와 텍스트 인코딩 모두에 동일한 내부 형식을 사용합니다. 내부 형식의 Megaco / H.248 메시지는 ASN.1 인코더 / 디코더가 사용하는 내부 형식에 크게 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="09eafdf76bfe34feacf5ab1510c6a7720bed3f57" translate="yes" xml:space="preserve">
          <source>We use the simplest possible &lt;code&gt;sys.config&lt;/code&gt;, which we store in &lt;code&gt;releases/FIRST&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;releases/FIRST&lt;/code&gt; 저장 하는 가장 간단한 &lt;code&gt;sys.config&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d8589e4a15b7a5013c9800a611e86facb44e60" translate="yes" xml:space="preserve">
          <source>We very much welcome user feedback - even wishlists! If you notice anything weird, especially if Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them.</source>
          <target state="translated">우리는 사용자의 의견을 환영합니다 &amp;ndash; 위시리스트까지! 이상한 것이 발견되면, 특히 Dialyzer가 오 탐지로 불일치를보고하면 증상과 그 재현 방법을 설명하는 오류 보고서를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="c5f285e2cc8e54c3430820d9c7f8e8768e8a5b79" translate="yes" xml:space="preserve">
          <source>We want a locking mechanism that gives no race conditions, to be sure if another Erlang node uses the listen socket name we require or if the file is only left there from a previous (crashed) session.</source>
          <target state="translated">경쟁 조건을 제공하지 않는 잠금 메커니즘이 필요합니다. 다른 Erlang 노드가 필요한 청취 소켓 이름을 사용하는지 또는 파일이 이전 (크래쉬 된) 세션에서만 남아 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b3d62af079f72041cf5e740a82dc4dbd33004d95" translate="yes" xml:space="preserve">
          <source>We want to find the reduction of the closure of the function graph to modules. The direct expression for doing that would be &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt;, but then we would have to represent all of the transitive closure of E in memory. Instead the number of indirectly used modules is found for each analyzed module, and the sum over all modules is calculated.</source>
          <target state="translated">함수 그래프의 폐쇄가 모듈로 축소되는 것을 찾고 싶습니다. 그렇게하는 직접적인 표현은 &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt; 이 될 것이지만, 메모리에서 E의 모든 전 이적 클로저를 표현해야합니다. 대신 간접적으로 사용 된 모듈의 수는 분석 된 각 모듈에 대해 발견되며 모든 모듈에 대한 합계가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d1cec4b25e7ec82e4a29c249c1772265612c2f98" translate="yes" xml:space="preserve">
          <source>We will first go through the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure which people probably are most familiar with.</source>
          <target state="translated">먼저 사람들이 가장 익숙한 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 빌드 절차를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e5ff38c2602baf56bc8c3440d3937fb894b7ad10" translate="yes" xml:space="preserve">
          <source>We will not be bug-compatible. A bug fix might introduce incompatible changes. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">우리는 버그 호환되지 않습니다. 버그 수정으로 인해 호환되지 않는 변경이 발생할 수 있습니다. 이러한 종류의 비 호환성은 패치에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad9e6cc5dd978296e9f3155b1fac5bd4e904894" translate="yes" xml:space="preserve">
          <source>We will see more details of this later. If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an &lt;strong&gt;Erlang node&lt;/strong&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 나중에 볼 수 있습니다. 분산 Erlang을 실험하고 싶지만 한 대의 컴퓨터 만 작업하려는 경우 동일한 컴퓨터에서 두 개의 개별 Erlang 시스템을 시작하지만 서로 다른 이름을 지정할 수 있습니다. 컴퓨터에서 실행되는 각 Erlang 시스템을 &lt;strong&gt;Erlang 노드&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6fd397370c00ee4d81771bc1a4690627c9a9c47d" translate="yes" xml:space="preserve">
          <source>We would recommend using 1.0.2d.</source>
          <target state="translated">1.0.2d를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="843043fadfaea89e297baed2f38224161728a8fc" translate="yes" xml:space="preserve">
          <source>We write it using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ets:fun2ms/1&lt;/code&gt; 을 사용하여 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="2d11ec20af5e84fd81824db4ba0a8cd93159b8e2" translate="yes" xml:space="preserve">
          <source>We've tried up to 1.0, but the latest version should do. Make sure you download the &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt;, not a linux version. You unzip the package on top of your MinGW installation (&lt;code&gt;c:\MinGW&lt;/code&gt;) and that's it.</source>
          <target state="translated">1.0까지 시도했지만 최신 버전이 필요합니다. Linux 버전이 아닌 &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt; 을 다운로드하십시오 . MinGW 설치 ( &lt;code&gt;c:\MinGW&lt;/code&gt; ) 위에 패키지의 압축을 풀면 됩니다.</target>
        </trans-unit>
        <trans-unit id="b8eef6e94eb7100a713ed2ea56c1d7018de92907" translate="yes" xml:space="preserve">
          <source>We've used this build procedure for a couple of releases, and it has worked fine for us. Still, there might be all sorts of troubles on different machines and with different setups. We'll try to give hints wherever we've encountered difficulties, but please share your experiences by using the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; mailing list. We cannot, of course, help everyone with all their issues, so please try to solve such issues and submit solutions/workarounds.</source>
          <target state="translated">우리는이 빌드 절차를 몇 가지 릴리스에 사용했으며 우리에게 잘 작동했습니다. 그럼에도 불구하고 다른 시스템과 설정에 따라 모든 종류의 문제가 발생할 수 있습니다. 문제가 발생한 곳마다 힌트를 주려고 노력하지만 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; 메일 링리스트를 사용하여 경험을 공유하십시오 . 물론 모든 문제에 대해 모든 사람을 도울 수는 없으므로 그러한 문제를 해결하고 해결책 / 해결 방법을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="b36b032611690f561af6ed7868e7f249080a2d29" translate="yes" xml:space="preserve">
          <source>Web server users without server administrative privileges that need to manage authentication of web pages that are local to their user can use the per-directory runtime configurable user-authentication scheme &lt;code&gt;htaccess&lt;/code&gt;. It works as follows:</source>
          <target state="translated">사용자에게 로컬 인 웹 페이지의 인증을 관리해야하는 서버 관리 권한이없는 웹 서버 사용자는 디렉토리 별 런타임 구성 가능 사용자 인증 체계 &lt;code&gt;htaccess&lt;/code&gt; 를 사용할 수 있습니다 . 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3ee3b99c66ed2c1f02ee33b7f98ce7fdcb23b424" translate="yes" xml:space="preserve">
          <source>Welcome to Erlang/OTP, a complete development environment for concurrent programming.</source>
          <target state="translated">동시 프로그래밍을위한 완벽한 개발 환경 인 Erlang / OTP에 오신 것을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="22c886918035c78f6182ee187f960d0ece83d0bb" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">이 경우 인쇄 가능한 문자 는 Erlang VM의 시작 플래그 &lt;code&gt;+pc&lt;/code&gt; 에 의해 결정됩니다 . &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;erl(1)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4edfb9d438187e25e8117b3d96348c8b942d6ff3" translate="yes" xml:space="preserve">
          <source>What is captured in this example is the part of the work the shell does while interpreting the command line that occurs between the actual calls to &lt;code&gt;cprof:start()&lt;/code&gt; and &lt;code&gt;cprof:analyse()&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 캡처 된 것은 &lt;code&gt;cprof:start()&lt;/code&gt; 및 &lt;code&gt;cprof:analyse()&lt;/code&gt; 대한 실제 호출 사이에서 발생하는 명령 행을 해석하는 동안 쉘이 수행하는 작업의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="8308f9197a4bcfd38df815152af92e5bca4b765b" translate="yes" xml:space="preserve">
          <source>What makes the &lt;code&gt;Mnesia&lt;/code&gt; data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 데이터 모델을 확장 된 관계형 모델로 만드는 것은 속성 필드에 임의의 Erlang 용어를 저장하는 기능입니다. 예를 들어 하나의 속성 값은 다른 테이블의 다른 용어로 이어지는 전체 OID 트리 일 수 있습니다. 이러한 유형의 레코드는 기존 관계형 DBMS에서 모델링하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="405eee64426a95cf4618da03e92872e8805137ae" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="translated">당신은 무엇을 더 할 수 있습니까? 간단한 대답은 : ERTS 사용 설명서의 &lt;code&gt;match specifications&lt;/code&gt; 설명서를 참조하십시오 . 그러나 다음은 재미가 &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; 에 의해 일치 스펙으로 변환 될 때 사용할 수있는 가장 유용한 &quot;내장 함수&quot;에 대한 간략한 개요입니다 . 일치 스펙에서 허용 된 것 이외의 다른 함수를 호출 할 수 없습니다. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 로 번역 된 기능으로 &quot;일반&quot;Erlang 코드를 실행할 수 없습니다 . 재미는 불행히도 경기 사양의 힘으로 정확하게 제한되지만 &lt;code&gt;ets:foldl/foldr&lt;/code&gt; 과 비교하여 ets : &lt;code&gt;ets:select/2&lt;/code&gt; 의 실행 속도에 대해 지불해야하는 가격 입니다.</target>
        </trans-unit>
        <trans-unit id="be9abe5ff356944e50659de71982880b18848dd6" translate="yes" xml:space="preserve">
          <source>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</source>
          <target state="translated">실제 메모리 예약의 의미는 운영 체제 및 구성 방법에 따라 다릅니다. 예를 들어 Linux의 다른 메모리 오버 커밋 설정은 동작을 크게 변경합니다.</target>
        </trans-unit>
        <trans-unit id="587af77c14f789357e51980e72003df91f480665" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;qlc&lt;/code&gt; module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Usually &lt;code&gt;qlc:table/2&lt;/code&gt; is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: &lt;code&gt;mnesia:table/1,2&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt;. For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describes the implementation of a function calling &lt;code&gt;qlc:table/2&lt;/code&gt;.</source>
          <target state="translated">무엇 &lt;code&gt;qlc&lt;/code&gt; 모듈은 주로 지능형리스트에 추가하면 해당 데이터가 작은 덩어리 QLC 테이블에서 읽을 수있다. &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 QLC 테이블이 작성됩니다 . 일반적으로 &lt;code&gt;qlc:table/2&lt;/code&gt; 는 쿼리에서 직접 호출되지 않고 일부 데이터 구조의 인터페이스 함수를 통해 호출됩니다. Erlang / OTP에는 &lt;code&gt;mnesia:table/1,2&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt; 와 같은 함수의 몇 가지 예가 포함되어 있습니다. 주어진 데이터 구조에 대해 많은 함수가 QLC 테이블을 작성할 수 있지만 이러한 함수의 공통점은 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; 로 작성된 조회 핸들을 리턴한다는 것 입니다. Erlang / OTP가 제공하는 QLC 테이블을 사용하는 것이 일반적이지만 충분하지만 고급 사용자 섹션에는 충분합니다. &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출하는 함수의 구현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e307252350d5f0ef992b3ab620b890f8bd198517" translate="yes" xml:space="preserve">
          <source>What the I/O server sends when there is no data.</source>
          <target state="translated">데이터가 없을 때 I / O 서버가 보내는 것.</target>
        </trans-unit>
        <trans-unit id="1804d21d5ef8f5b8cb1f89c4e94fe07aef9672aa" translate="yes" xml:space="preserve">
          <source>What this means, if anything, is implementation dependent.</source>
          <target state="translated">이것이 의미하는 바는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a86e62a665b180d594c01dd61c21371b36d33af5" translate="yes" xml:space="preserve">
          <source>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</source>
          <target state="translated">이러한 경우 메타 변수를 구문 적으로 유효한 위치에 작성하고 리프팅 마커를 사용하여 다음과 같이 실제로 적용해야하는 위치를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c621a34cc77c693f796b9c9a4e0202b514808a" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="translated">테스트 스위트에서 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 가 추가 한 것 .</target>
        </trans-unit>
        <trans-unit id="0e65ac25edcc6a715cbfb229eba192595c676d46" translate="yes" xml:space="preserve">
          <source>When (*SKIP) has an associated name, its behavior is modified:</source>
          <target state="translated">(* SKIP)에 연관된 이름이 있으면 해당 동작이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="04fe958830198355cc811da35c494d7c1c3c2d18" translate="yes" xml:space="preserve">
          <source>When (finally?) everything is in order with the locale settings, fonts. and the terminal emulator, you have probably found a way to input characters in the script you desire. For testing, the simplest way is to add some keyboard mappings for other languages, usually done with some applet in your desktop environment.</source>
          <target state="translated">로케일 설정, 글꼴 순서대로 (마침내?) 터미널 에뮬레이터에서 원하는 스크립트에 문자를 입력하는 방법을 찾았을 것입니다. 테스트를위한 가장 간단한 방법은 일반적으로 데스크탑 환경에서 일부 애플릿을 사용하여 다른 언어에 대한 키보드 매핑을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c61293396a0994c6191d7911346e57c38611cf9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; 라고, 로거 호출 &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt; . 이 함수가 &lt;code&gt;{ok,NewConfig1}&lt;/code&gt; 을 반환 하면 로거는 &lt;code&gt;NewConfig1&lt;/code&gt; 을 구성 데이터베이스에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="93e75014a8819db24d123ffe574cf1058af1d7b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Addr&lt;/code&gt; does not contain a port number, the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">때 &lt;code&gt;Addr&lt;/code&gt; 포트 번호를 포함하지 않는,의 값 &lt;code&gt;port&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3df4cc98d21f4d7157a7f5c03ed4afe7255c29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:cancel_timer()&lt;/code&gt;. otherwise &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">때 &lt;code&gt;Async&lt;/code&gt; 있습니다 &lt;code&gt;false&lt;/code&gt; : 경우에 &lt;code&gt;Info&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 의 &lt;code&gt;Result&lt;/code&gt; 에 의해 반환되는 &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;ok&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c3055751c190947148414125cb3febf1e8f6f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a message on the form &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; when the cancellation operation has been performed, otherwise no message is sent.</source>
          <target state="translated">경우 &lt;code&gt;Async&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; : 만약 &lt;code&gt;Info&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; , 폼 메시지 &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; 호출자에게 송신된다 &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; 취소 동작이 수행되면, 그렇지 않으면 메시지를 송신한다.</target>
        </trans-unit>
        <trans-unit id="166a240b6e5cc60a7634b1583a60930de57018f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Common Test&lt;/code&gt; starts, it automatically attempts to compile any suites included in the specified tests. If particular suites are specified, only those suites are compiled. If a particular test object directory is specified (meaning all suites in this directory are to be part of the test), &lt;code&gt;Common Test&lt;/code&gt; runs function &lt;code&gt;make:all/1&lt;/code&gt; in the directory to compile the suites.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 가 시작 되면 지정된 테스트에 포함 된 스위트를 자동으로 컴파일하려고 시도합니다. 특정 스위트가 지정되면 해당 스위트 만 컴파일됩니다. 특정 테스트 오브젝트 디렉토리가 지정된 경우 (이 디렉토리의 모든 스위트가 테스트의 일부임을 의미 함) &lt;code&gt;Common Test&lt;/code&gt; 는 스위트에서 컴파일하기 위해 디렉토리에서 &lt;code&gt;make:all/1&lt;/code&gt; 함수 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="42507199eef19752873563b14392dfa940c65fc9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 많은 테이블을로드 할 때 기본로드 순서가 사용됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 테이블의 &lt;code&gt;load_order&lt;/code&gt; 속성을 명시 적으로 변경하면로드 순서에 영향을 줄 수 있습니다 . &lt;code&gt;LoadOrder&lt;/code&gt; 는 기본적 으로 모든 테이블에 대해 &lt;code&gt;0&lt;/code&gt; 이지만 임의의 정수로 설정할 수 있습니다. &lt;code&gt;load_order&lt;/code&gt; 가 가장 높은 테이블이 먼저로드됩니다. 로드 순서 변경은 기본 테이블의 초기 가용성을 보장해야하는 응용 프로그램에 특히 유용합니다. 큰 주변 장치 테이블의로드 순서 값은 &lt;code&gt;0&lt;/code&gt; 보다 낮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="69de3dae19f69610dd34e83bd997df060a7428e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Arguments&lt;/code&gt; are provided, we apply it and do the same with the result as if the data was provided directly.</source>
          <target state="translated">때 &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; , 및 &lt;code&gt;Arguments&lt;/code&gt; 제공하는 데이터를 직접 제공 것처럼, 우리는 결과와 동일하게 적용하고 않습니다.</target>
        </trans-unit>
        <trans-unit id="c52ee13a4dcb299f5a385cfe15fc42403a860bc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; calls a traced function. The return values of calls are never supplied, only the call and its arguments.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 추적 된 함수를 호출 할 때 호출의 반환 값은 제공되지 않으며 호출 및 해당 인수 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="323d59db6fafd89e5c07401fb7993540b99d690e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits &lt;strong&gt;from&lt;/strong&gt; the specified function because of an exception. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with an &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 종료 &lt;strong&gt;에서&lt;/strong&gt; 지정된 기능 때문에 예외. 이 추적 메시지는 플래그 &lt;code&gt;call&lt;/code&gt; 이 설정되고 함수가 &lt;code&gt;exception_trace&lt;/code&gt; 조치 와 일치 스펙을 갖는 경우에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc3d1426688af7f3815ab8ffb8557afa8cf69def" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits with reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 이유와 종료 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a10c0e2595bc6a45b793e623dbb1d7e74c4840d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 예정되어 있을 때 . 프로세스가 {M, F, Arity} 기능에서 실행 중입니다. 드문 경우지만 현재 기능을 확인할 수없는 경우 마지막 요소는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="885b32e12e9f0ba67537b4a0349bf3e528dd7008" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled to run. The process runs in function &lt;code&gt;{M, F, Arity}&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 실행 예정이다. 프로세스는 &lt;code&gt;{M, F, Arity}&lt;/code&gt; 함수에서 실행됩니다 . 드문 경우지만 현재 기능을 확인할 수없는 경우 마지막 요소는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2579456f2ac4547aa51c7500a5011980e64fed27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is spawned by process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">지정된 함수 호출을 진입 점으로 하여 프로세스 &lt;code&gt;Pid2&lt;/code&gt; 에 의해 &lt;code&gt;Pid&lt;/code&gt; 가 생성 될 때 .</target>
        </trans-unit>
        <trans-unit id="ee6d840360c675d28fb4189ea75bcf500ea96744" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; links to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 프로세스에 대한 링크 &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0d2e5fb513b27fbae59d57a8659f003a4ecf83" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; opens a new port &lt;code&gt;Port&lt;/code&gt; with the running &lt;code&gt;Driver&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 새 포트 열립니다 &lt;code&gt;Port&lt;/code&gt; 실행중인와 &lt;code&gt;Driver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ed889ebc9aca15515c2b45ca1a374fd67cf415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; removes the link from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 프로세스 &lt;code&gt;Pid2&lt;/code&gt; 에서 링크를 제거 할 때 .</target>
        </trans-unit>
        <trans-unit id="5751eed2112a0c8b568fa52ffcbeb3e9cb0f2b8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;from&lt;/strong&gt; the specified function. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with a &lt;code&gt;return_trace&lt;/code&gt; or &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 지정된 함수 &lt;strong&gt;에서&lt;/strong&gt; 돌아올 때 . 이 추적 메시지는 플래그 &lt;code&gt;call&lt;/code&gt; 이 설정되고 함수가 &lt;code&gt;return_trace&lt;/code&gt; 또는 &lt;code&gt;exception_trace&lt;/code&gt; 조치 와 일치 스펙을 갖는 경우에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcbfdb05819ccf5c6584d296609a8e52d12c64f1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;to&lt;/strong&gt; the specified function. This trace message is sent if both the flags &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; are set, and the function is set to be traced on &lt;strong&gt;local&lt;/strong&gt; function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a &lt;code&gt;call&lt;/code&gt; trace message (that is, the functions match specification matched, and &lt;code&gt;{message, false}&lt;/code&gt; was not an action).</source>
          <target state="translated">때 &lt;code&gt;Pid&lt;/code&gt; 반환 &lt;strong&gt;에&lt;/strong&gt; 지정된 기능. 이 추적 메시지는 플래그 &lt;code&gt;call&lt;/code&gt; 과 &lt;code&gt;return_to&lt;/code&gt; 가 모두 설정되고 함수가 &lt;strong&gt;로컬&lt;/strong&gt; 함수 호출 에서 추적되도록 설정 되면 전송됩니다 . 메시지는 꼬리 재귀 함수 호출 체인에서 리턴 될 때만 전송됩니다. 여기서 최소한 하나의 호출이 &lt;code&gt;call&lt;/code&gt; 추적 메시지를 생성했습니다 (즉, 함수가 스펙이 일치하고 &lt;code&gt;{message, false}&lt;/code&gt; 가 조치가 아닙니다).</target>
        </trans-unit>
        <trans-unit id="ba46a646e37ed8b7d35c674ed3b3e32924ba03e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; spawns a new process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 가 지정된 함수 호출을 진입 점으로 하여 새로운 프로세스 &lt;code&gt;Pid2&lt;/code&gt; 를 생성 할 때 .</target>
        </trans-unit>
        <trans-unit id="5cc371b2356f9951c5abbb937169272313d56c71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets linked to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;PidPort&lt;/code&gt; 는 프로세스에 연결됩니다 &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972a925137e0ccb08bc5aeffdfecb3782e3bc889" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; registered.</source>
          <target state="translated">&lt;code&gt;PidPort&lt;/code&gt; 가 등록 된 이름 &lt;code&gt;RegName&lt;/code&gt; 을 가져올 때 .</target>
        </trans-unit>
        <trans-unit id="162e33555c86a661514ef9d4a857ec534b5a22a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; unregistered. This is done automatically when a registered process or port exits.</source>
          <target state="translated">때 &lt;code&gt;PidPort&lt;/code&gt; 가 도착 이름 &lt;code&gt;RegName&lt;/code&gt; 은 등록 해제. 등록 된 프로세스 또는 포트가 종료되면 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="feb1d708bf63c2940ea863c472a540929d8d0a03" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets unlinked from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PidPort&lt;/code&gt; 가 프로세스 &lt;code&gt;Pid2&lt;/code&gt; 에서 연결 해제 될 때 .</target>
        </trans-unit>
        <trans-unit id="96a6470e961b2d5912dd59eb5021ef79f690f562" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; receives message &lt;code&gt;Msg&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is set to time-out, a receive statement can have timed out, or the process received a message with the payload &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PidPort&lt;/code&gt; 가 메시지 &lt;code&gt;Msg&lt;/code&gt; 를 수신 할 때 . &lt;code&gt;Msg&lt;/code&gt; 가 시간 종료로 설정 되면 수신 명령문이 시간 종료되었거나 프로세스가 페이로드 &lt;code&gt;timeout&lt;/code&gt; 메시지를 수신했습니다 .</target>
        </trans-unit>
        <trans-unit id="e87cde17521c68e2a936fe17936bf5ceeb2c3d14" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;PidPort&lt;/code&gt; 가 메시지 전송 &lt;code&gt;Msg&lt;/code&gt; 처리하도록 &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61e6201a42785b41b69c2b7a25abb9b7fd4f07c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to the non-existing process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PidPort&lt;/code&gt; 가 존재하지 않는 프로세스 &lt;code&gt;To&lt;/code&gt; 에 메시지 &lt;code&gt;Msg&lt;/code&gt; 를 보낼 때 .</target>
        </trans-unit>
        <trans-unit id="15233790daaa8247a54c54b5c9b5074f4bf171a9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; closes with &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">시 &lt;code&gt;Port&lt;/code&gt; 와 종료 &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80787715e672faf25567796cfbe4be1ecff2d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled out. The last command run was &lt;code&gt;Command&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;Command&lt;/code&gt; can contain the same commands as &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;Port&lt;/code&gt; 밖으로 예정이다. 마지막 명령 실행은 &lt;code&gt;Command&lt;/code&gt; 입니다. 드문 경우지만 현재 기능을 확인할 수없는 경우 마지막 요소는 &lt;code&gt;0&lt;/code&gt; 입니다. &lt;code&gt;Command&lt;/code&gt; 과 같은 명령을 포함 할 수 &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9ef0bd2183c0bb797164fa66a45ee2bd8c3d2cf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled to run. &lt;code&gt;Command&lt;/code&gt; is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Port&lt;/code&gt; 실행 예정이다. &lt;code&gt;Command&lt;/code&gt; 은 포트가 가장 먼저 실행하지만 예약되기 전에 몇 가지 명령을 실행할 수 있습니다. 드문 경우지만 현재 기능을 확인할 수없는 경우 마지막 요소는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="763a821ae322d45ebff08f1076aa08fd98dc4152" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;accept&lt;/code&gt; is issued, the values of the listening socket options are inherited. No such application variable is therefore needed for &lt;code&gt;accept&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 가 발행 되면 청취 소켓 옵션의 값이 상속됩니다. 따라서 그러한 응용 변수는 &lt;code&gt;accept&lt;/code&gt; 에 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a84fa4a21d8059b923917b5063cf77ca5a084f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/2,3&lt;/code&gt; is used with wrap logs, the returned continuation might not be valid in the next call to &lt;code&gt;chunk()&lt;/code&gt;. This is because the log can wrap and delete the file into which the continuation points. To prevent this, the log can be blocked during the search.</source>
          <target state="translated">때 &lt;code&gt;chunk/2,3&lt;/code&gt; 랩 로그를 사용하는 경우, 반환 계속이에 대한 다음 호출에 유효하지 않을 &lt;code&gt;chunk()&lt;/code&gt; . 로그가 연속 지점이있는 파일을 랩핑하고 삭제할 수 있기 때문입니다. 이를 방지하기 위해 검색 중에 로그를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b575a5e86459930acb9d9587352f01c78bb4d138" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 64 kilobyte chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that the end of the file is reached.</source>
          <target state="translated">경우 &lt;code&gt;chunk/3&lt;/code&gt; 호출되고, &lt;code&gt;N&lt;/code&gt; 은 각 청크의 로그로부터 판독 된 용어의 최대 수를 제어한다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 로 , 64 킬로바이트 청크에 포함 된 모든 용어를 읽습니다. &lt;code&gt;N&lt;/code&gt; 개 미만의 용어가 반환되는 경우 반드시 파일 끝에 도달했음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea8aa73939a31b631da4d86b608b56e6f570baca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 8K chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that end of file is reached.</source>
          <target state="translated">경우 &lt;code&gt;chunk/3&lt;/code&gt; 호출되고, &lt;code&gt;N&lt;/code&gt; 은 각 청크의 로그로부터 판독 된 용어의 최대 수를 제어한다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 로 , 8K 청크에 포함 된 모든 용어를 읽습니다. &lt;code&gt;N&lt;/code&gt; 개 미만의 용어가 반환되는 경우 반드시 파일 끝에 도달했음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e99ff5779b67a6b782f749fc2ebb582cf983dde5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</source>
          <target state="translated">시 &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; 라고하며, 비동기 신호를 결합하려고 그들을 일으키는 온라인 모든 스케줄러로 전송 또는 바인딩 해제 요청한한다.</target>
        </trans-unit>
        <trans-unit id="0f7f20feb6d8e86e2be7182c1146591f5b2c10e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;float/1&lt;/code&gt; is used in an expression in a guard, such as '&lt;code&gt;float(A) == 4.0&lt;/code&gt;', it converts a number as described earlier.</source>
          <target state="translated">&lt;code&gt;float/1&lt;/code&gt; 이 ' &lt;code&gt;float(A) == 4.0&lt;/code&gt; ' 과 같은 가드의 표현식에 사용 되면 앞에서 설명한대로 숫자를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="71613609aa61c62cf20cbe58dfba008b2ab16c3a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;format_temps&lt;/code&gt; is called the first time, &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; and &lt;code&gt;Rest&lt;/code&gt; is the rest of the list. So the function &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; is called.</source>
          <target state="translated">때 &lt;code&gt;format_temps&lt;/code&gt; 이 처음이라고, &lt;code&gt;City&lt;/code&gt; 값 가져 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 하고 &lt;code&gt;Rest&lt;/code&gt; 목록의 나머지 부분입니다. 따라서 &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5bb83110e8f27a779d6f37f6cb1a70e2e21776a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;handle_connect/2,3&lt;/code&gt; is triggered by an explicit call to &lt;code&gt;megaco:connect/4,5&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;handle_connect/2,3&lt;/code&gt; 는 명시 적으로 호출에 의해 트리거됩니다 &lt;code&gt;megaco:connect/4,5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672bdd7739faf4a0068adc26b9d59100e10bc739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;httpd&lt;/code&gt; is shut down, it tries to execute &lt;code&gt;remove/1&lt;/code&gt; in each Erlang web server callback module. The programmer can use this function to clean up resources created in the store function.</source>
          <target state="translated">&lt;code&gt;httpd&lt;/code&gt; 가 종료 되면 각 Erlang 웹 서버 콜백 모듈에서 &lt;code&gt;remove/1&lt;/code&gt; 을 실행하려고 합니다. 프로그래머는이 기능을 사용하여 상점 기능에서 작성된 자원을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34c8eb52d34fbd9a9b37c654c599a9d1639ad3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;make install&lt;/code&gt; has finished, change directory into &lt;code&gt;$DESTDIR&lt;/code&gt;, package the system, move it to the target machine, and unpack it. Note that the installation will only be working on the target machine at the location determined by &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;make install&lt;/code&gt; 완료로 변경 디렉토리 &lt;code&gt;$DESTDIR&lt;/code&gt; , 시스템을 패키지 대상 컴퓨터로 이동하고 압축을 풉니 다. 설치는 &lt;code&gt;configure&lt;/code&gt; 에 의해 결정된 위치의 대상 시스템에서만 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="6458c29bc8527ea3593b744f1b95db5d14bc00a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;schema_location&lt;/code&gt; is set to &lt;code&gt;opt_disc&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; can be used to change the storage type of the schema. This is illustrated as follows:</source>
          <target state="translated">경우 &lt;code&gt;schema_location&lt;/code&gt; 가 설정되어 &lt;code&gt;opt_disc&lt;/code&gt; , 함수 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; 스키마의 저장 형식을 변경하는데 사용될 수있다. 이것은 다음과 같이 설명됩니다 :</target>
        </trans-unit>
        <trans-unit id="8f7039593357562dd4f3df83c986379cb1c6cf4e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sys:get_status/1,2&lt;/code&gt; is called, &lt;code&gt;gen_event&lt;/code&gt; ensures that its return value contains &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">때 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; ,라고 &lt;code&gt;gen_event&lt;/code&gt; 반환 값이 포함되도록 &lt;code&gt;Status&lt;/code&gt; 이벤트 핸들러의 상태 용어 대신에.</target>
        </trans-unit>
        <trans-unit id="5455489a72db154806b1402161102765e042f513" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_ack_maxcount&lt;/code&gt; number of ack's has been received.</source>
          <target state="translated">&lt;code&gt;trans_ack_maxcount&lt;/code&gt; 수의 ack가 수신 되었을 때 .</target>
        </trans-unit>
        <trans-unit id="2d6f023a935d787f78f929b26ccb79c057c7e544" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_req_maxcount&lt;/code&gt; number of requests's has been received.</source>
          <target state="translated">때 &lt;code&gt;trans_req_maxcount&lt;/code&gt; 요청의 수가 수신되었습니다.</target>
        </trans-unit>
        <trans-unit id="4691b74e02fcb2a43c31be2ce08725b89f8c00a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_timer&lt;/code&gt; expires.</source>
          <target state="translated">&lt;code&gt;trans_timer&lt;/code&gt; 가 만료 될 때</target>
        </trans-unit>
        <trans-unit id="9f62e8b515ecdd9f175ebeef24a151629f33f401" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, exit signals arriving to a process are converted to &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; messages, which can be received as ordinary messages. If &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the process exits if it receives an exit signal other than &lt;code&gt;normal&lt;/code&gt; and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</source>
          <target state="translated">&lt;code&gt;trap_exit&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 프로세스에 도달하는 종료 신호가 일반 메시지로 수신 할 수있는 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 메시지 로 변환됩니다 . 경우 &lt;code&gt;trap_exit&lt;/code&gt; 가 설정되어 &lt;code&gt;false&lt;/code&gt; , 처리 종료 그 이외의 종료 신호를 수신하면 &lt;code&gt;normal&lt;/code&gt; 및 종료 신호는 링크 된 프로세스로 전달된다. 애플리케이션 프로세스는 일반적으로 엑시트를 트랩하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb45a25cdcc4004483ae5e0296eb6055f647d85a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, sent multicast packets are looped back to the local sockets.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 멀티 캐스트 패킷이 로컬 소켓에 다시 반복된다 보냈다.</target>
        </trans-unit>
        <trans-unit id="10db437ea36ac965fd403789d69242cf01a29208" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;{active, true}&lt;/code&gt;, data is delivered on the form &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; or &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{active, true}&lt;/code&gt; , 데이터 형식에 전달 &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; 또는 &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50818e5b2ee1eb06b98eca2c46320af1c49650c8" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;ActualReason&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">때 &lt;strong&gt;이유가&lt;/strong&gt; 있다 &lt;strong&gt;{... send_failed}&lt;/strong&gt; 그것은 net_if 프로세스가 메시지를 보내지 못했습니다 것을 의미한다. 인코딩 오류와 같은 여러 가지 이유로 발생할 수 있습니다. &lt;strong&gt;ActualReason은이&lt;/strong&gt; 경우의 실제 이유입니다.</target>
        </trans-unit>
        <trans-unit id="9f41f432bb6d6b04eaeac809774055cb313c3684" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;R&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">때 &lt;strong&gt;이유가&lt;/strong&gt; 있다 &lt;strong&gt;{... send_failed}&lt;/strong&gt; 그것은 net_if 프로세스가 메시지를 보내지 못했습니다 것을 의미한다. 인코딩 오류와 같은 여러 가지 이유로 발생할 수 있습니다. 이 경우 &lt;strong&gt;R&lt;/strong&gt; 이 실제 이유입니다.</target>
        </trans-unit>
        <trans-unit id="f8aec189a88e9a30ca27fcd657c83b4b7d31fa73" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;var_and_val()&lt;/strong&gt; is &lt;strong&gt;{oid(), value()}&lt;/strong&gt;, the manager makes an educated guess based on the loaded mibs.</source>
          <target state="translated">경우 &lt;strong&gt;var_and_val가 ()&lt;/strong&gt; 이고 &lt;strong&gt;{OID () 값은 ()}&lt;/strong&gt; , 매니저는 로딩 된 MIB에 기초한 추측한다.</target>
        </trans-unit>
        <trans-unit id="ccaef80e646aaabd78d92b0630d31df5f39a479a" translate="yes" xml:space="preserve">
          <source>When Cover is stopped, all Cover compiled modules are unloaded.</source>
          <target state="translated">Cover가 중지되면 모든 Cover 컴파일 된 모듈이 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ce23e1563e5351f589159eb5b770cd3cbd2e8d8c" translate="yes" xml:space="preserve">
          <source>When Debugger is started in global mode (which is the default, see &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt;), modules added (or deleted) for interpretation are added (or deleted) on all known Erlang nodes.</source>
          <target state="translated">디버거가 전역 모드 (기본값 인 &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt; 참조 )에서 시작 되면 해석을 위해 추가 (또는 삭제) 된 모듈이 알려진 모든 Erlang 노드에서 추가 (또는 삭제)됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8c9662238adfc3364171ed2abae67b6db526e0" translate="yes" xml:space="preserve">
          <source>When EDNS is enabled (resolver option &lt;code&gt;edns&lt;/code&gt; is set to the EDNS version (that is, &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;false&lt;/code&gt;), resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; sets the limit. If a name server replies with the TC bit set (truncation), indicating that the answer is incomplete, the query is retried to that name server using TCP. Resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; also sets the advertised size for the maximum allowed reply size, if EDNS is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets truncated, forcing a TCP requery.</source>
          <target state="translated">EDNS가 활성화되면 (리졸버 옵션 &lt;code&gt;edns&lt;/code&gt; 가 EDNS 버전 ( &lt;code&gt;false&lt;/code&gt; 대신 &lt;code&gt;0&lt;/code&gt; )으로 설정 됨) 리졸버 옵션 &lt;code&gt;udp_payload_size&lt;/code&gt; 가 한계를 설정합니다. 이름 서버가 TC 비트 세트 (절단)로 응답하면 응답이 불완전한 경우 쿼리는 TCP를 사용하여 해당 이름 서버로 재 시도되며 해결 프로그램 옵션 &lt;code&gt;udp_payload_size&lt;/code&gt; 는 EDNS가 사용 가능한 경우 허용되는 최대 응답 크기에 대해 알려진 크기를 설정합니다. 그렇지 않으면 이름 서버가 512 바이트 제한을 사용합니다. TCP 재 질의를 강제 실행하여 잘립니다.</target>
        </trans-unit>
        <trans-unit id="360f7568d87827777af3aa56a826957938118e43" translate="yes" xml:space="preserve">
          <source>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</source>
          <target state="translated">테스트를 실행하기 위해 EUnit이 테스트 표현을 통과하는 경우 새 생성기는 이전 테스트가 실행될 때까지 다음 테스트를 생성하도록 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f08e2448799430bb11532279edecae41a087b4a7" translate="yes" xml:space="preserve">
          <source>When Erlang is started with &lt;code&gt;-oldshell&lt;/code&gt; or &lt;code&gt;-noshell&lt;/code&gt;, the I/O server for &lt;code&gt;standard_io&lt;/code&gt; is by default set to bytewise encoding, while an interactive shell defaults to what the environment variables says.</source>
          <target state="translated">얼랑가 시작되면 &lt;code&gt;-oldshell&lt;/code&gt; 또는 &lt;code&gt;-noshell&lt;/code&gt; 에 대한 I / O 서버 &lt;code&gt;standard_io&lt;/code&gt; 는 대화 형 쉘 디폴트 동안 환경 변수의 말씀에, 바이트 단위의 인코딩 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="e501fa18494f297571df6ce7eaf406fc86c93dea" translate="yes" xml:space="preserve">
          <source>When Erlang starts up it reads the Kernel variable &lt;code&gt;inetrc&lt;/code&gt;, which, if defined, is to specify the location and name of a user configuration file. Example:</source>
          <target state="translated">Erlang이 시작되면 Kernel 변수 &lt;code&gt;inetrc&lt;/code&gt; 를 읽습니다. 정의 된 경우 사용자 구성 파일의 위치와 이름을 지정합니다. 예:</target>
        </trans-unit>
        <trans-unit id="128caf28b58716150fb0bb58c207dbe8dd83fd4e" translate="yes" xml:space="preserve">
          <source>When Erlang was designed, it was assumed that the wall clock time in the system showed a monotonic time moving forward at exactly the same pace as the definition of time. This more or less meant that an atomic clock (or better time source) was expected to be attached to your hardware and that the hardware was then expected to be locked away from any human tinkering forever. While this can be a compelling thought, it is simply never the case.</source>
          <target state="translated">Erlang이 설계되었을 때, 시스템의 벽시계 시간은 시간의 정의와 정확히 같은 속도로 진행하는 단조로운 시간을 보여 주었다고 가정했습니다. 이것은 다소 원자 시계 (또는 더 나은 시간 소스)가 하드웨어에 부착되어 하드웨어가 인간의 땜장이로부터 영원히 잠기 게 될 것을 의미했습니다. 이것은 설득력있는 생각이 될 수 있지만, 결코 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50fa1c320969db01352828d7fe383abc4a1895e0" translate="yes" xml:space="preserve">
          <source>When Erlang/OTP is started, the system searches for a file named &lt;code&gt;.erlang&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">Erlang / OTP가 시작되면 시스템 은 사용자의 홈 디렉토리에서 &lt;code&gt;.erlang&lt;/code&gt; 이라는 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="f3f71d6c7e7a2c0c5ada3244d6eb663b401f9b01" translate="yes" xml:space="preserve">
          <source>When PER is used, there is a significant difference in the encoding scheme between &lt;code&gt;OCTET STRING&lt;/code&gt;s and other strings. The constraints specified for a type are especially important for PER, where they affect the encoding.</source>
          <target state="translated">PER을 사용하면 &lt;code&gt;OCTET STRING&lt;/code&gt; 과 다른 문자열 간에 인코딩 체계에 큰 차이가 있습니다. 유형에 지정된 제약은 인코딩에 영향을주는 PER에 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1b03f5d92803d36900a526928289b233412ad464" translate="yes" xml:space="preserve">
          <source>When SSL/TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="translated">SSL / TLS가 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; 에 따라 인증서 경로 유효성 검사를 수행 할 때 CRL 유효성 검사도 수행해야합니다. CRL 검사를 활성화하려면 응용 프로그램이 CRL에 액세스해야합니다. CRL 데이터베이스는 여러 가지 방법으로 설정할 수 있습니다. 이 모듈은 임의의 CRL 캐시를 erlang ssl 애플리케이션과 통합하는 데 필요한 API의 동작을 제공합니다. 또한 응용 프로그램 자체에서 CRL 캐시의 간단한 기본 구현을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d27327d683c2a19be0af9413a3ffb06c50231cc3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Addr&lt;/code&gt; is not specified i.e by using only a &lt;code&gt;Domain&lt;/code&gt; atom, the host's name is resolved to find the IP address, and the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">때 &lt;code&gt;Addr&lt;/code&gt; 만 사용하여 즉 지정되지 않은 &lt;code&gt;Domain&lt;/code&gt; 원자를, 호스트의 이름은 IP 주소를 찾아 해결하고,의 값 &lt;code&gt;port&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2dab5adc2b60fbe4714b50e24055b1753a3e2460" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CHOICE&lt;/code&gt; contains an extension marker and the decoder detects an unknown alternative of the &lt;code&gt;CHOICE&lt;/code&gt;, the value is represented as follows:</source>
          <target state="translated">때 &lt;code&gt;CHOICE&lt;/code&gt; 확장 표시자를 포함하고, 상기 디코더는 미지의 대안 검출 &lt;code&gt;CHOICE&lt;/code&gt; 를 다음과 같은 값을 나타낸다 :</target>
        </trans-unit>
        <trans-unit id="8d1d4d39dc5b42bbde592ff2e91a12f51026609b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SEQUENCE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt; contains an extension marker and extension components as the following, the type can get more components in newer versions of the ASN.1 spec:</source>
          <target state="translated">때 &lt;code&gt;SEQUENCE&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 는 다음과 같은 확장 마커 및 확장 구성 요소가 포함되어 있습니다, 종류는 ASN.1 사양의 최신 버전에 더 많은 구성 요소를 얻을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6259eac0d0652866c8be2d5774deb52d326c9816" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered, a &lt;code&gt;'DOWN'&lt;/code&gt; message is sent that has the following pattern:</source>
          <target state="translated">때 &lt;code&gt;process&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 모니터가 트리거하는 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지는 다음과 같은 패턴이이 전송됩니다</target>
        </trans-unit>
        <trans-unit id="dabb982d5bde66066a06ee6a787d40663b30219a" translate="yes" xml:space="preserve">
          <source>When a NETCONF server receives a &lt;code&gt;close-session&lt;/code&gt; request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a &lt;code&gt;close-session&lt;/code&gt; request are ignored.</source>
          <target state="translated">NETCONF 서버는 &lt;code&gt;close-session&lt;/code&gt; 요청을 받으면 정상적으로 세션을 닫습니다. 서버는 세션과 관련된 잠금 및 리소스를 해제하고 연결된 모든 연결을 정상적으로 닫습니다. &lt;code&gt;close-session&lt;/code&gt; 요청 후 수신 된 모든 NETCONF 요청 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6aef919ab5c9d7ca0a1f781798e898aede6e2d15" translate="yes" xml:space="preserve">
          <source>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. &lt;code&gt;erl_nif.h&lt;/code&gt; defines the following:</source>
          <target state="translated">NIF 라이브러리가 빌드되면 NIF API 버전에 대한 정보가 라이브러리로 컴파일됩니다. NIF 라이브러리가로드되면 런타임 시스템은 라이브러리가 호환 가능한 버전인지 확인합니다. &lt;code&gt;erl_nif.h&lt;/code&gt; 는 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="618a279b6e67c1feb5bfb9caf244cc07fcd0fd4b" translate="yes" xml:space="preserve">
          <source>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after</source>
          <target state="translated">캡처 하위 패턴이 반복되면 캡처 된 값은 최종 반복과 일치하는 하위 문자열입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a65b284abe74e6a02c174667276a95aa7be67345" translate="yes" xml:space="preserve">
          <source>When a client checks a server certificate there are a number of checks available like checks that the certificate is not revoked, not forged or not out-of-date.</source>
          <target state="translated">클라이언트가 서버 인증서를 확인할 때 인증서가 해지되지 않았는지, 위조되지 않았는지 또는 오래된 것이 아닌지 확인하는 것과 같이 여러 가지 확인이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3aadc5d6a9fff7e5e64260bfe5a84b55671b941b" translate="yes" xml:space="preserve">
          <source>When a combining transaction writes with &quot;dirty_reads&quot;, that is, the functions &lt;code&gt;dirty_match_object&lt;/code&gt;, &lt;code&gt;dirty_read&lt;/code&gt;, &lt;code&gt;dirty_index_read&lt;/code&gt;, &lt;code&gt;dirty_select&lt;/code&gt;, and so on.</source>
          <target state="translated">결합 트랜잭션이 &quot;dirty_reads&quot;로 쓸 때, 즉 &lt;code&gt;dirty_match_object&lt;/code&gt; , &lt;code&gt;dirty_read&lt;/code&gt; , &lt;code&gt;dirty_index_read&lt;/code&gt; , &lt;code&gt;dirty_select&lt;/code&gt; 등 의 함수가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2b39b4ebe51a72b88123d3bad51bb926bc1540" translate="yes" xml:space="preserve">
          <source>When a complete sequence of valid events has been received, the result is returned as a list of letters.</source>
          <target state="translated">유효한 일련의 유효한 이벤트가 수신되면 결과는 문자 목록으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab3080f29934aab21a3904dcbbbf54ca9667260" translate="yes" xml:space="preserve">
          <source>When a configuration function fails (that is, terminates unexpectedly), the test cases depending on the configuration function are skipped automatically by &lt;code&gt;Common Test&lt;/code&gt;. The status of the test cases is then &quot;auto-skipped&quot;. Test cases are also &quot;auto-skipped&quot; by &lt;code&gt;Common Test&lt;/code&gt; if the required configuration data is unavailable at runtime.</source>
          <target state="translated">구성 기능이 실패하면 (즉, 예기치 않게 종료 됨) 구성 기능에 따른 테스트 사례는 &lt;code&gt;Common Test&lt;/code&gt; 에서 자동으로 건너 뜁니다 . 테스트 사례의 상태는 &quot;자동 건너 뛰기&quot;입니다. 런타임에 필요한 구성 데이터를 사용할 수없는 경우 &lt;code&gt;Common Test&lt;/code&gt; 테스트 사례를 &quot;자동 스킵&quot; 합니다.</target>
        </trans-unit>
        <trans-unit id="a5b5a638207ad9c6b58bc05153489fdb31694f0d" translate="yes" xml:space="preserve">
          <source>When a configuration variable name is used as reference to the data specifying the connection, the handle returned as a result of opening the connection must be used in all subsequent calls (also for closing the connection). Repeated calls to the open function with the same variable name as reference results in multiple connections being opened. This can be useful, for example, if a test case needs to open multiple connections to the same server on the target node (using the same configuration data for each connection).</source>
          <target state="translated">연결을 지정하는 데이터에 대한 참조로 구성 변수 이름을 사용하는 경우 연결을 연 결과로 리턴 된 핸들은 모든 후속 호출에서 사용되어야합니다 (연결을 닫는 경우에도). 참조와 동일한 변수 이름으로 open 함수를 반복해서 호출하면 여러 연결이 열립니다. 예를 들어, 테스트 사례가 대상 노드의 동일한 서버에 대한 여러 연결을 열어야하는 경우 (각 연결에 대해 동일한 구성 데이터 사용) 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40f1ad1022ce7c7ff4a72defc83b1ece3312d0f" translate="yes" xml:space="preserve">
          <source>When a correct code has been given, the door is unlocked and the following tuple is returned from &lt;code&gt;locked/2&lt;/code&gt;:</source>
          <target state="translated">올바른 코드가 제공되면 도어가 잠금 해제되고 다음 튜플이 &lt;code&gt;locked/2&lt;/code&gt; 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c237674f28de05213f857e3fa04838ee21db142" translate="yes" xml:space="preserve">
          <source>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</source>
          <target state="translated">디렉토리가 코드 경로에 추가되고 전체 코드 경로가 다시 설정되면 코드 서버는 응용 프로그램에서 아카이브에서 읽을 서브 디렉토리와 일반 파일로 읽을 서브 디렉토리를 결정합니다. 나중에 디렉토리를 추가하거나 제거하면 코드 경로가 업데이트되지 않은 경우 (이전과 동일한 경로로 디렉토리 해석 업데이트를 트리거 할 경우) 파일 액세스가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08512ee349a9c8aac50037692c41425ea5af4861" translate="yes" xml:space="preserve">
          <source>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none, a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items starts from there. If the format is &lt;code&gt;internal&lt;/code&gt; and the existing file is not recognized as an internally formatted log, a tuple &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; is returned.</source>
          <target state="translated">디스크 로그가 읽기 / 쓰기 모드로 열리면 기존의 모든 로그 파일이 검사됩니다. 비어있는 새 로그가 없으면 마지막으로 기록 된 항목 다음 위치에서 기존 파일이 열리고 여기에서 항목 로깅이 시작됩니다. 형식이 &lt;code&gt;internal&lt;/code&gt; 파일이고 기존 파일이 내부 형식의 로그로 인식되지 않으면 튜플 &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dd89c709c241e9c3808c6d9ef3bbf0c663231656" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_RESP&lt;/code&gt;.</source>
          <target state="translated">분산 노드가 시작되면 EPMD에 자체 등록됩니다. 아래 설명 된 &lt;code&gt;ALIVE2_REQ&lt;/code&gt; 메시지 는 노드에서 EPMD로 전송됩니다. EPMD의 응답은 &lt;code&gt;ALIVE2_RESP&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a52fed0cfcde5066a985fe2bdb039481aa8004a" translate="yes" xml:space="preserve">
          <source>When a driver creates a monitor for a process, a &lt;code&gt;ErlDrvMonitor&lt;/code&gt; is filled in. This is an opaque data type that can be assigned to, but not compared without using the supplied compare function (that is, it behaves like a struct).</source>
          <target state="translated">드라이버가 프로세스에 대한 모니터를 작성할 때 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 가 채워집니다. 이것은 제공된 비교 함수를 사용하지 않고 지정 될 수 있지만 비교할 수없는 불투명 한 데이터 유형입니다 (즉, 구조체처럼 동작 함).</target>
        </trans-unit>
        <trans-unit id="7d91cc2fa6325a0dec9adb1ac103e1c55c09f52b" translate="yes" xml:space="preserve">
          <source>When a driver is loaded it is executed in the context of the emulator, shares the same memory and the same thread. This means that all operations in the driver must be non-blocking, and that any crash in the driver brings the whole emulator down. In short, be careful.</source>
          <target state="translated">드라이버가로드되면 에뮬레이터의 컨텍스트에서 실행되고 동일한 메모리와 동일한 스레드를 공유합니다. 즉, 드라이버의 모든 작업이 차단되지 않아야하며 드라이버의 충돌로 인해 전체 에뮬레이터가 중단됩니다. 한마디로 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="23ef058276dd33859a9cf8494fcadec228e0e9ee" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for input. This callback is called when the emulator detects input on a file descriptor that the driver has marked for monitoring by using the interface &lt;code&gt;driver_select&lt;/code&gt;. The mechanism of driver select makes it possible to read non-blocking from file descriptors by calling &lt;code&gt;driver_select&lt;/code&gt; when reading is needed, and then do the reading in this callback (when reading is possible). The typical scenario is that &lt;code&gt;driver_select&lt;/code&gt; is called when an Erlang process orders a read operation, and that this routine sends the answer when data is available on the file descriptor.</source>
          <target state="translated">파일 디스크립터가 입력을 위해 신호를받을 때. 이 콜백은 드라이버가 &lt;code&gt;driver_select&lt;/code&gt; 인터페이스를 사용하여 드라이버가 모니터링하도록 표시 한 파일 디스크립터에서 입력을 감지 할 때 호출됩니다 . 드라이버 선택 메커니즘을 통해 읽기가 필요할 때 &lt;code&gt;driver_select&lt;/code&gt; 를 호출하여 파일 디스크립터에서 비 블로킹을 읽은 다음이 콜백에서 읽기를 수행 할 수 있습니다 (읽기가 가능한 경우). 일반적인 시나리오는 Erlang 프로세스가 읽기 작업을 지시 할 때 &lt;code&gt;driver_select&lt;/code&gt; 가 호출되고 파일 루틴에서 데이터를 사용할 수있을 때이 루틴이 응답을 보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a679df0f77926839147106039935be1d682ca28a" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for output. This callback is called in a similar way as the previous, but when writing to a file descriptor is possible. The usual scenario is that Erlang orders writing on a file descriptor and that the driver calls &lt;code&gt;driver_select&lt;/code&gt;. When the descriptor is ready for output, this callback is called and the driver can try to send the output. Queuing can be involved in such operations, and there are convenient queue routines available to the driver writer to use.</source>
          <target state="translated">파일 디스크립터가 출력 신호를받을 때. 이 콜백은 이전과 비슷한 방식으로 호출되지만 파일 디스크립터에 쓸 수 있습니다. 일반적인 시나리오는 Erlang이 파일 디스크립터에 쓰기를 주문하고 드라이버가 &lt;code&gt;driver_select&lt;/code&gt; 를 호출하는 것 입니다. 디스크립터가 출력 준비가되면이 콜백이 호출되고 드라이버는 출력을 보내려고 시도 할 수 있습니다. 큐는 이러한 작업에 관여 할 수 있으며 드라이버 작성기에서 사용할 수있는 편리한 큐 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cff5a25a671ee65d3e016e0e72ebcef87ec1e190" translate="yes" xml:space="preserve">
          <source>When a file is saved the name in the &lt;code&gt;-module().&lt;/code&gt; line is checked against the file name. Should they mismatch Emacs can change the module specifier so that it matches the file name. By default, the user is asked before the change is performed.</source>
          <target state="translated">파일이 저장되면 &lt;code&gt;-module().&lt;/code&gt; 이름이 저장 됩니다. 파일 이름과 비교하여 행을 검사합니다. 일치하지 않는 경우 Emacs는 파일 이름과 일치하도록 모듈 지정자를 변경할 수 있습니다. 기본적으로 변경을 수행하기 전에 사용자에게 요청합니다.</target>
        </trans-unit>
        <trans-unit id="3f363e70739be22c64648901764e5ee5e3346b81" translate="yes" xml:space="preserve">
          <source>When a filter includes the &lt;code&gt;no&lt;/code&gt; atom, it excludes the reports that match that filter.</source>
          <target state="translated">필터에 원자 &lt;code&gt;no&lt;/code&gt; 포함 된 경우 해당 필터와 일치하는 보고서가 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="11b080dca26694157c4bd883a5fe6d59a076fa4f" translate="yes" xml:space="preserve">
          <source>When a function &lt;code&gt;m:f/N&lt;/code&gt; is called, first the code for the function is located. If the function cannot be found, an &lt;code&gt;undef&lt;/code&gt; runtime error occurs. Notice that the function must be exported to be visible outside the module it is defined in.</source>
          <target state="translated">&lt;code&gt;m:f/N&lt;/code&gt; 함수 가 호출되면 먼저 함수의 코드가 있습니다. 함수를 찾을 수 없으면 &lt;code&gt;undef&lt;/code&gt; 런타임 오류가 발생합니다. 정의 된 모듈 외부에서 볼 수 있도록 함수를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="74208e09de14be7d14103a45ed652bc9fc053707" translate="yes" xml:space="preserve">
          <source>When a function defined elsewhere is used as a fun, it can be referred to as &lt;code&gt;Function/Arity&lt;/code&gt; (remember that &lt;code&gt;Arity&lt;/code&gt; = number of arguments). So in the &lt;code&gt;map&lt;/code&gt;-call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; is written. As shown, &lt;code&gt;convert_list_to_c&lt;/code&gt; becomes much shorter and easier to understand.</source>
          <target state="translated">다른 곳에서 정의 된 함수가 재미로 사용되는 경우, &lt;code&gt;Function/Arity&lt;/code&gt; 라고 할 수 있습니다 ( &lt;code&gt;Arity&lt;/code&gt; = 인수 수를 기억하십시오 ). 따라서 &lt;code&gt;map&lt;/code&gt; - call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; 가 작성됩니다. 도시 된 바와 같이, &lt;code&gt;convert_list_to_c&lt;/code&gt; 는 훨씬 짧아지고 이해하기 쉽다.</target>
        </trans-unit>
        <trans-unit id="74001e8b9e330c78c97c92b41f6d0fc8532d215e" translate="yes" xml:space="preserve">
          <source>When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option &lt;code&gt;export_all&lt;/code&gt; was given) or if not all calls to the function are inlined.</source>
          <target state="translated">함수가 인라인 될 때 ​​원래 함수는 익스포트 된 경우 (명시 적 익스포트 또는 &lt;code&gt;export_all&lt;/code&gt; 옵션 이 제공된 경우) 또는 함수에 대한 모든 호출이 인라인되지 않은 경우 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f80601e5580fc09c93533fc9ff760c5048491df1" translate="yes" xml:space="preserve">
          <source>When a functional module has been changed, for example, if a new function has been added or a bug has been corrected, simple code replacement is sufficient, for example:</source>
          <target state="translated">기능 모듈이 변경된 경우 (예 : 새 기능이 추가되었거나 버그가 수정 된 경우) 간단한 코드 교체로 충분합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="177c42f544b61e4f56d8eebb388d0ad5082dd374" translate="yes" xml:space="preserve">
          <source>When a grammar rule is used by the parser to parse (part of) the input string as a grammatical phrase, the associated code is evaluated, and the value of the last expression becomes the value of the parsed phrase. This value may be used by the parser later to build structures that are values of higher phrases of which the current phrase is a part. The values initially associated with terminal category phrases, i.e. input tokens, are the token tuples themselves.</source>
          <target state="translated">구문 분석기가 입력 문자열을 문법 구문으로 구문 분석하기 위해 문법 규칙을 사용하는 경우 연관된 코드가 평가되고 마지막 표현식의 값이 구문 분석 된 구문의 값이됩니다. 이 값은 나중에 구문 분석기에서 현재 구문이 일부인 상위 구문의 값인 구조를 빌드하는 데 사용할 수 있습니다. 터미널 범주 문구, 즉 입력 토큰과 처음 연결된 값은 토큰 튜플 자체입니다.</target>
        </trans-unit>
        <trans-unit id="b974112391a6bf5f0b5186bac330512807e3d96c" translate="yes" xml:space="preserve">
          <source>When a group of subtrees (as e.g., the argument list of an &lt;code&gt;application&lt;/code&gt; node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by &lt;code&gt;Node&lt;/code&gt; even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if &lt;code&gt;Tree&lt;/code&gt; represents a list of integers &quot;&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;&quot;, the result of &lt;code&gt;limit(Tree, 5)&lt;/code&gt; will represent &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt;.</source>
          <target state="translated">서브 트리 그룹 (예 : &lt;code&gt;application&lt;/code&gt; 노드 의 인수 목록 )이 지정된 깊이에 있고 그룹에 둘 이상의 서브 트리가있는 경우 리프 노드 인 경우에도 &lt;code&gt;Node&lt;/code&gt; 로 대체됩니다 . 지정된 깊이보다 위에있는 하위 트리 그룹은 그룹의 각 후속 트리가 이전보다 한 수준 깊게있는 것처럼 크기가 제한됩니다. 예를 들어 &lt;code&gt;Tree&lt;/code&gt; 가 정수 목록 &lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt; &quot;을 나타내는 경우 &lt;code&gt;limit(Tree, 5)&lt;/code&gt; 의 결과 는 &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt; 나타냅니다 . , 4, ...] .</target>
        </trans-unit>
        <trans-unit id="546a7cd5ad3598834756b341e22241b28b75ab4c" translate="yes" xml:space="preserve">
          <source>When a halt log has reached its maximum size, all attempts to log more items are rejected. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which for halt implies that there is no maximum size.</source>
          <target state="translated">정지 로그가 최대 크기에 도달하면 더 많은 항목을 기록하려는 모든 시도가 거부됩니다. 기본적으로 &lt;code&gt;infinity&lt;/code&gt; 로 설정 하면 정지시 최대 크기가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0173ad86ffa8dc5a72f7880331dbb41cadacb3d5" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="translated">핸들러가 추가되면 (예 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt; 호출 ) 로거는 먼저 &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt; 호출합니다 . 이 함수가 &lt;code&gt;{ok,Config1}&lt;/code&gt; 을 리턴 하면 로거는 &lt;code&gt;Config1&lt;/code&gt; 을 구성 데이터베이스에 &lt;code&gt;logger:add_handler/3&lt;/code&gt; 하고 logger : add_handler / 3 호출이 리턴합니다. 그런 다음 핸들러가 설치되고 &lt;code&gt;HModule:log/2&lt;/code&gt; 에 대한 호출로 로그 이벤트를 수신 할 준비가되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b3fa26b8c4473c5e6353f135f20edbe40b9dc4c" translate="yes" xml:space="preserve">
          <source>When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.</source>
          <target state="translated">줄 끝이 단일 문자로 정의되면 dot은 해당 문자와 ​​일치하지 않습니다. 두 문자 시퀀스 CRLF를 사용하는 경우 LF 바로 뒤에 닷이 오는 경우 도트는 CR과 일치하지 않습니다. 유니 코드 줄 끝이 인식되면 dot은 CR, LF 또는 다른 줄 끝 문자와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c40d296ef828ecaf94ab88122caa6be54ba75b8f" translate="yes" xml:space="preserve">
          <source>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; is specified as &lt;code&gt;Pattern&lt;/code&gt;, this means either &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</source>
          <target state="translated">이진 목록이 지정되면 검색 할 대체 이진 집합을 나타냅니다. 예를 들어 &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; 이 &lt;code&gt;Pattern&lt;/code&gt; 으로 지정된 경우 &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt; &quot;을 의미합니다. 패턴은 대체 세트; 단일 바이너리 만 지정된 경우 세트에는 하나의 요소 만 있습니다 패턴의 대체 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e35511e71a7b0fd611ce8579dd128d7b017ba30" translate="yes" xml:space="preserve">
          <source>When a log file is opened (for appending or created), a time stamp is written to the file. If nothing has been written to the log files for 15 minutes, a record is inserted that says that we are still alive.</source>
          <target state="translated">추가 또는 생성을 위해 로그 파일이 열리면 타임 스탬프가 파일에 기록됩니다. 15 분 동안 로그 파일에 아무것도 기록되지 않은 경우 아직 살아 있다는 레코드가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="06e4937e775c2f940892fdab2739edda1362aa4d" translate="yes" xml:space="preserve">
          <source>When a log macro is used, Logger also inserts location information:</source>
          <target state="translated">로그 매크로가 사용되면 로거는 위치 정보도 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="aad0f82e057ba4854abcfc52c2eb835c19bd6591" translate="yes" xml:space="preserve">
          <source>When a managed object is referenced in an SNMP operation, the associated &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user.</source>
          <target state="translated">관리 대상 객체가 SNMP 작업에서 참조되면 관련 &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; 가 호출됩니다. 이 함수는 일부 표준 인수 (예 : 작업 유형) 및 사용자가 제공 한 추가 인수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bea9285e0f879b126068ba7917e2a2ade25429d" translate="yes" xml:space="preserve">
          <source>When a manager makes a request to the agent, the following illustrates the situation:</source>
          <target state="translated">관리자가 상담원에게 요청하면 다음 상황이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="092784e3d7c652eb428c18ea5b4a28b1c8500ff7" translate="yes" xml:space="preserve">
          <source>When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for &lt;code&gt;pcre_exec()&lt;/code&gt;&quot; in the &lt;code&gt;pcreapi&lt;/code&gt; documentation. In the following example of &lt;code&gt;pcretest&lt;/code&gt; output, the /K modifier requests the retrieval and outputting of (*MARK) data:</source>
          <target state="translated">일치하는 경우 일치하는 경로에서 마지막으로 발생한 (* MARK : NAME), (* PRUNE : NAME) 또는 (* THEN : NAME) 이름은 &quot;추가 데이터&quot;섹션에 설명 된대로 호출자에게 다시 전달됩니다. &lt;code&gt;pcre_exec()&lt;/code&gt; &quot;를에 &lt;code&gt;pcreapi&lt;/code&gt; 의 설명서를 참조하십시오. 다음 &lt;code&gt;pcretest&lt;/code&gt; 출력 예 에서 / K 수정자는 (* MARK) 데이터의 검색 및 출력을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="b9ff74687968e879951bb5da792862457fd61b73" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message &lt;code&gt;emsg.msg&lt;/code&gt; and &lt;code&gt;emsg.to&lt;/code&gt; or &lt;code&gt;emsg.from&lt;/code&gt;, depending on the type of message received.</source>
          <target state="translated">메시지가 수신되면 수신 된 메시지 유형에 따라 수신 된 메시지 &lt;code&gt;emsg.msg&lt;/code&gt; 및 &lt;code&gt;emsg.to&lt;/code&gt; 또는 &lt;code&gt;emsg.from&lt;/code&gt; 을 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="4ed264eb2a6ed34dada4086d909002ae020169ab" translate="yes" xml:space="preserve">
          <source>When a message is received</source>
          <target state="translated">메시지가 수신 된 경우</target>
        </trans-unit>
        <trans-unit id="8503be402b4e5542f8b3e1bb21c05d662a4228ff" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process on another Erlang node, it is first encoded to the Erlang External Format before being sent through a TCP/IP socket. The receiving Erlang node decodes the message and distributes it to the correct process.</source>
          <target state="translated">메시지가 다른 Erlang 노드의 프로세스로 전송되면 TCP / IP 소켓을 통해 전송되기 전에 먼저 Erlang 외부 형식으로 인코딩됩니다. 수신 Erlang 노드는 메시지를 디코딩하여 올바른 프로세스로 분배합니다.</target>
        </trans-unit>
        <trans-unit id="551c8d852b503a0a48471c3cded481149fff350c" translate="yes" xml:space="preserve">
          <source>When a module is Cover compiled, it is also loaded using the normal code loading mechanism of Erlang. This means that if a Cover compiled module is re-loaded during a Cover session, for example using &lt;code&gt;c(Module)&lt;/code&gt;, it will no longer be Cover compiled.</source>
          <target state="translated">모듈이 Cover 컴파일되면 Erlang의 일반 코드 로딩 메커니즘을 사용하여로드됩니다. 즉, Cover 컴파일 된 모듈이 Cover 세션 중에 다시로드되면 &lt;code&gt;c(Module)&lt;/code&gt; 예 : c (Module) 사용 ) 더 이상 Cover 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="072f598e1ef5d76264967426b11622ee9dff185e" translate="yes" xml:space="preserve">
          <source>When a module is to be updated, the release handler finds which processes that are &lt;strong&gt;using&lt;/strong&gt; the module by traversing the supervision tree of each running application and checking all the child specifications:</source>
          <target state="translated">모듈을 업데이트 할 때 릴리스 핸들러는 실행중인 각 애플리케이션의 감독 트리를 통과하고 모든 하위 스펙을 확인하여 모듈을 &lt;strong&gt;사용&lt;/strong&gt; 중인 프로세스를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="9033ba75ed69bf751fa6e5b051720381187f258c" translate="yes" xml:space="preserve">
          <source>When a new OTP release is released it will have an OTP version on the form &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; where the major OTP version number equals the release number. The major version number is increased one step since the last major version. All other OTP versions with the same major OTP version number are patches on that OTP release.</source>
          <target state="translated">새 OTP 릴리스가 릴리스되면 &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; 형식의 OTP 버전을 갖게 되며 여기서 주요 OTP 버전 번호는 릴리스 번호와 같습니다. 주 버전 번호는 마지막 주 버전 이후 한 단계 증가합니다. 주 OTP 버전 번호가 동일한 다른 모든 OTP 버전은 해당 OTP 릴리스의 패치입니다.</target>
        </trans-unit>
        <trans-unit id="cbbb4bde17a561149622c0549faa70bd0cd996df" translate="yes" xml:space="preserve">
          <source>When a new fun is defined in the shell, the value of the fun is printed as &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">쉘에 새 fun이 정의되면 fun 값이 &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a3c0fc498149078e34911c14f7a085c035bd806" translate="yes" xml:space="preserve">
          <source>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</source>
          <target state="translated">새 버전의 릴리스가 설치되면로드 된 모든 응용 프로그램에 대해 응용 프로그램 사양이 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1659bff51ef846577db0a731a65e27f0a6975ea2" translate="yes" xml:space="preserve">
          <source>When a node gets overloaded, it is not possible to issue &lt;code&gt;ttb:p/2&lt;/code&gt; or any command from the &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; family, as it would lead to inconsistent tracing state (different trace specifications on different nodes).</source>
          <target state="translated">노드에 과부하가 &lt;code&gt;ttb:p/2&lt;/code&gt; 또는 &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; 제품군 에서 명령을 실행할 수 없습니다. 추적 상태가 일관되지 않기 때문입니다 (서로 다른 노드에서 다른 추적 스펙).</target>
        </trans-unit>
        <trans-unit id="9107c7e3a2ab54b42fe2aa4f90dbf2f0ef91d069" translate="yes" xml:space="preserve">
          <source>When a node tries to connect to another node, the magic cookies are compared. If they do not match, the connected node rejects the connection.</source>
          <target state="translated">노드가 다른 노드에 연결을 시도하면 매직 쿠키가 비교됩니다. 일치하지 않으면 연결된 노드가 연결을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="91dc7db1911778980d1a145028f56ea061e34c24" translate="yes" xml:space="preserve">
          <source>When a parenthesized subpattern is quantified with a minimum repeat count that is &amp;gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.</source>
          <target state="translated">괄호로 묶인 하위 패턴을 최소 반복 횟수가 1보다 크거나 제한된 최대 값으로 수량화하면 컴파일 된 패턴에 최소 또는 최대 크기에 비례하여 더 많은 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="17163b128ce2d3940abc9e287d9eb3065dfe4943" translate="yes" xml:space="preserve">
          <source>When a part in the version number increases, all less significant parts are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">버전 번호의 부품이 증가하면 덜 중요한 모든 부품이 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="414ecb7481a0e4a00ed77662f92beb6946aca44b" translate="yes" xml:space="preserve">
          <source>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern</source>
          <target state="translated">패턴 자체가 무제한 반복 될 수있는 서브 패턴 내부에 무한 반복이 포함 된 경우 원자 그룹을 사용하는 것이 일부 실패한 경기가 오래 걸리는 것을 피할 수있는 유일한 방법입니다. 패턴</target>
        </trans-unit>
        <trans-unit id="ca6c00c70d6d587bfac21cf87c7afe2ad1eacd1f" translate="yes" xml:space="preserve">
          <source>When a pending message is received, and the &lt;code&gt;long_request_timer&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; &quot;on its final leg&quot;, the timer will be restarted, and, if &lt;code&gt;long_request_resend = true&lt;/code&gt;, the request will be re-sent.</source>
          <target state="translated">보류중인 메시지가 수신되고 &lt;code&gt;long_request_timer&lt;/code&gt; 가 &quot;최종 레그&quot;에 &lt;strong&gt;있지 않으면&lt;/strong&gt; 타이머가 다시 시작되고 &lt;code&gt;long_request_resend = true&lt;/code&gt; 인 경우 요청이 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f75f183f6a0a339836141c5520bd7b12114dfb3c" translate="yes" xml:space="preserve">
          <source>When a pending message is received, the timer is cancelled and the &lt;code&gt;long_request_timer&lt;/code&gt; is started instead (see below). No resends will be performed from this point (since we now know that the other side has received the request).</source>
          <target state="translated">보류중인 메시지가 수신되면 타이머가 취소되고 대신 &lt;code&gt;long_request_timer&lt;/code&gt; 가 시작됩니다 (아래 참조). 이 시점부터는 재전송이 수행되지 않습니다 (이제 상대방이 요청을 수신 한 것을 알고 있으므로).</target>
        </trans-unit>
        <trans-unit id="caca1f590c83f0cbc730079b288c0a340c8795e2" translate="yes" xml:space="preserve">
          <source>When a pending transaction is sent.</source>
          <target state="translated">보류중인 트랜잭션이 전송 된 경우</target>
        </trans-unit>
        <trans-unit id="9309b1e58646bc0004532eb714a09afd5a498a84" translate="yes" xml:space="preserve">
          <source>When a port is closed, either by an Erlang process or by the driver calling one of the &lt;code&gt;driver_failure_XXX&lt;/code&gt; routines. This routine is to clean up everything connected to one particular port. When other callbacks call a &lt;code&gt;driver_failure_XXX&lt;/code&gt; routine, this routine is immediately called. The callback routine issuing the error can make no more use of the data structures for the port, as this routine surely has freed all associated data and closed all file descriptors. If the queue utility available to driver writer is used, this routine is however &lt;strong&gt;not&lt;/strong&gt; called until the queue is empty.</source>
          <target state="translated">Erlang 프로세스 또는 드라이버가 &lt;code&gt;driver_failure_XXX&lt;/code&gt; 루틴 중 하나를 호출하여 포트를 닫을 때 . 이 루틴은 하나의 특정 포트에 연결된 모든 것을 정리하는 것입니다. 다른 콜백이 &lt;code&gt;driver_failure_XXX&lt;/code&gt; 루틴을 호출하면 이 루틴이 즉시 호출됩니다. 오류를 발생시키는 콜백 루틴은 포트에 대한 데이터 구조를 더 이상 사용할 수 없습니다.이 루틴은 반드시 모든 관련 데이터를 해제하고 모든 파일 설명자를 닫았 기 때문입니다. 그러나 드라이버 라이터가 사용할 수있는 큐 유틸리티가 사용되면 큐가 비워 질 때 까지이 루틴이 호출 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cab97407457bdcec73d321074e9305a6e73487c1" translate="yes" xml:space="preserve">
          <source>When a port to the driver is opened (by a &lt;code&gt;open_port&lt;/code&gt; call from Erlang). This routine is to set up internal data structures and return an opaque data entity of the type &lt;code&gt;ErlDrvData&lt;/code&gt;, which is a data type large enough to hold a pointer. The pointer returned by this function is the first argument to all other callbacks concerning this particular port. It is usually called the port handle. The emulator only stores the handle and does never try to interpret it, why it can be virtually anything (anything not larger than a pointer that is) and can point to anything if it is a pointer. Usually this pointer refers to a structure holding information about the particular port, as it does in the example.</source>
          <target state="translated">드라이버의 포트가 열릴 때 ( Erlang 의 &lt;code&gt;open_port&lt;/code&gt; 호출로) 이 루틴은 내부 데이터 구조를 설정 하고 포인터를 보유하기에 충분히 큰 데이터 유형 인 &lt;code&gt;ErlDrvData&lt;/code&gt; 유형의 불투명 한 데이터 엔티티를 리턴하는 것 입니다. 이 함수에 의해 반환되는 포인터는이 특정 포트와 관련된 다른 모든 콜백에 대한 첫 번째 인수입니다. 일반적으로 포트 핸들이라고합니다. 에뮬레이터는 핸들 만 저장하고 해석하려고 시도하지 않습니다. 왜 포인터가 포인터보다 크지 않은지 실제로는 무엇이든 될 수 있습니다. 일반적으로이 포인터는 예제에서와 같이 특정 포트에 대한 정보를 보유하는 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d6c6008e1040993823cc1153b9087a328f65c269" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt; 에 의해 프로세스가 종료되면 가비지 콜렉션이 완료되기 전에 프로세스가 종료 되므로 큰 힙 메시지가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54c7049ba92415c934270df93ecc40c6ff49a6de" translate="yes" xml:space="preserve">
          <source>When a process is trapping exits, it does not terminate when an exit signal is received. Instead, the signal is transformed into a message &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt;, which is put into the mailbox of the process, just like a regular message.</source>
          <target state="translated">프로세스가 종료를 트래핑하는 경우 종료 신호가 수신 될 때 종료되지 않습니다. 대신, 신호는 일반 메시지처럼 프로세스의 편지함에 넣어지는 &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt; 메시지로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f894aeebc67996f11b9c7ed1100aea86a6d270d1" translate="yes" xml:space="preserve">
          <source>When a process reaches a breakpoint, only that process is stopped. Other processes are not affected.</source>
          <target state="translated">프로세스가 중단 점에 도달하면 해당 프로세스 만 중지됩니다. 다른 프로세스는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5fe92890350a386281d849d2308c2fdf32b6229" translate="yes" xml:space="preserve">
          <source>When a process terminates, it always terminates with an &lt;strong&gt;exit reason&lt;/strong&gt;. The reason can be any term.</source>
          <target state="translated">프로세스가 종료되면 항상 종료 &lt;strong&gt;이유로&lt;/strong&gt; 종료됩니다 . 이유는 임의의 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33255f3d61f1a754c180593962f65ef23e96913" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="translated">프로세스가 종료되면 프로세스 종료에 설명 된대로 &lt;strong&gt;종료 이유&lt;/strong&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt; 됩니다. 이 종료 이유는 모든 연결된 프로세스 에 대한 &lt;strong&gt;종료 신호&lt;/strong&gt; 로 방출 됩니다.</target>
        </trans-unit>
        <trans-unit id="f438ecf00c74cada65672d3aca9158bdc88f9b65" translate="yes" xml:space="preserve">
          <source>When a process that is started using &lt;code&gt;proc_lib&lt;/code&gt; terminates abnormally (that is, with another exit reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;), a &lt;strong&gt;crash report&lt;/strong&gt; is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 시작된 프로세스가 비정상적으로 종료 되면 (즉, &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 종료 이유로 인해 ) &lt;strong&gt;충돌 보고서&lt;/strong&gt; 가 생성되며, 이는 커널이 기본 로거 핸들러 설정에 의해 터미널에 작성됩니다. . Erlang / OTP 21.0 이전에 충돌 보고서가 기록 된 방법에 대한 자세한 내용은 SASL 사용 설명서의 &lt;code&gt;SASL Error Logging&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="620e45b56f249c1dbe8f129dc957582dac227989" translate="yes" xml:space="preserve">
          <source>When a program runs in the service context, it must handle the control events that are sent to every program in the system when the interactive user logs off. This is done in different ways for programs running in the console subsystem and programs running as window applications. An application running in the console subsystem (normal for port programs) uses the win32 function &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; to register a control handler that returns &lt;code&gt;true&lt;/code&gt; in answer to the &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; events. Other applications only forward &lt;code&gt;WM_ENDSESSION&lt;/code&gt; and &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; to the default window procedure.</source>
          <target state="translated">프로그램이 서비스 컨텍스트에서 실행될 때 대화식 사용자가 로그 오프 할 때 시스템의 모든 프로그램으로 전송되는 제어 이벤트를 처리해야합니다. 이것은 콘솔 서브 시스템에서 실행되는 프로그램과 창 응용 프로그램으로 실행되는 프로그램에 대해 다른 방식으로 수행됩니다. 콘솔 서브 시스템에서 실행중인 응용 프로그램 (포트 프로그램의 일반)은 win32 함수 &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; 를 사용 하여 &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; 및 &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; 이벤트 에 대한 응답으로 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 제어 핸들러를 등록 합니다. 다른 응용 프로그램은 &lt;code&gt;WM_ENDSESSION&lt;/code&gt; 및 &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; 을 기본 창 프로 시저 로만 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="19ffb1b5dfb2cc8d3c94f0461fc310cb105f6b53" translate="yes" xml:space="preserve">
          <source>When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte.</source>
          <target state="translated">키를 다시 입력하면 타이머와 바이트 카운터가 모두 다시 시작됩니다. 기본값은 1 시간 1GB입니다.</target>
        </trans-unit>
        <trans-unit id="160df15be10c112ef08e1b12460eb364b392a9a7" translate="yes" xml:space="preserve">
          <source>When a reply &lt;code&gt;Reply&lt;/code&gt; is received from the &lt;code&gt;gen_server&lt;/code&gt; process at a node &lt;code&gt;Node&lt;/code&gt;, &lt;code&gt;{Node,Reply}&lt;/code&gt; is added to &lt;code&gt;Replies&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 로부터 응답 &lt;code&gt;Reply&lt;/code&gt; 이 수신 되면 &lt;code&gt;{Node,Reply}&lt;/code&gt; 가 &lt;code&gt;Replies&lt;/code&gt; 에 추가됩니다 . &lt;code&gt;Reply&lt;/code&gt; 은 &lt;code&gt;Module:handle_call/3&lt;/code&gt; 의 반환 값에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3612568b6d1bd1adf395a8924394d4f1cda79d" translate="yes" xml:space="preserve">
          <source>When a reply transaction is sent.</source>
          <target state="translated">답장 거래가 전송 될 때.</target>
        </trans-unit>
        <trans-unit id="6b9676d76432236d4be5a23bf4ca85a4c81230e6" translate="yes" xml:space="preserve">
          <source>When a request is received, some info related to the reply is store internally (e.g. the binary of the reply). This info will live until either an ack is received or this timer expires. For instance, if the same request is received again (e.g. a request with the same transaction id), the (stored) reply will be (re-) sent automatically by megaco.</source>
          <target state="translated">요청이 수신되면 응답과 관련된 일부 정보가 내부적으로 저장됩니다 (예 : 응답의 이진). 이 정보는 ack가 수신되거나이 타이머가 만료 될 때까지 유지됩니다. 예를 들어, 동일한 요청이 다시 수신되면 (예 : 동일한 트랜잭션 ID를 가진 요청), (저장된) 응답은 megaco에 의해 자동으로 (재) 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b6b06f9b88824f92a821ddd40390c63201a38782" translate="yes" xml:space="preserve">
          <source>When a request is sent using the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; function, a proxy process is started to handle all replies. When the reply has been received and delivered to the user, the proxy process continue to exist for as long as this option specifies. Any received messages, is passed on to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 요청이 전송되면 모든 회신을 처리하기 위해 프록시 프로세스가 시작됩니다. 응답을 수신하여 사용자에게 전달한 경우이 옵션이 지정하는 한 프록시 프로세스가 계속 존재합니다. 수신 된 모든 메시지는 &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; 콜백 함수 를 통해 사용자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="c88f71ef842c681d045f4cae79da80397386486a" translate="yes" xml:space="preserve">
          <source>When a run-time error occurs, that is an exception of class &lt;code&gt;error&lt;/code&gt;. The exit reason is a tuple &lt;code&gt;{Reason,Stack}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is a term indicating the type of error:</source>
          <target state="translated">런타임 오류가 발생하면 이는 class &lt;code&gt;error&lt;/code&gt; 예외입니다 . 종료 이유는 튜플 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 이며 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 오류 유형을 나타내는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="25b12f8bd1c57b6ce9840c0a7b9fe58cbedb898d" translate="yes" xml:space="preserve">
          <source>When a run-time error or generated error occurs in Erlang, execution for the process that evaluated the erroneous expression is stopped. This is referred to as a &lt;strong&gt;failure&lt;/strong&gt;, that execution or evaluation &lt;strong&gt;fails&lt;/strong&gt;, or that the process &lt;strong&gt;fails&lt;/strong&gt;, &lt;strong&gt;terminates&lt;/strong&gt;, or &lt;strong&gt;exits&lt;/strong&gt;. Notice that a process can terminate/exit for other reasons than a failure.</source>
          <target state="translated">Erlang에서 런타임 오류 또는 생성 된 오류가 발생하면 잘못된 표현식을 평가 한 프로세스의 실행이 중지됩니다. 이를 &lt;strong&gt;실패&lt;/strong&gt; , 실행 또는 평가 &lt;strong&gt;실패&lt;/strong&gt; 또는 프로세스 &lt;strong&gt;실패&lt;/strong&gt; , &lt;strong&gt;종료&lt;/strong&gt; 또는 &lt;strong&gt;종료라고&lt;/strong&gt; 합니다. 프로세스는 실패 이외의 다른 이유로 종료 / 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6222adda532a7ba95811b3f47ed6b592bce7369e" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details), transitions to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode, the controlling process is notified by a message of the following form:</source>
          <target state="translated">&lt;code&gt;{active, N}&lt;/code&gt; 모드 의 소켓 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 참조)이 수동 ( &lt;code&gt;{active, false}&lt;/code&gt; ) 모드로 전환되면 제어 프로세스에 다음 형식의 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad380e3a94ebd517a8a93bc527d1a2a8c42ac9d" translate="yes" xml:space="preserve">
          <source>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</source>
          <target state="translated">고정 쓰기 잠금이 확보되면 모든 노드에 어떤 노드가 잠겨 있는지 알립니다. 그런 다음 동일한 노드의 고정 잠금 요청이 다른 노드와의 통신없이 로컬 작업으로 수행됩니다. 트랜잭션이 끝난 후에도 고정 잠금이 노드에 남아 있습니다. 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f8a9afc8539f723b3d906fa063814442e45d9210" translate="yes" xml:space="preserve">
          <source>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</source>
          <target state="translated">테이블이 SNMP 주문 인 경우 수정은 보통 O (logN)보다 비쌉니다. 또한 더 많은 메모리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09de174e5f27981b5d536ae7d587e5f775467043" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed, and each object in the table is returned only once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal &lt;strong&gt;can&lt;/strong&gt; be returned by &lt;code&gt;next/2&lt;/code&gt; (it depends on the internal ordering of the keys).</source>
          <target state="translated">테이블이 고정되면 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 호출 시퀀스 가 성공할 수 있으며 순회 중에 오브젝트를 제거하거나 삽입하더라도 테이블의 각 오브젝트는 한 번만 리턴됩니다. 순회 중 삽입 된 새 객체의 키는 &lt;code&gt;next/2&lt;/code&gt; 의해 반환 될 &lt;strong&gt;수&lt;/strong&gt; 있습니다 (키의 내부 순서에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="f25502d9a8f67791267ea14f5c70c734251d290a" translate="yes" xml:space="preserve">
          <source>When a target name is used for referencing the configuration data (that specifies the connection to be opened), the same name can be used as connection identity in all subsequent calls related to the connection (also for closing it). Only one open connection per target name is possible. If you attempt to open a new connection using a name already associated with an open connection, &lt;code&gt;Common Test&lt;/code&gt; returns the already existing handle so the previously opened connection is used. This feature makes it possible to call the function for opening a particular connection whenever useful. An action like this does not necessarily open any new connections unless it is required (which could be the case if, for example, the previous connection has been closed unexpectedly by the server). Using named connections also removes the need to pass handle references around in the suite for these connections.</source>
          <target state="translated">구성 데이터를 참조하기 위해 대상 이름을 사용하는 경우 (열릴 연결을 지정하는 경우) 연결과 관련된 모든 후속 호출에서 동일한 이름을 연결 ID로 사용할 수 있습니다 (닫을 때도). 대상 이름 당 하나의 열린 연결 만 가능합니다. 열린 연결과 이미 연결된 이름을 사용하여 새 연결을 열려고하면 &lt;code&gt;Common Test&lt;/code&gt; 이전에 열린 연결이 사용되도록 기존 핸들을 반환합니다. 이 기능을 사용하면 유용 할 때마다 특정 연결을 여는 함수를 호출 할 수 있습니다. 이와 같은 조치가 필요한 경우가 아니면 새 연결을 반드시 열 필요는 없습니다 (예를 들어, 이전 연결이 서버에 의해 예기치 않게 닫힌 경우). 명명 된 연결을 사용하면 이러한 연결을 위해 제품군에서 핸들 참조를 전달할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b832ad499cefe25ddc82f36d870e896057644d6" translate="yes" xml:space="preserve">
          <source>When a term is passed as the initial process arguments in the &lt;code&gt;spawn&lt;/code&gt; call</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 호출 에서 용어가 초기 프로세스 인수로 전달되는 경우</target>
        </trans-unit>
        <trans-unit id="6e389307b8d59483ef3d7e87b6dfe90a060b042c" translate="yes" xml:space="preserve">
          <source>When a term is sent to another process</source>
          <target state="translated">용어가 다른 프로세스로 전송 된 경우</target>
        </trans-unit>
        <trans-unit id="b733aebb93dce74a8914341750d479f7d8a549ed" translate="yes" xml:space="preserve">
          <source>When a term is stored in an Ets table</source>
          <target state="translated">용어가 Ets 테이블에 저장된 경우</target>
        </trans-unit>
        <trans-unit id="0c7ebdcd78a12cc7bd8bd97eb29bacb32f39549b" translate="yes" xml:space="preserve">
          <source>When a test case group is repeated, the configuration functions &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; are also always called with each repetition.</source>
          <target state="translated">테스트 케이스 그룹이 반복되면 구성 함수 &lt;code&gt;init_per_group/2&lt;/code&gt; 및 &lt;code&gt;end_per_group/2&lt;/code&gt; 도 항상 각 반복마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2be9bace113be2bd43525f396f001fb603a47ce4" translate="yes" xml:space="preserve">
          <source>When a test case group is specified, the resulting test executes function &lt;code&gt;init_per_group&lt;/code&gt;, followed by all test cases and subgroups (including their configuration functions), and finally function &lt;code&gt;end_per_group&lt;/code&gt;. Also, if particular test cases in a group are specified, &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt;, for the group in question, are called. If a group defined (in &lt;code&gt;Suite:group/0&lt;/code&gt;) as a subgroup of another group, is specified (or if particular test cases of a subgroup are), &lt;code&gt;Common Test&lt;/code&gt; calls the configuration functions for the top-level groups and for the subgroup in question (making it possible to pass configuration data all the way from &lt;code&gt;init_per_suite&lt;/code&gt; down to the test cases in the subgroup).</source>
          <target state="translated">테스트 케이스 그룹이 지정되면 결과 테스트는 &lt;code&gt;init_per_group&lt;/code&gt; 함수 와 모든 테스트 케이스 및 서브 그룹 (구성 함수 포함)을 실행하고 마지막으로 &lt;code&gt;end_per_group&lt;/code&gt; 함수를 실행 합니다. 또한 그룹의 특정 테스트 사례가 지정된 경우 해당 그룹에 대한 &lt;code&gt;init_per_group&lt;/code&gt; 및 &lt;code&gt;end_per_group&lt;/code&gt; 이 호출됩니다. 그룹이 ( &lt;code&gt;Suite:group/0&lt;/code&gt; 에서 ) 다른 그룹의 하위 그룹으로 정의 된 경우 (또는 하위 그룹의 특정 테스트 사례가 지정된 경우) &lt;code&gt;Common Test&lt;/code&gt; 는 최상위 그룹 및 하위 그룹의 구성 함수를 호출합니다. 질문 ( &lt;code&gt;init_per_suite&lt;/code&gt; 에서 구성 데이터를 전달하는 것이 가능하게 함) 하위 그룹의 테스트 사례까지).</target>
        </trans-unit>
        <trans-unit id="7eab1460f1347d0c73cb3c3a8b4439b39091de4a" translate="yes" xml:space="preserve">
          <source>When a test case is skipped, it is noted as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log.</source>
          <target state="translated">테스트 사례를 건너 뛰면 HTML 로그에 &lt;code&gt;SKIPPED&lt;/code&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7277815e7b5fc7d7307a8ad2c9b5d0b7fee5390" translate="yes" xml:space="preserve">
          <source>When a timer expires. The driver can set timers with the function &lt;code&gt;driver_set_timer&lt;/code&gt;. When such timers expire, a specific callback function is called. No timers are used in the example.</source>
          <target state="translated">타이머가 만료 될 때 드라이버는 &lt;code&gt;driver_set_timer&lt;/code&gt; 함수를 사용하여 타이머를 설정할 수 있습니다 . 이러한 타이머가 만료되면 특정 콜백 함수가 호출됩니다. 예제에서는 타이머가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01248c84705afaa8d22118ccef5dc76865736320" translate="yes" xml:space="preserve">
          <source>When a transaction acknowledgement is received it is possible that user has decided not to bother about the acknowledgement. But in case the return value from UserMod:handle_trans_request/3 indicates that the acknowledgement is important the following callback function will be invoked:</source>
          <target state="translated">거래 확인이 수신되면, 사용자는 확인에 대해 귀찮게하지 않기로 결정했을 수있다. 그러나 UserMod : handle_trans_request / 3의 리턴 값이 승인이 중요 함을 나타내는 경우 다음 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="163b7a94b619edcfd4f6cd93b3333d250e24a1fb" translate="yes" xml:space="preserve">
          <source>When a user (MG/MGC) is distributed over several nodes, it is required that the node hosting the connection already has activated the connection and that it is in the &quot;normal&quot; state. The RemoteMid must be a real Megaco MID and not a preliminary_mid.</source>
          <target state="translated">사용자 (MG / MGC)가 여러 노드에 분산 된 경우 연결을 호스트하는 노드가 이미 연결을 활성화하고 &quot;정상&quot;상태에 있어야합니다. RemoteMid는 예비 Mega가 아니라 실제 Megaco MID 여야합니다.</target>
        </trans-unit>
        <trans-unit id="19eb5cc222fe8477b606be0ecb93b47faec2127d" translate="yes" xml:space="preserve">
          <source>When a valid request reaches &lt;code&gt;httpd&lt;/code&gt;, it calls &lt;code&gt;do/1&lt;/code&gt; in each module, defined by the configuration option of &lt;code&gt;Module&lt;/code&gt;. The function can generate data for other modules or a response that can be sent back to the client.</source>
          <target state="translated">유효한 요청이 도달하면 &lt;code&gt;httpd&lt;/code&gt; , 그것을 호출 &lt;code&gt;do/1&lt;/code&gt; 의 구성 옵션에 의해 정의 된 각 모듈에 &lt;code&gt;Module&lt;/code&gt; . 이 함수는 다른 모듈에 대한 데이터를 생성하거나 클라이언트로 다시 보낼 수있는 응답을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988284baf01c48f0333363a5420ee041f8e80f73" translate="yes" xml:space="preserve">
          <source>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; instead. It can be used for records of type &lt;code&gt;RecordName&lt;/code&gt;.</source>
          <target state="translated">레코드에서 단일 속성에 액세스 할 때 속성 이름을 원자로 하드 코딩하는 것이 필요하지 않거나 심지어 권장되지 않습니다. 대신 construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; 사용하십시오. &lt;code&gt;RecordName&lt;/code&gt; 유형의 레코드에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a069a06056d1779ba3b73665e6912fd948d0893" translate="yes" xml:space="preserve">
          <source>When adding or removing an application, no &lt;code&gt;.appup&lt;/code&gt; file is needed. When generating &lt;code&gt;relup&lt;/code&gt;, the &lt;code&gt;.rel&lt;/code&gt; files are compared and the &lt;code&gt;add_application&lt;/code&gt; and &lt;code&gt;remove_application&lt;/code&gt; instructions are added automatically.</source>
          <target state="translated">응용 프로그램을 추가하거나 제거 할 때 &lt;code&gt;.appup&lt;/code&gt; 파일이 필요 하지 않습니다. 생성 할 때 &lt;code&gt;relup&lt;/code&gt; 을 의 &lt;code&gt;.rel&lt;/code&gt; 의 파일을 비교하고 &lt;code&gt;add_application&lt;/code&gt; 및 &lt;code&gt;remove_application&lt;/code&gt; 지침은 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7dcf974a69ad2af0b183e9640143a16ca26c965" translate="yes" xml:space="preserve">
          <source>When adding processes or ports, a window with trace options is displayed. The chosen options are set for the selected processes/ports. To change the options, right-click the process or port and select &lt;strong&gt;Edit process options&lt;/strong&gt;. To remove a process or port from the list, right-click and select &lt;strong&gt;Remove process&lt;/strong&gt; or &lt;strong&gt;Remove port&lt;/strong&gt;, respectively.</source>
          <target state="translated">프로세스 또는 포트를 추가 할 때 추적 옵션이있는 창이 표시됩니다. 선택된 옵션은 선택된 프로세스 / 포트에 대해 설정됩니다. 옵션을 변경하려면 프로세스 또는 포트를 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;프로세스 옵션 편집을&lt;/strong&gt; 선택 &lt;strong&gt;하십시오&lt;/strong&gt; . 목록에서 프로세스 또는 포트를 제거하려면 마우스 오른쪽 단추를 클릭하고 &lt;strong&gt;프로세스 &lt;/strong&gt;&lt;strong&gt;제거&lt;/strong&gt; 또는 &lt;strong&gt;포트 제거&lt;/strong&gt; 를 각각 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed50d489e165b74cf018acee993218839df9d7b" translate="yes" xml:space="preserve">
          <source>When all involved (mandatory) nodes have been started, the distributed application can be started by calling &lt;code&gt;application:start(Application)&lt;/code&gt; at &lt;strong&gt;all of these nodes.&lt;/strong&gt;</source>
          <target state="translated">모든 관련 (필수) 노드가 시작되면 &lt;strong&gt;이러한 모든 노드&lt;/strong&gt; 에서 &lt;code&gt;application:start(Application)&lt;/code&gt; 을 호출하여 분산 응용 프로그램을 시작할 수 있습니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd73cca48ba2b286c66fc15f791c382c884ddbc5" translate="yes" xml:space="preserve">
          <source>When all nodes are operational, &lt;code&gt;myapp&lt;/code&gt; can be started. This is achieved by calling &lt;code&gt;application:start(myapp)&lt;/code&gt; at all three nodes. It is then started at &lt;code&gt;cp1&lt;/code&gt;, as shown in the following figure:</source>
          <target state="translated">모든 노드가 작동하면 &lt;code&gt;myapp&lt;/code&gt; 을 시작할 수 있습니다. 세 노드 모두에서 &lt;code&gt;application:start(myapp)&lt;/code&gt; 를 호출 하면됩니다. 그런 다음 다음 그림과 같이 &lt;code&gt;cp1&lt;/code&gt; 에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="efd0a7b9eacf13a1791c55c3dbd5596c2928ca10" translate="yes" xml:space="preserve">
          <source>When all objects of the table have been matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">테이블의 모든 개체가 일치하면 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1c6e68ed8acc251646eddfa314228262bb5f3b" translate="yes" xml:space="preserve">
          <source>When all table objects are matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">모든 테이블 개체가 일치하면 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c62a1cbadf2c2b8976473d30ec9850b0e30154" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;escript&lt;/code&gt; file contains an archive, there are no restrictions on the name of the &lt;code&gt;escript&lt;/code&gt; and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) &lt;code&gt;ebin&lt;/code&gt; directories in the embedded archive are added to the code path. See &lt;code&gt;erts:escript(1)&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;escript&lt;/code&gt; 의 파일 아카이브를 포함,의 이름에 대한 제한이없는 &lt;code&gt;escript&lt;/code&gt; 및 포함 된 아카이브에 저장 할 수있는 방법을 많은 응용 프로그램에는 제한. 단일 빔 파일은 아카이브의 최상위 레벨에있을 수도 있습니다. 시작시 임베디드 아카이브의 최상위 디렉토리와 임베디드 아카이브의 모든 (두 번째 레벨) &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 코드 경로에 추가됩니다. &lt;code&gt;erts:escript(1)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9936eae6e93ab6d5c78b6480d03e1af10ab7148" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;usm_entry()&lt;/code&gt; tuple (or a list of such tuples) is returned, this data is then added to the &lt;code&gt;usmUserTable&lt;/code&gt; by the (master-) agent.</source>
          <target state="translated">때 &lt;code&gt;usm_entry()&lt;/code&gt; 튜플 (또는 튜플들의 목록)을 리턴하고,이 데이터는 그 다음에 첨가 &lt;code&gt;usmUserTable&lt;/code&gt; 제 (마스터 -) 에이전트.</target>
        </trans-unit>
        <trans-unit id="0b976e99904fcceb1196e74093f891273ad96adf" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled with option &lt;code&gt;ber&lt;/code&gt;, the &lt;code&gt;asn1rt_nif&lt;/code&gt; module and the NIF library in &lt;code&gt;asn1/priv_dir&lt;/code&gt; are needed at runtime.</source>
          <target state="translated">ASN.1 사양이 옵션으로 컴파일 할 때 &lt;code&gt;ber&lt;/code&gt; 의 &lt;code&gt;asn1rt_nif&lt;/code&gt; 의 모듈과의 NIF 라이브러리 &lt;code&gt;asn1/priv_dir&lt;/code&gt; 런타임에 필요하다.</target>
        </trans-unit>
        <trans-unit id="5c483462464501bc7953de399a743714b5061e30" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled, all defined types of type &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SEQUENCE&lt;/code&gt; result in a corresponding record in the generated &lt;code&gt;.hrl&lt;/code&gt; file. This is because the values for &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;SEQUENCE&lt;/code&gt; are represented as records by default.</source>
          <target state="translated">ASN.1 스펙이 컴파일되면 &lt;code&gt;SET&lt;/code&gt; 또는 &lt;code&gt;SEQUENCE&lt;/code&gt; 유형의 모든 정의 된 유형 이 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일 에 해당 레코드가 됩니다. &lt;code&gt;SET&lt;/code&gt; 및 &lt;code&gt;SEQUENCE&lt;/code&gt; 의 값 이 기본적으로 레코드로 표시 되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="0e9c8df5e2566ccd5d9fbe4734d8fd9d613779aa" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="translated">Erlang 프로세스가 드라이버에 대한 동기식 인터페이스 인 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 . 제어 인터페이스는 드라이버 옵션 설정, 포트 상태 변경 등을 위해 사용됩니다. 이 인터페이스는 예제에서 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b618715bb8bb03bc07feda65b3a85bb43cb72de" translate="yes" xml:space="preserve">
          <source>When an Erlang process sends data to the port. The data arrives as a buffer of bytes, the interpretation is not defined, but is up to the implementor. This callback returns nothing to the caller, answers are sent to the caller as messages (using a routine called &lt;code&gt;driver_output&lt;/code&gt; available to all drivers). There is also a way to talk in a synchronous way to drivers, described below. There can be an additional callback function for handling data that is fragmented (sent in a deep io-list). That interface gets the data in a form suitable for Unix &lt;code&gt;writev&lt;/code&gt; rather than in a single buffer. There is no need for a distribution driver to implement such a callback, so we will not.</source>
          <target state="translated">Erlang 프로세스가 포트로 데이터를 보낼 때. 데이터는 바이트 버퍼로 도착하고 해석은 정의되지 않지만 구현 자에게 달려 있습니다. 이 콜백은 호출자에게 아무것도 반환하지 않으며 응답은 호출자에게 메시지로 전송됩니다 ( 모든 드라이버가 사용할 수있는 &lt;code&gt;driver_output&lt;/code&gt; 루틴 사용 ). 아래에 설명 된 것처럼 운전자와 동기식으로 대화하는 방법도 있습니다. 조각난 데이터를 처리하기위한 추가 콜백 함수가있을 수 있습니다 (심층 IO 목록으로 전송). 이 인터페이스는 단일 버퍼가 아닌 Unix &lt;code&gt;writev&lt;/code&gt; 에 적합한 형식으로 데이터를 가져옵니다 . 배포 드라이버가 이러한 콜백을 구현할 필요가 없으므로 그렇게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd682219ed27952353a789f2a95e93eae1b95ef" translate="yes" xml:space="preserve">
          <source>When an Erlang runtime system is started, a number of processes are started as part of the Kernel application. One of these processes is the &lt;strong&gt;application controller&lt;/strong&gt; process, registered as &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템이 시작되면 커널 프로세스의 일부로 많은 프로세스가 시작됩니다. 이들 방법 중 하나는 인 &lt;strong&gt;애플리케이션 컨트롤러&lt;/strong&gt; 로 등록 프로세스 &lt;code&gt;application_controller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6e9cd273f9f4e055a8524b92a57509f35b9cee" translate="yes" xml:space="preserve">
          <source>When an I/O server receives an &lt;code&gt;io_request&lt;/code&gt; tuple, it acts upon the &lt;code&gt;Request&lt;/code&gt; part and eventually sends an &lt;code&gt;io_reply&lt;/code&gt; tuple with the corresponding &lt;code&gt;Reply&lt;/code&gt; part.</source>
          <target state="translated">I / O 서버가 &lt;code&gt;io_request&lt;/code&gt; 튜플을 수신 하면 &lt;code&gt;Request&lt;/code&gt; 부분 을 처리하여 해당 &lt;code&gt;Reply&lt;/code&gt; 부분 과 함께 &lt;code&gt;io_reply&lt;/code&gt; 튜플을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c97830caeadaae0c71c4a6641f2b72ee5a3a4441" translate="yes" xml:space="preserve">
          <source>When an MIB is compiled, the compiler detects if several managed objects use the same &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. If that is the case, it issues an error message. However, the compiler cannot detect Oid conflicts between different MIBs. These kinds of conflicts generate an error at load time. To avoid this, the following function can be used to do consistency checking between MIBs:</source>
          <target state="translated">MIB가 컴파일 될 때 컴파일러는 여러 관리 객체가 동일한 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 를 사용하는지 감지합니다 . 이 경우 오류 메시지가 표시됩니다. 그러나 컴파일러는 다른 MIB 간의 Oid 충돌을 감지 할 수 없습니다. 이러한 종류의 충돌은로드시 오류를 생성합니다. 이를 방지하기 위해 다음 기능을 사용하여 MIB간에 일관성 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db011fd2eddc67aaa683180ce280cb84fa7377af" translate="yes" xml:space="preserve">
          <source>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</source>
          <target state="translated">TLS / DTLS 소켓이 활성 모드 인 경우 (기본값) 소켓의 데이터는 메시지 형식으로 소켓 소유자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="996325d55085b77e5910030169e95fa9280c37bb" translate="yes" xml:space="preserve">
          <source>When an accept sequence has been completed the acceptor process is expected to continue accepting further requests.</source>
          <target state="translated">수락 순서가 완료되면 수락 자 프로세스는 추가 요청을 계속 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="709fa60f17ba558cd057f2a6b62757eac692ee54" translate="yes" xml:space="preserve">
          <source>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</source>
          <target state="translated">응용 프로그램이 여러 노드에서 실행되고 원격 프로세스가 생성되거나 메시지가 원격 프로세스로 전송되기 전에 원격 노드에서 업데이트가 수행되도록하려는 경우.</target>
        </trans-unit>
        <trans-unit id="6c28abc5b0d379d3a8ba44dbcc2c9763e0be3b27" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on other nodes.</source>
          <target state="translated">응용 프로그램이 다른 노드에서 &lt;code&gt;Mnesia&lt;/code&gt; 를 오버로드 할 수있는 빈번하거나 대량 업데이트를 수행하는 경우</target>
        </trans-unit>
        <trans-unit id="a47a8128b591f9e03e1d7bb3a8b71505f2177f47" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on the nodes.</source>
          <target state="translated">응용 프로그램 이 노드에서 &lt;code&gt;Mnesia&lt;/code&gt; 를 오버로드 할 수있는 빈번하거나 대량 업데이트를 수행하는 경우</target>
        </trans-unit>
        <trans-unit id="8091d18c34c7568e437ad61e1779d1db887806b5" translate="yes" xml:space="preserve">
          <source>When an event handler terminates abnormally, &lt;code&gt;gen_event&lt;/code&gt; logs &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">이벤트 핸들러가 비정상적으로 종료되면 &lt;code&gt;gen_event&lt;/code&gt; 는 이벤트 핸들러 의 상태 용어 대신 &lt;code&gt;Status&lt;/code&gt; 를 로깅 합니다.</target>
        </trans-unit>
        <trans-unit id="3b856ad79c467961efb9c09f4c8c68ce2f0ae4ff" translate="yes" xml:space="preserve">
          <source>When an event manager is stopped, it gives each of the installed event handlers the chance to clean up by calling &lt;code&gt;terminate/2&lt;/code&gt;, the same way as when deleting a handler.</source>
          <target state="translated">이벤트 관리자가 중지되면 설치된 각 이벤트 핸들러 가 핸들러를 삭제할 때와 동일한 방법으로 &lt;code&gt;terminate/2&lt;/code&gt; 를 호출하여 정리할 수있는 기회를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="6ecb64233649623988df5a15e4320b8e35507f15" translate="yes" xml:space="preserve">
          <source>When an installed release is made permanent, the system process &lt;code&gt;init&lt;/code&gt; is set to point out the new &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">설치된 릴리스가 영구적이되면 시스템 프로세스 &lt;code&gt;init&lt;/code&gt; 는 새 &lt;code&gt;sys.config&lt;/code&gt; 를 가리 키도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b00873013d7a25ee81fef530c37b0fd219bde2fd" translate="yes" xml:space="preserve">
          <source>When an integer-value is specified, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process never goes into hibernation.</source>
          <target state="translated">정수 값이 지정되면 &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; 은 지정된 밀리 초 동안 활동이 없으면 최대 절전 모드로 전환되므로 메모리 사용 공간이 줄어 듭니다. &lt;code&gt;undefined&lt;/code&gt; 를 지정 하면 (기본값) 프로세스가 최대 절전 모드로 전환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd630c54a2a673edbcdeb121843359b4c127f6e0" translate="yes" xml:space="preserve">
          <source>When analysing code coverage, the result for &lt;code&gt;m1&lt;/code&gt; can be seen in the cover log in the &lt;code&gt;s1&lt;/code&gt; test result.</source>
          <target state="translated">코드 커버리지를 분석 할 때 &lt;code&gt;s1&lt;/code&gt; 테스트 결과 의 커버 로그에서 &lt;code&gt;m1&lt;/code&gt; 에 대한 결과를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89c824ef18f1155e6eb73bb5f1e6f145e288eb6a" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the &lt;code&gt;include_dir&lt;/code&gt; to Dialyzer. (**)</source>
          <target state="translated">소스에서 분석 할 때 &lt;code&gt;include_dir&lt;/code&gt; 을 Dialyzer로 전달하십시오 . (**)</target>
        </trans-unit>
        <trans-unit id="6d86eb0ccd83bcc9cd8e9fc364281c878af586ee" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the define to Dialyzer. (**)</source>
          <target state="translated">소스에서 분석 할 때 정의를 Dialyzer로 전달하십시오. (**)</target>
        </trans-unit>
        <trans-unit id="ac42477caf4c3ea1c573d88619291bc09d0583f2" translate="yes" xml:space="preserve">
          <source>When analyzing from source, you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the &lt;code&gt;erlc&lt;/code&gt; flags &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-D&lt;/code&gt;). This can be done either by starting Dialyzer with these flags from the command line as in:</source>
          <target state="translated">소스에서 분석 할 때, &lt;code&gt;erlc&lt;/code&gt; 플래그 &lt;code&gt;-I&lt;/code&gt; 및 &lt;code&gt;-D&lt;/code&gt; 와 같이 include 디렉토리 및 매크로 정의 목록을 Dialyzer에 제공해야 할 수도 있습니다 . 다음과 같이 명령 행에서 다음 플래그로 Dialyzer를 시작하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658b2374a8aacc4b9e6927fe3e6096361c317c2b" translate="yes" xml:space="preserve">
          <source>When analyzing the result file from the profiling activity, look for functions that are called many times and have a long &quot;own&quot; execution time (time excluding calls to other functions). Functions that are called a lot of times can also be interesting, as even small things can add up to quite a bit if repeated often. Also ask yourself what you can do to reduce this time. The following are appropriate types of questions to ask yourself:</source>
          <target state="translated">프로파일 링 활동에서 결과 파일을 분석 할 때 여러 번 호출되고 &quot;자신의&quot;실행 시간이 긴 기능 (다른 기능에 대한 호출을 제외한 시간)을 찾으십시오. 많은 시간이 걸리는 함수도 흥미로울 수 있습니다. 작은 것을 반복해도 자주 추가 될 수 있기 때문입니다. 이 시간을 줄이기 위해 무엇을 할 수 있는지 스스로에게 물어보십시오. 다음은 자신에게 물어볼 적절한 질문 유형입니다.</target>
        </trans-unit>
        <trans-unit id="806459f8533827481672dc572cf1bf7921931e0f" translate="yes" xml:space="preserve">
          <source>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</source>
          <target state="translated">다음과 같이 이진을 추가 할 때는 최신 추가 작업에서 반환 된 이진 만 더 저렴한 추가 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="228cd4e5a8bc6e5b7fee2e6123af719e572f533e" translate="yes" xml:space="preserve">
          <source>When building in a Git working directory you also have to have a GNU &lt;code&gt;autoconf&lt;/code&gt; of at least version 2.59 on your system, because you need to generate the &lt;code&gt;configure&lt;/code&gt; scripts before you can start building.</source>
          <target state="translated">Git 작업 디렉토리에 빌드 할 때 빌드를 시작하기 전에 &lt;code&gt;configure&lt;/code&gt; 스크립트 를 생성해야하기 때문에 시스템에 버전 2.59 이상의 GNU &lt;code&gt;autoconf&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf8c1d8b7925ac8c617463eca8b72a76f666d34" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-21.0 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">문서를 작성할 때 &lt;code&gt;$PATH&lt;/code&gt; 에 완전한 Erlang / OTP-21.0 시스템이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="90530c4b0ae5b8364ccb16ac3ef25111d36b377f" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">인수로 호출하면 &lt;code&gt;read&lt;/code&gt; , 기능 &lt;code&gt;InitFun&lt;/code&gt; 는 반환 가정 &lt;code&gt;end_of_input&lt;/code&gt; 더 이상 입력하거나이없는 경우 &lt;code&gt;{Objects, Fun}&lt;/code&gt; , &lt;code&gt;Objects&lt;/code&gt; 객체의 목록이며, &lt;code&gt;Fun&lt;/code&gt; 새로운 입력 기능입니다. 다른 값 &lt;code&gt;Value&lt;/code&gt; 는 오류 &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; 로 리턴됩니다 . 각 입력 함수는 정확히 한 번 호출되며, 오류가 발생하면 마지막 함수는 인수 &lt;code&gt;close&lt;/code&gt; 로 호출되며 응답은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="07cb85581936567b82cbd8ae581b4c6171786cd2" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, the function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occur, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">인수로 호출하면 &lt;code&gt;read&lt;/code&gt; , 기능을 &lt;code&gt;InitFun&lt;/code&gt; 은 반환에 가정 &lt;code&gt;end_of_input&lt;/code&gt; 더 이상 입력하거나이없는 경우 &lt;code&gt;{Objects, Fun}&lt;/code&gt; , &lt;code&gt;Objects&lt;/code&gt; 객체의 목록과 &lt;code&gt;Fun&lt;/code&gt; 새로운 입력 함수가. 다른 값 &lt;code&gt;Value&lt;/code&gt; 는 오류 &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; 로 리턴됩니다 . 각 입력 함수는 정확히 한 번 호출되며, 오류가 발생하면 마지막 함수는 인수 &lt;code&gt;close&lt;/code&gt; 로 호출되며 응답은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="364ba2a27b870da0b99015d17a3a2b5626ba1eeb" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;undefined&lt;/code&gt;, all system performance monitoring settings are cleared.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 인수와 함께 호출하면 모든 시스템 성능 모니터링 설정이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="b44f8219d85b31453de272e6169e5dfa4f9585c9" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;qlc:q/1,2&lt;/code&gt; from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. This is also true when expressions are evaluated by &lt;code&gt;file:eval/1,2&lt;/code&gt; or in the debugger.</source>
          <target state="translated">Erlang 쉘에서 &lt;code&gt;qlc:q/1,2&lt;/code&gt; 를 호출 하면 구문 분석 변환이 자동으로 호출됩니다. 이 경우 QLC를 대체하는 fun은 컴파일되지 않지만 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 의해 평가됩니다 . 표현식이 &lt;code&gt;file:eval/1,2&lt;/code&gt; 또는 디버거에서 평가 될 때도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="0142d7dfddbd655a17b503f022ba1db92cd0ecd9" translate="yes" xml:space="preserve">
          <source>When calling BIFs that accept deep lists, such as &lt;code&gt;list_to_binary/1&lt;/code&gt; or &lt;code&gt;iolist_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list_to_binary/1&lt;/code&gt; 또는 &lt;code&gt;iolist_to_binary/1&lt;/code&gt; 과 같이 딥 목록을 허용하는 BIF를 호출 할 때 .</target>
        </trans-unit>
        <trans-unit id="18c494144b9a22a3f981a6afcba77050a11fcf18" translate="yes" xml:space="preserve">
          <source>When calling this function, &lt;code&gt;iovec&lt;/code&gt; should contain a pointer to &lt;code&gt;NULL&lt;/code&gt; or a ErlNifIOVec structure that should be used if possible. e.g.</source>
          <target state="translated">이 함수를 호출 할 때 &lt;code&gt;iovec&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 에 대한 포인터 또는 가능한 경우 사용해야하는 ErlNifIOVec 구조를 포함해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="865c3803d266e89c17825224f1f9b63a82983678" translate="yes" xml:space="preserve">
          <source>When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless &lt;code&gt;[aeiou]&lt;/code&gt; matches &quot;A&quot; and &quot;a&quot;, and a caseless &lt;code&gt;[^aeiou]&lt;/code&gt; does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &amp;lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &amp;gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support.</source>
          <target state="translated">대소 문자가 일치하지 않으면 클래스의 모든 문자가 대문자와 소문자 버전을 모두 나타냅니다. 예를 들어, 대소 문자 가없는 &lt;code&gt;[aeiou]&lt;/code&gt; 는 &quot;A&quot;및 &quot;a&quot;와 일치하고 대소 문자가 없는 &lt;code&gt;[^aeiou]&lt;/code&gt; 는 &quot;A&quot;와 일치하지 않지만 사례가 많은 버전입니다. UTF 모드에서 PCRE는 항상 &amp;lt;256 미만의 문자에 대한 대소 문자 개념을 이해하므로 대소 문자를 구분하지 않아도됩니다. 값이 더 높은 문자의 경우 대소 문자 개념은 PCRE가 유니 코드 특성 지원으로 컴파일 된 경우에만 지원됩니다. 문자&amp;gt; =에 대해 UTF 모드에서 대소 문자를 구분하지 않으려면 PCRE가 유니 코드 특성 지원 및 UTF 지원으로 컴파일되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1fa07acc11a720ed656be365e748b1e786d781a3" translate="yes" xml:space="preserve">
          <source>When caseless matching is specified (option &lt;code&gt;caseless&lt;/code&gt;), letters are matched independently of case.</source>
          <target state="translated">대소 문자가 일치하지 &lt;code&gt;caseless&lt;/code&gt; ( 대소 문자 옵션 ) 문자가 대소 문자와 독립적으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="37ae8050f70165954f23ba0ebf3fbda68196592f" translate="yes" xml:space="preserve">
          <source>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</source>
          <target state="translated">이 플래그를 변경하면 메시지가 이동합니다. 이 작업이 시작되었지만이 함수 호출이 리턴 될 때 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1c283832835fc69a63d88192d48cfa2b0fe0ad55" translate="yes" xml:space="preserve">
          <source>When changing to state &lt;code&gt;open&lt;/code&gt;, the collected buttons are reset, the lock unlocked, and a state timer for 10 s is started.</source>
          <target state="translated">state &lt;code&gt;open&lt;/code&gt; 으로 변경 하면 수집 된 버튼이 재설정되고 잠금이 해제되며 10 초 동안 상태 타이머가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="44d2f7b0ec39f0b334cd93ff69fd7523f8653774" translate="yes" xml:space="preserve">
          <source>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of &lt;code&gt;=:=&lt;/code&gt; or &lt;code&gt;=/=&lt;/code&gt;. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</source>
          <target state="translated">정수를 부동 소수점과 비교할 때 연산자가 &lt;code&gt;=:=&lt;/code&gt; 또는 &lt;code&gt;=/=&lt;/code&gt; 중 하나가 아닌 경우 정밀도가 낮은 항은 다른 항의 유형으로 변환됩니다 . 부동 소수점은 부동 소수점의 모든 유효 숫자가 소수점 왼쪽에 올 때까지 정수보다 정확합니다. 플로트가 +/- 9007199254740992.0보다 크거나 작은 경우에 발생합니다. 변환 전략은 부동 수의 크기에 따라 변경됩니다. 그렇지 않으면 큰 부동 수와 정수를 비교하면 전이성이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057fdbcf9c89dcfcef51fc5e8e497f10a792cf05" translate="yes" xml:space="preserve">
          <source>When comparing external sets, operator &lt;code&gt;==/2&lt;/code&gt; is used.</source>
          <target state="translated">외부 세트를 비교할 때 연산자 &lt;code&gt;==/2&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc0d77de42806fcc3f093559352b14f83658b4e" translate="yes" xml:space="preserve">
          <source>When comparing two version numbers that have an order, one compare each part as ordinary integers from the most significant part to less significant parts. The order is defined by the first parts of the same significance that differ. An OTP version with a larger version includes all changes that are part of a smaller OTP version. The same goes for application versions.</source>
          <target state="translated">순서가있는 두 가지 버전 번호를 비교할 때 각 부분을 가장 중요한 부분에서 덜 중요한 부분으로 일반 정수로 비교합니다. 순서는 다른 동일한 의미의 첫 번째 부분으로 정의됩니다. 더 큰 버전의 OTP 버전에는 더 작은 OTP 버전의 일부인 모든 변경 사항이 포함됩니다. 응용 프로그램 버전도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7045558361dff4148b294c98385164fc4d95e222" translate="yes" xml:space="preserve">
          <source>When compilation is involved, exception &lt;code&gt;badarg&lt;/code&gt; is thrown if a compilation error occurs. Call &lt;code&gt;compile/2&lt;/code&gt; to get information about the location of the error in the regular expression.</source>
          <target state="translated">컴파일이 관련된 경우 컴파일 오류가 발생하면 &lt;code&gt;badarg&lt;/code&gt; 예외 가 발생합니다. 정규식에서 오류 위치에 대한 정보를 얻으려면 &lt;code&gt;compile/2&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="70f94aaa056c45f783cd020ccfb0c871d028ac6c" translate="yes" xml:space="preserve">
          <source>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</source>
          <target state="translated">연결이 끊어지면 (즉, megaco : disconnect / 2에 의해 명시 적으로 제어 프로세스가 종료 될 때), 사용자가 연결을 다시 설정할 수 있도록 사용자 콜백 함수가 호출됩니다. 보관 된 메시지, 재전송 타이머 등의 내부 상태는 이에 영향을받지 않습니다. 물론 재전송은 연결이 끊어졌을 때 실패하지만 자동 재전송 알고리즘은 이에 대해 신경 쓰지 않으며 결국 연결이 작동되어 실행될 때 시간 초과가 충분히 길게 설정된 경우 메시지가 전달됩니다. . 사용자는 megaco : cancel / 2를 명시 적으로 호출하여 연결에 대한 모든 메시지를 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee80008193ca8beab002b82928ea575e05d44fd" translate="yes" xml:space="preserve">
          <source>When constructing a segment of a &lt;code&gt;utf&lt;/code&gt; type, &lt;code&gt;Value&lt;/code&gt; must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;Value&lt;/code&gt; is outside the allowed ranges. The size of the resulting binary segment depends on the type or &lt;code&gt;Value&lt;/code&gt;, or both:</source>
          <target state="translated">&lt;code&gt;utf&lt;/code&gt; 유형 의 세그먼트를 구성 할 때 &lt;code&gt;Value&lt;/code&gt; 는 0..16 # D7FF 또는 16 # E000 .... 16 # 10FFFF 범위의 정수 여야합니다. &lt;code&gt;Value&lt;/code&gt; 가 허용 된 범위를 벗어나 면 &lt;code&gt;badarg&lt;/code&gt; 예외 와 함께 구성이 실패 합니다. 결과 이진 세그먼트의 크기는 type 또는 &lt;code&gt;Value&lt;/code&gt; 또는 둘 다 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2dfba87ba5340bf590a9719ae92123f1780ed535" translate="yes" xml:space="preserve">
          <source>When constructing binaries, &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; can be any Erlang expression. However, for syntactical reasons, both &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</source>
          <target state="translated">바이너리를 구성 할 때 &lt;code&gt;Value&lt;/code&gt; 및 &lt;code&gt;Size&lt;/code&gt; 는 Erlang 식일 수 있습니다. 그러나 구문상의 이유로 표현식이 단일 리터럴 또는 변수 이상의 것으로 구성된 경우 &lt;code&gt;Value&lt;/code&gt; 과 &lt;code&gt;Size&lt;/code&gt; 모두 괄호로 묶어야합니다. 다음은 컴파일러 구문 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a4d4be88f085f6842045d6bb85ffd60f1c5e2495" translate="yes" xml:space="preserve">
          <source>When constructing binaries, if the size &lt;code&gt;N&lt;/code&gt; of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the &lt;code&gt;N&lt;/code&gt; least significant bits are put into the binary.</source>
          <target state="translated">이진을 구성 할 때 정수 세그먼트 의 크기 &lt;code&gt;N&lt;/code&gt; 이 주어진 정수를 포함하기에 너무 작은 경우 정수의 최상위 비트는 자동으로 버리고 이진 에는 &lt;code&gt;N&lt;/code&gt; 개의 최하위 비트 만 넣습니다.</target>
        </trans-unit>
        <trans-unit id="ed7c4511bca13fde6765438ddbde809cac5d3478" translate="yes" xml:space="preserve">
          <source>When constructing, a literal string can be given followed by one of the UTF types, for example: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; which is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">구성 할 때 리터럴 문자열 뒤에 UTF 유형 중 하나를 지정할 수 있습니다 (예 : &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt; 구문 설탕 임) &amp;gt;&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="14ed84f016fc083dab3c16b2cd6e8fe5dee14cdb" translate="yes" xml:space="preserve">
          <source>When creating a record to be used in a select/match operation, you want most of the fields to have the value &quot;_&quot;. The easiest and fastest way to do that is as follows:</source>
          <target state="translated">선택 / 일치 작업에 사용할 레코드를 만들 때 대부분의 필드에 &quot;_&quot;값을 갖기를 원합니다. 가장 쉽고 빠른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0be878ceb74375986a99208578a50205223bc154" translate="yes" xml:space="preserve">
          <source>When creating a system using Erlang/OTP, the simplest way is to install Erlang/OTP somewhere, install the application-specific code somewhere else, and then start the Erlang runtime system, making sure the code path includes the application-specific code.</source>
          <target state="translated">Erlang / OTP를 사용하여 시스템을 작성할 때 가장 간단한 방법은 Erlang / OTP를 어딘가에 설치하고 다른 곳에 응용 프로그램 특정 코드를 설치 한 다음 Erlang 런타임 시스템을 시작하여 코드 경로에 응용 프로그램 특정 코드가 포함되어 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9a48110445b8b431b0a819b4efed940d95979f9" translate="yes" xml:space="preserve">
          <source>When creating test suites, it is strongly recommended to not create dependencies between test cases, that is, letting test cases depend on the result of previous test cases. There are various reasons for this, such as, the following:</source>
          <target state="translated">테스트 스위트를 작성할 때 테스트 케이스간에 종속성을 작성하지 않는 것이 좋습니다. 즉, 테스트 케이스가 이전 테스트 케이스의 결과에 의존하게하십시오. 다음과 같은 여러 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cf28e2e1bf20fe1af4eb848b0d0a7d334f0f8b" translate="yes" xml:space="preserve">
          <source>When debugging a process with the functions of this module, the process generates &lt;strong&gt;system_events&lt;/strong&gt;, which are then treated in the debug function. For example, &lt;code&gt;trace&lt;/code&gt; formats the system events to the terminal.</source>
          <target state="translated">이 모듈의 기능으로 프로세스를 디버깅 할 때 프로세스는 &lt;strong&gt;system_events를&lt;/strong&gt; 생성 한 다음 디버그 기능에서 처리합니다. 예를 들어, &lt;code&gt;trace&lt;/code&gt; 은 시스템 이벤트를 터미널로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="f636b27b7770791a083db3563a557efb2923ba0e" translate="yes" xml:space="preserve">
          <source>When decoding &lt;code&gt;property_group()&lt;/code&gt; or &lt;code&gt;property_groups()&lt;/code&gt;, those property parameter constructs that cannot be decoded (either because of decode error or because they are unknown), will be returned as a two-tuple. The first element of which will be the (undecoded) property parameter and the other the actual reason. This means that the caller of this function has to expect not only sdp-records, but also this two-tuple construct.</source>
          <target state="translated">&lt;code&gt;property_group()&lt;/code&gt; 또는 &lt;code&gt;property_groups()&lt;/code&gt; 디코딩 할 때 ( 디코딩 오류로 인해 또는 알 수 없기 때문에) 디코딩 할 수없는 속성 매개 변수 구문은 2 튜플로 반환됩니다. 첫 번째 요소는 (비 경제적) 속성 매개 변수이고 다른 하나는 실제 이유입니다. 이것은이 함수의 호출자가 sdp-records뿐만 아니라이 2 개의 튜플 구조도 예상해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="17f3e727c9b04040e7e330882d55b9758d892ab6" translate="yes" xml:space="preserve">
          <source>When decoding a type that uses an extensible set constraint, it is always possible that the value in field &lt;code&gt;UNIQUE&lt;/code&gt; is unknown (that is, the type has been encoded with a later version of the ASN.1 specification). The unencoded data is then returned wrapped in a tuple as follows:</source>
          <target state="translated">확장 가능한 세트 제약 조건을 사용하는 형식을 디코딩 할 때 &lt;code&gt;UNIQUE&lt;/code&gt; 필드의 값을 알 수없는 경우가 있습니다 (즉, 형식이 이후 버전의 ASN.1 사양으로 인코딩되었습니다). 인코딩되지 않은 데이터는 다음과 같이 튜플에 싸여 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="15c1a9e3a07dbc42bbebe73b1a8cb57a2a65f591" translate="yes" xml:space="preserve">
          <source>When decoding binaries from untrusted sources, consider using &lt;code&gt;binary_to_term/2&lt;/code&gt; to prevent Denial of Service attacks.</source>
          <target state="translated">신뢰할 수없는 소스에서 바이너리를 디코딩 할 때는 &lt;code&gt;binary_to_term/2&lt;/code&gt; 를 사용하여 서비스 거부 공격을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="d0e0e586b31755d07f5d7b42305304a2d4527232" translate="yes" xml:space="preserve">
          <source>When decoding, optional fields will be omitted from the map:</source>
          <target state="translated">디코딩시 선택적 필드는 맵에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="e2aad35acaab6959e7cb6145c3615cfd817ae41a" translate="yes" xml:space="preserve">
          <source>When describing a set of functions (that is, a module, a part of a module, or an application), executing in a process and wanting to use a ddll-driver, we use the term &lt;strong&gt;user&lt;/strong&gt;. A process can have many users (different modules needing the same driver) and many processes running the same code, making up many &lt;strong&gt;users&lt;/strong&gt; of a driver.</source>
          <target state="translated">프로세스에서 실행되고 ddll 드라이버를 사용하려는 일련의 기능 (즉, 모듈, 모듈의 일부 또는 응용 프로그램)을 설명 할 때는 &lt;strong&gt;user&lt;/strong&gt; 라는 용어를 &lt;strong&gt;사용&lt;/strong&gt; 합니다. 프로세스에는 많은 사용자 (동일한 드라이버가 필요한 다른 모듈)와 동일한 코드를 실행하는 많은 프로세스가있을 수 있으며 많은 &lt;strong&gt;사용자&lt;/strong&gt; 가 드라이버를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d599e465efb7551b80d5232a1bfe503d0d783500" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="translated">Erlang / OTP로 개발할 때는 일반적으로 개별 기능을 호출 할 수 있는 대화식 쉘 ( &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Erlang 시작&lt;/a&gt; 참조)에서 프로그램을 테스트합니다 . 시스템 정보, ets 및 mnesia 테이블 등을 검사하기위한 그래픽 &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;디버거&lt;/a&gt; 및 &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;옵저버 도구&lt;/a&gt; 와 같은 다양한 도구도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf2dfb99c11e0b6eebdf245aebada381fb9ab39" translate="yes" xml:space="preserve">
          <source>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option &lt;code&gt;local&lt;/code&gt; and global tracing with option &lt;code&gt;global&lt;/code&gt; (or no option), and so on.</source>
          <target state="translated">트레이스를 비활성화 할 때 옵션은 함수에 설정된 트레이스 유형과 일치해야합니다. 즉, 옵션 &lt;code&gt;global&lt;/code&gt; 옵션 (또는 옵션 없음) 등을 사용하여 &lt;code&gt;local&lt;/code&gt; 및 전역 추적 옵션으로 로컬 추적을 사용 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8e262a7b92cfd57af3c5fc673b211db44e0d61d2" translate="yes" xml:space="preserve">
          <source>When doing &lt;code&gt;make install&lt;/code&gt; and the default installation prefix is used, relative symbolic links will be created from &lt;code&gt;/usr/local/bin&lt;/code&gt; to all public Erlang/OTP executables in &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt;. The installation phase will try to create relative symbolic links as long as &lt;code&gt;--bindir&lt;/code&gt; and the Erlang bin directory, located under &lt;code&gt;--libdir&lt;/code&gt;, both have &lt;code&gt;--exec-prefix&lt;/code&gt; as prefix. Where &lt;code&gt;--exec-prefix&lt;/code&gt; defaults to &lt;code&gt;--prefix&lt;/code&gt;. &lt;code&gt;--prefix&lt;/code&gt;, &lt;code&gt;--exec-prefix&lt;/code&gt;, &lt;code&gt;--bindir&lt;/code&gt;, and &lt;code&gt;--libdir&lt;/code&gt; are all arguments that can be passed to &lt;code&gt;configure&lt;/code&gt;. One can force relative, or absolute links by passing &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; as arguments to &lt;code&gt;make&lt;/code&gt; during the install phase. Note that such a request might cause a failure if the request cannot be satisfied.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 수행 할 때 기본 설치 접두사가 사용되면 &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt; 의 모든 공용 Erlang / OTP 실행 파일에 대한 상대 기호 링크가 &lt;code&gt;/usr/local/bin&lt;/code&gt; 에서 작성됩니다 . 설치 단계에서는 &lt;code&gt;--bindir&lt;/code&gt; 및 &lt;code&gt;--libdir&lt;/code&gt; 아래에있는 Erlang bin 디렉토리가 모두 &lt;code&gt;--exec-prefix&lt;/code&gt; 를 접두어 로 사용하는 한 상대 기호 링크를 작성하려고 합니다. 어디 &lt;code&gt;--exec-prefix&lt;/code&gt; 기본값을하는 &lt;code&gt;--prefix&lt;/code&gt; . &lt;code&gt;--prefix&lt;/code&gt; , &lt;code&gt;--exec-prefix&lt;/code&gt; , &lt;code&gt;--bindir&lt;/code&gt; 및 &lt;code&gt;--libdir&lt;/code&gt; 은 모두 &lt;code&gt;configure&lt;/code&gt; 위해 전달할 수있는 인수입니다.. 하나는 전달하여 상대 또는 절대 링크를 강제 할 수 &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; 인수하기로 &lt;code&gt;make&lt;/code&gt; 설치 단계에서. 요청을 충족시킬 수없는 경우 이러한 요청으로 인해 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2786f78387349e137e785c359068f69a038e2e9" translate="yes" xml:space="preserve">
          <source>When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file.</source>
          <target state="translated">테이블을 덤프 할 때 테이블에 대한 일부 정보가 덤프 시작시 헤더에 덤프됩니다. 이 정보에는 테이블 유형, 이름, 보호, 크기, 버전 및 이름이 지정된 테이블인지에 대한 데이터가 포함됩니다. 또한 파일에 추가 된 확장 정보에 대한 메모가 포함되어 있습니다. 파일에있는 개체 수 또는 파일에있는 헤더 및 레코드의 MD5 합계 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb8dc80e08844ad0426660bafbab7a03b0891ac" translate="yes" xml:space="preserve">
          <source>When editing normal text in text mode you can let Emacs reformat the text by the &lt;code&gt;fill-paragraph&lt;/code&gt; command. This command will not work for comments since it will treat the comment characters as words.</source>
          <target state="translated">텍스트 모드에서 일반 텍스트를 편집 할 때 Emacs가 &lt;code&gt;fill-paragraph&lt;/code&gt; 명령으로 텍스트를 다시 포맷하도록 할 수 있습니다 . 이 명령은 주석 문자를 단어로 취급하므로 주석에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="385563ac3b6af3039b39f79f5505ddf536cbbbf9" translate="yes" xml:space="preserve">
          <source>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a &lt;code&gt;badarg&lt;/code&gt; error.</source>
          <target state="translated">활성화하면 Erlang 시스템을 공격하는 데 사용할 수있는 데이터 디코딩을 방지합니다. 안전하지 않은 데이터를 수신하는 경우 &lt;code&gt;badarg&lt;/code&gt; 오류 로 인해 디코딩이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="7e911575fa07d922476972d70c313e02f9b293dc" translate="yes" xml:space="preserve">
          <source>When enabling an &lt;code&gt;Item&lt;/code&gt; that represents a group of processes, the &lt;code&gt;Item&lt;/code&gt; is enabled on all nodes added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">유효화되면 &lt;code&gt;Item&lt;/code&gt; 프로세스기를 나타내는 상기 &lt;code&gt;Item&lt;/code&gt; 첨가 모든 노드에서 사용되는 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="961f18823d723f8de73592aaed24463820242f21" translate="yes" xml:space="preserve">
          <source>When encoding action requests for one transaction, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When encoding action requests for several transactions, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">하나의 트랜잭션에 대한 조치 요청을 인코딩 할 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;action_reqs()&lt;/code&gt; 이어야합니다 . 여러 트랜잭션에 대한 조치 요청을 인코딩 할 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;[action_reqs()]&lt;/code&gt; 이어야합니다 . 목록의 각 요소는 하나의 트랜잭션의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="c3e08a1905a5b3e0dc65abec6d55dd6312a7226f" translate="yes" xml:space="preserve">
          <source>When evaluating a digit map, a state machine waits for timeouts and letters reported by megaco:report_digit_event/2. The length of the various timeouts are defined in the digit_map_value() record.</source>
          <target state="translated">숫자 맵을 평가할 때 상태 시스템은 megaco : report_digit_event / 2에 의해보고 된 시간 종료 및 문자를 기다립니다. 다양한 시간 종료의 길이는 digit_map_value () 레코드에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3c6596324fcf3c283be7c0b3555d1b46a28bd6" translate="yes" xml:space="preserve">
          <source>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</source>
          <target state="translated">식을 평가할 때 우선 순위가 가장 높은 연산자가 먼저 평가됩니다. 우선 순위가 동일한 연산자는 연관성에 따라 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1250bb19a7c4cde6aa87a09dc8b61c235001dd61" translate="yes" xml:space="preserve">
          <source>When executing in an emulator thread, it is &lt;strong&gt;very important&lt;/strong&gt; that you unlock &lt;strong&gt;all&lt;/strong&gt; locks you have locked before letting the thread out of your control; otherwise you are &lt;strong&gt;very likely&lt;/strong&gt; to deadlock the whole emulator.</source>
          <target state="translated">에뮬레이터 스레드에서 실행하면은 &lt;strong&gt;매우 중요&lt;/strong&gt; 잠금을 해제하는 것이 &lt;strong&gt;모든&lt;/strong&gt; 당신이 당신의 통제 불능 스레드를시키기 전에 잠근 자물쇠를; 그렇지 않으면 당신은 &lt;strong&gt;매우 높다&lt;/strong&gt; 전체 에뮬레이터를 교착 상태에.</target>
        </trans-unit>
        <trans-unit id="3d063e02c2be3b7faac0250e13934a29e88d4cb4" translate="yes" xml:space="preserve">
          <source>When executing the &lt;code&gt;etop&lt;/code&gt; script, configuration parameters can be specified as command-line options, for example, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt;. The following configuration parameters exist for the tool:</source>
          <target state="translated">&lt;code&gt;etop&lt;/code&gt; 스크립트를 실행할 때 구성 매개 변수를 명령 행 옵션으로 지정할 수 있습니다 (예 : &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt; . 도구에 대한 다음 구성 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eb714d64a16860edb9466fdec5e16164e92007d" translate="yes" xml:space="preserve">
          <source>When executing within a CTH, all timetraps are shut off. So if your CTH never returns, the entire test run is stalled.</source>
          <target state="translated">CTH 내에서 실행하면 모든 타임 트랩이 종료됩니다. 따라서 CTH가 반환되지 않으면 전체 테스트 실행이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="407f5e1130fa4448aafc45d4cd243aed3adf7a96" translate="yes" xml:space="preserve">
          <source>When failing, all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">실패하면 세 함수 모두 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="40b47ee65ea9b082b925d4c051f321ad5844fe95" translate="yes" xml:space="preserve">
          <source>When fragments are added or deleted, &lt;code&gt;Mnesia&lt;/code&gt; automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field &lt;code&gt;Attr&lt;/code&gt; is used. This feature makes it possible to colocate records automatically in different tables to the same node. &lt;code&gt;foreign_key&lt;/code&gt; defaults to &lt;code&gt;undefined&lt;/code&gt;. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</source>
          <target state="translated">조각이 추가되거나 삭제되면 &lt;code&gt;Mnesia&lt;/code&gt; 는이 테이블을 참조하는 외래 키가있는 모든 조각화 된 테이블에 작업을 자동으로 전파합니다. 액세스 할 조각을 판별하기 위해 레코드 키를 사용하는 대신 필드 &lt;code&gt;Attr&lt;/code&gt; 의 값 이 사용됩니다. 이 기능을 사용하면 다른 테이블의 레코드를 동일한 노드에 자동으로 배치 할 수 있습니다. &lt;code&gt;foreign_key&lt;/code&gt; 의 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다. 그러나 외래 키가 다른 것으로 설정되면 다른 조각화 속성의 기본값이 외래 테이블의 실제 조각화 속성과 동일한 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="333f980f252538f0da8f8c81fee6306212deb2e4" translate="yes" xml:space="preserve">
          <source>When generating the &lt;code&gt;relup&lt;/code&gt; file, &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures that there is only one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and that it is the last instruction in the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 는 하나의 &lt;code&gt;restart_emulator&lt;/code&gt; 명령 만 있고 &lt;code&gt;relup&lt;/code&gt; 파일 의 마지막 명령 인지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="80c099bc81dcbffa43792d0bf735abab5b902a73" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;code&gt;ssh&lt;/code&gt; subsystem for daemons, use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Replaces ssh_daemon_channel) instead.</source>
          <target state="translated">데몬에 대한 &lt;code&gt;ssh&lt;/code&gt; 하위 시스템을 구현할 때는 대신 -behaviour &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (ssh_daemon_channel 대체)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6478258292a96422b7f4fde5f2a8507d5b2f75a" translate="yes" xml:space="preserve">
          <source>When implementing a client subsystem handler, use &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">클라이언트 서브 시스템 핸들러를 구현할 때 대신 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0817fdff736a7fb006dde9156f2e254a826ee1a2" translate="yes" xml:space="preserve">
          <source>When importing MIBs, ensure that the imported MIBs as well as the importing MIB are compiled using the same version of the SNMP-compiler.</source>
          <target state="translated">MIB를 가져올 때 가져온 MIB와 가져 오는 MIB가 동일한 버전의 SNMP 컴파일러를 사용하여 컴파일되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4d86af8d65c195f9b07f8aefb0aff8be5ef9554d" translate="yes" xml:space="preserve">
          <source>When inputting data using sql_query/[2,3] the values will always be in string format as they are part of an SQL-query. Example:</source>
          <target state="translated">sql_query / [2,3]을 사용하여 데이터를 입력 할 때 값은 SQL-query의 일부이므로 항상 문자열 형식입니다. 예:</target>
        </trans-unit>
        <trans-unit id="38a61084660618420bf57899c1e143bbdfd319d4" translate="yes" xml:space="preserve">
          <source>When installing a release, the application specifications are automatically updated before evaluating the &lt;code&gt;relup&lt;/code&gt; script. Thus, no instructions are needed in the &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">릴리스를 설치할 때 &lt;code&gt;relup&lt;/code&gt; 스크립트 를 평가하기 전에 응용 프로그램 스펙이 자동으로 업데이트됩니다 . 따라서 &lt;code&gt;.appup&lt;/code&gt; 파일 에는 지침이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ab36faf918b13f9650566e7cda312d53b2b058cb" translate="yes" xml:space="preserve">
          <source>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</source>
          <target state="translated">에뮬레이터의 계측이 활성화되면 에뮬레이터는 더 많은 메모리를 사용하고 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="613cb49badd27e8334ffae06e691a346b0c3156f" translate="yes" xml:space="preserve">
          <source>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given the following:</source>
          <target state="translated">프로세스의 데이터를 해석 할 때 익명 함수 오브젝트 (fun)에 다음이 제공됨을 아는 것이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a1e6f2364e14a4f8731ff03ef081c6c153b8e5" translate="yes" xml:space="preserve">
          <source>When it comes to pure encode/decode performance, it turns out that:</source>
          <target state="translated">순수한 인코딩 / 디코딩 성능과 관련하여 다음과 같이 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="fdb9a1b728613db78be0dae343529296127017c3" translate="yes" xml:space="preserve">
          <source>When it is guaranteed that all trace messages are delivered to the tracer up to the point that &lt;code&gt;Tracee&lt;/code&gt; reached at the time of the call to &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;, then a &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; message is sent to the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</source>
          <target state="translated">이 모든 추적 메시지가 있다는 점에 추적까지 전달되는 것을 보장되면 &lt;code&gt;Tracee&lt;/code&gt; 가 호출 시점에 도달 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; , 다음 &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; 메시지의 발신자로 전송됩니다 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6efe9163e0ae5672fec51b923b5f0a3fddf22450" translate="yes" xml:space="preserve">
          <source>When libraries and escripts are expanded, the names of their contained applications will be displayed. Double click on an application name to launch an application window.</source>
          <target state="translated">라이브러리 및 escript가 확장되면 포함 된 응용 프로그램의 이름이 표시됩니다. 응용 프로그램 이름을 두 번 클릭하여 응용 프로그램 창을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8ec607efa45c31ad1357f20a7d66c6c141bb9cf2" translate="yes" xml:space="preserve">
          <source>When linking:</source>
          <target state="translated">연결할 때 :</target>
        </trans-unit>
        <trans-unit id="d08f2f18c94939c7eb816f59b144c9e39119701b" translate="yes" xml:space="preserve">
          <source>When loading, function &lt;code&gt;load/2&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; when any instance of the driver is present. Thus, if a driver is waiting to get unloaded (because of open ports), it simply changes state to no longer need unloading.</source>
          <target state="translated">로드 할 때 드라이버 인스턴스가 있으면 함수 &lt;code&gt;load/2&lt;/code&gt; 가 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 따라서 드라이버가 열린 포트로 인해 언로드되기를 기다리는 경우 더 이상 언로드 할 필요가없는 상태로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="65fab8b9afb79981ea75c2c9f545c0487fc0a213" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt;erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="translated">실행중인 시스템에서 메모리 사용량을 볼 때 정보를 얻는 가장 기본적인 기능은 &lt;code&gt;erlang:memory()&lt;/code&gt; 입니다. 시스템의 현재 메모리 사용량을 반환합니다. &lt;code&gt;instrument(3)&lt;/code&gt; 는 메모리가 사용되는 위치를보다 자세히 분석하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc0303546ea4a5cee3b6a223eb3288b9d2ea037" translate="yes" xml:space="preserve">
          <source>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</source>
          <target state="translated">매크로가 표현식에서 확장되면 매크로 호출은 따옴표로 묶거나 괄호로 묶지 않고 매크로 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6e14461d99df8d7f5bd6dbaee93c610c2ce18da3" translate="yes" xml:space="preserve">
          <source>When many types (or another ASN.1 entity) only differ in some minor cases, but the structure of the types is similar, only one general type can be defined and the differences can be supplied through parameters.</source>
          <target state="translated">많은 유형 (또는 다른 ASN.1 엔티티)이 일부 사소한 경우에만 다르지만 유형의 구조가 유사하면 하나의 일반 유형 만 정의 할 수 있으며 차이는 매개 변수를 통해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3e3f53fcfe03af37581eeb29d3a1f8a21d06868" translate="yes" xml:space="preserve">
          <source>When matched against a term, both &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</source>
          <target state="translated">용어에 대해 일치 할 때, 모두 &lt;code&gt;Pattern1&lt;/code&gt; 과 &lt;code&gt;Pattern2&lt;/code&gt; 용어에 대해 일치합니다. 이 기능의 기본 개념은 용어의 재구성을 피하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70ef1970aabf29043b85da367698cefcc4f383ae" translate="yes" xml:space="preserve">
          <source>When matching &lt;code&gt;Value&lt;/code&gt;, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</source>
          <target state="translated">&lt;code&gt;Value&lt;/code&gt; 와 일치하는 경우 value는 변수 또는 정수 또는 부동 소수점 리터럴이어야합니다. 식은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="919226a6786be88542935b4ae72b62f44ea75480" translate="yes" xml:space="preserve">
          <source>When matching strings, the following is a valid pattern:</source>
          <target state="translated">문자열을 일치시킬 때 다음은 유효한 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d1c82c501be92ba824ae89344ef75c4d9af9bf67" translate="yes" xml:space="preserve">
          <source>When megaco fails to send the reply (see &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;), for whatever reason.</source>
          <target state="translated">megaco가 어떤 이유로 든 회신을 보내지 못하는 경우 ( &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="acae380ca138d49866a8d2225bb9fdf2866a8ef8" translate="yes" xml:space="preserve">
          <source>When messages are &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header.</source>
          <target state="translated">메시지되면 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; 하고, &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; 사용되는 버전 번호 (131)를 포함하는 첫 번째 바이트는 메일 헤더를 따르는 측면에서 생략된다. 이는 배포 헤더의 버전 번호로 버전 번호가 암시되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="787e404397583f253bb775c283cf222bacb2db6c" translate="yes" xml:space="preserve">
          <source>When monitoring is requested, and a corresponding &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt; would be returned, the function instead returns a tuple &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; and the process then gets a monitor message later, when the driver gets loaded. The monitor message to expect is described in the function description of &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모니터링이 요청되고 해당 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 또는 &lt;code&gt;{ok, pending_process}&lt;/code&gt; 가 반환되면 함수는 대신 튜플 &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; 를 반환 하고 프로세스는 나중에 모니터 메시지를받습니다. 드라이버가로드됩니다. 예상되는 모니터 메시지는 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 의 기능 설명에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb7c3fa2502fdd9d0754635086f8f9899582889" translate="yes" xml:space="preserve">
          <source>When multiple test specification files are specified at startup (either with &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; or &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; either executes one test run per specification file, or joins the files and performs all tests within one single test run. The first behavior is the default one. The latter requires that start flag/option &lt;code&gt;join_specs&lt;/code&gt; is provided, for example, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt;.</source>
          <target state="translated">시작시 여러 테스트 스펙 파일이 지정되면 ( &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; 또는 &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt; ) &lt;code&gt;Common Test&lt;/code&gt; 는 하나의 테스트 실행을 실행합니다. 사양 파일 당 또는 파일을 결합하고 단일 테스트 실행 내에서 모든 테스트를 수행합니다. 첫 번째 동작이 기본 동작입니다. 후자는 시작 플래그 / 옵션 &lt;code&gt;join_specs&lt;/code&gt; 를 제공해야합니다 (예 : &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0d4d379ce1acc3e58649f3f6e5610dec08b734cc" translate="yes" xml:space="preserve">
          <source>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function &lt;code&gt;Resolve&lt;/code&gt; is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</source>
          <target state="translated">새 노드가 네트워크에 추가되면 이미 존재하는 전체적으로 등록 된 이름을 알려줍니다. 네트워크는 또한 새로 연결된 노드의 모든 글로벌 이름을 알려줍니다. 이름 충돌이 발견되면 &lt;code&gt;Resolve&lt;/code&gt; 함수 가 호출됩니다. 그 목적은 어떤 pid가 올바른지 결정하는 것입니다. 함수가 충돌하거나 pid 중 하나 이외의 것을 반환하면 이름이 등록되지 않은 것입니다. 이 함수는 각 이름 충돌마다 한 번씩 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="78f8bd0d1896a4dff8f44b290b2a56e3f9fcb215" translate="yes" xml:space="preserve">
          <source>When one node wants to connect to another node it starts with a &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</source>
          <target state="translated">한 노드가 다른 노드에 연결하려고 할 때 노드가 수신하는 분배 포트를 얻기 위해 노드가 상주하는 호스트의 EPMD에 대한 &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; 요청으로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="733930eec7fc5b747c5c2817c8d2e79c6f4e243c" translate="yes" xml:space="preserve">
          <source>When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.</source>
          <target state="translated">이러한 옵션 변경 중 하나가 최상위 수준에서 발생하면 (즉, 하위 패턴 괄호 안에 있지 않은 경우) 변경 사항은 다음 패턴의 나머지 부분에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b86cd46910a6aa214f7f42e5ee8633b337f649a0" translate="yes" xml:space="preserve">
          <source>When opening an existing wrap log, it is not necessary to supply a value for option &lt;code&gt;Size&lt;/code&gt;, but any supplied value must equal the current log size, otherwise the tuple &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; is returned.</source>
          <target state="translated">기존 랩 로그를 열 때 옵션 &lt;code&gt;Size&lt;/code&gt; 값을 제공 할 필요는 없지만 제공된 값은 현재 로그 크기와 같아야합니다. 그렇지 않으면 튜플 &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; 이 (가) 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7edf9e74339539f6cc3b3080ee90687bd35019" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;global&lt;/code&gt; is speciified, the &lt;code&gt;capture&lt;/code&gt; specification affects each match separately, so that:</source>
          <target state="translated">옵션 &lt;code&gt;global&lt;/code&gt; 을 지정하면 &lt;code&gt;capture&lt;/code&gt; 스펙이 각 일치에 개별적으로 영향을 미치므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35779093faa3e10fba6141595e13648b564ea182" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;unicode&lt;/code&gt; is specified, the regular expression is to be specified as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise as any valid &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 옵션 이 지정되면 정규식은 유효한 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; , 그렇지 않으면 유효한 &lt;code&gt;iodata()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="55a165a455c0fbb6c5fe22fe047dc9f316e166c5" translate="yes" xml:space="preserve">
          <source>When ordered to shut down, the &lt;code&gt;gen_statem&lt;/code&gt; then calls callback function &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt;.</source>
          <target state="translated">종료 명령을 &lt;code&gt;gen_statem&lt;/code&gt; 은 콜백 함수 &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a6c0af6f0c64d162765f0e344a6e84e0addaa2a2" translate="yes" xml:space="preserve">
          <source>When packaging code using &lt;code&gt;systools&lt;/code&gt;, the code for each application is placed in a separate directory, &lt;code&gt;lib/Application-Vsn&lt;/code&gt;, where &lt;code&gt;Vsn&lt;/code&gt; is the version number.</source>
          <target state="translated">&lt;code&gt;systools&lt;/code&gt; 를 사용하여 코드를 패키징 할 때 각 애플리케이션의 코드는 별도의 디렉토리 인 &lt;code&gt;lib/Application-Vsn&lt;/code&gt; 에 있으며 여기서 &lt;code&gt;Vsn&lt;/code&gt; 은 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="9753680bda30c348a14a4334e6baee4da1b60e94" translate="yes" xml:space="preserve">
          <source>When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails.</source>
          <target state="translated">알 수없는 체계 (구성표 기본값에없는 체계)로 URI를 구문 분석 할 때 포트 번호를 제공해야합니다. 그렇지 않으면 구문 분석이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="710f52128840cdac154a523eb3c58c2968f8b895" translate="yes" xml:space="preserve">
          <source>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally.</source>
          <target state="translated">MIB의 일부가 구현되면 MIB을 다시 컴파일하고 기본 기능을 사용하여 계속합니다. 이 방법을 사용하면 SNMP 에이전트를 점진적으로 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91864f69e3643249c414a5ca6b0b38fdf0614ca" translate="yes" xml:space="preserve">
          <source>When performance is of highest priority and you are interested in a limited part of the ASN.1 encoded message before deciding what to do with the rest of it, an option is to decode only this small part. The situation can be a server that has to decide the addressee of a message. The addressee can be interested in the entire message, but the server can be a bottleneck that you want to spare any unnecessary load.</source>
          <target state="translated">성능이 최우선 순위이고 ASN.1로 인코딩 된 메시지의 제한된 부분에 관심이있는 경우 나머지 부분으로 수행 할 작업을 결정하려면이 작은 부분 만 디코딩하는 옵션이 있습니다. 상황은 메시지의 수신자를 결정해야하는 서버 일 수 있습니다. 수신자는 전체 메시지에 관심이있을 수 있지만 서버는 불필요한로드를 아끼려는 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f8fec10d66dd9849d5606b35c3bae4eb0e24b0" translate="yes" xml:space="preserve">
          <source>When performing a GC, this is the max number of cache entries that will be deleted from the cache.</source>
          <target state="translated">GC를 수행 할 때 이것은 캐시에서 삭제 될 최대 캐시 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="c12910634b83422602cdf82ac5e1d4a0b08ca569" translate="yes" xml:space="preserve">
          <source>When positioning in a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, caution must be taken to set the position on a correct character boundary. For details, see &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 으로 파일에 배치 할 때는 올바른 문자 경계에 위치를 설정해야합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1edc83622335984eb1eafacb2b7c60d225676ad9" translate="yes" xml:space="preserve">
          <source>When reading and writing to Unicode-aware entities, like a file opened for Unicode translation, you probably want to format text strings using the functions in the &lt;code&gt;io&lt;/code&gt; module or the &lt;code&gt;io_lib&lt;/code&gt; module. For backward compatibility reasons, these functions do not accept any list as a string, but require a special &lt;strong&gt;translation modifier&lt;/strong&gt; when working with Unicode texts. The modifier is &lt;code&gt;t&lt;/code&gt;. When applied to control character &lt;code&gt;s&lt;/code&gt; in a formatting string, it accepts all Unicode code points and expects binaries to be in UTF-8:</source>
          <target state="translated">유니 코드 변환을 위해 열린 파일과 같이 유니 코드 인식 엔터티를 읽고 쓸 때 &lt;code&gt;io&lt;/code&gt; 모듈 또는 &lt;code&gt;io_lib&lt;/code&gt; 모듈 의 함수를 사용하여 텍스트 문자열 의 서식을 지정할 수 있습니다. 이전 버전과의 호환성을 위해 이러한 함수는 목록을 문자열로 허용하지 않지만 유니 코드 텍스트로 작업 할 때는 특수 &lt;strong&gt;변환 수정자가&lt;/strong&gt; 필요합니다 . 수정자는 &lt;code&gt;t&lt;/code&gt; 입니다. 제어 문자에 적용 할 때 &lt;code&gt;s&lt;/code&gt; 서식 문자열에, 그것은 UTF-8로 모든 유니 코드 포인트와 예상하는 바이너리를 허용합니다</target>
        </trans-unit>
        <trans-unit id="d8c1dd8823b82718c750f6e4752dce919973fd1c" translate="yes" xml:space="preserve">
          <source>When receiving data from untrusted sources, use option &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt;.</source>
          <target state="translated">신뢰할 수없는 소스에서 데이터를 수신 할 때 옵션 &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="caaa8dcd0a5b73778282496efd8b85cdbc96febe" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler clears the latest received alarm with id &lt;code&gt;AlarmId&lt;/code&gt;.</source>
          <target state="translated">이 이벤트를 수신하면 기본 단순 핸들러는 id &lt;code&gt;AlarmId&lt;/code&gt; 로 최근 수신 된 알람을 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="9e62ca61b001221600279b3875635215766f5030" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler stores the alarm. &lt;code&gt;AlarmId&lt;/code&gt; identifies the alarm and is used when the alarm is cleared.</source>
          <target state="translated">이 이벤트를 수신하면 기본 단순 핸들러는 알람을 저장합니다. &lt;code&gt;AlarmId&lt;/code&gt; 는 경보를 식별하며 경보가 해제 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cab9fe9e9b48ff6bfb268655c0f4e10837898a9b" translate="yes" xml:space="preserve">
          <source>When recompiling with &lt;code&gt;gcc&lt;/code&gt;, use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; to get better warnings. Try to find a similar flag if you use another compiler.</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 로 재 컴파일 할 때 더 나은 경고를 받으려면 플래그 &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; 를 사용하십시오 . 다른 컴파일러를 사용하는 경우 유사한 플래그를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="5fa55ded95f5c996f7f21886e99692b06c59dfaf" translate="yes" xml:space="preserve">
          <source>When recursing and building a list, it is important to ensure that you attach the new elements to the beginning of the list. In this way, you will build &lt;strong&gt;one&lt;/strong&gt; list, not hundreds or thousands of copies of the growing result list.</source>
          <target state="translated">목록을 되풀이하고 작성할 때 새 요소를 목록의 시작 부분에 첨부해야합니다. 이러한 방식으로, 증가하는 결과 목록의 수백 또는 수천 사본이 아닌 &lt;strong&gt;하나의&lt;/strong&gt; 목록을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d8bab5f0a38ad7351ef92518566a8a66e14c70a0" translate="yes" xml:space="preserve">
          <source>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</source>
          <target state="translated">제한된 쉘 모드가 활성화되거나 비활성화되면 노드에서 시작된 새 작업이 각각 제한 또는 일반 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5c2049b6ccaf60623aba58c7816db28baba978c3" translate="yes" xml:space="preserve">
          <source>When run as above (this will take some time), the measurement process is done as follows:</source>
          <target state="translated">위와 같이 실행하면 (시간이 다소 소요됨) 측정 프로세스는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bcae0656877ffa6ebb4290ed9f508d93d062de30" translate="yes" xml:space="preserve">
          <source>When run on Linux, &lt;code&gt;cpu_sup&lt;/code&gt; assumes that the &lt;code&gt;/proc&lt;/code&gt; file system is present and accessible by &lt;code&gt;cpu_sup&lt;/code&gt;. If it is not, &lt;code&gt;cpu_sup&lt;/code&gt; will terminate.</source>
          <target state="translated">Linux에서 실행될 때 &lt;code&gt;cpu_sup&lt;/code&gt; 은 &lt;code&gt;/proc&lt;/code&gt; 파일 시스템이 존재하고 &lt;code&gt;cpu_sup&lt;/code&gt; 에 의해 액세스 가능 하다고 가정합니다 . 그렇지 않으면 &lt;code&gt;cpu_sup&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf54f8998c8d68cc207a24a295ffc4553d6eff1" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;high&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; are selected for execution. Notice however that this does &lt;strong&gt;not&lt;/strong&gt; mean that no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; can run when processes are running on priority &lt;code&gt;high&lt;/code&gt;. When using multiple schedulers, more processes can be running in parallel than processes on priority &lt;code&gt;high&lt;/code&gt;. That is, a &lt;code&gt;low&lt;/code&gt; and a &lt;code&gt;high&lt;/code&gt; priority process can execute at the same time.</source>
          <target state="translated">우선 순위가 &lt;code&gt;high&lt;/code&gt; 실행 가능 프로세스가 존재하는 경우 우선 순위가 &lt;code&gt;low&lt;/code&gt; 거나 &lt;code&gt;normal&lt;/code&gt; 프로세스 가 실행되도록 선택 되지 않습니다 . 그러나 이것이 프로세스가 우선 순위가 &lt;code&gt;high&lt;/code&gt; 상태에서 실행될 때 우선 순위가 &lt;code&gt;low&lt;/code&gt; 거나 &lt;code&gt;normal&lt;/code&gt; 프로세스를 실행할 수 없음을 의미 하지는 &lt;strong&gt;않습니다&lt;/strong&gt; . 여러 스케줄러를 사용하는 경우 우선 순위가 &lt;code&gt;high&lt;/code&gt; 프로세스보다 많은 프로세스를 병렬로 실행할 수 있습니다 . 즉, &lt;code&gt;low&lt;/code&gt; 우선 순위 프로세스 와 &lt;code&gt;high&lt;/code&gt; 우선 순위 프로세스가 동시에 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac375c5ce5278df5f7742eba36c446680185abe" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;max&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;high&lt;/code&gt; are selected for execution. As with priority &lt;code&gt;high&lt;/code&gt;, processes on lower priorities can execute in parallel with processes on priority &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">우선 순위 &lt;code&gt;max&lt;/code&gt; 에서 실행 가능한 프로세스가 존재하는 경우 우선 순위 &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; 또는 &lt;code&gt;high&lt;/code&gt; 에 대한 프로세스 가 실행되도록 선택 되지 않습니다 . 우선 순위가 &lt;code&gt;high&lt;/code&gt; 경우 와 같이 우선 순위 가 낮은 프로세스는 우선 순위가 &lt;code&gt;max&lt;/code&gt; 인 프로세스와 동시에 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="680e4c2820f1533afc4212ad58a52897fa7b6ea9" translate="yes" xml:space="preserve">
          <source>When running SMP erlang on a multi-core machine the &quot;throughput&quot; is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner.</source>
          <target state="translated">다중 코어 시스템에서 SMP erlang을 실행할 때 &quot;처리량&quot;이 상당히 높습니다. mstone1 테스트는 극단적 인 테스트이지만 재진입 형 플렉스 스캐너를 사용하여 얻은 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb8603cea37568d4ea95955c8c7cd5ad79e8fceb" translate="yes" xml:space="preserve">
          <source>When running a distributed system with two or more participating nodes, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, &lt;code&gt;mnesia:start()&lt;/code&gt; can also be used either from the Erlang shell or another program.</source>
          <target state="translated">참여 노드가 두 개 이상인 분산 시스템을 실행할 때는 각 참여 노드에서 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 함수를 실행해야합니다. 이것은 일반적으로 임베디드 환경에서 부트 스크립트의 일부입니다. 테스트 환경 또는 대화식 환경에서 &lt;code&gt;mnesia:start()&lt;/code&gt; 쉘 또는 다른 프로그램에서 mnesia : start ()를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e9a6705c8969bac7cd69e2170ef9d9d0ac1c6a" translate="yes" xml:space="preserve">
          <source>When running in &lt;code&gt;utf8&lt;/code&gt; mode, functions &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; never return raw filenames. To return all filenames including raw filenames, use functions &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; 모드 에서 실행될 때 , &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; 함수는 원시 파일 이름을 리턴하지 않습니다. 원시 파일 이름을 포함한 모든 파일 이름을 반환하려면 &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfdc638646c31aefd08c7b469c60f917c3f883df" translate="yes" xml:space="preserve">
          <source>When running on OSs lacking support for monotonic time, &lt;code&gt;heart&lt;/code&gt; is susceptible to system clock adjustments of more than &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds. When this happens, &lt;code&gt;heart&lt;/code&gt; times out and tries to reboot the system. This can occur, for example, if the system clock is adjusted automatically by use of the Network Time Protocol (NTP).</source>
          <target state="translated">단조 시간에 대한 지원이 부족의 OS에서 실행하면, &lt;code&gt;heart&lt;/code&gt; 이상의 시스템 클럭 조정에 취약 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 의 초. 이 경우 &lt;code&gt;heart&lt;/code&gt; 시간 초과되어 시스템을 재부팅하려고합니다. 예를 들어 NTP (Network Time Protocol)를 사용하여 시스템 시계가 자동으로 조정되는 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ecb6729e649e0c2e3875d3412d7df6f9ff2fc1b" translate="yes" xml:space="preserve">
          <source>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</source>
          <target state="translated">Windows에서 실행할 때 포트 프로그램을 생성 할 때 새 콘솔 창이 작성되지 않습니다. 이 옵션은 다른 플랫폼에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63b602ea12cff6b347850ec520a992d2e4051e4a" translate="yes" xml:space="preserve">
          <source>When selecting data from a table, all data types are returned from the database to the ODBC driver as an ODBC data type. The tables below shows the mapping between those data types and what is returned by the Erlang API.</source>
          <target state="translated">테이블에서 데이터를 선택하면 모든 데이터 유형이 데이터베이스에서 ODBC 데이터 유형으로 ODBC 드라이버로 리턴됩니다. 아래 표는 이러한 데이터 유형과 Erlang API가 리턴 한 데이터 간의 맵핑을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5028404a77ebb05ae66aa4cdb0300c35b354c2d2" translate="yes" xml:space="preserve">
          <source>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</source>
          <target state="translated">포트로 데이터를 보낼 때. 포트는 딥 목록을 이해하므로 목록을 포트로 보내기 전에 목록을 병합 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6655794aac8234bda9f3cc8627542cf28e39cd7" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;user_reply()&lt;/code&gt;). When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;[user_reply()]&lt;/code&gt;). Each element of the list is part of one transaction.</source>
          <target state="translated">메시지에서 하나의 트랜잭션을 보낼 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;action_reqs()&lt;/code&gt; 이어야합니다 ( &lt;code&gt;UserReply&lt;/code&gt; 는 &lt;code&gt;user_reply()&lt;/code&gt; ). 메시지로 여러 트랜잭션을 보낼 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;[action_reqs()]&lt;/code&gt; 여야합니다 ( &lt;code&gt;UserReply&lt;/code&gt; 는 &lt;code&gt;[user_reply()]&lt;/code&gt; ). 목록의 각 요소는 하나의 트랜잭션의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="342bdd47df4ec30e4e5a4ebaa64afc70c7b8eea1" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">하나의 트랜잭션으로 메시지를 보낼 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;action_reqs()&lt;/code&gt; 이어야합니다 . 메시지로 여러 트랜잭션을 보낼 때 &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;[action_reqs()]&lt;/code&gt; 이어야합니다 . 목록의 각 요소는 하나의 트랜잭션의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="75b19f5e353d16bcbf308a2928e10b271ad77a7b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt;logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 런타임 시스템 은 최대 힙 크기에 도달했을 때 프로세스에 대한 세부 사항을 포함하는 &lt;code&gt;logger&lt;/code&gt; 를 통해 오류 이벤트를 로깅합니다 . 한도에 도달 할 때마다 하나의 로그 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a9f29c7c04f56d28d9864f8634905c97f0d23f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system sends an untrappable exit signal with reason &lt;code&gt;kill&lt;/code&gt; to the process if the maximum heap size is reached. The garbage collection that triggered the &lt;code&gt;kill&lt;/code&gt; is not completed, instead the process exits as soon as possible. When set to &lt;code&gt;false&lt;/code&gt;, no exit signal is sent to the process, instead it continues executing.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 런타임 시스템은 최대 힙 크기에 도달하면 이유 &lt;code&gt;kill&lt;/code&gt; 과 함께 처리 할 수 없는 종료 신호를 프로세스에 보냅니다 . 트리거 가비지 수집 &lt;code&gt;kill&lt;/code&gt; , 가능한 한 빨리 대신 프로세스가 종료가 완료되지 않습니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 종료 신호가 프로세스로 전송되지 않고 대신 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1535dfcd1ada0e5df2bfdd93f8582a8fb9db2211" translate="yes" xml:space="preserve">
          <source>When set, informs the peer to use &lt;code&gt;{IP, Port}&lt;/code&gt; as the primary address of the local endpoint for the association specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">설정된 경우, 피어에게 &lt;code&gt;{IP, Port}&lt;/code&gt; 를 &lt;code&gt;assoc_id&lt;/code&gt; 로 지정된 연관에 대한 로컬 엔드 포인트의 기본 주소로 사용하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="a09fa3690c8e86bcc1ad44fbac6fe4381cfc8c36" translate="yes" xml:space="preserve">
          <source>When set, requests that the local endpoint uses the value specified by &lt;code&gt;adaptation_ind&lt;/code&gt; as the Adaptation Indication parameter for establishing new associations. For details, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">설정되면 로컬 엔드 포인트가 새 연관을 설정하기 위해 &lt;code&gt;adaptation_ind&lt;/code&gt; 로 지정된 값을 Adaptation Indication 매개 변수로 사용하도록 요청합니다 . 세부 사항은 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35268e3a52547204a88309f957a19dbdd29a75e6" translate="yes" xml:space="preserve">
          <source>When setting up a trace, the following features can also be activated:</source>
          <target state="translated">추적을 설정할 때 다음 기능을 활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc86d8be157ab5b84c3a61f949941d9549419fe9" translate="yes" xml:space="preserve">
          <source>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then &lt;code&gt;trans_req_maxsize&lt;/code&gt;, in which case the stored transactions are sent first in a separate message and the reply in another message.</source>
          <target state="translated">무언가가 전송 될 때 트리거가 응답 트랜잭션이고 응답의 추가 크기이고 모든 요청이 &lt;code&gt;trans_req_maxsize&lt;/code&gt; 보다 크지 않은 경우 모든 것이 하나의 메시지로 압축됩니다 .이 경우 저장된 트랜잭션은 별도의 메시지로 먼저 전송됩니다 다른 메시지의 답장.</target>
        </trans-unit>
        <trans-unit id="5c6669a85ba52eabed1bcac71536c7df178c1e61" translate="yes" xml:space="preserve">
          <source>When sorting or merging files, only the first of a sequence of terms that compare equal (&lt;code&gt;==&lt;/code&gt;) is output if this option is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">파일을 정렬하거나 병합 할 때이 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 같음 ( &lt;code&gt;==&lt;/code&gt; ) 을 비교하는 첫 번째 항만 출력됩니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 로 , 동일하게 비교되는 모든 항이 출력됨을 나타냅니다. 정렬을 위해 파일을 검사 할 때이 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으면 연속 항 쌍이 같은지 비교하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8c34b332981b8e474e02ef63bcc500fd0757ef2" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.</source>
          <target state="translated">&lt;code&gt;stand_alone&lt;/code&gt; 을 시작 하면 pid 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b66f134384d3cc9012959c5c579272f12c941335" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can used.</source>
          <target state="translated">&lt;code&gt;stand_alone&lt;/code&gt; 을 시작 하면 pid 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9910d3d66f8237ea301a1cc0a52c4d81c8b1682" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt;.</source>
          <target state="translated">때 시작 &lt;code&gt;stand_alone&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a4ce6035e3ae59d7f18987449985901fd92e494f" translate="yes" xml:space="preserve">
          <source>When started, the node waits for all nodes specified by &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; and &lt;code&gt;sync_nodes_optional&lt;/code&gt; to come up. When all nodes are up, or when all mandatory nodes are up and the time specified by &lt;code&gt;sync_nodes_timeout&lt;/code&gt; has elapsed, all applications start. If not all mandatory nodes are up, the node terminates.</source>
          <target state="translated">시작되면 노드는 &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; 및 &lt;code&gt;sync_nodes_optional&lt;/code&gt; 으로 지정된 모든 노드가 나타날 때까지 기다립니다 . 모든 노드가 작동 중이거나 모든 필수 노드가 &lt;code&gt;sync_nodes_timeout&lt;/code&gt; 지정된 시간 이 경과하면 모든 응용 프로그램이 시작됩니다. 모든 필수 노드가 작동하지 않으면 노드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4f35884d86e4f1c2ac96377ac4d8d3d8958cc289" translate="yes" xml:space="preserve">
          <source>When started, the supervisor does not start any child processes. Instead, all child processes are added dynamically by calling:</source>
          <target state="translated">시작되면 감독자는 자식 프로세스를 시작하지 않습니다. 대신, 모든 하위 프로세스는 다음을 호출하여 동적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="af782a2bcb2a4b2a362bed6616a129bcc6a72b52" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;Mnesia&lt;/code&gt;, a &lt;code&gt;.LOG&lt;/code&gt; file called &lt;code&gt;LATEST.LOG&lt;/code&gt; is created and placed in the database directory. This file is used by &lt;code&gt;Mnesia&lt;/code&gt; to log disc-based transactions. This includes all transactions that write at least one record in a table that is of storage type &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;disc_only_copies&lt;/code&gt;. The file also includes all operations that manipulate the schema itself, such as creating new tables. The log format can vary with different implementations of &lt;code&gt;Mnesia&lt;/code&gt;. The &lt;code&gt;Mnesia&lt;/code&gt; log is currently implemented in the standard library module &lt;code&gt;disk_log&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">시작할 때 &lt;code&gt;Mnesia&lt;/code&gt; 을 하는 &lt;code&gt;.LOG&lt;/code&gt; 의 파일이라고 &lt;code&gt;LATEST.LOG&lt;/code&gt; 가 작성되어 데이터베이스 디렉토리에 배치됩니다. 이 파일은 &lt;code&gt;Mnesia&lt;/code&gt; 에서 디스크 기반 트랜잭션을 기록 하는 데 사용됩니다 . 여기에는 스토리지 유형 &lt;code&gt;disc_copies&lt;/code&gt; 또는 &lt;code&gt;disc_only_copies&lt;/code&gt; 인 테이블에 하나 이상의 레코드를 쓰는 모든 트랜잭션이 포함됩니다 . 파일에는 새 테이블 작성과 같이 스키마 자체를 조작하는 모든 조작도 포함됩니다. 로그 형식은 &lt;code&gt;Mnesia&lt;/code&gt; 구현에 따라 다를 수 있습니다 . &lt;code&gt;Mnesia&lt;/code&gt; 의 로그는 현재 표준 라이브러리 모듈에서 구현 &lt;code&gt;disk_log&lt;/code&gt; 에서 &lt;code&gt;Kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbcc2618bb75c573fc25f8a846a8fe36e4ed8763" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;prim_app&lt;/code&gt; as defined above, the application controller calls the following callback functions before &lt;code&gt;application:start(prim_app)&lt;/code&gt; returns a value:</source>
          <target state="translated">위에서 정의 &lt;code&gt;prim_app&lt;/code&gt; 를 시작 하면 응용 프로그램 제어기는 &lt;code&gt;application:start(prim_app)&lt;/code&gt; 가 값을 리턴 하기 전에 다음 콜백 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4cd4f1a6e7e43123fc3118e6461ff8abe900204f" translate="yes" xml:space="preserve">
          <source>When starting Erlang in embedded mode, it is assumed that exactly one system configuration file is used, named &lt;code&gt;sys.config&lt;/code&gt;. This file is to be located in &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the Erlang/OTP root installation directory and &lt;code&gt;Vsn&lt;/code&gt; is the release version.</source>
          <target state="translated">임베디드 모드에서 Erlang을 시작할 때 &lt;code&gt;sys.config&lt;/code&gt; 라는 정확히 하나의 시스템 구성 파일이 사용된다고 가정합니다 . 이 파일은 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 에 있습니다. 여기서 &lt;code&gt;$ROOT&lt;/code&gt; 는 Erlang / OTP 루트 설치 디렉토리이고 &lt;code&gt;Vsn&lt;/code&gt; 은 릴리스 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b5ddbb5d78d831c78a317496e7e2a2d2c40076a3" translate="yes" xml:space="preserve">
          <source>When starting Erlang/OTP using the boot script, all applications from the &lt;code&gt;.rel&lt;/code&gt; file are automatically loaded and started:</source>
          <target state="translated">부팅 스크립트를 사용하여 Erlang / OTP를 시작하면 &lt;code&gt;.rel&lt;/code&gt; 파일의 모든 응용 프로그램 이 자동으로로드되고 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b604ec38ae2b79479f9ec0cb1378442b00d5b576" translate="yes" xml:space="preserve">
          <source>When starting a primary application with included applications, the primary application is started the normal way, that is:</source>
          <target state="translated">포함 된 응용 프로그램으로 기본 응용 프로그램을 시작할 때 기본 응용 프로그램은 일반적인 방식으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ed0f727403d7e975b13ca3d05489c37f1a495f5a" translate="yes" xml:space="preserve">
          <source>When starting an Erlang node, the default behaviour is that all log events on level &lt;code&gt;notice&lt;/code&gt; or more severe, are logged to the terminal via the default handler. To also log info events, you can either change the primary log level to &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">Erlang 노드를 시작할 때 기본 동작은 레벨 &lt;code&gt;notice&lt;/code&gt; 또는 더 심각한 레벨의 모든 로그 이벤트 가 기본 핸들러를 통해 터미널에 로깅되는 것입니다. 정보 이벤트도 기록하려면 기본 로그 레벨을 &lt;code&gt;info&lt;/code&gt; 로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="d267d7fc52461e3316cc2f612f2db868d98e7a72" translate="yes" xml:space="preserve">
          <source>When starting external programs on Solaris, the system call &lt;code&gt;vfork&lt;/code&gt; is used in preference to &lt;code&gt;fork&lt;/code&gt; for performance reasons, although it has a history of being less robust. If there are problems using &lt;code&gt;vfork&lt;/code&gt;, setting environment variable &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; to any value causes &lt;code&gt;fork&lt;/code&gt; to be used instead.</source>
          <target state="translated">Solaris에서 외부 프로그램을 시작할 때 성능 저하 를 위해 &lt;code&gt;fork&lt;/code&gt; 대신 시스템 호출 &lt;code&gt;vfork&lt;/code&gt; 가 기본적 으로 사용 되지만 덜 강력합니다. &lt;code&gt;vfork&lt;/code&gt; 사용에 문제가있는 경우 환경 변수 &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; 를 임의의 값으로 설정하면 &lt;code&gt;fork&lt;/code&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eba2c0286e1f80a8b6d2f783a23106deb0b2394" translate="yes" xml:space="preserve">
          <source>When starting snmpa_local_db it always tries to open an existing database. If &lt;code&gt;false&lt;/code&gt;, and some errors occur, a new database is created instead. If &lt;code&gt;true&lt;/code&gt;, an existing file will be repaired. If &lt;code&gt;force&lt;/code&gt;, the table will be repaired even if it was properly closed.</source>
          <target state="translated">snmpa_local_db를 시작할 때 항상 기존 데이터베이스를 열려고 시도합니다. 경우 &lt;code&gt;false&lt;/code&gt; , 일부 오류가 발생, 새로운 데이터베이스 대신 생성됩니다. 경우 &lt;code&gt;true&lt;/code&gt; , 기존 파일이 복구됩니다. 경우 &lt;code&gt;force&lt;/code&gt; , 테이블이 제대로 닫히지 않은 경우에도 복구됩니다.</target>
        </trans-unit>
        <trans-unit id="c1c86792af0c1fc90a287c8a9c5bae64d2165932" translate="yes" xml:space="preserve">
          <source>When starting the &lt;code&gt;Inets&lt;/code&gt; application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request.</source>
          <target state="translated">&lt;code&gt;Inets&lt;/code&gt; 응용 프로그램을 시작할 때 기본 프로파일에 대한 관리자 프로세스가 시작됩니다. 프로파일을 명시 적으로 사용하지 않는이 API의 기능은 기본 프로파일에 액세스합니다. 프로필은 프록시 옵션, 쿠키 및 둘 이상의 요청에 적용될 수있는 기타 옵션을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="cd05c53bfd126defe810f3a187a5cf1551a34b96" translate="yes" xml:space="preserve">
          <source>When starting the flex scanner a port to the linked in driver is created. This port has to be owned by a process. This process must not die. If it does the port will also terminate. Therefor:</source>
          <target state="translated">플렉스 스캐너를 시작할 때 연결된 드라이버에 대한 포트가 생성됩니다. 이 포트는 프로세스가 소유해야합니다. 이 프로세스는 죽지 않아야합니다. 그렇게하면 포트도 종료됩니다. 그 때문에:</target>
        </trans-unit>
        <trans-unit id="6d9ab8ee43c8cd162c696fc7f8c9882054157b9c" translate="yes" xml:space="preserve">
          <source>When starting this release, three things must be specified:</source>
          <target state="translated">이 릴리스를 시작할 때 세 가지 사항을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5e8349f617cc19cb94845c2b5a433d10397c346" translate="yes" xml:space="preserve">
          <source>When starting with Unicode, one often stumbles over some common issues. This section describes some methods of dealing with Unicode data.</source>
          <target state="translated">유니 코드로 시작할 때 종종 몇 가지 일반적인 문제가 발생합니다. 이 섹션에서는 유니 코드 데이터를 처리하는 몇 가지 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">중지 된 경우 응용 프로그램이 계속로드됩니다.</target>
        </trans-unit>
        <trans-unit id="6bcf5a7b78ff49a4689ff94e30fd3cc2e19a3b3d" translate="yes" xml:space="preserve">
          <source>When streaming to the calling processes using option &lt;code&gt;{self, once}&lt;/code&gt;, the first message has an extra element, that is, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt;. This is the process id to be used as an argument to &lt;code&gt;httpc:stream_next/1&lt;/code&gt; to trigger the next message to be sent to the calling process.</source>
          <target state="translated">&lt;code&gt;{self, once}&lt;/code&gt; 옵션을 사용하여 호출 프로세스로 스트리밍 할 때 첫 번째 메시지에는 추가 요소, 즉 &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt; 있습니다. 다음 프로세스가 호출 프로세스로 전송되도록 트리거 하기 위해 &lt;code&gt;httpc:stream_next/1&lt;/code&gt; 에 대한 인수로 사용되는 프로세스 ID 입니다.</target>
        </trans-unit>
        <trans-unit id="715fec6e13a0abfe20ee555a6324b0802bfff927" translate="yes" xml:space="preserve">
          <source>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</source>
          <target state="translated">문자열 또는 이진 개체가 레지스트리에 저장 될 때 몇 가지 간단한 지침을 따르는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9879a39d7048a88467f14f974e9672e4f402cb5c" translate="yes" xml:space="preserve">
          <source>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</source>
          <target state="translated">로컬 디스크에서 테이블을 강제로로드하면 로컬 노드가 작동 중지되고 원격 복제본이 활성 상태 인 동안 복제 된 테이블에서 수행 된 모든 작업이 손실됩니다. 이로 인해 데이터베이스가 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9c626bcd30b7f8ecf9ddc823a493152c649dd7" translate="yes" xml:space="preserve">
          <source>When tests start, &lt;code&gt;Common Test&lt;/code&gt; Master displays information to console about the involved nodes. &lt;code&gt;Common Test&lt;/code&gt; Master also reports when tests finish, successfully or unsuccessfully. If connection is lost to a node, the test on that node is considered finished. &lt;code&gt;Common Test&lt;/code&gt; Master does not attempt to re-establish contact with the failing node.</source>
          <target state="translated">테스트가 시작되면 &lt;code&gt;Common Test&lt;/code&gt; Master는 관련 노드에 대한 정보를 콘솔에 표시합니다. &lt;code&gt;Common Test&lt;/code&gt; Master는 또한 테스트가 성공적으로 완료되거나 실패한시기를보고합니다. 노드와의 연결이 끊어지면 해당 노드의 테스트가 완료된 것으로 간주됩니다. &lt;code&gt;Common Test&lt;/code&gt; Master는 실패한 노드와의 연결을 다시 설정하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0e15e615fec1bfe62b38c3373f94e44765c1055" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="translated">때 &lt;code&gt;'CHANGE'&lt;/code&gt; 메시지가 수신 된 당신이 호출 할 때 기존 오프셋 시간을 검색 할 수 없습니다 보장 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;'CHANGE'&lt;/code&gt; 메시지 를 받기 전에 &lt;code&gt;erlang:time_offset()&lt;/code&gt; 호출 할 때 시간 오프셋의 변경을 관찰 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="389c67d197284147820c964a147bf25f89168f89" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the state callback name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;handle_event_function&lt;/code&gt; 가 , 국가가 어떤 용어와 상태 콜백 이름이 될 수 있습니다 것은 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . 이를 통해 원하는 상태 나 이벤트에 따라 쉽게 분기 할 수 있습니다. 어떤 이벤트를 어떤 상태에서 처리하는지주의해서 실수로 무한 바쁜 통화 루프를 생성하는 이벤트를 연기하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="7c771ceccfcda3b957b4a4bb8455365fc3a48832" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the state callback name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;state_functions&lt;/code&gt; 를 , 상태는 원자이어야하고 상태 콜백 이름으로 사용된다; &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 이것은 상태 이름에 따라 &lt;code&gt;gen_statem&lt;/code&gt; 엔진 분기 로 한 함수에서 특정 상태에 대한 모든 코드를 함께 배치합니다 . 콜백 함수는 사실 참고 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 상태 이름을 만드는 &lt;code&gt;terminate&lt;/code&gt; 모드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bd23a20d36b333c46d925b8fd401de86fe841dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">때 &lt;code&gt;Addr&lt;/code&gt; 값은 포트 번호를 포함하지 않는,의 값 &lt;code&gt;intAgentUDPPort&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22814bccf02caaf2232de9c743157f0b7348ee14" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_tar&lt;/code&gt; 코어가 예를 들어 &lt;code&gt;Data&lt;/code&gt; 조각을 쓰려고 할 때 &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b84a2f0be01530772a20ac645af7f54b604dbf79" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fprof&lt;/code&gt; server is stopped the collected raw profile data is lost.</source>
          <target state="translated">하면 &lt;code&gt;fprof&lt;/code&gt; 의 서버가 중지 수집 된 원시 프로파일 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="e37d26017c607226a4f422562f10e0bd5f4835e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; 와 함께 실행될 때 이러한 함수는 상태가 변경 될 때마다 인수 &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; 와 함께 호출 됩니다. 이 경우 리턴 될 수 있는 &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 에 대한 제한 사항 이 있습니다. &lt;strong&gt;상태 입력 호출&lt;/strong&gt; 이 이벤트가 아니므로 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 이 허용 되지 않으므로 연기 할 이벤트가 없으므로 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; 이 허용되지 않습니다. &lt;strong&gt;상태 입력 호출을&lt;/strong&gt; 사용 &lt;strong&gt;하면&lt;/strong&gt; 이벤트 소비 및 생성 방식에 영향을 미치지 않아야합니다. 이 통화에서 상태를 변경할 수도 없습니다. 당신이 반환해야합니다 &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; 와 &lt;code&gt;NextState =/= State&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt; &lt;code&gt;gen_statem&lt;/code&gt; 이 충돌합니다. 실제로 &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; 를 사용할 수는 있지만 새로운 &lt;strong&gt;상태 입력 호출로&lt;/strong&gt; 즉시 다시 &lt;strong&gt;호출&lt;/strong&gt; 되므로 이상한 반복 방법이되므로 더 좋은 방법이 있습니다. 얼랭의 루프. &lt;code&gt;NewData&lt;/code&gt; 를 업데이트하지 않고 루프 종료 조건이 있거나 &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; 또는 &lt;code&gt;repeat_state_and_data&lt;/code&gt; 를 사용하면 무한 루프가됩니다! &lt;strong&gt;상태 입력 호출&lt;/strong&gt; 에서 상태를 변경할 수 &lt;code&gt;keep_state_and_data&lt;/code&gt; &lt;code&gt;{keep_state,...}&lt;/code&gt; , &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; 또는 keep_state_and_data 를 사용하는 것이 좋습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88a1846d28e7d4cd1692423afe0396a4f961fecf" translate="yes" xml:space="preserve">
          <source>When the Cover analysis is ready, Cover is stopped and all Cover compiled modules are &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt;. The code for &lt;code&gt;channel&lt;/code&gt; is now loaded as usual from a &lt;code&gt;.beam&lt;/code&gt; file in the current path.</source>
          <target state="translated">Cover 분석이 준비되면 Cover가 중지되고 모든 Cover 컴파일 된 모듈이 &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt; 됩니다. &lt;code&gt;channel&lt;/code&gt; 코드 는 이제 현재 경로 의 &lt;code&gt;.beam&lt;/code&gt; 파일에서 평소와 같이로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e678693029d9376dee27d1a3e9cecfc3eb0694b" translate="yes" xml:space="preserve">
          <source>When the Erlang function &lt;code&gt;t/1&lt;/code&gt; was applied to an Xref server loaded with the current version of OTP, the returned value was close to 84 (percent). This means that the number of indirectly used modules is approximately six times greater when using the module graph. So the answer to the above stated question is that it is definitely worth while using the function graph for this particular analysis. Finally, note that in the presence of unresolved calls, the graphs may be incomplete, which means that there may be indirectly used modules that do not show up.</source>
          <target state="translated">Erlang 함수 &lt;code&gt;t/1&lt;/code&gt; 이 현재 버전의 OTP로로드 된 외부 참조 서버에 적용 되었을 때 반환 된 값은 84 (퍼센트)에 가깝습니다. 이것은 모듈 그래프를 사용할 때 간접적으로 사용되는 모듈의 수가 약 6 배 더 크다는 것을 의미합니다. 따라서 위에서 언급 한 질문에 대한 답은이 특정 분석에 함수 그래프를 사용하는 동안 가치가 있다는 것입니다. 마지막으로, 해결되지 않은 호출이있는 경우 그래프가 불완전 할 수 있으며, 표시되지 않은 간접적으로 사용되는 모듈이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef14100f6973eec9a2da0c5aac1b652a8be07c43" translate="yes" xml:space="preserve">
          <source>When the Erlang mode is correctly installed, it is automatically activated when a file ending in &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; is opened in Emacs.</source>
          <target state="translated">Erlang 모드가 올바르게 설치되면 Emacs 에서 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 로 끝나는 파일을 열 때 자동으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="064005753816c68987f62de4089ac63432bbee7f" translate="yes" xml:space="preserve">
          <source>When the Erlang runtime system is automatically started from the &lt;code&gt;S75otp.system&lt;/code&gt; script, the &lt;code&gt;TERM&lt;/code&gt; environment variable must be set. The following is a minimal setting:</source>
          <target state="translated">Erlang 런타임 시스템이 &lt;code&gt;S75otp.system&lt;/code&gt; 스크립트 에서 자동으로 시작 되면 &lt;code&gt;TERM&lt;/code&gt; 환경 변수를 설정해야합니다. 다음은 최소 설정입니다.</target>
        </trans-unit>
        <trans-unit id="e452b2fde57d622fa0997d4cb19e28e4a65d9107" translate="yes" xml:space="preserve">
          <source>When the MGC receives its first message, the Service Change Request, the Megaco application will automatically establish the connection by using the MG MID found in the message header as remote mid.</source>
          <target state="translated">MGC가 첫 번째 메시지 인 서비스 변경 요청을 수신하면 Megaco 애플리케이션은 메시지 헤더에서 찾은 MG MID를 원격 중간으로 사용하여 자동으로 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0bc1904c9d30ade44fccd694ce928f2cb4a5ad23" translate="yes" xml:space="preserve">
          <source>When the MIB definition work is finished, there are two major issues left.</source>
          <target state="translated">MIB 정의 작업이 완료되면 두 가지 주요 문제가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e36ed72ceac42895c73ec727502a81f2596dcdf" translate="yes" xml:space="preserve">
          <source>When the SASL application is started, it adds a Logger handler that formats and writes these reports, as specified in the &lt;code&gt;configuration parameters for SASL&lt;/code&gt;.</source>
          <target state="translated">SASL 애플리케이션이 시작되면 SASL &lt;code&gt;configuration parameters for SASL&lt;/code&gt; 지정된대로 이러한 보고서를 형식화하고 기록하는 로거 핸들러를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3b73a5fb29f56921e69c0ac4a2cd6ca545f386dd" translate="yes" xml:space="preserve">
          <source>When the SNMP manager has crashed, the dependent client application has to wait for the SNMP manager to be restarted before it can &lt;strong&gt;reconnect&lt;/strong&gt;.</source>
          <target state="translated">SNMP 관리자가 충돌 한 경우 종속 클라이언트 응용 프로그램은 SNMP 관리자가 다시 &lt;strong&gt;연결&lt;/strong&gt; 되기 전에 다시 시작하기를 기다려야합니다 .</target>
        </trans-unit>
        <trans-unit id="a13e96b0328435d455e574296b3ea29ea96cf675" translate="yes" xml:space="preserve">
          <source>When the agent receives a request, it keeps the request ID for one second after the response is sent. If the agent receives another request with the same request ID during this time, from the same IP address and UDP port, that request will be discarded. This mechanism has nothing to do with the function &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt;.</source>
          <target state="translated">에이전트는 요청을 받으면 응답이 전송 된 후 1 초 동안 요청 ID를 유지합니다. 이 시간 동안 에이전트가 동일한 IP 주소 및 UDP 포트에서 동일한 요청 ID로 다른 요청을 수신하면 해당 요청은 삭제됩니다. 이 메커니즘은 &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; 함수와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c76ffb17b2706d88d3e12e2091f84905c555d5ff" translate="yes" xml:space="preserve">
          <source>When the agent receives the same get-request as above, a call will be made to &lt;code&gt;generic_access(get,&lt;/code&gt;'&lt;code&gt;IPADR')&lt;/code&gt;.</source>
          <target state="translated">에이전트가 위와 동일한 get-request를 받으면 &lt;code&gt;generic_access(get,&lt;/code&gt; ' &lt;code&gt;IPADR')&lt;/code&gt; 이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a93278d10a2e49a183a4771ee8ba18b8f11a4c78" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="translated">비동기 작업이 완료되면 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; 드라이버 입력 기능이 호출됩니다. 경우 &lt;code&gt;ready_async&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; 드라이버 항목에서, &lt;code&gt;async_free&lt;/code&gt; 의 기능을 대신이라고합니다.</target>
        </trans-unit>
        <trans-unit id="45fda767b9fff4af850e8e6b34bac5b879c78132" translate="yes" xml:space="preserve">
          <source>When the choice of directories in the code path is &lt;code&gt;strict&lt;/code&gt;, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; is explicitly added to the code path, the code server does not load files from &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">코드 경로에서 디렉토리 선택이 &lt;code&gt;strict&lt;/code&gt; 하면 코드 경로로 끝나는 디렉토리가 정확히 언급 된 디렉토리입니다. 예를 들어 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; 가 코드 경로에 명시 적으로 추가 된 경우 코드 서버는 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; 에서 파일을로드하지 않습니다. /mnesia-4.4.7/ebin .</target>
        </trans-unit>
        <trans-unit id="85eceed499c5d35cfe880d316d8beaf6cbb94efc" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 쪽 끝에서 실행중인 명령이 종료되면 다음 메시지를 보내 명령의 종료 상태를 반환 할 수 있습니다. &lt;code&gt;exit_status&lt;/code&gt; 가 0 이면 일반적으로 명령이 성공적으로 종료되었음을 의미합니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3d64a299ff94a9ee47249f94cefcc624dd35a6f" translate="yes" xml:space="preserve">
          <source>When the compiler encounters the module attribute &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; in a module &lt;code&gt;Mod&lt;/code&gt;, it calls &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; and compares the result with the set of functions actually exported from &lt;code&gt;Mod&lt;/code&gt;, and issues a warning if any callback function is missing.</source>
          <target state="translated">컴파일러가 &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; 모듈 속성을 발견하면 모듈에 &lt;code&gt;Mod&lt;/code&gt; , 그것은 호출 &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; 실제로에서 내 보낸 함수의 집합으로 결과를 비교 &lt;code&gt;Mod&lt;/code&gt; 문제는 콜백 기능이없는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="844a9525ff66b482554dce5aa81432bba7df925d" translate="yes" xml:space="preserve">
          <source>When the data has passed through an Ets table, &lt;code&gt;erts_debug:size/1&lt;/code&gt; and &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; return the same value. Sharing has been lost.</source>
          <target state="translated">데이터가 Ets 테이블을 통과하면 &lt;code&gt;erts_debug:size/1&lt;/code&gt; 및 &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; 은 동일한 값을 반환합니다. 공유가 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="0180fd29af0af06f5eb68c4a08485d210bd536c3" translate="yes" xml:space="preserve">
          <source>When the data is returned, we deallocate our data.</source>
          <target state="translated">데이터가 반환되면 데이터 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b841886acb544968ed7c8d220277846a17d2018c" translate="yes" xml:space="preserve">
          <source>When the driver has passed the &lt;code&gt;driver_entry&lt;/code&gt; over to the emulator, the driver is &lt;strong&gt;not&lt;/strong&gt; allowed to modify the &lt;code&gt;driver_entry&lt;/code&gt;.</source>
          <target state="translated">운전자가 통과 할 때 &lt;code&gt;driver_entry&lt;/code&gt; 을 에뮬레이터에 걸쳐, 드라이버가되어 &lt;strong&gt;있지&lt;/strong&gt; 수정 할 수 &lt;code&gt;driver_entry&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ff1b7d404a057ddcb6ce2d59d8b2bdb057597c3d" translate="yes" xml:space="preserve">
          <source>When the driver is implemented, one would preferably write an Erlang interface for the driver to be able to test the functionality of the driver separately. This interface can then be used by the distribution module, which will cover the details of the protocol from the &lt;code&gt;net_kernel&lt;/code&gt;.</source>
          <target state="translated">드라이버가 구현 될 때, 드라이버의 기능을 개별적으로 테스트 할 수 있도록 Erlang 인터페이스를 작성하는 것이 바람직하다. 이 인터페이스는 배포 모듈에서 사용할 수 있으며 &lt;code&gt;net_kernel&lt;/code&gt; 의 프로토콜 세부 사항을 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="4f7f8ef65dc76d982cfe0dc69232e4e5827bba12" translate="yes" xml:space="preserve">
          <source>When the driver is loaded. This callback must have a special name and inform the emulator of what callbacks are to be used by returning a pointer to a &lt;code&gt;ErlDrvEntry&lt;/code&gt; struct, which is to be properly filled in (see below).</source>
          <target state="translated">드라이버가로드 된 경우 이 콜백은 특수한 이름을 가져야하며 &lt;code&gt;ErlDrvEntry&lt;/code&gt; 구조체에 대한 포인터를 반환하여 콜백 사용에 대한 정보를 에뮬레이터에 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="68f883c088fbc777f98b15d9733f9e21c9a4e592" translate="yes" xml:space="preserve">
          <source>When the emulator is run with instrumentation, the &lt;code&gt;system&lt;/code&gt; value is more accurate, but memory directly allocated for &lt;code&gt;malloc&lt;/code&gt; (and friends) is still not part of the &lt;code&gt;system&lt;/code&gt; value. Direct calls to &lt;code&gt;malloc&lt;/code&gt; are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</source>
          <target state="translated">에뮬레이터를 계측으로 실행하면 &lt;code&gt;system&lt;/code&gt; 값이 더 정확하지만 &lt;code&gt;malloc&lt;/code&gt; (및 친구)에 직접 할당 된 메모리 는 여전히 &lt;code&gt;system&lt;/code&gt; 값의 일부가 아닙니다 . &lt;code&gt;malloc&lt;/code&gt; 에 대한 직접 호출 은 OS 별 런타임 라이브러리 및 드라이버 인터페이스에서 메모리 할당 기능을 사용하지 않는 사용자 구현 Erlang 드라이버에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="77fa82a9f2b1030c7423dea145244305c2d9ec50" translate="yes" xml:space="preserve">
          <source>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</source>
          <target state="translated">이진의 끝에 도달하고 두 번째 절이 일치하면 일치 컨텍스트는 단순히 버려집니다 (더 이상 참조가 없으므로 다음 가비지 수집에서 제거됨).</target>
        </trans-unit>
        <trans-unit id="6749f7e62fded072722b2a6ba9f855671542a797" translate="yes" xml:space="preserve">
          <source>When the external process connected to the port exits, a message of the form &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; is sent to the connected process, where &lt;code&gt;Status&lt;/code&gt; is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</source>
          <target state="translated">포트에 연결된 외부 프로세스가 종료되면 &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; 형식의 메시지가 연결된 프로세스로 전송되며, 여기서 &lt;code&gt;Status&lt;/code&gt; 는 외부 프로세스의 종료 상태입니다. 프로그램이 Unix에서 중단되면 쉘과 동일한 규칙 (128+ 신호)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4264b7112b0cfbe36495f0cf35a65dd07c402f" translate="yes" xml:space="preserve">
          <source>When the function &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; cannot be used, &lt;code&gt;Mnesia&lt;/code&gt; provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수없는 경우 &lt;code&gt;Mnesia&lt;/code&gt; 는 프로그래머에게 레코드와 패턴을 일치시키기위한 여러 기능을 제공합니다. 가장 유용한 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a19808ffaca3fd048abe14ac1422112fae7f8be" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt;, one can get information about when the driver is &lt;strong&gt;actually&lt;/strong&gt; loaded by using option &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt;.</source>
          <target state="translated">함수가 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 또는 &lt;code&gt;{ok, pending_process}&lt;/code&gt; 리턴하면 &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt; 옵션을 사용하여 드라이버가 &lt;strong&gt;실제로&lt;/strong&gt; 로드되는 시기에 대한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ba8ad7fadddd0bcf392a93e44763cd846c6e5a" translate="yes" xml:space="preserve">
          <source>When the indexed set is a set of subsets of a set X, we call x a &lt;strong id=&quot;family&quot;&gt;family of subsets&lt;/strong&gt; of X.</source>
          <target state="translated">인덱싱 된 집합이 집합 X의 하위 집합 집합 인 경우 xa &lt;strong id=&quot;family&quot;&gt;하위 집합&lt;/strong&gt; X를 X라고합니다.</target>
        </trans-unit>
        <trans-unit id="b2e8e9476aa05c51f4eed310e674f5ac07849f6f" translate="yes" xml:space="preserve">
          <source>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</source>
          <target state="translated">초기 메시지가 도착하면 전송 서비스는이를 다음과 같이 서비스 변경 요청과 함께 UserMod : handle_trans_request / 3를 호출하기 전에 자동으로 연결을 설정하고 UserMod : handle_connect / 2를 호출하는 프로토콜 엔진으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0b479e3b528c8dff428a540e36a91f070ee36f40" translate="yes" xml:space="preserve">
          <source>When the instrumentation function for the distributed table is called, the request should be forwarded to the table coordinator. The coordinator finds the requested information among the table holders and then returns the answer to the instrumentation function. The SNMP toolkit contains no support for coordination of tables since this must be independent of the implementation.</source>
          <target state="translated">분산 테이블의 인스 트루먼 테이션 기능이 호출되면 요청이 테이블 코디네이터로 전달되어야합니다. 코디네이터는 테이블 홀더 중에서 요청 된 정보를 찾은 후 인스 트루먼 테이션 기능에 대한 응답을 리턴합니다. SNMP 툴킷은 구현과 독립적이어야하므로 테이블 조정을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d4612fb76d339a555d7ce395426dfd7559ca7e3" translate="yes" xml:space="preserve">
          <source>When the logs are full, &lt;code&gt;run_erl&lt;/code&gt; deletes and reuses the oldest log file.</source>
          <target state="translated">로그가 가득 차면 &lt;code&gt;run_erl&lt;/code&gt; 은 가장 오래된 로그 파일을 삭제하고 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="981906d024a846c5ad60dd39439e2525942f2a29" translate="yes" xml:space="preserve">
          <source>When the message queue grows larger than this threshold, the handler switches to a mode in which it drops all new events that senders want to log. Dropping an event in this mode means that the call to the log function never results in a message being sent to the handler, but the function returns without taking any action. The handler keeps logging the events that are already in its message queue, and when the length of the message queue is reduced to a level below the threshold, synchronous or asynchronous mode is resumed. Notice that when the handler activates or deactivates drop mode, information about it is printed in the log.</source>
          <target state="translated">메시지 큐가이 임계 값보다 커지면 핸들러는 송신자가 로그하려는 모든 새 이벤트를 삭제하는 모드로 전환합니다. 이 모드에서 이벤트를 삭제하면 로그 함수 호출로 인해 메시지가 핸들러로 전송되지 않지만 조치를 취하지 않고 함수가 리턴됩니다. 핸들러는 메시지 큐에 이미있는 이벤트를 계속 로깅하며 메시지 큐 길이가 임계 값보다 낮은 레벨로 줄어들면 동기식 또는 비동기식 모드가 재개됩니다. 핸들러가 드롭 모드를 활성화하거나 비활성화 할 때 이에 대한 정보가 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="377865ca162dc01a005c1cf33711bbbcf3cf6d3a" translate="yes" xml:space="preserve">
          <source>When the modifier &lt;code&gt;l&lt;/code&gt; is specified, no detection of printable character lists takes place, for example:</source>
          <target state="translated">수정 자 &lt;code&gt;l&lt;/code&gt; 을 지정 하면 다음 과 같이 인쇄 가능한 문자 목록이 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28bc31ee472c6a6f71d309884c8eb89c306960b4" translate="yes" xml:space="preserve">
          <source>When the monitor is triggered a &lt;code&gt;'CHANGE'&lt;/code&gt; message is sent to the monitoring process. A &lt;code&gt;'CHANGE'&lt;/code&gt; message has the following pattern:</source>
          <target state="translated">모니터가 트리거되면 &lt;code&gt;'CHANGE'&lt;/code&gt; 메시지가 모니터링 프로세스로 전송됩니다. &lt;code&gt;'CHANGE'&lt;/code&gt; 메시지는 다음과 같은 패턴을 가지고 :</target>
        </trans-unit>
        <trans-unit id="a6576c399613f943fdf757c4457a0db8dddece67" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the reader groups limit, each scheduler has its own reader group. When the number of schedulers is larger than the reader groups limit, schedulers share reader groups. Shared reader groups degrade read lock and read unlock performance while many reader groups degrade write lock performance. So, the limit is a tradeoff between performance for read operations and performance for write operations. Each reader group consumes 64 byte in each read/write lock.</source>
          <target state="translated">스케줄러 수가 판독기 그룹 한계보다 작거나 같으면 각 스케줄러에는 고유 한 판독기 그룹이 있습니다. 스케줄러 수가 판독기 그룹 제한보다 큰 경우 스케줄러는 판독기 그룹을 공유합니다. 공유 리더 그룹은 읽기 잠금 및 읽기 잠금 해제 성능을 저하시키는 반면 많은 리더 그룹은 쓰기 잠금 성능을 저하시킵니다. 따라서 한계는 읽기 작업 성능과 쓰기 작업 성능 간의 균형입니다. 각 리더 그룹은 각 읽기 / 쓰기 잠금에서 64 바이트를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="36226219dde60c8da7ee7e2f3ead5fe94e62e1f9" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;maps&lt;/code&gt; is given, no &lt;code&gt;.hrl&lt;/code&gt; files will be generated. The rest of this section describes the behavior of the compiler when &lt;code&gt;maps&lt;/code&gt; is not used.</source>
          <target state="translated">옵션 &lt;code&gt;maps&lt;/code&gt; 이 제공되면 &lt;code&gt;.hrl&lt;/code&gt; 파일이 생성 되지 않습니다 . 이 섹션의 나머지 부분에서는 &lt;code&gt;maps&lt;/code&gt; 사용하지 않을 때의 컴파일러 동작에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="54a21311cf0fcf49981af7057a09551734c3f7b1" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="translated">&lt;code&gt;verify&lt;/code&gt; 옵션 이 &lt;code&gt;verify_peer&lt;/code&gt; 로 설정 되면 일반적인 x509-path 유효성 검사 외에 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 검사 가 수행됩니다. 검사가 실패하면 {bad_cert, hostname_check_failed} 오류가 경로 유효성 검사 fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; 으로 전파되어 &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API 의 모든 가능성을 사용하여 사용자 정의 검사를 수행 할 수 있습니다 . &lt;code&gt;server_name_indication&lt;/code&gt; 옵션 이 제공되면 해당 값 (DNS 이름)이 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 에 대한 &lt;code&gt;ReferenceID&lt;/code&gt; 로 사용 됩니다 . &lt;code&gt;server_name_indication&lt;/code&gt; 옵션이 제공 되지 않으면 &lt;code&gt;Host&lt;/code&gt; 인수는 서버 이름 표시 확장으로 사용됩니다. &lt;code&gt;Host&lt;/code&gt; 인수도에 사용될 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 체크하고 만약 &lt;code&gt;Host&lt;/code&gt; 인수가있다 &lt;code&gt;inet:ip_address()&lt;/code&gt; &lt;code&gt;ReferenceID&lt;/code&gt; 것이다 체크 사용을 &lt;code&gt;{ip, Host}&lt;/code&gt; 그렇지 &lt;code&gt;dns_id&lt;/code&gt; 는 대체 시스템으로 가정한다 &lt;code&gt;ip&lt;/code&gt; 실패하면.</target>
        </trans-unit>
        <trans-unit id="a93a77e10e8decc9a9a5af353d5ffa646066813a" translate="yes" xml:space="preserve">
          <source>When the port has been opened, the driver can be called. In the &lt;code&gt;pg_sync&lt;/code&gt; example, we do not have any data from the port, only the return value from the &lt;code&gt;port_control&lt;/code&gt;.</source>
          <target state="translated">포트가 열리면 드라이버를 호출 할 수 있습니다. 에서 &lt;code&gt;pg_sync&lt;/code&gt; 의 예를 들어, 우리는 포트에서 만 반환 값 데이터가없는 &lt;code&gt;port_control&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fc2960ec142372aacf524e3c02cb29b3deda53c6" translate="yes" xml:space="preserve">
          <source>When the port is in &lt;code&gt;data&lt;/code&gt; mode, all data is sent to Erlang in a format that suits the distribution. In fact, the raw data will never reach any Erlang process, but will be translated/interpreted by the emulator itself and then delivered in the correct format to the correct processes. In the current emulator version, received data is to be tagged with a single byte of 100. That is what the macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; is defined to. The tagging of data in the distribution can be changed in the future.</source>
          <target state="translated">포트가 &lt;code&gt;data&lt;/code&gt; 모드 인 경우 모든 데이터는 배포에 적합한 형식으로 Erlang에 전송됩니다. 실제로 원시 데이터는 어떤 Erlang 프로세스에도 도달하지 않지만 에뮬레이터 자체에서 변환 / 해석 된 다음 올바른 형식으로 올바른 프로세스에 전달됩니다. 현재 에뮬레이터 버전에서 수신 된 데이터는 100의 단일 바이트로 태그됩니다. 이것이 매크로 &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; 가 정의한 것입니다. 배포판의 데이터 태깅은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a5fc45c74e8bc2edca91ff415618981adda324" translate="yes" xml:space="preserve">
          <source>When the protocol is available to Erlang through a driver and an Erlang interface module, a distribution module can be written. The distribution module is a module with well-defined callbacks, much like a &lt;code&gt;gen_server&lt;/code&gt; (there is no compiler support for checking the callbacks, though). This module implements:</source>
          <target state="translated">드라이버와 Erlang 인터페이스 모듈을 통해 Erlang에 프로토콜을 사용할 수 있으면 배포 모듈을 작성할 수 있습니다. 배포 모듈은 &lt;code&gt;gen_server&lt;/code&gt; 와 매우 유사하게 잘 정의 된 콜백이있는 모듈입니다 (콜백 확인을위한 컴파일러 지원은 없습니다). 이 모듈은 다음을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="be29dce95eec97a67e2087b38e94bd51a5e3dde0" translate="yes" xml:space="preserve">
          <source>When the queue contains data, the driver does not close until the queue is empty.</source>
          <target state="translated">대기열에 데이터가 포함되어 있으면 대기열이 비워 질 때까지 드라이버가 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21ba1599707f578e6da25bafa5c66c03f204937f" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the &lt;code&gt;heart&lt;/code&gt; program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</source>
          <target state="translated">릴리스 핸들러는 명령어를 만나면 먼저 임시 부트 파일을 생성하여 에뮬레이터 및 핵심 응용 프로그램의 새 버전과 다른 모든 응용 프로그램의 이전 버전을 시작합니다. 그런 다음 &lt;code&gt;init:reboot()&lt;/code&gt; 를 호출하여 현재 에뮬레이터를 종료합니다 . 커널 의 &lt;code&gt;init(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오. 모든 프로세스가 정상적으로 종료 되고 임시 부팅 파일을 사용하여 &lt;code&gt;heart&lt;/code&gt; 프로그램 이 시스템을 재부팅 합니다. 재부팅 후 나머지 relup 명령어가 실행됩니다. 이는 임시 부팅 스크립트의 일부로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cee98f8753d15dee1e12f17349a48be34b074873" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it shuts down the emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the &lt;code&gt;heart&lt;/code&gt; program using the new release version. No more upgrade instruction is executed after the restart.</source>
          <target state="translated">릴리스 핸들러가 명령어를 만나면 &lt;code&gt;init:reboot()&lt;/code&gt; 를 호출하여 에뮬레이터를 종료합니다 . 커널 의 &lt;code&gt;init(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오. 모든 프로세스가 정상적으로 종료 된 후 새 릴리스 버전을 사용하여 &lt;code&gt;heart&lt;/code&gt; 프로그램으로 시스템을 재부팅 할 수 있습니다 . 다시 시작한 후에는 더 이상 업그레이드 지침이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a250d269026a9e3f5fca66518f55dd84f05c8c5d" translate="yes" xml:space="preserve">
          <source>When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_cast(Request, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{noreply,State1}&lt;/code&gt;. &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">요청이 수신되면 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;handle_cast(Request, State)&lt;/code&gt; 호출 하여 튜플 &lt;code&gt;{noreply,State1}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;State1&lt;/code&gt; 의 상태에 대한 새 값입니다 &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d57c2ee62a9879fde2097882cf19d4663d2b600" translate="yes" xml:space="preserve">
          <source>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns &lt;code&gt;true&lt;/code&gt; to let the shell go ahead with the evaluation, or &lt;code&gt;false&lt;/code&gt; to abort it. There are two possible callback functions for the user to implement:</source>
          <target state="translated">제한된 쉘이 표현식을 평가하고 함수 호출 또는 연산자 애플리케이션을 발견하면 콜백 함수를 호출합니다 (해당 함수 호출에 대한 정보 포함). 이 콜백 함수는 쉘이 평가를 진행하게하려면 &lt;code&gt;true&lt;/code&gt; 를, 중단하려면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 . 사용자가 구현할 수있는 두 가지 콜백 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54c402919b78665c1c8f198f292bab9fc59cd16" translate="yes" xml:space="preserve">
          <source>When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type.</source>
          <target state="translated">서버에 MIME 유형 설정으로 확인할 수없는 문서 유형을 제공하도록 요청하면 서버는이 기본 유형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb82b8ca8c5a5957509c8e72df7e62feb33df317" translate="yes" xml:space="preserve">
          <source>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a &lt;code&gt;job&lt;/code&gt;. Only the current job, which is said to be &lt;code&gt;connected&lt;/code&gt;, can perform operations with standard I/O. All other jobs, which are said to be &lt;code&gt;detached&lt;/code&gt;, are &lt;code&gt;blocked&lt;/code&gt; if they attempt to use standard I/O.</source>
          <target state="translated">쉘이 시작되면 단일 평가 기 프로세스가 시작됩니다. 이 프로세스는 생성 된 로컬 프로세스와 함께 &lt;code&gt;job&lt;/code&gt; 이라고합니다 . &lt;code&gt;connected&lt;/code&gt; 있는 현재 작업 만 표준 I / O로 작업을 수행 할 수 있습니다. 할 수 있다고하는 다른 모든 작업, &lt;code&gt;detached&lt;/code&gt; ,하는 &lt;code&gt;blocked&lt;/code&gt; 들은 표준 I / O를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3c74035ba1de254b56bab74be22512784e14aa0a" translate="yes" xml:space="preserve">
          <source>When the size of all received requests exceeds &lt;code&gt;trans_req_maxsize&lt;/code&gt;.</source>
          <target state="translated">때 수신 된 모든 요청의 크기를 초과 &lt;code&gt;trans_req_maxsize&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="bf7ff81cd7bcbcf93265972ba220ec58a44a2621" translate="yes" xml:space="preserve">
          <source>When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt; is called as:</source>
          <target state="translated">지정된 이벤트가 발생하면 &lt;code&gt;Function&lt;/code&gt; 함수 는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a9b740db20f360e56cbaf192b02a625103f61f81" translate="yes" xml:space="preserve">
          <source>When the supervisor terminates, then the next higher-level supervisor takes some action. It either restarts the terminated supervisor or terminates itself.</source>
          <target state="translated">수퍼바이저가 종료되면 다음 상위 수퍼바이저가 조치를 취합니다. 종료 된 수퍼바이저를 다시 시작하거나 자체 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f021b23bfe2cd55d1b599da584871e714016f843" translate="yes" xml:space="preserve">
          <source>When the timer finally expires, a &quot;megaco segments not received&quot; (459) error message is sent to the other side and the user is notified with a &lt;code&gt;segment timeout&lt;/code&gt;&lt;code&gt;UserReply&lt;/code&gt; in either the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function or the return value of the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">타이머가 마지막으로, &quot;MEGACO 세그먼트가 수신되지&quot;만료되면 (459) 에러 메시지를 다른쪽으로 전송되고 사용자가 함께 통지 &lt;code&gt;segment timeout&lt;/code&gt; &lt;code&gt;UserReply&lt;/code&gt; 하나로 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 콜백 함수 또는 반환 값 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="6bf973279da0cedc632ba88c183b69c62e648346" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">타이머가 &lt;code&gt;0&lt;/code&gt; 에 도달 하고 만료되면 드라이버 입력 기능 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9f3b6a59efe7a46474fcba7bb50d20a40f5897" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the request is resent and the timer is restarted.</source>
          <target state="translated">타이머가 중간 만료에 도달하면 요청이 다시 전송되고 타이머가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="fd4e877095aa4be1ada9827ad7529e4bc18e2c51" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer is restarted.</source>
          <target state="translated">타이머가 중간 만료에 도달하면 타이머가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="157d3bfb09cfc45ece6b6d5a8c11a2c6035409d0" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer restarted.</source>
          <target state="translated">타이머가 중간 만료에 도달하면 타이머가 다시 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="e2702c4a29cb7ffd2d62635fddc60ffda837b937" translate="yes" xml:space="preserve">
          <source>When the timer reaches the final expire, either the function &lt;code&gt;megaco:call&lt;/code&gt; will return with &lt;code&gt;{error, timeout}&lt;/code&gt; or the callback function &lt;code&gt;handle_trans_reply&lt;/code&gt; will be called with &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (if &lt;code&gt;megaco:cast&lt;/code&gt; was used).</source>
          <target state="translated">타이머가 최종 만료에 도달하면 &lt;code&gt;megaco:call&lt;/code&gt; 함수 는 &lt;code&gt;{error, timeout}&lt;/code&gt; 과 함께 리턴 되거나 callback 함수 &lt;code&gt;handle_trans_reply&lt;/code&gt; 는 &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; ( &lt;code&gt;megaco:cast&lt;/code&gt; 가 사용 된 경우) 과 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d489b1aa41c1da0731c58c4d8333c65b8fb249f" translate="yes" xml:space="preserve">
          <source>When the tracing is completed, stop the tracer with &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; and format the trace log with &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (if there is anything to format).</source>
          <target state="translated">추적이 완료되면 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; 로 추적 프로그램을 중지 하고 &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; ( 포맷 할 것이있는 경우)로 추적 로그 를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="c36338011eef64525211dd65889fb16a9937ec35" translate="yes" xml:space="preserve">
          <source>When the transaction sender receives a request which is already &quot;in storage&quot; (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the &lt;code&gt;trans_timer&lt;/code&gt; and the &lt;code&gt;request_timer&lt;/code&gt; is not properly chosen.</source>
          <target state="translated">트랜잭션 발신자가 이미 &quot;저장소에있는&quot;(트랜잭션 ID로 표시) 요청을 받으면 다시 보낸 것으로 가정하고 저장된 모든 것이 전송됩니다. &lt;code&gt;trans_timer&lt;/code&gt; 및 &lt;code&gt;request_timer&lt;/code&gt; 값이 올바르게 선택되지 않은 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7862d7ec18f93027c83a7039d6cf2d951465703f" translate="yes" xml:space="preserve">
          <source>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</source>
          <target state="translated">사용자가 콜백 함수에서 트랜잭션 요청을 처리 한 경우 Megaco 애플리케이션은 트랜잭션 응답을 어셈블하고 선택한 인코딩 모듈을 사용하여이를 인코딩 한 후 콜백 함수를 호출하여 메시지를 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="17fcbf724175dd6197cb33c7a80fb993e93fef84" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop, or for backwards compatibility, an Apache-like configuration file. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="translated">애플리케이션 시작시 웹 서버가 시작되면 일반 Erlang 특성 목록 (예 : &lt;code&gt;[{Option, Value}]&lt;/code&gt; ) 으로 구성 파일에서 특성을 가져옵니다 . 여기서 &lt;code&gt;Option = property()&lt;/code&gt; 및 &lt;code&gt;Value = term()&lt;/code&gt; 다음에 전체 중지 또는 이전 버전과의 호환성을 위해 Apache와 유사한 구성 파일. 웹 서버가 런타임시 동적으로 시작되면 파일을 지정할 수 있지만 전체 특성 목록도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8385f08e883f730c6d6877fd915bdc9c53f2091" translate="yes" xml:space="preserve">
          <source>When the whole driver is unloaded. Every resource allocated by the driver is to be freed.</source>
          <target state="translated">전체 드라이버가 언로드 될 때 드라이버가 할당 한 모든 리소스를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="1864bbfe1bb4da0ed39ef620a0d58a044889dcf3" translate="yes" xml:space="preserve">
          <source>When the window (terminal) size changes on the client side, it &lt;strong&gt;can&lt;/strong&gt; send a message to the server side to inform it of the new dimensions. No API function generates this event.</source>
          <target state="translated">클라이언트 쪽에서 창 (터미널) 크기가 변경 되면 새 차원을 알리기 위해 서버쪽에 메시지를 보낼 &lt;strong&gt;수 있습니다&lt;/strong&gt; . API 함수가이 이벤트를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ae6cb0d1aeff4baecd961c38c7a0d0343bce682" translate="yes" xml:space="preserve">
          <source>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating &lt;code&gt;Expr&lt;/code&gt;) if all filters are true or an empty list otherwise.</source>
          <target state="translated">생성기 또는 비트 문자열 생성기가없는 경우 목록 이해는 모든 필터가 true 인 경우 하나의 요소가있는 목록 ( &lt;code&gt;Expr&lt;/code&gt; 평가 결과)을 리턴하거나 그렇지 않으면 빈 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="68c8a10137c4675b33b04fc152e8dd169fb08630" translate="yes" xml:space="preserve">
          <source>When there are no more objects in the table, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">테이블에 더 이상 개체가 없으면 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="745f9cd3851e711d348b63ccc23a8f52273edfe7" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, &lt;code&gt;qlc&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">키 위치에 대한 간단한 제한 만있는 경우 &lt;code&gt;qlc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 키를 찾습니다. 이것이 불가능하면 전체 테이블이 순회됩니다. 옵션 &lt;code&gt;traverse&lt;/code&gt; 는이를 수행하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a97d09e0174e7ebcd752be249e317734288c7fe5" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, QLC uses &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">키 위치에 간단한 제한 만있는 경우 QLC는 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 키를 찾습니다. 이것이 불가능하면 전체 테이블이 순회됩니다. 옵션 &lt;code&gt;traverse&lt;/code&gt; 는이를 수행하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1432344868741e2698e6a9b96d60c2837b98772c" translate="yes" xml:space="preserve">
          <source>When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).</source>
          <target state="translated">혼동의 위험이없는 경우, 세트의 요소는 그들이 나타내는 세트로 식별됩니다. 예를 들어 U가 S1과 S2를 인수로하여 &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과 인 경우 U는 S1과 S2의 합집합이라고합니다. 보다 정확한 공식은 Set (U)가 Set (S1)과 Set (S2)의 합집합이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3340db1e6247a69837f2ad75c699140be306fabf" translate="yes" xml:space="preserve">
          <source>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</source>
          <target state="translated">이 인수가 제거되면 사용할 최종 CPU 토폴로지가 에뮬레이터 부팅시 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b43ec86ba8c916251f60d0bb263cce04f4688f6" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="translated">이 플래그가 지정되면 링크 된 드라이버는 &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt; 사용하여 포트가 시작되었음을 수동으로 인식해야합니다 . 이를 통해 구현 &lt;code&gt;badarg&lt;/code&gt; 초기 비동기 초기화가 완료된 후 badarg 와 함께 &lt;code&gt;erlang:open_port&lt;/code&gt; 를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c9e4e469cc7c78f5cf4d1f7fdc335fb16bb6a9" translate="yes" xml:space="preserve">
          <source>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function &lt;code&gt;raise/2&lt;/code&gt; without interfering with each other.</source>
          <target state="translated">이 함수가 트랜잭션 내에서 실행될 때 서로 다른 노드에서 실행중인 여러 프로세스 가 서로 방해하지 않고 함수 &lt;code&gt;raise/2&lt;/code&gt; 를 동시에 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f5be18c956ae3c742f6fbc74a81c84e27f37de5" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="translated">이 함수가 호출 되면 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; 함수가 방금 호출 된 &lt;code&gt;erlang:open_port&lt;/code&gt; 시작 erlang : open_port 호출이 리턴됩니다 . 연결된 드라이버에서 플래그 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; 가 설정된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f1d28b41ff3a8afa6eef2cd6d49d478529957d0" translate="yes" xml:space="preserve">
          <source>When this function is called with a list of certificate options; it generates a configuration with just one node certificate where &lt;code&gt;cacerts&lt;/code&gt; contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles.</source>
          <target state="translated">이 옵션이 인증서 옵션 목록과 함께 호출 된 경우 &lt;code&gt;cacerts&lt;/code&gt; 에 루트 인증서와 피어에 제공해야하는 중간 인증서가 포함 된 하나의 노드 인증서만으로 구성이 생성됩니다 . 이 경우 모든 피어에 대해 동일한 루트 인증서를 사용해야합니다. 예를 들어 다른 노드를 향한 노드가 누구에게 누가 연결하는지에 따라 서버 또는 클라이언트 역할을하는 Erlang 분산 클러스터에 유용합니다. 생성 된 인증서에는 클라이언트 인증서에는 필요하지 않지만 두 역할 모두에 유용한 인증서 제목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0dc82b5ddcdc81bd48ff82e4659150dc801ef9" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="translated">이 함수가 클라이언트 및 서버 체인 사양을 포함하는 맵과 함께 호출 된 경우 서버에 대해 리턴 된 &lt;code&gt;cacerts&lt;/code&gt; 에 서버가 신뢰해야하는 루트 인증서와 서버가 연결 클라이언트에 제공해야하는 중간 인증서가 포함 된 클라이언트 및 서버 인증서 체인이 모두 생성됩니다 . 서버가 신뢰해야하는 루트 인증서는 클라이언트 인증서 체인의 루트로 사용됩니다. 그 반대의 경우도 클라이언트에 대해 반환 된 &lt;code&gt;cacerts&lt;/code&gt; 적용됩니다 . 루트 인증서는 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 로 미리 생성 되거나 옵션이 지정된 경우에 생성 될 수 있습니다 . 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ef9a4bfdea86e7e0384f0eb8ca04b745e4df80d6" translate="yes" xml:space="preserve">
          <source>When this function is called, &lt;code&gt;*value_size&lt;/code&gt; is to contain the size of the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">이 함수가 호출 될 때 &lt;code&gt;*value_size&lt;/code&gt; 는 &lt;code&gt;value&lt;/code&gt; 버퍼 의 크기를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="4f0658a8caa71ae8ec3af2aaa874893698a63c04" translate="yes" xml:space="preserve">
          <source>When this function is executed inside a transaction-context, it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수가 트랜잭션 컨텍스트 내에서 실행되면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="dcdfcd8239bab330841cc445bcf6b51860555e6e" translate="yes" xml:space="preserve">
          <source>When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.</source>
          <target state="translated">이것이 트리거되면 패턴을 통한 이전 경로에서 동일한 이름을 가진 가장 최근 (* MARK)을 검색합니다. 하나가 발견되면 &quot;bumpalong&quot;진행은 (* SKIP)가 발생한 위치가 아니라 (* MARK)에 해당하는 주제 위치로 진행됩니다. 이름이 일치하는 (* MARK)가 없으면 (* SKIP)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7db68b788b90d41b1ce4140671c7e956cf1dfc1" translate="yes" xml:space="preserve">
          <source>When this mapping is used, insertion and deletion in the original Mnesia table is slower, with a factor O(log n). The read access is not affected.</source>
          <target state="translated">이 매핑을 사용하면 원래 Mnesia 테이블의 삽입 및 삭제 속도가 느리고 인수 O (log n)가 발생합니다. 읽기 액세스에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb494176e860d606fcf89bbbcaf477ac48b4e483" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;false&lt;/code&gt;, which is default, an RST received from the TCP peer is treated as a normal close (as though an FIN was sent). A caller to &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; gets &lt;code&gt;{error, closed}&lt;/code&gt;. In active mode, the controlling process receives a &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; message, indicating that the peer has closed the connection.</source>
          <target state="translated">이 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정되면 ( 기본값) TCP 피어로부터 수신 된 RST는 정상 닫기로 처리됩니다 (FIN이 전송 된 것처럼). &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; 를 호출 하면 &lt;code&gt;{error, closed}&lt;/code&gt; 합니다. 활성 모드에서 제어 프로세스는 피어가 연결을 종료했음을 나타내는 &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; 메시지를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="cc7f5c99c2ce601b738e1cbcc7fe8e59a1211a42" translate="yes" xml:space="preserve">
          <source>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option &lt;code&gt;/m&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?m)&lt;/code&gt; option setting. If there are no newlines in a subject string, or no occurrences of &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a pattern, setting &lt;code&gt;multiline&lt;/code&gt; has no effect.</source>
          <target state="translated">이 옵션이 지정되면 &quot;줄 시작&quot;및 &quot;줄 끝&quot;구문은 제목 문자열에서 내부 개행 바로 다음 또는 바로 앞뿐만 아니라 시작 및 끝에서 각각 일치합니다. 이것은 Perl 옵션 &lt;code&gt;/m&lt;/code&gt; 과 동일 하며 &lt;code&gt;(?m)&lt;/code&gt; 옵션 설정 으로 패턴 내에서 변경할 수 있습니다 . 제목 문자열에는 줄 바꿈, 또는 전혀 발생이없는 경우 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 설정, 패턴에 &lt;code&gt;multiline&lt;/code&gt; 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="675f8d886654247d43dbcd4fe8a49b4d5b32073b" translate="yes" xml:space="preserve">
          <source>When this option is used, the result of &lt;code&gt;write/2&lt;/code&gt; calls can prematurely be reported as successful, and if a write error occurs, the error is reported as the result of the next file operation, which is not executed.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;write/2&lt;/code&gt; 호출 의 결과가 조기에 성공한 것으로보고 될 수 있으며, 쓰기 오류가 발생하면 다음 파일 작업의 결과로 오류가보고되며 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efc30def2e6a5147d2d890feeb73645cc382d513" translate="yes" xml:space="preserve">
          <source>When time-out occurs, &lt;code&gt;Common Test&lt;/code&gt; never aborts the ongoing test case, as this can leave the SUT in an undefined, and possibly bad, state. Instead &lt;code&gt;Common Test&lt;/code&gt;, by default, finishes the current test run before stopping. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified, &lt;code&gt;Common Test&lt;/code&gt; stops when the current test job is finished. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified with &lt;code&gt;skip_rest&lt;/code&gt;, &lt;code&gt;Common Test&lt;/code&gt; only completes the current test case and skips the remaining tests in the test job.</source>
          <target state="translated">시간 초과가 발생하면 &lt;code&gt;Common Test&lt;/code&gt; 는 진행중인 테스트 사례를 중단하지 않습니다. SUT가 정의되지 않은 상태이거나 나쁜 상태 일 수 있습니다. 대신 기본적으로 &lt;code&gt;Common Test&lt;/code&gt; 는 중지하기 전에 현재 테스트 실행을 완료합니다. 플래그 &lt;code&gt;force_stop&lt;/code&gt; 을 지정 하면 현재 테스트 작업이 완료되면 &lt;code&gt;Common Test&lt;/code&gt; 가 중지됩니다. &lt;code&gt;skip_rest&lt;/code&gt; 와 함께 &lt;code&gt;force_stop&lt;/code&gt; 플래그 를 지정 하면 &lt;code&gt;Common Test&lt;/code&gt; 는 현재 테스트 케이스 만 완료하고 테스트 작업의 나머지 테스트는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="7496cb290358c83d75813f93e436cc9aa7801dbd" translate="yes" xml:space="preserve">
          <source>When to use a Sub-agent</source>
          <target state="translated">서브 에이전트를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="25981ff4244a1ee87a90be438c90aa93aa36e1ed" translate="yes" xml:space="preserve">
          <source>When trace flag &lt;code&gt;call&lt;/code&gt; is set on a process, function calls are traced on that process if a trace pattern is set for the called function.</source>
          <target state="translated">프로세스에서 추적 플래그 &lt;code&gt;call&lt;/code&gt; 이 설정 되면 호출 된 함수에 추적 패턴이 설정된 경우 해당 프로세스에서 함수 호출이 추적됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
