<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="c8613cbf9cc57a98765708cdc22f9ed8559f964a" translate="yes" xml:space="preserve">
          <source>When trace output is desired, &lt;code&gt;debug&lt;/code&gt; is to be defined when the module &lt;code&gt;m&lt;/code&gt; is compiled:</source>
          <target state="translated">추적 출력이 필요한 경우 모듈 &lt;code&gt;m&lt;/code&gt; 이 컴파일 될 때 &lt;code&gt;debug&lt;/code&gt; 가 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="256e90d704880ae674edcafcdfe9548c1c7249cd" translate="yes" xml:space="preserve">
          <source>When tracing a system of Mnesia applications it is useful to be able to interleave Mnesia own events with application-related events that give information about the application context.</source>
          <target state="translated">Mnesia 애플리케이션 시스템을 추적 할 때 Mnesia 자체 이벤트를 애플리케이션 관련 이벤트와 인터리브하여 애플리케이션 컨텍스트에 대한 정보를 제공하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e113da41d29c2c3638afdbda456737663befd306" translate="yes" xml:space="preserve">
          <source>When tracing diskless nodes, &lt;code&gt;ttb&lt;/code&gt; must be started from an external &quot;trace control node&quot; with disk access, and &lt;code&gt;Client&lt;/code&gt; must be &lt;code&gt;{local, File}&lt;/code&gt;. All trace information is then sent to the trace control node where it is written to file.</source>
          <target state="translated">디스크없는 노드를 추적 할 때는 디스크 액세스 권한이있는 외부 &quot;추적 제어 노드&quot;에서 &lt;code&gt;ttb&lt;/code&gt; 를 시작 해야하며 &lt;code&gt;Client&lt;/code&gt; 는 &lt;code&gt;{local, File}&lt;/code&gt; 이어야합니다 . 그런 다음 모든 추적 정보가 추적 제어 노드로 전송되어 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6193e77c0b9e8850c79e56437a7ff2bfa89554ed" translate="yes" xml:space="preserve">
          <source>When tracing function calls on a group leader process (an IO process), there is risk of causing a deadlock. This will happen if a group leader process generates a trace message and the tracer process, by calling the trace handler function, sends an IO request to the same group leader. The problem can only occur if the trace handler prints to tty using an &lt;code&gt;io&lt;/code&gt; function such as &lt;code&gt;format/2&lt;/code&gt;. Note that when &lt;code&gt;dbg:p(all,call)&lt;/code&gt; is called, IO processes are also traced. Here's an example:</source>
          <target state="translated">그룹 리더 프로세스 (IO 프로세스)에서 함수 호출을 추적하면 교착 상태가 발생할 위험이 있습니다. 이는 그룹 리더 프로세스가 추적 메시지를 생성하고 추적 핸들러 프로세스가 추적 핸들러 함수를 호출하여 동일한 그룹 리더에게 IO 요청을 보내는 경우에 발생합니다. 추적 핸들러가 &lt;code&gt;format/2&lt;/code&gt; 와 같은 &lt;code&gt;io&lt;/code&gt; 함수를 사용하여 tty로 인쇄하는 경우에만 문제점이 발생할 수 있습니다 . 때 참고 &lt;code&gt;dbg:p(all,call)&lt;/code&gt; 라고, IO 과정도 추적됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466360c3c9707d034db5517f5ba6f1db58ddb4ed" translate="yes" xml:space="preserve">
          <source>When tracing live systems, always take special care to not overload a node with too heavy tracing. &lt;code&gt;ttb&lt;/code&gt; provides option &lt;code&gt;overload&lt;/code&gt; to address this problem.</source>
          <target state="translated">라이브 시스템을 추적 할 때 추적이 너무 무거운 노드에 과부하가 걸리지 않도록 항상 특히주의하십시오. &lt;code&gt;ttb&lt;/code&gt; 는 이 문제를 해결하기 위해 옵션 &lt;code&gt;overload&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1d713a6d3abef0dc19e9fef42b12e8d6a635ed21" translate="yes" xml:space="preserve">
          <source>When tracing there is no return value to produce, the match specification either matches or does not. The effect when the expression matches is a trace message rather than a returned term. The &lt;code&gt;ActionTerm&lt;/code&gt;s are executed as in an imperative language, that is, for their side effects. Functions with side effects are also allowed when tracing.</source>
          <target state="translated">추적 할 생성 값이 없으면 일치 스펙이 일치하거나 일치하지 않습니다. 표현식이 일치 할 때의 결과는 리턴 된 용어가 아닌 추적 메시지입니다. &lt;code&gt;ActionTerm&lt;/code&gt; 의 의는 그 부작용이다 명령형 언어에서와 같이 실행됩니다. 추적 할 때 부작용이있는 기능도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="58e093b3869faaa26b1860581c9f3af042ac8ce5" translate="yes" xml:space="preserve">
          <source>When tracing to shell or &lt;code&gt;{local,File}&lt;/code&gt;, an ip trace driver is used internally. The ip trace driver has a queue of maximum &lt;code&gt;QueueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced, the queue size might be exceeded and messages are dropped. This parameter is optional, and is only useful if many &lt;code&gt;{drop,N}&lt;/code&gt; trace messages are received by the trace handler. It has no meaning if shell or &lt;code&gt;{local,File}&lt;/code&gt; is not used. See &lt;code&gt;dbg:trace_port/2&lt;/code&gt; for more information about the ip trace driver.</source>
          <target state="translated">쉘 또는 &lt;code&gt;{local,File}&lt;/code&gt; 추적시 내부적으로 ip 추적 드라이버가 사용됩니다. ip 추적 드라이버에는 최대 &lt;code&gt;QueueSize&lt;/code&gt; 메시지 큐 가 전달 대기 중입니다. 드라이버가 메시지를 생성하는 속도만큼 빨리 메시지를 전달할 수 없으면 큐 크기가 초과되어 메시지가 삭제 될 수 있습니다. 이 매개 변수는 선택 사항이며 많은 &lt;code&gt;{drop,N}&lt;/code&gt; 추적 메시지가 추적 핸들러에 의해 수신 된 경우에만 유용 합니다. 쉘 또는 &lt;code&gt;{local,File}&lt;/code&gt; 을 사용 하지 않으면 의미 가 없습니다. 참조 &lt;code&gt;dbg:trace_port/2&lt;/code&gt; 는 IP 추적 드라이버에 대한 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093fdd62c1610e46d6f27c6de1ab5ef2750cca76" translate="yes" xml:space="preserve">
          <source>When traversing the contents of &lt;code&gt;sys.config&lt;/code&gt; and a filename is encountered, its contents are read and merged with the result so far. When an application configuration tuple &lt;code&gt;{Application, Env}&lt;/code&gt; is found, it is merged with the result so far. Merging means that new parameters are added and existing parameter values overwritten.</source>
          <target state="translated">&lt;code&gt;sys.config&lt;/code&gt; 의 내용을 탐색 하고 파일 이름이 발견되면 그 내용을 읽고 지금까지 결과와 병합합니다. 응용 프로그램 구성 튜플 &lt;code&gt;{Application, Env}&lt;/code&gt; 가 발견되면 지금까지 결과와 병합됩니다. 병합은 새 매개 변수가 추가되고 기존 매개 변수 값을 겹쳐 쓴다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c1a00c1646659dc3c25c531f96cba51c37aa323" translate="yes" xml:space="preserve">
          <source>When unregister the subagent using an &lt;code&gt;oid()&lt;/code&gt;, the &lt;code&gt;pid()&lt;/code&gt; of the process handling the sub-tree is also returned.</source>
          <target state="translated">&lt;code&gt;oid()&lt;/code&gt; 사용하여 서브 에이전트를 등록 취소하면 서브 트리를 처리하는 프로세스 의 &lt;code&gt;pid()&lt;/code&gt; 도 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="799f766e20f87f2dca4b1fd3e86f764dcd6d6a7e" translate="yes" xml:space="preserve">
          <source>When upgrading the emulator from a version older than OTP R15, an attempt is made to load new application beam code into the old emulator. Sometimes the new beam format cannot be read by the old emulator, so the code loading fails and the complete upgrade is terminated. To overcome this problem, the new application code is to be compiled with the old emulator. For more information about emulator upgrade from pre OTP R15 versions, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">OTP R15 이전 버전에서 에뮬레이터를 업그레이드 할 때 새 애플리케이션 빔 코드를 이전 에뮬레이터에로드하려고 시도합니다. 이전 에뮬레이터에서 새 빔 형식을 읽을 수없는 경우가 있으므로 코드로드에 실패하고 전체 업그레이드가 종료됩니다. 이 문제를 극복하기 위해 새로운 응용 프로그램 코드는 이전 에뮬레이터로 컴파일해야합니다. OTP R15 이전 버전에서의 에뮬레이터 업그레이드에 대한 자세한 내용은 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;Design Principles&lt;/code&gt; 을 참조하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c936186cbb39bacc2e228da8dc8dbbfc6f98893" translate="yes" xml:space="preserve">
          <source>When used together with a &lt;code&gt;Tracer Module&lt;/code&gt;, any message sent in the trace callback is guaranteed to have reached its recipient before the &lt;code&gt;trace_delivered&lt;/code&gt; message is sent.</source>
          <target state="translated">&lt;code&gt;Tracer Module&lt;/code&gt; 과 함께 사용 하면 &lt;code&gt;trace_delivered&lt;/code&gt; 메시지가 전송 되기 전에 추적 콜백으로 전송 된 모든 메시지가 수신자에게 도달 한 것으로 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="79aeb596bfcda207847ddb49137293b64e87d84d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see Section &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the keys &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;vsn&lt;/code&gt;, &lt;code&gt;modules&lt;/code&gt;, &lt;code&gt;registered&lt;/code&gt;, and &lt;code&gt;applications&lt;/code&gt; are also to be specified:</source>
          <target state="translated">&lt;code&gt;systools&lt;/code&gt; 를 사용할 때 코드 포장을위한 Erlang / OTP 도구 (섹션 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; 참조 ), 키 &lt;code&gt;description&lt;/code&gt; , &lt;code&gt;vsn&lt;/code&gt; , &lt;code&gt;modules&lt;/code&gt; , &lt;code&gt;registered&lt;/code&gt; 및 &lt;code&gt;applications&lt;/code&gt; 도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa09303e43191324a1721cf4208f1cd806ff1214" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;ttb&lt;/code&gt;, do not use module &lt;code&gt;dbg&lt;/code&gt; in application Runtime_Tools in parallel.</source>
          <target state="translated">&lt;code&gt;ttb&lt;/code&gt; 를 사용할 때 응용 프로그램 Runtime_Tools에서 모듈 &lt;code&gt;dbg&lt;/code&gt; 를 병렬로 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="dced03c330435f63fc32590f93a202225ef052df" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;{active, once}&lt;/code&gt; or &lt;code&gt;{active, N}&lt;/code&gt;, the socket changes behavior automatically when data is received. This can be confusing in combination with connection-oriented sockets (that is, &lt;code&gt;gen_tcp&lt;/code&gt;), as a socket with &lt;code&gt;{active, false}&lt;/code&gt; behavior reports closing differently than a socket with &lt;code&gt;{active, true}&lt;/code&gt; behavior. To simplify programming, a socket where the peer closed, and this is detected while in &lt;code&gt;{active, false}&lt;/code&gt; mode, still generates message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; when set to &lt;code&gt;{active, once}&lt;/code&gt;, &lt;code&gt;{active, true}&lt;/code&gt;, or &lt;code&gt;{active, N}&lt;/code&gt; mode. It is therefore safe to assume that message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt;, possibly followed by socket port termination (depending on option &lt;code&gt;exit_on_close&lt;/code&gt;) eventually appears when a socket changes back and forth between &lt;code&gt;{active, true}&lt;/code&gt; and &lt;code&gt;{active, false}&lt;/code&gt; mode. However, &lt;strong&gt;when&lt;/strong&gt; peer closing is detected it is all up to the underlying TCP/IP stack and protocol.</source>
          <target state="translated">사용시 &lt;code&gt;{active, once}&lt;/code&gt; 또는 &lt;code&gt;{active, N}&lt;/code&gt; 데이터가 수신 될 때, 소켓의 자동 동작을 변경한다. &lt;code&gt;{active, false}&lt;/code&gt; 동작 보고서가있는 소켓과 &lt;code&gt;{active, true}&lt;/code&gt; 동작 이있는 소켓과 다르게 닫히는 연결 지향 소켓 (즉, &lt;code&gt;gen_tcp&lt;/code&gt; ) 과 함께 혼동 될 수 있습니다 . 피어가 닫힌 소켓 인 프로그래밍을 단순화하기 위해 &lt;code&gt;{active, false}&lt;/code&gt; 모드 에서이 소켓을 감지 하면 &lt;code&gt;{active, once}&lt;/code&gt; , &lt;code&gt;{active, true}&lt;/code&gt; 또는 &lt;code&gt;{active, N}&lt;/code&gt; 설정된 경우 에도 &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; 메시지가 생성 됩니다. , N} 모드. 그러므로 그 메시지를 가정하는 것이 안전합니다 &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; 소켓 이 &lt;code&gt;{active, true}&lt;/code&gt; 및 &lt;code&gt;{active, false}&lt;/code&gt; 모드 사이에서 앞뒤로 변경되면 {tcp_closed, Socket} 다음에 소켓 포트 종료 ( &lt;code&gt;exit_on_close&lt;/code&gt; 옵션에 따라 )가 나타날 수 있습니다. 그러나 &lt;strong&gt;때&lt;/strong&gt; 피어 폐쇄가 감지는 기본 TCP / IP 스택 및 프로토콜에 대한 모든 걸 포기이다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2fcb6b502d0fb8883fe722b0fb211f708e76b4ea" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, output the raw analysis results (Erlang terms) instead of the formatted result. The raw format is easier to post-process (for example, to filter warnings or to output HTML pages).</source>
          <target state="translated">명령 행에서 Dialyzer를 사용하는 경우 형식화 된 결과 대신 원시 분석 결과 (Erlang 항)를 출력하십시오. 원시 형식은 후 처리가 더 쉽습니다 (예 : 경고 필터링 또는 HTML 페이지 출력).</target>
        </trans-unit>
        <trans-unit id="895bf807f2bce58c7df0a72cbf3fb93cefba69cf" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, send the analysis results to the specified outfile rather than to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">명령 행에서 Dialyzer를 사용하는 경우 분석 결과를 &lt;code&gt;stdout&lt;/code&gt; 대신 지정된 출력 파일로 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="da094abac8d6ebe76a11e697f4e1c5d8c383f3e5" translate="yes" xml:space="preserve">
          <source>When using Eprof, expect a slowdown in program execution.</source>
          <target state="translated">Eprof를 사용할 때 프로그램 실행이 느려질 것으로 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="8ac2072110b05033591debd298147443f0f01fa0" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt;, the module must be loaded before the match specification is executed. If it is not loaded, the match fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt; 사용하는 경우 일치 스펙을 실행하기 전에 모듈을로드해야합니다. 로드되지 않으면 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1061184d8334715a1b4b165eee90f4c38b81216b" translate="yes" xml:space="preserve">
          <source>When using binary encoding, the structure of the termination id's needs to be specified.</source>
          <target state="translated">이진 인코딩을 사용하는 경우 종료 ID의 구조를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="05cb8889170e86b20dbe5a37d8a1c94a4de731e5" translate="yes" xml:space="preserve">
          <source>When using long node names, the code is slightly different as shown in the following example:</source>
          <target state="translated">긴 노드 이름을 사용하는 경우 코드는 다음 예와 같이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f2766f8a1c9c5b824a82d01d204ba0da23305f93" translate="yes" xml:space="preserve">
          <source>When using one of the specialized decodes, exclusive or selective decode, instructions must be given in a configuration file. Option &lt;code&gt;asn1config&lt;/code&gt; enables specialized decodes and takes the configuration file in concern. The configuration file has the same name as the ASN.1 specification, but with extension &lt;code&gt;.asn1config&lt;/code&gt;.</source>
          <target state="translated">전용 디코딩, 독점 또는 선택적 디코딩 중 하나를 사용하는 경우 명령은 구성 파일에 제공되어야합니다. 옵션 &lt;code&gt;asn1config&lt;/code&gt; 는 특수한 디코딩을 가능하게하고 구성 파일을 고려합니다. 구성 파일의 이름은 ASN.1 사양과 동일하지만 확장자는 &lt;code&gt;.asn1config&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db0b593e72759555e6318e54e37fd3dd78c4b583" translate="yes" xml:space="preserve">
          <source>When using text encoding(s), there is actually two different configs controlling what software to use:</source>
          <target state="translated">텍스트 인코딩을 사용할 때 실제로 어떤 소프트웨어를 사용할지 제어하는 ​​두 가지 구성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b22551cdbafd14a01ac76572f423a143928c5aa" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;load/unload&lt;/code&gt; interfaces, the driver is not unloaded until the &lt;strong&gt;last port&lt;/strong&gt; using the driver is closed. Function &lt;code&gt;unload/1&lt;/code&gt; can return immediately, as the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have no interrest in when the unloading occurs. The driver is unloaded when no one needs it any longer.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;load/unload&lt;/code&gt; 인터페이스를 때까지 드라이버가 언로드되지 않은 &lt;strong&gt;마지막 포트&lt;/strong&gt; 드라이버를 사용하여이 닫힙니다. 언로드가 발생할 때 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 방해받지 않기 때문에 &lt;code&gt;unload/1&lt;/code&gt; 함수 는 즉시 리턴 될 수 있습니다 . 더 이상 필요하지 않으면 드라이버가 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="3ebfa3ee9cf60736bbe38ab4cca43cd168ab98e8" translate="yes" xml:space="preserve">
          <source>When using the default configuration, the data to pass over a connection needs to be delivered as is to the node on the receiving end in the &lt;strong&gt;exact same order&lt;/strong&gt;, with no loss of data what so ever, as sent from the sending node.</source>
          <target state="translated">기본 구성을 사용하는 경우 연결을 통과하는 데이터 는 전송 노드에서 전송 된 데이터 손실없이 데이터 를 그대로 수신 엔드의 노드에 그대로 &lt;strong&gt;동일한 순서&lt;/strong&gt; 로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c053c5fc182ecd19f8594a98a6d280896669e6b" translate="yes" xml:space="preserve">
          <source>When using the internal format for logs, use functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt;. These functions log one or more Erlang terms. By prefixing each of the functions with a &lt;code&gt;b&lt;/code&gt; (for &quot;binary&quot;), we get the corresponding &lt;code&gt;blog()&lt;/code&gt; functions for the external format. These functions log one or more chunks of bytes. For example, to log the string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in ASCII format, you can use &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt;, or &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt;. The two alternatives are equally efficient.</source>
          <target state="translated">로그에 내부 형식을 사용할 때는 &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 이 함수는 하나 이상의 Erlang 용어를 기록합니다. 각 함수 앞에 &lt;code&gt;b&lt;/code&gt; ( &quot;바이너리&quot;) 를 접두어 외부 형식에 해당하는 &lt;code&gt;blog()&lt;/code&gt; 함수를 얻습니다 . 이 함수는 하나 이상의 바이트 청크를 기록합니다. 예를 들어 문자열 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 를 ASCII 형식으로 기록하려면 &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt; 또는 &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt; 있습니다. 두 가지 대안이 모두 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b4a43444e4a47c6747c01683f8434e4d77e198b9" translate="yes" xml:space="preserve">
          <source>When using the state object from this function the &lt;code&gt;rand&lt;/code&gt; functions using it may throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">이 함수의 상태 객체를 사용할 때 안전한 &quot;무작위성&quot;부족으로 인해 랜덤 생성기가 실패한 경우 이를 사용 하는 &lt;code&gt;rand&lt;/code&gt; 함수 에서 예외 &lt;code&gt;low_entropy&lt;/code&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9cf555c8604c8a038c91aab86896c66a21405ac" translate="yes" xml:space="preserve">
          <source>When using version 3, then (at least one) &lt;strong&gt;usm user&lt;/strong&gt; has to be registered.</source>
          <target state="translated">버전 3을 사용하는 경우 (적어도 하나) &lt;strong&gt;usm 사용자&lt;/strong&gt; 를 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec7bdbbb710766593c75e9261e59e0df0f24c88d" translate="yes" xml:space="preserve">
          <source>When white-box testing an Erlang application, it is useful to be able to measure the code coverage of the test. &lt;code&gt;Common Test&lt;/code&gt; provides simple access to the OTP Cover tool for this purpose. &lt;code&gt;Common Test&lt;/code&gt; handles all necessary communication with the Cover tool (starting, compiling, analysing, and so on). The &lt;code&gt;Common Test&lt;/code&gt; user only needs to specify the extent of the code coverage analysis.</source>
          <target state="translated">Erlang 애플리케이션을 화이트 박스 테스트 할 때 테스트의 코드 적용 범위를 측정하는 것이 유용합니다. &lt;code&gt;Common Test&lt;/code&gt; 는이를 위해 OTP Cover 도구에 대한 간단한 액세스를 제공합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 Cover 도구와의 모든 필요한 통신 (시작, 컴파일, 분석 등)을 처리합니다. &lt;code&gt;Common Test&lt;/code&gt; 사용자는 코드 커버리지 분석의 범위를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f214ea79f2660a8546905638532084bd1af76b3" translate="yes" xml:space="preserve">
          <source>When working with binaries, you can get the horrible &quot;double UTF-8 encoding&quot;, where strange characters are encoded in your binaries or files. In other words, you can get a UTF-8 encoded binary that for the second time is encoded as UTF-8. A common situation is where you read a file, byte by byte, but the content is already UTF-8. If you then convert the bytes to UTF-8, using, for example, the &lt;code&gt;unicode&lt;/code&gt; module, or by writing to a file opened with option &lt;code&gt;{encoding,utf8}&lt;/code&gt;, you have each &lt;strong&gt;byte&lt;/strong&gt; in the input file encoded as UTF-8, not each character of the original text (one character can have been encoded in many bytes). There is no real remedy for this other than to be sure of which data is encoded in which format, and never convert UTF-8 data (possibly read byte by byte from a file) into UTF-8 again.</source>
          <target state="translated">바이너리로 작업 할 때 이상한 문자가 바이너리 나 파일로 인코딩되는 끔찍한 &quot;이중 UTF-8 인코딩&quot;을 얻을 수 있습니다. 즉, 두 번째로 UTF-8로 인코딩 된 UTF-8 인코딩 바이너리를 얻을 수 있습니다. 일반적인 상황은 파일을 바이트 단위로 읽는 것이지만 내용은 이미 UTF-8입니다. 그런 다음 예를 들어 &lt;code&gt;unicode&lt;/code&gt; 모듈을 사용하거나 &lt;code&gt;{encoding,utf8}&lt;/code&gt; 옵션으로 열린 파일에 쓰면 바이트를 UTF-8로 변환하면 각 &lt;strong&gt;바이트가 있습니다.&lt;/strong&gt;UTF-8로 인코딩 된 입력 파일에서 원본 텍스트의 각 문자가 아닙니다 (한 문자는 여러 바이트로 인코딩 될 수 있음). 어떤 데이터가 어떤 형식으로 인코딩되는지 확인하는 것 외에는 UTF-8 데이터 (파일에서 바이트 단위로 읽을 수 있음)를 다시 UTF-8로 변환하지 않는 것 외에 다른 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8aa37a649829db83e3c9dedf652e7985f8d65bf" translate="yes" xml:space="preserve">
          <source>When writing a driver in C++, the driver entry is to be of &lt;code&gt;&quot;C&quot;&lt;/code&gt; linkage. One way to do this is to put the following line somewhere before the driver entry:</source>
          <target state="translated">C ++로 드라이버를 작성할 때 드라이버 항목은 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 링크입니다. 이를 수행하는 한 가지 방법은 드라이버 항목 앞에 다음 줄을 두는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0855b2f59cc7fd85a55a378f3ac199542a22335d" translate="yes" xml:space="preserve">
          <source>When writing a driver to make a communications protocol available to Erlang, one should know just about everything worth knowing about that particular protocol. All operation must be non-blocking and all possible situations are to be accounted for in the driver. A non-stable driver will affect and/or crash the whole Erlang runtime system.</source>
          <target state="translated">통신 프로토콜을 Erlang에 제공하기 위해 드라이버를 작성할 때 특정 프로토콜에 대해 알아야 할 모든 것에 대해 알아야합니다. 모든 작업은 비 차단이어야하며 가능한 모든 상황을 운전자가 고려해야합니다. 불안정한 드라이버는 전체 Erlang 런타임 시스템에 영향을 미치거나 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="a72c2f5d7c0d4febcd9848b5e2d40ba7cee9b091" translate="yes" xml:space="preserve">
          <source>When writing data it's generally more efficient to write a list of binaries rather than a list of integers. It is not needed to flatten a deep list before writing. On Unix hosts, scatter output, which writes a set of buffers in one operation, is used when possible. In this way &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; writes the contents of the binaries without copying the data at all, except for perhaps deep down in the operating system kernel.</source>
          <target state="translated">데이터를 쓸 때 일반적으로 정수 목록보다는 이진 목록을 작성하는 것이 더 효율적입니다. 쓰기 전에 딥리스트를 평평하게 할 필요는 없습니다. 유닉스 호스트에서는 한 번의 작업으로 일련의 버퍼를 쓰는 스 캐터 출력이 사용됩니다. 이런 식으로 &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; 는 운영 체제 커널에 대한 자세한 내용을 제외하고는 데이터를 전혀 복사하지 않고 이진의 내용을 씁니다.</target>
        </trans-unit>
        <trans-unit id="3b93d4af25f4cfa6e840871298ee7870c462c231" translate="yes" xml:space="preserve">
          <source>When writing new event handlers for the alarm handler, the following events must be handled:</source>
          <target state="translated">알람 핸들러에 대한 새 이벤트 핸들러를 작성할 때 다음 이벤트를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="373413f347fd7c204258c00e02a894b57247817b" translate="yes" xml:space="preserve">
          <source>When writing recursive functions, it is preferable to make them tail-recursive so that they can execute in constant memory space:</source>
          <target state="translated">재귀 함수를 작성할 때 일정한 메모리 공간에서 실행할 수 있도록 꼬리 재귀를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa2d5599c173fb1e0df9df6db989c552f2a87193" translate="yes" xml:space="preserve">
          <source>When writing tests, the programmer may discover dependencies (in order to get the tests to run) that ought not to be there, and which need to be abstracted away to get a cleaner design. This helps eliminate bad dependencies before they spread throughout the code.</source>
          <target state="translated">테스트를 작성할 때 프로그래머는 테스트를 실행하기 위해 필요하지 않은 종속성을 발견하고 더 깔끔한 디자인을 얻기 위해 추상화해야 할 수도 있습니다. 이를 통해 코드 전체에 나쁜 종속성이 확산되기 전에이를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3af0ab66421941647abf2fd21f2bc78b64c5b301" translate="yes" xml:space="preserve">
          <source>When you are finished with a registry, close it to remove all the objects and free the memory back to the system:</source>
          <target state="translated">레지스트리가 완료되면 레지스트리를 닫고 모든 오브젝트를 제거하고 시스템에 메모리를 다시 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="81517dd740949b1006611dd1f8a8b5246c788490" translate="yes" xml:space="preserve">
          <source>When you do application:start(odbc) the only thing that happens is that a supervisor process is started. For each call to the API function connect/2 a process is spawned and added as a child to the Erlang ODBC supervisor. The supervisors only tasks are to provide error-log reports, if a child process should die abnormally, and the possibility to do a code change. Only the client process has the knowledge to decide if this connection managing process should be restarted.</source>
          <target state="translated">application : start (odbc)를 수행 할 때 발생하는 유일한 일은 감독자 프로세스가 시작된 것입니다. API 함수 connect / 2를 호출 할 때마다 프로세스가 생성되고 Erlang ODBC 수퍼바이저에 자식으로 추가됩니다. 하위 프로세스가 비정상적으로 종료되고 코드가 변경 될 가능성이있는 경우 감독자 만 할 일은 오류 로그 보고서를 제공하는 것입니다. 클라이언트 프로세스 만이 연결 관리 프로세스를 다시 시작해야하는지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7400e1e45c6bbbe2f2d319b38f4bbb29db5b56b8" translate="yes" xml:space="preserve">
          <source>When you have covered all scenarios, call &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; in order to create a configuration. The configuration is written to a file that you have chosen. This configuration file can later be read by an Erlang runtime-system at startup. Pass the command line argument &lt;code&gt;-args_file FileName&lt;/code&gt; to the &lt;code&gt;erl(1)&lt;/code&gt; command.</source>
          <target state="translated">모든 시나리오를 다루었 으면 구성을 작성하기 위해 &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 . 구성이 선택한 파일에 기록됩니다. 이 구성 파일은 나중에 시작할 때 Erlang 런타임 시스템에서 읽을 수 있습니다. 명령 행 인수 &lt;code&gt;-args_file FileName&lt;/code&gt; 을 &lt;code&gt;erl(1)&lt;/code&gt; 명령으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="2d53da3f7d650259d1f729b92236227077a1d6a9" translate="yes" xml:space="preserve">
          <source>When you have made a new version of a release, a release package can be created with this new version and transferred to the target environment.</source>
          <target state="translated">새 버전의 릴리스를 작성하면이 새 버전으로 릴리스 패키지를 작성하여 대상 환경으로 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aefe043fafd90a506fefaff1bdc21fce94c6f9bc" translate="yes" xml:space="preserve">
          <source>When you have written code implementing some specific functionality you might want to make the code into an &lt;strong&gt;application&lt;/strong&gt;, that is, a component that can be started and stopped as a unit, and which can also be reused in other systems.</source>
          <target state="translated">특정 기능을 구현하는 코드를 작성한 경우 코드를 &lt;strong&gt;응용 프로그램&lt;/strong&gt; , 즉 단위로 시작 및 중지 할 수있는 구성 요소로 만들고 다른 시스템에서도 재사용 할 수있는 구성 요소로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d367f0394e334cbcef285f586eb6654ee9a4318" translate="yes" xml:space="preserve">
          <source>When you have written one or more applications, you might want to create a complete system with these applications and a subset of the Erlang/OTP applications. This is called a &lt;strong&gt;release&lt;/strong&gt;.</source>
          <target state="translated">하나 이상의 응용 프로그램을 작성한 경우,이 응용 프로그램 및 Erlang / OTP 응용 프로그램의 서브 세트로 완전한 시스템을 작성하려고 할 수 있습니다. 이것을 &lt;strong&gt;릴리스&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="654964da7073e7c0e406ea7aa179e002a5b8ce21" translate="yes" xml:space="preserve">
          <source>When you know that your list is only one level deep, you can use &lt;code&gt;lists:append/1&lt;/code&gt;.</source>
          <target state="translated">목록의 깊이가 한 단계라는 것을 알면 &lt;code&gt;lists:append/1&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02bb765c4c067cc8ce440c6583ae9e207c512d37" translate="yes" xml:space="preserve">
          <source>When you retrieve a stored string or binary value from the registry, the registry maintains a pointer to the object and you are passed a copy of that pointer. You should never free an object retrieved in this manner because when the registry later attempts to free it, a runtime error occurs that likely causes the C-node to crash.</source>
          <target state="translated">레지스트리에서 저장된 문자열 또는 이진 값을 검색 할 때 레지스트리는 객체에 대한 포인터를 유지하고 해당 포인터의 사본이 전달됩니다. 레지스트리가 나중에 오브젝트를 해제하려고 할 때 C 노드가 충돌 할 수있는 런타임 오류가 발생하므로이 방식으로 검색된 오브젝트를 해제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5626fd2395b6a4085f46c5ac192af7d4f4d8e554" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;et_display_demo:test().&lt;/code&gt; function in the example above, the &lt;code&gt;Viewer&lt;/code&gt; window will look like this:</source>
          <target state="translated">&lt;code&gt;et_display_demo:test().&lt;/code&gt; 를 실행할 때 위 예제에서 기능을 사용하면 &lt;code&gt;Viewer&lt;/code&gt; 창은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="605aa269180a77759984c8901f4c82eed551f821" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;et_trace_demo:test()&lt;/code&gt; function above, the &lt;code&gt;Viewer&lt;/code&gt; window will look like this screenshot:</source>
          <target state="translated">위 의 &lt;code&gt;et_trace_demo:test()&lt;/code&gt; 함수 를 실행하면 &lt;code&gt;Viewer&lt;/code&gt; 창이 다음 스크린 샷과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="960b45a93de3d4904386ce3821892195b9e7ab8f" translate="yes" xml:space="preserve">
          <source>When you start an Erlang system that is going to talk to other Erlang systems, you must give it a name, for example:</source>
          <target state="translated">다른 Erlang 시스템과 통신 할 Erlang 시스템을 시작할 때 다음과 같이 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8df6d7cad16972ed6b617cfa7ca16f92b6efea50" translate="yes" xml:space="preserve">
          <source>When you start your first bash shell, you will get an awful prompt. You might also have a &lt;code&gt;PATH&lt;/code&gt; environment variable that contains backslashes and such. Edit &lt;code&gt;$HOME/.profile&lt;/code&gt; and &lt;code&gt;$HOME/.bashrc&lt;/code&gt; to set fair prompts and a correct PATH. Also do an &lt;code&gt;export SHELL&lt;/code&gt; in &lt;code&gt;.profile&lt;/code&gt;. For some non-obvious reason the environment variable &lt;code&gt;$SHELL&lt;/code&gt; is not exported in bash. Also note that &lt;code&gt;.profile&lt;/code&gt; is run at login time and &lt;code&gt;.bashrc&lt;/code&gt; when sub shells are created. You'll need to explicitly source &lt;code&gt;.bashrc&lt;/code&gt; from &lt;code&gt;.profile&lt;/code&gt; if you want the commands there to be run at login time (like setting up aliases, shell functions and the like). You can for example do like this at the end of &lt;code&gt;.profile&lt;/code&gt;:</source>
          <target state="translated">첫 번째 bash 쉘을 시작하면 끔찍한 프롬프트가 나타납니다. 백 슬래시 등을 포함 하는 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 가있을 수도 있습니다 . 공정한 프롬프트와 올바른 PATH를 설정하려면 &lt;code&gt;$HOME/.profile&lt;/code&gt; 및 &lt;code&gt;$HOME/.bashrc&lt;/code&gt; 를 편집 하십시오. 또한 &lt;code&gt;.profile&lt;/code&gt; 에서 &lt;code&gt;export SHELL&lt;/code&gt; 수행하십시오 . 명백하지 않은 이유로 환경 변수 &lt;code&gt;$SHELL&lt;/code&gt; 을 bash로 내 보내지 않습니다. 또한 &lt;code&gt;.profile&lt;/code&gt; 은 로그인시 실행되고 서브 쉘이 작성 될 때 &lt;code&gt;.bashrc&lt;/code&gt; 입니다. &lt;code&gt;.profile&lt;/code&gt; 에서 &lt;code&gt;.bashrc&lt;/code&gt; 를 명시 적으로 소싱해야합니다.로그인시 명령을 실행하려면 (별명 설정, 쉘 기능 등). 예를 들어 &lt;code&gt;.profile&lt;/code&gt; 끝에 다음과 같이 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bbc912db27df1bdd5b6c3cc6fb0b420ae0c2a51" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; to connect to an Erlang node, a connection is first made to &lt;code&gt;epmd&lt;/code&gt; and, if the node is known, a connection is then made to the Erlang node.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 을 얼랑 노드에 연결, 연결이 처음에 만들어 &lt;code&gt;epmd&lt;/code&gt; 와 노드가 알려진 경우, 연결이 다음 얼랑 노드로 이루어진다.</target>
        </trans-unit>
        <trans-unit id="9186fbf7f3fc276c1864ff1a046c155293e1a73d" translate="yes" xml:space="preserve">
          <source>When you've followed the instructions there, you also need to install these packages: autoconf, make, perl, and tar. You do so by running the following in the msys console:</source>
          <target state="translated">지침을 따랐 으면 autoconf, make, perl 및 tar와 같은 패키지도 설치해야합니다. msys 콘솔에서 다음을 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b5bd0acac37a6b1a7c503370b5d247b256244684" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;mod:func(...)&lt;/code&gt; is called after this, token &lt;code&gt;seq_trace&lt;/code&gt; is set on the executing process.</source>
          <target state="translated">이 후에 &lt;code&gt;mod:func(...)&lt;/code&gt; 가 호출 될 때마다 &lt;code&gt;seq_trace&lt;/code&gt; 토큰이 실행 프로세스에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d72b69344dfa59a6a3f516c3fd6fb4fed315938a" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;gen_server&lt;/code&gt; process is started using &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt;, this function is called by the new process to initialize.</source>
          <target state="translated">때마다 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스를 사용하여 시작됩니다 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; ,이 기능은 초기화 할 새로운 프로세스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4636ebe5538e407f431af7436aab013abc47a599" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;gen_server&lt;/code&gt; process receives a request sent using &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, this function is called to handle the request.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 프로세스가 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송 된 요청을 수신 할 때 마다이 함수는 요청을 처리하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8246b3f7ddedcfbbf57cabb4f3ba4a48febfdd74" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;gen_server&lt;/code&gt; process receives a request sent using &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#abcast-2&quot;&gt;abcast/2,3&lt;/a&gt;&lt;/code&gt;, this function is called to handle the request.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 프로세스가 &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#abcast-2&quot;&gt;abcast/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하여 전송 된 요청을 수신 할 때 마다이 함수는 요청을 처리하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="59d5a5416d0ba531e35225680d4d972654eaf438" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;gen_statem&lt;/code&gt; is started using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt;, this function is called by the new process to initialize the implementation state and server data.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 를 사용하여 gen_statem 이 시작될 때 마다이 함수는 새 프로세스에서 호출되어 구현 상태 및 서버 데이터를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="1fbe0f5778a727d43412487be9078f75fff292b2" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;gen_statem&lt;/code&gt; receives an event from &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt;, or as a normal process message, one of these functions is called. If &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, &lt;code&gt;Module:StateName/3&lt;/code&gt; is called, and if it is &lt;code&gt;handle_event_function&lt;/code&gt;, &lt;code&gt;Module:handle_event/4&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt; 또는 일반 프로세스 메시지 에서 이벤트를 수신 할 때마다 이러한 함수 중 하나가 호출됩니다. 경우 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;state_functions&lt;/code&gt; , &lt;code&gt;Module:StateName/3&lt;/code&gt; 라고하며,이 경우 &lt;code&gt;handle_event_function&lt;/code&gt; 는 , &lt;code&gt;Module:handle_event/4&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="060f352ef970eb18feed7d139ddbf0bd578e000a" translate="yes" xml:space="preserve">
          <source>Whenever a group is executed, if &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead. Output generated by hook functions are saved to the log files for these dummies. For more information, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Manipulating Tests&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">그룹이 실행될 때마다 &lt;code&gt;init_per_group&lt;/code&gt; 및 &lt;code&gt;end_per_group&lt;/code&gt; 이 스위트에 존재하지 않으면 &lt;code&gt;Common Test&lt;/code&gt; 는 대신 동일한 이름의 더미 함수를 호출합니다. 후크 기능에 의해 생성 된 출력은 이러한 더미의 로그 파일에 저장됩니다. 자세한 내용은 일반적인 테스트 후크 섹션의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Manipulating Tests&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abdf13a8a96504ff3ed49fca4f7de802cf3577c0" translate="yes" xml:space="preserve">
          <source>Whenever a new event handler is added to an event manager, this function is called to initialize the event handler.</source>
          <target state="translated">새 이벤트 핸들러가 이벤트 관리자에 추가 될 때마다이 함수는 이벤트 핸들러를 초기화하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="badee53ec6214ee55106eb2666ae6e01689cd3f4" translate="yes" xml:space="preserve">
          <source>Whenever a supervisor bridge is started using &lt;code&gt;&lt;a href=&quot;#start_link-2&quot;&gt;start_link/2,3&lt;/a&gt;&lt;/code&gt;, this function is called by the new process to start the subsystem and initialize.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_link-2&quot;&gt;start_link/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하여 수퍼바이저 브리지가 시작될 때 마다이 기능은 새 프로세스에서 호출되어 서브 시스템을 시작하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ac9804b31553b68b86de8b8d607773807cff019f" translate="yes" xml:space="preserve">
          <source>Whenever a supervisor is started using &lt;code&gt;&lt;a href=&quot;#start_link-2&quot;&gt;start_link/2,3&lt;/a&gt;&lt;/code&gt;, this function is called by the new process to find out about restart strategy, maximum restart intensity, and child specifications.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_link-2&quot;&gt;start_link/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하여 수퍼바이저가 시작될 때마다 새 프로세스에서이 함수를 호출하여 재시작 전략, 최대 재시작 강도 및 하위 스펙을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4b83efec02f8d41a6ae9c7e77ef60624db6e6a32" translate="yes" xml:space="preserve">
          <source>Whenever an &lt;strong id=&quot;ordering_function&quot;&gt;ordering function&lt;/strong&gt;&lt;code&gt;F&lt;/code&gt; is expected as argument, it is assumed that the following properties hold of &lt;code&gt;F&lt;/code&gt; for all x, y, and z:</source>
          <target state="translated">&lt;strong id=&quot;ordering_function&quot;&gt;순서 함수 &lt;/strong&gt; &lt;code&gt;F&lt;/code&gt; 가 인수로 예상 될 때마다 다음 특성 은 모든 x, y 및 z에 대해 &lt;code&gt;F&lt;/code&gt; 를 보유한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f1074a783fc4777d27f52c523982cfb1f94fba10" translate="yes" xml:space="preserve">
          <source>Whenever an event handler is deleted from an event manager, this function is called. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up.</source>
          <target state="translated">이벤트 관리자에서 이벤트 핸들러가 삭제 될 때마다이 함수가 호출됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 과 반대 가되며 필요한 정리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="068fc6ee5a1c4d1d9b9294ae0200a38ff117c977" translate="yes" xml:space="preserve">
          <source>Whenever an event manager receives a request sent using &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;call/3,4&lt;/a&gt;&lt;/code&gt;, this function is called for the specified event handler to handle the request.</source>
          <target state="translated">이벤트 관리자가 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;call/3,4&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송 된 요청을 수신 할 때마다 지정된 이벤트 핸들러에 대해이 함수가 호출되어 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5423fb1332b31975745a6de7e4d9bc58090c6de6" translate="yes" xml:space="preserve">
          <source>Whenever an event manager receives an event sent using &lt;code&gt;&lt;a href=&quot;#notify-2&quot;&gt;notify/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sync_notify-2&quot;&gt;sync_notify/2&lt;/a&gt;&lt;/code&gt;, this function is called for each installed event handler to handle the event.</source>
          <target state="translated">이벤트 관리자가 &lt;code&gt;&lt;a href=&quot;#notify-2&quot;&gt;notify/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#sync_notify-2&quot;&gt;sync_notify/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송 된 이벤트를 수신 할 때마다 설치된 각 이벤트 핸들러에 대해이 함수가 호출되어 이벤트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4351f2a3b168494b69e9b1be98a4b38f8367e952" translate="yes" xml:space="preserve">
          <source>Whenever option &lt;code&gt;extended_info&lt;/code&gt; is used, it results in a file not readable by versions of ETS before that in STDLIB 1.15.1</source>
          <target state="translated">&lt;code&gt;extended_info&lt;/code&gt; 옵션을 사용할 때마다 STDLIB 1.15.1에서 ETS 이전 버전으로 파일을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40a517195424f6c59533102727aaaf80a5a6a9c4" translate="yes" xml:space="preserve">
          <source>Whenever the application begins a new and demanding Mnesia task, or if it enters a new interesting phase in its execution, it can be a good idea to use &lt;code&gt;mnesia:report_event/1&lt;/code&gt;. &lt;code&gt;Event&lt;/code&gt; can be any term and generates a &lt;code&gt;{mnesia_user, Event}&lt;/code&gt; event for any processes that subscribe to Mnesia system events.</source>
          <target state="translated">응용 프로그램이 새롭고 까다로운 Mnesia 작업을 시작할 때마다 또는 실행 중에 새로운 흥미로운 단계에 들어가면 &lt;code&gt;mnesia:report_event/1&lt;/code&gt; 을 사용하는 것이 좋습니다 . &lt;code&gt;Event&lt;/code&gt; 는 임의의 용어 일 수 있으며 Mnesia 시스템 이벤트를 구독하는 모든 프로세스에 대해 &lt;code&gt;{mnesia_user, Event}&lt;/code&gt; 이벤트를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c1b3e73b65bf489cc2059c0d5cb3b8c01636a2e4" translate="yes" xml:space="preserve">
          <source>Whenever the function returns &lt;code&gt;false&lt;/code&gt; (either when a suspend would occur or when &lt;code&gt;noconnect&lt;/code&gt; was specified and the node was not already connected), the message is guaranteed &lt;strong&gt;not&lt;/strong&gt; to have been sent.</source>
          <target state="translated">함수가 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 때마다 (중단이 발생하거나 &lt;code&gt;noconnect&lt;/code&gt; 이 지정되지 않았고 노드가 아직 연결되지 않은 경우) 메시지가 전송 &lt;strong&gt;되지 않았 음&lt;/strong&gt; 을 보증 합니다.</target>
        </trans-unit>
        <trans-unit id="c1dadcfbaebba3928e790a14ae2ce1daeab89f8a" translate="yes" xml:space="preserve">
          <source>Whenever we receive a button event we start an event time-out of 30 seconds, and if we get an event type &lt;code&gt;timeout&lt;/code&gt; we reset the remaining code sequence.</source>
          <target state="translated">버튼 이벤트를받을 때마다 30 초의 이벤트 &lt;code&gt;timeout&lt;/code&gt; 가 시작되고 이벤트 유형 시간 초과 가 발생하면 나머지 코드 시퀀스가 ​​재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f11e733d6957530218fa0c33e9b080d6c38678e6" translate="yes" xml:space="preserve">
          <source>Whenever you want to match out a number of elements in a sequence (zero or more) rather than a fixed set of elements, you need to use a glob. For example:</source>
          <target state="translated">고정 된 요소 집합이 아닌 시퀀스 (0 개 이상)로 여러 요소를 일치 시키려면 glob를 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d8517da58ab05b8c0b03e7088b8e296b4ae1c0f" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;lt;ReleaseDir&amp;gt;&lt;/code&gt; is</source>
          <target state="translated">어디 &lt;code&gt;&amp;lt;ReleaseDir&amp;gt;&lt;/code&gt; IS</target>
        </trans-unit>
        <trans-unit id="6f3a961a4b885d1468059606ee74b25cafa51c46" translate="yes" xml:space="preserve">
          <source>Where E is the public exponent and N is public modulus.</source>
          <target state="translated">여기서 E는 공개 지수이고 N은 공개 계수입니다.</target>
        </trans-unit>
        <trans-unit id="4a7b7c13ae9c93fab8ce3de18c3783c30f1e1451" translate="yes" xml:space="preserve">
          <source>Where E is the public exponent, N is public modulus and D is the private exponent. The longer key format contains redundant information that will make the calculation faster. P1,P2 are first and second prime factors. E1,E2 are first and second exponents. C is the CRT coefficient. Terminology is taken from &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3477.txt&quot;&gt; RFC 3447&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">E가 공개 지수 인 경우 N은 공개 계수이고 D는 비공개 지수입니다. 더 긴 키 형식에는 계산을 빠르게하는 중복 정보가 포함되어 있습니다. P1, P2는 첫 번째 및 두 번째 주요 요소입니다. E1, E2는 첫 번째 및 두 번째 지수입니다. C는 CRT 계수입니다. 용어는 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3477.txt&quot;&gt; RFC 3447&lt;/a&gt;&lt;/code&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3144e74e87bbb4e8446bf9bded7d46890ebf3322" translate="yes" xml:space="preserve">
          <source>Where P, Q and G are the dss parameters and X is the private key.</source>
          <target state="translated">여기서 P, Q 및 G는 dss 매개 변수이고 X는 개인 키입니다.</target>
        </trans-unit>
        <trans-unit id="2225bc73e98d80c1bfa4e4cf3ed86983be9f6abd" translate="yes" xml:space="preserve">
          <source>Where P, Q and G are the dss parameters and Y is the public key.</source>
          <target state="translated">여기서 P, Q 및 G는 dss 매개 변수이고 Y는 공개 키입니다.</target>
        </trans-unit>
        <trans-unit id="4817edd006ce6eb15f5dd1caa449f5d7d24b519f" translate="yes" xml:space="preserve">
          <source>Where Verifier is &lt;code&gt;v&lt;/code&gt;, Generator is &lt;code&gt;g&lt;/code&gt; and Prime is&lt;code&gt;N&lt;/code&gt;, DerivedKey is &lt;code&gt;X&lt;/code&gt;, and Scrambler is &lt;code&gt;u&lt;/code&gt; (optional will be generated if not provided) from &lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt; Version = '3' | '6' | '6a'</source>
          <target state="translated">Verifier가 &lt;code&gt;v&lt;/code&gt; 이면 Generator는 &lt;code&gt;g&lt;/code&gt; 이고 Prime은 &lt;code&gt;N&lt;/code&gt; 이고 DerivedKey는 &lt;code&gt;X&lt;/code&gt; 이며 Scrambler는 &lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt; Version = '3' 에서 &lt;code&gt;u&lt;/code&gt; (제공되지 않은 경우 선택적으로 생성됨) | '6'| '6a'</target>
        </trans-unit>
        <trans-unit id="e63a13bf71d4a7ebc9b2737f3779c3e536718b27" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;A&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; 는 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="e839812da1a839a57adf7231f3fd47dc44d87628" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">어디 또는 &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;http://srp.stanford.edu/design.html&quot;&gt;SRP design&lt;/a&gt;&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b9a1763ac9bc8b491978b150abc3fe5244acde7" translate="yes" xml:space="preserve">
          <source>Where the content of the top element is: &lt;code&gt;[{xmlText,[{dog,1}],1,[],&quot;\ Grand Danois\ &quot;,text}]&lt;/code&gt;. Text will be returned in &lt;code&gt;xmlText&lt;/code&gt; records. Though, usually documents are more complex, and the content of the top element will in that case be a nested structure with xmlElement records that in turn may have complex content. All of this reflects the structure of the XML document.</source>
          <target state="translated">최상위 요소의 컨텐츠는 &lt;code&gt;[{xmlText,[{dog,1}],1,[],&quot;\ Grand Danois\ &quot;,text}]&lt;/code&gt; 입니다. 텍스트는 &lt;code&gt;xmlText&lt;/code&gt; 레코드 로 반환됩니다 . 일반적으로 문서는 더 복잡하지만 최상위 요소의 컨텐츠는 복잡한 컨텐츠를 가질 수있는 xmlElement 레코드가있는 중첩 구조가됩니다. 이 모든 것은 XML 문서의 구조를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="887842314d3d1ceea1cb4b38b8e7a7fc00c8daa0" translate="yes" xml:space="preserve">
          <source>Where to put the generated files. Default is the current directory.</source>
          <target state="translated">생성 된 파일을 넣을 위치 기본값은 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5648598d9c1122279909495088842eeb61ff331f" translate="yes" xml:space="preserve">
          <source>Where to search for &lt;code&gt;.asn1db&lt;/code&gt; files and ASN.1 source specs to resolve references to other modules. This option can be repeated many times if there are several places to search in. The compiler searches the current directory first.</source>
          <target state="translated">다른 모듈에 대한 참조를 해결하기 위해 &lt;code&gt;.asn1db&lt;/code&gt; 파일 및 ASN.1 소스 스펙 을 검색 할 위치 검색 할 위치가 여러 개인 경우이 옵션을 여러 번 반복 할 수 있습니다. 컴파일러는 현재 디렉토리를 먼저 검색합니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="ecbc2004e666a6ce8be8ae15948d6a5e5690e45c" translate="yes" xml:space="preserve">
          <source>Whereas a call to the following default code values would return a table with a RAM copy on the local node, no extra indexes, and the attributes defaulted to the list &lt;code&gt;[key,val]&lt;/code&gt;.</source>
          <target state="translated">다음 기본 코드 값을 호출하면 로컬 노드에 RAM 사본이 있고 추가 색인이없고 속성이 기본적으로 &lt;code&gt;[key,val]&lt;/code&gt; 목록으로 테이블이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="9d5abedb298ae261c18864ec4e752eb53242394e" translate="yes" xml:space="preserve">
          <source>Whereas tuples group things together, it is also needed to represent lists of things. Lists in Erlang are surrounded by square brackets, &quot;[&quot; and &quot;]&quot;. For example, a list of the temperatures of various cities in the world can be:</source>
          <target state="translated">튜플이 사물을 그룹화하는 반면 사물 목록을 나타내야합니다. Erlang의 목록은 대괄호 &quot;[&quot;및 &quot;]&quot;로 묶습니다. 예를 들어 세계 여러 도시의 온도 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36fcd280365ee86c3459e03bb8e681df6b1d1cfd" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;pool_size&lt;/code&gt; has been configured affects the format of the listing in the case of a connecting transport, since a value greater than 1 implies multiple transport processes for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, as in the listening case. The format in this case is similar to the listening case, with a &lt;code&gt;pool&lt;/code&gt; tuple in place of an &lt;code&gt;accept&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;pool_size&lt;/code&gt; 구성 여부 는 연결 전송의 경우 목록 형식에 영향을 미칩니다. 1보다 큰 값 은 청취 사례에서와 같이 동일한 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 대해 여러 전송 프로세스를 의미하기 때문 입니다. 이 경우 형식은 함께 청취의 경우와 유사하다 &lt;code&gt;pool&lt;/code&gt; 대신 튜플 &lt;code&gt;accept&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="67b0b7e85711868c9741c95515f7371a72c9fbc7" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;code&gt;pick_peer/4&lt;/code&gt; application callback can modify the application state. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pick_peer/4&lt;/code&gt; 애플리케이션 콜백이 애플리케이션 상태를 수정할 수 있는지 여부 입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d449b0476061df0503275d5625f4fff86548ae57" translate="yes" xml:space="preserve">
          <source>Whether or not to count application-specific messages; those for which &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks take place. If false then only messages handled by diameter itself are counted: CER/CEA, DWR/DWA, DPR/DPA.</source>
          <target state="translated">응용 프로그램 별 메시지를 계산할지 여부 하는 그 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백 이루어집니다. false 인 경우 CER / CEA, DWR / DWA, DPR / DPA와 같이 직경 자체로 처리 된 메시지 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c70b0206c5df852a42e48a70b35c7ae080f23eb5" translate="yes" xml:space="preserve">
          <source>Whether or not to decode AVPs of type &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;OctetString()&lt;/a&gt;&lt;/code&gt; and its derived types &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterURI()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;IPFilterRule()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;QoSFilterRule()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;UTF8String()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt; then AVPs of these types are decoded to string(). If &lt;code&gt;false&lt;/code&gt; then values are retained as binary().</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;OctetString()&lt;/a&gt;&lt;/code&gt; 유형 및 파생 유형 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterURI()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;IPFilterRule()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;QoSFilterRule()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;UTF8String()&lt;/a&gt;&lt;/code&gt; AVP를 디코딩할지 여부 입니다. &lt;code&gt;true&lt;/code&gt; 인 경우 이러한 유형의 AVP가 string ()으로 디코딩됩니다. 경우 &lt;code&gt;false&lt;/code&gt; 다음 값이 바이너리로 유지됩니다 ().</target>
        </trans-unit>
        <trans-unit id="21de803a1e4d911ea618dcf97a6a267f7c0e0c32" translate="yes" xml:space="preserve">
          <source>Whether or not to enforce the RFC 6733 requirement that any message before capabilities exchange should close the peer connection. If false then unexpected messages are discarded.</source>
          <target state="translated">기능을 교환하기 전에 모든 메시지가 피어 연결을 닫아야한다는 RFC 6733 요구 사항을 적용할지 여부입니다. false이면 예기치 않은 메시지가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4c4bdd79e26083d0f89cc38d1b9e82950a842605" translate="yes" xml:space="preserve">
          <source>Whether or not to regard an AVP setting the M-bit as erroneous when the command grammar in question does not explicitly allow the AVP. If &lt;code&gt;true&lt;/code&gt; then such AVPs are regarded as 5001 errors, DIAMETER_AVP_UNSUPPORTED. If &lt;code&gt;false&lt;/code&gt; then the M-bit is ignored and policing it becomes the receiver's responsibility.</source>
          <target state="translated">문제의 명령 문법이 AVP를 명시 적으로 허용하지 않는 경우 M- 비트를 M- 비트로 설정하는 AVP를 잘못된 것으로 간주할지 여부 경우에는 &lt;code&gt;true&lt;/code&gt; 다음과 같은 AVPs가 5001 오류로 간주, DIAMETER_AVP_UNSUPPORTED. &lt;code&gt;false&lt;/code&gt; 경우 M 비트가 무시되고 폴리싱이 수신자의 책임이됩니다.</target>
        </trans-unit>
        <trans-unit id="48a11d24108508650ea1d77cab3defeb042c79b6" translate="yes" xml:space="preserve">
          <source>Whether or not to require that the number of AVPs in a message or grouped AVP agree with those specified in the dictionary in question when passing messages to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. If &lt;code&gt;true&lt;/code&gt; then mismatches in an outgoing messages cause message encoding to fail, while mismatches in an incoming message are reported as 5005/5009 errors in the errors field of the diameter_packet record passed to &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callbacks. If &lt;code&gt;false&lt;/code&gt; then neither error is enforced/detected. If &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; then errors are only enforced/detected on outgoing or incoming messages respectively.</source>
          <target state="translated">&lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백에 메시지를 전달할 때 메시지 또는 그룹화 된 AVP의 AVP 수가 해당 사전에 지정된 것과 일치해야하는지 여부 입니다. &lt;code&gt;true&lt;/code&gt; 인 경우 발신 메시지의 불일치로 인해 메시지 인코딩이 실패하지만 수신 메시지의 불일치는 &lt;code&gt;handle_request/3&lt;/code&gt; 또는 &lt;code&gt;handle_answer/4&lt;/code&gt; 콜백으로 전달 된 diameter_packet 레코드의 오류 필드에서 5005/5009 오류로보고됩니다 . &lt;code&gt;false&lt;/code&gt; 인 경우 오류가 발생하거나 감지되지 않습니다. 인 &lt;code&gt;encode&lt;/code&gt; 또는 &lt;code&gt;decode&lt;/code&gt; 경우 오류는 발신 또는 수신 메시지에서만 각각 시행 / 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="b9cad2d39a7de589e0dd2507f90944f85bceec69" translate="yes" xml:space="preserve">
          <source>Whether the state machine should use &lt;strong&gt;state enter calls&lt;/strong&gt; or not is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상태 시스템이 &lt;strong&gt;상태 입력 호출을&lt;/strong&gt; 사용해야하는지 여부는 &lt;code&gt;gen_statem&lt;/code&gt; 을 시작할 때 와 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 사용하여 코드를 변경 한 후 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2b42f4f8ca231f51435d252ac3a5d231d8995a9" translate="yes" xml:space="preserve">
          <source>Whether the whole table is traversed or only some keys looked up depends on how the query is expressed. If the query has the form</source>
          <target state="translated">전체 테이블을 순회하는지 또는 일부 키만 조회하는지는 쿼리가 표현되는 방식에 따라 다릅니다. 쿼리의 형식이</target>
        </trans-unit>
        <trans-unit id="13c9973a4e7550104891acf7d7dc61bcaff3e712" translate="yes" xml:space="preserve">
          <source>Which OTP versions are &lt;code&gt;kernel-3.0&lt;/code&gt; part of?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; 일부인 OTP 버전은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6d10cf7cff62e6ebcafd8d63acafb6450f487b40" translate="yes" xml:space="preserve">
          <source>Which SNMP version to use is implicitly defined by specifying the Message Processing Model. This version of the agent handles the models &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2c&lt;/code&gt; and &lt;code&gt;v3&lt;/code&gt;.</source>
          <target state="translated">사용할 SNMP 버전은 메시지 처리 모델을 지정하여 암시 적으로 정의됩니다. 이 버전의 에이전트는 모델 &lt;code&gt;v1&lt;/code&gt; , &lt;code&gt;v2c&lt;/code&gt; 및 &lt;code&gt;v3&lt;/code&gt; 을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="2a1a0280b4f0af887bbcb8c357efdf2ef49d1504" translate="yes" xml:space="preserve">
          <source>Which SNMP versions shall be accepted/used.</source>
          <target state="translated">어떤 SNMP 버전이 허용 / 사용되어야합니까.</target>
        </trans-unit>
        <trans-unit id="8a387616ccaf26279c59014305b3dd869652107e" translate="yes" xml:space="preserve">
          <source>Which applications to be added, that is, applications listed in &lt;code&gt;Name2.rel&lt;/code&gt; but not in &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">어떤 응용 프로그램은 응용 프로그램에 나와, 즉, 추가 할 &lt;code&gt;Name2.rel&lt;/code&gt; 에 있지만 &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c14de31b7a3bcb7b1d01171585a9e9bb567167c" translate="yes" xml:space="preserve">
          <source>Which applications to be deleted, that is, applications listed in &lt;code&gt;Name.rel&lt;/code&gt; but not in &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">어떤 응용 프로그램, 즉,에 나열된 응용 프로그램을 삭제할 &lt;code&gt;Name.rel&lt;/code&gt; 을 에 있지만 &lt;code&gt;Name2.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5aceb77b6ae808863618fd33ff3e5c13a692594" translate="yes" xml:space="preserve">
          <source>Which applications to be upgraded/downgraded, that is, applications listed in both &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt; but with different versions</source>
          <target state="translated">업그레이드 / 다운 그레이드 할 응용 프로그램, 즉 &lt;code&gt;Name.rel&lt;/code&gt; 과 &lt;code&gt;Name2.rel&lt;/code&gt; 에 나열되어 있지만 버전이 다른 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="1131f8353bd6250399b31bfd889663a89d780f1a" translate="yes" xml:space="preserve">
          <source>Which applications to include is defined by the &lt;code&gt;included_applications&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">포함 할 애플리케이션 은 &lt;code&gt;.app&lt;/code&gt; 파일 의 &lt;code&gt;included_applications&lt;/code&gt; 키로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="33a2c320d733715d35457cb67d359c1e01e0a90f" translate="yes" xml:space="preserve">
          <source>Which boot script to use is specified by the command-line flag &lt;code&gt;-boot&lt;/code&gt;. The extension &lt;code&gt;.boot&lt;/code&gt; is to be omitted. For example, using the boot script &lt;code&gt;start_all.boot&lt;/code&gt;:</source>
          <target state="translated">사용할 부트 스크립트는 명령 행 플래그 &lt;code&gt;-boot&lt;/code&gt; 에 의해 지정됩니다 . 확장자 &lt;code&gt;.boot&lt;/code&gt; 는 생략해야합니다. 예를 들어, 부팅 스크립트 &lt;code&gt;start_all.boot&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="e50e23f7bb1779588d40d00c39241661c0f072b4" translate="yes" xml:space="preserve">
          <source>Which callback function that handles an event depends on the callback mode:</source>
          <target state="translated">이벤트를 처리하는 콜백 함수는 콜백 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6aa188514432d913525872db6b7914c6a3c8e363" translate="yes" xml:space="preserve">
          <source>Which child processes to start and monitor is specified by a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;. The child processes are started in the order specified by this list, and terminated in the reversed order.</source>
          <target state="translated">시작 및 모니터 할 하위 프로세스는 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; 목록으로 지정됩니다 . 하위 프로세스는이 목록에 지정된 순서대로 시작되고 역순으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd7d6e075a80e211e946c5a2bc1b0d5098a7027" translate="yes" xml:space="preserve">
          <source>Which layout is chosen depends on the available horizontal space. When processing a document, the main parameters are the &lt;strong&gt;paper width&lt;/strong&gt; and the &lt;strong&gt;line width&lt;/strong&gt; (also known as the &quot;ribbon width&quot;). In the resulting layout, no text should be printed beyond the paper width (which by default is 80 characters) as long as it can be avoided, and each single line of text (its indentation not counted, hence &quot;ribbon&quot;) should preferably be no wider than the specified line width (which by default is 65).</source>
          <target state="translated">선택되는 레이아웃은 사용 가능한 수평 공간에 따라 다릅니다. 문서를 처리 할 때 주요 매개 변수는 &lt;strong&gt;용지 너비&lt;/strong&gt; 와 &lt;strong&gt;선 너비&lt;/strong&gt; ( &quot;리본 너비&quot;라고도 함)입니다. 결과 레이아웃에서는 피할 수있는 한 텍스트를 용지 너비 (기본적으로 80 자)를 초과하여 인쇄해서는 안되며 각 텍스트 줄 (들여 쓰기가 포함되지 않으므로 &quot;리본&quot;)을 사용하는 것이 좋습니다. 지정된 선 너비보다 넓지 않아야합니다 (기본적으로 65).</target>
        </trans-unit>
        <trans-unit id="316f8f07fe22b27f60e4007a3b10b3081a7c24ed" translate="yes" xml:space="preserve">
          <source>Which module that is selected to implement the &lt;code&gt;mnesia_frag_hash&lt;/code&gt; behavior for a particular fragmented table is specified together with the other &lt;code&gt;frag_properties&lt;/code&gt;. The &lt;code&gt;hash_module&lt;/code&gt; defines the module name. The &lt;code&gt;hash_state&lt;/code&gt; defines the initial hash state.</source>
          <target state="translated">특정 조각화 된 테이블에 대해 &lt;code&gt;mnesia_frag_hash&lt;/code&gt; 동작 을 구현하기 위해 선택된 모듈이 다른 &lt;code&gt;frag_properties&lt;/code&gt; 와 함께 지정됩니다 . &lt;code&gt;hash_module&lt;/code&gt; 은 모듈의 이름을 정의합니다. &lt;code&gt;hash_state&lt;/code&gt; 는 초기 해시 상태를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="43b9aadd4cf4e0bbe301ebac4cf235c26b5cecf8" translate="yes" xml:space="preserve">
          <source>Which nodes that are allowed to communicate with each other is handled by the magic cookie system, see section &lt;code&gt;Distributed Erlang&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">서로 통신 할 수있는 노드는 매직 쿠키 시스템에 의해 처리됩니다 . Erlang 참조 매뉴얼의 &lt;code&gt;Distributed Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd16373e6ac28a23d9af45a12b0dbd962aedf699" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;start_clean&lt;/code&gt; and &lt;code&gt;start_sasl&lt;/code&gt; to use as default is decided by the user when installing Erlang/OTP using &lt;code&gt;Install&lt;/code&gt;. The user is asked &quot;Do you want to use a minimal system startup instead of the SASL startup&quot;. If the answer is yes, then &lt;code&gt;start_clean&lt;/code&gt; is used, otherwise &lt;code&gt;start_sasl&lt;/code&gt; is used. A copy of the selected boot script is made, named &lt;code&gt;start.boot&lt;/code&gt; and placed in directory &lt;code&gt;ROOT/bin&lt;/code&gt;.</source>
          <target state="translated">어떤 &lt;code&gt;start_clean&lt;/code&gt; 및 &lt;code&gt;start_sasl&lt;/code&gt; 사용 / OTP 얼랑를 설치할 때 기본으로 사용할 사용자에 의해 결정됩니다 &lt;code&gt;Install&lt;/code&gt; . &quot;SASL 시작 대신 최소 시스템 시작을 사용 하시겠습니까?&quot;라는 메시지가 표시됩니다. 대답이 예이면 &lt;code&gt;start_clean&lt;/code&gt; 이 사용되고 그렇지 않으면 &lt;code&gt;start_sasl&lt;/code&gt; 이 사용됩니다. 선택된 부팅 스크립트의 사본이 &lt;code&gt;start.boot&lt;/code&gt; 이고 디렉토리 &lt;code&gt;ROOT/bin&lt;/code&gt; 에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="7821793868ddcbfc00b34e99fc497909e5efa3de" translate="yes" xml:space="preserve">
          <source>Which options are selected</source>
          <target state="translated">선택된 옵션</target>
        </trans-unit>
        <trans-unit id="aae5ae585b22a628f4e51d3c9f19940824f3ef04" translate="yes" xml:space="preserve">
          <source>Which source and target options that can be issued depends on the capabilities supported by the server. That is, &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt; are required.</source>
          <target state="translated">발행 할 수있는 소스 및 대상 옵션은 서버에서 지원하는 기능에 따라 다릅니다. 즉, &lt;code&gt;:candidate&lt;/code&gt; 및 / 또는 &lt;code&gt;:startup&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="790ca84b049e16521ecebee52c49440e1de0020a" translate="yes" xml:space="preserve">
          <source>Which target parameters that can be used depends on if &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt; are supported by the server. If successfull, the configuration system of the device is unavailable to other clients (NETCONF, CORBA, SNMP, and so on). Locks are intended to be short-lived.</source>
          <target state="translated">사용할 수있는 대상 매개 변수 는 서버에서 &lt;code&gt;:candidate&lt;/code&gt; 및 / 또는 &lt;code&gt;:startup&lt;/code&gt; 을 지원 하는지 여부에 따라 다릅니다 . 성공하면 다른 클라이언트 (NETCONF, CORBA, SNMP 등)에서 장치의 구성 시스템을 사용할 수 없습니다. 잠금 장치는 수명이 짧습니다.</target>
        </trans-unit>
        <trans-unit id="c125aa8b69c05ef017f418200c2dd8030095a74e" translate="yes" xml:space="preserve">
          <source>Which types of information that is to be supervised by Erlang</source>
          <target state="translated">Erlang이 감독 할 정보 유형</target>
        </trans-unit>
        <trans-unit id="955269f29db543667262d6a6d8087530a608251f" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;net_kernel&lt;/code&gt; informs different subsystems that the connection is coming up, the port is to accept data to send. However, the port should not receive any data, to avoid that data arrives from another node before every kernel subsystem is prepared to handle it. A third mode, named &lt;code&gt;intermediate&lt;/code&gt;, is used for this intermediate stage.</source>
          <target state="translated">&lt;code&gt;net_kernel&lt;/code&gt; 이 다른 서브 시스템에 연결이 이루어지고 있음을 알리는 동안 포트는 전송할 데이터를 승인해야합니다. 그러나 포트는 모든 커널 서브 시스템이 처리 할 준비가되기 전에 다른 노드에서 데이터가 도착하지 않도록 데이터를 수신해서는 안됩니다. 이 중간 단계 에는 &lt;code&gt;intermediate&lt;/code&gt; 이라는 세 번째 모드 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae9d92c09d1918bae1349f12a4c25f948966b648" translate="yes" xml:space="preserve">
          <source>While a process executes a dirty NIF, some operations that communicate with it can take a very long time to complete. Suspend or garbage collection of a process executing a dirty NIF cannot be done until the dirty NIF has returned. Thus, other processes waiting for such operations to complete might have to wait for a very long time. Blocking multi-scheduling, that is, calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_multi_scheduling&quot;&gt;erlang:system_flag(multi_scheduling, block)&lt;/a&gt;&lt;/code&gt;, can also take a very long time to complete. This is because all ongoing dirty operations on all dirty schedulers must complete before the block operation can complete.</source>
          <target state="translated">프로세스가 더티 NIF를 실행하는 동안 프로세스와 통신하는 일부 작업을 완료하는 데 시간이 오래 걸릴 수 있습니다. 더티 NIF가 리턴 될 때까지 더티 NIF를 실행하는 프로세스의 일시 중단 또는 가비지 콜렉션을 수행 할 수 없습니다. 따라서 이러한 작업이 완료되기를 기다리는 다른 프로세스는 매우 오래 기다려야 할 수 있습니다. 다중 스케줄링 차단, 즉 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_multi_scheduling&quot;&gt;erlang:system_flag(multi_scheduling, block)&lt;/a&gt;&lt;/code&gt; 호출 도 완료하는 데 시간이 오래 걸릴 수 있습니다. 이는 모든 더티 스케줄러에서 진행중인 더티 작업이 블록 작업을 완료하기 전에 완료해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f3c968926507d13833578dd04fa0445ed14918eb" translate="yes" xml:space="preserve">
          <source>While a service typically implements a single Diameter node (as identified by an Origin-Host AVP), transports can themselves be associated with capabilities AVPs so that a single service can be used to implement more than one Diameter node.</source>
          <target state="translated">서비스는 일반적으로 단일 직경 노드 (Origin-Host AVP로 식별)를 구현하지만 전송 자체는 기능 AVP와 연관 될 수 있으므로 단일 서비스를 사용하여 둘 이상의 직경 노드를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba190fb267746cc8b0c9573844864941c2b36751" translate="yes" xml:space="preserve">
          <source>While doing this, the message passing interface between the shell, the client, and the server is cleaned up and is defined using &lt;strong&gt;records&lt;/strong&gt;. Also, &lt;strong&gt;macros&lt;/strong&gt; are introduced:</source>
          <target state="translated">이 작업을 수행하는 동안 쉘, 클라이언트 및 서버 간의 메시지 전달 인터페이스가 정리되고 &lt;strong&gt;records를&lt;/strong&gt; 사용하여 정의됩니다 . 또한 &lt;strong&gt;매크로&lt;/strong&gt; 가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4bcae748a242838e1ff319d8c4a5667ec31db32" translate="yes" xml:space="preserve">
          <source>While in &quot;plain Erlang&quot;, a process is said to terminate normally only for exit reason &lt;code&gt;normal&lt;/code&gt;, a process started using &lt;code&gt;proc_lib&lt;/code&gt; is also said to terminate normally if it exits with reason &lt;code&gt;shutdown&lt;/code&gt; or &lt;code&gt;{shutdown,Term}&lt;/code&gt;. &lt;code&gt;shutdown&lt;/code&gt; is the reason used when an application (supervision tree) is stopped.</source>
          <target state="translated">&quot;plain Erlang&quot;에서 프로세스는 종료 이유 &lt;code&gt;normal&lt;/code&gt; 에 대해서만 정상적으로 종료한다고하며 , &lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 시작된 프로세스는 &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이유로 종료 되면 정상적으로 종료된다고합니다 . &lt;code&gt;shutdown&lt;/code&gt; 는 응용 프로그램 (감독 트리)이 중지 될 때 사용되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="4bb116c6c8689b91ebdb4eb3a65df11a70e53e50" translate="yes" xml:space="preserve">
          <source>While it is strongly encouraged that the encoding of characters in binary data is known before processing, that is not always possible. On a typical Linux system, there is a mix of UTF-8 and ISO Latin-1 text files, and there are seldom any BOMs in the files to identify them.</source>
          <target state="translated">이진 데이터의 문자 인코딩을 처리하기 전에 알고 있어야하지만 항상 가능한 것은 아닙니다. 일반적인 Linux 시스템에는 UTF-8과 ISO Latin-1 텍스트 파일이 혼합되어 있으며 파일에 BOM이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="25bf671ec448e1f371e002321038f9fb00ec1499" translate="yes" xml:space="preserve">
          <source>While ordinary list comprehensions evaluate to lists, calling &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; returns a &lt;strong id=&quot;query_handle&quot;&gt;query handle&lt;/strong&gt;. To obtain all the answers to a query, &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; is to be called with the query handle as first argument. Query handles are essentially functional objects (funs) created in the module calling &lt;code&gt;q/1,2&lt;/code&gt;. As the funs refer to the module code, be careful not to keep query handles too long if the module code is to be replaced. Code replacement is described in section &lt;code&gt;Compilation and Code Loading&lt;/code&gt; in the Erlang Reference Manual. The list of answers can also be traversed in chunks by use of a &lt;strong id=&quot;query_cursor&quot;&gt;query cursor&lt;/strong&gt;. Query cursors are created by calling &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; with a query handle as first argument. Query cursors are essentially Erlang processes. One answer at a time is sent from the query cursor process to the process that created the cursor.</source>
          <target state="translated">일반적인 목록 이해가 목록으로 평가되는 동안 &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; 를 호출 하면 &lt;strong id=&quot;query_handle&quot;&gt;쿼리 핸들이&lt;/strong&gt; 반환 됩니다. 쿼리에 대한 모든 답변을 얻으려면 쿼리 핸들을 첫 번째 인수로 사용하여 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; 를 호출해야합니다. 조회 핸들은 본질적으로 &lt;code&gt;q/1,2&lt;/code&gt; 를 호출하는 모듈에서 작성된 기능적 오브젝트 (fun)입니다 . 재미는 모듈 코드를 참조하므로 모듈 코드를 교체 할 경우 쿼리 핸들을 너무 오래 유지하지 않도록주의하십시오. 코드 교체는 Erlang 참조 매뉴얼의 &lt;code&gt;Compilation and Code Loading&lt;/code&gt; 섹션에 설명되어 있습니다. &lt;strong id=&quot;query_cursor&quot;&gt;쿼리 커서를&lt;/strong&gt; 사용하여 응답 목록을 청크 단위로 순회 할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하여 쿼리 커서를 만듭니다.쿼리 핸들을 첫 번째 인수로 사용합니다. 쿼리 커서는 본질적으로 Erlang 프로세스입니다. 쿼리 커서 프로세스에서 커서를 만든 프로세스로 한 번에 하나의 응답이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfb7e0b8e7246045409ca78f0b6e5dc307f3fb9" translate="yes" xml:space="preserve">
          <source>While running, &lt;code&gt;run_erl&lt;/code&gt; sends all output, uninterpreted, to a log file. The file is named &lt;code&gt;erlang.log.N&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. When the log is &quot;full&quot; (default log size is 100 KB), &lt;code&gt;run_erl&lt;/code&gt; starts to log in file &lt;code&gt;erlang.log.(N+1)&lt;/code&gt;, until &lt;code&gt;N&lt;/code&gt; reaches a certain number (default 5), whereupon &lt;code&gt;N&lt;/code&gt; starts at 1 again and the oldest files start getting overwritten.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; 은 실행 중에 해석되지 않은 모든 출력을 로그 파일로 보냅니다. 파일 이름은 &lt;code&gt;erlang.log.N&lt;/code&gt; 이며 여기서 &lt;code&gt;N&lt;/code&gt; 은 정수입니다. 로그가 &quot;전체&quot;(기본 로그 크기 100 KB입니다) &lt;code&gt;run_erl&lt;/code&gt; 이 파일에 기록하기 시작 &lt;code&gt;erlang.log.(N+1)&lt;/code&gt; 까지 &lt;code&gt;N&lt;/code&gt; 이 가는데, 특정 숫자 (기본값 5)에 도달 &lt;code&gt;N&lt;/code&gt; 은 다시 1에서 시작하고 가장 오래된 파일을 덮어 쓰기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0723cb3c16ddecdf0655aeda6e04632653e741f7" translate="yes" xml:space="preserve">
          <source>While strings can be input as Unicode characters, the language elements are still limited to the ISO Latin-1 character set. Only character constants and strings are allowed to be beyond that range:</source>
          <target state="translated">문자열은 유니 코드 문자로 입력 할 수 있지만 언어 요소는 여전히 ISO Latin-1 문자 세트로 제한됩니다. 문자 상수 및 문자열 만 해당 범위를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d8d8c326ee6b24ea1889f95470be78998df6197" translate="yes" xml:space="preserve">
          <source>White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space.</source>
          <target state="translated">Perl이이 문자를 공백으로 처리하지 않았기 때문에 공백은 VT 문자 (코드 11)를 포함하는 데 사용되지 않았습니다. 그러나 Perl은 릴리스 5.18에서 변경되었으므로 PCRE는 릴리스 8.34를 따르고 VT는 이제 공백으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1595814deaf00e4f6e3b44cb9377e2fe011e37cf" translate="yes" xml:space="preserve">
          <source>White-box testing of Erlang/OTP programs. This is easily done by calling the target API functions directly from the test case functions.</source>
          <target state="translated">Erlang / OTP 프로그램의 화이트 박스 테스트. 테스트 케이스 함수에서 직접 대상 API 함수를 호출하여 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b805e34456a2ce3669e5a13c32900b36e9845bc0" translate="yes" xml:space="preserve">
          <source>Whitespace (the same as \s from PCRE 8.34)</source>
          <target state="translated">공백 (PCRE 8.34의 \ s와 동일)</target>
        </trans-unit>
        <trans-unit id="de4842c6983b52e491b9f291872a3e7f3d936bc9" translate="yes" xml:space="preserve">
          <source>Whitespace characters (&lt;strong&gt;Space&lt;/strong&gt;, &lt;strong&gt;Tab&lt;/strong&gt;, and &lt;strong&gt;Newline&lt;/strong&gt;) that cause input to be read to the next non-whitespace character.</source>
          <target state="translated">공백이 아닌 다음 문자로 입력을 읽게하는 공백 문자 ( &lt;strong&gt;Space&lt;/strong&gt; , &lt;strong&gt;Tab&lt;/strong&gt; 및 &lt;strong&gt;Newline&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="84821441f4b8972977e4408981126dbb04ab2772" translate="yes" xml:space="preserve">
          <source>Will give the result &lt;code&gt;result_export.html&lt;/code&gt;</source>
          <target state="translated">결과 &lt;code&gt;result_export.html&lt;/code&gt; 을 줄 것이다</target>
        </trans-unit>
        <trans-unit id="e29aa56423ffafb3741063ceeff0a780f65c606d" translate="yes" xml:space="preserve">
          <source>Windows NT documentation</source>
          <target state="translated">Windows NT 설명서</target>
        </trans-unit>
        <trans-unit id="e645b2615d352bd6061745efc2717f7e035245ab" translate="yes" xml:space="preserve">
          <source>Windows and, for most common uses, MacOS X enforce Unicode support for filenames. All files created in the file system have names that can consistently be interpreted. In MacOS X, all filenames are retrieved in UTF-8 encoding. In Windows, each system call handling filenames has a special Unicode-aware variant, giving much the same effect. There are no filenames on these systems that are not Unicode filenames. So, the default behavior of the Erlang VM is to work in &quot;Unicode filename translation mode&quot;. This means that a filename can be specified as a Unicode list, which is automatically translated to the proper name encoding for the underlying operating system and file system.</source>
          <target state="translated">Windows 및 대부분의 일반적인 용도로 MacOS X은 파일 이름에 대한 유니 코드 지원을 시행합니다. 파일 시스템에서 작성된 모든 파일의 이름은 일관되게 해석 될 수 있습니다. MacOS X에서 모든 파일 이름은 UTF-8 인코딩으로 검색됩니다. Windows에서 각 시스템 호출 처리 파일 이름에는 특수한 유니 코드 인식 변형이 있으므로 거의 동일한 효과를 나타냅니다. 이러한 시스템에는 유니 코드 파일 이름이 아닌 파일 이름이 없습니다. 따라서 Erlang VM의 기본 동작은 &quot;유니 코드 파일 이름 변환 모드&quot;에서 작동하는 것입니다. 즉, 파일 이름을 유니 코드 목록으로 지정할 수 있으며 기본 운영 체제 및 파일 시스템에 적합한 이름 인코딩으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c125c4bf69fac9a29c86e4b1d481c02bb71651ac" translate="yes" xml:space="preserve">
          <source>Windows example: &lt;code&gt;D:/usr/local/bin&lt;/code&gt;</source>
          <target state="translated">Windows 예 : &lt;code&gt;D:/usr/local/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3b9d2244d29790aefa539ade087712dcc74c2b4" translate="yes" xml:space="preserve">
          <source>Windows example: &lt;code&gt;D:bar.erl, /bar/foo.erl&lt;/code&gt;</source>
          <target state="translated">Windows 예 : &lt;code&gt;D:bar.erl, /bar/foo.erl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edc4359fd495b4e83d92738738521dff7c9648fc" translate="yes" xml:space="preserve">
          <source>Windows specific C-code goes in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt;, &lt;code&gt;$ERL_TOP/erts/emulator/drivers/win32&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt;.</source>
          <target state="translated">Windows 고유의 C 코드는 &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; , &lt;code&gt;$ERL_TOP/erts/emulator/drivers/win32&lt;/code&gt; 또는 &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cebe814814fa7a01f7252bacdb196a2415e7c2cc" translate="yes" xml:space="preserve">
          <source>Windows specific erlang code should be used conditionally and the host OS tested in &lt;strong&gt;runtime&lt;/strong&gt;, the exactly same beam files should be distributed for every platform! So write code like:</source>
          <target state="translated">Windows 고유의 erlang 코드는 조건부로 사용되어야하며 호스트 OS는 &lt;strong&gt;런타임에&lt;/strong&gt; 테스트 해야합니다. 모든 플랫폼에 대해 정확히 동일한 빔 파일을 배포해야합니다! 따라서 다음과 같은 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9153ae7e742cafd43f95ca717cf1dfe512956eb4" translate="yes" xml:space="preserve">
          <source>Windows users probably want to use the &lt;code&gt;werl&lt;/code&gt; program instead, which runs in its own window with scrollbars and supports command-line editing. The &lt;code&gt;erl&lt;/code&gt; program on Windows provides no line editing in its shell, and on Windows 95 there is no way to scroll back to text that has scrolled off the screen. The &lt;code&gt;erl&lt;/code&gt; program must be used, however, in pipelines or if you want to redirect standard input or output.</source>
          <target state="translated">Windows 사용자 는 스크롤 막대가있는 자체 창에서 실행되며 명령 줄 편집을 지원 하는 &lt;code&gt;werl&lt;/code&gt; 프로그램을 대신 사용하려고합니다 . Windows 의 &lt;code&gt;erl&lt;/code&gt; 프로그램은 쉘에서 행 편집을 제공하지 않으며 Windows 95에서는 화면에서 스크롤 된 텍스트로 다시 스크롤 할 수 없습니다. 그러나 &lt;code&gt;erl&lt;/code&gt; 프로그램은 파이프 라인 또는 표준 입력 또는 출력을 리디렉션하려는 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d01fbb62689c9a50dbc798199c8abe5404a70e39" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SnmpAppConfName&lt;/code&gt; SNMP applications can be configured with parameters &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;net_if&lt;/code&gt;, and so on. The values are merged with (and possibly override) default values set by &lt;code&gt;ct_snmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SnmpAppConfName&lt;/code&gt; 을 사용하면 &lt;code&gt;config&lt;/code&gt; , &lt;code&gt;mibs&lt;/code&gt; , &lt;code&gt;net_if&lt;/code&gt; 등의 매개 변수로 SNMP 응용 프로그램을 구성 할 수 있습니다 . 값은 &lt;code&gt;ct_snmp&lt;/code&gt; 에 의해 설정된 기본값과 병합 (및 무시 가능)됩니다 .</target>
        </trans-unit>
        <trans-unit id="57de975e4ed5eb1eb7a9bb8718be7fce417a91ff" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;handle_event_function&lt;/code&gt;, you are free to mix strategies, as all events and states are handled in the same callback function.</source>
          <target state="translated">&lt;code&gt;handle_event_function&lt;/code&gt; 을 사용하면 모든 이벤트와 상태가 동일한 콜백 함수에서 처리되므로 전략을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dfbb3d46433438978efd2890875149c5eda9a4" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inet6fb4&lt;/code&gt; the client behaves as before, that is, tries to use IPv6, and only if that does not work it uses IPv4).</source>
          <target state="translated">함께 &lt;code&gt;inet6fb4&lt;/code&gt; 입니다 이전과 클라이언트 동작합니다,)의 IPv6를 사용하려고하고, 문제가 해결되지 않는 경우에만이 IPv4를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b18128932919ee9e9b89c4f5f6d45d4fabc7e543" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;state_functions&lt;/code&gt;, you are restricted to use atom-only states, and the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name for you. This encourages the callback module to co-locate the implementation of all event actions particular to one state in the same place in the code, hence to focus on one state at the time.</source>
          <target state="translated">로 &lt;code&gt;state_functions&lt;/code&gt; , 당신은 사용 원자 전용 상태로 제한되며, &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진 지사는 당신을위한 국가의 이름에 따라 달라집니다. 이것은 콜백 모듈이 코드에서 같은 장소에있는 하나의 상태에 특정한 모든 이벤트 액션의 구현을 같은 위치에 배치 할 것을 권장하므로 한 번에 하나의 상태에만 집중합니다.</target>
        </trans-unit>
        <trans-unit id="08bf3be09bca46d50f5c39e4638f13ff1f2f5384" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;tp&lt;/code&gt; and &lt;code&gt;tpl&lt;/code&gt;, one of the match specification shortcuts can be used (for example, &lt;code&gt;ttb:tp(foo_module, caller)&lt;/code&gt;).</source>
          <target state="translated">함께 &lt;code&gt;tp&lt;/code&gt; 및 &lt;code&gt;tpl&lt;/code&gt; , 경기 사양 바로 가기 중 하나를 사용할 수 있습니다 (예를 들어, &lt;code&gt;ttb:tp(foo_module, caller)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b6d97c65f416ad5168b9a2206a566140bcf2447d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;userdata&lt;/code&gt;, the user can specify any test case group related information that can be read by calling &lt;code&gt;&lt;a href=&quot;ct#userdata-2&quot;&gt;ct:userdata/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 를 사용하면 &lt;code&gt;&lt;a href=&quot;ct#userdata-2&quot;&gt;ct:userdata/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 읽을 수있는 테스트 케이스 그룹 관련 정보를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d403f91ef998735296b5b06b5d85b55c07feac9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;userdata&lt;/code&gt;, the user can specify any test case-related information that can be read by calling &lt;code&gt;&lt;a href=&quot;ct#userdata-3&quot;&gt;ct:userdata/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 를 사용하면 &lt;code&gt;&lt;a href=&quot;ct#userdata-3&quot;&gt;ct:userdata/3&lt;/a&gt;&lt;/code&gt; 를 호출하여 읽을 수있는 테스트 케이스 관련 정보를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ea441d926510f27d6d163d5468ba669996dc2de" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;userdata&lt;/code&gt;, the user can specify any test suite-related information, which can be read by calling &lt;code&gt;&lt;a href=&quot;ct#userdata-2&quot;&gt;ct:userdata/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 를 사용하면 &lt;code&gt;&lt;a href=&quot;ct#userdata-2&quot;&gt;ct:userdata/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 읽을 수있는 테스트 스위트 관련 정보를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26f6a3b686eca5b0930dd9afa29c9f563535a61e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;xslapply&lt;/code&gt; you tell the XSLT processor in which order it should traverse the XML structure. By default it goes in preorder traversal, but with the following we make a deliberate choice to break that order:</source>
          <target state="translated">&lt;code&gt;xslapply&lt;/code&gt; 를 사용 하면 XSLT 프로세서에게 XML 구조를 순회하는 순서를 알려줍니다. 기본적으로 사전 주문 순회가 진행되지만 다음과 같이 순서를 어길 의도적으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b3db18a9d447bf83ba06466f404b33da7b98fa17" translate="yes" xml:space="preserve">
          <source>With Erlang/OTP R16A came support for UTF-8 encoded source code, with enhancements to many of the applications to support both Unicode encoded filenames and support for UTF-8 encoded files in many circumstances. Most notable is the support for UTF-8 in files read by &lt;code&gt;file:consult/1&lt;/code&gt;, release handler support for UTF-8, and more support for Unicode character sets in the I/O system.</source>
          <target state="translated">Erlang / OTP와 함께 R16A는 UTF-8로 인코딩 된 소스 코드를 지원하며, 많은 환경에서 유니 코드로 인코딩 된 파일 이름과 UTF-8로 인코딩 된 파일을 모두 지원하는 많은 응용 프로그램이 향상되었습니다. 가장 주목할만한 것은 &lt;code&gt;file:consult/1&lt;/code&gt; 로 읽은 파일 에서 UTF-8 지원, UTF-8에 대한 릴리스 핸들러 지원 및 I / O 시스템에서 유니 코드 문자 세트에 대한 추가 지원입니다.</target>
        </trans-unit>
        <trans-unit id="b52c5284cd1c07c72e9a816bd1d34fef08587e9d" translate="yes" xml:space="preserve">
          <source>With a call to &lt;code&gt;block/1,2&lt;/code&gt; a process can block a log. If the blocking process is not an owner of the log, a temporary link is created between the disk log process and the blocking process. The link ensures that the disk log is unblocked if the blocking process terminates without first closing or unblocking the log.</source>
          <target state="translated">&lt;code&gt;block/1,2&lt;/code&gt; 호출 하면 프로세스가 로그를 차단할 수 있습니다. 차단 프로세스가 로그의 소유자가 아닌 경우 디스크 로그 프로세스와 차단 프로세스간에 임시 링크가 작성됩니다. 링크는 먼저 로그를 닫거나 차단 해제하지 않고 차단 프로세스가 종료되면 디스크 로그가 차단 해제되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c2f4e2815603bcfb42c9bd32a938d30836c2464a" translate="yes" xml:space="preserve">
          <source>With a function like &lt;code&gt;test/0&lt;/code&gt;, the whole example can be started:</source>
          <target state="translated">&lt;code&gt;test/0&lt;/code&gt; 과 같은 함수를 사용 하면 전체 예제를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b67278f00ea241bbed8eb4a0425fcb14e74474" translate="yes" xml:space="preserve">
          <source>With all the default values presented, a get request can also be written as follows:</source>
          <target state="translated">모든 기본값을 제시하면 다음과 같이 get 요청을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ab3e3e9a50d6aefe38373ab75bc2cd653fa049" translate="yes" xml:space="preserve">
          <source>With both maximizing (&quot;greedy&quot;) and minimizing (&quot;ungreedy&quot; or &quot;lazy&quot;) repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the remaining pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it to fail earlier than it otherwise might, when the author of the pattern knows that there is no point in carrying on.</source>
          <target state="translated">반복 (maximed) 및 최소화 ( &quot;ungreedy&quot;또는 &quot;lazy&quot;) 반복을 모두 수행하면, 일반적으로 뒤 따르는 항목이 실패하면 반복되는 항목을 다시 평가하여 다른 반복 횟수로 나머지 패턴이 일치하는지 확인합니다. 패턴의 작성자가 수행 할 점이 없다는 것을 알고있을 때, 일치를 막거나, 그렇지 않은 경우보다 빨리 실패하게하는 것을 방지하는 것이 유용한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f551d167438796ba8d34f3a93d3437c922c918" translate="yes" xml:space="preserve">
          <source>With configuration terms it is, for example, possible to do the following:</source>
          <target state="translated">구성 용어를 사용하면 예를 들어 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4782bd374a84a1af126f620034c11a07e9940a44" translate="yes" xml:space="preserve">
          <source>With lock contention we mean when one thread locks a resource and another thread, or threads, tries to acquire the same resource at the same time. The lock will deny the other thread access to the resource and the thread will be blocked from continuing its execution. The second thread has to wait until the first thread has completed its access to the resource and unlocked it. The &lt;code&gt;lcnt&lt;/code&gt; tool measures these lock conflicts.</source>
          <target state="translated">잠금 경합은 한 스레드가 리소스를 잠그고 다른 스레드가 동시에 동일한 리소스를 얻으려고 할 때를 의미합니다. 잠금은 리소스에 대한 다른 스레드 액세스를 거부하고 스레드가 계속 실행되지 못하게 차단합니다. 두 번째 스레드는 첫 번째 스레드가 리소스에 대한 액세스를 완료하고 잠금을 해제 할 때까지 기다려야합니다. &lt;code&gt;lcnt&lt;/code&gt; 의 도구는 이러한 잠금 충돌을 측정한다.</target>
        </trans-unit>
        <trans-unit id="c0a911f73e6123e20f8f0f466f4a6626750c6c0c" translate="yes" xml:space="preserve">
          <source>With one parameter this function disables tracing like the Erlang call &lt;code&gt;erlang:trace(self(), false, [P2])&lt;/code&gt;, where &lt;code&gt;P2&lt;/code&gt; is the parameter to &lt;code&gt;disable_trace&lt;/code&gt;.</source>
          <target state="translated">하나의 매개 변수를 사용하면이 함수는 Erlang 호출 &lt;code&gt;erlang:trace(self(), false, [P2])&lt;/code&gt; 와 같은 추적을 사용하지 않습니다 . 여기서 &lt;code&gt;P2&lt;/code&gt; 는 &lt;code&gt;disable_trace&lt;/code&gt; 의 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="e6d4ec70aba9d4e8b5fe9586efa00b26788175fc" translate="yes" xml:space="preserve">
          <source>With one parameter this function turns on tracing like the Erlang call &lt;code&gt;erlang:trace(self(), true, [P2])&lt;/code&gt;, where &lt;code&gt;P2&lt;/code&gt; is the parameter to &lt;code&gt;enable_trace&lt;/code&gt;.</source>
          <target state="translated">하나의 매개 변수를 사용하면이 함수는 Erlang 호출 &lt;code&gt;erlang:trace(self(), true, [P2])&lt;/code&gt; 와 같이 추적 을 &lt;code&gt;enable_trace&lt;/code&gt; . 여기서 &lt;code&gt;P2&lt;/code&gt; 는 enable_trace 의 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="c093c24e555eafd436e8bce479692e3fa910c4f5" translate="yes" xml:space="preserve">
          <source>With option &lt;code&gt;notempty&lt;/code&gt;, this match is invalid, so &lt;code&gt;run/3&lt;/code&gt; searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.</source>
          <target state="translated">&lt;code&gt;notempty&lt;/code&gt; 옵션을 사용하면 이 일치가 유효하지 않으므로 &lt;code&gt;run/3&lt;/code&gt; 은 문자열에서 &quot;a&quot;또는 &quot;b&quot;의 발생을 추가로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="66c1ff43299959efe80c7cf44d78f925f082f664" translate="yes" xml:space="preserve">
          <source>With relaxed command checking enabled, you can forcibly unregister live nodes.</source>
          <target state="translated">완화 된 명령 검사를 사용하면 라이브 노드를 강제로 등록 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7efd92dfbce122d4c020902f9bb3ba15456f6a1" translate="yes" xml:space="preserve">
          <source>With relaxed command checking, the &lt;code&gt;epmd&lt;/code&gt; daemon can be killed from the local host with, for example, command &lt;code&gt;epmd -kill&lt;/code&gt; even if active nodes are registered. Normally only daemons with an empty node database can be killed with &lt;code&gt;epmd -kill&lt;/code&gt;.</source>
          <target state="translated">완화 된 명령 검사를 사용 하면 활성 노드가 등록 된 경우에도 &lt;code&gt;epmd -kill&lt;/code&gt; 명령을 사용하여 로컬 호스트에서 &lt;code&gt;epmd&lt;/code&gt; 데몬을 종료 할 수 있습니다 . 일반적으로 비어있는 노드 데이터베이스가있는 데몬 만 &lt;code&gt;epmd -kill&lt;/code&gt; 을 사용 하여 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2f85c3f99d3d1f3a8aa5a200831ddee6512d66" translate="yes" xml:space="preserve">
          <source>With start flag &lt;code&gt;logopts&lt;/code&gt; options that modify some aspects of the logging behavior can be specified. The following options are available:</source>
          <target state="translated">시작 플래그 &lt;code&gt;logopts&lt;/code&gt; 를 사용하면 로깅 동작의 일부 측면을 수정하는 옵션을 지정할 수 있습니다. 다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d54fc2cd61b28fbb0b2ac41225b9c06890a3db" translate="yes" xml:space="preserve">
          <source>With term &lt;code&gt;init&lt;/code&gt; it is possible to specify initialization options for nodes defined in the test specification. There are options to start the node and to evaluate any function on the node. For details, see section &lt;code&gt;&lt;a href=&quot;ct_master_chapter#ct_slave&quot;&gt;Automatic Startup of Test Target Nodes&lt;/a&gt;&lt;/code&gt; in section Using Common Test for Large Scale Testing.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 라는 용어 를 사용하면 테스트 사양에 정의 된 노드의 초기화 옵션을 지정할 수 있습니다. 노드를 시작하고 노드의 기능을 평가하는 옵션이 있습니다. 자세한 내용 은 대규모 테스트에 공통 테스트 사용 섹션 &lt;code&gt;&lt;a href=&quot;ct_master_chapter#ct_slave&quot;&gt;Automatic Startup of Test Target Nodes&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c19b360c1da842dcfaf494562528f8e12e57f86" translate="yes" xml:space="preserve">
          <source>With test specification terms, it is possible to state exactly which tests to run and in which order. A test term specifies either one or more suites, one or more test case groups (possibly nested), or one or more test cases in a group (or in multiple groups) or in a suite.</source>
          <target state="translated">테스트 사양 용어를 사용하면 실행할 테스트와 순서를 정확하게 지정할 수 있습니다. 테스트 용어는 하나 이상의 스위트, 하나 이상의 테스트 케이스 그룹 (중첩 될 수 있음) 또는 그룹 (또는 여러 그룹) 또는 스위트의 하나 이상의 테스트 케이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e9e2ec8e2fd04041ccaf4a5dc724d5cd559f81d9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;EngineId&lt;/code&gt; argument it is possible to override the configured engine-id (SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 인수를 사용하면 구성된 engine-id (SNMP-FRAMEWORK-MIB)를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="802475deadf3a5ea8c927f887684eb19f0efa3d2" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;ct_run&lt;/code&gt; flag, or &lt;code&gt;ct:run_test/1&lt;/code&gt; option &lt;code&gt;group&lt;/code&gt;, one or more test case groups can be specified, optionally in combination with specific test cases. The syntax for specifying groups on the command line is as follows:</source>
          <target state="translated">으로 &lt;code&gt;ct_run&lt;/code&gt; 의 깃발, 또는 &lt;code&gt;ct:run_test/1&lt;/code&gt; 옵션 &lt;code&gt;group&lt;/code&gt; , 하나 이상의 테스트 케이스 그룹 선택적으로 특정 테스트 케이스와 함께 지정할 수 있습니다. 명령 행에서 그룹을 지정하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a3d4b278ce9ee7d8ad86780267fb6dd94072350" translate="yes" xml:space="preserve">
          <source>With the Emacs editor, the &lt;code&gt;next-error&lt;/code&gt; (&lt;code&gt;C-X `&lt;/code&gt;) function can be used indicate where a compilation error occurred, provided the error message is described by a line number.</source>
          <target state="translated">Emacs 편집기를 사용하면 &lt;code&gt;next-error&lt;/code&gt; ( &lt;code&gt;C-X `&lt;/code&gt; ) 기능을 사용하여 오류 메시지가 줄 번호로 설명되어있는 경우 컴파일 오류가 발생한 위치를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd1467c50929ca82151785c1269db67667bbfaf" translate="yes" xml:space="preserve">
          <source>With the Erlang editing mode the entire edit-compile-bugfix cycle can be performed without leaving Emacs. Emacs can order Erlang to compile a file and it can parse the error messages to automatically place the point on the erroneous lines.</source>
          <target state="translated">Erlang 편집 모드를 사용하면 Emacs를 떠나지 않고도 전체 편집 컴파일-버그-픽스 사이클을 수행 할 수 있습니다. Emacs는 Erlang에게 파일 컴파일을 명령하고 오류 메시지를 구문 분석하여 오류가있는 행에 자동으로 포인트를 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87f65f9f34aec9e8824942246b3c077a7feb1f5" translate="yes" xml:space="preserve">
          <source>With the SSH application it is possible to start</source>
          <target state="translated">SSH 응용 프로그램을 사용하면 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e989e36c428437d532173efb4dc1f11980139702" translate="yes" xml:space="preserve">
          <source>With the atom &lt;code&gt;pending&lt;/code&gt;, reloading is requested for any driver and is effectuated when &lt;strong&gt;all&lt;/strong&gt; ports opened to the driver are closed. The driver replacement in this case takes place regardless if there are still pending &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; having the driver loaded.</source>
          <target state="translated">atom &lt;code&gt;pending&lt;/code&gt; 인 경우 드라이버에 대해 다시로드가 요청되며 드라이버에 열려있는 &lt;strong&gt;모든&lt;/strong&gt; 포트가 닫힐 때 적용됩니다. 이 경우 드라이버를로드 한 보류중인 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 있는지 여부에 관계없이이 드라이버 교체가 이루어 집니다.</target>
        </trans-unit>
        <trans-unit id="a49c5a7288e37879fb1597723f7ac509b9a89558" translate="yes" xml:space="preserve">
          <source>With the exception of the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; data structures, the internal representations of abstract syntax trees are subject to change without notice, and should not be documented outside this module. Furthermore, we do not give any guarantees on how an abstract syntax tree may or may not be represented, &lt;strong&gt;with the following exceptions&lt;/strong&gt;: no syntax tree is represented by a single atom, such as &lt;code&gt;none&lt;/code&gt;, by a list constructor &lt;code&gt;[X | Y]&lt;/code&gt;, or by the empty list &lt;code&gt;[]&lt;/code&gt;. This can be relied on when writing functions that operate on syntax trees.</source>
          <target state="translated">의 제외 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; 데이터 구조, 추상 구문 트리의 내부 표현은 통보없이 변경 될 수 있으며, 이러한 모듈 외부 기록되어서는 안된다. 또한, &lt;strong&gt;다음의 경우를 제외&lt;/strong&gt; 하고 추상 구문 트리가 표현되거나 표현되지 않는 방법에 대한 보증을 제공하지 않습니다 . 구문 트리는 리스트 생성자에 의해 &lt;code&gt;none&lt;/code&gt; 과 같은 단일 원자로 표현 되지 않습니다 &lt;code&gt;[X | Y]&lt;/code&gt; 또는 빈 목록 &lt;code&gt;[]&lt;/code&gt; 로 표시 됩니다. 이것은 구문 트리에서 작동하는 함수를 작성할 때 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0799d7d4d3fdec3a7810006698814c9556e24aba" translate="yes" xml:space="preserve">
          <source>With the following example assignments in Erlang:</source>
          <target state="translated">Erlang에서 다음 예제 지정을 사용하여 :</target>
        </trans-unit>
        <trans-unit id="51ec259decd0a3955d2d19902beece7274482a60" translate="yes" xml:space="preserve">
          <source>With the following example, you can examine that both &lt;code&gt;selected_decode_Window2&lt;/code&gt; and &lt;code&gt;selected_decode_Window1&lt;/code&gt; decodes the intended subvalue of value &lt;code&gt;Val&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;selected_decode_Window2&lt;/code&gt; 및 &lt;code&gt;selected_decode_Window1&lt;/code&gt; 이 모두 &lt;code&gt;Val&lt;/code&gt; 값의 의도 된 하위 값을 디코딩 하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f20fe5ebde2a4b97859bb1e9c2b9058bbadcfaaf" translate="yes" xml:space="preserve">
          <source>With the optional flag &lt;code&gt;-erl_args&lt;/code&gt;, options on the &lt;code&gt;ct_run&lt;/code&gt; command line can be divided into two groups:</source>
          <target state="translated">선택적 플래그 &lt;code&gt;-erl_args&lt;/code&gt; 를 사용하면 &lt;code&gt;ct_run&lt;/code&gt; 명령 행의 옵션 을 두 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e84637f043080b06a85b6f9e7d2bf5daa570f9" translate="yes" xml:space="preserve">
          <source>With the same tracing turned on, the following trace output is received:</source>
          <target state="translated">동일한 추적이 설정되면 다음 추적 출력이 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="66c3da75d490fac9c0e2e40323391ab1e86a0c17" translate="yes" xml:space="preserve">
          <source>With the standard prologue, this call will return either &lt;code&gt;{ok, Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is a structure that the Erlang code of the grammar file has built, or &lt;code&gt;{error, {Line_number, Module, Message}}&lt;/code&gt; if there was a syntax error in the input.</source>
          <target state="translated">표준 프롤로그에서이 호출은 &lt;code&gt;{ok, Result}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 문법 파일의 Erlang 코드가 빌드 한 구조이거나 구문 오류가있는 경우 &lt;code&gt;{error, {Line_number, Module, Message}}&lt;/code&gt; 입력에서.</target>
        </trans-unit>
        <trans-unit id="3ef3136fe39b6dd4b9b8658e80f644b3dd783d88" translate="yes" xml:space="preserve">
          <source>With the term &lt;code&gt;specs&lt;/code&gt;, a test specification can include other specifications. An included specification can either be joined with the source specification or used to produce a separate test run (as with start flag/option &lt;code&gt;join_specs&lt;/code&gt; above).</source>
          <target state="translated">&lt;code&gt;specs&lt;/code&gt; 이라는 용어 로 테스트 사양에는 다른 사양이 포함될 수 있습니다. 포함 된 스펙은 소스 스펙과 결합되거나 별도의 테스트 실행을 생성하는 데 사용될 수 있습니다 ( 위의 시작 플래그 / 옵션 &lt;code&gt;join_specs&lt;/code&gt; 에서와 같이).</target>
        </trans-unit>
        <trans-unit id="f56b5631a8e7adb42a993a80c9f2280c615cde7c" translate="yes" xml:space="preserve">
          <source>With these functions, the driver sends data back to the emulator. The data is received as messages by the port owner process, see &lt;code&gt;erlang:open_port/2&lt;/code&gt;. The vector function and the function taking a driver binary are faster, as they avoid copying the data buffer. There is also a fast way of sending terms from the driver, without going through the binary term format.</source>
          <target state="translated">이 기능으로 드라이버는 데이터를 에뮬레이터로 다시 보냅니다. 데이터는 포트 소유자 프로세스에 의해 메시지로 수신됩니다 ( &lt;code&gt;erlang:open_port/2&lt;/code&gt; 참조) . 벡터 함수와 드라이버 바이너리를 취하는 함수는 데이터 버퍼를 복사하지 않기 때문에 더 빠릅니다. 이진 용어 형식을 거치지 않고 드라이버에서 용어를 보내는 빠른 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6a36166d3f6c702444500f5425ed08e5de6097" translate="yes" xml:space="preserve">
          <source>With this code added to the grammar rules, the parser produces the following value (structure) when parsing the input string &lt;code&gt;(a b c).&lt;/code&gt;. This still assumes that this was the first input line that the scanner tokenized:</source>
          <target state="translated">이 코드를 문법 규칙에 추가하면 파서는 입력 문자열 &lt;code&gt;(a b c).&lt;/code&gt; 구문 분석 할 때 다음 값 (구조)을 생성합니다 . . 이것은 여전히 ​​이것이 스캐너가 토큰 화 한 첫 번째 입력 라인이라고 가정합니다</target>
        </trans-unit>
        <trans-unit id="e713f1938bf3fb3084e642793f7a40e8d8bbb693" translate="yes" xml:space="preserve">
          <source>With this configuration, no debug messages will be logged, since they are all stopped by the primary log level.</source>
          <target state="translated">이 구성을 사용하면 디버그 메시지가 모두 기본 로그 수준에 의해 중지되므로 디버그 메시지가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac97a8644ed6681924aac07ccca3a39d7757ae76" translate="yes" xml:space="preserve">
          <source>With this data model, some operations execute considerably faster than they do with the normalized data model in the &lt;code&gt;Company&lt;/code&gt; database. However, some other operations become much more complicated. In particular, it becomes more difficult to ensure that records do not contain dangling pointers to other non-existent, or deleted, records.</source>
          <target state="translated">이 데이터 모델을 사용하면 일부 작업이 &lt;code&gt;Company&lt;/code&gt; 데이터베이스 의 정규화 된 데이터 모델보다 훨씬 빠르게 실행됩니다 . 그러나 일부 다른 작업은 훨씬 더 복잡해집니다. 특히, 레코드에 존재하지 않거나 삭제 된 다른 레코드에 대한 댕글 링 포인터가 레코드에 포함되지 않도록하는 것이 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="a35c73d89f3552b19d40e20a51d51ca37a42c624" translate="yes" xml:space="preserve">
          <source>With this expression, we could still give the index of the subpattern with the following call:</source>
          <target state="translated">이 표현식을 사용하면 다음 호출로 하위 패턴의 색인을 계속 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313e2124646117e104d6eee7968ee3579fdb519c" translate="yes" xml:space="preserve">
          <source>With this form of function reference, the function that is referred to does not need to be exported from the module.</source>
          <target state="translated">이 형식의 함수 참조를 사용하면 참조되는 함수를 모듈에서 내보낼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4684103f741acbd9e584e58990d9a187601f2fbe" translate="yes" xml:space="preserve">
          <source>With this function, tables can be restored online from a backup without restarting Mnesia. &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. &lt;code&gt;Args&lt;/code&gt; is a list of the following tuples:</source>
          <target state="translated">이 기능을 사용하면 Mnesia를 다시 시작하지 않고도 백업에서 테이블을 온라인으로 복원 할 수 있습니다. &lt;code&gt;Opaque&lt;/code&gt; 은 백업 모듈로 전달됩니다. &lt;code&gt;Args&lt;/code&gt; 는 다음 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="390851375656bd3e10d16d9031e247c3da30c4a7" translate="yes" xml:space="preserve">
          <source>With this option the Distinguished Encoding Rules (DER) is chosen. DER is regarded as a specialized variant of the BER encoding rule. Therefore, this option only makes sense together with option &lt;code&gt;ber&lt;/code&gt;. This option sometimes adds sorting and value checks when encoding, which implies a slower encoding. The decoding routines are the same as for &lt;code&gt;ber&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 DER (Distinguished Encoding Rules)이 선택됩니다. DER은 BER 인코딩 규칙의 특수 변형으로 간주됩니다. 따라서이 옵션은 &lt;code&gt;ber&lt;/code&gt; 옵션과 함께 사용해야 합니다. 이 옵션은 인코딩시 정렬 및 값 검사를 추가하기 때문에 인코딩 속도가 느려집니다. 디코딩 루틴은 &lt;code&gt;ber&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5bbf6f4e73a0719845e3065b5d609c70d3876ea6" translate="yes" xml:space="preserve">
          <source>With this option, comments inside complicated patterns can be included. However, notice that this applies only to data characters. Whitespace characters can never appear within special character sequences in a pattern, for example within sequence &lt;code&gt;(?(&lt;/code&gt; that introduces a conditional subpattern.</source>
          <target state="translated">이 옵션을 사용하면 복잡한 패턴 안에 주석을 포함시킬 수 있습니다. 그러나 이것은 데이터 문자에만 적용됩니다. 공백 문자는 패턴의 특수 문자 순서 내에는 절대로 나타날 수 없습니다 &lt;code&gt;(?(&lt;/code&gt; 예 : 순서 부호 (? ( 조건부 하위 패턴을 도입)).</target>
        </trans-unit>
        <trans-unit id="bbbe6bc004c4c1d69c0012b84302c6caacbcda99" translate="yes" xml:space="preserve">
          <source>With this option, the file is uncompressed while extracting. If the tar file is not compressed, this option is ignored.</source>
          <target state="translated">이 옵션을 사용하면 추출하는 동안 파일이 압축 해제됩니다. tar 파일이 압축되지 않은 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7afcca01a02c262508c18c8b083adc3d87c7c3f8" translate="yes" xml:space="preserve">
          <source>With this option, the generated &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; functions do not wrap a successful return value in an &lt;code&gt;{ok,...}&lt;/code&gt; tuple. If any error occurs, an exception will be raised.</source>
          <target state="translated">이 옵션을 사용하면 생성 된 인 &lt;code&gt;encode/2&lt;/code&gt; 및 &lt;code&gt;decode/2&lt;/code&gt; 기능이 성공적인 반환 값을 &lt;code&gt;{ok,...}&lt;/code&gt; 튜플에 래핑하지 않습니다 . 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79ed4cb6ebc92e4834967ba47cf97ac82ff9e34b" translate="yes" xml:space="preserve">
          <source>With this parameter, you can modify or disable the default handler, add custom handlers and primary logger filters, and set log levels per module.</source>
          <target state="translated">이 매개 변수를 사용하면 기본 핸들러를 수정 또는 사용 안함으로 설정하고, 사용자 정의 핸들러 및 기본 로거 필터를 추가하고, 모듈 당 로그 레벨을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae7955e8a35568cd9fc9b07467b9022a2db2720e" translate="yes" xml:space="preserve">
          <source>With this structure, the root directory for clients of &lt;code&gt;Type1&lt;/code&gt; is &lt;code&gt;$ROOT/clients/Type1&lt;/code&gt;.</source>
          <target state="translated">이 구조에서 &lt;code&gt;Type1&lt;/code&gt; 클라이언트의 루트 디렉토리 는 &lt;code&gt;$ROOT/clients/Type1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="432b508f16a314a63d1e68410564a6c13bfb94ce" translate="yes" xml:space="preserve">
          <source>With this structure, we can now map an OBJECT IDENTIFIER in e.g. a GET NEXT request, to the correct process:</source>
          <target state="translated">이 구조를 사용하면 GET NEXT 요청과 같은 객체 식별자를 올바른 프로세스에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ceeafc43a87abdccde2bded1edd74d9fa27f522" translate="yes" xml:space="preserve">
          <source>With three parameters to this function, the first is either a process identifier or the registered name of a process to set trace flags on, the second is the disable list, and the third is the enable list.</source>
          <target state="translated">이 함수에 대한 세 개의 매개 변수를 사용하면 첫 번째는 프로세스 식별자 또는 추적 플래그를 설정하는 프로세스의 등록 된 이름이고 두 번째는 비활성화 목록이고 세 번째는 활성화 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e8b6348b307af60a11f370355943e934c4b4e992" translate="yes" xml:space="preserve">
          <source>With two parameters this function takes a list of trace flags to disable as first parameter and a list of trace flags to enable as second parameter. Logically, the disable list is applied first, but effectively all changes are applied atomically. The trace flags are the same as for &lt;code&gt;erlang:trace/3&lt;/code&gt;, not including &lt;code&gt;cpu_timestamp&lt;/code&gt;, but including &lt;code&gt;tracer&lt;/code&gt;.</source>
          <target state="translated">두 개의 매개 변수를 사용하면이 함수는 첫 번째 매개 변수로 비활성화 할 추적 플래그 목록과 두 번째 매개 변수로 활성화 할 추적 플래그 목록을 사용합니다. 논리적으로 비활성화 목록이 먼저 적용되지만 사실상 모든 변경 사항이 원자 적으로 적용됩니다. 추적 플래그와 동일 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 포함하지 &lt;code&gt;cpu_timestamp&lt;/code&gt; 을 하지만, 포함 &lt;code&gt;tracer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d136f7e5cf76c4a347eacf5f74c9fbce0613f2db" translate="yes" xml:space="preserve">
          <source>With two parameters this function works as the Erlang call &lt;code&gt;erlang:trace(P1, false, [P2])&lt;/code&gt;, where &lt;code&gt;P1&lt;/code&gt; can be either a process identifier or a registered name and is specified as the first argument to the match specification function. &lt;code&gt;P2&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; be &lt;code&gt;cpu_timestamp&lt;/code&gt; or &lt;code&gt;tracer&lt;/code&gt;.</source>
          <target state="translated">두 개의 매개 변수를 사용하면이 함수는 Erlang 호출 &lt;code&gt;erlang:trace(P1, false, [P2])&lt;/code&gt; . 여기서 &lt;code&gt;P1&lt;/code&gt; 은 프로세스 ID 또는 등록 된 이름 일 수 있으며 일치 스펙 함수의 첫 번째 인수로 지정됩니다. &lt;code&gt;P2&lt;/code&gt; 는&lt;strong&gt;수&lt;/strong&gt; 있을 &lt;code&gt;cpu_timestamp&lt;/code&gt; 또는 &lt;code&gt;tracer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eda4b34bedd09e44ec9081e6140c9e1dfd683009" translate="yes" xml:space="preserve">
          <source>With two parameters, the first parameter is to be either a process identifier or the registered name of a process. In this case tracing is turned on for the designated process in the same way as in the Erlang call &lt;code&gt;erlang:trace(P1, true, [P2])&lt;/code&gt;, where &lt;code&gt;P1&lt;/code&gt; is the first and &lt;code&gt;P2&lt;/code&gt; is the second argument. The process &lt;code&gt;P1&lt;/code&gt; gets its trace messages sent to the same tracer as the process executing the statement uses. &lt;code&gt;P1&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; be one of the atoms &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;existing&lt;/code&gt; (unless they are registered names). &lt;code&gt;P2&lt;/code&gt;&lt;strong&gt;cannot&lt;/strong&gt; be &lt;code&gt;cpu_timestamp&lt;/code&gt; or &lt;code&gt;tracer&lt;/code&gt;.</source>
          <target state="translated">두 개의 매개 변수를 사용하면 첫 번째 매개 변수는 프로세스 ID이거나 프로세스의 등록 된 이름입니다. 이 경우 Erlang 호출 &lt;code&gt;erlang:trace(P1, true, [P2])&lt;/code&gt; 와 동일한 방식으로 지정된 프로세스에 대해 추적이 설정됩니다. 여기서 &lt;code&gt;P1&lt;/code&gt; 은 첫 번째이고 &lt;code&gt;P2&lt;/code&gt; 는 두 번째 인수입니다. 프로세스 &lt;code&gt;P1&lt;/code&gt; 은 명령문을 실행하는 프로세스와 동일한 추적 프로그램으로 추적 메시지를 보냅니다. &lt;code&gt;P1&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;all&lt;/code&gt; 원자 중 하나 일 &lt;strong&gt;수 없으며&lt;/strong&gt; , &lt;code&gt;new&lt;/code&gt; 또는 &lt;code&gt;existing&lt;/code&gt; (등록 된 이름이 아닌 한)입니다. &lt;code&gt;P2&lt;/code&gt; 는&lt;strong&gt;수&lt;/strong&gt; 있을 &lt;code&gt;cpu_timestamp&lt;/code&gt; 또는 &lt;code&gt;tracer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088861dc6130289d10248cfe85bbf4f7f1f9d45d" translate="yes" xml:space="preserve">
          <source>Within Git</source>
          <target state="translated">힘내</target>
        </trans-unit>
        <trans-unit id="6b3360c3e0960ab42b445ecad47d54b883ada536" translate="yes" xml:space="preserve">
          <source>Within a given module, the following shorthand suffices in most cases:</source>
          <target state="translated">주어진 모듈 내에서 대부분의 경우 다음과 같은 속기는 충분합니다.</target>
        </trans-unit>
        <trans-unit id="7a2917f02c4039ffaf187fe5fd6d555a6ef7c728" translate="yes" xml:space="preserve">
          <source>Within strings and quoted atoms, the following escape sequences are recognized:</source>
          <target state="translated">문자열과 인용 된 원자 내에서 다음과 같은 이스케이프 시퀀스가 ​​인식됩니다.</target>
        </trans-unit>
        <trans-unit id="53a5de5fa09f36497fe31f500b85e996cf6d9e85" translate="yes" xml:space="preserve">
          <source>Without the parentheses, it would match &quot;cataract&quot;, &quot;erpillar&quot;, or an empty string.</source>
          <target state="translated">괄호가 없으면 &quot;백내장&quot;, &quot;erpillar&quot;또는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1345f1a81ca030cb98d73c1808db779330bcf78e" translate="yes" xml:space="preserve">
          <source>Without the tags (the numbers in square brackets) the ASN.1 compiler refused to compile the file.</source>
          <target state="translated">태그 (대괄호 안의 숫자)가 없으면 ASN.1 컴파일러는 파일 컴파일을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="b66639b539cbc9a7d8de83368630ef491e405704" translate="yes" xml:space="preserve">
          <source>Without writing any instrumentation functions, we can compile the MIB and use the default implementation of it. Recall that MIBs imported by &quot;EX1-MIB.mib&quot; must be present and compiled in the current directory (&quot;./STANDARD-MIB.bin&quot;,&quot;./RFC1213-MIB.bin&quot;) when compiling.</source>
          <target state="translated">계측 기능을 작성하지 않고도 MIB를 컴파일하고 기본 구현을 사용할 수 있습니다. &quot;EX1-MIB.mib&quot;로 가져온 MIB는 컴파일 할 때 현재 디렉토리 ( &quot;./STANDARD-MIB.bin&quot;,&quot;./RFC1213-MIB.bin&quot;)에 존재하고 컴파일되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8d22583a6ade42fd4309dee38fdacc3898c0902c" translate="yes" xml:space="preserve">
          <source>Workers are processes that perform computations, that is, they do the actual work.</source>
          <target state="translated">작업자는 계산을 수행하는 프로세스, 즉 실제 작업을 수행하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="e985d0ce8ef0c16218446f6d7fcdb35b7c5b2148" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;'and'&lt;/code&gt;, but quits evaluating its arguments when one argument evaluates to something else than &lt;code&gt;true&lt;/code&gt;. Arguments are evaluated left to right.</source>
          <target state="translated">&lt;code&gt;'and'&lt;/code&gt; 로 작동 하지만 한 인수가 &lt;code&gt;true&lt;/code&gt; 이외의 다른 것으로 평가되면 인수 평가를 종료 합니다 . 인수는 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b805de4afdf90d138f66c4564f25db6bc7ea93cf" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;'or'&lt;/code&gt;, but quits evaluating as soon as one of its arguments evaluates to &lt;code&gt;true&lt;/code&gt;. Arguments are evaluated left to right.</source>
          <target state="translated">&lt;code&gt;'or'&lt;/code&gt; 로 작동 하지만 인수 중 하나가 &lt;code&gt;true&lt;/code&gt; 로 평가되는 즉시 평가는 종료됩니다 . 인수는 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="52d6d72bd3a0d1273818970c818a802d34ed9904" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;, except that an extra option list is specified when creating the process.</source>
          <target state="translated">프로세스 생성시 추가 옵션 목록이 지정되는 것을 제외하고 는 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="68e63d5c50b23e19cd48feaa939f809fb8ce20db" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;, except that it is always completely asynchronous.</source>
          <target state="translated">항상 완전히 비동기 적이라는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="421d33f0ac157b829988ba873a00c78043a6c8f0" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;&lt;a href=&quot;erlang#whereis-1&quot;&gt;erlang:whereis/1&lt;/a&gt;&lt;/code&gt;, but restricted to ports. See &lt;code&gt;&lt;a href=&quot;#enif_whereis_pid&quot;&gt;enif_whereis_pid&lt;/a&gt;&lt;/code&gt; to resolve registered processes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#whereis-1&quot;&gt;erlang:whereis/1&lt;/a&gt;&lt;/code&gt; 로 작동 하지만 포트로 제한됩니다. 등록 된 프로세스를 해결하려면 &lt;code&gt;&lt;a href=&quot;#enif_whereis_pid&quot;&gt;enif_whereis_pid&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="085224b8ff26237fd246cda51d286da34d390cf3" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;&lt;a href=&quot;erlang#whereis-1&quot;&gt;erlang:whereis/1&lt;/a&gt;&lt;/code&gt;, but restricted to processes. See &lt;code&gt;&lt;a href=&quot;#enif_whereis_port&quot;&gt;enif_whereis_port&lt;/a&gt;&lt;/code&gt; to resolve registered ports.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#whereis-1&quot;&gt;erlang:whereis/1&lt;/a&gt;&lt;/code&gt; 로 작동 하지만 프로세스로 제한됩니다. 등록 된 포트를 해결하려면 &lt;code&gt;&lt;a href=&quot;#enif_whereis_port&quot;&gt;enif_whereis_port&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40146c9605b0953856848c19e1cf03b08671385c" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;load&lt;/code&gt;, except that &lt;code&gt;*old_priv_data&lt;/code&gt; already contains the value set by the last call to &lt;code&gt;load&lt;/code&gt; or &lt;code&gt;upgrade&lt;/code&gt; for the old module code. &lt;code&gt;*priv_data&lt;/code&gt; is initialized to &lt;code&gt;NULL&lt;/code&gt; when &lt;code&gt;upgrade&lt;/code&gt; is called. It is allowed to write to both &lt;code&gt;*priv_data&lt;/code&gt; and &lt;code&gt;*old_priv_data.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*old_priv_data&lt;/code&gt; 에 이전 모듈 코드의 &lt;code&gt;load&lt;/code&gt; 또는 &lt;code&gt;upgrade&lt;/code&gt; 위해 마지막 호출에서 설정 한 값이 이미 포함되어있는 것을 제외하고 는 &lt;code&gt;load&lt;/code&gt; 로 작동 합니다. &lt;code&gt;*priv_data&lt;/code&gt; 는 &lt;code&gt;upgrade&lt;/code&gt; 가 호출 될 때 &lt;code&gt;NULL&lt;/code&gt; 로 초기화됩니다 . &lt;code&gt;*priv_data&lt;/code&gt; 및 &lt;code&gt;*old_priv_data.&lt;/code&gt; 에 모두 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93d1ed2124b6fb6e88a162d4ef28c9020229925d" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;return_trace&lt;/code&gt; plus; if the traced function exits because of an exception, an &lt;code&gt;exception_from&lt;/code&gt; trace message is generated, regardless of the exception is caught or not.</source>
          <target state="translated">&lt;code&gt;return_trace&lt;/code&gt; plus 로 작동합니다 . 예외로 인해 추적 된 함수가 종료되면 예외 가 발생했는지 여부에 관계없이 &lt;code&gt;exception_from&lt;/code&gt; 추적 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b206078d6990b20bbaaa91f4c79a77c17d0c31c4" translate="yes" xml:space="preserve">
          <source>Works as &lt;code&gt;seq_trace:set_token/2&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; on success, and &lt;code&gt;'EXIT'&lt;/code&gt; on error or bad argument. Only allowed in the &lt;code&gt;MatchBody&lt;/code&gt; part and only allowed when tracing.</source>
          <target state="translated">&lt;code&gt;seq_trace:set_token/2&lt;/code&gt; 로 작동 하지만 성공하면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 오류나 잘못된 인수에 대해서는 &lt;code&gt;'EXIT'&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;MatchBody&lt;/code&gt; 부분 에서만 허용되며 추적시에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d480bca78a77b5885a0910d0fbf6196db4a96eda" translate="yes" xml:space="preserve">
          <source>Works as in &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;. Notice that this only defines the scope of the search for matching strings, it does not cut the binary before splitting. The bytes before and after the scope are kept in the result. See the example below.</source>
          <target state="translated">에서와 같은 작품 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; . 이는 일치하는 문자열에 대한 검색 범위 만 정의하며 분리하기 전에 이진을 자르지 않습니다. 범위 전후의 바이트가 결과에 유지됩니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d4aa6d105820c86c03ede882c8250e6072a4f8d" translate="yes" xml:space="preserve">
          <source>Works essentially as &lt;code&gt;load/2&lt;/code&gt;, but loads the driver with other options. All ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; when the driver is to be unloaded.</source>
          <target state="translated">본질적으로 &lt;code&gt;load/2&lt;/code&gt; 로 작동 하지만 다른 옵션으로 드라이버를로드합니다. 드라이버를 언로드 할 때 &lt;code&gt;driver_unloaded&lt;/code&gt; 이유로 드라이버를 사용하는 모든 포트가 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9a156a4b5e3485aac781717824cc9df2b0af97" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt;, but for drivers loaded with the &lt;code&gt;&lt;a href=&quot;#load_driver-2&quot;&gt;load_driver/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; 와 동일하게 작동 하지만 &lt;code&gt;&lt;a href=&quot;#load_driver-2&quot;&gt;load_driver/2&lt;/a&gt;&lt;/code&gt; 인터페이스로 로드 된 드라이버에 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="e5bfcfa08363e9c1a9e4a5a320563ffdd6d25978" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;ei_send&lt;/code&gt;, the alternative name is retained for backward compatibility. The function will &lt;strong&gt;not&lt;/strong&gt; be removed without prior notice.</source>
          <target state="translated">&lt;code&gt;ei_send&lt;/code&gt; 와 동일하게 작동 하며 이전 버전과의 호환성을 위해 대체 이름이 유지됩니다. 이 기능은 사전 통지없이 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7179b049e2ae6550971075883dbbca59a393c2f9" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, added for completeness.</source>
          <target state="translated">완전성을 위해 추가 된 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="2045c26d05c2a39ea8c38958e51e1b6854d1e881" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;&lt;a href=&quot;#error-1&quot;&gt;error/1&lt;/a&gt;&lt;/code&gt;, but Dialyzer thinks that this BIF will return an arbitrary term. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer does not generate false warnings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#error-1&quot;&gt;error/1&lt;/a&gt;&lt;/code&gt; 과 똑같이 작동 하지만 Dialyzer는이 BIF가 임의의 항을 반환 할 것이라고 생각합니다. NIF 라이브러리가로드되지 않은 경우 NIF의 스텁 함수에서 예외를 생성하는 경우 Dialyzer는 잘못된 경고를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8e1ee5514688631957d392523baa902aeec57af" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;&lt;a href=&quot;#error-2&quot;&gt;error/2&lt;/a&gt;&lt;/code&gt;, but Dialyzer thinks that this BIF will return an arbitrary term. When used in a stub function for a NIF to generate an exception when the NIF library is not loaded, Dialyzer does not generate false warnings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#error-2&quot;&gt;error/2&lt;/a&gt;&lt;/code&gt; 와 똑같이 작동 하지만 Dialyzer는이 BIF가 임의의 항을 반환한다고 생각합니다. NIF 라이브러리가로드되지 않은 경우 NIF의 스텁 함수에서 예외를 생성하는 경우 Dialyzer는 잘못된 경고를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a3109fb641a70d9d930babef77e4ba838f74539" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;foldl/3&lt;/code&gt; but iterates the table in the opposite order for the &lt;code&gt;ordered_set&lt;/code&gt; table type. For all other table types, &lt;code&gt;foldr/3&lt;/code&gt; and &lt;code&gt;foldl/3&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;foldl/3&lt;/code&gt; 과 동일하게 작동 하지만 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형 과 반대 순서로 테이블을 반복합니다 . 다른 모든 테이블 유형의 경우 &lt;code&gt;foldr/3&lt;/code&gt; 및 &lt;code&gt;foldl/3&lt;/code&gt; 는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="ede6e2c002732cbb9c8c10ac948ca96d91d6146f" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;mnesia:dirty_first/1&lt;/code&gt; but returns the last object in Erlang term order for the &lt;code&gt;ordered_set&lt;/code&gt; table type. For all other table types, &lt;code&gt;mnesia:dirty_first/1&lt;/code&gt; and &lt;code&gt;mnesia:dirty_last/1&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_first/1&lt;/code&gt; 과 동일하게 작동 하지만 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에 대한 Erlang 용어 순서로 마지막 오브젝트를 리턴합니다 . 다른 모든 테이블 유형의 경우 &lt;code&gt;mnesia:dirty_first/1&lt;/code&gt; 및 &lt;code&gt;mnesia:dirty_last/1&lt;/code&gt; 은 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="f09f9e05fb05f55c1656616d936508f427869fa6" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; but returns the previous object in Erlang term order for the &lt;code&gt;ordered_set&lt;/code&gt; table type. For all other table types, &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; and &lt;code&gt;mnesia:dirty_prev/2&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 와 동일하게 작동 하지만 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에 대해 Erlang 용어 순서로 이전 오브젝트를 리턴합니다 . 다른 모든 테이블 유형의 경우 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 및 &lt;code&gt;mnesia:dirty_prev/2&lt;/code&gt; 는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="11974cf8c00cb82ecc66409b4c6075ddde474d45" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;mnesia:first/1&lt;/code&gt;, but returns the last object in Erlang term order for the &lt;code&gt;ordered_set&lt;/code&gt; table type. For all other table types, &lt;code&gt;mnesia:first/1&lt;/code&gt; and &lt;code&gt;mnesia:last/1&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;mnesia:first/1&lt;/code&gt; 과 동일하게 작동 하지만 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에 대한 Erlang 용어 순서로 마지막 오브젝트를 리턴합니다 . 다른 모든 테이블 유형의 경우 &lt;code&gt;mnesia:first/1&lt;/code&gt; 및 &lt;code&gt;mnesia:last/1&lt;/code&gt; 은 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="f5f64af685225de3b4df13f2834bfefb3bc5a5c6" translate="yes" xml:space="preserve">
          <source>Works exactly like &lt;code&gt;mnesia:next/2&lt;/code&gt;, but returns the previous object in Erlang term order for the &lt;code&gt;ordered_set&lt;/code&gt; table type. For all other table types, &lt;code&gt;mnesia:next/2&lt;/code&gt; and &lt;code&gt;mnesia:prev/2&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;mnesia:next/2&lt;/code&gt; 와 동일하게 작동 하지만 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에 대해 Erlang 용어 순서로 이전 오브젝트를 리턴합니다 . 다른 모든 테이블 유형의 경우 &lt;code&gt;mnesia:next/2&lt;/code&gt; 및 &lt;code&gt;mnesia:prev/2&lt;/code&gt; 는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="aa867b66bdf4464e1af900cf9c347d8786874ee8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt;, except that the environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; is not consulted.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 를 참조하지 않는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="c221d6baa71557704311e515bfcd11a497af34c4" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt;, except that the environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; is not consulted.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 를 참조하지 않는 것을 제외하고는 &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="de55de8466623382fc89162e3c4ac168d56f7b5c" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#get_env-2&quot;&gt;get_env/2&lt;/a&gt;&lt;/code&gt; but returns value &lt;code&gt;Def&lt;/code&gt; when configuration parameter &lt;code&gt;Par&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#get_env-2&quot;&gt;get_env/2&lt;/a&gt;&lt;/code&gt; 처럼 작동 하지만 구성 매개 변수 &lt;code&gt;Par&lt;/code&gt; 가 존재하지 않으면 &lt;code&gt;Def&lt;/code&gt; 값을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="891e2c50d6effc0271b3ccde49d4759c5cc0c4d1" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt;, but does not return the objects. Returns &lt;code&gt;true&lt;/code&gt; if one or more elements in the table has key &lt;code&gt;Key&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 처럼 작동 하지만 객체를 반환하지 않습니다. 반환 &lt;code&gt;true&lt;/code&gt; 테이블에 하나 개 이상의 요소가 키가있는 경우 &lt;code&gt;Key&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7dfe1c4ccfa61fb28f685417a682d140814b7c" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt;, but does not return the objects. Returns &lt;code&gt;true&lt;/code&gt; if one or more table elements has key &lt;code&gt;Key&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 처럼 작동 하지만 객체를 반환하지 않습니다. 하나 이상의 테이블 요소에 &lt;code&gt;Key&lt;/code&gt; 가 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="45ece2d9f6d9938921bea31a3a34b89ad834859c" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but returns only a limited (&lt;code&gt;Limit&lt;/code&gt;) number of matching objects. Term &lt;code&gt;Continuation&lt;/code&gt; can then be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">같은 작품 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 만 반환에만 제한 ( &lt;code&gt;Limit&lt;/code&gt; 일치하는 객체) 수. 그러면 용어 &lt;code&gt;Continuation&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에서 사용하여 일치 하는 오브젝트의 다음 청크를 얻을 수 있습니다. 이것은 테이블의 객체를 작업하는 공간 효율적인 방법으로 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 객체별로 테이블 객체를 순회하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="4553dd74ce070981c1a8fcf6d3cb0c01be4e1255" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt;, but only returns a limited (&lt;code&gt;Limit&lt;/code&gt;) number of matching objects. Term &lt;code&gt;Continuation&lt;/code&gt; can then be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">같은 작품 &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; 만 만 제한 (반환 &lt;code&gt;Limit&lt;/code&gt; 일치하는 객체) 번호를. 그런 다음 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에서 용어 &lt;code&gt;Continuation&lt;/code&gt; 을 사용하여 일치하는 오브젝트의 다음 청크를 얻을 수 있습니다. 이것은 테이블의 객체를 작업하는 공간 효율적인 방법으로 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 객체별로 테이블 객체를 순회하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="fdb05aad10b9931ac9274b9bfbd0f42cfeeb5831" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/1&lt;/a&gt;&lt;/code&gt;, except that the environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; is not consulted.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 를 참조하지 않는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/1&lt;/a&gt;&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="d3a6a65715bb756fb3aa512641f3c96d83f1564a" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; except that if &lt;code&gt;Filename&lt;/code&gt; is a symbolic link, information about the link is returned in the &lt;code&gt;file_info&lt;/code&gt; record and the &lt;code&gt;type&lt;/code&gt; field of the record is set to &lt;code&gt;symlink&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 이 기호 링크 인 경우 링크에 대한 정보가 &lt;code&gt;file_info&lt;/code&gt; 레코드에 리턴되고 레코드의 &lt;code&gt;type&lt;/code&gt; 필드가 &lt;code&gt;symlink&lt;/code&gt; 로 설정되는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="00d1c8949d6fad0922ba5ab04fe0bc7e556fac85" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#read_file_info-2&quot;&gt;read_file_info/1,2&lt;/a&gt;&lt;/code&gt; except that if &lt;code&gt;Name&lt;/code&gt; is a symbolic link, information about the link is returned in the &lt;code&gt;file_info&lt;/code&gt; record and the &lt;code&gt;type&lt;/code&gt; field of the record is set to &lt;code&gt;symlink&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 기호 링크 인 경우 링크에 대한 정보가 &lt;code&gt;file_info&lt;/code&gt; 레코드에 리턴되고 레코드의 &lt;code&gt;type&lt;/code&gt; 필드가 &lt;code&gt;symlink&lt;/code&gt; 로 설정 된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;#read_file_info-2&quot;&gt;read_file_info/1,2&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="4306a682289fe29cf880491be6e2d650b6ee0a9e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;, but only returns a limited (&lt;code&gt;Limit&lt;/code&gt;) number of matching objects. Term &lt;code&gt;Continuation&lt;/code&gt; can then be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is still faster than traversing the table object by object using &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작품처럼 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; 하지만, 제한된 (반환 &lt;code&gt;Limit&lt;/code&gt; 일치하는 객체) 번호를. 그런 다음 Term &lt;code&gt;Continuation&lt;/code&gt; 을 사용하여 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에서 일치하는 오브젝트의 다음 청크를 얻을 수 있습니다. 이것은 공간 효율적으로 테이블의 객체를 처리하는 방법으로 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 객체로 테이블 객체를 순회하는 것보다 여전히 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="c75d2e2ac9a39c9318f254f40721c617f94d8679" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;, but returns the list in reverse order for table type &lt;code&gt;ordered_set&lt;/code&gt;. For all other table types, the return value is identical to that of &lt;code&gt;select/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; 처럼 작동 하지만 테이블 유형 &lt;code&gt;ordered_set&lt;/code&gt; 에 대해 역순으로 목록을 리턴합니다 . 다른 모든 테이블 유형의 경우 리턴 값은 &lt;code&gt;select/2&lt;/code&gt; 의 리턴 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="463bdae22eae3b8c8de82e8a6bc16d71e831e6bf" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;, but for table type &lt;code&gt;ordered_set&lt;/code&gt; traversing is done starting at the last object in Erlang term order and moves to the first. For all other table types, the return value is identical to that of &lt;code&gt;select/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 와 같이 작동 하지만 테이블 유형의 경우 &lt;code&gt;ordered_set&lt;/code&gt; 순회는 Erlang 용어 순서의 마지막 오브젝트에서 시작하여 첫 번째로 이동합니다. 다른 모든 테이블 유형의 경우 리턴 값은 &lt;code&gt;select/3&lt;/code&gt; 의 리턴 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e5c1c8abeb4c1279789b624d58a590686cd04c5e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;unicode&lt;/code&gt;, but translation is done to and from big endian UTF-16 instead of UTF-8.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 처럼 작동 하지만 UTF-8 대신 big endian UTF-16으로 (부터) 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5a412e21ff7312505155bfe656355b5d3f799926" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;unicode&lt;/code&gt;, but translation is done to and from big endian UTF-32 instead of UTF-8.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 와 같이 작동 하지만 UTF-8 대신 big endian UTF-32로 (부터) 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b35d9e673e5534d1403707a3a6113b4ad6821fdd" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;unicode&lt;/code&gt;, but translation is done to and from little endian UTF-16 instead of UTF-8.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 와 같이 작동 하지만 UTF-8 대신 리틀 엔디 언 UTF-16으로 (부터) 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8acfc4c821f38a6abb20c5dbdbea542fe62afdc7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;unicode&lt;/code&gt;, but translation is done to and from little endian UTF-32 instead of UTF-8.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 와 같이 작동 하지만 UTF-8 대신 리틀 엔디 언 UTF-32로 (부터) 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="97b569356d25181602cf1090387087658283aa4f" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;{spawn, Command}&lt;/code&gt;, but demands the first (space-separated) token of the command to be the name of a loaded driver. If no driver with that name is loaded, a &lt;code&gt;badarg&lt;/code&gt; error is raised.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 처럼 작동 하지만 명령 의 첫 번째 (공백으로 구분 된) 토큰은로드 된 드라이버의 이름이어야합니다. 해당 이름의 드라이버가로드되지 않으면 &lt;code&gt;badarg&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be0e1775e6fa37077ec9c7df7a951bfba4f6f14d" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;{spawn, FileName}&lt;/code&gt;, but only runs external executables. &lt;code&gt;FileName&lt;/code&gt; in its whole is used as the name of the executable, including any spaces. If arguments are to be passed, the &lt;code&gt;PortSettings&lt;/code&gt;&lt;code&gt;args&lt;/code&gt; and &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">이 작품처럼 &lt;code&gt;{spawn, FileName}&lt;/code&gt; ,하지만 외부 실행 파일을 실행합니다. &lt;code&gt;FileName&lt;/code&gt; 전체는 공백을 포함하여 실행 파일의 이름으로 사용됩니다. 인수가 전달되면 &lt;code&gt;PortSettings&lt;/code&gt; &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;arg0&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff53e6ce6f573342993b9753bf5e3d494ee84afd" translate="yes" xml:space="preserve">
          <source>Works the same way as &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt;, only argument &lt;code&gt;TestCase&lt;/code&gt; makes it possible to pause a test case executing in a parallel group. Function &lt;code&gt;&lt;a href=&quot;#continue-1&quot;&gt;ct:continue/1&lt;/a&gt;&lt;/code&gt; is to be used to resume execution of &lt;code&gt;TestCase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt; 과 같은 방식으로 작동하며 &lt;code&gt;TestCase&lt;/code&gt; 인수 만 사용하면 병렬 그룹에서 실행되는 테스트 케이스를 일시 중지 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#continue-1&quot;&gt;ct:continue/1&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;TestCase&lt;/code&gt; 실행을 재개하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ebd064339024e6787ef613697d6eb49d74be02e" translate="yes" xml:space="preserve">
          <source>Wrap logs can be formatted one by one or all at once. See &lt;code&gt;&lt;a href=&quot;#format&quot;&gt;Formatting&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">랩 로그는 한 번에 하나씩 또는 모두 형식을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#format&quot;&gt;Formatting&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1c3bb1f1e3dd57b50d33d1e8bed09452b9c10aa" translate="yes" xml:space="preserve">
          <source>Wrap logs can be formatted one by one or all at once. To format one of the wrap logs in a set, specify the exact file name. To format the whole set of wrap logs, specify the name with &lt;code&gt;*&lt;/code&gt; instead of the wrap count.</source>
          <target state="translated">랩 로그는 한 번에 하나씩 또는 모두 형식을 지정할 수 있습니다. 랩 로그 중 하나를 세트로 형식화하려면 정확한 파일 이름을 지정하십시오. 전체 랩 로그 세트를 형식화하려면 랩 수 대신 &lt;code&gt;*&lt;/code&gt; 를 사용하여 이름을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="83ae92c027e83e4c2178c5c0cce8b7e2a0dbbeb1" translate="yes" xml:space="preserve">
          <source>Wrap logs can be formatted one by one or all at once. To format one of the wrap logs in a set, specify the exact file name. To format the whole set of wrap logs, specify the name with &lt;code&gt;*&lt;/code&gt; instead of the wrap count. For examples, see the &lt;code&gt;&lt;a href=&quot;ttb_ug#format&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">랩 로그는 한 번에 하나씩 또는 모두 형식을 지정할 수 있습니다. 랩 로그 중 하나를 세트로 형식화하려면 정확한 파일 이름을 지정하십시오. 전체 랩 로그 세트를 형식화하려면 랩 수 대신 &lt;code&gt;*&lt;/code&gt; 를 사용하여 이름을 지정하십시오 . 예를 들어, &lt;code&gt;&lt;a href=&quot;ttb_ug#format&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e130c2b794ac2a10a6d2f6a4c7b34014ba6446cb" translate="yes" xml:space="preserve">
          <source>Wrap logs write at most &lt;code&gt;MaxNoBytes&lt;/code&gt; bytes on each file and use &lt;code&gt;MaxNoFiles&lt;/code&gt; files before starting all over with the first wrap log file. Regardless of &lt;code&gt;MaxNoBytes&lt;/code&gt;, at least the header (if there is one) and one item are written on each wrap log file before wrapping to the next file.</source>
          <target state="translated">랩 로그 는 각 랩 파일 에서 최대 &lt;code&gt;MaxNoBytes&lt;/code&gt; 바이트를 작성 하고 첫 랩 랩 파일로 시작하기 전에 &lt;code&gt;MaxNoFiles&lt;/code&gt; 파일을 사용 합니다. &lt;code&gt;MaxNoBytes&lt;/code&gt; 에 관계없이 , 다음 파일로 랩핑하기 전에 최소한 랩핑 로그 파일에 헤더 (있는 경우)와 하나의 항목이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a105d6522aa571e1e8a17d1e92e4d1aea0100739" translate="yes" xml:space="preserve">
          <source>Write a module:</source>
          <target state="translated">모듈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="862fb68e5dcbfd4f5ccc03b0d915546c33fda2ac" translate="yes" xml:space="preserve">
          <source>Write a record to the mib-storage table.</source>
          <target state="translated">mib-storage 테이블에 레코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="622ba19358824007fde51e6a93cbc5f73ee9f13a" translate="yes" xml:space="preserve">
          <source>Write buffered data to disk.</source>
          <target state="translated">버퍼링 된 데이터를 디스크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ae037ff48de64980dec3bbf67f3a772e165b5a46" translate="yes" xml:space="preserve">
          <source>Write buffers grow large, which slows down file sync operations.</source>
          <target state="translated">쓰기 버퍼가 커져 파일 동기화 작업이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="5d031fc12a848dc71278bf7dd316744781ab426b" translate="yes" xml:space="preserve">
          <source>Write generated source to the specified directory. Defaults to the current working directory.</source>
          <target state="translated">생성 된 소스를 지정된 디렉토리에 씁니다. 현재 작업 디렉토리가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6a816c8f29a683594138fa84579ffe937a14ab50" translate="yes" xml:space="preserve">
          <source>Write generated source to the specified directory. Defaults to the current working directory. Has no effect if option &lt;code&gt;return&lt;/code&gt; is specified.</source>
          <target state="translated">생성 된 소스를 지정된 디렉토리에 씁니다. 현재 작업 디렉토리가 기본값입니다. 옵션 &lt;code&gt;return&lt;/code&gt; 이 지정 되면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89eca924064063f936f3bc70867b6edb5305fe4c" translate="yes" xml:space="preserve">
          <source>Write locks are exclusive. This means that if one transaction manages to acquire a write lock on an item, no other transaction can acquire any kind of lock on the same item.</source>
          <target state="translated">쓰기 잠금은 독점적입니다. 즉, 한 트랜잭션이 항목에 대한 쓰기 잠금을 획득하면 다른 트랜잭션이 동일한 항목에 대해 어떤 종류의 잠금도 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d8d63d23c0975c3cee9720bc48f9847ff5cff67" translate="yes" xml:space="preserve">
          <source>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local node if a local replica exists). Most of the context-sensitive access functions acquire an implicit lock if they are started in a transaction-context. The granularity of a lock can either be a single record or an entire table.</source>
          <target state="translated">쓰기 잠금은 일반적으로 테이블의 복제본이 상주하고 활성화 된 모든 노드에서 획득됩니다. 한 노드 (로컬 복제본이있는 경우 로컬 노드)에서 읽기 잠금을 획득합니다. 상황에 맞는 액세스 기능의 대부분은 트랜잭션 컨텍스트에서 시작되면 암시 적 잠금을 얻습니다. 잠금 단위는 단일 레코드이거나 전체 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8e027a55cac814963905df28e128e53f025a271" translate="yes" xml:space="preserve">
          <source>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local one if a local replica exists).</source>
          <target state="translated">쓰기 잠금은 일반적으로 테이블의 복제본이 상주하고 활성화 된 모든 노드에서 획득됩니다. 한 노드 (로컬 복제본이있는 경우 로컬 노드)에서 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="bf2bd0f3b5bd4941bbbcb59f2d35430b7d335818" translate="yes" xml:space="preserve">
          <source>Write more information to a trace information file, which is read during formatting.</source>
          <target state="translated">형식화 중에 읽는 추적 정보 파일에 추가 정보를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="11e03936270e768063b945e628f72f82cd7f2a6c" translate="yes" xml:space="preserve">
          <source>Write operations to a table replica of type &lt;code&gt;disc_copies&lt;/code&gt; write data to the disc copy and to the RAM copy of the table.</source>
          <target state="translated">&lt;code&gt;disc_copies&lt;/code&gt; 유형의 테이블 복제본에 대한 쓰기 조작 은 디스크 사본 및 테이블의 RAM 사본에 데이터를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="90a9bd9c8eda795510566a785ca5d3278970b55c" translate="yes" xml:space="preserve">
          <source>Write permission: group</source>
          <target state="translated">쓰기 권한 : 그룹</target>
        </trans-unit>
        <trans-unit id="6f993e4752f0f11bc37ea50a8c30a50e99af1c19" translate="yes" xml:space="preserve">
          <source>Write permission: other</source>
          <target state="translated">쓰기 권한 : 기타</target>
        </trans-unit>
        <trans-unit id="c13751536b741cb4a163bff9e95b674a5a724e0c" translate="yes" xml:space="preserve">
          <source>Write permission: owner</source>
          <target state="translated">쓰기 권한 : owner</target>
        </trans-unit>
        <trans-unit id="97f42019e59265a5d326a15e2fe411e7df077b47" translate="yes" xml:space="preserve">
          <source>Write selected entries from the history buffer to a configuration file:</source>
          <target state="translated">히스토리 버퍼에서 구성 파일로 선택된 항목을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="356fb521c1eac37bd33dda6838decdc47505164a" translate="yes" xml:space="preserve">
          <source>Write the agent community config to the agent community config file.</source>
          <target state="translated">에이전트 커뮤니티 구성을 에이전트 커뮤니티 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c363c87dac1a162c5390a7204a0846f1b2cf949b" translate="yes" xml:space="preserve">
          <source>Write the agent config to the agent config file.</source>
          <target state="translated">에이전트 구성을 에이전트 구성 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="df74bec607c35c5148d3bf1e23e2f5e18ed0edfc" translate="yes" xml:space="preserve">
          <source>Write the agent context config to the agent context config file.</source>
          <target state="translated">에이전트 컨텍스트 구성을 에이전트 컨텍스트 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="74a55f3f8ef78217a3178b9a4e102552a471649e" translate="yes" xml:space="preserve">
          <source>Write the agent notify config to the agent notify config file.</source>
          <target state="translated">에이전트 알림 구성을 에이전트 알림 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0725c824356172ca0bd72db608c7d1790917ec18" translate="yes" xml:space="preserve">
          <source>Write the agent standard config to the agent standard config file.</source>
          <target state="translated">에이전트 표준 구성을 에이전트 표준 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="742a51874a3a64b0aff03d59e1525f641c970329" translate="yes" xml:space="preserve">
          <source>Write the agent target_addr config to the agent target_addr config file.</source>
          <target state="translated">에이전트 target_addr 구성을 에이전트 target_addr 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e16e02f52081c8e5cb2ffdda5dfdbef9c34f3271" translate="yes" xml:space="preserve">
          <source>Write the agent target_params config to the agent target_params config file.</source>
          <target state="translated">에이전트 target_params 구성을 에이전트 target_params 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6b556a988009e0705c0f0c8a2093ed99cbfe9d02" translate="yes" xml:space="preserve">
          <source>Write the agent usm config to the agent usm config file.</source>
          <target state="translated">에이전트 usm 구성을 에이전트 usm 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="86cca1e1d7d421bc848733c75ac6bc17cc68210b" translate="yes" xml:space="preserve">
          <source>Write the agent vacm config to the agent vacm config file.</source>
          <target state="translated">에이전트 vacm 구성을 에이전트 vacm 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d8d44a989b8e869e90d14a4dd1692d7e8900440f" translate="yes" xml:space="preserve">
          <source>Write the content of the history buffer to a configuration file:</source>
          <target state="translated">히스토리 버퍼의 컨텐츠를 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d2fcdbc95034e2cd8830dd4403075a42d13d6c" translate="yes" xml:space="preserve">
          <source>Write the instrumentation functions in Erlang and compile them.</source>
          <target state="translated">Erlang에서 인스 트루먼 테이션 기능을 작성하고 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="dca5e01b6979dba86ef5f6da9b7d0c7f8ad85ad4" translate="yes" xml:space="preserve">
          <source>Write the manager agents config to the manager agents config file.</source>
          <target state="translated">관리자 에이전트 구성을 관리자 에이전트 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="858a87d5bc4ac108f9b0a840edd7c34fff07895a" translate="yes" xml:space="preserve">
          <source>Write the manager config to the manager config file.</source>
          <target state="translated">관리자 구성을 관리자 구성 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d471c2eac196383c37d37d93c2ae694af53d1078" translate="yes" xml:space="preserve">
          <source>Write the manager users config to the manager users config file.</source>
          <target state="translated">관리자 사용자 구성을 관리자 사용자 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ea7e6b78113f1851a77b719964eb267bbb6243f8" translate="yes" xml:space="preserve">
          <source>Write the manager usm config to the manager usm config file.</source>
          <target state="translated">manager usm 구성을 manager usm 구성 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="949c535de1f0852b852d57d6fe62226d17f73d93" translate="yes" xml:space="preserve">
          <source>Write your MIB in SMI in a text file.</source>
          <target state="translated">SMI로 MIB를 텍스트 파일로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e3c9ae7fc735225c30a703252970191d0ec1985c" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;Bytes&lt;/code&gt; to the file referenced by &lt;code&gt;IoDevice&lt;/code&gt;. This function is the only way to write to a file opened in &lt;code&gt;raw&lt;/code&gt; mode (although it works for normally opened files too). Returns &lt;code&gt;ok&lt;/code&gt; if successful, and &lt;code&gt;{error, Reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">기록 &lt;code&gt;Bytes&lt;/code&gt; 에 의해 참조되는 파일에 &lt;code&gt;IoDevice&lt;/code&gt; . 이 기능은 &lt;code&gt;raw&lt;/code&gt; 모드 에서 열린 파일에 쓸 수있는 유일한 방법 입니다 (일반적으로 열린 파일에서도 작동하지만). 반환 &lt;code&gt;ok&lt;/code&gt; 성공할 경우, 그리고 &lt;code&gt;{error, Reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="49d88d8ee4a01a2691097be38fe3b136e062c1b3" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;Data&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; &lt;code&gt;Data&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9ac02f39da90daccfaf1d97cf1fdbbf050d4299b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file referenced by &lt;code&gt;Handle&lt;/code&gt;. The file is to be opened with &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;append&lt;/code&gt; flag. Returns &lt;code&gt;ok&lt;/code&gt; if successful or &lt;code&gt;{error, reason()}&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;Handle&lt;/code&gt; 에서 참조하는 파일에 &lt;code&gt;data&lt;/code&gt; 를 씁니다 . 파일은 &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;append&lt;/code&gt; 플래그 로 열립니다 . 반환 &lt;code&gt;ok&lt;/code&gt; 성공적으로 실행되면 &lt;code&gt;{error, reason()}&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa2497f3c952063e780c16a948eff5c082d3decc" translate="yes" xml:space="preserve">
          <source>Writes a (virtual) file &lt;code&gt;RemoteFilename&lt;/code&gt; to a TFTP server.</source>
          <target state="translated">(가상) 파일 &lt;code&gt;RemoteFilename&lt;/code&gt; 을 TFTP 서버에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9240f35a3488e9301929c2cbe6d85a949584439a" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;NULL&lt;/code&gt;-terminated string in the buffer pointed to by &lt;code&gt;buf&lt;/code&gt; of size &lt;code&gt;size&lt;/code&gt;, consisting of the string representation of the atom &lt;code&gt;term&lt;/code&gt; with encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩 &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 을 사용하여 아톰 &lt;code&gt;term&lt;/code&gt; 의 문자열 표현으로 구성된 size &lt;code&gt;size&lt;/code&gt; 의 &lt;code&gt;buf&lt;/code&gt; 가 가리키는 버퍼에 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3634d9ab79165b10596b1586f67a583a9ea04a01" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;NULL&lt;/code&gt;-terminated string in the buffer pointed to by &lt;code&gt;buf&lt;/code&gt; with size &lt;code&gt;size&lt;/code&gt;, consisting of the characters in the string &lt;code&gt;list&lt;/code&gt;. The characters are written using encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 에 의해 지정된 크기가 &lt;code&gt;size&lt;/code&gt; 인 버퍼 로 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자열을 문자열 &lt;code&gt;list&lt;/code&gt; 의 문자로 작성합니다 . 문자는 encode &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="96006cf7f8155945d7ec8fbd7f526f8684308b8a" translate="yes" xml:space="preserve">
          <source>Writes a chunk to the file.</source>
          <target state="translated">파일에 청크를 씁니다.</target>
        </trans-unit>
        <trans-unit id="59d718f29132f1e0414bdcdb53791e5964851ad6" translate="yes" xml:space="preserve">
          <source>Writes a file to the server. The file is created if it does not exist but overwritten if it exists.</source>
          <target state="translated">서버에 파일을 씁니다. 파일이 존재하지 않으면 작성되지만 존재하면 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="8c67e29dd233b9da8b96f21dc789a53fb7c155b7" translate="yes" xml:space="preserve">
          <source>Writes a new line.</source>
          <target state="translated">새로운 줄을 씁니다.</target>
        </trans-unit>
        <trans-unit id="c5e76f620bf08e8f341dbb1e7466ba8f8dff5e76" translate="yes" xml:space="preserve">
          <source>Writes an integer in base 2-36, the default base is 10. A leading dash is printed for negative integers.</source>
          <target state="translated">밑줄 2-36에 정수를 쓰고 기본 밑줄은 10입니다. 선행 대시는 음의 정수로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="87c609439c3f1dd66d3875232c9deb5b66fbce4e" translate="yes" xml:space="preserve">
          <source>Writes data in the same way as &lt;code&gt;~p&lt;/code&gt;, but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with &lt;code&gt;...&lt;/code&gt;, for example:</source>
          <target state="translated">&lt;code&gt;~p&lt;/code&gt; 와 같은 방식으로 데이터를 쓰지만 용어가 인쇄되는 최대 깊이 인 추가 인수를 사용합니다. 이 깊이 아래의 모든 것은 &lt;code&gt;...&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccd6b3e6918423f892a6ad7d9a5360f6780119df" translate="yes" xml:space="preserve">
          <source>Writes data in the same way as &lt;code&gt;~w&lt;/code&gt;, but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with &lt;code&gt;...&lt;/code&gt;. For example, using &lt;code&gt;T&lt;/code&gt; above:</source>
          <target state="translated">&lt;code&gt;~w&lt;/code&gt; 와 같은 방식으로 데이터를 쓰지만 용어가 인쇄되는 최대 깊이 인 추가 인수를 사용합니다. 이 깊이 아래의 모든 것은 &lt;code&gt;...&lt;/code&gt; 로 대체됩니다 . 예를 들어, 위의 &lt;code&gt;T&lt;/code&gt; 를 사용 하면 :</target>
        </trans-unit>
        <trans-unit id="2d64d5867a243be9061399b7123c3937a95092e4" translate="yes" xml:space="preserve">
          <source>Writes data with the standard syntax. This is used to output Erlang terms. Atoms are printed within quotes if they contain embedded non-printable characters. Atom characters &amp;gt; 255 are escaped unless the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used. Floats are printed accurately as the shortest, correctly rounded string.</source>
          <target state="translated">표준 구문으로 데이터를 씁니다. 이것은 Erlang 용어를 출력하는 데 사용됩니다. 인쇄 할 수없는 문자가 포함 된 경우 따옴표 안에 원자가 인쇄됩니다. 유니 코드 변환 수정 자 ( &lt;code&gt;t&lt;/code&gt; )를 사용 하지 않으면 Atom 문자&amp;gt; 255가 이스케이프 됩니다. 플로트는 가장 짧고 올바르게 둥근 줄로 정확하게 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae0f9f7fb8da22844c48c2c1e0c8cca4432f865" translate="yes" xml:space="preserve">
          <source>Writes file information from a &lt;code&gt;file_info&lt;/code&gt; record to the file specified by &lt;code&gt;Name&lt;/code&gt;. See &lt;code&gt;file:write_file_info/[2,3]&lt;/code&gt; for information about the record.</source>
          <target state="translated">&lt;code&gt;file_info&lt;/code&gt; 레코드의 파일 정보를 &lt;code&gt;Name&lt;/code&gt; 에 의해 지정된 파일에 기록합니다 . 레코드에 대한 정보는 &lt;code&gt;file:write_file_info/[2,3]&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f911be02665842be0086f1f403e5bbcb8cc3684" translate="yes" xml:space="preserve">
          <source>Writes generated rules to &lt;code&gt;Output&lt;/code&gt; instead of the default &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. &lt;code&gt;Output&lt;/code&gt; can be a filename or an &lt;code&gt;io_device()&lt;/code&gt;. To write to stdout, use &lt;code&gt;standard_io&lt;/code&gt;. However, if &lt;code&gt;binary&lt;/code&gt; is set, nothing is written to &lt;code&gt;Output&lt;/code&gt; and the result is returned to the caller with &lt;code&gt;{ok, ModuleName, Binary}&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; 대신 생성 된 규칙을 &lt;code&gt;Output&lt;/code&gt; 에 씁니다 . &lt;code&gt;Output&lt;/code&gt; 은 파일 이름 또는 &lt;code&gt;io_device()&lt;/code&gt; 일 수 있습니다 . stdout에 쓰려면 &lt;code&gt;standard_io&lt;/code&gt; 를 사용하십시오 . 그러나 &lt;code&gt;binary&lt;/code&gt; 가 설정된 경우 아무것도 &lt;code&gt;Output&lt;/code&gt; 쓰여지지 않으며 &lt;code&gt;{ok, ModuleName, Binary}&lt;/code&gt; 를 사용하여 호출자에게 결과가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4dacf7c76ad7993807bea9feae5720cfd11d3c39" translate="yes" xml:space="preserve">
          <source>Writes information about the Erlang runtime system into the &lt;code&gt;&lt;a href=&quot;#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; structure referred to by the first argument. The second argument is to be the size of the &lt;code&gt;&lt;a href=&quot;#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; structure, that is, &lt;code&gt;sizeof(ErlDrvSysInfo)&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에 대한 정보를 첫 번째 인수가 참조 하는 &lt;code&gt;&lt;a href=&quot;#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; 구조에 기록합니다. 두 번째 인수는 &lt;code&gt;&lt;a href=&quot;#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; 구조 의 크기 , 즉 &lt;code&gt;sizeof(ErlDrvSysInfo)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc88daf5cb215faec7f56594456357a2fd81a3fa" translate="yes" xml:space="preserve">
          <source>Writes information about the local process &lt;code&gt;Pid&lt;/code&gt; on standard error. The only allowed value for the atom &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;backtrace&lt;/code&gt;, which shows the contents of the call stack, including information about the call chain, with the current function printed first. The format of the output is not further defined.</source>
          <target state="translated">표준 오류에 로컬 프로세스 &lt;code&gt;Pid&lt;/code&gt; 에 대한 정보를 씁니다 . atom &lt;code&gt;Type&lt;/code&gt; 허용되는 유일한 값 은 &lt;code&gt;backtrace&lt;/code&gt; 이며, 현재 함수가 먼저 인쇄 된 콜 체인에 대한 정보를 포함하여 콜 스택의 내용을 보여줍니다. 출력 형식은 더 이상 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="250e32eed820901a002622eee79cae6f62358060" translate="yes" xml:space="preserve">
          <source>Writes miscellaneous system information to file. This information will typically be requested by the Erlang/OTP team at Ericsson AB when reporting an issue.</source>
          <target state="translated">기타 시스템 정보를 파일에 씁니다. 이 정보는 일반적으로 문제를보고 할 때 Ericsson AB의 Erlang / OTP 팀이 요청합니다.</target>
        </trans-unit>
        <trans-unit id="9805b948ee39d3a1dcc417c333486fca32502f6d" translate="yes" xml:space="preserve">
          <source>Writes new line to the standard output (&lt;code&gt;IoDevice&lt;/code&gt;).</source>
          <target state="translated">표준 출력 ( &lt;code&gt;IoDevice&lt;/code&gt; )에 새 줄을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="dc0bcaf3a0eda5fffbae12642198bdd930d2ab4e" translate="yes" xml:space="preserve">
          <source>Writes record &lt;code&gt;Record&lt;/code&gt; to table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">레코드 &lt;code&gt;Record&lt;/code&gt; 를 테이블 &lt;code&gt;Tab&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="4323e451b949ee736a0f4b2b70c7768dcd1414d6" translate="yes" xml:space="preserve">
          <source>Writes term &lt;code&gt;DataToWrite&lt;/code&gt; using &lt;code&gt;UserPrivate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataToWrite&lt;/code&gt; 사용하여 &lt;code&gt;UserPrivate&lt;/code&gt; 용어 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1bca0ebfd4032923999bda67fa6a5d739027c0fc" translate="yes" xml:space="preserve">
          <source>Writes term &lt;code&gt;Term&lt;/code&gt; to the standard output (&lt;code&gt;IoDevice&lt;/code&gt;).</source>
          <target state="translated">용어 &lt;code&gt;Term&lt;/code&gt; 을 표준 출력 ( &lt;code&gt;IoDevice&lt;/code&gt; )에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7f4196f8290e1326de51378f3eeba9701f94dc38" translate="yes" xml:space="preserve">
          <source>Writes the characters of &lt;code&gt;CharData&lt;/code&gt; to the I/O server (&lt;code&gt;IoDevice&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CharData&lt;/code&gt; 의 문자를 I / O 서버 ( &lt;code&gt;IoDevice&lt;/code&gt; )에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="0e09719348776a162994ba30580c7a6f9428ce70" translate="yes" xml:space="preserve">
          <source>Writes the contents of the &lt;code&gt;iodata&lt;/code&gt; term &lt;code&gt;Bytes&lt;/code&gt; to file &lt;code&gt;Filename&lt;/code&gt;. The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iodata&lt;/code&gt; 용어 &lt;code&gt;Bytes&lt;/code&gt; 의 내용을 &lt;code&gt;Filename&lt;/code&gt; 파일에 씁니다 . 파일이 없으면 작성됩니다. 존재하는 경우 이전 내용을 덮어 씁니다. 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="11190aacf8c69f8fb520076a2dcf5b01800eb809" translate="yes" xml:space="preserve">
          <source>Writes the data with standard syntax in the same way as &lt;code&gt;~w&lt;/code&gt;, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. Left-justification is not supported. It also tries to detect flat lists of printable characters and output these as strings. For example:</source>
          <target state="translated">&lt;code&gt;~w&lt;/code&gt; 와 같은 방식으로 표준 구문으로 데이터를 쓰지만 인쇄 된 표현이 한 줄보다 긴 항을 여러 줄로 나누고 각 줄을 현명하게 들여 쓰기합니다. 왼쪽 정렬은 지원되지 않습니다. 또한 인쇄 가능한 문자의 단순 목록을 감지하여 문자열로 출력하려고 시도합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edd67c05e7abf8a55e7a45df50941009e549a0e1" translate="yes" xml:space="preserve">
          <source>Writes the items in &lt;code&gt;Data&lt;/code&gt; (&lt;code&gt;[]&lt;/code&gt;) on the standard output (&lt;code&gt;IoDevice&lt;/code&gt;) in accordance with &lt;code&gt;Format&lt;/code&gt;. &lt;code&gt;Format&lt;/code&gt; contains plain characters that are copied to the output device, and control sequences for formatting, see below. If &lt;code&gt;Format&lt;/code&gt; is an atom or a binary, it is first converted to a list with the aid of &lt;code&gt;atom_to_list/1&lt;/code&gt; or &lt;code&gt;binary_to_list/1&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Format&lt;/code&gt; 에 따라 표준 출력 ( &lt;code&gt;IoDevice&lt;/code&gt; )의 &lt;code&gt;Data&lt;/code&gt; ( &lt;code&gt;[]&lt;/code&gt; )에 항목을 씁니다 . &lt;code&gt;Format&lt;/code&gt; 에는 출력 장치에 복사되는 일반 문자와 형식 지정을위한 제어 순서가 포함되어 있습니다 (아래 참조). 경우 &lt;code&gt;Format&lt;/code&gt; 원자 또는 바이너리, 그것은 처음의 도움으로 목록으로 변환됩니다 &lt;code&gt;atom_to_list/1&lt;/code&gt; 또는 &lt;code&gt;binary_to_list/1&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="bd82ff973a69c0238fad9984d419046978981ebd" translate="yes" xml:space="preserve">
          <source>Writes to an open file, without waiting for the result. If the handle is valid, the function returns &lt;code&gt;{async, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is a term guaranteed to be unique between calls of &lt;code&gt;awrite&lt;/code&gt;. The result of the &lt;code&gt;write&lt;/code&gt; operation is sent as a message to the calling process. This message has the form &lt;code&gt;{async_reply, N, Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is the result from the write, either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error, reason()}&lt;/code&gt;.</source>
          <target state="translated">결과를 기다리지 않고 열린 파일에 씁니다. 핸들이 유효하면이 함수는 &lt;code&gt;{async, N}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;awrite&lt;/code&gt; 호출 사이에서 고유함을 보장하는 용어 입니다. &lt;code&gt;write&lt;/code&gt; 작업 의 결과 는 호출 프로세스에 메시지로 전송됩니다. 이 메시지의 형식은 &lt;code&gt;{async_reply, N, Result}&lt;/code&gt; . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, reason()}&lt;/code&gt; 쓰기 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="95560093414725c51ed8e81fdb4501026a286814" translate="yes" xml:space="preserve">
          <source>Writing an Erlang driver is not easy. The driver is written as some callback functions called by the Erlang emulator when data is sent to the driver, or the driver has any data available on a file descriptor. As the driver callback routines execute in the main thread of the Erlang machine, the callback functions can perform no blocking activity whatsoever. The callbacks are only to set up file descriptors for waiting and/or read/write available data. All I/O must be non-blocking. Driver callbacks are however executed in sequence, why a global state can safely be updated within the routines.</source>
          <target state="translated">Erlang 드라이버를 작성하는 것은 쉽지 않습니다. 드라이버는 데이터가 드라이버로 전송되거나 드라이버가 파일 디스크립터에서 사용 가능한 데이터를 가질 때 Erlang 에뮬레이터가 호출하는 일부 콜백 함수로 작성됩니다. 드라이버 콜백 루틴이 Erlang 시스템의 메인 스레드에서 실행될 때 콜백 함수는 어떠한 차단 활동도 수행 할 수 없습니다. 콜백은 대기 및 / 또는 사용 가능한 데이터 읽기 / 쓰기를 위해 파일 디스크립터를 설정하기위한 것입니다. 모든 I / O는 비 블로킹이어야합니다. 그러나 드라이버 콜백은 순서대로 실행되므로 루틴 내에서 전역 상태를 안전하게 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98612a0f6652d2811b89aef0049934abe9f222dd" translate="yes" xml:space="preserve">
          <source>Writing or deleting in transaction context creates a local copy of each modified record. Thus, modifying each record in a large table uses much memory. &lt;code&gt;Mnesia&lt;/code&gt; compensates for every written or deleted record during the iteration in a transaction context, which can reduce the performance. If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">트랜잭션 컨텍스트에서 쓰거나 삭제하면 수정 된 각 레코드의 로컬 사본이 작성됩니다. 따라서 큰 테이블에서 각 레코드를 수정하면 많은 메모리가 사용됩니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 트랜잭션 컨텍스트에서 반복하는 동안 모든 기록 또는 삭제 된 레코드를 보상하여 성능을 저하시킬 수 있습니다. 가능하면 테이블을 반복하기 전에 동일한 트랜잭션에서 레코드를 쓰거나 삭제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2158219f2b23b9c1414ff2f997bddb708f004bc7" translate="yes" xml:space="preserve">
          <source>Writing or deleting in transaction-context creates a local copy of each modified record during the transaction. During iteration, that is, &lt;code&gt;mnesia:fold[lr]/4&lt;/code&gt;, &lt;code&gt;mnesia:next/2&lt;/code&gt;, &lt;code&gt;mnesia:prev/2&lt;/code&gt;, and &lt;code&gt;mnesia:snmp_get_next_index/2&lt;/code&gt;, Mnesia compensates for every written or deleted record, which can reduce the performance.</source>
          <target state="translated">트랜잭션 컨텍스트에서 쓰거나 삭제하면 트랜잭션 중에 수정 된 각 레코드의 로컬 사본이 작성됩니다. 반복 중에 (즉, &lt;code&gt;mnesia:fold[lr]/4&lt;/code&gt; , &lt;code&gt;mnesia:next/2&lt;/code&gt; , &lt;code&gt;mnesia:prev/2&lt;/code&gt; , &lt;code&gt;mnesia:snmp_get_next_index/2&lt;/code&gt; ) Mnesia는 모든 기록 또는 삭제 된 레코드를 보상하여 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c916ed041ac56f7b5fe8fba00f4d3d9ae0c2d5" translate="yes" xml:space="preserve">
          <source>X Windows -- Development headers and libraries are needed to build the Erlang/OTP application &lt;code&gt;gs&lt;/code&gt; on Unix/Linux.</source>
          <target state="translated">X Windows- Unix / Linux 에서 Erlang / OTP 애플리케이션 &lt;code&gt;gs&lt;/code&gt; 를 빌드하려면 개발 헤더 및 라이브러리가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b1dc96e1bc7b76c3d0a668d65241f9122d97e6" translate="yes" xml:space="preserve">
          <source>XLineOp ::= &lt;code&gt;XXL&lt;/code&gt;</source>
          <target state="translated">XLineOp :: = &lt;code&gt;XXL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebaf703afcca9ac7d80cec79f8e4c38185d744c2" translate="yes" xml:space="preserve">
          <source>XML Base directory. If using string/1 default is current directory. If using file/1 default is directory of given file.</source>
          <target state="translated">XML 기본 디렉토리. string / 1을 사용하는 경우 기본값은 현재 디렉토리입니다. file / 1을 사용하는 경우 기본값은 지정된 파일의 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="d4942b7a0ca58ce9a60651831280a6a1a686d64d" translate="yes" xml:space="preserve">
          <source>XML SAX parser API</source>
          <target state="translated">XML SAX 파서 API</target>
        </trans-unit>
        <trans-unit id="76a2ea89ec47012fd2585a7f145edb56f2e38495" translate="yes" xml:space="preserve">
          <source>XSD Base directory.</source>
          <target state="translated">XSD 기본 디렉토리.</target>
        </trans-unit>
        <trans-unit id="cd5914d573e50149e231d0679f3994ef5c65dc1a" translate="yes" xml:space="preserve">
          <source>XSLT stylesheets are often used when transforming XML documents, to other XML documents or (X)HTML for presentation. XSLT contains quite many functions and learning them all may take some effort. This document assumes a basic level of understanding of XSLT.</source>
          <target state="translated">XSLT 스타일 시트는 종종 XML 문서를 다른 XML 문서 또는 프리젠 테이션을 위해 (X) HTML로 변환 할 때 사용됩니다. XSLT에는 많은 기능이 포함되어 있으며 모두 배우려면 약간의 노력이 필요할 수 있습니다. 이 문서는 XSLT에 대한 기본적인 이해 수준을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="91baafa2e6d790f0fd1e6b4c5d5dc90e636fd65f" translate="yes" xml:space="preserve">
          <source>Xan matches characters that have either the L (letter) or the N (number) property. Xps matches the characters tab, linefeed, vertical tab, form feed, or carriage return, and any other character that has the Z (separator) property. Xsp is the same as Xps; it used to exclude vertical tab, for Perl compatibility, but Perl changed, and so PCRE followed at release 8.34. Xwd matches the same characters as Xan, plus underscore.</source>
          <target state="translated">Xan은 L (문자) 또는 N (숫자) 속성이있는 문자와 일치합니다. Xps는 문자 탭, 줄 바꿈, 세로 탭, 용지 공급 또는 캐리지 리턴 및 Z (구분 기호) 속성이있는 다른 문자와 일치합니다. Xsp는 Xps와 동일합니다. Perl 호환성을 위해 수직 탭을 제외하는 데 사용되었지만 Perl이 변경되었으므로 PCRE는 릴리스 8.34를 따랐습니다. Xwd는 Xan과 동일한 문자와 밑줄을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="03cef8b5cbbd5ddf91318d63826f1481c80cbbe0" translate="yes" xml:space="preserve">
          <source>Xcode -- Download and install via the Mac App Store. Read about &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_OS-X-Darwin&quot;&gt;Building on a Mac&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Xcode-Mac App Store를 통해 다운로드하여 설치하십시오. 계속하기 전에 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_OS-X-Darwin&quot;&gt;Building on a Mac&lt;/a&gt;&lt;/code&gt; 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="8a29eadc00876c3f9f89861cd30ff0f184e72723" translate="yes" xml:space="preserve">
          <source>Xoroshiro116+, 58 bits precision and period of 2^116-1</source>
          <target state="translated">Xoroshiro116 +, 58 비트 정밀도 및주기 2 ^ 116-1</target>
        </trans-unit>
        <trans-unit id="90f37ece5b491baad7255059492161cafaeb7b80" translate="yes" xml:space="preserve">
          <source>Xorshift1024*, 64 bits precision and a period of 2^1024-1</source>
          <target state="translated">Xorshift1024 *, 64 비트 정밀도 및주기 2 ^ 1024-1</target>
        </trans-unit>
        <trans-unit id="bdfa54ab076a7f65b355fcd3585f50eac93fa010" translate="yes" xml:space="preserve">
          <source>Xorshift116+, 58 bits precision and period of 2^116-1</source>
          <target state="translated">Xorshift116 +, 58 비트 정밀도 및주기 2 ^ 116-1</target>
        </trans-unit>
        <trans-unit id="2ca96fe21b48b46326339731f1910ba4c39289d2" translate="yes" xml:space="preserve">
          <source>Xref is a cross reference tool that can be used for finding dependencies between functions, modules, applications and releases.</source>
          <target state="translated">외부 참조는 기능, 모듈, 응용 프로그램 및 릴리스 간의 종속성을 찾는 데 사용할 수있는 상호 참조 도구입니다.</target>
        </trans-unit>
        <trans-unit id="bf5db07cbf5de7a48698edf64bb54bb7181dae3a" translate="yes" xml:space="preserve">
          <source>Xref is a cross reference tool that can be used for finding dependencies between functions, modules, applications and releases. It does so by analyzing the defined functions and the function calls.</source>
          <target state="translated">외부 참조는 기능, 모듈, 응용 프로그램 및 릴리스 간의 종속성을 찾는 데 사용할 수있는 상호 참조 도구입니다. 정의 된 함수와 함수 호출을 분석하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0f82f4c6fd6d2e271c18dc16920529f19f31513c" translate="yes" xml:space="preserve">
          <source>Y is divisible by 4, but not by 100.</source>
          <target state="translated">Y는 4로 나눌 수 있지만 100으로 나눌 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed7e88a0e39e56909a7112967eb11b815a801630" translate="yes" xml:space="preserve">
          <source>Y is divisible by 400.</source>
          <target state="translated">Y는 400으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc754adcb9e0fb9bdb59e4affd3affee795f3be1" translate="yes" xml:space="preserve">
          <source>Year cannot be abbreviated. For example, 93 denotes year 93, not 1993. The valid range depends on the underlying operating system. The date tuple must denote a valid date.</source>
          <target state="translated">연도는 축약 될 수 없습니다. 예를 들어 93은 1993이 아니라 93 년을 나타냅니다. 유효한 범위는 기본 운영 체제에 따라 다릅니다. 날짜 튜플은 유효한 날짜를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="1a2942b3d437716ba7dc18750c7ae62ec76eaafa" translate="yes" xml:space="preserve">
          <source>Yecc source code. It generates an &lt;code&gt;.erl&lt;/code&gt; file.</source>
          <target state="translated">Yecc 소스 코드. &lt;code&gt;.erl&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="5f411c3c587484a1d48aefa7d4b4fd59514ba6b7" translate="yes" xml:space="preserve">
          <source>Yecc will add the extension &lt;code&gt;.yrl&lt;/code&gt; to the &lt;code&gt;Grammarfile&lt;/code&gt; name, the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name, and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Parserfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Yecc는 확장명이 &lt;code&gt;.yrl&lt;/code&gt; 을 &lt;code&gt;Grammarfile&lt;/code&gt; 이름에, 확장명이 &lt;code&gt;.hrl&lt;/code&gt; 을 포함 &lt;code&gt;Includefile&lt;/code&gt; 이름에, 확장명이 &lt;code&gt;.erl&lt;/code&gt; 을 &lt;code&gt;Parserfile&lt;/code&gt; 이름에 추가합니다 (확장자가 이미없는 경우).</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="d71ce5e0c5df7542006b59dc9b3838226fe8ef23" translate="yes" xml:space="preserve">
          <source>Yes, it will. The compiler will remove the building of the sub binary in the second clause:</source>
          <target state="translated">그렇습니다. 컴파일러는 두 번째 절에서 하위 바이너리 빌드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="db0743dfbc21679c5d5f6843a71f19fba1d8be6c" translate="yes" xml:space="preserve">
          <source>Yet another possibility, closer to the hardware, could be:</source>
          <target state="translated">하드웨어에 더 가까운 또 다른 가능성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2bf8cb1a13b6661ace7ce9f9719055b32f2e726" translate="yes" xml:space="preserve">
          <source>Yi</source>
          <target state="translated">Yi</target>
        </trans-unit>
        <trans-unit id="aa9f168c3a59a63ca6dd4dca9f3f7875cef10b5b" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;false&lt;/code&gt; if the node has no associated comments, and &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">수익률 &lt;code&gt;false&lt;/code&gt; 노드가 댓글 없음을 연결하고있는 경우 &lt;code&gt;true&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="fa41faedce6ff2c37f6aa8305079a3e9471a91f5" translate="yes" xml:space="preserve">
          <source>Yields a document representing a fixed, unbreakable sequence of characters. The string should contain only &lt;strong&gt;printable&lt;/strong&gt; characters (tabs allowed but not recommended), and &lt;strong&gt;not&lt;/strong&gt; newline, line feed, vertical tab, etc. A tab character (&lt;code&gt;\t&lt;/code&gt;) is interpreted as padding of 1-8 space characters to the next column of 8 characters &lt;strong&gt;within the string&lt;/strong&gt;.</source>
          <target state="translated">고정되고 깨지지 않는 일련의 문자를 나타내는 문서를 생성합니다. 문자열 만 포함해야 &lt;strong&gt;인쇄 가능한&lt;/strong&gt; 문자 (탭 권장 허용하지만), 그리고 &lt;strong&gt;하지&lt;/strong&gt; 바꿈, 줄 바꿈, 세로 탭 등 탭 문자 ( &lt;code&gt;\t&lt;/code&gt; ) 8의 다음 컬럼에 1-8 공백 문자의 패딩으로 해석됩니다 &lt;strong&gt;문자열 내의&lt;/strong&gt; 문자 .</target>
        </trans-unit>
        <trans-unit id="6342bb3b872c93baac7b84d88b17cec249d4f899" translate="yes" xml:space="preserve">
          <source>Yields a document representing paragraph-formatted plain text. The optional &lt;code&gt;Indentation&lt;/code&gt; parameter specifies the extra indentation of the first line of the paragraph. For example, &lt;code&gt;text_par(&quot;Lorem ipsum dolor sit amet&quot;, N)&lt;/code&gt; could represent</source>
          <target state="translated">단락 형식의 일반 텍스트를 나타내는 문서를 생성합니다. 선택적 &lt;code&gt;Indentation&lt;/code&gt; 매개 변수는 단락의 첫 줄에 추가 들여 쓰기를 지정합니다. 예를 들어 &lt;code&gt;text_par(&quot;Lorem ipsum dolor sit amet&quot;, N)&lt;/code&gt; 은 다음을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8539219eb3fd77fc26dc9662796e268067a2b3" translate="yes" xml:space="preserve">
          <source>Yields the empty document, which has neither height nor width. (&lt;code&gt;empty&lt;/code&gt; is thus different from an empty &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; string, which has zero width but height 1.)</source>
          <target state="translated">높이나 너비가없는 빈 문서를 생성합니다. ( 따라서 &lt;code&gt;empty&lt;/code&gt; 은 너비가 0이지만 높이는 1 인 빈 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 문자열과 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="f0ae54f0f8d8777ee1ccd332c51571592e4ee4d9" translate="yes" xml:space="preserve">
          <source>Yields the most compact form for an abstract list skeleton. The result either represents &quot;&lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt;&quot;, where &lt;code&gt;Tail&lt;/code&gt; is not a list skeleton, or otherwise simply &quot;&lt;code&gt;[E1, ..., En]&lt;/code&gt;&quot;. Annotations on subtrees of &lt;code&gt;Node&lt;/code&gt; that represent list skeletons may be lost, but comments will be propagated to the result. Returns &lt;code&gt;Node&lt;/code&gt; itself if &lt;code&gt;Node&lt;/code&gt; does not represent a list skeleton.</source>
          <target state="translated">추상리스트 스켈레톤에 가장 컴팩트 한 형태를 나타냅니다. 결과는 &quot; &lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt; &quot;을 나타냅니다 . 여기서 &lt;code&gt;Tail&lt;/code&gt; 은 목록 골격이 아니거나 단순히 &quot; &lt;code&gt;[E1, ..., En]&lt;/code&gt; &quot;입니다. 목록 스켈레톤을 나타내는 &lt;code&gt;Node&lt;/code&gt; 서브 트리에서 어노테이션 이 유실 될 수 있지만, 주석은 결과에 전파됩니다. &lt;code&gt;Node&lt;/code&gt; 가 목록 스켈레톤을 나타내지 않으면 &lt;code&gt;Node&lt;/code&gt; 자체를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3aae39c5f243994db952309b19946cb1797fc221" translate="yes" xml:space="preserve">
          <source>You also need a gcc. If you installed the 64 bit MSYS2 you run:</source>
          <target state="translated">또한 gcc가 필요합니다. 64 비트 MSYS2를 설치 한 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8c04a1eb0d947a600ddd92a5988643cdbc486eb8" translate="yes" xml:space="preserve">
          <source>You are free to modify the contents of an object retrieved this way. However, when you do so, the registry is not aware of your changes, possibly causing it to be missed the next time you make an &lt;code&gt;Mnesia&lt;/code&gt; backup of the registry contents. This can be avoided if you mark the object as dirty after any such changes with &lt;code&gt;&lt;a href=&quot;registry#ei_reg_markdirty&quot;&gt;registry:ei_reg_markdirty&lt;/a&gt;&lt;/code&gt;, or pass appropriate flags to &lt;code&gt;&lt;a href=&quot;registry#ei_reg_dump&quot;&gt;registry:ei_reg_dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 방법으로 검색된 객체의 내용을 자유롭게 수정할 수 있습니다. 그러나 이렇게하면 레지스트리가 변경 내용을 인식하지 못하므로 다음 에 레지스트리 내용을 &lt;code&gt;Mnesia&lt;/code&gt; 백업 할 때 변경 내용이 누락 될 수 있습니다 . 당신이 이러한 변경 후 오염으로 개체를 표시하는 경우이 피할 수 &lt;code&gt;&lt;a href=&quot;registry#ei_reg_markdirty&quot;&gt;registry:ei_reg_markdirty&lt;/a&gt;&lt;/code&gt; , 또는 적절한 플래그를 통과 &lt;code&gt;&lt;a href=&quot;registry#ei_reg_dump&quot;&gt;registry:ei_reg_dump&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9038edf94d4f5a46f306613699436e553a464d65" translate="yes" xml:space="preserve">
          <source>You are not allowed to allocate the &lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; structure by yourself. It must be allocated and initialized by &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt;erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; 구조를 직접 할당 할 수 없습니다 . &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt;erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt; 에 의해 할당되고 초기화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c5b8225aef9f734d74aff7e241e5e65c8a19461f" translate="yes" xml:space="preserve">
          <source>You are not allowed to allocate the &lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; structure by yourself. It must be allocated and initialized by &lt;code&gt;erl_drv_thread_opts_create&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; 구조를 직접 할당 할 수 없습니다 . &lt;code&gt;erl_drv_thread_opts_create&lt;/code&gt; 에 의해 할당되고 초기화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="30dfa6dc48b2fd68234390e1944fedce147fe434" translate="yes" xml:space="preserve">
          <source>You are now ready to install the Erlang/OTP release! The following command will install the release on your system.</source>
          <target state="translated">이제 Erlang / OTP 릴리스를 설치할 준비가되었습니다! 다음 명령은 시스템에 릴리스를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="22729cd29e226b629e272d1a72f8f88eeaa3c868" translate="yes" xml:space="preserve">
          <source>You are only allowed to terminate threads created with &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 로 작성된 스레드 만 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59411bea6575cd8a0ea474d86bf6c78783f3875a" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;not&lt;/strong&gt; pass a configuration file using the &lt;code&gt;--xcomp-conf&lt;/code&gt; argument when you invoke &lt;code&gt;configure&lt;/code&gt; directly. The &lt;code&gt;--xcomp-conf&lt;/code&gt; argument can only be passed to &lt;code&gt;otp_build configure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 를 직접 호출 할 때 &lt;code&gt;--xcomp-conf&lt;/code&gt; 인수를 사용하여 구성 파일을 전달할 수 &lt;strong&gt;없습니다&lt;/strong&gt; . &lt;code&gt;--xcomp-conf&lt;/code&gt; 의 인수는 전달 될 수 있습니다 &lt;code&gt;otp_build configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35abdd922e455eb4e3458a582559df01c500c039" translate="yes" xml:space="preserve">
          <source>You can add custom metadata, either by specifying a map as the last parameter to any of the log macros or the API functions, or by setting process metadata with &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로그 매크로 또는 API 함수에 대한 마지막 매개 변수로 맵을 지정하거나 &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt; 로 프로세스 메타 데이터를 설정하여 사용자 정의 메타 데이터를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1677347fdd98391eca3e5758569bcaf17f81c50" translate="yes" xml:space="preserve">
          <source>You can also configure the system so that the default handler prints log events to a single file, or to a set of wrap logs via &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 핸들러가 로그 이벤트를 단일 파일 또는 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 를 통해 랩 로그 세트로 인쇄하도록 시스템을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09c242cbdd777d34ff137ac36a09731f4c420b6d" translate="yes" xml:space="preserve">
          <source>You can also enable code coverage in your test specifications (see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results).</source>
          <target state="translated">테스트 사양에서 코드 적용 범위를 활성화 할 수도 있습니다 ( &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 실행 및 결과 분석 섹션의 테스트 사양 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="4483ff84688ea822bef4ab30674260e42c82a3bb" translate="yes" xml:space="preserve">
          <source>You can also pass the cover specification file name in a call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, by adding a &lt;code&gt;{cover,CoverSpec}&lt;/code&gt; tuple to argument &lt;code&gt;Opts&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Opts&lt;/code&gt; 에 &lt;code&gt;{cover,CoverSpec}&lt;/code&gt; 튜플을 추가 하여 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 표지 스펙 파일 이름을 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9833460ab32f6f87bd66898784de048510ecec5" translate="yes" xml:space="preserve">
          <source>You can also set match specifications on messages. By default, if tracing messages, all messages sent and/or received by the process or port are traced. Match specifications can be used to reduce the number of traced messages and/or to trigger more information in the trace messages.</source>
          <target state="translated">메시지에서 일치 사양을 설정할 수도 있습니다. 기본적으로 메시지를 추적하면 프로세스 또는 포트에서 보내고받는 모든 메시지가 추적됩니다. 일치 스펙을 사용하여 추적 된 메시지 수를 줄이거 나 추적 메시지에서 추가 정보를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551210ee2bccd3e951c3dbbc9801ca4766798e44" translate="yes" xml:space="preserve">
          <source>You can also use the function &lt;code&gt;&lt;a href=&quot;eunit#test-1&quot;&gt;eunit:test/1&lt;/a&gt;&lt;/code&gt; to run arbitrary tests, for example to try out some more advanced test descriptors (see &lt;code&gt;&lt;a href=&quot;#EUnit_test_representation&quot;&gt;EUnit test representation&lt;/a&gt;&lt;/code&gt;). For example, running &lt;code&gt;eunit:test(m)&lt;/code&gt; does the same thing as the auto-generated function &lt;code&gt;m:test()&lt;/code&gt;, while &lt;code&gt;eunit:test({inparallel, m})&lt;/code&gt; runs the same test cases but executes them all in parallel.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eunit#test-1&quot;&gt;eunit:test/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 임의의 테스트를 실행할 수 있습니다 ( 예 : 고급 테스트 디스크립터 사용) ( &lt;code&gt;&lt;a href=&quot;#EUnit_test_representation&quot;&gt;EUnit test representation&lt;/a&gt;&lt;/code&gt; 참조 ). 예를 들어 &lt;code&gt;eunit:test(m)&lt;/code&gt; 실행 하면 자동 생성 된 &lt;code&gt;m:test()&lt;/code&gt; 함수와 동일한 기능을 수행 하지만 &lt;code&gt;eunit:test({inparallel, m})&lt;/code&gt; 은 동일한 테스트 케이스를 실행하지만 모두 병렬로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a9ff8518e43bdc2355b6cee436db8164290ae7ae" translate="yes" xml:space="preserve">
          <source>You can always decide not to format the whole trace data contained in the fetch directory, but analyze single files instead. To do so, a single file (or list of files) must be passed as the first argument to &lt;code&gt;format/1,2&lt;/code&gt;.</source>
          <target state="translated">페치 디렉토리에 포함 된 전체 추적 데이터를 형식화하지 않고 대신 단일 파일을 분석하도록 결정할 수 있습니다. 그렇게하려면 단일 파일 (또는 파일 목록)이 &lt;code&gt;format/1,2&lt;/code&gt; 의 첫 번째 인수로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e1cbb080a7afb39db98054ecb11afc153564abe" translate="yes" xml:space="preserve">
          <source>You can always traverse the result set sequential by using next</source>
          <target state="translated">다음을 사용하여 항상 결과 세트를 순차적으로 순회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a98ace90529f363634dbd989ec1efbfa146358f" translate="yes" xml:space="preserve">
          <source>You can check the setting of this by calling &lt;code&gt;io:getopts()&lt;/code&gt;, which gives you an option list containing &lt;code&gt;{encoding,unicode}&lt;/code&gt; or &lt;code&gt;{encoding,latin1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:getopts()&lt;/code&gt; 를 호출하여이 설정을 확인할 수 있습니다. 그러면 &lt;code&gt;{encoding,unicode}&lt;/code&gt; 또는 &lt;code&gt;{encoding,latin1}&lt;/code&gt; 이 포함 된 옵션 목록이 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="8574e316289208e29729f5052d5efe32f2f00e93" translate="yes" xml:space="preserve">
          <source>You can check this option by calling &lt;code&gt;io:printable_range/0&lt;/code&gt;, which returns &lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;latin1&lt;/code&gt;. To be compatible with future (expected) extensions to the settings, rather use &lt;code&gt;io_lib:printable_list/1&lt;/code&gt; to check if a list is printable according to the setting. That function takes into account new possible settings returned from &lt;code&gt;io:printable_range/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:printable_range/0&lt;/code&gt; 을 호출하여이 옵션을 확인할 수 있습니다.이 &lt;code&gt;unicode&lt;/code&gt; 는 unicode 또는 &lt;code&gt;latin1&lt;/code&gt; 을 반환합니다 . 나중에 설정에 대한 확장 (예상) 확장과 호환되도록하려면 &lt;code&gt;io_lib:printable_list/1&lt;/code&gt; 을 사용 하여 설정에 따라 목록을 인쇄 할 수 있는지 확인하십시오. 이 기능은 &lt;code&gt;io:printable_range/0&lt;/code&gt; 에서 반환 된 새로운 가능한 설정을 고려합니다 .</target>
        </trans-unit>
        <trans-unit id="d0e04a4a6eb568c8b8c3a76a7b176057654292be" translate="yes" xml:space="preserve">
          <source>You can choose to export and import code coverage data between tests. If you specify the name of an export file in the cover specification file, &lt;code&gt;Common Test&lt;/code&gt; exports collected coverage data to this file at the end of the test. You can similarly specify previously exported data to be imported and included in the analysis for a test (multiple import files can be specified). This way, the total code coverage can be analyzed without necessarily running all tests at once.</source>
          <target state="translated">테스트간에 코드 적용 범위 데이터를 내보내거나 가져 오도록 선택할 수 있습니다. 표지 사양 파일에 내보내기 파일 이름을 지정하면 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트가 끝날 때 수집 된 범위 데이터를이 파일로 내 보냅니다. 이전에 내 보낸 데이터를 가져 와서 테스트 분석에 포함하도록 유사하게 지정할 수 있습니다 (여러 가져 오기 파일을 지정할 수 있음). 이러한 방식으로 모든 코드를 한 번에 실행하지 않고도 전체 코드 적용 범위를 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7fb46f54e79b2ee6f1b2af9d941dce71c1854fe" translate="yes" xml:space="preserve">
          <source>You can easily create deadlocks if processes suspends each other (directly or in circles). In ERTS versions prior to ERTS version 10.0, the runtime system prevented such deadlocks, but this prevention has now been removed due to performance reasons.</source>
          <target state="translated">프로세스가 서로 직접 또는 원으로 중단되면 교착 상태를 쉽게 만들 수 있습니다. ERTS 버전 10.0 이전의 ERTS 버전에서 런타임 시스템은 이러한 교착 상태를 방지했지만 성능상의 이유로이 방지 기능이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="423b821d23b692bfa4b48fe6190af1e377d23e6e" translate="yes" xml:space="preserve">
          <source>You can either install using the installation paths determined by &lt;code&gt;configure&lt;/code&gt; (4), or install manually using (5).</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; (4)에 의해 결정된 설치 경로를 사용하여 설치 하거나 (5)를 사용하여 수동으로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34178d3c81c96b486894bd95b9f44ba16a15c48" translate="yes" xml:space="preserve">
          <source>You can even write case switches using &lt;code&gt;?Q&lt;/code&gt; macros as patterns. For example:</source>
          <target state="translated">&lt;code&gt;?Q&lt;/code&gt; 매크로를 패턴으로 사용하여 대소 문자 전환을 작성할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1639897175fdaf0ee0817cc235065e52a6c6ddc8" translate="yes" xml:space="preserve">
          <source>You can find examples of these three examples of usage below.</source>
          <target state="translated">아래 세 가지 사용 예에 ​​대한 예를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f57329dd909da731d2afd5bd8834c0250077de" translate="yes" xml:space="preserve">
          <source>You can generate events of any existing &lt;code&gt;type&lt;/code&gt;, but the &lt;code&gt;internal&lt;/code&gt; type can only be generated through action &lt;code&gt;next_event&lt;/code&gt;. Hence, it cannot come from an external source, so you can be certain that an &lt;code&gt;internal&lt;/code&gt; event is an event from your state machine to itself.</source>
          <target state="translated">기존 &lt;code&gt;type&lt;/code&gt; 이벤트를 생성 할 수 있지만, &lt;code&gt;next_event&lt;/code&gt; 조치를 통해서만 &lt;code&gt;internal&lt;/code&gt; 유형을 생성 할 수 있습니다 . 따라서 외부 소스에서 올 수 없으므로 &lt;code&gt;internal&lt;/code&gt; 이벤트가 상태 머신에서 자체 이벤트 임을 확신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36825f6895831ae9ce55288bf8e10f1c7f638cd5" translate="yes" xml:space="preserve">
          <source>You can iterate over a backup, either to transform it into a new backup, or only read it. The function &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)&lt;/a&gt;&lt;/code&gt;, which normally returns &lt;code&gt;{ok, LastAcc}&lt;/code&gt;, is used for both of these purposes.</source>
          <target state="translated">백업을 반복하여 새 백업으로 변환하거나 읽기만 할 수 있습니다. 함수 &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)&lt;/a&gt;&lt;/code&gt; 정상적으로 복귀 &lt;code&gt;{ok, LastAcc}&lt;/code&gt; 이러한 목적에 모두 사용된다.</target>
        </trans-unit>
        <trans-unit id="5b52459c10b0116f65512e9127ad338dfcd988bd" translate="yes" xml:space="preserve">
          <source>You can lose accuracy and precision when converting between time units. To minimize such loss, collect all data at &lt;code&gt;native&lt;/code&gt; time unit and do the conversion on the end result.</source>
          <target state="translated">시간 단위간에 변환 할 때 정확성과 정밀도를 잃을 수 있습니다. 이러한 손실을 최소화하려면 &lt;code&gt;native&lt;/code&gt; 시간 단위로 모든 데이터를 수집 하고 최종 결과에서 변환을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04104ee8d9624f138edb2edb4f4b2cef9c367e73" translate="yes" xml:space="preserve">
          <source>You can now either do:</source>
          <target state="translated">이제 다음 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdeb798230562cb1e552bac539bf89bbf6d2c2e2" translate="yes" xml:space="preserve">
          <source>You can of course use any editor you like to write Erlang programs, but if you use Emacs there exists editing support such as indentation, syntax highlighting, electric commands, module name verification, comment support including paragraph filling, skeletons, tags support and more. See the &lt;a href=&quot;lib/tools-3.0/doc/html/index&quot;&gt; Tools&lt;/a&gt; application for details.</source>
          <target state="translated">물론 Erlang 프로그램을 작성하려는 편집기를 사용할 수 있지만 Emacs를 사용하는 경우 들여 쓰기, 구문 강조, 전기 명령, 모듈 이름 확인, 단락 채우기, 골격, 태그 지원 등의 주석 지원과 같은 편집 지원이 있습니다. 자세한 내용은 &lt;a href=&quot;lib/tools-3.0/doc/html/index&quot;&gt;도구&lt;/a&gt; 응용 프로그램을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4229af77909230adf1fbc9979cfbb58d6a1bba78" translate="yes" xml:space="preserve">
          <source>You can open a connection for a particular &lt;code&gt;Name&lt;/code&gt; and use the same name as reference for all following subsequent operations. If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; instead (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. A connection without an associated target name can only be closed with the handle value.</source>
          <target state="translated">특정 &lt;code&gt;Name&lt;/code&gt; 대한 연결을 열고 다음의 모든 후속 작업에 대한 참조와 동일한 이름을 사용할 수 있습니다 . 연결이 대신 &lt;code&gt;Handle&lt;/code&gt; 과 연결되도록하려면 (예를 들어 호스트에 대한 여러 연결을 열어야하는 경우) 구성 변수 이름 인 &lt;code&gt;Key&lt;/code&gt; 를 사용하여 대상을 지정하십시오. 연관된 대상 이름이없는 연결은 핸들 값으로 만 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93205ae69716dec641b4316864a13837f4fa7ff7" translate="yes" xml:space="preserve">
          <source>You can open as many registries as you like (if memory permits).</source>
          <target state="translated">메모리가 허용하는 경우 원하는만큼 레지스트리를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965541b42f007530fda56b4a6fc39a30f4e5b6a0" translate="yes" xml:space="preserve">
          <source>You can order &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests you specify. You can choose to repeat tests a number of times, repeat tests for a specific period of time, or repeat tests until a particular stop time is reached. If repetition is controlled by time, an action for &lt;code&gt;Common Test&lt;/code&gt; to take upon time-out can be specified. Either &lt;code&gt;Common Test&lt;/code&gt; performs all tests in the current run before stopping, or it stops when the current test job is finished. Repetition can be activated by &lt;code&gt;ct_run&lt;/code&gt; start flags, or tuples in the &lt;code&gt;ct:run:test/1&lt;/code&gt; option list argument. The flags (options in parentheses) are the following:</source>
          <target state="translated">지정한 &lt;code&gt;Common Test&lt;/code&gt; 를 반복 하기 위해 공통 테스트 를 주문할 수 있습니다 . 테스트를 여러 번 반복하거나 특정 기간 동안 테스트를 반복하거나 특정 중지 시간에 도달 할 때까지 테스트를 반복하도록 선택할 수 있습니다. 반복이 시간별로 제어되는 경우 시간 &lt;code&gt;Common Test&lt;/code&gt; 가 수행 되는 작업을 지정할 수 있습니다. 어느 &lt;code&gt;Common Test&lt;/code&gt; 중지하기 전에 현재 실행의 모든 테스트를 수행하거나 현재 테스트 작업이 완료 될 때 정지합니다. &lt;code&gt;ct_run&lt;/code&gt; 시작 플래그 또는 &lt;code&gt;ct:run:test/1&lt;/code&gt; 옵션 목록 인수의 튜플을 사용하여 반복을 활성화 할 수 있습니다 . 플래그 (괄호 안의 옵션)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92f23e4337a24de1c7d4a0723408a7ebe3dbd5f7" translate="yes" xml:space="preserve">
          <source>You can provide a seed value (a tuple of three integers) with the shuffle property &lt;code&gt;{shuffle,Seed}&lt;/code&gt;. This way, the same shuffling order can be created every time the group is executed. If no seed value is specified, &lt;code&gt;Common Test&lt;/code&gt; creates a &quot;random&quot; seed for the shuffling operation (using the return value of &lt;code&gt;erlang:timestamp/0&lt;/code&gt;). The seed value is always printed to the &lt;code&gt;init_per_group/2&lt;/code&gt; log file so that it can be used to recreate the same execution order in a subsequent test run.</source>
          <target state="translated">shuffle 속성 &lt;code&gt;{shuffle,Seed}&lt;/code&gt; 로 시드 값 (3 개의 정수로 구성된 튜플)을 제공 할 수 있습니다 . 이런 식으로 그룹이 실행될 때마다 동일한 순서 순서를 만들 수 있습니다. 시드 값이 지정되지 않은 경우 &lt;code&gt;Common Test&lt;/code&gt; 는 셔플 링 조작에 대해 &quot;랜덤&quot;시드를 작성합니다 ( &lt;code&gt;erlang:timestamp/0&lt;/code&gt; 의 리턴 값 사용 ). 시드 값은 항상 &lt;code&gt;init_per_group/2&lt;/code&gt; 로그 파일에 인쇄 되므로 이후 테스트 실행에서 동일한 실행 순서를 다시 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c1bc31c671f224905996302123a407a1ab1a1b" translate="yes" xml:space="preserve">
          <source>You can repeat the state enter code by returning one of &lt;code&gt;{repeat_state, ...}&lt;/code&gt;, &lt;code&gt;{repeat_state_and_data,_}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; that otherwise behaves exactly like their &lt;code&gt;keep_state&lt;/code&gt; siblings. See the type &lt;code&gt;state_callback_result()&lt;/code&gt; in the reference manual.</source>
          <target state="translated">&lt;code&gt;keep_state&lt;/code&gt; 형제 와 똑같이 동작하는 &lt;code&gt;{repeat_state, ...}&lt;/code&gt; , &lt;code&gt;{repeat_state_and_data,_}&lt;/code&gt; 또는 &lt;code&gt;repeat_state_and_data&lt;/code&gt; 중 하나를 반환하여 상태 입력 코드를 반복 할 수 있습니다 . 참조 설명서의 &lt;code&gt;state_callback_result()&lt;/code&gt; 유형을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="525476aa0bb90732c53b00712010689976af1013" translate="yes" xml:space="preserve">
          <source>You can retrieve the &lt;code&gt;encoding&lt;/code&gt; setting for an I/O server with function &lt;code&gt;io:getopts()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:getopts()&lt;/code&gt; 함수를 사용하여 I / O 서버 의 &lt;code&gt;encoding&lt;/code&gt; 설정을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17abf270f149ddbce7ab05d930e6206fa2b11a9e" translate="yes" xml:space="preserve">
          <source>You can run into trouble if this feature is used carelessly. Always ensure that all communicating components are either from the same Erlang/OTP release, or from release X and release Y where all components from release Y are in compatibility mode of release X.</source>
          <target state="translated">이 기능을 부주의하게 사용하면 문제가 발생할 수 있습니다. 릴리스 Y의 모든 구성 요소가 릴리스 X의 호환 모드에있는 경우 모든 통신 구성 요소가 항상 동일한 Erlang / OTP 릴리스 또는 릴리스 X 및 릴리스 Y에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="96008ca2eaded68beb9b63d4f96f05cd66c94e49" translate="yes" xml:space="preserve">
          <source>You can set the encoding of a file or other I/O server with function &lt;code&gt;io:setopts/2&lt;/code&gt;. This can also be set when opening a file. Setting the terminal (or other &lt;code&gt;standard_io&lt;/code&gt; server) unconditionally to option &lt;code&gt;{encoding,utf8}&lt;/code&gt; implies that UTF-8 encoded characters are written to the device, regardless of how Erlang was started or the user's environment.</source>
          <target state="translated">&lt;code&gt;io:setopts/2&lt;/code&gt; 기능을 사용하여 파일 또는 기타 I / O 서버의 인코딩을 설정할 수 있습니다 . 파일을 열 때 설정할 수도 있습니다. 터미널 (또는 기타 &lt;code&gt;standard_io&lt;/code&gt; 서버)을 옵션 &lt;code&gt;{encoding,utf8}&lt;/code&gt; 으로 무조건 설정하면 Erlang 시작 방법이나 사용자 환경에 관계없이 UTF-8로 인코딩 된 문자가 장치에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="413ecdb1d68a2adf4a654bf35c78d174f104d6f7" translate="yes" xml:space="preserve">
          <source>You can start &lt;code&gt;Common Test&lt;/code&gt; in an interactive shell mode where no automatic testing is performed. Instead, &lt;code&gt;Common Test&lt;/code&gt; starts its utility processes, installs configuration data (if any), and waits for the user to call functions (typically test case support functions) from the Erlang shell.</source>
          <target state="translated">자동 테스트가 수행되지 않는 대화식 쉘 모드에서 &lt;code&gt;Common Test&lt;/code&gt; 를 시작할 수 있습니다 . 대신 &lt;code&gt;Common Test&lt;/code&gt; 는 유틸리티 프로세스를 시작하고 구성 데이터 (있는 경우)를 설치하며 사용자가 Erlang 쉘에서 함수 (일반적으로 테스트 케이스 지원 함수)를 호출 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6ccecfb82cbec8981031453403b8d005a1fb2328" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;regular expressions&lt;/code&gt; and search for objects, and edit or delete them.</source>
          <target state="translated">&lt;code&gt;regular expressions&lt;/code&gt; 을 사용 하고 객체를 검색하고 편집하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e98168372b155e90b7443b26516f4fe2b04c377" translate="yes" xml:space="preserve">
          <source>You cannot encode a class, object, or object set, only refer to it when defining other ASN.1 entities. Typically you refer to a class as well as to object sets by table constraints and component relation constraints (X.682) in ASN.1 types, as in the following:</source>
          <target state="translated">클래스, 객체 또는 객체 세트를 인코딩 할 수 없으며 다른 ASN.1 엔티티를 정의 할 때만 참조하십시오. 일반적으로 다음과 같이 ASN.1 유형의 테이블 제한 조건 및 구성 요소 관계 제한 조건 (X.682)에 의한 오브젝트 세트뿐만 아니라 클래스도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="537051b02b992f39da66b30d6aa73765fb5e2c0e" translate="yes" xml:space="preserve">
          <source>You cannot use different names to distinguish between two subpatterns with the same number, as PCRE uses only the numbers when matching. For this reason, an error is given at compile time if different names are specified to subpatterns with the same number. However, you can specify the same name to subpatterns with the same number, even when &lt;code&gt;dupnames&lt;/code&gt; is not set.</source>
          <target state="translated">PCRE는 일치 할 때 숫자 만 사용하므로 같은 이름을 가진 두 개의 서브 패턴을 구별하기 위해 다른 이름을 사용할 수 없습니다. 이러한 이유로 같은 이름의 하위 패턴에 다른 이름을 지정하면 컴파일 타임에 오류가 발생합니다. 그러나 &lt;code&gt;dupnames&lt;/code&gt; 가 설정되지 않은 경우에도 동일한 번호를 가진 서브 패턴에 동일한 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e3e363bb7e4c920f6f1dc0384793c43d52437a3" translate="yes" xml:space="preserve">
          <source>You get vectors of &lt;code&gt;ErlIOVec&lt;/code&gt; type from the driver queue (see below), and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver entry function. You can also make them yourself, if you want to send several &lt;code&gt;ErlDrvBinary&lt;/code&gt; buffers at once. Often it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; or .</source>
          <target state="translated">드라이버 대기열 (아래 참조)과 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 드라이버 입력 함수 에서 &lt;code&gt;ErlIOVec&lt;/code&gt; 유형의 벡터를 얻습니다 . 여러 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 버퍼를 한 번 에 보내려면 직접 만들 수도 있습니다 . 종종 &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; 또는 을 사용하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="be9e9d89afaeb9f12be394e2b3fc585cd8a4ce30" translate="yes" xml:space="preserve">
          <source>You have realized that function &lt;code&gt;evil_fun&lt;/code&gt; of the &lt;code&gt;evil_mod&lt;/code&gt; module, with arity &lt;code&gt;2&lt;/code&gt;, is causing all this trouble.</source>
          <target state="translated">arity &lt;code&gt;2&lt;/code&gt; 가있는 &lt;code&gt;evil_mod&lt;/code&gt; 모듈 의 evil_fun 함수 &lt;code&gt;evil_fun&lt;/code&gt; 모든 문제를 일으킨다 는 것을 알았습니다 .</target>
        </trans-unit>
        <trans-unit id="43b8009bceaba89dd5daa6bdc91cff55c1a31c2c" translate="yes" xml:space="preserve">
          <source>You may also input data using &lt;code&gt;&lt;a href=&quot;odbc#param_query&quot;&gt;param_query/[3,4]&lt;/a&gt;&lt;/code&gt; and then the input data will have the Erlang type corresponding to the ODBC type of the column.&lt;code&gt;&lt;a href=&quot;#type&quot;&gt;See ODBC to Erlang mapping&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;odbc#param_query&quot;&gt;param_query/[3,4]&lt;/a&gt;&lt;/code&gt; 를 사용하여 데이터를 입력 하면 입력 데이터의 열 유형에 해당하는 Erlang 유형이 사용됩니다. &lt;code&gt;&lt;a href=&quot;#type&quot;&gt;See ODBC to Erlang mapping&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7edfe74c0254b806dfd4cbe8b427f6bd45d01ea" translate="yes" xml:space="preserve">
          <source>You may even need to apply lifting more than once. To match the entire export list as a single syntax tree, you can write:</source>
          <target state="translated">리프팅을 두 번 이상 적용해야 할 수도 있습니다. 전체 내보내기 목록을 단일 구문 트리로 일치 시키려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e5ee1a6ba8110135a28a89b341ab0c77b29a34c" translate="yes" xml:space="preserve">
          <source>You may repeat the state enter call using the &lt;code&gt;{repeat_state,...}&lt;/code&gt; return value from the &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt;. In this case &lt;code&gt;OldState&lt;/code&gt; will also be equal to the current state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;{repeat_state,...}&lt;/code&gt; 리턴 값을 사용하여 상태 입력 호출을 반복 할 수 있습니다 . 이 경우 &lt;code&gt;OldState&lt;/code&gt; 는 현재 상태와 같습니다.</target>
        </trans-unit>
        <trans-unit id="bda3d6632dce9bc85f74cf55588ba7e9389da040" translate="yes" xml:space="preserve">
          <source>You may run into trouble if this feature is used carelessly. Always ensure that all communicating components are either from the same Erlang/OTP release, or from release X and release Y where all components from release Y are in compatibility mode of release X.</source>
          <target state="translated">이 기능을 부주의하게 사용하면 문제가 발생할 수 있습니다. 릴리스 Y의 모든 구성 요소가 릴리스 X의 호환 모드에있는 경우 모든 통신 구성 요소가 항상 동일한 Erlang / OTP 릴리스 또는 릴리스 X 및 릴리스 Y에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e5c76c19a3b13c108dfd91af1a0ec2e9a7a1de8d" translate="yes" xml:space="preserve">
          <source>You may want to start a timer in one state and respond to the time-out in another, maybe cancel the time-out without changing states, or perhaps run multiple time-outs in parallel. All this can be accomplished with &lt;code&gt;generic time-outs&lt;/code&gt;. They may look a little bit like &lt;code&gt;event time-outs&lt;/code&gt; but contain a name to allow for any number of them simultaneously and they are not automatically cancelled.</source>
          <target state="translated">한 상태에서 타이머를 시작하고 다른 상태에서 시간 초과에 응답하거나 상태를 변경하지 않고 시간 초과를 취소하거나 여러 시간 초과를 병렬로 실행할 수 있습니다. 이 모든 것은 &lt;code&gt;generic time-outs&lt;/code&gt; 으로 수행 할 수 있습니다 . &lt;code&gt;event time-outs&lt;/code&gt; 와 약간 비슷 하지만 동시에 여러 개의 번호를 허용하는 이름이 포함되어 있으며 자동으로 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4f4ce8a1bafe76a9e86e5436df884d3b5865a78" translate="yes" xml:space="preserve">
          <source>You might also want to setup X-windows (XFree86). That might be as easy as running startx from the command prompt and it might be much harder. Use Google to find help.</source>
          <target state="translated">X-windows (XFree86)를 설정할 수도 있습니다. 명령 프롬프트에서 startx를 실행하는 것만 큼 쉬울 수 있으며 훨씬 어려울 수 있습니다. 도움이 필요하면 Google을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="58e6db453bffb8455418bbe276d7e4038ab657de" translate="yes" xml:space="preserve">
          <source>You might want to check out versions of the source code from GitHUB. That is possible directly in Cygwin, but not in MSYS. There is a project MsysGIT:</source>
          <target state="translated">GitHUB에서 소스 코드의 버전을 확인하고 싶을 수도 있습니다. Cygwin에서는 직접 가능하지만 MSYS에서는 불가능합니다. MsysGIT 프로젝트가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c62fe3437c022e8570028fdd328c0f7d666c1479" translate="yes" xml:space="preserve">
          <source>You might wonder why these aren't just one module. The &lt;code&gt;Collector&lt;/code&gt; is a generic full-fledged framework that allows processes to &quot;subscribe&quot; to the &lt;code&gt;Events&lt;/code&gt; that it collects. One &lt;code&gt;Collector&lt;/code&gt; can serve several &lt;code&gt;Viewers&lt;/code&gt;. The typical case is that you have one &lt;code&gt;Viewer&lt;/code&gt; that visualizes &lt;code&gt;Events&lt;/code&gt; in one flavor and another &lt;code&gt;Viewer&lt;/code&gt; that visualizes them in another flavor. If you for example are tracing a text based protocol like &lt;code&gt;HTML&lt;/code&gt; (or &lt;code&gt;Megaco/H.248&lt;/code&gt;) it would be useful to be able to display the &lt;code&gt;Events&lt;/code&gt; as plain text as well as the internal representation of the message. The architecture does also allow you to implement your own &lt;code&gt;Viewer&lt;/code&gt; program as long as it complies to the protocol between the &lt;code&gt;Collector/Viewer&lt;/code&gt; protocol. Currently two kinds of &lt;code&gt;Viewers&lt;/code&gt; exists. That is the old &lt;code&gt;GS&lt;/code&gt; based one and the new based on &lt;code&gt;wxWidgets&lt;/code&gt;. But if you feel for it you may implement your own &lt;code&gt;Viewer&lt;/code&gt;, which for example could display the &lt;code&gt;Events&lt;/code&gt; as ASCII art or whatever you feel useful.</source>
          <target state="translated">왜 이것이 하나의 모듈이 아닌지 궁금 할 것입니다. &lt;code&gt;Collector&lt;/code&gt; 프로세스가에 &quot;가입&quot;할 수있는 일반적인 본격적인 프레임 워크 &lt;code&gt;Events&lt;/code&gt; 가 수집하는. 하나의 &lt;code&gt;Collector&lt;/code&gt; 가 여러 &lt;code&gt;Viewers&lt;/code&gt; 제공 할 수 있습니다 . 일반적인 경우는 하나의 플레이버에서 &lt;code&gt;Events&lt;/code&gt; 를 시각화하는 하나의 &lt;code&gt;Viewer&lt;/code&gt; 와 다른 플레이버에서 이벤트 를 시각화하는 다른 &lt;code&gt;Viewer&lt;/code&gt; 가있는 것입니다. 예를 들어 &lt;code&gt;HTML&lt;/code&gt; (또는 &lt;code&gt;Megaco/H.248&lt;/code&gt; ) 과 같은 텍스트 기반 프로토콜을 추적하는 경우 &lt;code&gt;Events&lt;/code&gt; 를 표시하는 것이 유용합니다메시지의 내부 표현뿐만 아니라 일반 텍스트. &lt;code&gt;Collector/Viewer&lt;/code&gt; 프로토콜 사이의 프로토콜을 준수하는 한이 아키텍처를 통해 자체 &lt;code&gt;Viewer&lt;/code&gt; 프로그램 을 구현할 수도 있습니다. 현재 두 종류의 &lt;code&gt;Viewers&lt;/code&gt; 가 있습니다. 그것은 이전 &lt;code&gt;GS&lt;/code&gt; 기반의 것과 &lt;code&gt;wxWidgets&lt;/code&gt; 기반의 새로운 것입니다 . 그러나 당신이 그것을 느낀다면 당신은 자신의 &lt;code&gt;Viewer&lt;/code&gt; 구현할 수 있습니다. 예를 들어 &lt;code&gt;Events&lt;/code&gt; 를 ASCII 아트 또는 당신이 유용하다고 생각하는 것으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edffabbfaa98cb58bc42c95e3d19809c6eae37f1" translate="yes" xml:space="preserve">
          <source>You need some tools to be able to build Erlang/OTP on Windows. Most notably you'll need Cygwin, MSYS or MSYS2, Visual Studio and Microsofts Windows SDK, but you might also want a Java compiler, the NSIS install system and OpenSSL. Well, here's some information about the different tools:</source>
          <target state="translated">Windows에서 Erlang / OTP를 빌드하려면 몇 가지 도구가 필요합니다. 특히 Cygwin, MSYS 또는 MSYS2, Visual Studio 및 Microsoft Windows SDK가 필요하지만 Java 컴파일러, NSIS 설치 시스템 및 OpenSSL이 필요할 수도 있습니다. 다양한 도구에 대한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae8e918676db4997ccb96dd5218b9d3e93aa95bc" translate="yes" xml:space="preserve">
          <source>You need to retrieve data from XML documents. Your Erlang software can handle information from the XML document by extracting data from the data structure received by parsing.</source>
          <target state="translated">XML 문서에서 데이터를 검색해야합니다. Erlang 소프트웨어는 구문 분석을 통해 수신 한 데이터 구조에서 데이터를 추출하여 XML 문서의 정보를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="56322d848be6f1012153725fd14cdbdcd0d3d138" translate="yes" xml:space="preserve">
          <source>You need to write template functions to be able to control what kind of output you want. Thus if you want to encapsulate a &lt;code&gt;bike&lt;/code&gt; element in &amp;lt;p&amp;gt; tags you simply write a function:</source>
          <target state="translated">원하는 출력 종류를 제어하려면 템플릿 기능을 작성해야합니다. 따라서 &lt;code&gt;bike&lt;/code&gt; 요소를 &amp;lt;p&amp;gt; 태그 로 캡슐화 하려면 간단히 함수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a15fb947f56c5ca980fe1f5447d83f6abf981cc2" translate="yes" xml:space="preserve">
          <source>You normally do only one of the encrypt or decrypt operations, and the peer does the other. This normaly used in legacy applications as a primitive digital signature.</source>
          <target state="translated">일반적으로 암호화 또는 암호 해독 작업 중 하나만 수행하고 피어는 다른 작업을 수행합니다. 이는 레거시 응용 프로그램에서 기본 디지털 서명으로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a0077f1555cfe12a61c3d877c68597be7546cc11" translate="yes" xml:space="preserve">
          <source>You normally do only one of the sign or verify operations, and the peer does the other.</source>
          <target state="translated">일반적으로 서명 또는 확인 작업 중 하나만 수행하고 피어는 다른 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ba70d6f6844215520a1ab62c505590fe6b80d193" translate="yes" xml:space="preserve">
          <source>You probably want to get started on your own first test suites now, while at the same time digging deeper into the &lt;code&gt;Common Test&lt;/code&gt; User's Guide and Reference Manual. There are much more to learn about the things that have been introduced in this section. There are also many other useful features to learn, so please continue to the other sections and have fun.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; User 's Guide and Reference Manual을 더 깊이 파고 들면서 자신의 첫 번째 테스트 스위트에서 시작하고 싶을 것입니다 . 이 섹션에서 소개 된 것들에 대해 더 많은 것을 배울 수 있습니다. 배울 수있는 다른 유용한 기능도 많이 있으므로 다른 섹션으로 계속 진행하여 재미있게 보내십시오.</target>
        </trans-unit>
        <trans-unit id="885ba0137c3250a49cd7c1983d4abc2a83e3fbc8" translate="yes" xml:space="preserve">
          <source>You return a list containing &lt;code&gt;state_enter&lt;/code&gt; from your &lt;code&gt;callback_mode/0&lt;/code&gt; function and the &lt;code&gt;gen_statem&lt;/code&gt; engine will call your state callback once with the arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. Then you just need to handle these event-like calls in all states.</source>
          <target state="translated">&lt;code&gt;callback_mode/0&lt;/code&gt; 함수 에서 &lt;code&gt;state_enter&lt;/code&gt; 가 포함 된 목록을 반환 하면 &lt;code&gt;gen_statem&lt;/code&gt; 엔진은 상태가 변경 될 때마다 인수 &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; 하여 상태 콜백을 한 번 호출합니다 . 그런 다음 모든 주에서 이러한 이벤트와 유사한 호출을 처리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6d3a1a8c0569b8643dc506d38af14e3006dabe74" translate="yes" xml:space="preserve">
          <source>You should also have an &lt;code&gt;ERL_TOP&lt;/code&gt; environment variable that is &lt;strong&gt;Cygwin style&lt;/strong&gt;, and points to a directory containing, among other files, the script &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Cygwin 스타일&lt;/strong&gt; 의 &lt;code&gt;ERL_TOP&lt;/code&gt; 환경 변수 도 있어야하며 다른 파일 중에서 &lt;code&gt;otp_build&lt;/code&gt; 스크립트를 포함하는 디렉토리를 가리 킵니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25958a4183a827e82b00b48702f979c03c46e39e" translate="yes" xml:space="preserve">
          <source>You should by now be able to understand most of the code in the messenger-module. Let us study one case in detail: a message is sent from one user to another.</source>
          <target state="translated">이제 메신저 모듈에서 대부분의 코드를 이해할 수 있습니다. 한 사례를 자세히 연구 해 봅시다. 한 사용자에서 다른 사용자에게 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6fe2775e95e1dce6b8fbcf029eef7f2e5c555539" translate="yes" xml:space="preserve">
          <source>You should get a lot of printouts as the testcases are compiled. Once done you should copy the entire &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; folder to the cross host system.</source>
          <target state="translated">테스트 케이스가 컴파일 될 때 많은 인쇄물을 얻을 수 있습니다. 완료되면 전체 &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; 폴더를 교차 호스트 시스템에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7a1bf6128411067b9a8564b654da2a3e3601e90" translate="yes" xml:space="preserve">
          <source>You should now have a working release of Erlang/OTP! Jump to &lt;code&gt;&lt;a href=&quot;../system_principles/system_principles&quot;&gt;System Principles&lt;/a&gt;&lt;/code&gt; for instructions on running Erlang/OTP.</source>
          <target state="translated">이제 Erlang / OTP가 작동합니다. Erlang / OTP 실행에 대한 지침을 보려면 &lt;code&gt;&lt;a href=&quot;../system_principles/system_principles&quot;&gt;System Principles&lt;/a&gt;&lt;/code&gt; 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ff9957d9923b6af6d60b3c95e5c034281cea473" translate="yes" xml:space="preserve">
          <source>You should read and precisely follow the instructions of the &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp1747.pdf&quot;&gt;Security Policy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/fips/UserGuide-2.0.pdf&quot;&gt;User Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp1747.pdf&quot;&gt;Security Policy&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/fips/UserGuide-2.0.pdf&quot;&gt;User Guide&lt;/a&gt;&lt;/code&gt; 의 지침을 읽고 정확하게 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="3275068cb1741362b3ab0825e2a9a7c5bf3e22a3" translate="yes" xml:space="preserve">
          <source>You should therefore set the period to be long enough that you can accept that the supervisor keeps going at that rate. For example, if you have picked an intensity value of 5, then setting the period to 30 seconds will give you at most one restart per 6 seconds for any longer period of time, which means that your logs won't fill up too quickly, and you will have a chance to observe the failures and apply a fix.</source>
          <target state="translated">따라서 감독자가 해당 비율로 계속 진행할 수 있도록 기간을 충분히 길게 설정해야합니다. 예를 들어 강도 값을 5로 선택한 경우 기간을 30 초로 설정하면 6 초마다 최대 한 번만 다시 시작할 수 있으므로 로그가 너무 빨리 채워지지 않습니다. 실패를 관찰하고 수정 사항을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10eb9fdb5475174f6ad8a75d8add7701e7ee6155" translate="yes" xml:space="preserve">
          <source>You typically do &lt;strong&gt;not&lt;/strong&gt; want to enable this option when the common access pattern is a few read operations interleaved with a few write operations repeatedly. In this case, you would get a performance degradation by enabling this option.</source>
          <target state="translated">당신은 일반적으로 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 일반적인 액세스 패턴이 반복적으로 몇 쓰기 작업 인터리브 몇 읽기 작업 때이 옵션을 사용하려면. 이 경우이 옵션을 활성화하면 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="86b5e238a54f91530f806ebbf549940c9f49564d" translate="yes" xml:space="preserve">
          <source>You typically want to enable this option when concurrent read operations are much more frequent than write operations, or when concurrent reads and writes comes in large read and write bursts (that is, many reads not interrupted by writes, and many writes not interrupted by reads).</source>
          <target state="translated">일반적으로 동시 읽기 작업이 쓰기 작업보다 훨씬 더 자주 또는 동시 읽기 및 쓰기가 큰 읽기 및 쓰기 버스트 (즉, 쓰기에 의해 중단되지 않은 많은 읽기 및 읽기에 의해 중단되지 않은 많은 쓰기)가 발생하는 경우이 옵션을 활성화하려고합니다. ).</target>
        </trans-unit>
        <trans-unit id="92f5aff359b87e5d53f4849dc307f5a4affb6037" translate="yes" xml:space="preserve">
          <source>You want only one resulting module.</source>
          <target state="translated">하나의 결과 모듈 만 원합니다.</target>
        </trans-unit>
        <trans-unit id="ea796648d0d9300b8b1cded2425740926ceca9e0" translate="yes" xml:space="preserve">
          <source>You were trying to unload an Erlang statically linked-in driver, which cannot be manipulated with this interface (and cannot be unloaded at all).</source>
          <target state="translated">이 인터페이스로 조작 할 수없고 언로드 할 수없는 Erlang 정적 링크 드라이버를 언로드하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="72380257abe5d5cd2d0c1013b795250f53c529a6" translate="yes" xml:space="preserve">
          <source>Your environment probably provides similar means of changing the keyboard layout. Ensure that you have a way to switch back and forth between keyboards easily if you are not used to this. For example, entering commands using a Cyrillic character set is not easily done in the Erlang shell.</source>
          <target state="translated">환경에 따라 키보드 레이아웃을 변경하는 비슷한 방법이 제공 될 수 있습니다. 키보드에 익숙하지 않은 경우 키보드간에 쉽게 전환 할 수있는 방법이 있는지 확인하십시오. 예를 들어, 키릴 문자 세트를 사용하여 명령을 입력하는 것은 Erlang 쉘에서 쉽게 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfc7c8128b732e96eaa4cdde7bebdd176ce280b6" translate="yes" xml:space="preserve">
          <source>Zip64 archives are not supported.</source>
          <target state="translated">Zip64 아카이브는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bfb00948cc698b3c09503dcaf8708c03daec895" translate="yes" xml:space="preserve">
          <source>[#'AccessDescription'{}]</source>
          <target state="translated">[#'AccessDescription'{}]</target>
        </trans-unit>
        <trans-unit id="e1ce0a14dc0686331ce9550b44fbed909b7b9883" translate="yes" xml:space="preserve">
          <source>[#'Attribute'{}]</source>
          <target state="translated">[#'Attribute'{}]</target>
        </trans-unit>
        <trans-unit id="7521150a8643e4389b97d238734fbf1c297c37fb" translate="yes" xml:space="preserve">
          <source>[#'DistributionPoint'{}]</source>
          <target state="translated">[#'DistributionPoint'{}]</target>
        </trans-unit>
        <trans-unit id="da1ff1345fbb73baa0e0803ea0d0bfd142cb99bb" translate="yes" xml:space="preserve">
          <source>[#'Distributionpoint'{}]</source>
          <target state="translated">[#'Distributionpoint'{}]</target>
        </trans-unit>
        <trans-unit id="51b40a19d8cfda51ed2913bcb1627e5b4327a49e" translate="yes" xml:space="preserve">
          <source>[1]: Microsoft ODBC 3.0, Programmer's Reference and SDK Guide</source>
          <target state="translated">[1] : Microsoft ODBC 3.0, 프로그래머 참조 및 SDK 안내서</target>
        </trans-unit>
        <trans-unit id="66417bc1eadcab6b0b674cc1634320e93505ce28" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="b9c1ecfd8694939fd5931ed6e3f157f3ffcf4476" translate="yes" xml:space="preserve">
          <source>[Arg1, Arg2, ...]</source>
          <target state="translated">[Arg1, Arg2, ...]</target>
        </trans-unit>
        <trans-unit id="42a0b24be599f79aef35b1492c3ad15e2c16879c" translate="yes" xml:space="preserve">
          <source>[MSAcc_Thread] | undefined</source>
          <target state="translated">[MSAcc_Thread] | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="72fc185e7d2415424198bc4e97e4925953c70d24" translate="yes" xml:space="preserve">
          <source>[Node, Sender, Message]</source>
          <target state="translated">[노드, 발신자, 메시지]</target>
        </trans-unit>
        <trans-unit id="2a85c92367aa7a40051022096ca8cf11d8242c6b" translate="yes" xml:space="preserve">
          <source>[Pid :: pid()]</source>
          <target state="translated">[Pid :: pid ()]</target>
        </trans-unit>
        <trans-unit id="0aa157adc562adac91575bb4c43eab47bc7e5f60" translate="yes" xml:space="preserve">
          <source>[Receiver, Message]</source>
          <target state="translated">[수신인, 메시지]</target>
        </trans-unit>
        <trans-unit id="ee00e0101d39709f50e398a82bd0ea3291fa544c" translate="yes" xml:space="preserve">
          <source>[] |</source>
          <target state="translated">[] |</target>
        </trans-unit>
        <trans-unit id="6ca53cc1334ef69049fc43ae5128d412b73b67bb" translate="yes" xml:space="preserve">
          <source>[char()] |</source>
          <target state="translated">[char ()] |</target>
        </trans-unit>
        <trans-unit id="576f6256e36d8c94122108cff7936adada6f9d21" translate="yes" xml:space="preserve">
          <source>[char()] | {error, [char()], &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;}</source>
          <target state="translated">[char ()] | {오류, [char ()], &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="dfdac258a47c9548f07058a4d414926565e2af67" translate="yes" xml:space="preserve">
          <source>[id_key_purpose()]</source>
          <target state="translated">[id_key_purpose()]</target>
        </trans-unit>
        <trans-unit id="2959facd9edc3e27045426ab594a9fed5e38ef6b" translate="yes" xml:space="preserve">
          <source>[key_usage()]</source>
          <target state="translated">[key_usage()]</target>
        </trans-unit>
        <trans-unit id="80cff9d804929b13bd503fac44a911fdc9bd9578" translate="yes" xml:space="preserve">
          <source>[optional] Implement the default user.</source>
          <target state="translated">[선택 사항] 기본 사용자를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="be02612d6c39318d90a0953fdf863bc655b53e4a" translate="yes" xml:space="preserve">
          <source>[pid()] | {error, {no_such_group, Name}}</source>
          <target state="translated">[pid ()] | {오류, {no_such_group, 이름}}</target>
        </trans-unit>
        <trans-unit id="6274e10bcfa160bff5b4411f5a150d9c302e5be9" translate="yes" xml:space="preserve">
          <source>[{&lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-port_number&quot;&gt;port_number()&lt;/a&gt;&lt;/code&gt;} |</source>
          <target state="translated">[{ &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-port_number&quot;&gt;port_number()&lt;/a&gt;&lt;/code&gt; } |</target>
        </trans-unit>
        <trans-unit id="dadf5afb9a670102f8e9550c35fdd5519c70b3df" translate="yes" xml:space="preserve">
          <source>[{Par :: atom(), Val :: any()} |</source>
          <target state="translated">[{Par :: atom (), Val :: any ()} |</target>
        </trans-unit>
        <trans-unit id="3aeb2bf44fbbf62ac9faaa808312e1fe929b20fd" translate="yes" xml:space="preserve">
          <source>[{SchedulerId, ActiveTime, TotalTime}] | undefined</source>
          <target state="translated">[{SchedulerId, ActiveTime, TotalTime}] | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="7309754570cf1a09cfa657f2546d91f8fd76acab" translate="yes" xml:space="preserve">
          <source>[{atom(), integer()}]</source>
          <target state="translated">[{atom (), 정수 ()}]</target>
        </trans-unit>
        <trans-unit id="4bd5d0fef71d6ccb3189e94373cd25fa0b91c611" translate="yes" xml:space="preserve">
          <source>[{atom(), term()}]</source>
          <target state="translated">[{atom (), term ()}]</target>
        </trans-unit>
        <trans-unit id="14391628efa44e40ee12bbe076863a61135834a2" translate="yes" xml:space="preserve">
          <source>[{a}]</source>
          <target state="translated">[{a}]</target>
        </trans-unit>
        <trans-unit id="e2a32cb1fd713c0eed8d48b0cd7bad3597b1db49" translate="yes" xml:space="preserve">
          <source>[{memory_type(), integer() &amp;gt;= 0}]</source>
          <target state="translated">[{memory_type (), 정수 ()&amp;gt; = 0}]</target>
        </trans-unit>
        <trans-unit id="0d6089f53cda0554d0fa4e28f4ec9f7dc7f9017f" translate="yes" xml:space="preserve">
          <source>[{module(), &lt;code&gt;&lt;a href=&quot;#type-level&quot;&gt;level()&lt;/a&gt;&lt;/code&gt; | all | none}]}</source>
          <target state="translated">[{모듈 (), &lt;code&gt;&lt;a href=&quot;#type-level&quot;&gt;level()&lt;/a&gt;&lt;/code&gt; | 모두 | none}]}</target>
        </trans-unit>
        <trans-unit id="ca717bb5d14518f424644a24b58029b2355342d3" translate="yes" xml:space="preserve">
          <source>[{{a}}]</source>
          <target state="translated">[{{a}}]</target>
        </trans-unit>
        <trans-unit id="ab006bb8aacdf6e68299bc1dffccc9bcc8ac3eaf" translate="yes" xml:space="preserve">
          <source>\&quot;</source>
          <target state="translated">\&quot;</target>
        </trans-unit>
        <trans-unit id="9ca863000c0131ce2b74e96a2de49fddf5ae1e10" translate="yes" xml:space="preserve">
          <source>\'</source>
          <target state="translated">\'</target>
        </trans-unit>
        <trans-unit id="d247b868bf66bb4f3e6e64a75980114e868f80c1" translate="yes" xml:space="preserve">
          <source>\N is not allowed in a character class. \B, \R, and \X are not special inside a character class. Like other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;R&quot;, and &quot;X&quot;. Outside a character class, these sequences have different meanings.</source>
          <target state="translated">문자 클래스에는 \ N을 사용할 수 없습니다. \ B, \ R 및 \ X는 문자 클래스 내에서 특별하지 않습니다. 인식 할 수없는 다른 이스케이프 시퀀스와 마찬가지로 리터럴 문자 &quot;B&quot;, &quot;R&quot;및 &quot;X&quot;로 취급됩니다. 문자 클래스 외부에서이 시퀀스는 다른 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="58aec324b2389c6b52945c44a246277784ee9780" translate="yes" xml:space="preserve">
          <source>\R can be restricted to match only CR, LF, or CRLF (instead of the complete set of Unicode line endings) by setting option &lt;code&gt;bsr_anycrlf&lt;/code&gt; either at compile time or when the pattern is matched. (BSR is an acronym for &quot;backslash R&quot;.) This can be made the default when PCRE is built; if so, the other behavior can be requested through option &lt;code&gt;bsr_unicode&lt;/code&gt;. These settings can also be specified by starting a pattern string with one of the following sequences:</source>
          <target state="translated">컴파일 타임 또는 패턴이 일치 할 때 옵션 &lt;code&gt;bsr_anycrlf&lt;/code&gt; 를 설정하여 \ R을 전체 유니 코드 줄 끝 대신 CR, LF 또는 CRLF 와만 일치하도록 제한 할 수 있습니다 . (BSR은 &quot;backslash R&quot;의 약어입니다.) PCRE가 구축 될 때 기본값으로 설정할 수 있습니다. 그렇다면 &lt;code&gt;bsr_unicode&lt;/code&gt; 옵션을 통해 다른 동작을 요청할 수 있습니다 . 다음 설정 중 하나를 사용하여 패턴 문자열을 시작하여이 설정을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="821bc1e3064e5be5c599e2cff7d5d54b776a988d" translate="yes" xml:space="preserve">
          <source>\X always matches at least one character. Then it decides whether to add more characters according to the following rules for ending a cluster:</source>
          <target state="translated">\ X는 항상 하나 이상의 문자와 일치합니다. 그런 다음 클러스터 종료에 대한 다음 규칙에 따라 문자를 추가할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="195f6b5cfc2bdb0e5ace74ca82a581b3f8bfbe14" translate="yes" xml:space="preserve">
          <source>\XYZ, \YZ, \Z</source>
          <target state="translated">\ XYZ, \ YZ, \ Z</target>
        </trans-unit>
        <trans-unit id="9e94758983980504af303ef297fd2bf9d9cea063" translate="yes" xml:space="preserve">
          <source>\\</source>
          <target state="translated">\\</target>
        </trans-unit>
        <trans-unit id="252e8da96b92b7a90e8b1552e1907cd30addbc90" translate="yes" xml:space="preserve">
          <source>\^A...\^Z</source>
          <target state="translated">\^A...\^Z</target>
        </trans-unit>
        <trans-unit id="1fe89331ca92589385290d32cdf4c88a07b2cca0" translate="yes" xml:space="preserve">
          <source>\^a...\^z</source>
          <target state="translated">\^a...\^z</target>
        </trans-unit>
        <trans-unit id="4629ca1b60e263bdc4326334b23323e0434717a5" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>
        </trans-unit>
        <trans-unit id="caf5b0b18d08106e7f87e99a2da9940d43b46e3b" translate="yes" xml:space="preserve">
          <source>\d</source>
          <target state="translated">\d</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="794a729d2e4ffbb094fec03ae9b3acd219371385" translate="yes" xml:space="preserve">
          <source>\f</source>
          <target state="translated">\f</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="f12c84902108895980702c88db900ceea2d2ec01" translate="yes" xml:space="preserve">
          <source>\r</source>
          <target state="translated">\r</target>
        </trans-unit>
        <trans-unit id="e1c702e348504013ae2a1faa8cec6a558f9315a8" translate="yes" xml:space="preserve">
          <source>\s</source>
          <target state="translated">\s</target>
        </trans-unit>
        <trans-unit id="8bf81043e29dfc96a6fe1f30f7116f552de6e7d7" translate="yes" xml:space="preserve">
          <source>\t</source>
          <target state="translated">\t</target>
        </trans-unit>
        <trans-unit id="d5d0ebb2740b3e81b5cce512a169118a280bb8cb" translate="yes" xml:space="preserve">
          <source>\v</source>
          <target state="translated">\v</target>
        </trans-unit>
        <trans-unit id="aa5c3d84724b17a06e8486d209463a0cacc3bc46" translate="yes" xml:space="preserve">
          <source>\xXY</source>
          <target state="translated">\xXY</target>
        </trans-unit>
        <trans-unit id="b3bafabd71b5e3f6f0b7e7fff954f28e5b18fb17" translate="yes" xml:space="preserve">
          <source>\x{X...}</source>
          <target state="translated">\x{X...}</target>
        </trans-unit>
        <trans-unit id="910430359def8b6f4101c0bfa3263d48597c76cc" translate="yes" xml:space="preserve">
          <source>_client_channel</source>
          <target state="translated">_client_channel</target>
        </trans-unit>
        <trans-unit id="9944247b429c4be28335eda6279ee22a6fde09de" translate="yes" xml:space="preserve">
          <source>_client_key_api</source>
          <target state="translated">_client_key_api</target>
        </trans-unit>
        <trans-unit id="a259c9cf0e5845c9647dbd0e2cc8ac938ee3ddd7" translate="yes" xml:space="preserve">
          <source>_codec</source>
          <target state="translated">_codec</target>
        </trans-unit>
        <trans-unit id="27ebe2b676fb65035b0da6b71e99f8bdd71439cc" translate="yes" xml:space="preserve">
          <source>_codec_meas</source>
          <target state="translated">_codec_meas</target>
        </trans-unit>
        <trans-unit id="6c13d5ea43d36d761149497241c9063f67e6a398" translate="yes" xml:space="preserve">
          <source>_codec_mstone1</source>
          <target state="translated">_codec_mstone1</target>
        </trans-unit>
        <trans-unit id="e31dc134e3b80e71589f5ac6fad16e099f10b3c4" translate="yes" xml:space="preserve">
          <source>_codec_mstone2</source>
          <target state="translated">_codec_mstone2</target>
        </trans-unit>
        <trans-unit id="90359852ce07bfa97d9689b7aa43e693def3938c" translate="yes" xml:space="preserve">
          <source>_codec_transform</source>
          <target state="translated">_codec_transform</target>
        </trans-unit>
        <trans-unit id="19872913d782be1589e6701b03a7f45da98d1400" translate="yes" xml:space="preserve">
          <source>_collector</source>
          <target state="translated">_collector</target>
        </trans-unit>
        <trans-unit id="95fd16755308c58bf314492a449a1014c914f078" translate="yes" xml:space="preserve">
          <source>_community_mib</source>
          <target state="translated">_community_mib</target>
        </trans-unit>
        <trans-unit id="18e80d5bfae24861611db7385f7013928e5d6e0d" translate="yes" xml:space="preserve">
          <source>_connection</source>
          <target state="translated">_connection</target>
        </trans-unit>
        <trans-unit id="a0a6e30e98ad368e6a56c6efa08b338f8d445a91" translate="yes" xml:space="preserve">
          <source>_crl_cache</source>
          <target state="translated">_crl_cache</target>
        </trans-unit>
        <trans-unit id="7941966cbd72225704aa9bfd459214344268ebb2" translate="yes" xml:space="preserve">
          <source>_crl_cache_api</source>
          <target state="translated">_crl_cache_api</target>
        </trans-unit>
        <trans-unit id="3682fa3f78064956dda27a4bd62f2333444d4b0f" translate="yes" xml:space="preserve">
          <source>_diameters Service Name and Port Number Registration</source>
          <target state="translated">_diameters 서비스 이름 및 포트 번호 등록</target>
        </trans-unit>
        <trans-unit id="c30c34a37e294b320ee5958d661b902bfb44ae53" translate="yes" xml:space="preserve">
          <source>_edist_compress</source>
          <target state="translated">_edist_compress</target>
        </trans-unit>
        <trans-unit id="109b8ec3b51a8766d30cf8ba35a2b40246af0a62" translate="yes" xml:space="preserve">
          <source>_encoder</source>
          <target state="translated">_encoder</target>
        </trans-unit>
        <trans-unit id="8028fc33af10b780f948e45b09f52da447e46fdc" translate="yes" xml:space="preserve">
          <source>_eventp</source>
          <target state="translated">_eventp</target>
        </trans-unit>
        <trans-unit id="82f8180da8217ef3e2205182011fd18fc88f7425" translate="yes" xml:space="preserve">
          <source>_flex_scanner</source>
          <target state="translated">_flex_scanner</target>
        </trans-unit>
        <trans-unit id="991349ac1ce87ece4b2e2145ad4c432f32ef22b4" translate="yes" xml:space="preserve">
          <source>_frag_hash</source>
          <target state="translated">_frag_hash</target>
        </trans-unit>
        <trans-unit id="36e352f7602ed6ff5b4d3c20ca4f2ecd9762f123" translate="yes" xml:space="preserve">
          <source>_framework_mib</source>
          <target state="translated">_framework_mib</target>
        </trans-unit>
        <trans-unit id="bbf74989137c6ab670df736ad7e99665b37bf816" translate="yes" xml:space="preserve">
          <source>_generic</source>
          <target state="translated">_generic</target>
        </trans-unit>
        <trans-unit id="57efb0a40cc309b5df8e44e3bd28362d8dd5749d" translate="yes" xml:space="preserve">
          <source>_index</source>
          <target state="translated">_index</target>
        </trans-unit>
        <trans-unit id="fae34c1b72ed9b8467d52591b2bce86f7231f1ef" translate="yes" xml:space="preserve">
          <source>_notification_mib</source>
          <target state="translated">_notification_mib</target>
        </trans-unit>
        <trans-unit id="4e978448a39ad6264b1335da8913bc80bc35bb4a" translate="yes" xml:space="preserve">
          <source>_registry</source>
          <target state="translated">_registry</target>
        </trans-unit>
        <trans-unit id="9e12eefdf403355bcef74652ad9c69a9e23b92ed" translate="yes" xml:space="preserve">
          <source>_sax_parser</source>
          <target state="translated">_sax_parser</target>
        </trans-unit>
        <trans-unit id="b80362d86e60aad62fc19cd4291b21f9cc5e74d5" translate="yes" xml:space="preserve">
          <source>_selector</source>
          <target state="translated">_selector</target>
        </trans-unit>
        <trans-unit id="928c08775129da2e65f5a26ddd7c047ceca219b0" translate="yes" xml:space="preserve">
          <source>_server_channel</source>
          <target state="translated">_server_channel</target>
        </trans-unit>
        <trans-unit id="03786a0e59ea12891f7d1aafedc1dd322f0a4a75" translate="yes" xml:space="preserve">
          <source>_server_key_api</source>
          <target state="translated">_server_key_api</target>
        </trans-unit>
        <trans-unit id="b8856171bfcbab10cae954cc8871b426fe01d425" translate="yes" xml:space="preserve">
          <source>_session_cache_api</source>
          <target state="translated">_session_cache_api</target>
        </trans-unit>
        <trans-unit id="5ab367fbe50d2be8c17052d34ea7846a858a0823" translate="yes" xml:space="preserve">
          <source>_sftpd</source>
          <target state="translated">_sftpd</target>
        </trans-unit>
        <trans-unit id="36327c474ffb863cd315060f16b646fc9f886d90" translate="yes" xml:space="preserve">
          <source>_standard_mib</source>
          <target state="translated">_standard_mib</target>
        </trans-unit>
        <trans-unit id="fdaf9ee7f1c954d6ec27a2bc4262c918c79d9d43" translate="yes" xml:space="preserve">
          <source>_surefire</source>
          <target state="translated">_surefire</target>
        </trans-unit>
        <trans-unit id="fae159c3bbaacbf232b454a5f598ad5777905bb7" translate="yes" xml:space="preserve">
          <source>_target_mib</source>
          <target state="translated">_target_mib</target>
        </trans-unit>
        <trans-unit id="d5400cfd5df0e2b5888f26e0fcbc79b4733be156" translate="yes" xml:space="preserve">
          <source>_transport</source>
          <target state="translated">_transport</target>
        </trans-unit>
        <trans-unit id="38a498c8bf43f2521df379307eafdd3caf03310c" translate="yes" xml:space="preserve">
          <source>_user_based_sm_mib</source>
          <target state="translated">_user_based_sm_mib</target>
        </trans-unit>
        <trans-unit id="68c989013d882bac18756c204f907b0ced5b51ae" translate="yes" xml:space="preserve">
          <source>_view_based_acm_mib</source>
          <target state="translated">_view_based_acm_mib</target>
        </trans-unit>
        <trans-unit id="623272811c212441ff18fde00b01b6c2dcd21dde" translate="yes" xml:space="preserve">
          <source>_viewer</source>
          <target state="translated">_viewer</target>
        </trans-unit>
        <trans-unit id="ec9274d990f6a819f4992976553663b0387141da" translate="yes" xml:space="preserve">
          <source>_xpath</source>
          <target state="translated">_xpath</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="9209a9399eab62a76dfdee367b13d15ddcddf6a3" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;table element&lt;/strong&gt;, which is a special type of scalar variable.</source>
          <target state="translated">&lt;strong&gt;테이블 요소&lt;/strong&gt; 스칼라 변수의 특별한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="59f850078a1da734ba08cef0859f100fe8981523" translate="yes" xml:space="preserve">
          <source>a description of a Management Information Base (MIB) in Abstract Syntax Notation One (ASN.1)</source>
          <target state="translated">ASN.1 (Abstract Syntax Notation One)의 MIB (Management Information Base)에 대한 설명</target>
        </trans-unit>
        <trans-unit id="598ba6d6d2150e77bd152dcc13c73aea221d2a5f" translate="yes" xml:space="preserve">
          <source>a list of any of the above, e.g. &lt;code&gt;['file*','../foo/file3','File4']&lt;/code&gt;</source>
          <target state="translated">위의 목록 중 하나, 예 : &lt;code&gt;['file*','../foo/file3','File4']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6aa21f6a27cddec52cbf6694c42d1efd18020bd" translate="yes" xml:space="preserve">
          <source>a mechanism for sending notifications (traps and informs)</source>
          <target state="translated">알림 (트랩 및 알림)을 전송하는 메커니즘</target>
        </trans-unit>
        <trans-unit id="d3f50d1c8c2b43636798e88f62cb7fbbbf750c67" translate="yes" xml:space="preserve">
          <source>a module name in another directory, e.g. &lt;code&gt;../foo/file3&lt;/code&gt;</source>
          <target state="translated">다른 디렉토리에있는 모듈 이름, 예 : &lt;code&gt;../foo/file3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f8feb36544be17ef62afe31de2e6ba28542d0dc" translate="yes" xml:space="preserve">
          <source>a module name, e.g. &lt;code&gt;file1&lt;/code&gt;</source>
          <target state="translated">모듈 이름 (예 : &lt;code&gt;file1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2ebaeff8eee87080a90c31f62fb9e00acf1580a" translate="yes" xml:space="preserve">
          <source>a reference to a key in the Engine is available. This should be an Erlang string or binary and depends on the Engine loaded</source>
          <target state="translated">엔진의 키에 대한 참조가 가능합니다. Erlang 문자열 또는 바이너리 여야하며로드 된 엔진에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b0f536aaf11d6a845928df04b25b502dda74aa22" translate="yes" xml:space="preserve">
          <source>a set of modules specified with a wildcards, e.g. &lt;code&gt;'file*'&lt;/code&gt;</source>
          <target state="translated">와일드 카드로 지정된 모듈 세트 (예 : &lt;code&gt;'file*'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2142723e842ef520a7459b07b3cc5f339a0aa9ea" translate="yes" xml:space="preserve">
          <source>a simple and extensible model for transaction handling and consistency checking of set-requests</source>
          <target state="translated">트랜잭션 처리 및 세트 요청의 일관성 검사를위한 간단하고 확장 가능한 모델</target>
        </trans-unit>
        <trans-unit id="38f6085046e882c0a7a04cd899fe5a545baf84b3" translate="yes" xml:space="preserve">
          <source>a wildcard indicating all modules in current directory, i.e. &lt;code&gt;'*'&lt;/code&gt;</source>
          <target state="translated">현재 디렉토리의 모든 모듈을 나타내는 와일드 카드, 즉 &lt;code&gt;'*'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8b64c78e460148bffaf38c45ea356ef93872bfc" translate="yes" xml:space="preserve">
          <source>a_conf</source>
          <target state="translated">a_conf</target>
        </trans-unit>
        <trans-unit id="c7b8738431983fe29472fb70a8178a2b46e97bbb" translate="yes" xml:space="preserve">
          <source>a_discovery_handler</source>
          <target state="translated">a_discovery_handler</target>
        </trans-unit>
        <trans-unit id="93100c315fb6a4a680b80c6ef74e3b42901b4ef6" translate="yes" xml:space="preserve">
          <source>a_error</source>
          <target state="translated">a_error</target>
        </trans-unit>
        <trans-unit id="91cdbf281b85512304d2e4aa00cc84b0a7116cc8" translate="yes" xml:space="preserve">
          <source>a_error_io</source>
          <target state="translated">a_error_io</target>
        </trans-unit>
        <trans-unit id="a9a69b4ef7c8a631b988528c71a8fb229b7342ab" translate="yes" xml:space="preserve">
          <source>a_error_logger</source>
          <target state="translated">a_error_logger</target>
        </trans-unit>
        <trans-unit id="d58660a063e19d1e165103417ccafc244fe6c4fa" translate="yes" xml:space="preserve">
          <source>a_error_report</source>
          <target state="translated">a_error_report</target>
        </trans-unit>
        <trans-unit id="15d1631bb10bca396a6313726844ca91b666c395" translate="yes" xml:space="preserve">
          <source>a_function(Tuples) -&amp;gt; Function</source>
          <target state="translated">a_function (Tuples)-&amp;gt; 함수</target>
        </trans-unit>
        <trans-unit id="90ae25b7a163dfe99700824480bc8489041602ee" translate="yes" xml:space="preserve">
          <source>a_function(Tuples, Type) -&amp;gt; Function</source>
          <target state="translated">a_function (Tuples, Type)-&amp;gt; 기능</target>
        </trans-unit>
        <trans-unit id="6c78c23fcc9749492f0e95659d009aacbd0b549b" translate="yes" xml:space="preserve">
          <source>a_local_db</source>
          <target state="translated">a_local_db</target>
        </trans-unit>
        <trans-unit id="4d9fa8f6f06a58c228ab59428061a559afd4d349" translate="yes" xml:space="preserve">
          <source>a_mib_data</source>
          <target state="translated">a_mib_data</target>
        </trans-unit>
        <trans-unit id="b98e8d4d40c0f85d0e5453795eac17c1117970c5" translate="yes" xml:space="preserve">
          <source>a_mib_storage</source>
          <target state="translated">a_mib_storage</target>
        </trans-unit>
        <trans-unit id="33fb33f4be736b0342549eb4b0f40a121541761c" translate="yes" xml:space="preserve">
          <source>a_network_interface</source>
          <target state="translated">a_network_interface</target>
        </trans-unit>
        <trans-unit id="c89366d95a71167b5f2acc9361247e07b3d68c83" translate="yes" xml:space="preserve">
          <source>a_network_interface_filter</source>
          <target state="translated">a_network_interface_filter</target>
        </trans-unit>
        <trans-unit id="965e9121d01780b225ad12e277a002a60a1deb93" translate="yes" xml:space="preserve">
          <source>a_notification_delivery_info_receiver</source>
          <target state="translated">a_notification_delivery_info_receiver</target>
        </trans-unit>
        <trans-unit id="e470655cfa14cf813f61bb23d74e82172ceb0adb" translate="yes" xml:space="preserve">
          <source>a_notification_filter</source>
          <target state="translated">a_notification_filter</target>
        </trans-unit>
        <trans-unit id="38858de9533084e156dfb13fbf7c902544855905" translate="yes" xml:space="preserve">
          <source>a_supervisor</source>
          <target state="translated">a_supervisor</target>
        </trans-unit>
        <trans-unit id="49b2bcc09405df13855e7497804d2f4d6b1694b9" translate="yes" xml:space="preserve">
          <source>abcast(Name, Msg) -&amp;gt; abcast</source>
          <target state="translated">abcast (이름, 메시지)-&amp;gt; abcast</target>
        </trans-unit>
        <trans-unit id="2635da48392751f2fcd42d1a6423fda958353f98" translate="yes" xml:space="preserve">
          <source>abcast(Nodes, Name, Msg) -&amp;gt; abcast</source>
          <target state="translated">abcast (노드, 이름, 메시지)-&amp;gt; abcast</target>
        </trans-unit>
        <trans-unit id="09e9564e661cbe8ce66fe209e78ec306eabd9752" translate="yes" xml:space="preserve">
          <source>abort(Socket, Assoc) -&amp;gt; ok | {error, &lt;code&gt;&lt;a href=&quot;inet#type-posix&quot;&gt;inet:posix()&lt;/a&gt;&lt;/code&gt;}</source>
          <target state="translated">중단 (소켓, Assoc)-&amp;gt; 확인 | {오류, &lt;code&gt;&lt;a href=&quot;inet#type-posix&quot;&gt;inet:posix()&lt;/a&gt;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="c3c8890721b3c655c531f48de57de28fdc6630a5" translate="yes" xml:space="preserve">
          <source>abs(Float) -&amp;gt; float()</source>
          <target state="translated">abs (플로트)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="cf11c8b1d7379471b7d904cd217e8ce582257a2e" translate="yes" xml:space="preserve">
          <source>abs(Int) -&amp;gt; integer() &amp;gt;= 0</source>
          <target state="translated">abs (Int)-&amp;gt; 정수 ()&amp;gt; = 0</target>
        </trans-unit>
        <trans-unit id="4ae90431e45cb5bb0df1f957e38644b03ceaca91" translate="yes" xml:space="preserve">
          <source>absname(Filename) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">absname (파일 이름)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dadb80572d787a2a2876e8d9bdff30e554ed4e1" translate="yes" xml:space="preserve">
          <source>absname(Filename, Dir) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">absname (파일 이름, 디렉터리)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0caa322bfeb0dc87a2f34fec852074656296ce2" translate="yes" xml:space="preserve">
          <source>absname_join(Dir, Filename) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">absname_join (Dir, Filename)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="532a2994137354b8940205950971da0a8bd9b1a6" translate="yes" xml:space="preserve">
          <source>abstract(Data) -&amp;gt; AbsTerm</source>
          <target state="translated">초록 (데이터)-&amp;gt; AbsTerm</target>
        </trans-unit>
        <trans-unit id="6558389c79dfad53c8f95ec9a11e7d158122c8e3" translate="yes" xml:space="preserve">
          <source>abstract(Data, Options) -&amp;gt; AbsTerm</source>
          <target state="translated">초록 (데이터, 옵션)-&amp;gt; AbsTerm</target>
        </trans-unit>
        <trans-unit id="6f744acd95bd2bf36b1388a10744a694c3d9d9fa" translate="yes" xml:space="preserve">
          <source>accept(ListenSocket) -&amp;gt; {ok, Socket} | {error, Reason}</source>
          <target state="translated">accept (ListenSocket)-&amp;gt; {ok, Socket} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="7459bc4b9c5cdae9838af1a0697e470d695a1761" translate="yes" xml:space="preserve">
          <source>accept(ListenSocket, Timeout) -&amp;gt; {ok, Socket} | {error, Reason}</source>
          <target state="translated">accept (ListenSocket, Timeout)-&amp;gt; {ok, Socket} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="9f231959406861cc11841f428e5c83cf8ebc7abd" translate="yes" xml:space="preserve">
          <source>access control</source>
          <target state="translated">액세스 제어</target>
        </trans-unit>
        <trans-unit id="48be7659e77f020ad29782ad8c3ca981c8efca50" translate="yes" xml:space="preserve">
          <source>accessible_logs() -&amp;gt; {[LocalLog], [DistributedLog]}</source>
          <target state="translated">access_logs ()-&amp;gt; {[LocalLog], [DistributedLog]}</target>
        </trans-unit>
        <trans-unit id="35fba5bc784d45ba80fc856041cec697067dead0" translate="yes" xml:space="preserve">
          <source>acos(X) -&amp;gt; float()</source>
          <target state="translated">acos (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="1ddb6bfe54948f1f86d652c905651fc94ff04b0d" translate="yes" xml:space="preserve">
          <source>acosh(X) -&amp;gt; float()</source>
          <target state="translated">acosh (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="6218de7b88db2b268c25eec6e0b07eafa450cabf" translate="yes" xml:space="preserve">
          <source>action must be taken immediately</source>
          <target state="translated">즉시 조치를 취해야합니다</target>
        </trans-unit>
        <trans-unit id="e394f08f2e8d57232cd2ae1777a3230db3bf9ec4" translate="yes" xml:space="preserve">
          <source>action(Client, Action) -&amp;gt; Result</source>
          <target state="translated">액션 (클라이언트, 액션)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="3bb1bdbfd67ce20857fa7c017e6f6426a3633f0f" translate="yes" xml:space="preserve">
          <source>action(Client, Action, Timeout) -&amp;gt; Result</source>
          <target state="translated">액션 (클라이언트, 액션, 타임 아웃)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="c4eb246cd0b6bce10dc9b716021941ad855f1ca9" translate="yes" xml:space="preserve">
          <source>active_filter - collector.</source>
          <target state="translated">active_filter-수집기.</target>
        </trans-unit>
        <trans-unit id="4615c92e5c305c827a68665438ef70606004cff6" translate="yes" xml:space="preserve">
          <source>actors - [&quot;UNKNOWN&quot;].</source>
          <target state="translated">배우-[ &quot;알 수 없음&quot;].</target>
        </trans-unit>
        <trans-unit id="6576cc357b960d4b0c83d38a9e07d2d605de6677" translate="yes" xml:space="preserve">
          <source>adaption of legacy equipment</source>
          <target state="translated">레거시 장비의 적응</target>
        </trans-unit>
        <trans-unit id="4ea2abb73535206ef92d517cb876b6300f152df8" translate="yes" xml:space="preserve">
          <source>add(Element, Set1) -&amp;gt; Set2</source>
          <target state="translated">add (Element, Set1)-&amp;gt; Set2</target>
        </trans-unit>
        <trans-unit id="e7670b41b68f186df0e13666cf646588f19eb634" translate="yes" xml:space="preserve">
          <source>add_binding(Name, Value, BindingStruct) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">add_binding (이름, 값, BindingStruct)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3678a7f18b0a89514fe10fe9362d9d4535110c" translate="yes" xml:space="preserve">
          <source>add_edge(G, E, V1, V2, Label) -&amp;gt;</source>
          <target state="translated">add_edge (G, E, V1, V2, 라벨)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d1ec2a372a413447ea97d64f426b1b39de3ff9cf" translate="yes" xml:space="preserve">
          <source>add_edge(G, V1, V2) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-edge&quot;&gt;edge()&lt;/a&gt;&lt;/code&gt; | {error, add_edge_err_rsn()}</source>
          <target state="translated">add_edge (G, V1, V2)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-edge&quot;&gt;edge()&lt;/a&gt;&lt;/code&gt; | {오류, add_edge_err_rsn ()}</target>
        </trans-unit>
        <trans-unit id="b3400458091cf48e0059fd116ba45d3087b097dc" translate="yes" xml:space="preserve">
          <source>add_edge(G, V1, V2, Label) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-edge&quot;&gt;edge()&lt;/a&gt;&lt;/code&gt; | {error, add_edge_err_rsn()}</source>
          <target state="translated">add_edge (G, V1, V2, 레이블)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-edge&quot;&gt;edge()&lt;/a&gt;&lt;/code&gt; | {오류, add_edge_err_rsn ()}</target>
        </trans-unit>
        <trans-unit id="520109a15ec095a2d9cde3be2dc14cfdcfdc1264" translate="yes" xml:space="preserve">
          <source>add_element(Element, Ordset1) -&amp;gt; Ordset2</source>
          <target state="translated">add_element (요소, Ordset1)-&amp;gt; Ordset2</target>
        </trans-unit>
        <trans-unit id="2f2b3fb1df1f53380cfed1136cf60fddd69e4719" translate="yes" xml:space="preserve">
          <source>add_element(Element, Set1) -&amp;gt; Set2</source>
          <target state="translated">add_element (요소, Set1)-&amp;gt; Set2</target>
        </trans-unit>
        <trans-unit id="87a29e323bc1897e8be4ff18e6d34334075045cf" translate="yes" xml:space="preserve">
          <source>add_handler(HandlerId, Module, Config) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">add_handler (HandlerId, 모듈, 구성)-&amp;gt; ok | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="0d5ba58c0fad9b0a1d5a381557c1515d28ba9802" translate="yes" xml:space="preserve">
          <source>add_handler_filter(HandlerId, FilterId, Filter) -&amp;gt;</source>
          <target state="translated">add_handler_filter (HandlerId, FilterId, 필터)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fa5e7b0fea542972df9d4c2bd6c67c59b0465cff" translate="yes" xml:space="preserve">
          <source>add_handlers(Application) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">add_handlers (Application)-&amp;gt; 확인 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="62f2cab368c614ca8d746ffcd7dc56d70c13fa37" translate="yes" xml:space="preserve">
          <source>add_handlers(HandlerConfig) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">add_handlers (HandlerConfig)-&amp;gt; 확인 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="f23261944662c692d5bb80b52bcc2021c3e5a8c0" translate="yes" xml:space="preserve">
          <source>add_path(Dir) -&amp;gt; add_path_ret()</source>
          <target state="translated">add_path (Dir)-&amp;gt; add_path_ret ()</target>
        </trans-unit>
        <trans-unit id="2be842d431a9d86c5d96e60664cacb61f61e0a93" translate="yes" xml:space="preserve">
          <source>add_patha(Dir) -&amp;gt; add_path_ret()</source>
          <target state="translated">add_patha (Dir)-&amp;gt; add_path_ret ()</target>
        </trans-unit>
        <trans-unit id="ae26e9dbabe45af85669f9252e4f17339825692f" translate="yes" xml:space="preserve">
          <source>add_paths(Dirs) -&amp;gt; ok</source>
          <target state="translated">add_paths (Dirs)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="a989d2b4d60c99c25823c188d803b4f82e3bf36f" translate="yes" xml:space="preserve">
          <source>add_pathsa(Dirs) -&amp;gt; ok</source>
          <target state="translated">add_pathsa (Dirs)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="0c35ea2dbcb9fa9aa6ce31b9d307c09bbdf6def6" translate="yes" xml:space="preserve">
          <source>add_pathsz(Dirs) -&amp;gt; ok</source>
          <target state="translated">add_pathsz (Dirs)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="2e0ce42350675083063f18cce7bd9049c7e38f9d" translate="yes" xml:space="preserve">
          <source>add_pathz(Dir) -&amp;gt; add_path_ret()</source>
          <target state="translated">add_pathz (Dir)-&amp;gt; add_path_ret ()</target>
        </trans-unit>
        <trans-unit id="ee9d98e37a8b9c161685fea136a45b92224e29a0" translate="yes" xml:space="preserve">
          <source>add_predefined_functions(Forms) -&amp;gt; UpdatedForms</source>
          <target state="translated">add_predefined_functions (양식)-&amp;gt; UpdatedForms</target>
        </trans-unit>
        <trans-unit id="7bc1b31fc59f768dcba6d6bd411ae48685b68b5d" translate="yes" xml:space="preserve">
          <source>add_primary_filter(FilterId, Filter) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">add_primary_filter (FilterId, Filter)-&amp;gt; 확인 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="39dc9598bdd4ada4f624d8a7d464fc2d4ce27b58" translate="yes" xml:space="preserve">
          <source>add_report_handler(Handler) -&amp;gt; any()</source>
          <target state="translated">add_report_handler (Handler)-&amp;gt; any ()</target>
        </trans-unit>
        <trans-unit id="cec820a5714d57bdee8e6697687e51e5b2b8a644" translate="yes" xml:space="preserve">
          <source>add_report_handler(Handler, Args) -&amp;gt; Result</source>
          <target state="translated">add_report_handler (Handler, Args)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="a2ed2e0d7b9fccc6df085a54a049cf086b9e465c" translate="yes" xml:space="preserve">
          <source>add_slave(Slave) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">add_slave (Slave)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="01168eb23addf2838560909bef241c0ed5c7956c" translate="yes" xml:space="preserve">
          <source>add_vertex(G) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">add_vertex (G)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94e175a3210d4edf403441f0831e94cf9e1f2f83" translate="yes" xml:space="preserve">
          <source>add_vertex(G, V) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">add_vertex (G, V)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bc1cc55319fe45c237035802a9c25d46cda395c" translate="yes" xml:space="preserve">
          <source>add_vertex(G, V, Label) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">add_vertex (G, V, Label)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-vertex&quot;&gt;vertex()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cde5dd472003faf1e7928417ca9aaa15af6ca28" translate="yes" xml:space="preserve">
          <source>address_please(Name, Host, AddressFamily) -&amp;gt;</source>
          <target state="translated">address_please (이름, 호스트, 주소 패밀리)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e1c203fab2eb01eaddc506ebbf05b11bd8ee3314" translate="yes" xml:space="preserve">
          <source>adler32(Z, Data) -&amp;gt; CheckSum</source>
          <target state="translated">adler32 (Z, 데이터)-&amp;gt; CheckSum</target>
        </trans-unit>
        <trans-unit id="3010be9abd4e9e4f1ecc88483a5a41b8715785ab" translate="yes" xml:space="preserve">
          <source>adler32(Z, PrevAdler, Data) -&amp;gt; CheckSum</source>
          <target state="translated">adler32 (Z, PrevAdler, Data)-&amp;gt; CheckSum</target>
        </trans-unit>
        <trans-unit id="cee36dab124305111bb43143f8ae42ab4996ca52" translate="yes" xml:space="preserve">
          <source>adler32_combine(Z, Adler1, Adler2, Size2) -&amp;gt; Adler</source>
          <target state="translated">adler32_combine (Z, Adler1, Adler2, Size2)-&amp;gt; 아들러</target>
        </trans-unit>
        <trans-unit id="ef820fbff8a2936b677933f9e0b8e10d95885a16" translate="yes" xml:space="preserve">
          <source>advise(IoDevice, Offset, Length, Advise) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">조언 (IoDevice, 오프셋, 길이, 조언)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="22c354cca6642d17574452dcfad93f851b24844c" translate="yes" xml:space="preserve">
          <source>agent/2, agent/3</source>
          <target state="translated">요원 / 2, 요원 / 3</target>
        </trans-unit>
        <trans-unit id="e6eae4997a31e489ef041df5587d3ef4adc39fe4" translate="yes" xml:space="preserve">
          <source>alarm_handler</source>
          <target state="translated">alarm_handler</target>
        </trans-unit>
        <trans-unit id="8f1dba76b561684930a25a984046b3b4149785ca" translate="yes" xml:space="preserve">
          <source>alert</source>
          <target state="translated">alert</target>
        </trans-unit>
        <trans-unit id="a9957d965ac5d06bae0744f6022b4f0ca588006b" translate="yes" xml:space="preserve">
          <source>all of the matched subject is captured, as well as the captured substrings:</source>
          <target state="translated">일치하는 모든 주제와 캡처 된 하위 문자열이 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="864e8b3eb2304ca23a7d18d8972363d24eac0cf9" translate="yes" xml:space="preserve">
          <source>all() -&amp;gt; [&lt;code&gt;&lt;a href=&quot;#type-tab_name&quot;&gt;tab_name()&lt;/a&gt;&lt;/code&gt;]</source>
          <target state="translated">all ()-&amp;gt; [ &lt;code&gt;&lt;a href=&quot;#type-tab_name&quot;&gt;tab_name()&lt;/a&gt;&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="f540653e3159efabb2a32bc0522b5fd2ab1ef283" translate="yes" xml:space="preserve">
          <source>all() -&amp;gt; [Tab]</source>
          <target state="translated">all ()-&amp;gt; [탭]</target>
        </trans-unit>
        <trans-unit id="cd7fb59dea50d667b37c820c0721a759d6368257" translate="yes" xml:space="preserve">
          <source>all(Pred, List) -&amp;gt; boolean()</source>
          <target state="translated">all (Pred, List)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="013111e46b6bc8d4cf365655d47bd8f012ed4da4" translate="yes" xml:space="preserve">
          <source>all_chunks(File :: &lt;code&gt;&lt;a href=&quot;#type-beam&quot;&gt;beam()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">all_chunks (파일 :: &lt;code&gt;&lt;a href=&quot;#type-beam&quot;&gt;beam()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ed8099cee729b1e25df63173ad72ff29f7628701" translate="yes" xml:space="preserve">
          <source>all_loaded() -&amp;gt; [{Module, Loaded}]</source>
          <target state="translated">all_loaded ()-&amp;gt; [{모듈,로드 된}]</target>
        </trans-unit>
        <trans-unit id="265de813a6c960a6f9ad0f7fa192e948a567684d" translate="yes" xml:space="preserve">
          <source>allocate(File, Offset, Length) -&amp;gt; ok | {error, &lt;code&gt;&lt;a href=&quot;#type-posix&quot;&gt;posix()&lt;/a&gt;&lt;/code&gt;}</source>
          <target state="translated">assign (파일, 오프셋, 길이)-&amp;gt; ok | {오류, &lt;code&gt;&lt;a href=&quot;#type-posix&quot;&gt;posix()&lt;/a&gt;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="e1b292e4b425c6abd7984973b874e7320b69e75c" translate="yes" xml:space="preserve">
          <source>allocations() -&amp;gt; {ok, Result} | {error, Reason}</source>
          <target state="translated">할당 ()-&amp;gt; {ok, Result} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="9b58e1de9a88d7f5893c209e77fc394d05c88fef" translate="yes" xml:space="preserve">
          <source>allocations(Options) -&amp;gt; {ok, Result} | {error, Reason}</source>
          <target state="translated">할당 (옵션)-&amp;gt; {ok, Result} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="2d02b2c6b5a98ba505a2a2fcd003460b7b6a904e" translate="yes" xml:space="preserve">
          <source>allow(Nodes) -&amp;gt; ok | error</source>
          <target state="translated">allow (Nodes)-&amp;gt; 확인 | 오류</target>
        </trans-unit>
        <trans-unit id="65ec21073e5df85f4cd2d347361fd4bcb869132c" translate="yes" xml:space="preserve">
          <source>alog(Log, Term) -&amp;gt; notify_ret()</source>
          <target state="translated">alog (로그, 용어)-&amp;gt; notify_ret ()</target>
        </trans-unit>
        <trans-unit id="e014ae0ef6b7946a6d70ba6d9e45669ea868563a" translate="yes" xml:space="preserve">
          <source>alog_terms(Log, TermList) -&amp;gt; notify_ret()</source>
          <target state="translated">alog_terms (로그, TermList)-&amp;gt; notify_ret ()</target>
        </trans-unit>
        <trans-unit id="1c8519a743ba01d2496091da12f2feb9a9d51b37" translate="yes" xml:space="preserve">
          <source>already cancelled</source>
          <target state="translated">이미 취소</target>
        </trans-unit>
        <trans-unit id="d431a6acd8a5a35fc2ba1662a48f31a4a4c97b7e" translate="yes" xml:space="preserve">
          <source>already triggered</source>
          <target state="translated">이미 트리거</target>
        </trans-unit>
        <trans-unit id="fad1be4ebf56132018a4efb30adc2a5b336148fb" translate="yes" xml:space="preserve">
          <source>alternatively:</source>
          <target state="translated">alternatively:</target>
        </trans-unit>
        <trans-unit id="2fdac3c4a49bed868038fdabc46d931d0bd0436e" translate="yes" xml:space="preserve">
          <source>an Engine is loaded, see the chapter on &lt;code&gt;Engine Load&lt;/code&gt; or the &lt;code&gt;Reference Manual&lt;/code&gt;</source>
          <target state="translated">엔진이로드 된 경우 &lt;code&gt;Engine Load&lt;/code&gt; 장 또는 &lt;code&gt;Reference Manual&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="781dc5e7288030786fc67dccaa94d77c5f4521e6" translate="yes" xml:space="preserve">
          <source>an Erlang map is constructed with the Engine reference, the key reference and possibly a key passphrase if needed by the Engine. See the &lt;code&gt;Reference Manual&lt;/code&gt; for details of the map.</source>
          <target state="translated">Erlang 맵은 엔진 참조, 키 참조 및 엔진에서 필요한 경우 키 암호로 구성됩니다. 맵에 대한 자세한 내용은 &lt;code&gt;Reference Manual&lt;/code&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3558d78e025d73eec1204da3a205506c6a34cdf8" translate="yes" xml:space="preserve">
          <source>an include file has been modified since the source file was last compiled.</source>
          <target state="translated">소스 파일이 마지막으로 컴파일 된 이후 포함 파일이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="a2e7f10c2cc920d2e5cd26d567b470c641505d9d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Domain&lt;/code&gt; differs from &lt;code&gt;MatchDomain&lt;/code&gt;, or if there is no domain field in metadata.</source>
          <target state="translated">및 &lt;code&gt;Domain&lt;/code&gt; 상이 &lt;code&gt;MatchDomain&lt;/code&gt; 또는 메타 데이터에는 도메인 필드가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="23f0594083a5da8b10e8a2ab26298e8675aa6721" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Domain&lt;/code&gt; is equal to &lt;code&gt;MatchDomain&lt;/code&gt;.</source>
          <target state="translated">및 &lt;code&gt;Domain&lt;/code&gt; 같다 &lt;code&gt;MatchDomain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5651ee4ec1efdba8d30f06606338f7dbc9b0a3d7" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Domain&lt;/code&gt; is equal to or a sub-domain of &lt;code&gt;MatchDomain&lt;/code&gt;, that is, if &lt;code&gt;MatchDomain&lt;/code&gt; is a prefix of &lt;code&gt;Domain&lt;/code&gt;.</source>
          <target state="translated">및 &lt;code&gt;Domain&lt;/code&gt; 의 서브 도메인 또는 같은지 &lt;code&gt;MatchDomain&lt;/code&gt; 경우이다 &lt;code&gt;MatchDomain&lt;/code&gt; 는 접두사이다 &lt;code&gt;Domain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c37d2503a3ba7f64eff085561405608469c092d1" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Domain&lt;/code&gt; is equal to or a super-domain of &lt;code&gt;MatchDomain&lt;/code&gt;, that is, if &lt;code&gt;Domain&lt;/code&gt; is a prefix of &lt;code&gt;MatchDomain&lt;/code&gt;.</source>
          <target state="translated">및 &lt;code&gt;Domain&lt;/code&gt; 의 수퍼 도메인 또는 같은지 &lt;code&gt;MatchDomain&lt;/code&gt; 경우이고, &lt;code&gt;Domain&lt;/code&gt; 의 접두사 &lt;code&gt;MatchDomain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85650a2303153176b2d32ef0359aa6966910b56d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;P&lt;/code&gt; is a tuple, the &lt;code&gt;qlc&lt;/code&gt; module analyzes &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; in compile time to find positions of tuple &lt;code&gt;P&lt;/code&gt; that are tested for equality to constants. If such a position at runtime turns out to be the key position, the lookup function can be used, otherwise all objects of the table must be traversed. The info function &lt;code&gt;InfoFun&lt;/code&gt; returns the key position. There can be indexed positions as well, also returned by the info function. An index is an extra table that makes lookup on some position fast. Mnesia maintains indexes upon request, and introduces so called secondary keys. The &lt;code&gt;qlc&lt;/code&gt; module prefers to look up objects using the key before secondary keys regardless of the number of constants to look up.</source>
          <target state="translated">그리고 &lt;code&gt;P&lt;/code&gt; 는 튜플의입니다 &lt;code&gt;qlc&lt;/code&gt; 모듈 분석 &lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;F&lt;/code&gt; 튜플의 위치를 찾을 수 컴파일 시간에 &lt;code&gt;P&lt;/code&gt; 상수에 어떤지를 테스트합니다. 런타임시 이러한 위치가 핵심 위치로 판명되면 조회 기능을 사용할 수 있습니다. 그렇지 않으면 테이블의 모든 오브젝트를 순회해야합니다. 정보 함수 &lt;code&gt;InfoFun&lt;/code&gt; 은 키 위치를 반환합니다. info 함수에 의해 리턴 된 색인 위치도있을 수 있습니다. 인덱스는 특정 위치를 빠르게 조회 할 수있는 추가 테이블입니다. Mnesia는 요청에 따라 인덱스를 유지 관리하고 소위 보조 키를 도입합니다. &lt;code&gt;qlc&lt;/code&gt; 모듈은 조회 할 상수의 수에 관계없이 2 차 키보다 먼저 키를 사용하여 오브젝트를 찾는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="a092140407d1d0bdcf6c0a8081368ead5e8d13e1" translate="yes" xml:space="preserve">
          <source>and after a while Erlang/OTP-21 will have been installed in &lt;code&gt;C:\Program Files\erl10.0\&lt;/code&gt;, with shortcuts in the menu etc.</source>
          <target state="translated">그리고 잠시 후 Erlang / OTP-21이 &lt;code&gt;C:\Program Files\erl10.0\&lt;/code&gt; 에 설치되고 메뉴 등의 바로 가기 가 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c09e2e9338eecd9d58d7ec35b3de798f274a0d1" translate="yes" xml:space="preserve">
          <source>and finally, &lt;code&gt;&quot;when _@__@Guard -&amp;gt;&quot;&lt;/code&gt; will match any clause, binding &lt;code&gt;Guard&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; if the guard is empty and to &lt;code&gt;[Disjunction]&lt;/code&gt; otherwise</source>
          <target state="translated">마지막으로 &lt;code&gt;&quot;when _@__@Guard -&amp;gt;&quot;&lt;/code&gt; 는 가드가 비어있는 경우 &lt;code&gt;Guard&lt;/code&gt; 를 &lt;code&gt;[]&lt;/code&gt; 에 바인딩 하고 그렇지 않으면 &lt;code&gt;[Disjunction]&lt;/code&gt; 에 바인딩하는 임의의 절과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b7ebb6f00f745a17b7a50b25f230dae062785e2b" translate="yes" xml:space="preserve">
          <source>and finaly what the SSH app implements</source>
          <target state="translated">마지막으로 SSH 앱이 구현하는 것</target>
        </trans-unit>
        <trans-unit id="64f96460c8f9bfc4a2fdf3a7dd31c2ba9418a902" translate="yes" xml:space="preserve">
          <source>and motorcycles.dtd looks like:</source>
          <target state="translated">motorcycles.dtd는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d491e274919486aef4d4bbdb353bb3e22c7d8ca" translate="yes" xml:space="preserve">
          <source>and sometimes</source>
          <target state="translated">그리고 때로는</target>
        </trans-unit>
        <trans-unit id="46fd59de2909ece56f52284188694c3a52dbcbe7" translate="yes" xml:space="preserve">
          <source>and that:</source>
          <target state="translated">그리고 그것은 :</target>
        </trans-unit>
        <trans-unit id="75c005f32e8885c088986480f71cba8346ce540d" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;eq&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="08366225fe44bcd5d81c51c77de9b9231dab0b84" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;gt&lt;/code&gt; or &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;gt&lt;/code&gt; 또는 &lt;code&gt;eq&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c29b958aebaf91eaa4b4fc0e383d015e20d4a631" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;gt&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;gt&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="004da623dc23abbc77bdc9ccae266580dab903af" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;lt&lt;/code&gt; or &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;lt&lt;/code&gt; 또는 &lt;code&gt;eq&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fafca81c05db8361dd5e261c3aaa8ec8c79d2de8" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;lt&lt;/code&gt; or &lt;code&gt;gt&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;lt&lt;/code&gt; 또는 &lt;code&gt;gt&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c27967e0d82144b5cd16de71839fe2cf85c0c165" translate="yes" xml:space="preserve">
          <source>and the compare function returns &lt;code&gt;lt&lt;/code&gt;.</source>
          <target state="translated">그리고 비교 함수는 &lt;code&gt;lt&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c1b700757b2c3a8a734178e043e69f30937c6fd6" translate="yes" xml:space="preserve">
          <source>and then make sure that every module of your application includes that header file. This means that you have a only a single place to modify in order to change the default setting for testing. To override the &lt;code&gt;NOTEST&lt;/code&gt; setting without modifying the code, you can define &lt;code&gt;TEST&lt;/code&gt; in a compiler option, like this:</source>
          <target state="translated">그런 다음 응용 프로그램의 모든 모듈에 해당 헤더 파일이 포함되어 있는지 확인하십시오. 이는 테스트를위한 기본 설정을 변경하기 위해 수정할 장소가 하나뿐임을 의미합니다. 코드를 수정하지 않고 &lt;code&gt;NOTEST&lt;/code&gt; 설정 을 재정의하려면 다음 과 같이 컴파일러 옵션에서 &lt;code&gt;TEST&lt;/code&gt; 를 정의 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7d0ecfa1634b0abb29975802f12a9ca3ec96e9f2" translate="yes" xml:space="preserve">
          <source>and there is no domain field in metadata. In this case &lt;code&gt;MatchDomain&lt;/code&gt; must be set to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">메타 데이터에 도메인 필드가 없습니다. 이 경우 &lt;code&gt;MatchDomain&lt;/code&gt; 을 &lt;code&gt;[]&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="15776e659486167076d3cb321fce2312d24fb803" translate="yes" xml:space="preserve">
          <source>and there must be spaces around &lt;code&gt;=&lt;/code&gt;. Macros can be used in the regular expressions of rules by writing &lt;code&gt;{NAME}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 주위에 공백이 있어야합니다 . &lt;code&gt;{NAME}&lt;/code&gt; 을 작성하여 규칙의 정규식에 매크로를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e07a5c56ecbb0097ee8073f245a7172ebf9eb4a" translate="yes" xml:space="preserve">
          <source>and to start</source>
          <target state="translated">그리고 시작</target>
        </trans-unit>
        <trans-unit id="36894c0e7fe357f11b9f44b6a70c4ab817c3a65b" translate="yes" xml:space="preserve">
          <source>and you also need to change the PATH environment variable to:</source>
          <target state="translated">또한 PATH 환경 변수를 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="7914f3693a7b7d05ec42de24054fef2cb7500c57" translate="yes" xml:space="preserve">
          <source>and, of course, also make sure that you place all test code that uses EUnit macros within &lt;code&gt;-ifdef(TEST)&lt;/code&gt; or &lt;code&gt;-ifdef(EUNIT)&lt;/code&gt; sections.</source>
          <target state="translated">물론 &lt;code&gt;-ifdef(TEST)&lt;/code&gt; 매크로를 사용하는 모든 테스트 코드를 -ifdef (TEST) 또는 &lt;code&gt;-ifdef(EUNIT)&lt;/code&gt; 섹션에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="03437c3d563b9905c8c35ef6b7a9b572fef4c3f9" translate="yes" xml:space="preserve">
          <source>andalso</source>
          <target state="translated">andalso</target>
        </trans-unit>
        <trans-unit id="578f286f6ab178c50892f36a4fad7b4aa9f05750" translate="yes" xml:space="preserve">
          <source>anno_from_term(Term) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-erl_parse_tree&quot;&gt;erl_parse_tree()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-form_info&quot;&gt;form_info()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">anno_from_term (Term)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-erl_parse_tree&quot;&gt;erl_parse_tree()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-form_info&quot;&gt;form_info()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e73f9bd1a9803a0012fc8a0fbebc486e9c9b3ac" translate="yes" xml:space="preserve">
          <source>anno_to_term(Abstr) -&amp;gt; term()</source>
          <target state="translated">anno_to_term (Abstr)-&amp;gt; 용어 ()</target>
        </trans-unit>
        <trans-unit id="8105e619777b3d59b78f84b33dbebce9658fbfae" translate="yes" xml:space="preserve">
          <source>any(Pred, List) -&amp;gt; boolean()</source>
          <target state="translated">any (Pred, List)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="d10841d2304b7b77bfc6054c2b2dc5bc853ae3c7" translate="yes" xml:space="preserve">
          <source>append(Key, Value, Dict1) -&amp;gt; Dict2</source>
          <target state="translated">추가 (키, 값, Dict1)-&amp;gt; Dict2</target>
        </trans-unit>
        <trans-unit id="d4bf5c0acbaedb45c0da8c81997293d60ada9894" translate="yes" xml:space="preserve">
          <source>append(Key, Value, Orddict1) -&amp;gt; Orddict2</source>
          <target state="translated">추가 (키, 값, Orddict1)-&amp;gt; Orddict2</target>
        </trans-unit>
        <trans-unit id="3c636072995a7d4159ff90be42115a100e5fa0d2" translate="yes" xml:space="preserve">
          <source>append(List1, List2) -&amp;gt; List3</source>
          <target state="translated">추가 (목록 1, 목록 2)-&amp;gt; 목록 3</target>
        </trans-unit>
        <trans-unit id="a5d4ff25be1367720e036d2617abcdc57bf54ef4" translate="yes" xml:space="preserve">
          <source>append(ListOfLists) -&amp;gt; List1</source>
          <target state="translated">append (ListOfLists)-&amp;gt; 목록 1</target>
        </trans-unit>
        <trans-unit id="fb98fd6d9fec894b59b8f6b3bdf27630de51b73b" translate="yes" xml:space="preserve">
          <source>append(QH1, QH2) -&amp;gt; QH3</source>
          <target state="translated">추가 (QH1, QH2)-&amp;gt; QH3</target>
        </trans-unit>
        <trans-unit id="f4d993a4882c620993a920f306787cd3dd59b3f7" translate="yes" xml:space="preserve">
          <source>append(QHL) -&amp;gt; QH</source>
          <target state="translated">추가 (QHL)-&amp;gt; QH</target>
        </trans-unit>
        <trans-unit id="9b475dbe1473e86886a8b4cdfe418e8b3ea7b5f7" translate="yes" xml:space="preserve">
          <source>append_list(Key, ValList, Dict1) -&amp;gt; Dict2</source>
          <target state="translated">append_list (키, ValList, Dict1)-&amp;gt; Dict2</target>
        </trans-unit>
        <trans-unit id="b2d2d6942e878222f08a719555bc70b55954dc11" translate="yes" xml:space="preserve">
          <source>append_list(Key, ValList, Orddict1) -&amp;gt; Orddict2</source>
          <target state="translated">append_list (키, ValList, Orddict1)-&amp;gt; Orddict2</target>
        </trans-unit>
        <trans-unit id="2d10c6ee0dd4778c117e8c3682c178d579bd4a18" translate="yes" xml:space="preserve">
          <source>append_values(Key, ListIn) -&amp;gt; ListOut</source>
          <target state="translated">append_values ​​(Key, ListIn)-&amp;gt; ListOut</target>
        </trans-unit>
        <trans-unit id="d2005cc206ccbfdedf2be43a200cb050c538bdb5" translate="yes" xml:space="preserve">
          <source>application</source>
          <target state="translated">application</target>
        </trans-unit>
        <trans-unit id="568860282a1ec842e1ac6d1d30363015f3f2dde7" translate="yes" xml:space="preserve">
          <source>application annotated_type arity_qualifier atom</source>
          <target state="translated">응용 프로그램 annotated_type arity_qualifier atom</target>
        </trans-unit>
        <trans-unit id="1e1d067557b1043c2184a711f7cff2957fb839ce" translate="yes" xml:space="preserve">
          <source>apply(Fun, Args) -&amp;gt; term()</source>
          <target state="translated">적용 (Fun, Args)-&amp;gt; term ()</target>
        </trans-unit>
        <trans-unit id="5f87db34c6505c677d6c49a06f49220e952a09e1" translate="yes" xml:space="preserve">
          <source>apply(Module, Function, Args) -&amp;gt; term()</source>
          <target state="translated">apply (모듈, 함수, Args)-&amp;gt; term ()</target>
        </trans-unit>
        <trans-unit id="8b33142aa22a9284aef7e9d7ff3d6aa1896b4cd0" translate="yes" xml:space="preserve">
          <source>apply_after(Time, Module, Function, Arguments) -&amp;gt;</source>
          <target state="translated">apply_after (시간, 모듈, 함수, 인수)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="84107d7bb57b203ad953502281b775aef3287b48" translate="yes" xml:space="preserve">
          <source>apply_interval(Time, Module, Function, Arguments) -&amp;gt;</source>
          <target state="translated">apply_interval (시간, 모듈, 함수, 인수)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="54ef3c30ac7fb5592b321d71bbdff18ad945f17f" translate="yes" xml:space="preserve">
          <source>appup</source>
          <target state="translated">appup</target>
        </trans-unit>
        <trans-unit id="4697dcb9422d15abf18c225a945de46886104261" translate="yes" xml:space="preserve">
          <source>arborescence_root(Digraph) -&amp;gt; no | {yes, Root}</source>
          <target state="translated">arborescence_root (Digraph)-&amp;gt; 아니오 | {예, 루트}</target>
        </trans-unit>
        <trans-unit id="59ddf6722b9f0593289a296b4a403eb6c0b2a0ad" translate="yes" xml:space="preserve">
          <source>arith_op(OpName, Arity) -&amp;gt; boolean()</source>
          <target state="translated">arith_op (OpName, Arity)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="19edc1210777ba4d45049c29280d9cc5e1064c25" translate="yes" xml:space="preserve">
          <source>array</source>
          <target state="translated">array</target>
        </trans-unit>
        <trans-unit id="6fbd33b2aeb593002556cd75a61bc45f654e10b3" translate="yes" xml:space="preserve">
          <source>as returned by &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는</target>
        </trans-unit>
        <trans-unit id="042c62668e9a4ead6d9afb4138f6b2a8b3735800" translate="yes" xml:space="preserve">
          <source>as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which is also returned. This behavior differs from the default behavior of the split function in Perl, where empty strings at the end are by default removed. To get the &quot;trimming&quot; default behavior of Perl, specify &lt;code&gt;trim&lt;/code&gt; as an option:</source>
          <target state="translated">문자열 끝에서 &quot;g&quot;를 일치 시키면 빈 쉼표가 남게되므로 반환됩니다. 이 동작은 마지막에 빈 문자열이 기본적으로 제거되는 Perl 분할 기능의 기본 동작과 다릅니다. Perl의 &quot;트리밍&quot;기본 동작을 얻으려면 &lt;code&gt;trim&lt;/code&gt; 을 옵션으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="73688580af35401988ca63c730bbff475def44d3" translate="yes" xml:space="preserve">
          <source>as:</source>
          <target state="translated">as:</target>
        </trans-unit>
        <trans-unit id="e29e01a495de2aa0eeaf07aabfce1c8aadd72b63" translate="yes" xml:space="preserve">
          <source>asin(X) -&amp;gt; float()</source>
          <target state="translated">asin (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="81f51029f05bb19fa09635d29fc8e04062fc5a1a" translate="yes" xml:space="preserve">
          <source>asinh(X) -&amp;gt; float()</source>
          <target state="translated">asinh (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="9edf4240018976bf964cf31c1a24d34fde8d517d" translate="yes" xml:space="preserve">
          <source>asn1</source>
          <target state="translated">asn1</target>
        </trans-unit>
        <trans-unit id="a5c623fea2ecc95d7d78e4a2f7b1a6636e9e9561" translate="yes" xml:space="preserve">
          <source>asn1ct</source>
          <target state="translated">asn1ct</target>
        </trans-unit>
        <trans-unit id="77b583668f59664395679b42c2fc85de4fdce9bf" translate="yes" xml:space="preserve">
          <source>assigns the same value to &lt;code&gt;Y&lt;/code&gt; as this:</source>
          <target state="translated">&lt;code&gt;Y&lt;/code&gt; 와 동일한 값을 다음과 같이 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="38f344fad19df89790d8a548dab4cddfc73ab329" translate="yes" xml:space="preserve">
          <source>assigns the same value to &lt;code&gt;Z&lt;/code&gt; as this:</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; 와 동일한 값을 다음과 같이 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="69bfbbcd78b5bc5db0e0a7dcccaa794f9a824e51" translate="yes" xml:space="preserve">
          <source>async_call(Node, Module, Function, Args) -&amp;gt; Key</source>
          <target state="translated">async_call (노드, 모듈, 기능, Args)-&amp;gt; 키</target>
        </trans-unit>
        <trans-unit id="9e04f49c91b068f23107ab4ee13991d045937efc" translate="yes" xml:space="preserve">
          <source>at(Subject, Pos) -&amp;gt; byte()</source>
          <target state="translated">at (제목, Pos)-&amp;gt; 바이트 ()</target>
        </trans-unit>
        <trans-unit id="af47c5430e2e70631a4fcd2e5be37991ecd7370a" translate="yes" xml:space="preserve">
          <source>atan(X) -&amp;gt; float()</source>
          <target state="translated">atan (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="627c8fbaf02f5b457b741f6eebefcaf928e54a19" translate="yes" xml:space="preserve">
          <source>atan2(Y, X) -&amp;gt; float()</source>
          <target state="translated">atan2 (Y, X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="b813663879e58121083ad2009d43be9680e58057" translate="yes" xml:space="preserve">
          <source>atanh(X) -&amp;gt; float()</source>
          <target state="translated">atanh (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="bc158557e832bb320df845e44ae97cb1e13dab94" translate="yes" xml:space="preserve">
          <source>atom_to_binary(Atom, Encoding) -&amp;gt; binary()</source>
          <target state="translated">atom_to_binary (Atom, Encoding)-&amp;gt; 이진 ()</target>
        </trans-unit>
        <trans-unit id="bbebd8f662d346e33af0898064b3c45a418d6fa4" translate="yes" xml:space="preserve">
          <source>atom_to_list(Atom) -&amp;gt; string()</source>
          <target state="translated">atom_to_list (Atom)-&amp;gt; 문자열 ()</target>
        </trans-unit>
        <trans-unit id="8c997ae8c22f818e9d99a82e3f4ed9c818b5921c" translate="yes" xml:space="preserve">
          <source>atomic_load(Modules) -&amp;gt; ok | {error, [{Module, What}]}</source>
          <target state="translated">atomic_load (모듈)-&amp;gt; ok | {오류, [{모듈, 무엇}]}</target>
        </trans-unit>
        <trans-unit id="2ad7021968425c3d482967ef78871505f0fde340" translate="yes" xml:space="preserve">
          <source>attach(Node) -&amp;gt; already_attached | attached</source>
          <target state="translated">attach (Node)-&amp;gt; already_attached | 붙여진</target>
        </trans-unit>
        <trans-unit id="7440b3eb7a1c9fda6e0f30aee46bcd5756f9fbf3" translate="yes" xml:space="preserve">
          <source>attribute binary binary_field bitstring_type</source>
          <target state="translated">이진 binary_field bitstring_type 속성</target>
        </trans-unit>
        <trans-unit id="5269fe7c8b5a323cdee23ea6d236f5dde4c5ade6" translate="yes" xml:space="preserve">
          <source>attribute(Attribute) -&amp;gt; &lt;code&gt;&lt;a href=&quot;io_lib#type-chars&quot;&gt;io_lib:chars()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">속성 (속성)-&amp;gt; &lt;code&gt;&lt;a href=&quot;io_lib#type-chars&quot;&gt;io_lib:chars()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6ecd3f6f4e23adddd9500ef8ac9b9ce0b603262" translate="yes" xml:space="preserve">
          <source>attribute(Attribute, Options) -&amp;gt; &lt;code&gt;&lt;a href=&quot;io_lib#type-chars&quot;&gt;io_lib:chars()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">속성 (속성, 옵션)-&amp;gt; &lt;code&gt;&lt;a href=&quot;io_lib#type-chars&quot;&gt;io_lib:chars()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66a36e77fd002579809717841f998f4d21cd5913" translate="yes" xml:space="preserve">
          <source>auth</source>
          <target state="translated">auth</target>
        </trans-unit>
        <trans-unit id="176939638191d5a13935ccb90c0c8a70a5e30773" translate="yes" xml:space="preserve">
          <source>authentication</source>
          <target state="translated">authentication</target>
        </trans-unit>
        <trans-unit id="afcbbc0446e4d73184b39582e4989b409070433a" translate="yes" xml:space="preserve">
          <source>available() -&amp;gt; boolean()</source>
          <target state="translated">사용 가능 ()-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="3a56424474f8507b071c1802db5350b0d3930468" translate="yes" xml:space="preserve">
          <source>badValue</source>
          <target state="translated">badValue</target>
        </trans-unit>
        <trans-unit id="5fe93e4c0bcf90e54bcfd5dabd72f342eb374b22" translate="yes" xml:space="preserve">
          <source>balance(Set1) -&amp;gt; Set2</source>
          <target state="translated">저울 (Set1)-&amp;gt; Set2</target>
        </trans-unit>
        <trans-unit id="40831ed7e9e91cfff9b51a88adb7295f83bbf5df" translate="yes" xml:space="preserve">
          <source>balance(Tree1) -&amp;gt; Tree2</source>
          <target state="translated">균형 (나무 1)-&amp;gt; 나무 2</target>
        </trans-unit>
        <trans-unit id="40d92c6dc271a0615a75fb1dab3afa49f45a6835" translate="yes" xml:space="preserve">
          <source>balog(Log, Bytes) -&amp;gt; notify_ret()</source>
          <target state="translated">balog (로그, 바이트)-&amp;gt; notify_ret ()</target>
        </trans-unit>
        <trans-unit id="c46b99f318b76b18c90d1b2e4136a70ea3a3eb6e" translate="yes" xml:space="preserve">
          <source>balog_terms(Log, ByteList) -&amp;gt; notify_ret()</source>
          <target state="translated">balog_terms (로그, 바이트리스트)-&amp;gt; notify_ret ()</target>
        </trans-unit>
        <trans-unit id="2502deb44ba556abc83784f27250dcd7bbaebc0f" translate="yes" xml:space="preserve">
          <source>band</source>
          <target state="translated">band</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="2f59b6d8e4a0093e2cc2e3169190857078f78275" translate="yes" xml:space="preserve">
          <source>basedir(Type, Application) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">basedir (Type, Application)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5467c698883b77a34b1a469f2866b11d034710d0" translate="yes" xml:space="preserve">
          <source>basedir(Type, Application, Opts) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">basedir (Type, Application, Opts)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9aec39dfd77cd2f941d4b5b26ad4abdf2d7e4aa" translate="yes" xml:space="preserve">
          <source>basename(Filename) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">기본 이름 (파일 이름)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8297d7a9e0184bdf9d54df4b0623f8178dacee9" translate="yes" xml:space="preserve">
          <source>basename(Filename, Ext) -&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</source>
          <target state="translated">기본 이름 (파일 이름, Ext)-&amp;gt; &lt;code&gt;file:filename_all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2612c1d59e605c4aa626bc1ddc2ae7fb66f425f0" translate="yes" xml:space="preserve">
          <source>basic fault handling such as automatic type checking</source>
          <target state="translated">자동 유형 검사와 같은 기본 결함 처리</target>
        </trans-unit>
        <trans-unit id="5f5262763f739e7bfcc5b1bd3fdcd890d49574fc" translate="yes" xml:space="preserve">
          <source>bchunk(Log, Continuation) -&amp;gt; bchunk_ret()</source>
          <target state="translated">bchunk (로그, 계속)-&amp;gt; bchunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="e8f3ed1099245011c6ea627ef845b263b03472cf" translate="yes" xml:space="preserve">
          <source>bchunk(Log, Continuation, N) -&amp;gt; bchunk_ret()</source>
          <target state="translated">bchunk (로그, 계속, N)-&amp;gt; bchunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="bc974bf63d12f7fcc03212f1d3d2ec9c988b172a" translate="yes" xml:space="preserve">
          <source>bchunk(Name, Continuation) -&amp;gt;</source>
          <target state="translated">bchunk (이름, 계속)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5df635d31ba2bae170199b7b33e263c28d0828b" translate="yes" xml:space="preserve">
          <source>beam_lib</source>
          <target state="translated">beam_lib</target>
        </trans-unit>
        <trans-unit id="d807d11fc0d203e592513df0c4f1b29e4ac463e1" translate="yes" xml:space="preserve">
          <source>becomes in Erlang:</source>
          <target state="translated">Erlang이됩니다 :</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="37b477d71d4dff4e8be0781e55a37b73e266f5c2" translate="yes" xml:space="preserve">
          <source>ber bin</source>
          <target state="translated">베르 빈</target>
        </trans-unit>
        <trans-unit id="930b7c14f9c78481b6564d4b76ba739e01d1f5e3" translate="yes" xml:space="preserve">
          <source>ber bin [driver,native]</source>
          <target state="translated">베르 빈 [드라이버, 네이티브]</target>
        </trans-unit>
        <trans-unit id="e7e01863fb1068bce6b288e6a46af7d12f323b0c" translate="yes" xml:space="preserve">
          <source>ber bin [driver]</source>
          <target state="translated">버 빈 [드라이버]</target>
        </trans-unit>
        <trans-unit id="cc37ba75621c9f315651e9c54a653563d92c9691" translate="yes" xml:space="preserve">
          <source>ber bin [native]</source>
          <target state="translated">베르 빈 [네이티브]</target>
        </trans-unit>
        <trans-unit id="45a432b22b94f4a73c79ea415b91f5719888570e" translate="yes" xml:space="preserve">
          <source>bif(Name, Arity) -&amp;gt; boolean()</source>
          <target state="translated">bif (이름, Arity)-&amp;gt; boolean ()</target>
        </trans-unit>
        <trans-unit id="bbe359e237c1d61a5cef555d759fea80f99d7ef1" translate="yes" xml:space="preserve">
          <source>bin_to_list(Subject) -&amp;gt; [byte()]</source>
          <target state="translated">bin_to_list (제목)-&amp;gt; [바이트 ()]</target>
        </trans-unit>
        <trans-unit id="ddc11d9360688d7adda17dd499f2081340817864" translate="yes" xml:space="preserve">
          <source>bin_to_list(Subject, Pos, Len) -&amp;gt; [byte()]</source>
          <target state="translated">bin_to_list (제목, Pos, Len)-&amp;gt; [byte ()]</target>
        </trans-unit>
        <trans-unit id="26a4ec73f8515351e70b298ca1df987ef296e90c" translate="yes" xml:space="preserve">
          <source>bin_to_list(Subject, PosLen) -&amp;gt; [byte()]</source>
          <target state="translated">bin_to_list (제목, PosLen)-&amp;gt; [byte ()]</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="d3883335929a74767b5c892d136b104945ab0a00" translate="yes" xml:space="preserve">
          <source>binary_part(Subject, PosLen) -&amp;gt; binary()</source>
          <target state="translated">binary_part (제목, PosLen)-&amp;gt; binary ()</target>
        </trans-unit>
        <trans-unit id="daf1972817b954b7d4f843e8f1e167f58b772861" translate="yes" xml:space="preserve">
          <source>binary_part(Subject, Start, Length) -&amp;gt; binary()</source>
          <target state="translated">binary_part (제목, 시작, 길이)-&amp;gt; binary ()</target>
        </trans-unit>
        <trans-unit id="d32f1e77007bf94b60332fe66d737afa28eac134" translate="yes" xml:space="preserve">
          <source>binary_to_atom(Binary, Encoding) -&amp;gt; atom()</source>
          <target state="translated">binary_to_atom (이진, 인코딩)-&amp;gt; atom ()</target>
        </trans-unit>
        <trans-unit id="e84c827133b25fa86f287f81660f3e670345043b" translate="yes" xml:space="preserve">
          <source>binary_to_existing_atom(Binary, Encoding) -&amp;gt; atom()</source>
          <target state="translated">binary_to_existing_atom (이진, 인코딩)-&amp;gt; atom ()</target>
        </trans-unit>
        <trans-unit id="a5b3332c1669fab5819cf0e32147078f0ebc007e" translate="yes" xml:space="preserve">
          <source>binary_to_float(Binary) -&amp;gt; float()</source>
          <target state="translated">binary_to_float (바이너리)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="791f8901cafcc176519a514a6cba4dcc8267825f" translate="yes" xml:space="preserve">
          <source>binary_to_integer(Binary) -&amp;gt; integer()</source>
          <target state="translated">binary_to_integer (바이너리)-&amp;gt; 정수 ()</target>
        </trans-unit>
        <trans-unit id="1467eef026591937d74ea6b19564fce34d19044e" translate="yes" xml:space="preserve">
          <source>binary_to_integer(Binary, Base) -&amp;gt; integer()</source>
          <target state="translated">binary_to_integer (이진, 밑)-&amp;gt; 정수 ()</target>
        </trans-unit>
        <trans-unit id="aa0d55a1a4d394c99be7d7a0634585e2d0e3a5c8" translate="yes" xml:space="preserve">
          <source>binary_to_list(Binary) -&amp;gt; [byte()]</source>
          <target state="translated">binary_to_list (바이너리)-&amp;gt; [바이트 ()]</target>
        </trans-unit>
        <trans-unit id="074eb30a31005d6a4ebfa39a1586c91bb7277c66" translate="yes" xml:space="preserve">
          <source>binary_to_list(Binary, Start, Stop) -&amp;gt; [byte()]</source>
          <target state="translated">binary_to_list (이진, 시작, 중지)-&amp;gt; [byte ()]</target>
        </trans-unit>
        <trans-unit id="80e55f7d3cfd11d0e212f14b573ceef6f66e6738" translate="yes" xml:space="preserve">
          <source>binary_to_term(Binary) -&amp;gt; term()</source>
          <target state="translated">binary_to_term (이진)-&amp;gt; term ()</target>
        </trans-unit>
        <trans-unit id="2b795103f453e979aac26647d5cc073756bfe26b" translate="yes" xml:space="preserve">
          <source>binary_to_term(Binary, Opts) -&amp;gt; term() | {term(), Used}</source>
          <target state="translated">binary_to_term (이진, 옵션)-&amp;gt; term () | {term (), 사용}</target>
        </trans-unit>
        <trans-unit id="6e2e1571fd12a310ac375837b974d3a3fc53116c" translate="yes" xml:space="preserve">
          <source>binding(Name, BindingStruct) -&amp;gt; {value, &lt;code&gt;&lt;a href=&quot;#type-value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt;} | unbound</source>
          <target state="translated">binding (Name, BindingStruct)-&amp;gt; {값, &lt;code&gt;&lt;a href=&quot;#type-value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; } | 매여 있지 않은</target>
        </trans-unit>
        <trans-unit id="f6c04cbc8640694d31904425a2b68a98465a3b8e" translate="yes" xml:space="preserve">
          <source>bindings(BindingStruct :: &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-bindings&quot;&gt;bindings()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">바인딩 (BindingStruct :: &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-bindings&quot;&gt;bindings()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0203ff37fd8649acbb74b5d65f549140be91dc63" translate="yes" xml:space="preserve">
          <source>bit_size(Bitstring) -&amp;gt; integer() &amp;gt;= 0</source>
          <target state="translated">bit_size (비트 열)-&amp;gt; 정수 ()&amp;gt; = 0</target>
        </trans-unit>
        <trans-unit id="d837d332e8e1beb2cd16e8f3531304c0d159e914" translate="yes" xml:space="preserve">
          <source>bitstring_to_list(Bitstring) -&amp;gt; [byte() | bitstring()]</source>
          <target state="translated">bitstring_to_list (비트 열)-&amp;gt; [byte () | 비트 스트링 ()]</target>
        </trans-unit>
        <trans-unit id="d3b2a5d7c98ea683b103e280654c42c14fba7a51" translate="yes" xml:space="preserve">
          <source>block(Log) -&amp;gt; ok | {error, block_error_rsn()}</source>
          <target state="translated">블록 (로그)-&amp;gt; 확인 | {오류, block_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="6cb88986b71a24912415b57a409d5ea17be1e56e" translate="yes" xml:space="preserve">
          <source>block(Log, QueueLogRecords) -&amp;gt; ok | {error, block_error_rsn()}</source>
          <target state="translated">블록 (로그, QueueLogRecords)-&amp;gt; 확인 | {오류, block_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="8c8fd5e53c9f8727669d6100d4f208bce4d30494" translate="yes" xml:space="preserve">
          <source>block_call(Node, Module, Function, Args) -&amp;gt; Res | {badrpc, Reason}</source>
          <target state="translated">block_call (노드, 모듈, 함수, Args)-&amp;gt; Res | {badrpc, 이유}</target>
        </trans-unit>
        <trans-unit id="b23f2e95b93674d1dfc2e3ac44aed2b88cfdbb90" translate="yes" xml:space="preserve">
          <source>block_call(Node, Module, Function, Args, Timeout) -&amp;gt;</source>
          <target state="translated">block_call (노드, 모듈, 함수, Args, Timeout)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd3fb95e2e8de8d56289b202407712ce7b08d0a7" translate="yes" xml:space="preserve">
          <source>block_expr case_expr catch_expr char</source>
          <target state="translated">block_expr case_expr catch_expr char</target>
        </trans-unit>
        <trans-unit id="4afc334809efe11398470686b7036f8e78933955" translate="yes" xml:space="preserve">
          <source>blocked |</source>
          <target state="translated">차단 |</target>
        </trans-unit>
        <trans-unit id="1a397ad31897e50ea475b6705de127fbb370da75" translate="yes" xml:space="preserve">
          <source>blocked_normal |</source>
          <target state="translated">block_normal |</target>
        </trans-unit>
        <trans-unit id="3beee47ea2b078cd59c4c5ce4b9190eb9146b4f9" translate="yes" xml:space="preserve">
          <source>blog(Log, Bytes) -&amp;gt; ok | {error, Reason :: log_error_rsn()}</source>
          <target state="translated">블로그 (로그, 바이트)-&amp;gt; ok | {오류, 이유 :: log_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="fd89d388c12a39eefed7b264ab6c94451497daf4" translate="yes" xml:space="preserve">
          <source>blog_terms(Log, BytesList) -&amp;gt;</source>
          <target state="translated">blog_terms (로그, 바이트 목록)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="73007bbd46f4537b551caebd6b8b9edad123d036" translate="yes" xml:space="preserve">
          <source>bnot</source>
          <target state="translated">bnot</target>
        </trans-unit>
        <trans-unit id="51b5e482911bb6268c2e8441668f0475ddf3a241" translate="yes" xml:space="preserve">
          <source>bom_to_encoding(Bin) -&amp;gt; {Encoding, Length}</source>
          <target state="translated">bom_to_encoding (Bin)-&amp;gt; {인코딩, 길이}</target>
        </trans-unit>
        <trans-unit id="48f21c15b1a3ef3e80d90f4547b15acb2b2278c5" translate="yes" xml:space="preserve">
          <source>bool_op(OpName, Arity) -&amp;gt; boolean()</source>
          <target state="translated">bool_op (OpName, Arity)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="9424b2cb7838f8e03100e5d1f08259651bbc4380" translate="yes" xml:space="preserve">
          <source>boolean()</source>
          <target state="translated">boolean()</target>
        </trans-unit>
        <trans-unit id="4c588bef1112cdcd9df76232b803718e01380b3c" translate="yes" xml:space="preserve">
          <source>boot(BootArgs) -&amp;gt; no_return()</source>
          <target state="translated">boot (BootArgs)-&amp;gt; no_return ()</target>
        </trans-unit>
        <trans-unit id="52bb0a7e3d33a423ae04f237f2810d90b2958d74" translate="yes" xml:space="preserve">
          <source>bor</source>
          <target state="translated">bor</target>
        </trans-unit>
        <trans-unit id="6fb0ba68c9e796283f40b2a10f8a4caa02b5fdab" translate="yes" xml:space="preserve">
          <source>both spawns the &quot;pong&quot; process and gives it the name &lt;code&gt;pong&lt;/code&gt;. In the &quot;ping&quot; process, messages can be sent to &lt;code&gt;pong&lt;/code&gt; by:</source>
          <target state="translated">둘 다 &quot;pong&quot;프로세스를 생성하고 이름을 &lt;code&gt;pong&lt;/code&gt; 으로 지정 합니다. &quot;ping&quot;프로세스에서 다음을 통해 메시지를 &lt;code&gt;pong&lt;/code&gt; 으로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1427acd9017f044f097b39bd8dd867988c97a153" translate="yes" xml:space="preserve">
          <source>breopen(Log, File, BHead) -&amp;gt; ok | {error, reopen_error_rsn()}</source>
          <target state="translated">breopen (로그, 파일, BHead)-&amp;gt; 확인 | {오류, reopen_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="50f0842e1cda0fe8c9f71cfa4ea2f0841c7e72b2" translate="yes" xml:space="preserve">
          <source>bsl</source>
          <target state="translated">bsl</target>
        </trans-unit>
        <trans-unit id="63f2dca71c40848a4d8dc8e8cd8519a87854073a" translate="yes" xml:space="preserve">
          <source>bsr</source>
          <target state="translated">bsr</target>
        </trans-unit>
        <trans-unit id="4227474834bb37177c89c0c04a1c6088a0e0806d" translate="yes" xml:space="preserve">
          <source>bt(Pid) -&amp;gt; ok | undefined</source>
          <target state="translated">bt (Pid)-&amp;gt; 확인 | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="8cd9983b11c76876844be257a0f87b83409ff33e" translate="yes" xml:space="preserve">
          <source>btruncate(Log, BHead) -&amp;gt; ok | {error, trunc_error_rsn()}</source>
          <target state="translated">btruncate (로그, BHead)-&amp;gt; 확인 | {오류, trunc_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="d9e9c73acc45e7723c0d136c3fe7b40a2a9f6e19" translate="yes" xml:space="preserve">
          <source>build: From a command prompt with the VC tools available (See the instructions for OpenSSL build above for help on starting the proper command prompt in RELEASE mode):</source>
          <target state="translated">빌드 : VC 도구를 사용할 수있는 명령 프롬프트에서 (릴리스 모드에서 적절한 명령 프롬프트를 시작하는 데 대한 도움말은 위의 OpenSSL 빌드 지시 사항 참조) :</target>
        </trans-unit>
        <trans-unit id="183ecb4902d0d0d41b48309e30dd5254ba89737d" translate="yes" xml:space="preserve">
          <source>build_module(Chunks) -&amp;gt; {ok, Binary}</source>
          <target state="translated">build_module (Chunks)-&amp;gt; {ok, 이진}</target>
        </trans-unit>
        <trans-unit id="761567101897b252935ed432a4e4198076c07914" translate="yes" xml:space="preserve">
          <source>build_text(FormatList) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-chars&quot;&gt;chars()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">build_text (FormatList)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-chars&quot;&gt;chars()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c15d9af91a67e242ca69b3cc677bedd7cf7a1311" translate="yes" xml:space="preserve">
          <source>built-in filters, see &lt;code&gt;&lt;a href=&quot;logger_filters&quot;&gt;logger_filters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내장 필터는 &lt;code&gt;&lt;a href=&quot;logger_filters&quot;&gt;logger_filters&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bcba5ec087d106757db884cf7c12f1e54e03c54" translate="yes" xml:space="preserve">
          <source>but if Erlang was started with &lt;code&gt;+pc unicode&lt;/code&gt;:</source>
          <target state="translated">그러나 Erlang이 &lt;code&gt;+pc unicode&lt;/code&gt; 로 시작된 경우 :</target>
        </trans-unit>
        <trans-unit id="190e9b4cffa7d0a9b40313246c0c7618ab1908bb" translate="yes" xml:space="preserve">
          <source>but if the &lt;code&gt;user_args&lt;/code&gt; parameter is set to a longer list, such as &lt;code&gt;[SomePid,SomeTableRef]&lt;/code&gt;, the callback function is expected to have these (in this case two) extra arguments last in the argument list:</source>
          <target state="translated">그러나 &lt;code&gt;user_args&lt;/code&gt; 매개 변수가 더 긴 목록 (예 : &lt;code&gt;[SomePid,SomeTableRef]&lt;/code&gt; )으로 설정되면 콜백 함수는 인수 목록에서 다음과 같은 추가 인수가 마지막에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="87f9c67072367b652ee581fe6702e90f86a88df1" translate="yes" xml:space="preserve">
          <source>but if you want to match on something like the name of a function, you have to use an atom as metavariable:</source>
          <target state="translated">그러나 함수 이름과 같은 것을 일치 시키려면 원자를 메타 변수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf05994ef579f79cdaa47b8de3629989183079f3" translate="yes" xml:space="preserve">
          <source>bxor</source>
          <target state="translated">bxor</target>
        </trans-unit>
        <trans-unit id="cd735cd6accded04e305d48a4573dbc18c35e2d5" translate="yes" xml:space="preserve">
          <source>byte_size(Bitstring) -&amp;gt; integer() &amp;gt;= 0</source>
          <target state="translated">byte_size (비트 열)-&amp;gt; 정수 ()&amp;gt; = 0</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="c96598b814dcba9a9e1f98c1b6985598ed7b2584" translate="yes" xml:space="preserve">
          <source>c(Module) -&amp;gt; {ok, ModuleName} | error</source>
          <target state="translated">c (모듈)-&amp;gt; {ok, ModuleName} | 오류</target>
        </trans-unit>
        <trans-unit id="9b04aeac7f4b5720e8ac207dd62c5ce15ce0106d" translate="yes" xml:space="preserve">
          <source>c(Module, Options) -&amp;gt; {ok, ModuleName} | error</source>
          <target state="translated">c (모듈, 옵션)-&amp;gt; {ok, ModuleName} | 오류</target>
        </trans-unit>
        <trans-unit id="f57652c8c1ca50e19e0b8ad191019a332a4b9b1e" translate="yes" xml:space="preserve">
          <source>c(Module, Options, Filter) -&amp;gt; {ok, ModuleName} | error</source>
          <target state="translated">c (모듈, 옵션, 필터)-&amp;gt; {ok, ModuleName} | 오류</target>
        </trans-unit>
        <trans-unit id="e4ffacba5591440a14a08eac7aade57c603e17c0" translate="yes" xml:space="preserve">
          <source>calendar</source>
          <target state="translated">calendar</target>
        </trans-unit>
        <trans-unit id="c4d23b67e305f02cc6296b3fb8e9c61a291a202a" translate="yes" xml:space="preserve">
          <source>calendar(3)</source>
          <target state="translated">calendar(3)</target>
        </trans-unit>
        <trans-unit id="11a5154fab3fad99dfcf27e7652ca5cc053e9ebd" translate="yes" xml:space="preserve">
          <source>calendar(3), erlc(1)</source>
          <target state="translated">달력 (3), erlc (1)</target>
        </trans-unit>
        <trans-unit id="bc8d8647b02deea0ab3e715c220d041ee78cc19d" translate="yes" xml:space="preserve">
          <source>call</source>
          <target state="translated">call</target>
        </trans-unit>
        <trans-unit id="9c6a639756ac5ffb262ebf578907862758c2dd70" translate="yes" xml:space="preserve">
          <source>call(Node, Module, Function, Args) -&amp;gt; Res | {badrpc, Reason}</source>
          <target state="translated">호출 (노드, 모듈, 함수, Args)-&amp;gt; Res | {badrpc, 이유}</target>
        </trans-unit>
        <trans-unit id="08f979cae5db743f169883afbe8b5f12097026c8" translate="yes" xml:space="preserve">
          <source>call(Node, Module, Function, Args, Timeout) -&amp;gt;</source>
          <target state="translated">호출 (노드, 모듈, 함수, Args, 타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c4765dd33456ed105d24d5704b27dde8cb8d9886" translate="yes" xml:space="preserve">
          <source>call(ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">call (ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0ba6ce98874a5c86261e3fbbcd1cbbc9dd2967c2" translate="yes" xml:space="preserve">
          <source>call(ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt;, Request :: term()) -&amp;gt;</source>
          <target state="translated">call (ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; , 요청 :: term ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26d71743b2cda8f3c5b1b0c17a1ec20c638d5711" translate="yes" xml:space="preserve">
          <source>callback functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="97afaf3f7d287fac5660c73b7a658f2fedeceedc" translate="yes" xml:space="preserve">
          <source>can be rewritten to be more readable:</source>
          <target state="translated">더 읽기 쉽게 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f4c3ceeafe1d883f6ac4d4cb5ff62d588550d0" translate="yes" xml:space="preserve">
          <source>can be rewritten to:</source>
          <target state="translated">다시 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fa8c9a76d02216d180ab712928f241fa3f5fa8ab" translate="yes" xml:space="preserve">
          <source>can instead be written as</source>
          <target state="translated">대신 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8b3eff9ca3eaef64b1fc77c577b756f666c76190" translate="yes" xml:space="preserve">
          <source>cancel(TRef) -&amp;gt; {ok, cancel} | {error, Reason}</source>
          <target state="translated">cancel (TRef)-&amp;gt; {ok, cancel} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="d0f5bc9e7850806fda269bc43f2e3119e92c12b2" translate="yes" xml:space="preserve">
          <source>canonical_relation(SetOfSets) -&amp;gt; BinRel</source>
          <target state="translated">canonical_relation (SetOfSets)-&amp;gt; BinRel</target>
        </trans-unit>
        <trans-unit id="3a52a465fada7e9c75be4f939e764083831448bd" translate="yes" xml:space="preserve">
          <source>carriers() -&amp;gt; {ok, Result} | {error, Reason}</source>
          <target state="translated">carriers ()-&amp;gt; {ok, Result} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="ee5214a0625718436544ae70fe60f4d82b91e2db" translate="yes" xml:space="preserve">
          <source>carriers(Options) -&amp;gt; {ok, Result} | {error, Reason}</source>
          <target state="translated">이동 통신사 (옵션)-&amp;gt; {ok, Result} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="7eb4f86b6d9ac5664065c4597d525d38854b4720" translate="yes" xml:space="preserve">
          <source>casefold(String :: &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">casefold (String :: &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a45288041b7277b587938369be0c9d86f6ad7edf" translate="yes" xml:space="preserve">
          <source>cast(Node, Module, Function, Args) -&amp;gt; true</source>
          <target state="translated">캐스트 (노드, 모듈, 함수, Args)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="381e46370e8a81b3601dcd66a0d30c1e7b579344" translate="yes" xml:space="preserve">
          <source>cast(ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt;, Msg :: term()) -&amp;gt; ok</source>
          <target state="translated">cast (ServerRef :: &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; , Msg :: term ())-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="9ebad64e5d2b9542779537fce0354f34c099e7ff" translate="yes" xml:space="preserve">
          <source>catch</source>
          <target state="translated">catch</target>
        </trans-unit>
        <trans-unit id="f443b2f9a405f81f49c3989ddcf0dbd1252a91dd" translate="yes" xml:space="preserve">
          <source>category(Token) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-category&quot;&gt;category()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">category (토큰)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-category&quot;&gt;category()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="639287c1f36ef84ae38ed37b5ac7cf276477fba3" translate="yes" xml:space="preserve">
          <source>cd(Dir) -&amp;gt; ok</source>
          <target state="translated">cd (Dir)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="80b80913dd4035ef9aaa91f5f87178c517a7c9c0" translate="yes" xml:space="preserve">
          <source>ceil(Number) -&amp;gt; integer()</source>
          <target state="translated">ceil (Number)-&amp;gt; 정수 ()</target>
        </trans-unit>
        <trans-unit id="ba4898d1e8bc8aaa35047d5a0a24d5ad9db64383" translate="yes" xml:space="preserve">
          <source>ceil(X) -&amp;gt; float()</source>
          <target state="translated">ceil (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="430831ed6146303877cf7be9022369ef4669761c" translate="yes" xml:space="preserve">
          <source>centre(String, Number) -&amp;gt; Centered</source>
          <target state="translated">center (문자열, 숫자)-&amp;gt; 가운데</target>
        </trans-unit>
        <trans-unit id="6d425e0de1476cc745bedfaa528f54aa28294852" translate="yes" xml:space="preserve">
          <source>centre(String, Number, Character) -&amp;gt; Centered</source>
          <target state="translated">center (문자열, 숫자, 문자)-&amp;gt; 가운데</target>
        </trans-unit>
        <trans-unit id="b0d0d921640f8dee544001e223d7bd2196d6e8f2" translate="yes" xml:space="preserve">
          <source>change_code(Name, Module, OldVsn, Extra) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_code (이름, 모듈, OldVsn, Extra)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="ebb8c3045bd28c21b6056fc7ad0e6f34271d630f" translate="yes" xml:space="preserve">
          <source>change_code(Name, Module, OldVsn, Extra, Timeout) -&amp;gt;</source>
          <target state="translated">change_code (이름, 모듈, OldVsn, Extra, Timeout)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="783522fc90c82b44cbd792497069d120268dc7b9" translate="yes" xml:space="preserve">
          <source>change_group(Filename, Gid) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_group (파일 이름, Gid)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="813b43d9f912fc121c8d6021e058ea6e68594eca" translate="yes" xml:space="preserve">
          <source>change_header(Log, Header) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_header (로그, 헤더)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="9ee1b282106ead99f37f874d43ec57bd8437b08b" translate="yes" xml:space="preserve">
          <source>change_key(RegHandle, Key) -&amp;gt; ReturnValue</source>
          <target state="translated">change_key (RegHandle, Key)-&amp;gt; 리턴 값</target>
        </trans-unit>
        <trans-unit id="1018df7f56e905f0dab8158912e0d1ae7158718f" translate="yes" xml:space="preserve">
          <source>change_key_create(RegHandle, Key) -&amp;gt; ReturnValue</source>
          <target state="translated">change_key_create (RegHandle, Key)-&amp;gt; 리턴 값</target>
        </trans-unit>
        <trans-unit id="bca67c8be654ba78537aed478f039caf99cca9f2" translate="yes" xml:space="preserve">
          <source>change_mode(Filename, Mode) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_mode (파일 이름, 모드)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="8a3f9c9d1b52f169e5c459cd5f0f9ba380ec3c6e" translate="yes" xml:space="preserve">
          <source>change_notify(Log, Owner, Notify) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_notify (로그, 소유자, 알림)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="a63fd44f204117228407c76fcf3481e903d5cb26" translate="yes" xml:space="preserve">
          <source>change_owner(Filename, Uid) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_owner (파일 이름, Uid)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="f4f5da258939e140cb61e3b735a04bc820246d79" translate="yes" xml:space="preserve">
          <source>change_owner(Filename, Uid, Gid) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_owner (파일 이름, Uid, Gid)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="afb290d7490cde5b145dd7d93cf0d803d23e88da" translate="yes" xml:space="preserve">
          <source>change_size(Log, Size) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_size (로그, 크기)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="791e710387d0d415cf29c846113be273ae0a4f62" translate="yes" xml:space="preserve">
          <source>change_time(Filename, Atime, Mtime) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_time (파일 이름, Atime, Mtime)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="2fdcec46b372cbab633de2105e377c344475062c" translate="yes" xml:space="preserve">
          <source>change_time(Filename, Mtime) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">change_time (파일 이름, Mtime)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="b373c5419d5796d4aec2cc2b3a99d2881565ccd0" translate="yes" xml:space="preserve">
          <source>char_list(Term) -&amp;gt; boolean()</source>
          <target state="translated">char_list (용어)-&amp;gt; boolean ()</target>
        </trans-unit>
        <trans-unit id="97acdeea52ff074a79d4f4a036cfe0deedb393cf" translate="yes" xml:space="preserve">
          <source>character with octal code ddd..</source>
          <target state="translated">8 진 코드 ddd ..</target>
        </trans-unit>
        <trans-unit id="50dd212971b862e228bd0cb0b91a358f1b6648be" translate="yes" xml:space="preserve">
          <source>characters_to_binary(Data) -&amp;gt; Result</source>
          <target state="translated">characters_to_binary (Data)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="aadceda668c49dda7bac9a8574904aa1b30596ed" translate="yes" xml:space="preserve">
          <source>characters_to_binary(Data, InEncoding) -&amp;gt; Result</source>
          <target state="translated">characters_to_binary (데이터, 인코딩)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="c1527fcfa4b121203e4e1dc1047e1efd8102d562" translate="yes" xml:space="preserve">
          <source>characters_to_binary(Data, InEncoding, OutEncoding) -&amp;gt; Result</source>
          <target state="translated">characters_to_binary (Data, InEncoding, OutEncoding)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="6df472875c5fb944d9c780677694bf3acd8df87b" translate="yes" xml:space="preserve">
          <source>characters_to_list(Data) -&amp;gt; Result</source>
          <target state="translated">characters_to_list (데이터)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="0be42f160cc63b226b89e76ba26a22c9d089da08" translate="yes" xml:space="preserve">
          <source>characters_to_list(Data, InEncoding) -&amp;gt; Result</source>
          <target state="translated">characters_to_list (데이터, 인코딩)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="2ba3ed5bf166b53d492b4c2910228a6a9a308c2f" translate="yes" xml:space="preserve">
          <source>characters_to_nfc_binary(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfc_binary (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3a992f407babbcb92da44c4c4a00edeee005a324" translate="yes" xml:space="preserve">
          <source>characters_to_nfc_list(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfc_list (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a50804d73541388bd1f9b9cfd58d50935a1532e7" translate="yes" xml:space="preserve">
          <source>characters_to_nfd_binary(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfd_binary (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3a73758f285f32879954a26aa7bcf685eb8f29b2" translate="yes" xml:space="preserve">
          <source>characters_to_nfd_list(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfd_list (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f31faaa6282e529db9ca4a80795cf6063a787e92" translate="yes" xml:space="preserve">
          <source>characters_to_nfkc_binary(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfkc_binary (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="33a61d8980375f87b4307c0001df8865101cd823" translate="yes" xml:space="preserve">
          <source>characters_to_nfkc_list(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfkc_list (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3c5a611ecf8b29176a655e3d243f26eee4a03b8b" translate="yes" xml:space="preserve">
          <source>characters_to_nfkd_binary(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfkd_binary (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1162a0c030dee7362242d5d4889617380f5b1117" translate="yes" xml:space="preserve">
          <source>characters_to_nfkd_list(CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">characters_to_nfkd_list (CD :: &lt;code&gt;&lt;a href=&quot;#type-chardata&quot;&gt;chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="10796c10a0d913f50eaf9f5e9e98eb494d45b996" translate="yes" xml:space="preserve">
          <source>chars(Character, Number) -&amp;gt; String</source>
          <target state="translated">문자 (문자, 숫자)-&amp;gt; 문자열</target>
        </trans-unit>
        <trans-unit id="6b90cf1e25454d1ce2e6fe69ba6126d8cee80995" translate="yes" xml:space="preserve">
          <source>chars(Character, Number, Tail) -&amp;gt; String</source>
          <target state="translated">chars (Character, Number, Tail)-&amp;gt; 문자열</target>
        </trans-unit>
        <trans-unit id="9ab9e1b88757331e50f7177d246a6ac6814e59fb" translate="yes" xml:space="preserve">
          <source>check for UTRACE support in your current kernel:</source>
          <target state="translated">현재 커널에서 UTRACE 지원을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3d169e3674a560aa2c318fdc654be52039e49b3" translate="yes" xml:space="preserve">
          <source>check is only performed on the peer certificate.</source>
          <target state="translated">확인은 피어 인증서에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ca38ce7e1dd5c5036886c71fceaf06e593f3c559" translate="yes" xml:space="preserve">
          <source>check(FileName) -&amp;gt; Reply</source>
          <target state="translated">확인 (파일 이름)-&amp;gt; 회신</target>
        </trans-unit>
        <trans-unit id="b58dd293f1c20a1a5ce151c3dd25dbf472399074" translate="yes" xml:space="preserve">
          <source>check(FileNames, Options) -&amp;gt; Reply</source>
          <target state="translated">확인 (파일 이름, 옵션)-&amp;gt; 답장</target>
        </trans-unit>
        <trans-unit id="85d09266f730ed0ef11150d70e729fa7eff222f8" translate="yes" xml:space="preserve">
          <source>check_childspecs(ChildSpecs) -&amp;gt; Result</source>
          <target state="translated">check_childspecs (ChildSpecs)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="025372ec22477e9ed850bd0a7594df78e4a7e901" translate="yes" xml:space="preserve">
          <source>check_config(Config) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">check_config (Config)-&amp;gt; 확인 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="cdd039a4a821ac3ab2ae2b30d5a6cea34bd528dc" translate="yes" xml:space="preserve">
          <source>check_old_code(Module) -&amp;gt; boolean()</source>
          <target state="translated">check_old_code (모듈)-&amp;gt; boolean ()</target>
        </trans-unit>
        <trans-unit id="858a711c9ed5861d92934be8a86c2b8fc57262c7" translate="yes" xml:space="preserve">
          <source>check_process_code(Pid, Module) -&amp;gt; CheckResult</source>
          <target state="translated">check_process_code (Pid, Module)-&amp;gt; CheckResult</target>
        </trans-unit>
        <trans-unit id="02bb69bcfbe9631af85f29388f5458e1710f36a4" translate="yes" xml:space="preserve">
          <source>check_process_code(Pid, Module, OptionList) -&amp;gt; CheckResult | async</source>
          <target state="translated">check_process_code (Pid, Module, OptionList)-&amp;gt; CheckResult | 비동기</target>
        </trans-unit>
        <trans-unit id="f1470d1355971648fda0d3239972aae8cf53a09a" translate="yes" xml:space="preserve">
          <source>chomp(String :: &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">chomp (String :: &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bed3a9983ca825632c6ecf8da20aebbefc0d07af" translate="yes" xml:space="preserve">
          <source>chr(String, Character) -&amp;gt; Index</source>
          <target state="translated">chr (문자열, 문자)-&amp;gt; 색인</target>
        </trans-unit>
        <trans-unit id="5b6400e6315f474c7d3ef6d5d682c030be6e1e5c" translate="yes" xml:space="preserve">
          <source>chunk(Continuation) -&amp;gt; chunk_ret()</source>
          <target state="translated">청크 (계속)-&amp;gt; chunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="05be0dd9e71fb7d4bcdd7c6dc89b0a9801785ccf" translate="yes" xml:space="preserve">
          <source>chunk(Continuation, N) -&amp;gt; chunk_ret()</source>
          <target state="translated">청크 (계속, N)-&amp;gt; chunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="a274fcea06afb64eca7855cbea372182f5cad268" translate="yes" xml:space="preserve">
          <source>chunk(Log, Continuation) -&amp;gt; chunk_ret()</source>
          <target state="translated">청크 (로그, 계속)-&amp;gt; chunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="bb306e0f5f5c5bf52efb13e6f7840f7fe62ab1fa" translate="yes" xml:space="preserve">
          <source>chunk(Log, Continuation, N) -&amp;gt; chunk_ret()</source>
          <target state="translated">청크 (로그, 연속, N)-&amp;gt; chunk_ret ​​()</target>
        </trans-unit>
        <trans-unit id="b60020e1bd24497c7a856b4bd24c7b804dbf3ef3" translate="yes" xml:space="preserve">
          <source>chunk_info(Continuation) -&amp;gt; InfoList | {error, Reason}</source>
          <target state="translated">chunk_info (계속)-&amp;gt; InfoList | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="bac6f8bf8225d7b9b559782f93abe21ea5036e41" translate="yes" xml:space="preserve">
          <source>chunk_step(Log, Continuation, Step) -&amp;gt;</source>
          <target state="translated">chunk_step (로그, 계속, 단계)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="366a764e9406d8fa8a195b78e6c83d79ba3eece7" translate="yes" xml:space="preserve">
          <source>chunks(Beam, ChunkRefs) -&amp;gt;</source>
          <target state="translated">덩어리 (Beam, ChunkRefs)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b109e88bd0666bd32af0e725acf2d5ad1b561a20" translate="yes" xml:space="preserve">
          <source>chunks(Beam, ChunkRefs, Options) -&amp;gt;</source>
          <target state="translated">청크 (Beam, ChunkRefs, Options)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb84e35d6406ac74325686d9b399e2c067031ba1" translate="yes" xml:space="preserve">
          <source>clash() -&amp;gt; ok</source>
          <target state="translated">충돌 ()-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="c3cec0881945cba668f9d48b9e22ae3751b011f8" translate="yes" xml:space="preserve">
          <source>class_qualifier clause comment cond_expr</source>
          <target state="translated">class_qualifier 절 주석 cond_expr</target>
        </trans-unit>
        <trans-unit id="5e7884515ab16e4fab1b842c5ba8c4c01b4df0d5" translate="yes" xml:space="preserve">
          <source>clear_callback() -&amp;gt; ok</source>
          <target state="translated">clear_callback ()-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="5f0385341d0d9dc1330078377476f25920368051" translate="yes" xml:space="preserve">
          <source>clear_cmd() -&amp;gt; ok</source>
          <target state="translated">clear_cmd ()-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="3216feb60522c7752bc3d58cd3f2e7dc2984e813" translate="yes" xml:space="preserve">
          <source>clear_crypto_key_fun() -&amp;gt; undefined | {ok, Result}</source>
          <target state="translated">clear_crypto_key_fun ()-&amp;gt; 정의되지 않음 | {확인, 결과}</target>
        </trans-unit>
        <trans-unit id="93df14617ceda8ee499003ae137b44e91aa26cce" translate="yes" xml:space="preserve">
          <source>clients</source>
          <target state="translated">clients</target>
        </trans-unit>
        <trans-unit id="7f8b454bfd8f7d9a92afda64070ce71fdfd2e466" translate="yes" xml:space="preserve">
          <source>close(ConnectionRef) -&amp;gt; ok | {error, term()}</source>
          <target state="translated">close (ConnectionRef)-&amp;gt; 확인 | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="405b991a1f1c3f1f1e979b838fc1db9c1f16ff47" translate="yes" xml:space="preserve">
          <source>close(Continuation) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">닫기 (계속)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="057544b5e2ac221fbb8165280b21b26bae408c90" translate="yes" xml:space="preserve">
          <source>close(Epp) -&amp;gt; ok</source>
          <target state="translated">닫기 (Epp)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="4b0c201fa495b4dbaad337f5ae57d4ca607c5b0d" translate="yes" xml:space="preserve">
          <source>close(IoDevice) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">close (IoDevice)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="524e7f9b6548d1169747d906fa1bcdf2a90c4c31" translate="yes" xml:space="preserve">
          <source>close(Log) -&amp;gt; ok | {error, close_error_rsn()}</source>
          <target state="translated">닫기 (로그)-&amp;gt; 확인 | {오류, close_error_rsn ()}</target>
        </trans-unit>
        <trans-unit id="d8097d564ac8a77dadce2098b541a026d4c5534d" translate="yes" xml:space="preserve">
          <source>close(Name) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">닫기 (이름)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="d87db21865a684fc7fb6307f14b21e9b8ca38986" translate="yes" xml:space="preserve">
          <source>close(RegHandle) -&amp;gt; ok</source>
          <target state="translated">닫기 (RegHandle)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="0e4bb3fb6f47b73e2d08297f4a38fc0e6739b507" translate="yes" xml:space="preserve">
          <source>close(Socket) -&amp;gt; ok</source>
          <target state="translated">닫기 (소켓)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="7b3608d6ece4ad8fe103f51f76d5738be90841ee" translate="yes" xml:space="preserve">
          <source>close(Socket) -&amp;gt; ok | {error, &lt;code&gt;&lt;a href=&quot;inet#type-posix&quot;&gt;inet:posix()&lt;/a&gt;&lt;/code&gt;}</source>
          <target state="translated">닫기 (소켓)-&amp;gt; 확인 | {오류, &lt;code&gt;&lt;a href=&quot;inet#type-posix&quot;&gt;inet:posix()&lt;/a&gt;&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="82120cb0a9a3d8267c30e933c49975eabd2bec5a" translate="yes" xml:space="preserve">
          <source>close(Z) -&amp;gt; ok</source>
          <target state="translated">닫기 (Z)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="3a46caa6c4eb9cce8b01bc14c6acc15e94854358" translate="yes" xml:space="preserve">
          <source>close_session(Client) -&amp;gt; Result</source>
          <target state="translated">close_session (Client)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="60b85f36b3da2679378993163997137d8779e866" translate="yes" xml:space="preserve">
          <source>close_session(Client, Timeout) -&amp;gt; Result</source>
          <target state="translated">close_session (클라이언트, 제한 시간 초과)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="13a86e8221c178650a11dd64a31fa2e5594d1b46" translate="yes" xml:space="preserve">
          <source>cmd(Command) -&amp;gt; string()</source>
          <target state="translated">cmd (명령)-&amp;gt; 문자열 ()</target>
        </trans-unit>
        <trans-unit id="b5ba6d6ad096e0b05e114431b163b9368f5efcb0" translate="yes" xml:space="preserve">
          <source>cmd(Command, Options) -&amp;gt; string()</source>
          <target state="translated">cmd (명령, 옵션)-&amp;gt; 문자열 ()</target>
        </trans-unit>
        <trans-unit id="76cde058fcf2fea65cdff54b66e764aa168f69d9" translate="yes" xml:space="preserve">
          <source>cmp(Beam1, Beam2) -&amp;gt; ok | {error, beam_lib, cmp_rsn()}</source>
          <target state="translated">cmp (빔 1, 빔 2)-&amp;gt; 확인 | {오류, beam_lib, cmp_rsn ()}</target>
        </trans-unit>
        <trans-unit id="a45101c8700b675e33f2e27f291a6dad251aaac2" translate="yes" xml:space="preserve">
          <source>cmp_dirs(Dir1, Dir2) -&amp;gt;</source>
          <target state="translated">cmp_dirs (Dir1, Dir2)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="4ca2a21fb83cf707e2de16c66773b4497aa55a47" translate="yes" xml:space="preserve">
          <source>code(3), compile(3)</source>
          <target state="translated">코드 (3), 컴파일 (3)</target>
        </trans-unit>
        <trans-unit id="6154a1389edd3ab751adb19441ec668fa60c5615" translate="yes" xml:space="preserve">
          <source>collector_pid - undefined.</source>
          <target state="translated">collector_pid-정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c4917293b3f6d941cb86e7439956a85a589af1ef" translate="yes" xml:space="preserve">
          <source>column numbers</source>
          <target state="translated">열 번호</target>
        </trans-unit>
        <trans-unit id="4c005b25a39f8f4196d18435cf113789ddff1e80" translate="yes" xml:space="preserve">
          <source>column(Anno) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-column&quot;&gt;column()&lt;/a&gt;&lt;/code&gt; | undefined</source>
          <target state="translated">column (Anno)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-column&quot;&gt;column()&lt;/a&gt;&lt;/code&gt; | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="3edebbdb0e986a71c739939f8611de063d46564b" translate="yes" xml:space="preserve">
          <source>column(Token) -&amp;gt; &lt;code&gt;&lt;a href=&quot;erl_anno#type-column&quot;&gt;erl_anno:column()&lt;/a&gt;&lt;/code&gt; | undefined</source>
          <target state="translated">열 (토큰)-&amp;gt; &lt;code&gt;&lt;a href=&quot;erl_anno#type-column&quot;&gt;erl_anno:column()&lt;/a&gt;&lt;/code&gt; | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="8e0c05a69d72d58e0161e44b5e5dbd2a94d154fb" translate="yes" xml:space="preserve">
          <source>columns() -&amp;gt; {ok, integer() &amp;gt;= 1} | {error, enotsup}</source>
          <target state="translated">columns ()-&amp;gt; {ok, integer ()&amp;gt; = 1} | {오류, enotsup}</target>
        </trans-unit>
        <trans-unit id="613f633c6b5af7d2278a11f4bc637b8ebefef8e9" translate="yes" xml:space="preserve">
          <source>columns(IoDevice) -&amp;gt; {ok, integer() &amp;gt;= 1} | {error, enotsup}</source>
          <target state="translated">columns (IoDevice)-&amp;gt; {ok, integer ()&amp;gt; = 1} | {오류, enotsup}</target>
        </trans-unit>
        <trans-unit id="35fbc1c4ef846a8613de892f3c24cebce7bb1674" translate="yes" xml:space="preserve">
          <source>commit(Ref, CommitMode) is the same as commit(Ref, CommitMode, infinity). If the timeout expires the client will exit with the reason timeout.</source>
          <target state="translated">commit (Ref, CommitMode)는 commit (Ref, CommitMode, infinity)와 동일합니다. 시간 초과가 만료되면 클라이언트는 시간 초과 이유와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="975db8aa4539732ff0ee2dfb613c7e625dffc732" translate="yes" xml:space="preserve">
          <source>commitFailed</source>
          <target state="translated">commitFailed</target>
        </trans-unit>
        <trans-unit id="7e4aea77a2953f1457a0d38b49acf1d461b9a701" translate="yes" xml:space="preserve">
          <source>common_test</source>
          <target state="translated">common_test</target>
        </trans-unit>
        <trans-unit id="1b53b0152534976505f715a73361f6799fa3b9f4" translate="yes" xml:space="preserve">
          <source>comp_op(OpName, Arity) -&amp;gt; boolean()</source>
          <target state="translated">comp_op (OpName, Arity)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="4f44e2cffa8f7b516c9e499285c951d788431a28" translate="yes" xml:space="preserve">
          <source>compact</source>
          <target state="translated">compact</target>
        </trans-unit>
        <trans-unit id="6a65c8bd6197684775e3bb22b33b16fdd20aa7f3" translate="yes" xml:space="preserve">
          <source>compact [flex]</source>
          <target state="translated">콤팩트 [플렉스]</target>
        </trans-unit>
        <trans-unit id="dd252e97b6b47f7eec947ec60d1c3b02c2b40c3e" translate="yes" xml:space="preserve">
          <source>compact(ListIn) -&amp;gt; ListOut</source>
          <target state="translated">컴팩트 (ListIn)-&amp;gt; ListOut</target>
        </trans-unit>
        <trans-unit id="386cfae07cc6b4302dea2a4e1f0f9e823e17f56d" translate="yes" xml:space="preserve">
          <source>compare_levels(Level1, Level2) -&amp;gt; eq | gt | lt</source>
          <target state="translated">compare_levels (Level1, Level2)-&amp;gt; eq | gt | lt</target>
        </trans-unit>
        <trans-unit id="36d0981b3375d78be03ea98700ecec8f4e4bd4f9" translate="yes" xml:space="preserve">
          <source>compile</source>
          <target state="translated">compile</target>
        </trans-unit>
        <trans-unit id="6bb816b0dbea47ad317d7a37b02463acd4585d97" translate="yes" xml:space="preserve">
          <source>compile(Regexp) -&amp;gt; {ok, MP} | {error, ErrSpec}</source>
          <target state="translated">컴파일 (Regexp)-&amp;gt; {ok, MP} | {오류, ErrSpec}</target>
        </trans-unit>
        <trans-unit id="fdac821a1e3b33e3d131a97c4fefa795119827b9" translate="yes" xml:space="preserve">
          <source>compile(Regexp, Options) -&amp;gt; {ok, MP} | {error, ErrSpec}</source>
          <target state="translated">컴파일 (Regexp, Options)-&amp;gt; {ok, MP} | {오류, ErrSpec}</target>
        </trans-unit>
        <trans-unit id="06ae00d6350f1f8e8373c376d364c4b9f2ef7141" translate="yes" xml:space="preserve">
          <source>compile_pattern(Pattern) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-cp&quot;&gt;cp()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">compile_pattern (Pattern)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-cp&quot;&gt;cp()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac20d084c192f03422d4d714dfe9c4179807ef63" translate="yes" xml:space="preserve">
          <source>compiler</source>
          <target state="translated">compiler</target>
        </trans-unit>
        <trans-unit id="0738f4b8555630007dd0072b0045ceb7129ca75a" translate="yes" xml:space="preserve">
          <source>compiler_dir() -&amp;gt; &lt;code&gt;&lt;a href=&quot;file#type-filename&quot;&gt;file:filename()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">compiler_dir ()-&amp;gt; &lt;code&gt;&lt;a href=&quot;file#type-filename&quot;&gt;file:filename()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d2d1872d3ebbacd8c375708a57375ece8097bd0" translate="yes" xml:space="preserve">
          <source>components(Digraph) -&amp;gt; [Component]</source>
          <target state="translated">구성 요소 (Digraph)-&amp;gt; [Component]</target>
        </trans-unit>
        <trans-unit id="89deb94b571abcd3d38bf175d1516dab4ad8bfbc" translate="yes" xml:space="preserve">
          <source>compose_query(QueryList) -&amp;gt; QueryString</source>
          <target state="translated">compose_query (QueryList)-&amp;gt; QueryString</target>
        </trans-unit>
        <trans-unit id="83a467a3d8bee33048ef3e83a094c349f2bdd2e7" translate="yes" xml:space="preserve">
          <source>compose_query(QueryList, Options) -&amp;gt; QueryString</source>
          <target state="translated">compose_query (QueryList, Options)-&amp;gt; QueryString</target>
        </trans-unit>
        <trans-unit id="4f0ddcaf0eec4c55b5e76e7c3760510160ac6e30" translate="yes" xml:space="preserve">
          <source>composite(Function1, Function2) -&amp;gt; Function3</source>
          <target state="translated">복합 (함수 1, 기능 2)-&amp;gt; 기능 3</target>
        </trans-unit>
        <trans-unit id="2c9a0fdedd9bed9e662940dc86a76aca02d478e0" translate="yes" xml:space="preserve">
          <source>compress(Data) -&amp;gt; Compressed</source>
          <target state="translated">압축 (데이터)-&amp;gt; 압축</target>
        </trans-unit>
        <trans-unit id="391e074aa055e776c060ab7ad54605bec127dad0" translate="yes" xml:space="preserve">
          <source>concat(String1, String2) -&amp;gt; String3</source>
          <target state="translated">concat (문자열 1, 문자열 2)-&amp;gt; 문자열 3</target>
        </trans-unit>
        <trans-unit id="4ce6c476ff719a1759697ac1019217e9a118a68b" translate="yes" xml:space="preserve">
          <source>concat(Things) -&amp;gt; string()</source>
          <target state="translated">concat (것)-&amp;gt; 문자열 ()</target>
        </trans-unit>
        <trans-unit id="97cc041fbe504430ce6a557a4f0a5af0e137d2d5" translate="yes" xml:space="preserve">
          <source>condensation(Digraph) -&amp;gt; CondensedDigraph</source>
          <target state="translated">결로 (Digraph)-&amp;gt; 응축 된 Digraph</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="4d80e6543987b5f69c0ac05d151b65275018e2bb" translate="yes" xml:space="preserve">
          <source>config_err/2</source>
          <target state="translated">config_err/2</target>
        </trans-unit>
        <trans-unit id="a3cc6caa3d5c90bb3063655e5a5e77aac6399cfe" translate="yes" xml:space="preserve">
          <source>configuration directories and parameters</source>
          <target state="translated">구성 디렉토리 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="6746989237b7a068284976d022b7de3eee8d10d9" translate="yes" xml:space="preserve">
          <source>conjunction constrained_function_type constraint disjunction</source>
          <target state="translated">constrained_function_type 제약 조건 분리</target>
        </trans-unit>
        <trans-unit id="9a2afe300547011a85385e34655cc9219bf4fede" translate="yes" xml:space="preserve">
          <source>connect(Address, Port, Options) -&amp;gt; {ok, Socket} | {error, Reason}</source>
          <target state="translated">connect (주소, 포트, 옵션)-&amp;gt; {ok, Socket} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="370622cf4db46ee7498ec7f55bfc67720836c2bb" translate="yes" xml:space="preserve">
          <source>connect(Address, Port, Options, Timeout) -&amp;gt;</source>
          <target state="translated">connect (주소, 포트, 옵션, 타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f4edd64e75f17a976d449fff30d5297a680bdb8" translate="yes" xml:space="preserve">
          <source>connect(KeyOrName, ExtraOptions) -&amp;gt; Result</source>
          <target state="translated">connect (KeyOrName, ExtraOptions)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="868f78486f2a9a4b00139a36221c7f681667f8ba" translate="yes" xml:space="preserve">
          <source>connect(Options) -&amp;gt; Result</source>
          <target state="translated">connect (옵션)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="06b329c7e6b949b5cb3698e561f5b595982fa5b1" translate="yes" xml:space="preserve">
          <source>connect(Socket, Addr, Port, Opts) -&amp;gt;</source>
          <target state="translated">connect (소켓, 주소, 포트, 옵션)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2e5be28a202c1a1a9d218c470327e3cdeba0e3dc" translate="yes" xml:space="preserve">
          <source>connect(Socket, Addr, Port, Opts, Timeout) -&amp;gt;</source>
          <target state="translated">connect (소켓, 주소, 포트, 옵션, 타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d5574c9dc86e68fb4ff2fed87557172eb245c354" translate="yes" xml:space="preserve">
          <source>connect_init(Socket, Addr, Port, Opts) -&amp;gt;</source>
          <target state="translated">connect_init (소켓, 주소, 포트, 옵션)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1589362737416ec60bd6fc116699d981abd923f8" translate="yes" xml:space="preserve">
          <source>connect_init(Socket, Addr, Port, Opts, Timeout) -&amp;gt;</source>
          <target state="translated">connect_init (소켓, 주소, 포트, 옵션, 타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ab119559d2514fe9c2f92800ceca9ebd6db47964" translate="yes" xml:space="preserve">
          <source>connect_node(Node) -&amp;gt; boolean() | ignored</source>
          <target state="translated">connect_node (Node)-&amp;gt; 부울 () | 무시</target>
        </trans-unit>
        <trans-unit id="ae73f001a386f910c26892b99aaf04e904cfd004" translate="yes" xml:space="preserve">
          <source>connection_info(ConnectionRef, Keys) -&amp;gt; ConnectionInfo</source>
          <target state="translated">connection_info (ConnectionRef, 키)-&amp;gt; ConnectionInfo</target>
        </trans-unit>
        <trans-unit id="b8d068eba51665ed21c0f2edf3c36bb633b7c89c" translate="yes" xml:space="preserve">
          <source>cons(Item, Q1 :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt;(Item)) -&amp;gt; Q2 :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt;(Item)</source>
          <target state="translated">cons (Item, Q1 :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt; (Item))-&amp;gt; Q2 :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt; (Item)</target>
        </trans-unit>
        <trans-unit id="7b2dd828fc192ce296acba031555db824efbd079" translate="yes" xml:space="preserve">
          <source>consists of the name (the atom &lt;code&gt;zero&lt;/code&gt;), and a list of clauses containing the single clause &lt;code&gt;() -&amp;gt; 0&lt;/code&gt;. The clause consists of an argument list (empty), a guard (empty), and a body (which is always a list of expressions) containing the single expression &lt;code&gt;0&lt;/code&gt;. This means that to match out the name and the list of clauses of any function, you'll need to use a pattern like &lt;code&gt;?Q(&quot;'@Name'() -&amp;gt; _@_@Body.&quot;)&lt;/code&gt;, using a dummy clause whose body is a glob lifted one level.</source>
          <target state="translated">이름 (atom &lt;code&gt;zero&lt;/code&gt; )과 단일 절 &lt;code&gt;() -&amp;gt; 0&lt;/code&gt; 포함하는 절 목록으로 구성 됩니다. 이 절은 인수 목록 (빈), 보호 (빈) 및 단일 표현식 &lt;code&gt;0&lt;/code&gt; 을 포함하는 본문 (항상 표현식 목록)으로 구성 됩니다. 즉, 함수의 이름과 절 목록을 일치 시키려면 더미를 사용하여 &lt;code&gt;?Q(&quot;'@Name'() -&amp;gt; _@_@Body.&quot;)&lt;/code&gt; 와 같은 패턴을 사용해야합니다 . 몸이 하나의 구체 인 절.</target>
        </trans-unit>
        <trans-unit id="868fe4bcc51d9138e6ba286c24a2e7645d98dba4" translate="yes" xml:space="preserve">
          <source>constant_function(Set, AnySet) -&amp;gt; Function</source>
          <target state="translated">constant_function (Set, AnySet)-&amp;gt; 함수</target>
        </trans-unit>
        <trans-unit id="40a93e2052d430b04a53abcdf31c2cb66f0db6cd" translate="yes" xml:space="preserve">
          <source>consult(Filename) -&amp;gt; {ok, Terms} | {error, Reason}</source>
          <target state="translated">상담 (파일명)-&amp;gt; {ok, 약관} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="eb7be3b35349899105657b73d46c8a2a6b0a147a" translate="yes" xml:space="preserve">
          <source>controlling_process(Socket, Pid) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">controls_process (소켓, Pid)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="5413bf18b660beb63a8705ca9bd7f75ca073fc99" translate="yes" xml:space="preserve">
          <source>converse(BinRel1) -&amp;gt; BinRel2</source>
          <target state="translated">대화 (BinRel1)-&amp;gt; BinRel2</target>
        </trans-unit>
        <trans-unit id="4c51b3b7d029f9096880a2342e7cd2274f73bba5" translate="yes" xml:space="preserve">
          <source>cookie() -&amp;gt; Cookie</source>
          <target state="translated">cookie ()-&amp;gt; 쿠키</target>
        </trans-unit>
        <trans-unit id="aa965a0a2130653fda9de70c3838b549f500bcaf" translate="yes" xml:space="preserve">
          <source>cookie(TheCookie) -&amp;gt; true</source>
          <target state="translated">쿠키 (TheCookie)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="7221cc8b2793e13aa37ff0cb6363727d245cf4bb" translate="yes" xml:space="preserve">
          <source>copies(String, Number) -&amp;gt; Copies</source>
          <target state="translated">사본 (문자열, 숫자)-&amp;gt; 사본</target>
        </trans-unit>
        <trans-unit id="f4ff84890eb3dcf959cfcead8e0144d3cbdccd5f" translate="yes" xml:space="preserve">
          <source>copy(Source, Destination) -&amp;gt; {ok, BytesCopied} | {error, Reason}</source>
          <target state="translated">카피 (소스, 목적지)-&amp;gt; {ok, BytesCopied} | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="722ad3c44af17d2643ed48db612280941ca554c0" translate="yes" xml:space="preserve">
          <source>copy(Source, Destination, ByteCount) -&amp;gt;</source>
          <target state="translated">복사 (소스, 대상, ByteCount)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8c46fa4b3f52b532bd80970d91f53d17a0d49f87" translate="yes" xml:space="preserve">
          <source>copy(Subject) -&amp;gt; binary()</source>
          <target state="translated">복사 (제목)-&amp;gt; 이진 ()</target>
        </trans-unit>
        <trans-unit id="8fbd8d3517393e1202843686109660b5c218f5b1" translate="yes" xml:space="preserve">
          <source>copy(Subject, N) -&amp;gt; binary()</source>
          <target state="translated">복사 (제목, N)-&amp;gt; 이진 ()</target>
        </trans-unit>
        <trans-unit id="fddd2eda380d6a1ccb0d45dbcb86fe2fb2a78f8f" translate="yes" xml:space="preserve">
          <source>copy_config(Client, Target, Source) -&amp;gt; Result</source>
          <target state="translated">copy_config (클라이언트, 대상, 소스)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="3be000dd44b93adb33e1693489552e86b7852956" translate="yes" xml:space="preserve">
          <source>copy_config(Client, Target, Source, Timeout) -&amp;gt; Result</source>
          <target state="translated">copy_config (클라이언트, 대상, 소스, 타임 아웃)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="4add817c21dfd8c7dcde4a0acea5481c390272da" translate="yes" xml:space="preserve">
          <source>cos(X) -&amp;gt; float()</source>
          <target state="translated">cos (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="00303aaf549d37029a12de52351eefd2fb37df9a" translate="yes" xml:space="preserve">
          <source>cosh(X) -&amp;gt; float()</source>
          <target state="translated">cosh (X)-&amp;gt; float ()</target>
        </trans-unit>
        <trans-unit id="5671fcad1da572f4ff309116ad190117f1dd4a59" translate="yes" xml:space="preserve">
          <source>count_children(SupRef) -&amp;gt; PropListOfCounts</source>
          <target state="translated">count_children (SupRef)-&amp;gt; PropListOfCounts</target>
        </trans-unit>
        <trans-unit id="a28100fa6a50a3cbd5dd6b7e69b0a4377f855523" translate="yes" xml:space="preserve">
          <source>cover</source>
          <target state="translated">cover</target>
        </trans-unit>
        <trans-unit id="4503dda6ecc1ad84be6b48e5c91ec7463dc87e8d" translate="yes" xml:space="preserve">
          <source>cprof</source>
          <target state="translated">cprof</target>
        </trans-unit>
        <trans-unit id="3c4700346b947c9354233ace3f2dc1277ae1d3db" translate="yes" xml:space="preserve">
          <source>cpu_sup</source>
          <target state="translated">cpu_sup</target>
        </trans-unit>
        <trans-unit id="69f0dc7a59452c693c84898cc4b0c49ba48f638e" translate="yes" xml:space="preserve">
          <source>crashdump_viewer</source>
          <target state="translated">crashdump_viewer</target>
        </trans-unit>
        <trans-unit id="8d23adeb6032cb30af3f7099b72d75c3376cef0c" translate="yes" xml:space="preserve">
          <source>crc32(Z) -&amp;gt; CRC</source>
          <target state="translated">crc32 (Z)-&amp;gt; CRC</target>
        </trans-unit>
        <trans-unit id="8dd598ddf6c7cd2c6e391b8deeb50ac099fb52fa" translate="yes" xml:space="preserve">
          <source>crc32(Z, Data) -&amp;gt; CRC</source>
          <target state="translated">crc32 (Z, 데이터)-&amp;gt; CRC</target>
        </trans-unit>
        <trans-unit id="d5275fe18aa498a6dde3f717c5b459f7e326a108" translate="yes" xml:space="preserve">
          <source>crc32(Z, PrevCRC, Data) -&amp;gt; CRC</source>
          <target state="translated">crc32 (Z, PrevCRC, 데이터)-&amp;gt; CRC</target>
        </trans-unit>
        <trans-unit id="07d2cc56c134df4dc81e62e8380a5122b4be4d8d" translate="yes" xml:space="preserve">
          <source>crc32_combine(Z, CRC1, CRC2, Size2) -&amp;gt; CRC</source>
          <target state="translated">crc32_combine (Z, CRC1, CRC2, Size2)-&amp;gt; CRC</target>
        </trans-unit>
        <trans-unit id="0939ce4228d371ad665dfd0531d51ed12ce0a8ff" translate="yes" xml:space="preserve">
          <source>create(Name :: &lt;code&gt;&lt;a href=&quot;#type-name&quot;&gt;name()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; ok</source>
          <target state="translated">create (이름 :: &lt;code&gt;&lt;a href=&quot;#type-name&quot;&gt;name()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; ok</target>
        </trans-unit>
        <trans-unit id="3693efdc8fcd5cfda2bafd27ca11078a69f23ed5" translate="yes" xml:space="preserve">
          <source>create(Name, FileList) -&amp;gt; RetValue</source>
          <target state="translated">create (이름, FileList)-&amp;gt; RetValue</target>
        </trans-unit>
        <trans-unit id="79f61bb6b803e8d95bed1875fca88a422f68f430" translate="yes" xml:space="preserve">
          <source>create(Name, FileList, Options) -&amp;gt; RetValue</source>
          <target state="translated">create (이름, 파일 목록, 옵션)-&amp;gt; RetValue</target>
        </trans-unit>
        <trans-unit id="ca12b59a6ebaaed57ca8e04a38c3dea08c037b0f" translate="yes" xml:space="preserve">
          <source>create_subscription(Client,</source>
          <target state="translated">create_subscription(Client,</target>
        </trans-unit>
        <trans-unit id="c006a621f3dfb6c432072475343e8017ff961e89" translate="yes" xml:space="preserve">
          <source>create_subscription(Client, Stream, Filter, StartTime, StopTime) -&amp;gt;</source>
          <target state="translated">create_subscription (클라이언트, 스트림, 필터, StartTime, StopTime)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3461f46982b89f02655b3a55556b2498986cc228" translate="yes" xml:space="preserve">
          <source>creates a filter which performs a &lt;code&gt;caseExactMatch&lt;/code&gt; on the attribute &lt;code&gt;sn&lt;/code&gt; and matches with the value &lt;code&gt;&quot;Bar&quot;&lt;/code&gt;. The default value of &lt;code&gt;dnAttributes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;sn&lt;/code&gt; 에 대해 &lt;code&gt;caseExactMatch&lt;/code&gt; 를 수행하고 &lt;code&gt;&quot;Bar&quot;&lt;/code&gt; 값과 일치 하는 필터를 작성합니다 . &lt;code&gt;dnAttributes&lt;/code&gt; 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d7152f0f4a9a2c018578ec787fcd2393ed1f647" translate="yes" xml:space="preserve">
          <source>creates a fixed-size array of size 100, whose default value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">크기가 100 인 고정 크기 배열을 작성합니다 . 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a9a0b9272eab96ff64bb239d1c9f1ba201132279" translate="yes" xml:space="preserve">
          <source>creates a fixed-size array of size 100.</source>
          <target state="translated">크기가 100 인 고정 크기 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="63a39dacf0314736836446a6cf5cccaef43a631e" translate="yes" xml:space="preserve">
          <source>creates an empty, extendible array whose default value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">기본값이 &lt;code&gt;0&lt;/code&gt; 인 비어 있고 확장 가능한 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4acdf494cf79649d50f2f8820d92901866c22b00" translate="yes" xml:space="preserve">
          <source>creates an extendible array with initial size 10 whose default value is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">기본값이 &lt;code&gt;-1&lt;/code&gt; 인 초기 크기 10의 확장 가능한 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1210cdffc1810f2947084bec43397aa36018c6bf" translate="yes" xml:space="preserve">
          <source>critical</source>
          <target state="translated">critical</target>
        </trans-unit>
        <trans-unit id="0460f85644bb7c87eca38663e27fe804154dff93" translate="yes" xml:space="preserve">
          <source>critical conditions</source>
          <target state="translated">중요한 조건</target>
        </trans-unit>
        <trans-unit id="572c31ce6d04556dd6ff4f1c83f6e71fa3aedd6d" translate="yes" xml:space="preserve">
          <source>crl_reason()</source>
          <target state="translated">crl_reason()</target>
        </trans-unit>
        <trans-unit id="44a9713350e53858f058463d4bf7f1e542d9ca4b" translate="yes" xml:space="preserve">
          <source>crypto</source>
          <target state="translated">crypto</target>
        </trans-unit>
        <trans-unit id="838590eee32fc68f44cf5bceeb4da24441d46978" translate="yes" xml:space="preserve">
          <source>crypto_key_fun(CryptoKeyFun) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">crypto_key_fun (CryptoKeyFun)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="1f62b0a89bf4fcb5dc6c7e06ec998eeb34084a4c" translate="yes" xml:space="preserve">
          <source>cspan(String, Chars) -&amp;gt; Length</source>
          <target state="translated">cspan (문자열, 문자)-&amp;gt; 길이</target>
        </trans-unit>
        <trans-unit id="589e942e00a7dd64a273deb5041c7ce469f2bad7" translate="yes" xml:space="preserve">
          <source>ct</source>
          <target state="translated">ct</target>
        </trans-unit>
        <trans-unit id="6ee59c2355edd903c06745611fcc2a37002ce241" translate="yes" xml:space="preserve">
          <source>ct_cover</source>
          <target state="translated">ct_cover</target>
        </trans-unit>
        <trans-unit id="6a9c9f65bbe99f3450ba6f72efd86ade2cdb185d" translate="yes" xml:space="preserve">
          <source>ct_ftp</source>
          <target state="translated">ct_ftp</target>
        </trans-unit>
        <trans-unit id="a7ca1497e22192fb2a5ea410275301d5f7ab3c26" translate="yes" xml:space="preserve">
          <source>ct_hooks</source>
          <target state="translated">ct_hooks</target>
        </trans-unit>
        <trans-unit id="5c3e2499b133f6ead1697b8778baa3e63813f72b" translate="yes" xml:space="preserve">
          <source>ct_master</source>
          <target state="translated">ct_master</target>
        </trans-unit>
        <trans-unit id="a979fe410f41af35dfbd744b9e3149738798a918" translate="yes" xml:space="preserve">
          <source>ct_netconfc</source>
          <target state="translated">ct_netconfc</target>
        </trans-unit>
        <trans-unit id="ea8e0177c743a3ed1981aa66c63a7625205a8678" translate="yes" xml:space="preserve">
          <source>ct_property_test</source>
          <target state="translated">ct_property_test</target>
        </trans-unit>
        <trans-unit id="40353d30d48dbf9f957c48068895e6b1d6beff2b" translate="yes" xml:space="preserve">
          <source>ct_rpc</source>
          <target state="translated">ct_rpc</target>
        </trans-unit>
        <trans-unit id="a54cb600796fb43b2ed63876b13d9202d383c4f7" translate="yes" xml:space="preserve">
          <source>ct_run</source>
          <target state="translated">ct_run</target>
        </trans-unit>
        <trans-unit id="4d366bcf5339a96b748d8a4d4f1c8fe15535b23e" translate="yes" xml:space="preserve">
          <source>ct_slave</source>
          <target state="translated">ct_slave</target>
        </trans-unit>
        <trans-unit id="c6d7ee80c1ab363c37dffc39a230d7ec186e4350" translate="yes" xml:space="preserve">
          <source>ct_snmp</source>
          <target state="translated">ct_snmp</target>
        </trans-unit>
        <trans-unit id="8b0515c9d9eae90e7d070c3e8e20ab8c0c29eca3" translate="yes" xml:space="preserve">
          <source>ct_ssh</source>
          <target state="translated">ct_ssh</target>
        </trans-unit>
        <trans-unit id="21918137b9e95c6d1ae25919d8befad954fc22b7" translate="yes" xml:space="preserve">
          <source>ct_telnet</source>
          <target state="translated">ct_telnet</target>
        </trans-unit>
        <trans-unit id="c68581ff92d3440330845bbcf2b295dedef37bf6" translate="yes" xml:space="preserve">
          <source>ct_testspec</source>
          <target state="translated">ct_testspec</target>
        </trans-unit>
        <trans-unit id="9331b1637c234fdbdb120b56c6b183b34dd662ea" translate="yes" xml:space="preserve">
          <source>current_key(RegHandle) -&amp;gt; ReturnValue</source>
          <target state="translated">current_key (RegHandle)-&amp;gt; ReturnValue</target>
        </trans-unit>
        <trans-unit id="226f0b09fa6aa779ab590ef23d09cebd6daff686" translate="yes" xml:space="preserve">
          <source>cursor(QH) -&amp;gt; Cursor</source>
          <target state="translated">커서 (QH)-&amp;gt; 커서</target>
        </trans-unit>
        <trans-unit id="593270bf214c51284e0f73efd69329fd76678535" translate="yes" xml:space="preserve">
          <source>cursor(QH, Options) -&amp;gt; Cursor</source>
          <target state="translated">커서 (QH, 옵션)-&amp;gt; 커서</target>
        </trans-unit>
        <trans-unit id="fd41950e3989cfa35ed6d935ecb7ac40b30be32e" translate="yes" xml:space="preserve">
          <source>cyclic_strong_components(Digraph) -&amp;gt; [StrongComponent]</source>
          <target state="translated">cyclic_strong_components (Digraph)-&amp;gt; [StrongComponent]</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="ed441f2fcf2c9eab3035bccda4b5492e18ba1bb8" translate="yes" xml:space="preserve">
          <source>daeh(Q :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt;(Item)) -&amp;gt; Item</source>
          <target state="translated">daeh (Q :: &lt;code&gt;&lt;a href=&quot;#type-queue&quot;&gt;queue&lt;/a&gt;&lt;/code&gt; (항목))-&amp;gt; 항목</target>
        </trans-unit>
        <trans-unit id="a6aac24f7e7b52db7d71db304bb653afa0c4d667" translate="yes" xml:space="preserve">
          <source>daemon_info(Daemon) -&amp;gt; {ok, DaemonInfo} | {error, term()}</source>
          <target state="translated">daemon_info (Daemon)-&amp;gt; {ok, DaemonInfo} | {오류, 용어 ()}</target>
        </trans-unit>
        <trans-unit id="9884e793180c5a11c6e6744ab1bd2d33cb920524" translate="yes" xml:space="preserve">
          <source>daemons</source>
          <target state="translated">daemons</target>
        </trans-unit>
        <trans-unit id="1bd41877f2856c4d7b5bc551b1c51509f9f61a5b" translate="yes" xml:space="preserve">
          <source>data types</source>
          <target state="translated">데이터 타입</target>
        </trans-unit>
        <trans-unit id="1e8cc122f5326c3e32c633d431cb69c1554ebb0b" translate="yes" xml:space="preserve">
          <source>datasync(IoDevice) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">datasync (IoDevice)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="480c43d599389866caca24b63e1cdb9b26feb1c1" translate="yes" xml:space="preserve">
          <source>date() -&amp;gt; Date</source>
          <target state="translated">날짜 ()-&amp;gt; 날짜</target>
        </trans-unit>
        <trans-unit id="3495d4b1c222236a1a714a7ad463b6bc6da7fcaa" translate="yes" xml:space="preserve">
          <source>date_to_gregorian_days(Date) -&amp;gt; Days</source>
          <target state="translated">date_to_gregorian_days (날짜)-&amp;gt; 일</target>
        </trans-unit>
        <trans-unit id="e9c7ff77828297abcc3f386f6123f558bbdcb5fd" translate="yes" xml:space="preserve">
          <source>date_to_gregorian_days(Year, Month, Day) -&amp;gt; Days</source>
          <target state="translated">date_to_gregorian_days (년, 월, 일)-&amp;gt; 일</target>
        </trans-unit>
        <trans-unit id="717d89be8437a011121ff677ef23f35a22b2476e" translate="yes" xml:space="preserve">
          <source>datetime_to_gregorian_seconds(DateTime) -&amp;gt; Seconds</source>
          <target state="translated">datetime_to_gregorian_seconds (DateTime)-&amp;gt; 초</target>
        </trans-unit>
        <trans-unit id="85ceb65db6b54a8a2661a23da8563a3e21071829" translate="yes" xml:space="preserve">
          <source>day_of_the_week(Date) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-daynum&quot;&gt;daynum()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">day_of_the_week (Date)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-daynum&quot;&gt;daynum()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1498e9cfd850f15b3c5cdec224e2f22770ef2d5c" translate="yes" xml:space="preserve">
          <source>day_of_the_week(Year, Month, Day) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-daynum&quot;&gt;daynum()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">day_of_the_week (년, 월, 일)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-daynum&quot;&gt;daynum()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d58201c6a55c4d1c368f212ccb94ceab277b9ff" translate="yes" xml:space="preserve">
          <source>dbg</source>
          <target state="translated">dbg</target>
        </trans-unit>
        <trans-unit id="e2fdb7ab8eb295166247537e7c85222d5438e23d" translate="yes" xml:space="preserve">
          <source>dbg(3), &lt;code&gt;&lt;a href=&quot;eprof&quot;&gt;eprof&lt;/a&gt;&lt;/code&gt;(3), erlang(3), io(3), &lt;code&gt;&lt;a href=&quot;fprof_chapter&quot;&gt;Tools User's Guide&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">dbg (3), &lt;code&gt;&lt;a href=&quot;eprof&quot;&gt;eprof&lt;/a&gt;&lt;/code&gt; (3), erlang (3), io (3), &lt;code&gt;&lt;a href=&quot;fprof_chapter&quot;&gt;Tools User's Guide&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32faaecac742100f7753f0c1d0aa0add01b4046b" translate="yes" xml:space="preserve">
          <source>debug</source>
          <target state="translated">debug</target>
        </trans-unit>
        <trans-unit id="3875aa0d6dc0d110607bf7e5446ebf078a229c04" translate="yes" xml:space="preserve">
          <source>debug |</source>
          <target state="translated">디버그 |</target>
        </trans-unit>
        <trans-unit id="9e7b5d64ea9989cd1b08153ba7bf3bd3089e2a92" translate="yes" xml:space="preserve">
          <source>debug-level messages</source>
          <target state="translated">디버그 수준 메시지</target>
        </trans-unit>
        <trans-unit id="4a02794713dea1e5283e0616c74d612a5dfa98fc" translate="yes" xml:space="preserve">
          <source>debug_options(Options) -&amp;gt; [&lt;code&gt;&lt;a href=&quot;#type-dbg_opt&quot;&gt;dbg_opt()&lt;/a&gt;&lt;/code&gt;]</source>
          <target state="translated">debug_options (옵션)-&amp;gt; [ &lt;code&gt;&lt;a href=&quot;#type-dbg_opt&quot;&gt;dbg_opt()&lt;/a&gt;&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="5fbd02245cf700ea94d638c8d76924ecca52d330" translate="yes" xml:space="preserve">
          <source>debugger</source>
          <target state="translated">debugger</target>
        </trans-unit>
        <trans-unit id="0f695a04bca7839cd439ef3ea9c37b97bdc49f13" translate="yes" xml:space="preserve">
          <source>debugging the application (agent and/or manager)</source>
          <target state="translated">응용 프로그램 디버깅 (에이전트 및 / 또는 관리자)</target>
        </trans-unit>
        <trans-unit id="69272a8b10a81b9f33e74ccb9b7b088a0a5d9968" translate="yes" xml:space="preserve">
          <source>decode(Base64) -&amp;gt; Data</source>
          <target state="translated">디코드 (Base64)-&amp;gt; 데이터</target>
        </trans-unit>
        <trans-unit id="1b6e3dd68188945d5898f52f270bab1270b9ca82" translate="yes" xml:space="preserve">
          <source>decode_time.xls -&amp;gt; Decoding result</source>
          <target state="translated">decode_time.xls-&amp;gt; 디코딩 결과</target>
        </trans-unit>
        <trans-unit id="6ed7997a989982a21b6669116d26b7ce40ae6cd2" translate="yes" xml:space="preserve">
          <source>decode_to_string(Base64) -&amp;gt; DataString</source>
          <target state="translated">decode_to_string (Base64)-&amp;gt; DataString</target>
        </trans-unit>
        <trans-unit id="8c5b728310f6cc6fb390cbbc3362e37082750eb3" translate="yes" xml:space="preserve">
          <source>decode_unsigned(Subject) -&amp;gt; Unsigned</source>
          <target state="translated">decode_unsigned (제목)-&amp;gt; 부호없는</target>
        </trans-unit>
        <trans-unit id="4032615ba7b6706e201ec762c189d6a760b44be4" translate="yes" xml:space="preserve">
          <source>decode_unsigned(Subject, Endianness) -&amp;gt; Unsigned</source>
          <target state="translated">decode_unsigned (제목, 엔디안)-&amp;gt; 부호 없음</target>
        </trans-unit>
        <trans-unit id="6eea90a21ec183ceaf6537bb63f17e3b87e0aa83" translate="yes" xml:space="preserve">
          <source>deep_char_list(Term) -&amp;gt; boolean()</source>
          <target state="translated">deep_char_list (Term)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="dd9e69812156975a79d45ba93e8425c3e552c991" translate="yes" xml:space="preserve">
          <source>deep_latin1_char_list(Term) -&amp;gt; boolean()</source>
          <target state="translated">deep_latin1_char_list (Term)-&amp;gt; 부울 ()</target>
        </trans-unit>
        <trans-unit id="0a2043a236beefb84c7833e0c14a204dd1015616" translate="yes" xml:space="preserve">
          <source>default values for variables and table columns.</source>
          <target state="translated">변수 및 테이블 열의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6dfbeb579535756d1d833a63a52c983776c49a98" translate="yes" xml:space="preserve">
          <source>default(Array :: &lt;code&gt;&lt;a href=&quot;#type-array&quot;&gt;array&lt;/a&gt;&lt;/code&gt;(Type)) -&amp;gt; Value :: Type</source>
          <target state="translated">기본값 (배열 :: &lt;code&gt;&lt;a href=&quot;#type-array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; (유형))-&amp;gt; 값 :: 유형</target>
        </trans-unit>
        <trans-unit id="24fc0758faf135b15faa3e7ed222edb4629efb1d" translate="yes" xml:space="preserve">
          <source>default_algorithms() -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-algs_list&quot;&gt;algs_list()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">default_algorithms ()-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-algs_list&quot;&gt;algs_list()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b4dda4cea310b78c1709f2558a0a3dcdb5c76" translate="yes" xml:space="preserve">
          <source>default_encoding() -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-source_encoding&quot;&gt;source_encoding()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">default_encoding ()-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-source_encoding&quot;&gt;source_encoding()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24fe8b716f4cee62d59e332592f6b1465be6a64c" translate="yes" xml:space="preserve">
          <source>deflate(Z, Data) -&amp;gt; Compressed</source>
          <target state="translated">수축 (Z, 데이터)-&amp;gt; 압축</target>
        </trans-unit>
        <trans-unit id="c40affb1ff2ef7ca274ec90b460e9a78e7b62385" translate="yes" xml:space="preserve">
          <source>deflate(Z, Data, Flush) -&amp;gt; Compressed</source>
          <target state="translated">수축 (Z, 데이터, 플러시)-&amp;gt; 압축</target>
        </trans-unit>
        <trans-unit id="420e6e61b6ac2d62d6b4cc3381050d76fb47cc7a" translate="yes" xml:space="preserve">
          <source>deflateEnd(Z) -&amp;gt; ok</source>
          <target state="translated">deflateEnd (Z)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="ad20d26c4954672fcd9cb6b5244f2cdb650dc13f" translate="yes" xml:space="preserve">
          <source>deflateInit(Z) -&amp;gt; ok</source>
          <target state="translated">deflateInit (Z)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="a2160a91ca63bf9d640e3c87189169b341912d36" translate="yes" xml:space="preserve">
          <source>deflateInit(Z, Level) -&amp;gt; ok</source>
          <target state="translated">deflateInit (Z, 레벨)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="58074a17e59819ae62d4cffb30a109b7193a11d7" translate="yes" xml:space="preserve">
          <source>deflateInit(Z, Level, Method, WindowBits, MemLevel, Strategy) -&amp;gt;</source>
          <target state="translated">deflateInit (Z, 레벨, 메소드, WindowBits, MemLevel, 전략)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f351c0f6cf06fd17be25a82f9adbcf66f7ffc8f9" translate="yes" xml:space="preserve">
          <source>deflateParams(Z, Level, Strategy) -&amp;gt; ok</source>
          <target state="translated">deflateParams (Z, 레벨, 전략)-&amp;gt; ok</target>
        </trans-unit>
        <trans-unit id="bf0a216d1e2f3fd71a2bd8f6737431f06946ff1d" translate="yes" xml:space="preserve">
          <source>deflateReset(Z) -&amp;gt; ok</source>
          <target state="translated">deflateReset (Z)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="0fe1b3602c3f3f60389099d3bf77eb88024e998f" translate="yes" xml:space="preserve">
          <source>deflateSetDictionary(Z, Dictionary) -&amp;gt; Adler32</source>
          <target state="translated">deflateSetDictionary (Z, Dictionary)-&amp;gt; Adler32</target>
        </trans-unit>
        <trans-unit id="f87bec0d7c334b53e899e581233263600c1efe41" translate="yes" xml:space="preserve">
          <source>del_binding(Name, BindingStruct) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">del_binding (이름, BindingStruct)-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-binding_struct&quot;&gt;binding_struct()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdee6484dea620842afe59e404db9b4090eac326" translate="yes" xml:space="preserve">
          <source>del_dir(Dir) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">del_dir (Dir)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="f88864510fe211fc5c06668e2dd14806e61fa002" translate="yes" xml:space="preserve">
          <source>del_edge(G, E) -&amp;gt; true</source>
          <target state="translated">del_edge (G, E)-&amp;gt; 참</target>
        </trans-unit>
        <trans-unit id="5053f07646f0f8c2d66c6c91b8bc89ecc6491eb2" translate="yes" xml:space="preserve">
          <source>del_edges(G, Edges) -&amp;gt; true</source>
          <target state="translated">del_edges (G, Edges)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="a135948d159b865b2e61766eea72896bc56a01ce" translate="yes" xml:space="preserve">
          <source>del_element(Element, Ordset1) -&amp;gt; Ordset2</source>
          <target state="translated">del_element (요소, Ordset1)-&amp;gt; Ordset2</target>
        </trans-unit>
        <trans-unit id="3f74b0b41d4b9aa7f82f1ac81516fd2dd150a16d" translate="yes" xml:space="preserve">
          <source>del_element(Element, Set1) -&amp;gt; Set2</source>
          <target state="translated">del_element (요소, 세트 1)-&amp;gt; 세트 2</target>
        </trans-unit>
        <trans-unit id="75b4a6f0b1df38d883d973ee43133d3fba27d73d" translate="yes" xml:space="preserve">
          <source>del_lock(Id) -&amp;gt; true</source>
          <target state="translated">del_lock (Id)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="bdf5d61a3f3bd2cdc298e8fef3261d0df6d26c90" translate="yes" xml:space="preserve">
          <source>del_lock(Id, Nodes) -&amp;gt; true</source>
          <target state="translated">del_lock (Id, Nodes)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="d2fd4f55abcc9073604c7cdb39ba4f1ed8564f07" translate="yes" xml:space="preserve">
          <source>del_path(G, V1, V2) -&amp;gt; true</source>
          <target state="translated">del_path (G, V1, V2)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="9f055613ce1f9041de8d8abc2f51ca40c0c3fc60" translate="yes" xml:space="preserve">
          <source>del_path(NameOrDir) -&amp;gt; boolean() | {error, What}</source>
          <target state="translated">del_path (NameOrDir)-&amp;gt; 부울 () | {오류, 무엇}</target>
        </trans-unit>
        <trans-unit id="8fcfe56d7a102e441f45853cb70b06b1b873bab1" translate="yes" xml:space="preserve">
          <source>del_vertex(G, V) -&amp;gt; true</source>
          <target state="translated">del_vertex (G, V)-&amp;gt; 참</target>
        </trans-unit>
        <trans-unit id="c4939add0d83c5595ce2a244fc8c3a34dfcfd18d" translate="yes" xml:space="preserve">
          <source>del_vertices(G, Vertices) -&amp;gt; true</source>
          <target state="translated">del_vertices (G, 꼭짓점)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="fb037fd6d1547c90c58e89daee8c85d3f18a0955" translate="yes" xml:space="preserve">
          <source>delete(Elem, List1) -&amp;gt; List2</source>
          <target state="translated">삭제 (엘렘,리스트 1)-&amp;gt;리스트 2</target>
        </trans-unit>
        <trans-unit id="cef25e205a8a0f5849ef736b51130ea7797625bc" translate="yes" xml:space="preserve">
          <source>delete(Element, Set1) -&amp;gt; Set2</source>
          <target state="translated">delete (요소, 세트 1)-&amp;gt; 세트 2</target>
        </trans-unit>
        <trans-unit id="0528d49a9aff43b64f36d9f9a5fd041c8f99914a" translate="yes" xml:space="preserve">
          <source>delete(Filename) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">delete (파일 이름)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="9f78d23f87ddf3665524d25428353b83a1d66986" translate="yes" xml:space="preserve">
          <source>delete(G) -&amp;gt; true</source>
          <target state="translated">삭제 (G)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="400956421291c0d96e7149cfa77a838dacbc12d2" translate="yes" xml:space="preserve">
          <source>delete(Key, List) -&amp;gt; List</source>
          <target state="translated">삭제 (키,리스트)-&amp;gt;리스트</target>
        </trans-unit>
        <trans-unit id="7472210320372db8e8a5404de0ce4f05afc401a0" translate="yes" xml:space="preserve">
          <source>delete(Key, Tree1) -&amp;gt; Tree2</source>
          <target state="translated">삭제 (키, Tree1)-&amp;gt; Tree2</target>
        </trans-unit>
        <trans-unit id="fcb685d5c516624acc03cbb0ee674c772d0cb530" translate="yes" xml:space="preserve">
          <source>delete(Module) -&amp;gt; boolean()</source>
          <target state="translated">delete (모듈)-&amp;gt; boolean ()</target>
        </trans-unit>
        <trans-unit id="37567bdba3ea297c1e3affed20e0c961f0c74c08" translate="yes" xml:space="preserve">
          <source>delete(Name :: &lt;code&gt;&lt;a href=&quot;#type-name&quot;&gt;name()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; ok</source>
          <target state="translated">delete (Name :: &lt;code&gt;&lt;a href=&quot;#type-name&quot;&gt;name()&lt;/a&gt;&lt;/code&gt; )-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="19834de1d06b0cd464dd4b6c04a805e2cbbb8dd7" translate="yes" xml:space="preserve">
          <source>delete(Name, Key) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">delete (이름, 키)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="e9e3b290875459a0890d43e6a988565b5c30187a" translate="yes" xml:space="preserve">
          <source>delete(Tab) -&amp;gt; true</source>
          <target state="translated">delete (Tab)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="c311afe02eee5c96e16a1b51b071409cd0f0ab09" translate="yes" xml:space="preserve">
          <source>delete(Tab, Key) -&amp;gt; true</source>
          <target state="translated">삭제 (탭, 키)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="b5f982303bf3f25806b5c3ac6162cce5d193b3a9" translate="yes" xml:space="preserve">
          <source>delete_all_objects(Name) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">delete_all_objects (이름)-&amp;gt; 확인 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="0fdb85b5e4f053b3b2af86dc889e6a8f5dd8d7dc" translate="yes" xml:space="preserve">
          <source>delete_all_objects(Tab) -&amp;gt; true</source>
          <target state="translated">delete_all_objects (Tab)-&amp;gt; true</target>
        </trans-unit>
        <trans-unit id="38599d8ccdc4e48acbd6b58ac6cbe9f61f787b52" translate="yes" xml:space="preserve">
          <source>delete_any(Element, Set1) -&amp;gt; Set2</source>
          <target state="translated">delete_any (요소, 세트 1)-&amp;gt; 세트 2</target>
        </trans-unit>
        <trans-unit id="16f025b31f6ec89966b5ba51a122bb421a57e382" translate="yes" xml:space="preserve">
          <source>delete_any(Key, Tree1) -&amp;gt; Tree2</source>
          <target state="translated">delete_any (키, Tree1)-&amp;gt; Tree2</target>
        </trans-unit>
        <trans-unit id="a94f8d33e74fbae42bcd311b0985d6b193a70777" translate="yes" xml:space="preserve">
          <source>delete_child(SupRef, Id) -&amp;gt; Result</source>
          <target state="translated">delete_child (SupRef, Id)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="0ad9d5b97e7eeb60df24922a14bf6c0faf337050" translate="yes" xml:space="preserve">
          <source>delete_config(Client, Target) -&amp;gt; Result</source>
          <target state="translated">delete_config (클라이언트, 대상)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="03498a62d88d97056669e2fb8b1b5212ddd36925" translate="yes" xml:space="preserve">
          <source>delete_config(Client, Target, Timeout) -&amp;gt; Result</source>
          <target state="translated">delete_config (클라이언트, 대상, 시간 초과)-&amp;gt; 결과</target>
        </trans-unit>
        <trans-unit id="21a64cb57bd6c4d1f0adffb760a8b3f6c55dfe30" translate="yes" xml:space="preserve">
          <source>delete_cursor(QueryCursor) -&amp;gt; ok</source>
          <target state="translated">delete_cursor (QueryCursor)-&amp;gt; 확인</target>
        </trans-unit>
        <trans-unit id="8b6710b10e64178c8a46f162887d7e410c728ba4" translate="yes" xml:space="preserve">
          <source>delete_key(RegHandle) -&amp;gt; ReturnValue</source>
          <target state="translated">delete_key (RegHandle)-&amp;gt; ReturnValue</target>
        </trans-unit>
        <trans-unit id="b23d2978af16fdb552d14549ae1cec0e0b361e28" translate="yes" xml:space="preserve">
          <source>delete_module(Module) -&amp;gt; true | undefined</source>
          <target state="translated">delete_module (모듈)-&amp;gt; true | 찾으시는 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="50f77e0fc0819bb7ceddfe11960464daab7a15e1" translate="yes" xml:space="preserve">
          <source>delete_object(Name, Object) -&amp;gt; ok | {error, Reason}</source>
          <target state="translated">delete_object (이름, 개체)-&amp;gt; ok | {오류, 이유}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
