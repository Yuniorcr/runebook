<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 필드 의 ReferenceID와 CN 값 사이의 일치 조작의 경우 fun에 대한 첫 번째 인수는 ReferenceID에서 추출 된 호스트 이름이고 두 번째 인수는 &lt;code&gt;Subject&lt;/code&gt; 에서 가져온 튜플 &lt;code&gt;{cn, string()}&lt;/code&gt; 입니다. 들. 따라서 &lt;code&gt;Subject&lt;/code&gt; 필드와 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드 에서 제시된 ID에 대해 별도의 일치 규칙을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류 (예 : &lt;code&gt;addr_unreachable&lt;/code&gt; )의 경우 필드 &lt;code&gt;error&lt;/code&gt; 는 더 많은 진단을 제공합니다. 이 경우 이벤트 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 에서 반환 한 &lt;code&gt;error&lt;/code&gt; 용어로 자동 변환됩니다 . &lt;code&gt;error&lt;/code&gt; 필드 값을 사용하여 문자열로 변환 할 수있다 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">오류가 발생하면 모든 계측 기능이 SNMPv1 또는 SNMPv2 오류 코드를 반환 할 수 있습니다. SNMPv2 코드를 리턴하면 SNMPv1 관리자에게 전송되기 전에 SNMPv1 코드로 변환됩니다. 자세한 내용은 모든 계측 기능에 대해 SNMPv2 오류 코드를 사용하는 것이 좋습니다. 오류 코드 변환에 대한 설명은 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">목록의 경우 퍼센트 인코딩 만 있습니다. 그러나 바이너리에서는 바이너리 인코딩과 퍼센트 인코딩이 모두 고려됩니다. &lt;code&gt;transcode/2&lt;/code&gt; 는 지원되는 인코딩 사이를 변환하는 수단을 제공합니다. &lt;code&gt;uri_string()&lt;/code&gt; 및 인바운드 및 아웃 바운드 인코딩을 지정하는 옵션 목록이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">로드의 경우, 수 모니터링을 &lt;strong&gt;하지&lt;/strong&gt; 유일한 옵션을 사용하여 트리거 얻을 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; 뿐만 아니라로드 오류가 일시적인 특별한 경우. 따라서 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 는 기본적으로 &lt;strong&gt;모든&lt;/strong&gt; 실제 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 인증서 필드 에서 제시된 ID를 가져 오는 경우 이름에 와일드 카드 문자가 포함될 수 있습니다. 이 기능은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 정의 된대로이를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OctetString () 및 파생 유형에 대해 string () 및 binary () 유형 중에서 선택할 수있는 경우, 표현은 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; 의 값으로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">제목 문자열에 줄 바꿈이 포함되어 있지 않은 것으로 알려진 경우 &lt;code&gt;dotall&lt;/code&gt; 을 설정 하여이 최적화를 얻거나 ^을 사용하여 명시 적으로 앵커를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">표준 입력 및 / 또는 표준 출력을 리디렉션하거나 파이프 라인에서 Erlang을 사용하려는 경우 &lt;code&gt;werl&lt;/code&gt; 이 적합하지 않으며 &lt;code&gt;erl&lt;/code&gt; 프로그램이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">특정 출력 함수 및 쉘의 리턴 값 출력에서 ​​Erlang은 경험적으로 목록 및 이진에서 문자열 데이터를 감지하려고 시도합니다. 일반적으로 다음과 같은 상황에서 휴리스틱 탐지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">특정 상황에서, 특히 표준 출력이 리디렉션 될 때 오류 메시지에 특정한 I / O 서버에 대한 액세스가 편리 할 수 ​​있습니다. I / O 장치 &lt;code&gt;standard_error&lt;/code&gt; 를 사용하여 현재 운영 체제가 오류 출력에 적합한 I / O 장치로 간주하는 모든 항목으로 출력을 보낼 수 있습니다. 유닉스 계열 운영 체제의 예 :</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">와 결합 &lt;code&gt;{locations, true}&lt;/code&gt; 이 옵션은 각 항목에 대한 통계와 함께 잠금 작업 소스 파일과 줄 번호 엔트리 포인트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 옵션과 함께 각 종속성에 대한 가짜 대상을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 와 함께 생성 된 규칙의 이름을 &lt;code&gt;Target&lt;/code&gt; 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 옵션과 함께 누락 된 헤더를 생성 된 파일로 간주하여 종속성에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">RPC와 달리 다중 호출은 한 클라이언트에서 여러 서버로 동시에 전송되는 RPC입니다. 이는 노드 세트에서 정보를 수집하거나 일부 부작용을 달성하기 위해 노드 세트에서 함수를 호출하는 데 유용합니다. 의미 적으로 모든 노드에서 일련의 RPC를 반복적으로 만드는 것과 동일하지만 모든 요청이 동시에 전송되고 돌아올 때 하나씩 하나씩 수집되므로 다중 호출이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">대부분의 다른 콜백 함수와 &lt;code&gt;stop_select&lt;/code&gt; 는 모든 포트와 독립적으로 호출됩니다. &lt;code&gt;ErlDrvData&lt;/code&gt; 인수가 함수에 전달 되지 않았습니다 . 드라이버 잠금 또는 포트 잠금은 유지되지 않습니다. 라고하는 포트 &lt;code&gt;driver_select&lt;/code&gt; 가 도 시간에 마감 될 수 &lt;code&gt;stop_select&lt;/code&gt; 이 라고합니다. 그러나 &lt;code&gt;stop_select&lt;/code&gt; 가 &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 에 의해 직접 호출 되는 경우도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">대조적으로, 번호가 매겨진 서브 패턴에 대한 서브 루틴 호출은 항상 주어진 번호를 가진 패턴에서 첫 번째를 참조합니다. 다음 패턴은 &quot;abcabc&quot;또는 &quot;defabc&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">크래시 덤프에서는 스택, 메시지 및 프로세스 사전이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">더티 컨텍스트, 즉 &lt;code&gt;sync_dirty&lt;/code&gt; 또는 &lt;code&gt;async_dirty&lt;/code&gt; 에서 수정 된 레코드는 로컬 사본에 저장되지 않습니다. 대신 각 레코드가 개별적으로 업데이트됩니다. 테이블에 다른 노드에 복제본이 있고 더티 작업에 발생하는 다른 모든 단점이있는 경우 많은 네트워크 트래픽이 생성됩니다. 특히 &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; 명령의 경우 , &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; 에 대해 이전에 설명한 것과 동일한 단점이 적용됩니다. 즉, 반복 중에 테이블에 대한 쓰기는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">각 &lt;code&gt;Viewer&lt;/code&gt; 에는 활성 필터가 하나만 있으며, &lt;code&gt;Collector&lt;/code&gt; 에서 &lt;code&gt;Viewer&lt;/code&gt; 가 가져 오는 모든 추적 &lt;code&gt;Events&lt;/code&gt; 는 해당 필터를 통해 전달됩니다. 영리한 필터를 작성 하면 뷰어에서 &lt;code&gt;Events&lt;/code&gt; 가 표시되는 방식을 사용자 정의 할 수 있습니다 . &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; 의 다음 필터 는 액터 이름 &lt;code&gt;mnesia_tm&lt;/code&gt; 및 &lt;code&gt;mnesia_locker&lt;/code&gt; 를 대체 하고 레코드에 다른 모든 것을 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">각 반복에서 바이너리의 처음 8 비트는 건너 뛰지 않고 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">이전 Erlang / OTP 릴리스에서 너무 큰 바이너리에 대한 작업은 일반적으로 실패하거나 잘못된 결과를 제공합니다. 다음 릴리스에서는 바이너리를 만드는 다른 작업 (예 : &lt;code&gt;list_to_binary/1&lt;/code&gt; )도 같은 제한을 적용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">두 경우 모두 에이전트는 아무 것도 수행하지 않지만 검색된 ManagerEngineID를 반환하고 ( 자세한 정보 는 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 참조 ) 감지 프로세스의 2 단계를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">내장 모드에서는 모든 스크립트가 부팅 스크립트에 따라 시스템 시작 중에로드됩니다. 나중에 코드 서버에 명시 적으로 주문하여 코드를로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">내장 모드에서는 먼저 모든 모듈이로드됩니다. 그런 다음 모든 &lt;code&gt;on_load&lt;/code&gt; 함수가 호출됩니다. 모든 &lt;code&gt;on_load&lt;/code&gt; 함수가 &lt;code&gt;ok&lt;/code&gt; 를 반환 하지 않으면 시스템이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">내장 모드에서는 모듈이 자동으로로드되지 않습니다. 로드되지 않은 모듈을 사용하려고하면 오류가 발생합니다. 이 모드는 부트 스크립트가 일반적으로 OTP 릴리스에서 수행되므로 모든 모듈을로드 할 때 권장됩니다. 코드 서버에서 명시 적으로 주문하여 나중에 코드를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RAM이 적고 가상 메모리가없는 내장 시스템에서는 &lt;code&gt;Number&lt;/code&gt; 를 0 으로 설정 하여 메모리를 보존 할 수 있습니다 . (값은 전체적으로 설정할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">본질적으로, 함수는 동일한 동작을 수행 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 을 하지만, 대신에 사용하는 &lt;code&gt;ei_x_buff&lt;/code&gt; 를 함수는 문자 포인터 (포인터 기대 &lt;code&gt;mbufp&lt;/code&gt; 문자 포인터에 의해 할당 된 메모리 영역에 점이다) &lt;code&gt;malloc&lt;/code&gt; . 인수 &lt;code&gt;bufsz&lt;/code&gt; 는 메모리 영역의 정확한 크기 (바이트)를 포함하는 정수에 대한 포인터입니다. 이러한 경우에 메모리 영역과 의지를 재 할당 할 수있는 기능은 새 크기를 넣어 &lt;code&gt;*bufsz&lt;/code&gt; 및 업데이트 &lt;code&gt;*mbufp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">&lt;code&gt;DocumentRoot&lt;/code&gt; 또는 &lt;code&gt;Alias&lt;/code&gt; 아래의 모든 디렉토리에서 사용자는 액세스 파일을 배치 할 수 있습니다. 액세스 파일은 웹 서버가 요청에 응답하기 전에 고려해야 할 제한 사항을 지정하는 일반 텍스트 파일입니다. 요청 된 자산의 경로에 둘 이상의 액세스 파일이있는 경우 자산에 가장 가까운 디렉토리에있는 액세스 파일의 지시문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">실제로 임의의 데이터가 캐시되므로 시도하면 일부 숫자가 재생산 될 수 있지만 이는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">운 좋게도 불일치는 특정 응용 프로그램에 속하는 테이블에서만 볼 수 있습니다. 그러나 강제 트랜잭션 복구 결정으로 인해 스키마 트랜잭션이 일관되지 않게 복구되면 불일치의 영향이 치명적일 수 있습니다. 그러나 높은 우선 순위가 일관성이 아닌 가용성 인 경우 위험 할만한 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">일반적으로 버그는 최신 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; 에서만 수정 되며 새로운 기능은 개발중인 다음 릴리스에 도입되었습니다. 그러나 내부 이유로 인해 이전 릴리스의 버그를 수정하면 해당 버그도 사용 가능하고 발표됩니다.</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">일반적으로 일치하는 값이 할당되지 않은 하위 패턴은 &lt;code&gt;type&lt;/code&gt; 이 &lt;code&gt;index&lt;/code&gt; 일 때 튜플 &lt;code&gt;{-1,0}&lt;/code&gt; 로 반환됩니다 . 할당되지 않은 하위 패턴은 다른 반환 유형에 대해 각각 빈 이진 또는 목록으로 반환됩니다. 다음 정규식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">일반적으로 시간 초과를 사용하여 분산 Erlang 시스템의 일부를 감독하는 것보다 더 나은 방법이 있습니다. 시간 초과는 일반적으로 외부 이벤트를 감독하는 데 적합합니다 (예 : 지정된 시간 내에 일부 외부 시스템에서 메시지를 예상 한 경우). 예를 들어, 사용자가 메신저 시스템에 액세스하지 않은 경우 (예 : 10 분) 시간 초과를 사용하여 메신저 시스템에서 로그 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">일반적으로 튜플은 &quot;레코드&quot;또는 &quot;구조체&quot;가 다른 언어로 사용되는 경우에 사용됩니다. 또한, 크기는 다양한 크기, 즉 링크 된 목록이 다른 언어로 사용되는 것을 나타낼 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">일반적으로 버전은 3 개 이상의 부분을 가질 수 있습니다. 그런 다음 버전은 부분적으로 만 주문됩니다. 이러한 버전은 예외적 인 경우에만 사용됩니다. 추가 부품 (일반 3 개 부품 중)이 버전 번호에 추가되면 새 버전의 분기가 작성됩니다. 새 브랜치는 기본 버전에 대해 선형 순서를 갖습니다. 그러나 다른 브랜치의 버전은 순서가 없으므로 가장 가까운 공통 조상에 포함 된 내용이 모두 포함되어 있다고 결론을 내릴 수 있습니다. 동일한 기본 버전에서 여러 번 분기하는 경우 고유 버전을 찾을 때까지 기본 버전과 최하위 &lt;code&gt;1&lt;/code&gt; 개 부품 사이에 &lt;code&gt;0&lt;/code&gt; 개의 부품이 추가 됩니다. 순서가있는 버전은 이전 단락에서 설명한대로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">글로벌 추적 모드에서 콜렉터는 연결된 모든 Erlang 노드에서 자동으로 추적을 시작합니다. 노드가 연결되면 해당 노드에서 포트 추적기가 시작되고 콜렉터 노드에서 해당 추적 클라이언트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">대화식 모드에서 코드는 처음 참조 할 때 동적으로로드됩니다. 모듈에서 함수를 호출하고 모듈이로드되지 않으면 코드 서버는 코드 경로를 검색하여 모듈을 시스템에로드합니다.</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">대화식 모드에서 코드 서버 는 디렉토리 목록으로 구성된 검색 경로 (일반적으로 &lt;strong&gt;코드 경로)를&lt;/strong&gt; 유지 보수합니다.이 경로 는 모듈을로드하려고 할 때 순차적으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">대화식 모드 (기본값)에서는 시스템 시작 중에 기본적으로 런타임 시스템에 필요한 모듈 중 일부 코드 만로드됩니다. 다른 코드는 처음 참조 할 때 동적으로로드됩니다. 특정 모듈에서 함수를 호출하고 모듈이로드되지 않으면 코드 서버는 모듈을 검색하여로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">가장 간단한 형식에서 &lt;code&gt;match_spec&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">로컬 모드에서 코드는 현재 노드에서만 해석됩니다. 전역 모드에서 코드는 알려진 모든 노드에서 해석됩니다. 해석 된 코드를 실행하는 다른 노드의 프로세스는 모니터 창에 자동으로 표시되며 다른 디버깅 된 프로세스와 마찬가지로 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">메모리 부족 시스템 (특히 가상 메모리가없는 시스템)에서 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하면 메모리를 절약하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">많은 응용 프로그램에서 트랜잭션 처리 오버 헤드로 인해 성능이 저하 될 수 있습니다. 더티 작업은 많은 처리를 우회하고 트랜잭션 속도를 높이는 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">많은 시스템에서 오버로드 된 큐의 임시 상태는 정상입니다. 이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 한다고해서 다른 노드가 응답하지 않는 것은 아니지만 일시적인 과부하 일 수 있습니다. 또한 반환 값이 &lt;code&gt;true&lt;/code&gt; 인 것은 차단없이 (TCP) 채널에서 메시지를 보낼 수 있다는 의미 일뿐입니다. 메시지가 원격 노드에 도착한다고 보장되지는 않습니다. 연결이 끊긴 비 응답 노드의 경우 반환 값은 &lt;code&gt;true&lt;/code&gt; 입니다 (연산자 &lt;code&gt;!&lt;/code&gt; 의 동작과 유사 함 ). 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때 예상되는 동작 및 수행 할 작업 은 응용 프로그램 및 하드웨어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">일치하는 경우이 기본값은 마지막 요소에만 유효합니다. 일치하는 다른 모든 비트 문자열 또는 이진 요소의 크기 사양이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">마이크로 초</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_none&lt;/code&gt; 모드 에서 기본 동작은 모든 x509 경로 유효성 검사 오류를 허용하는 것입니다. 또한 &lt;code&gt;verify_fun&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">보다 기술적 인 용어로, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 는 프로세스의 호출 스택을 버리고 가비지가 프로세스를 수집합니다. 이후 모든 라이브 데이터는 하나의 연속 힙에 있습니다. 그런 다음 힙은 보유하고있는 라이브 데이터와 정확히 동일한 크기로 축소됩니다 (해당 크기가 프로세스의 최소 힙 크기보다 작더라도).</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 주소 계열을 사용할 수있는 대부분의 API 함수에서 포트 번호는 &lt;code&gt;0&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;RootDir&lt;/code&gt; 매개 변수는 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (또는 구성 매개 변수가 설정되지 않은 경우 &lt;code&gt;code:root_dir()&lt;/code&gt; 호출에 사용 된 &lt;code&gt;root_dir&lt;/code&gt; 구성 매개 변수 와 동일하게 설정해야합니다 . 경우에 따라 다른 루트 디렉토리에 대해 동일한 대상 사양을 평가하는 것이 유용 할 수 있습니다. 그러나 모든 루트에서 동등한 파일 구조가 필요하므로 매우주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">일반 모드에서 사용자의 키 입력은 &lt;code&gt;tty&lt;/code&gt; 에 의해 수집되고 해석됩니다 . 대부분의 &lt;strong&gt;Emacs&lt;/strong&gt; 라인 편집 명령이 지원됩니다. 다음은 지원되는 라인 편집 명령의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">정상적인 작동에서 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 통화는 거의 무료입니다. 추적이 필요한 경우 이러한 기능에 대한 추적을 명시 적으로 활성화 할 수 있습니다. 또는 당신의 사용을 결합 할 수 있습니다 &lt;code&gt;trace_global&lt;/code&gt; 을 의 사용과 &lt;code&gt;trace_pattern&lt;/code&gt; . 설정하면 &lt;code&gt;trace_pattern&lt;/code&gt; 이 연결된 모든 노드에서 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">구현에서 향상된 SNMPv2 오류 코드를 완전히 활용하려면 오류가 발생할 경우 계측 기능이 항상 SNMPv2 오류 코드를 반환해야합니다. 필요한 경우 에이전트가 해당 SNMPv1 오류 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Erlang 드라이버 스레드 API가 작동하려면 런타임 시스템에서 스레드 지원이 사용 가능해야합니다. Erlang 드라이버는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드 지원이 사용 가능한지 확인할 수 있습니다 . Erlang 드라이버 API의 일부 기능은 런타임 시스템이 SMP를 지원하는 경우에만 스레드로부터 안전하며 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 통해이 정보를 검색 할 수 있습니다 . 또한 통지 얼랭 드라이버 API의 많은 기능이 있다고 &lt;strong&gt;하지&lt;/strong&gt; 관계없이 SMP 지원이 활성화되어 있는지의 여부, 스레드 안전합니다. 함수가 스레드 안전으로 문서화되지 않은 경우 스레드 안전 상태가 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">중단 / 계속 기능이 작동 하려면 &lt;code&gt;Common Test&lt;/code&gt; &lt;code&gt;stdin&lt;/code&gt; 을 제어하는 쉘 프로세스를 해제해야합니다 . 시작 옵션 &lt;code&gt;release_shell&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하면됩니다 . 자세한 내용 은 사용자 안내서 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 에서 테스트 실행 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 스케줄러를 바인드 할 수 있으려면 CPU 토폴로지를 알아야합니다. 런타임 시스템이 CPU 토폴로지를 자동으로 감지하지 못하면 정의 할 수 있습니다. CPU 토폴로지를 정의하는 방법에 대한 자세한 내용 은 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 플래그 &lt;code&gt;+sct&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">이 기능이 제대로 작동하려면 다음 두 가지 요구 사항이 충족되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">이 데이터를 motorcycles.xml 문서의 끝에 추가하려면 파일을 구문 분석하고 루트 요소 컨텐츠의 끝에 데이터를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Erlang 코드를 컴파일하려면 작은 Erlang 부트 스트랩 시스템을 구축해야하거나, 구축 된 시스템과 동일한 릴리스의 Erlang / OTP 시스템을 &lt;code&gt;$PATH&lt;/code&gt; 제공해야합니다 . 대상 시스템의 Erlang / OTP는이 Erlang 시스템을 사용하여 제공된 크로스 컴파일 도구와 함께 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">내부 형식을 완전히 이해하려면 Megaco / H.248 프로토콜에 대한 ASN.1 사양을 유지하고 위의 규칙을 적용해야합니다. ASN.1과 해당 내부 형식 간의 매핑 시맨틱에 대한 자세한 내용은 Erlang / OTP의 ASN.1 컴파일러 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">추적을 더욱 단순화하기 위해 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 함수를 사용할 수 있습니다 . 이러한 기능은 응용 프로그램에 강조 표시해야 할 흥미로운 &lt;code&gt;Events&lt;/code&gt; 가있을 때 다른 응용 프로그램에서 호출하기위한 것 입니다. 원자를 돌려주는 것 외에는 아무것도하지 않기 때문에 함수는 매우 가볍습니다. 이러한 기능은 특별히 추적하도록 설계되었습니다. 호출자가 명시 적으로 &lt;code&gt;Event Record&lt;/code&gt; 필드 의 값을 제공하므로 기본 &lt;code&gt;Collector Filter&lt;/code&gt; 는 사용자 정의 필터 기능없이 사용자 정의 된 &lt;code&gt;Event Record&lt;/code&gt; 를 자동으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">외부 참조를 쉽게 사용할 수 있도록하기 위해 몇 가지 일반적인 작업을 수행하는 사전 정의 된 분석이 있습니다. 일반적으로 정의되지 않은 함수에 대한 호출을 모듈 또는 릴리스에서 확인할 수 있습니다. 다소 고급 사용자에게는 분석 된 시스템의 일부를 선택하고 선택된 통화에 대한 간단한 그래프 분석을 수행하는 데 사용할 수있는 작지만 융통성있는 언어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">초기 메시지, 서비스 변경 요청의 전송을 위해 MG를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">초기 메시지, 서비스 변경 요청을 수신하기 위해 MGC를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">MG 및 MGC의 확장 가능한 구현을위한 솔루션을 제공하기 위해 사용자는 여러 Erlang 노드에 분산 될 수 있습니다. Erlang 노드 중 하나가 실제 네트워크 인터페이스에 연결되어 있지만 다른 노드에서 메시지가 전송 될 수 있으며 응답은 자동으로 원래 노드로 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">의 본격 비교 정보 참조하기 위해서는 &lt;code&gt;Event&lt;/code&gt; 는 클릭 수 &lt;code&gt;Event&lt;/code&gt; [시작하기 위해 &lt;code&gt;Contents Viewer&lt;/code&gt; 그것을 위해 &lt;code&gt;Event&lt;/code&gt; . 에서 &lt;code&gt;Contents Viewer&lt;/code&gt; 가도 검사 할 수있는 필터 메뉴입니다 &lt;code&gt;Event&lt;/code&gt; 뷰어에서 선택한 것과 다른 뷰에서입니다. 온 딸깍 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; 원인이됩니다 &lt;code&gt;Contents Viewer&lt;/code&gt; 게재하며, 팝업 창을 &lt;code&gt;Event&lt;/code&gt; 에 &lt;code&gt;mgr_actors&lt;/code&gt; 보기 :</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">태그 시스템을 사용하려면 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 작성해야합니다. 파일은 프로젝트의 모든 파일에있는 모든 기능, 레코드 및 매크로에 대한 데이터베이스로 볼 수 있습니다. &lt;code&gt;TAGS&lt;/code&gt; 파일은 얼랑에 대한 두 가지 다른 방법을 사용하여 만들 수 있습니다. 첫 번째는 표준 Emacs 유틸리티 &quot;etags&quot;이고 두 번째는 Erlang 모듈 &lt;code&gt;tags&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">측정 결과 ASN.1 BER과 간단한 텍스트 형식간에 메시지 크기에 큰 차이가 없음을 확인했습니다. 예쁜 텍스트 스타일 (프로토콜 사양에 포함되어 있고 디버깅 세션 중에 선호되는 모든 예제에서 사용됨)을 사용할 때는 메시지가 상당히 클 수 있으므로주의해야합니다. 메시지 크기가 실제로 심각한 문제인 경우 ASN.1 PER 형식이 다른 모든 대안보다 훨씬 컴팩트하므로 인코더 당 인코더를 사용해야합니다. 주요 단점은 유효한 Megaco / H.248 메시지 인코딩으로 승인되지 않았다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">실제로, 객체 세트는 일반적으로 확장 가능한 것으로 선언되어 나중에 더 많은 객체를 세트에 추가 할 수 있습니다. 확장 성은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">이전 버전의 &lt;code&gt;file&lt;/code&gt; 에서 모드는 목록 대신 원자 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 중 하나로 지정되었습니다 . 이전 버전과의 호환성을 위해 여전히 허용되지만 새 코드에는 사용되지 않습니다. 또한 &lt;code&gt;read_write&lt;/code&gt; 는 모드 목록에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">원칙적으로이 함수 는 &lt;code&gt;spawn&lt;/code&gt; 을 통해 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수를 호출 하여 실제 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">클라이언트 시작 재협상을 지원하는 프로토콜에서 이러한 작업의 자원 비용은 클라이언트보다 서버에 더 높습니다. 이는 서비스 거부 공격을위한 벡터 역할을 할 수 있습니다. SSL 응용 프로그램은 이미 이러한 시도에 대응하기위한 조치를 취하고 있지만이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 클라이언트 시작 재협상을 엄격히 비활성화 할 수 있습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 재협상을 비활성화하면 기본 암호 제품군이 암호화 할 수있는 메시지 수의 제한으로 인해 장기 연결을 사용할 수 없게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">드문 경우이지만이 기능은 Unix에서 실패 할 수 있습니다. 현재 디렉토리의 상위 디렉토리에 대한 읽기 권한이없는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">실제로 데이터 모델은 거의 정규화되지 않습니다. 정규화 된 데이터베이스 모델에 대한 현실적인 대안은 첫 번째 정규 형식이 아닌 데이터 모델입니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 유연한 방식으로 데이터를 쉽게 구성 할 수 있기 때문에 통신과 같은 애플리케이션에 적합합니다. &lt;code&gt;Mnesia&lt;/code&gt; 의 데이터베이스는 항상 테이블의 집합으로 구성되어있다. 각 테이블은 행, 개체 및 레코드로 채워집니다. 어떤 설정 &lt;code&gt;Mnesia&lt;/code&gt; 을 분리하는 것은 레코드의 개별 필드가 복합 데이터 구조의 모든 유형을 포함 할 수 있다는 것입니다. 레코드의 개별 필드에는 목록, 튜플, 함수 및 레코드 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">시나리오 1에서 테스트 케이스 프로세스 는 &lt;code&gt;case A&lt;/code&gt; 가 오류를 감지하지 않고 테스트 코드 실행을 완료 한 후 정상적으로 종료됩니다 . 테스트 케이스 함수는 값을 리턴하고 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 케이스를 성공으로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">시나리오 2에서 테스트 &lt;code&gt;case B&lt;/code&gt; 실행 중에 오류가 감지되었습니다 . 이로 인해 테스트 &lt;code&gt;case B&lt;/code&gt; 함수가 예외를 생성하고 결과적으로 테스트 케이스 프로세스가 정상 이외의 이유로 종료됩니다. &lt;code&gt;Common Test&lt;/code&gt; 는 이를 실패한 (실패한) 테스트 사례로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신화에 대한 섹션에서 다음과 같은 신화가 드러났습니다. &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">간단히 말해 &lt;code&gt;DebugType&lt;/code&gt; 은 디버깅 전용입니다. 생산 중 로그는 표준 Erlang 로깅 기능으로 더 잘 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">일부 응용 프로그램에서는 개별 로그의 회신이 무시되는 것이 허용되지 않을 수 있습니다. 이러한 상황에 대한 대안은 하나의 분산 디스크 로그 대신 많은 로컬 디스크 로그를 사용하고 &lt;code&gt;disk_log&lt;/code&gt; 모듈 을 사용하지 않고 분배를 구현하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">몇몇 양상들에서, Erlang MIB 컴파일러는 SMI를 완전히 따르거나 구현하지 않는다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">일부 측면에서 에이전트는 SNMP를 완전히 구현하지 않습니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">경우에 따라 Erlang 구문 규칙을 사용하면 원하는 곳에 메타 변수를 직접 배치 할 수 없습니다. 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">경우에 따라 선택 / 일치 작업이 전체 테이블을 스캔하지 않아도됩니다. 예를 들어, &lt;code&gt;ordered_set&lt;/code&gt; 테이블을 검색 할 때 키의 일부가 바인드 되거나 Mnesia 테이블이고 선택 / 일치되는 필드에 보조 인덱스가있는 경우. 키가 완전히 바인드 된 경우 백 테이블이없고 특정 키가있는 요소의 서브 세트에만 관심이없는 경우 선택 / 일치를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">일부 컨텍스트에서는 문자열 또는 정수만 허용됩니다. 예를 들어, 지시문 &lt;code&gt;-file(Name, Line)&lt;/code&gt; 하려면 &lt;code&gt;Name&lt;/code&gt; 은 문자열 리터럴이고 &lt;code&gt;Line&lt;/code&gt; 은 정수 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; 상태 에서 버튼을 누르면 마지막으로 누른 버튼을 올바른 코드 길이까지 수집하여 올바른 코드와 비교합니다. 결과에 따라 도어가 잠금 해제되고 &lt;code&gt;gen_statem&lt;/code&gt; 이 &lt;code&gt;open&lt;/code&gt; 상태가 되거나 도어가 &lt;code&gt;locked&lt;/code&gt; 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">state &lt;code&gt;open&lt;/code&gt; 상태 에서 버튼 이벤트는 동일한 상태를 유지하여 무시됩니다. 이것은 또한 반환하여 수행 할 수 있습니다 &lt;code&gt;{keep_state, Data}&lt;/code&gt; 또는 이후이 경우 &lt;code&gt;Data&lt;/code&gt; 반환하여 변경도 &lt;code&gt;keep_state_and_data&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">많은 프로세스가있는 시스템에서 짧은 시간 동안 실행되는 계산 작업을 최소 힙 크기가 더 높은 새 프로세스로 생성 할 수 있습니다. 프로세스가 완료되면 계산 결과를 다른 프로세스로 보내고 종료합니다. 최소 힙 크기가 올바르게 계산되면 프로세스에서 가비지 콜렉션을 전혀 수행하지 않아도됩니다. &lt;strong&gt;적절한 측정 없이는이 최적화를 시도하지 않아야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">통신 애플리케이션에서는 기존 DBMS에서 제공하는 기능과는 다른 요구가 있습니다. 현재 Erlang으로 구현 된 애플리케이션에는 광범위한 기능이 혼합되어있어 일반적으로 기존 DBMS에서는 충족되지 않습니다. Mnesia는 다음과 같은 요구 사항을 염두에두고 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">Erlang의 32 비트 구현에서 536,870,911 바이트는 비트 구문을 사용하여 구성하거나 일치시킬 수있는 가장 큰 바이너리입니다. 64 비트 구현에서 최대 크기는 2,305,843,009,213,693,951 바이트입니다. 제한이 초과되면 비트 구문 구성은 &lt;code&gt;system_limit&lt;/code&gt; 예외로 실패하고 너무 큰 이진 파일과 일치하려는 시도는 실패합니다. 이 제한은 R11B-4부터 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">에서 &lt;code&gt;MatchBody&lt;/code&gt; 및 &lt;code&gt;MatchCondition&lt;/code&gt; 부품, 이전에 바인딩 변수 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">에서 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 의 부분에는 바인드 변수이므로, 허용되는 &lt;code&gt;'_'&lt;/code&gt; 자체 (원자)로서 해석된다. 변수는 &lt;code&gt;MatchHead&lt;/code&gt; 부분 에만 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">에서 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 의 부품, 해석은 서로 다른 몇 가지 방법입니다. 이 부분의 리터럴은 튜플을 제외한 모든 리터럴에 대해 작동하는 &quot;있는 그대로&quot;또는 특수 양식 &lt;code&gt;{const, T}&lt;/code&gt; 를 사용하여 작성할 수 있습니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">에서 &lt;code&gt;MatchHead&lt;/code&gt; 의 부분 (위의 변수를 제외한) 모든 리터럴 &quot;그대로&quot;해석된다.</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;do_perm&lt;/code&gt; 우리는 할당 된 구조에서 작동하는 일을 &lt;code&gt;output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">위의 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 예제 에서 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 을 소스 코드 에 포함 시켜야 합니다 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 유효한 일치 스펙 에 대한 ets : fun2ms / 1 호출 의 구문 분석 변환을 트리거하기 때문 입니다. 이는 또한 컴파일시 변환이 수행되고 (쉘에서 호출 된 경우 제외) 런타임에 리소스를 사용하지 않음을 의미합니다. 즉,보다 직관적 인 재미있는 구문을 사용하더라도 직접 일치 스펙을 작성하는 것만 큼 런타임에서 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; 기능은 C 프로그램이 선택된 부호화에있어서, 얼랑로부터 메시지를 수신하고 인 / 디코딩 방식, 전화 기능에 인수 번째 바이트되는 함수 결정하는 첫 번째 바이트를 사용한다. 함수를 호출 한 결과는 Erlang으로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">에서 &lt;code&gt;ready_async&lt;/code&gt; 함수 출력 에뮬레이터로 다시 보내진다. &lt;code&gt;ei&lt;/code&gt; 대신 드라이버 용어 형식을 사용합니다 . 이것은 Erlang 코드가 &lt;code&gt;binary_to_term/1&lt;/code&gt; 을 호출하지 않고도 Erlang 용어를 드라이버로 직접 보내는 유일한 방법 입니다. 간단한 예제에서 이것은 잘 작동 하며 이진 용어 형식을 처리 하기 위해 &lt;code&gt;ei&lt;/code&gt; 를 사용할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">Megaco의 API에서 사용자는 작업 요청을 명시 적으로 보낼 수 있지만, 트랜잭션 식별자 생성, 원격 사용자에 대한 메시지의 인코딩 및 실제 전송은 실제 연결 구성에 따라 프로토콜 엔진에 의해 자동으로 처리됩니다. Megaco 메시지는 API에 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">Erlang 런타임 시스템에서 스케줄러가 여러 개인 경우에만 엔티티가 병렬로 실행됩니다. 따라서 &lt;code&gt;lcnt&lt;/code&gt; 는 많은 코어에서 많은 스케줄러를 사용하는 시스템에서 더 많은 경합 지점을 표시하므로 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">커널 애플리케이션에서 :</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">Mnesia 테이블에서 두 개의 키 열은 두 개의 요소가있는 튜플로 저장됩니다. 따라서 테이블의 arity는 3입니다.</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">4.4BSD Unix에 포함 된 POSIX.2 호환 라이브러리에서 못생긴 구문 [[: &amp;lt;:]] 및 [[:&amp;gt; :]]는 &quot;단어 시작&quot;과 &quot;단어 끝&quot;을 일치시키는 데 사용됩니다. PCRE는 이러한 항목을 다음과 같이 취급합니다.</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">PRF (pseud-random function)에서 PFS를 사용하지 않는 암호 제품군에서 키 자료를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">SSL 애플리케이션에서 추가 분배 모듈 인 &lt;code&gt;inet_tls_dist&lt;/code&gt; 가 대안으로 사용될 수 있습니다. 모든 분배 연결은 TLS를 사용하며 분산 시스템의 모든 참여 Erlang 노드는이 분배 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">STDLIB 애플리케이션에서 :</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">위의 예에서 &quot;ping&quot;이 시작될 때 &quot;pong&quot;의 ID를 제공 할 수 있도록 &quot;pong&quot;이 처음 작성되었습니다. 즉, 어떤 식 으로든 &quot;ping&quot;은 메시지를 보낼 수 있도록 &quot;pong&quot;의 ID를 알 수 있어야합니다. 때때로 서로의 아이덴티티를 알아야하는 프로세스는 서로 독립적으로 시작됩니다. 따라서 Erlang은 프로세스에 이름을 부여하는 메커니즘을 제공하므로 이러한 이름을 pid 대신 ID로 사용할 수 있습니다. 이는 &lt;code&gt;register&lt;/code&gt; BIF 를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">기본 시나리오에서 각 사용자는 드라이버를 사용하기 전에 드라이버를로드하고 완료되면 드라이버를 언로드합니다. 참조 횟수는 프로세스 및 각 프로세스 별로드 수를 추적합니다. 이렇게하면 아무도 원하지 않을 때만 (사용자가없는 경우) 드라이버가 언로드됩니다. 드라이버는 또한 열린 포트를 추적합니다. 이렇게하면 모든 포트가 닫힐 때까지 언로드가 지연되거나 드라이버가 언로드 될 때 드라이버를 사용하는 모든 포트가 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">위의 경우 메신저 예제의 다른 모든 파일과 동일한 디렉토리에서 파일을 가져옵니다. (*설명서*).</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">업그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;Vsn&lt;/code&gt; 이고 다운 그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;{down,Vsn}&lt;/code&gt; 입니다. &lt;code&gt;Vsn&lt;/code&gt; 은 이전 버전의 콜백 모듈 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;vsn&lt;/code&gt; 속성으로 정의됩니다 . 그러한 속성이 정의되어 있지 않으면 버전은 BEAM 파일의 체크섬입니다.</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응답의 경우 megaco는 응답을 취소하고이 정보는 콜백 함수 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 호출을 통해 사용자에게 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요청의 경우 megaco는 &lt;code&gt;megaco:cancel&lt;/code&gt; 이 성공적으로 전송 된 후 호출 된 것과 거의 같은 방식으로 메시지를 취소합니다 . 정보는 요청이 발행 된 방법에 따라 다르게 사용자에게 다시 전파됩니다. &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 을 사용하여 발행 된 요청의 경우 정보가 리턴 값으로 전달됩니다. &lt;code&gt;megaco:cast&lt;/code&gt; 를 사용하여 발행 된 요청의 경우 콜백 함수 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 통해 정보가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;Destination&lt;/code&gt; 인 &lt;code&gt;File&lt;/code&gt; , 인쇄 MEGACO 추적 이벤트는 파일로 인쇄 할 &lt;code&gt;File&lt;/code&gt; 일반 사용 &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">경우에 때 &lt;code&gt;Destination&lt;/code&gt; 입니다 &lt;code&gt;io&lt;/code&gt; 인쇄 MEGACO 추적 이벤트가 일반 사용하여 표준 출력에 인쇄됩니다, &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">pdu 유형이 &lt;code&gt;report&lt;/code&gt; 인 경우 &lt;code&gt;MsgData&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">이 섹션의 시작 부분에있는 코드 조각에서는 &lt;code&gt;Bin&lt;/code&gt; 에 추가하는 것이 저렴하지만 &lt;code&gt;Bin0&lt;/code&gt; 에 추가 하면 새로운 바이너리가 &lt;code&gt;Bin0&lt;/code&gt; 의 내용을 복사 하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">표지 사양 파일에서 필요한 수준의 코드 범위 분석을 지정할 수도 있습니다. &lt;code&gt;details&lt;/code&gt; 또는 &lt;code&gt;overview&lt;/code&gt; . 상세 모드에서는 모듈 당 총 커버리지 비율을 보여주는 커버리지 개요 페이지가 표시됩니다. 또한 테스트 중에 코드의 어떤 부분이 실행되었는지 정확하게 보여주는 분석에 포함 된 각 모듈에 대해 HTML 파일이 인쇄됩니다. 개요 모드에서는 코드 적용 범위 개요 페이지 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">현재 &lt;code&gt;Common Test&lt;/code&gt; 버전에서 &lt;code&gt;silent_connections&lt;/code&gt; 기능은 Telnet 및 SSH 연결에서만 작동합니다. 다른 연결 유형에 대한 지원은 향후 &lt;code&gt;Common Test&lt;/code&gt; 버전 에서 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang / SCTP 바인딩의 현재 구현에서이 이벤트는 내부적 으로 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;error&lt;/code&gt; 용어로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">현재 구현에서 모든 객체 삽입 및 조회 작업으로 객체의 사본이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">릴리스 의 현재 버전 &lt;code&gt;CurVsn&lt;/code&gt; 에서 &lt;code&gt;myapp&lt;/code&gt; 의 응용 프로그램 디렉토리 는 &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; 입니다. 새로운 버전의 &lt;code&gt;NewVsn&lt;/code&gt; 은 릴리스 핸들러 외부에서 압축이 풀리고 릴리스 핸들러는 다음과 같이 호출하여이를 알립니다.</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">&lt;code&gt;data_dir&lt;/code&gt; 데이터 디렉토리 에서 테스트 모듈에는 테스트에 필요한 자체 파일이 있습니다. 이름 &lt;code&gt;data_dir&lt;/code&gt; 은 다음에 테스트 스위트의 이름입니다 &lt;code&gt;&quot;_data&quot;&lt;/code&gt; . 예를 들어, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; 에는 &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; 데이터 디렉토리가 있습니다. 이식성을 위해, 즉 스위트에서 디렉토리 이름을 하드 코딩하지 않으려면이 디렉토리를 사용하십시오. 데이터 디렉토리는 테스트 스위트와 동일한 디렉토리에 저장되므로 테스트 스위트 디렉토리에 대한 경로가 테스트 스위트 구현과 실행간에 변경된 경우에도 런타임시 해당 디렉토리에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">다음 설명에서는 기본값을 변경하는 데 사용되는 양식이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">노드에 대한 세부 정보 창에 원래 노드와 연결된 노드의 프로세스 간 기존 링크 및 모니터가 표시됩니다. &lt;strong&gt;추가 정보&lt;/strong&gt; 에는 디버그 정보 (에뮬레이터가 디버그 컴파일 된 경우 작성된 ​​특수 정보) 또는 오류 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">이벤트 관리자에는 0 개, 1 개 또는 많은 &lt;strong&gt;이벤트 핸들러&lt;/strong&gt; 가 설치됩니다. 이벤트 관리자에게 이벤트에 대한 알림이 표시되면 설치된 모든 이벤트 핸들러에서 이벤트를 처리합니다. 예를 들어, 오류를 처리하기위한 이벤트 관리자는 기본적으로 핸들러를 설치하여 오류 메시지를 터미널에 기록 할 수 있습니다. 특정 기간 동안 오류 메시지를 파일에 저장하려는 경우 사용자는이를 수행하는 다른 이벤트 핸들러를 추가합니다. 파일에 로깅 할 필요가 없으면이 이벤트 핸들러가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">위의 예에서 유효한 &lt;code&gt;keys&lt;/code&gt; 는 &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; 및 &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; 일 수 있지만 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; , &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; 및 &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; 가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">아래 예에서, 라인 번호 2,4,6,8 및 11은 실행 가능한 라인입니다.</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">이전 섹션의 예에서 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;ch3:start_link()&lt;/code&gt; 호출하여 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">이전 섹션의 예제에서 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; 호출하여 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">이 예에서 제시된 ID는 &lt;code&gt;example.com&lt;/code&gt; 및 &lt;code&gt;*.example.com&lt;/code&gt; 과 일치하는 호스트 이름 입니다. 예를 들어 &lt;code&gt;foo.example.com&lt;/code&gt; 과 &lt;code&gt;bar.example.com&lt;/code&gt; 은 모두 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 과 일치하지만 일치하지는 않습니다 . &lt;code&gt;erlang.org&lt;/code&gt; 라는 이름 은 CN이 아니기 때문에 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">이 예에서, 들어 오고 나가는 각 메시지마다 &lt;code&gt;handle_debug&lt;/code&gt; 가 호출됩니다. 형식 함수 &lt;code&gt;Func&lt;/code&gt; 는 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; 함수이며, &lt;code&gt;io:format/3&lt;/code&gt; 을 사용하여 메시지를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예 에서, &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; 의 첫 번째 인코딩 된 요소의 구성 요소 &lt;code&gt;number&lt;/code&gt; 가 선택됩니다. 이는 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 섹션의 ASN.1 사양에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">이 예에서 &lt;code&gt;==/2&lt;/code&gt; 연산자 는 &lt;code&gt;=:=/2&lt;/code&gt; 처럼 처리되었습니다. 그러나 일부 상수에 정수가없는 것으로 컴파일 시간에 판별 할 수없고 테이블이 동일한 키를 비교할 때 &lt;code&gt;=:=/2&lt;/code&gt; 를 사용하는 경우 ( &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; 옵션 참조 ) &lt;code&gt;qlc&lt;/code&gt; 모듈은 상수를 찾지 않습니다. . 그 이유는 일반적으로 그러한 상수와 동일하게 비교할 수있는 키 값의 수에 대한 상한이 없기 때문입니다. 모든 정수와 부동 소수점 조합을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 동기식 시작이 사용됩니다. 프로세스는 &lt;code&gt;ch4:start_link()&lt;/code&gt; 를 호출하여 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">이 예에서 일반 노드 이름은 &lt;code&gt;c1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">예제에서 :</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">예제에서 기본 Erlang 쉘은 ISO Latin1 범위의 문자 만 인쇄 가능으로 해석하고 문자열 데이터를 포함하는 &quot;인쇄 가능&quot;문자가있는 목록 또는 이진 만 감지합니다. 러시아어 &quot;Юникод&quot;를 포함하는 유효한 UTF-8 바이너리는 문자열로 인쇄되지 않습니다. 인쇄 가능한 모든 유니 코드 문자 ( &lt;code&gt;+pc unicode&lt;/code&gt; )로 시작하면 쉘은 인쇄 가능한 유니 코드 데이터 (바이너리, UTF-8 또는 바이트 단위 인코딩)를 문자열 데이터로 포함하는 모든 것을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">비 익명 PFS (완전 순방향 비밀)를 제공하는 암호 제품군의 DH 매개 변수 교환</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">함수 호출의 첫 번째 형식 인 &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; 에서 &lt;code&gt;ExprM&lt;/code&gt; 및 &lt;code&gt;ExprF&lt;/code&gt; 는 각각 원자 또는 원자로 평가되는 표현식이어야합니다. 함수는 &lt;strong&gt;완전한 함수 이름&lt;/strong&gt; 을 사용하여 호출된다고합니다 . 이것은 종종 &lt;strong&gt;원격&lt;/strong&gt; 또는 &lt;strong&gt;외부 함수 호출이라고&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">첫 번째 섹션에서 &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; 조치는 일반 상태 머신 모델의 일부로 언급되었습니다. 이러한 일반 조치는 &lt;code&gt;gen_statem&lt;/code&gt; 엔진으로 리턴하기 전에 콜백 모듈 &lt;code&gt;gen_statem&lt;/code&gt; 이 이벤트 처리 콜백 함수에서 실행 하는 코드로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; 의 첫 번째 단어 (4 바이트)에서 18 비트 만 유효하고 나머지는 0이어야합니다. &lt;code&gt;Creation&lt;/code&gt; 에서는 2 비트 만 유효하고 나머지는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">다음 설명에서 &lt;strong&gt;Point&lt;/strong&gt; 라는 단어의 사용은 &quot;포인트는 커서의 위치로 볼 수 있습니다.보다 정확하게 말하면, 커서는 포인트 다음의 문자 위에 그려지는 동안 두 문자 사이의 위치입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">다음 설명에서 &lt;strong&gt;그룹 노드&lt;/strong&gt; 는 로컬 노드와 동일한 글로벌 그룹에 속하는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">다음의 설명에서, 모든 기능은 이유와 함께 실패 &lt;code&gt;badarg&lt;/code&gt; 경우 &lt;code&gt;heart&lt;/code&gt; 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">다음 예에서는 QLC &lt;code&gt;V2&lt;/code&gt; 가 삽입되어 결합 된 생성기와 선택된 결합 방법을 보여줍니다. 조회 조인에 규칙이 사용됩니다. 첫 번째 생성기 ( &lt;code&gt;G2&lt;/code&gt; )는 트래버스 된 것이고, 두 번째 생성기 ( &lt;code&gt;G1&lt;/code&gt; )는 상수를 찾는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">다음 예에서 병합 결합의 캐시 된 결과는 각 &lt;code&gt;A&lt;/code&gt; 값에 대해 순회됩니다 . 옵션 &lt;code&gt;cache&lt;/code&gt; 가 없으면 조인이 &lt;code&gt;A&lt;/code&gt; 의 각 값에 대해 한 번씩 세 번 수행되었을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">다음 예에서는 두 개의 프로세스가 만들어지고 여러 번 서로에게 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">다음 예에서는 옵션 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 를 보유하기 위해 두 개의 간단한 QLC가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">이 프로그램을 사용하는 다음 예에서 노드는 네 개의 다른 컴퓨터에서 시작됩니다. 네트워크에 사용 가능한 머신이 많지 않은 경우 동일한 머신에서 여러 노드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">다음 예에서, &lt;code&gt;Common Test&lt;/code&gt; 발견 실행한다 두 시험으로부터의 경로에 대해 하나의 &lt;code&gt;top2&lt;/code&gt; 에 &lt;code&gt;sub2X2&lt;/code&gt; 통해 &lt;code&gt;sub21&lt;/code&gt; 및 하나 &lt;code&gt;top2&lt;/code&gt; 에 &lt;code&gt;sub2X2&lt;/code&gt; 통해 &lt;code&gt;sub22&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">다음 예에서 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; 는 등록 된 프로세스 &lt;code&gt;my_server&lt;/code&gt; 로 전송됩니다 . 메시지는 &lt;code&gt;erl_send()&lt;/code&gt; 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">다음 예제에서 고유 경로 &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; 를 지정하면 하나의 테스트 만 실행됩니다. &lt;code&gt;top2&lt;/code&gt; 에서 &lt;code&gt;sub2X2&lt;/code&gt; (이전 예제에서)까지 가능한 두 번째 경로 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">다음 예에서 함수 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 이 순차 추적을위한 트리거로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">다음 예제에서 2, 4, 6, 8 및 11 행은 실행 가능한 행입니다.</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 모듈 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">다음 예제에서 BIF &lt;code&gt;self()&lt;/code&gt; 는 호출 프로세스의 pid를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">다음 예에서 Erlang 쉘은 채널 응답을받는 클라이언트 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">다음 예에서는이 ASN.1 사양이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">다음 예에서는 &lt;code&gt;my_SUITE&lt;/code&gt; 테스트를 위한 두 개의 이벤트 핸들러 가 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션 의 &lt;code&gt;gb_table&lt;/code&gt; 모듈을 사용하여 6 개의 키를 찾아야합니다. &lt;code&gt;{1,a}&lt;/code&gt; , &lt;code&gt;{1,b}&lt;/code&gt; , &lt;code&gt;{1,c}&lt;/code&gt; , &lt;code&gt;{2,a}&lt;/code&gt; , &lt;code&gt;{2,b}&lt;/code&gt; 및 &lt;code&gt;{2,c}&lt;/code&gt; . 그 이유는 키 &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; 의 두 요소가 별도로 비교되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">다음 예에서는 XML 파일 &quot;motorcycles.xml&quot;과 해당 DTD &quot;motorcycles.dtd&quot;를 사용합니다. motorcycles.xml은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">다음 그림에서는 표시된 요소 만 &lt;code&gt;selected_decode_Window2&lt;/code&gt; 에 의해 디코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">다음 그림에서 사각형 상자는 감독자를 나타내고 원은 근로자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">다음 목록에서 초기화 플래그는 &quot;(init flag)&quot;로 표시됩니다. 달리 지정되지 않는 한 다른 모든 플래그는 사용자 플래그이며 &lt;code&gt;init:get_argument/1&lt;/code&gt; 을 호출하여 값을 검색 할 수 있습니다 . 사용자 플래그 목록이 완전한 것은 아니며 해당 응용 프로그램 설명서에 설명 된 응용 프로그램 별 플래그가 더있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">다음 섹션에서는 이러한 주제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">다음 섹션에서는 필요한 도구 설치에 대해 최대한 많이 설명했습니다. 도구가 설치되면 구축이 매우 쉽습니다. 우리는 또한 유닉스 경험이 제한적인 사람들이이 지침을 이해할 수 있도록 노력했습니다. Cygwin / MSYS / MSYS2는 일부 Windows 사용자에게 완전히 새로운 환경이므로 환경 변수 등에 대한 신중한 설명이 필요한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">다음과 같은 상황 &lt;code&gt;lists:flatten/1&lt;/code&gt; 호출을 쉽게 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">다음 예제 표에서 &lt;code&gt;Data&lt;/code&gt; 는 I / O 목록이어야합니다. I / O 목록은 0 또는 ..255 범위의 이진 또는 정수 또는 이진 (정수) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">아래 정의 된 기능에서 다음 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">향후 디버그 기능은 Erlang 드라이버 스레드 API와 통합 될 것입니다. 엔터티를 만드는 모든 함수에는 &lt;code&gt;name&lt;/code&gt; 인수가 사용됩니다. 현재 &lt;code&gt;name&lt;/code&gt; 인수는 사용되지 않지만 디버그 기능이 구현 될 때 사용됩니다. 작성된 모든 엔티티의 이름을 올바르게 지정하면 디버그 기능이 더 나은 오류 보고서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">생성 된 부팅 스크립트에서 모든 응용 프로그램 디렉토리는 &lt;code&gt;App-Vsn/ebin&lt;/code&gt; 으로 구성 됩니다. &lt;code&gt;$ROOT/lib&lt;/code&gt; 에있는 것으로 가정합니다 . 여기서 &lt;code&gt;$ROOT&lt;/code&gt; 는 설치된 릴리스의 루트 디렉토리입니다. &lt;code&gt;local&lt;/code&gt; 옵션 이 지정되면 대신 응용 프로그램이 발견 된 실제 디렉토리가 사용됩니다. 생성 된 부팅 스크립트를 로컬에서 테스트하는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">마지막 예제에서 분석 할 모듈은 &lt;code&gt;m/1&lt;/code&gt; 에 대한 인수로 제공되었으며 코드 경로는 (암시 적으로) &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 로 사용되었습니다 . 이 예제에서는 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; 가 사용되어 응용 프로그램 및 릴리스를 분석하고 라이브러리 경로를 명시 적으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">마지막 줄에서 튜플 {256,10, -2}는 특수 표기법에서 실수 2.56이며 숫자를 단순히 &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; 으로 표시하는 것보다 빠르게 인코딩 됩니다. arity 3 튜플은 &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; 입니다 . 즉, Mantissa * Base ^ Exponent입니다.</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">두 방향 (cf &lt;code&gt;cipher&lt;/code&gt; ) 에 대해 두 개로 나뉘어 진 목록 에서 한 번에 두 방향을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">두 방향 (cf &lt;code&gt;cipher&lt;/code&gt; ) 에 대해 두 개로 나누어 진 목록에서 다음 방향 중 하나만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">요청이 처리되는 루프에서 이제 송신 제한 시간을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">메신저 예제에서 전송되는 메시지가 무엇인지에 대한 가정은 없었습니다. 유효한 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">모니터 메시지에서 &lt;code&gt;MonitorRef&lt;/code&gt; 및 &lt;code&gt;Type&lt;/code&gt; 은 앞에서 설명한 것과 동일하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">일반적인 경우 버전은 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 로 구성 되며 여기서 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; 가 가장 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">필드의 초기 값이있는 경우 다음과 같이 초기화 후에 유형을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">이전 예에서는 어떤 프로토콜이 예상되는지 표시하지 않았습니다. 따라서 클라이언트는 웹 서버, LDAP 서버 또는 연결된 sip 서버인지 여부를 표시하지 않습니다. 인증서에이를 나타낼 수있는 필드가 있습니다. 보다 정확하게 말하면, rfc 는 &lt;code&gt;X509v3 extensions&lt;/code&gt; 필드 에 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 의 사용법을 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">이전 예에서 &quot;ping&quot;및 &quot;pong&quot;은 두 개의 개별 Erlang 노드의 쉘에서 시작되었습니다. &lt;code&gt;spawn&lt;/code&gt; 을 사용하여 다른 노드에서 프로세스를 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">이전 예에서 &lt;code&gt;all/0&lt;/code&gt; 이 &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; 순서로 그룹 이름 참조를 리턴 하면 구성 함수 및 테스트 케이스의 순서는 다음과 같습니다 ( &lt;code&gt;init_per_testcase/2&lt;/code&gt; 및 &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 항상 호출되지만 단순화를 위해이 예제에는 포함되지 않음) :</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">이전 예에서 감독자는 &lt;code&gt;ch_sup:start_link()&lt;/code&gt; 호출하여 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">이전 예제에서는 이전 변수 인 &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;TheRest&lt;/code&gt; , &lt;code&gt;E1&lt;/code&gt; , &lt;code&gt;E2&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 재사용하는 대신 새 변수 이름이 사용되었습니다 . 그 이유는 변수 (컨텍스트)에서 변수에 값을 한 번만 제공 할 수 있기 때문입니다. 나중에 이것에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">SMP를 지원하는 런타임 시스템에서 드라이버는 드라이버 레벨 또는 포트 레벨 (드라이버 인스턴스 레벨)에서 잠 깁니다. 기본적으로 드라이버 레벨 잠금이 사용됩니다. 즉, 한 번에 하나의 에뮬레이터 스레드 만 드라이버에서 코드를 실행합니다. 포트 레벨 잠금이 사용되는 경우 여러 에뮬레이터 스레드가 동시에 드라이버에서 코드를 실행할 수 있습니다. 그러나 한 번에 하나의 스레드 만 동일한 포트에 해당하는 드라이버 콜백을 호출합니다. 포트 레벨 잠금을 사용하려면 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 사용 하는 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 에서 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; 드라이버 플래그 를 설정하십시오 . 포트 레벨 잠금이 사용되면 드라이버 기록기는 포트 (드라이버 인스턴스)가 공유하는 데이터에 대한 모든 액세스를 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">두 번째 예에서는 기본 추적 처리기 함수를 사용합니다. 이 핸들러는 IO 요청을 &lt;code&gt;user&lt;/code&gt; 프로세스 로 전송하여 tty로 인쇄합니다 . Erlang이 이전 쉘 모드에서 시작되면 쉘 프로세스는 &lt;code&gt;user&lt;/code&gt; 를 그룹 리더로 사용 하므로이 예제에서 추적 프로그램 프로세스도 마찬가지입니다. &lt;code&gt;user&lt;/code&gt; 가 &lt;code&gt;lists&lt;/code&gt; 에서 함수를 호출 하기 때문에 첫 번째 IO 요청이 전송되는 즉시 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">두 번째 형태의 함수 호출 &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; 에서 &lt;code&gt;ExprF&lt;/code&gt; 는 원자이거나 재미로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">시퀀스 차트에서 액터 (심볼 적으로 &lt;code&gt;Event&lt;/code&gt; 를 수행 한 액터 )는 이름이 지정된 세로 막대로 표시됩니다. 액터의 순서는 액터의 이름 태그를 드래그하여 (작업 중에 마우스 버튼 1을 누르고 있음) 다른 곳에 놓으면 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">쉘에서 유니 코드 입력 장치를 사용하거나 UTF-8로 저장된 소스 코드에서 &lt;code&gt;$&lt;/code&gt; 뒤에 바로 정수를 생성하는 유니 코드 문자가 올 수 있습니다. 다음 예에서, 키릴의 코드 포인트 &lt;code&gt;с&lt;/code&gt; 가 출력된다 :</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">노드가 글로벌 그룹의 다른 노드와의 연결이 끊어졌지만 다른 글로벌 그룹의 노드와의 연결이있는 경우 다른 글로벌 그룹의 요청이 부정확하거나 잘못된 결과를 초래할 수 있습니다. 예를 들어 격리 된 노드는 글로벌 그룹에 등록 된 이름에 대한 정보가 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">대상 디렉토리에서 &lt;code&gt;releases/start_erl.data&lt;/code&gt; 파일을 읽고 Erlang 런타임 시스템 버전 ( &quot;5.10.4&quot;)을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">텍스트 인코딩에서 구현자는 짧은 키워드와 긴 키워드를 혼합하여 사용할 수 있습니다. 가독성을 높이기 위해 공백을 추가 할 수도 있습니다. 키워드가 가장 짧고 공백이없는 문자 메시지에 대해서는 압축이라는 용어를 사용하고, 긴 키워드를 사용하여 잘 들여 쓰기 된 텍스트 형식과 Megaco / H.248 사양의 텍스트 예와 같이 들여 쓰기 스타일에 적합한 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">xmerl_xs 함수에서 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 기능인 select (String) 호출을 제공 할 수 있습니다 . 자세한 내용은 xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">이 경우 ProtocolVersion 기본 버전은 정적 연결 구성에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">이 에이전트 시스템에는 관리 정보를 동적으로 설치하는 두 가지 방법이 있습니다. 가장 일반적인 방법은 MIB를 에이전트에로드하는 것입니다. 다른 방법은 응용 프로그램에 의해 제어되며 자체 등록 및 등록 취소가 가능한 하위 에이전트를 사용하는 것입니다. 서브 에이전트는 서브 트리 관리를 위해 자체 등록 할 수 있습니다 ( &lt;code&gt;erlang:register&lt;/code&gt; 와 혼용하지 말 것 ). 하위 트리는 개체 식별자로 식별됩니다. 서브 에이전트가 등록되면이 특정 서브 트리에 대한 모든 요청을 수신하고 응답해야합니다. 또한 서브 에이전트는 언제든지 시작하고 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">이 호출에서 &lt;code&gt;[1, 1]&lt;/code&gt; 은 &lt;code&gt;RowIndex&lt;/code&gt; 이며 키 1에는 값 1이 있고 키 2에는 값 1이 있으며 &lt;code&gt;[3, 5]&lt;/code&gt; 는 요청 된 열 목록입니다. 함수는 이제 사전 식으로 다음 요소를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">이 경우 새로운 구성 요소 &lt;code&gt;b&lt;/code&gt; 가 있습니다. 따라서, 디코딩 된 수신 메시지는이 것보다 더 많거나 열이 많은 구성 요소를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">이 경우 테스트 스위트 의 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">이 경우 구성 파일에는 최소한 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">이 경우 필터는 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 에 대한 모든 가능한 응답 쌍에 한 번에 하나씩 적용됩니다. &lt;code&gt;QH1&lt;/code&gt; 에 대한 M 개의 답변 과 &lt;code&gt;QH2&lt;/code&gt; 에 대한 N 개의 답변이 있는 경우 필터는 M * N 회 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">이 경우 &lt;code&gt;CTH&lt;/code&gt; 는 CTH 의 모듈 이름이거나 모듈 이름과 초기 인수가있는 튜플 일 수 있으며 선택적으로 CTH의 후크 우선 순위 일 수 있습니다. 예를 들어, 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">이 경우 컴파일러 옵션 &lt;code&gt;encrypt_debug_info&lt;/code&gt; 를 사용할 수 있습니다 &lt;code&gt;compile(3)&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">이 경우 첫 번째 인수를 제외한 모든 인수는 무시되고 함수는 단순히 내부 상태를 다시 반환합니다. 코드 만 확장 된 경우 충분합니다. 내부 상태가 (의 예와 유사하게 변경하는 대신 경우 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; )이이 기능에서 수행하고 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">이 경우 &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; 중 하나 이상 이 바인딩되지 않은 변수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">이 경우 간단한 코드 교체로는 충분하지 않습니다. 새로운 버전의 콜백 모듈로 전환하기 전에 프로세스는 콜백 함수 &lt;code&gt;code_change&lt;/code&gt; 를 사용하여 명시 적으로 상태를 변환해야합니다 . 따라서 동기화 된 코드 교체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">이 경우 간단한 코드 교체로는 충분하지 않습니다. 특수 프로세스에 대한 새 버전의 거주 모듈이로드 될 때 프로세스는 루프 코드를 완전히 호출하여 새 코드로 전환해야합니다. 따라서 동기화 된 코드 교체를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">이 경우 호출 프로세스는 쉘이므로 다음 결과가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">이 경우 해당 모듈에서 함수를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">이 경우, 주요 &lt;code&gt;Key&lt;/code&gt; 후속 호출에 사용될 수 리턴은하기 &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; 평가 값 검색 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 노드에서 &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">이 경우, 새로운 상태는 이용 가능한 채널 ( &lt;code&gt;Chs2&lt;/code&gt; )의 업데이트 된리스트이다 . &lt;code&gt;gen_server&lt;/code&gt; 는 이제 새로운 요청에 대한 준비가되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">이 경우 &lt;code&gt;.appup&lt;/code&gt; 파일 을 지정하지 않고도 릴리스 패키지의 자동 패킹 및 언 패킹, 자동 경로 업데이트 등이 포함 된 릴리스 핸들러 프레임 워크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">이 경우, 응답은 할당 된 채널 ( &lt;code&gt;Ch&lt;/code&gt; ) 이고 새로운 상태는 남아있는 이용 가능한 채널 ( &lt;code&gt;Chs2&lt;/code&gt; )의 세트이다 .</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">이 경우 감독자는 등록되지 않습니다. 대신 pid를 사용해야합니다. &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; 또는 &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; 를 호출하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">이 경우 두 항을 독립적으로 해제합니다. &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리는 참조 계산을 사용하여 개체를 제거하기에 안전한시기를 결정 하므로 용어 &lt;code&gt;ep&lt;/code&gt; 및 &lt;code&gt;ep2&lt;/code&gt; 를 해제하는 순서는 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">이 예에서는 XML 파일의 특정 데이터를 검사하려는 상황을 고려하십시오. 예를 들어, 각 오토바이가 기록 된 시간을 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">이 예제에서 Pea 애플리케이션이 변경되었으며 ERTS, Kernel, STDLIB 및 SASL 애플리케이션도 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 숫자는 정수이고 코드 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 의 함수 인수는 변수라고합니다. 변수는 대문자로 시작해야합니다 ( &lt;code&gt;Variables&lt;/code&gt; 참조 ). 변수의 예는 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;ShoeSize&lt;/code&gt; 및 &lt;code&gt;Age&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">이 예에서는 값을 &quot;운반&quot;하는 목록 (이 경우 &lt;code&gt;Result_so_far&lt;/code&gt; )을 살펴 봅니다 . &lt;code&gt;list_max/1&lt;/code&gt; 은 단순히리스트의 최대 값이리스트의 헤드라고 가정하고리스트 의 나머지와리스트의 헤드 값으로 &lt;code&gt;list_max/2&lt;/code&gt; 를 호출 합니다. 위에서 이것은 &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; 입니다. 당신이 사용하려고하는 경우 &lt;code&gt;list_max/1&lt;/code&gt; 빈 목록 또는 모두에서 목록이 아닙니다 뭔가를 사용하려고하면 오류가 발생할 것입니다. Erlang 철학은 이러한 유형의 오류를 발생하는 기능에서 처리하는 것이 아니라 다른 곳에서 수행해야합니다. 나중에 이것에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">이 예에서 &lt;code&gt;suite/0&lt;/code&gt; 은 &lt;code&gt;Common Test&lt;/code&gt; 에 Telnet 및 SSH 연결의 출력을 억제하도록 지시 합니다. 이것은 모든 테스트 사례에 유효합니다. 그러나 &lt;code&gt;my_testcase1/0&lt;/code&gt; 은이 테스트 사례에 대해 SSH 만 자동으로 지정하도록 지정합니다. 결과적으로 &lt;code&gt;my_testcase1&lt;/code&gt; 은 SSH 정보가 아닌 로그에 Telnet 정보 (있는 경우)를 인쇄합니다. &lt;code&gt;my_testcase2&lt;/code&gt; 는 인쇄 된 연결에서 정보를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;{Pid, Something}&lt;/code&gt; 이 수신되었습니다. 수신 된 pid는 &lt;code&gt;{goodbye,Pid}&lt;/code&gt; 를 리턴하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">이 예에서, 일련의 바이트가 외부 소스로부터 수신되고 바이트는 유효한 Erlang 항으로 디코딩됩니다. 이것은 &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; 호출로 달성되었으며 ASN.1 유형 &lt;code&gt;Person&lt;/code&gt; 의 Erlang 값을 리턴했습니다 . 그런 다음 정의 된 ASN.1 유형의 인스턴스를 가져 와서 BER 또는 PER 인코딩 규칙에 따라 이진으로 변환하는 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; 를 사용하여 응답을 구성하고 인코딩 했습니다.</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">이 예제에서 NIF 백엔드가있는 추적 프로그램 모듈 은 발신자와 수신자 만 포함하는 각 &lt;code&gt;send&lt;/code&gt; 추적 태그 에 대해 메시지를 보냅니다 . 이 추적 프로그램 모듈을 사용하면 훨씬 더 가벼운 메시지 추적 프로그램이 사용되며 누가 메시지를 보낸 사람 만 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 환경 변수 &lt;code&gt;DISPLAY&lt;/code&gt; 가 &lt;code&gt;gin:0&lt;/code&gt; 으로 설정된 Erlang 런타임 시스템이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 문자열 형식 지정 지시문 &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 하여 단일 문자 65를 출력하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">이 예에서, io : format 호출이 완료되면 호출 프로세스에서 설정된 모든 사용자 태그가 I / O 서버로 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">이 예제에서 각 런타임 시스템에는 각각 온라인으로 두 개의 스케줄러가 있으며 모든 온라인 스케줄러는 다른 코어에서 실행됩니다. 하나의 런타임 시스템에서 하나의 스케줄러를 온라인으로 변경하고 다른 하나의 스케줄러를 온라인으로 세 개의 스케줄러로 변경해도 온라인의 모든 스케줄러는 여전히 다른 코어에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">이 예에서 function &lt;code&gt;terminate/3&lt;/code&gt; 는 문이 열려 있으면 잠그므로 감독 트리가 종료 될 때 실수로 문을 열어 두지 않습니다.</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">첫 번째 요소는 키를 있었다면이 예에서는, 그것은에서 해당 키와 일치하는 것이 훨씬 더 효율적입니다 &lt;code&gt;MatchHead&lt;/code&gt; 의 보다 부분을 &lt;code&gt;MatchConditions&lt;/code&gt; 의 일부입니다. 일치 키를 가진 개체 만 검색 할 수 있도록 &lt;code&gt;MatchHead&lt;/code&gt; 와 관련하여 테이블의 검색 공간이 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;open&lt;/code&gt; 상태 에서 버튼 이벤트를 무시하지 않고 이를 연기 할 수 있으며 대기 상태가되고 나중에 &lt;code&gt;locked&lt;/code&gt; 상태 에서 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">이 예에서는 다음 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">이 예에서는 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 섹션과 동일한 ASN.1 사양 이 사용됩니다. 다음은 유효한 선택적 디코딩 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">이 예에서 &quot;b.spec&quot;및 &quot;c.spec&quot;파일에 정의 된 테스트 용어는 소스 사양 &quot;a.spec&quot;(있는 경우)의 용어와 결합됩니다. &quot;d.spec&quot;및 &quot;e.spec&quot;사양을 포함 시키면 두 개의 독립적 인 독립적 인 테스트 실행이 포함됩니다 (포함 된 각 사양마다 하나씩).</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">이 예에서는 보관하려는 데이터 크기의 두 배 이상 이진을 참조하는 경우 이진 내용을 &lt;code&gt;gb_sets:set()&lt;/code&gt; 에 삽입하기 전에 이진 내용을 복사하기로했습니다 . 물론 다른 프로그램에 복사 할 때는 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">이 예에서는 'diffie-hellman-group1-sha1'을 먼저 넣고 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; 을 kex 목록의 끝으로 이동 합니다. 즉, &lt;code&gt;append&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">이 예에서는 두 가지 옵션 ( &lt;code&gt;preferred_algorithms&lt;/code&gt; 및 &lt;code&gt;modify_algorithms&lt;/code&gt; )을 모두 사용 하고 지원되지 않는 알고리즘을 앞에 추가하려고합니다. 지원되지 않는 알고리즘은 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">이 예에서는 다음 ASN.1 사양의 정의가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">다음 예에서 비밀번호는 &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">이 모드에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">이 모듈에서 V는 비워 둘 수 있습니다. 이렇게 얻은 고유 한 digraph를 &lt;strong id=&quot;empty_digraph&quot;&gt;빈 digraph&lt;/strong&gt; 라고합니다 . 정점과 모서리는 모두 고유 한 얼랭 용어로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">이 모듈에서 고려되는 유일한 패밀리는 일부 세트 X의 서브 세트 패밀리입니다. 이하에서, &quot;패밀리&quot;라는 단어는 이러한 서브 세트 패밀리에 사용된다.</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">시간 제한 이벤트에서 상태를 변경하는 유일한 가능한 이유 때문에이 특별한 경우에 우리는 타임 아웃을 취소 할 필요가 없습니다 &lt;code&gt;open&lt;/code&gt; 에 &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">이 특정 경우, 명령 &lt;code&gt;i&lt;/code&gt; ( &quot;인터럽트&quot;)는 루핑 프로그램을 종료하고 명령 &lt;code&gt;c&lt;/code&gt; 는 쉘에 다시 연결됩니다. 프로세스가 &lt;code&gt;** exception exit: killed&lt;/code&gt; 되기 전에 백그라운드에서 실행 중이므로 &quot; ** exception exit : killed &quot; 메시지가 표시되기 전에 더 많은 인쇄가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">이 시나리오에서 ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; 을 보호하는 잠금 은 대부분의 대기 시간을 소비했습니다. 60 초 동안 실행 된 테스트에서 1.8 초입니다. 시간은 또한 8 개의 다른 스케줄러 스레드에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Domain&lt;/code&gt; 필드 중 하나, 즉 반송 도메인이다 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 은 및 &lt;code&gt;Addr&lt;/code&gt; 필드가있다 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">이 섹션에서 &lt;code&gt;Address&lt;/code&gt; 필드는 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 튜플이며 여기서 &lt;code&gt;Domain&lt;/code&gt; 은 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 이고 &lt;code&gt;Addr&lt;/code&gt; 은 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">이 섹션에는 모든 유효한 Erlang 표현식이 나열됩니다. Erlang 프로그램을 작성할 때 매크로 및 레코드 표현식을 사용할 수도 있습니다. 그러나 이러한 표현식은 컴파일 중에 확장되며 그런 의미에서 Erlang 표현식이 아닙니다. 매크로 및 레코드 표현식은 별도의 섹션으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">이 섹션에서는 사용자 이름이 &lt;code&gt;otpuser&lt;/code&gt; 이고 해당 사용자의 홈 디렉토리 가 다음 과 같다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">이 섹션에서는 다음과 같은 용어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">이 간단한 경우에, 가독성 측면에서 전자의 표현이 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">이러한 방식으로 링크를 사용하여 트랜잭션의 모든 프로세스를 함께 연결할 수 있습니다. 프로세스 중 하나가 비정상적으로 종료되면 트랜잭션의 모든 프로세스가 종료됩니다. 종종 같은 시간에 그것을 프로세스와 링크를 만들고 싶었되기 때문에,이 특별한 BIF이다 &lt;code&gt;spawn_link&lt;/code&gt; 과 동일하지 &lt;code&gt;spawn&lt;/code&gt; , 또한 생성 된 프로세스에 대한 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">기존의 관계형 데이터베이스 용어에서이 작업을 선택이라고하며 투영이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StartMessage&lt;/code&gt; 유형에서 필드 &lt;code&gt;content&lt;/code&gt; 뒤의 제한 조건 은 &lt;code&gt;StartMessage&lt;/code&gt; 유형 의 값에서 필드 &lt;code&gt;content&lt;/code&gt; 의 값이 msgId 필드 에서 선택한 동일한 오브젝트에서 &lt;code&gt;msgId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco 표준 버전 3에서는 세분화 패키지가 도입되었습니다. 간단히 말해서,이 패키지는 자동으로이를 수행하지 않는 전송 (예 : UDP)을 사용할 때 megaco 메시지 (트랜잭션 응답)를 분할하는 절차를 정의합니다. &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; -3.0은 어떤 OTP 버전에 도입 되었습니까?</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">자체 추적 처리기 함수에서 &lt;code&gt;io&lt;/code&gt; 함수 대신 &lt;code&gt;erlang:display/1&lt;/code&gt; 을 호출 하거나 &lt;code&gt;user&lt;/code&gt; 가 그룹 리더로 사용되지 않는 경우 기본 그룹 리더 대신 &lt;code&gt;user&lt;/code&gt; 에게 인쇄 하십시오. 예 : &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">인 밴드 보안 ID AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">인 밴드 보안 ID AVP (코드 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id의 기본값은 빈 목록으로, 0을 포함하는 목록 (NO_INBAND_SECURITY)과 같습니다. 1 (TLS)이 지정된 경우 피어에서 수신 한 CER / CEA가이를 제공하면 TLS가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">바이너리의 인바운드 바이너리 인코딩</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">목록 및 이진의 인바운드 백분율 인코딩</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">또한 테스트 사례가 수정 되면 실제로 &lt;code&gt;channel&lt;/code&gt; 버그를 발견해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Erlang의 경로에 &lt;code&gt;dir&lt;/code&gt; 을 포함하십시오 . &lt;code&gt;-include_lib()&lt;/code&gt; 지시문 이있는 파일을 분석 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디렉토리도 테스트 사양에 지정 될 수 있습니다 포함, 참조 &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">파일 포함</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">포함 파일은 일반적으로 여러 모듈이 공유하는 레코드 및 매크로 정의에 사용됩니다. 포함 파일에는 파일 이름 확장자 &lt;code&gt;.hrl&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">토큰 주석에 토큰 텍스트를 포함하십시오. 텍스트는 토큰에 해당하는 입력 부분입니다.</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">구조화 된 리턴 값을 무시하거나 가능한 많은 리턴 값 중 하나와 일치하지 않는 함수 호출에 대한 경고를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">예외에 의해서만 반환되는 함수에 대한 경고를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">가능한 경쟁 조건에 대한 경고를 포함하십시오. 데이터 레이스를 찾는 분석은 절차 내 데이터 흐름 분석을 수행하며 때로는 시간이지나면서 폭발 할 수 있습니다. 자신의 책임하에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">포함 된 테스트 메시지</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">프로세스에 관계없이 모든 통화에 대한 통화 통계를 포함하는 섹션을 분석에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에 타임 스탬프를 포함합니다. 타임 스탬프 (Ts)는 &lt;code&gt;erlang:now()&lt;/code&gt; 반환 한 형식과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에서 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 단조 증가 정수 로 구성된 타임 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 에서 생성 한 것과 동일한 형식과 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 빔 모듈에 사용자 정의 &lt;code&gt;Data&lt;/code&gt; 가있는 &lt;code&gt;Backend&lt;/code&gt; 모듈 형식의 사용자 정의 디버그 정보를 포함 합니다. 지정된 모듈은 &lt;code&gt;debug_info/4&lt;/code&gt; 함수를 구현해야하며 &lt;code&gt;beam_lib(3)&lt;/code&gt; 아래 의 &lt;code&gt;debug_info&lt;/code&gt; 에 설명 된대로 다른 코드 표현을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">컴파일 된 빔 모듈 의 &lt;code&gt;debug_info&lt;/code&gt; 청크에 &lt;code&gt;Erlang Abstract Format&lt;/code&gt; 형식 의 디버그 정보를 포함 합니다. Debugger, Xref 및 Cover와 같은 도구에는 디버그 정보가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">디버그 정보를 포함하지만 키를 제공하지 않으면 액세스 할 수 없도록 암호화합니다. ( &lt;code&gt;debug_info&lt;/code&gt; 옵션도 제공 할 수 있지만 반드시 필요한 것은 아닙니다.)이 옵션을 사용하면 테스트 중에 디버그 정보를 항상 사용할 수 있지만 소스 코드는 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">속성 포함 &lt;code&gt;{role, client | server}&lt;/code&gt; . 현재이 속성은 사전 정의 된 유일한 속성이며 사용자 정의 속성도있을 수 있습니다. 응용 프로그램 환경 변수 &lt;code&gt;session_cb_init_args&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">들어오는 연결</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">들어오는 Diameter 메시지는 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백 에 전달되기 전에 binary ()에서 디코딩됩니다 . 마찬가지로, 나가는 Diameter 메시지는 전송 을 위해 적절한 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 모듈 로 전달되기 전에 binary ()로 인코딩됩니다 . 여기에 문서화 된 기능은 기본 인코딩 / 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 정상적으로 디코딩됩니다. 그러나 디코딩에 실패한 경우이 기능이 호출되어 발신자가 회신 메시지를 받아야하는지 (응답) 또는 회신을 자동으로 폐기해야하는지 (no_reply) 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 성공적으로 디코딩됩니다. 일반적으로 메시지에는 트랜잭션 목록이 포함되어 있으며이 함수는 메시지의 각 TransactionRequest에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 성공적으로 디코딩됩니다. 일반적으로 메시지에는 트랜잭션 목록이 포함되지만 대신 메시지의 최상위 레벨에 ErrorDescriptor가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">릴리스간에 호환되지 않는 변경이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">스트림 상태가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">잘못된 UTF 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스에서 일시 중단 횟수를 늘리고 해당 상태가 아닌 경우 일시 중단 상태로 만듭니다. 일시 중단 된 프로세스는 프로세스가 재개 될 때까지 실행 예약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">NIF 라이브러리가 호환되지 않는 변경 사항이 Erlang 런타임 시스템에 적용될 때 증가합니다. 일반적으로 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 이 변경 되면 NIF 라이브러리를 다시 컴파일하면 충분 하지만 드문 경우지만 NIF 라이브러리를 약간 수정해야 할 수도 있습니다. 그렇다면, 이것은 문서화 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">새로운 기능이 추가되면 증가합니다. 런타임 시스템은 부 버전을 사용하여 사용할 기능을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">MIB에서 변수를 &lt;code&gt;N&lt;/code&gt; 으로 증가 시키거나 &lt;code&gt;N&lt;/code&gt; 을 지정하지 않은 경우 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">이터레이터는 다음 키-값 항목을 가리 키도록 반복자를 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금의 참조 횟수를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">에 증가 참조 카운트를 &lt;code&gt;bin&lt;/code&gt; 반환은 참조 횟수가 증가 후에 도달했다.</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">폐기 된 pdu와 연관된 변수를 증가시킵니다. 이 기능은 net_if 프로세스 가 에이전트로부터 &lt;code&gt;discarded_pdu&lt;/code&gt; _pdu 메시지를 수신 할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">문서를 오른쪽으로 여러 문자 위치를 들여 씁니다. 참고 &lt;code&gt;N&lt;/code&gt; 은 케이스있는 왼쪽, 또는 제로의 텍스트를 이동, 음수 일 수 &lt;code&gt;D&lt;/code&gt; 는 그대로 리턴된다.</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">인덱스는 무료로 제공되지 않습니다. 테이블 크기에 비례하는 공간을 차지하며 테이블 삽입이 약간 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">테이블의 인덱스는 유형이 아닌 객체 여야합니다 (SMIv1과 다름).</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">끊어진 링크를 나타냅니다. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 에는 연결된 프로세스의 pid가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">결과 파서 파일의 시작 부분에 포함 된 기본 파일 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; 대신 사용자가 사용할 수있는 사용자 정의 된 프롤로그 파일을 나타냅니다 . &lt;strong&gt;NB &lt;/strong&gt; &lt;code&gt;Includefile&lt;/code&gt; 는 그것의 자신의 모듈 선언이 없어야하므로, 파서 파일에 '있는 그대로', 그리고 컴파일하지 말아야 포함되어 있습니다. 그러나 필요한 내보내기 선언이 포함되어 있어야합니다. 기본값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">연관 &lt;code&gt;assoc_id&lt;/code&gt; 내에서 &lt;code&gt;addr&lt;/code&gt; 로 지정된 피어의 IP 주소 상태 변경을 나타냅니다 . 가능한 &lt;code&gt;state&lt;/code&gt; 값 (주로 자체 설명)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">문자 범위를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 응용 프로그램 코드 경로를 업데이트할지 ( &lt;code&gt;Bool==true&lt;/code&gt; ) 수정 된 응용 프로그램의 코드 경로 만 업데이트할지 ( &lt;code&gt;Bool==false&lt;/code&gt; , 기본값)를 나타냅니다. 이 옵션은 기본 &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; 이외의 다른 응용 프로그램 디렉토리 , 즉 &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 AppDirs 인수에 지정된 응용 프로그램 디렉토리 &lt;code&gt;AppDirs&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">프로세스 정보를 수집할지 여부를 나타냅니다. 경우 &lt;code&gt;PI = true&lt;/code&gt; (기본이되는), 식별자 각 공정 &lt;code&gt;Pid&lt;/code&gt; 튜플로 대체 &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; , &lt;code&gt;ProcessInfo&lt;/code&gt; 는 등록 프로세스 명, 그 전역 등록 된 이름, 또는 초기 기능. 이 기능을 끄려면 &lt;code&gt;PI = false&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">테이블이 압축되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">프로세스가 테이블을 수정했는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">테이블의 이름이 지정되었는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">자녀가 감독자의 관점에서 종료 된 단계를 나타냅니다. &lt;code&gt;start_error&lt;/code&gt; , &lt;code&gt;child_terminated&lt;/code&gt; 또는 &lt;code&gt;shutdown_error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">프로세스를 시작 &lt;strong&gt;하기 전에&lt;/strong&gt; 로드 &lt;strong&gt;해야하는&lt;/strong&gt; 모든 모듈이 로드 되었음을 나타냅니다 . 대화식 모드 에서이 명령 이후 해석 된 모든 &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; 명령은 무시되며 이러한 모듈은 요청시로드됩니다. 내장 모드에서는 &lt;code&gt;kernel_load_completed&lt;/code&gt; 가 무시되고 시스템 시작 중에 모든 모듈이로드됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">일반 전송 작업이 발생했음을 나타냅니다. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 수신자 (C-node)의 pid 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">더 이상 데이터가 전송되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">명령 실행을 위해 시작된 &lt;code&gt;ssh_client_channel&lt;/code&gt; 이 이제 종료되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">클라이언트가 Next Protocol Negotiation을 수행하려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">Telnet 클라이언트가 유휴 시간 (즉, 데이터가 수신되지 않은 경우) 이상 &lt;code&gt;IdleTimeout&lt;/code&gt; 밀리 초 이상 동안 함수가 리턴해야 함을 나타냅니다 . 기본 시간 제한은 10 초입니다.</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">로그가 타임 스탬프에 따라 병합되지 않고 파일마다 하나씩 처리됨을 나타냅니다 (조금 더 빠를 수 있음).</target>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상대방이 더 이상 데이터를 보내지 않음을 나타냅니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">&lt;code&gt;MSec&lt;/code&gt; 밀리 초 후에 추적이 자동으로 중지됨을 나타냅니다 . &lt;code&gt;StopOpts&lt;/code&gt; 는 지정된 경우 명령 &lt;code&gt;ttb:stop/2&lt;/code&gt; 에 전달 됩니다 (기본값은 &lt;code&gt;[]&lt;/code&gt; ). 네트워크 통신과 관련된 지연이 항상 존재하므로 타이밍은 대략적인 것입니다. &lt;code&gt;ttb:p/2&lt;/code&gt; 가 실행 된 후 타이머가 시작 되므로 추적 패턴을 미리 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">결과를 얻기에 충분한 입력 데이터가 있음을 나타냅니다. &lt;code&gt;Result&lt;/code&gt; 는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">이 호출이 드라이버에서 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 를 제거 했지만 여전히 사용중인 열린 포트가 있음을 나타냅니다 . 모든 포트가 닫히고 새로운 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 도착 하지 않으면 드라이버가 다시로드되고 이름과 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">추적이 중지 된 후 추적 로그가 수집되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">추적 메시지가 추적 프로세스에 수신 될 때 콘솔에 추적 메시지가 인쇄됨을 나타냅니다. 이는 추적 클라이언트 &lt;code&gt;{local, File}&lt;/code&gt; 의미합니다 . &lt;code&gt;ShellSpec&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 가 아닌 &lt;code&gt;only&lt;/code&gt; 경우 에는 추적 로그가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">파일 소유자를 나타냅니다. 비 유닉스 파일 시스템에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">inets 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">파일의 소유자를 나타냅니다. 비 유닉스 파일 시스템에서이 필드는 0입니다.</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">리턴 값이 &lt;code&gt;{stopped, Dir}&lt;/code&gt; 이고 &lt;code&gt;stopped&lt;/code&gt; 되지 않은 것을 나타냅니다 . 이것은 &lt;code&gt;fetch&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">서버가 ALPN (Application-Layer Protocol Negotiation)을 수행하려고 시도 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">추적이 중지 된 후 형식화 될 추적 로그를 나타냅니다. 페치 디렉토리의 모든 로그가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">테이블이 &lt;code&gt;read_concurrency&lt;/code&gt; 를 사용하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">테이블이 &lt;code&gt;write_concurrency&lt;/code&gt; 를 사용하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">기능 교환이 TLS를 사용하여 대역 내 보안을 선택했는지 여부를 나타냅니다. &lt;code&gt;Ref&lt;/code&gt; 는 전송의 부모 프로세스 에 대한 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 응답 메시지에 포함되어야하는 reference ()입니다 (아래 참조). &lt;code&gt;Type&lt;/code&gt; 은 연결 또는 청취 전송에 대해 프로세스가 각각 시작되었는지에 따라 &lt;code&gt;connect&lt;/code&gt; 또는 &lt;code&gt;accept&lt;/code&gt; 입니다. &lt;code&gt;Bool&lt;/code&gt; 은 전송 연결을 TLS로 업그레이드해야하는지 여부를 나타내는 boolean ()입니다.</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">개별 패턴은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">Origin-State-Id에서 세션 종료 유추</target>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">무한 루프는 예를 들어 상한이없는 수량 자와 문자를 일치시킬 수없는 하위 패턴을 따라 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">배송 결과를 알려주세요.</target>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">대상 주소를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=accept&lt;/code&gt; 인 전송 프로세스가 피어와 연결을 설정 했음을 부모에게 알리십시오 . 전송 프로세스에 &lt;code&gt;Type=connect&lt;/code&gt; 가 있으면 전송되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=connect&lt;/code&gt; 인 전송 프로세스가 피어와 연결 을 설정 했음을 부모에게 알리십시오 . 전송 프로세스에 &lt;code&gt;Type=accept&lt;/code&gt; 가 있으면 전송되지 않습니다 . &lt;code&gt;Remote&lt;/code&gt; 는 전송이 연결된 리모트 엔드 포인트를 고유하게 식별하는 임의의 용어입니다. &lt;code&gt;LocalAddr&lt;/code&gt; 의 리스트로부터 리턴 된 것과 동일한 의미를 가지고 &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">비공식적으로 I / O 목록은 Erlang 포트로 보낼 수있는 문자 및 이진의 깊은 목록입니다. BNF에서 I / O 목록은 공식적으로 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">정보 객체 클래스, 정보 객체 및 정보 객체 세트 (각각 다음의 클래스, 객체 및 객체 세트)는 표준 정의 X.681에 정의되어 있습니다. 여기서는 간단한 설명 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">모든 디버깅 된 프로세스, 즉 해석 된 모듈에서 코드를 실행했거나 실행중인 모든 프로세스에 대한 정보</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">업그레이드 또는 다운 그레이드가 수행 될 때 스크립트에서 응용 프로그램에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">Erlang 구현에 대한 정보는 예를 들어 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">충돌 프로세스에 링크되고 종료를 트랩하지 않는 프로세스에 대한 정보. 이러한 프로세스는이 프로세스 충돌로 인해 종료되는 이웃입니다. 수집 된 정보는 이전 항목에서 설명한 Crasher의 정보와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">초기 함수 호출, 종료 이유 및 메시지 큐와 같은 충돌 프로세스에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">&lt;code&gt;--add_to_plt&lt;/code&gt; 옵션을 사용하여 기존 PLT에 정보를 추가 할 수 있습니다 . Erlang 컴파일러를 PLT에 포함시키고 새 PLT에 배치하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">테스트 케이스 특성 목록을 리턴하는 정보 함수. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">테스트 케이스 그룹의 특성을 리턴하는 데 사용되는 정보 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">제품군의 속성을 반환하는 데 사용되는 정보 함수입니다. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">정보 함수는 &lt;code&gt;init_per_suite&lt;/code&gt; , &lt;code&gt;end_per_suite&lt;/code&gt; , &lt;code&gt;init_per_group&lt;/code&gt; 및 &lt;code&gt;end_per_group&lt;/code&gt; 함수에도 사용할 수 있으며 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동합니다 . 예를 들어, 타임 트랩을 설정하고 해당 구성 기능과 관련된 외부 구성 데이터가 필요한 경우에 유용합니다 (스위트의 그룹 및 테스트 케이스에 설정된 특성에 영향을주지 않음).</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">콜백 함수 &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; 에 대한 호출을 통해 정보가 수신자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">제공된 fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; 에 대한 호출을 통해 정보가 수신자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">현재 기본 피어 주소에 대한 정보 ( &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; 형식은 아래 참조 )</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로 정보 전달 &lt;code&gt;Allowed&lt;/code&gt; 에 &lt;code&gt;accept_connection/5&lt;/code&gt; . 이 필드는 원격 노드가 연결을 시작한 경우에만 필수입니다. 즉, &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 를 통해 연결이 설정된 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 추적 정보 파일에 정보를 추가 할 수 있습니다 . 공지 사항 것을 &lt;code&gt;ValueList&lt;/code&gt; 는 항상 목록입니다, 당신이 호출하면 &lt;code&gt;write_trace_info/2&lt;/code&gt; 같은과 함께 여러 번 &lt;code&gt;Key&lt;/code&gt; 는 &lt;code&gt;ValueList&lt;/code&gt; 는 새 값마다로 확장된다.</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">유익한 참고 문헌</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">테스트 케이스를위한 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">테스트 케이스 그룹의 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">테스트 스위트를위한 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">테스트 스펙 용어 &lt;code&gt;init&lt;/code&gt; 를 사용하여 테스트 대상 노드에서 초기 조치를 자동으로 시작하고 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">초기 콜백 상태 우세한 상태는 어떤 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백으로 전달되며 , 그러면 새로운 상태를 반환 할 수 있습니다. &lt;code&gt;alias&lt;/code&gt; 옵션 의 값이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">사용자의 초기 구성</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">벤치 마크의 초기 구성이 완료되었습니다. 실제 벤치 마크 및 Mnesia를 프로파일 링 할 때입니다</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">구두점</target>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; 가 읽은 초기화 구조 .</target>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">속성 테스트를위한 &lt;code&gt;Config&lt;/code&gt; 을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">zlib 스트림에서 압축 해제 세션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">압축을 위해 zlib 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">압축 해제를 위해 zlib 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 변수를 초기화하여 호출 프로세스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">서버의 노드 이름과 쿠키를 식별하기 위해 &lt;code&gt;ec&lt;/code&gt; 구조를 초기화 합니다. &lt;code&gt;ei_cnode&lt;/code&gt; 유형 에서 작동하는 다른 함수 나 다른 노드에 대한 연결과 연관된 파일 디스크립터를 사용 하기 전에 이들 중 하나를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">&lt;code&gt;erl_connect&lt;/code&gt; 모듈을 초기화합니다 . 특히,이 함수는 호출 된 C 노드의 이름을 식별하는 데 사용됩니다. &lt;code&gt;erl_connect&lt;/code&gt; 모듈 의 다른 기능을 사용 하기 전에이 기능 중 하나를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">압축 된 출력을 생성하지 않고 지정된 바이트 시퀀스에서 압축 사전을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">스트리밍 HMAC 작업에 대한 컨텍스트를 초기화합니다. &lt;code&gt;Type&lt;/code&gt; 은 HMAC 작업에 사용할 해시 함수를 결정합니다. &lt;code&gt;Key&lt;/code&gt; 는 인증 키입니다. 키는 임의의 길이가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스트리밍 해시 작업에 대한 컨텍스트를 초기화합니다. &lt;code&gt;Type&lt;/code&gt; 은 사용할 다이제스트를 결정합니다. 리턴 된 컨텍스트는 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; 의 인수로 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">지정된 비 압축 바이트 시퀀스에서 압축 해제 사전을 초기화합니다. 이 함수는 &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; 을 리턴 하거나 더 이상 사용되지 않는 함수의 경우 &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; 리턴 하는 팽창 조작 (예 : &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; )에 대한 응답으로 호출되어야합니다. }} 예외.</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">RC4 스트림 암호화에 사용할 상태를 초기화합니다. &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터 모드 (CTR)를 사용하여 스트리밍 AES 암호화에서 사용할 상태를 초기화합니다. &lt;code&gt;Key&lt;/code&gt; 는 AES 키이며 길이는 128, 192 또는 256 비트 여야합니다. &lt;code&gt;IVec&lt;/code&gt; 은 128 비트 (16 바이트)의 임의의 초기화 벡터입니다. 이 상태는 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">&lt;code&gt;iolist&lt;/code&gt; 와 동일한 바이트 내용을 갖는 연속 버퍼를 사용하여 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 구조를 초기화합니다 . &lt;code&gt;inspect_binary&lt;/code&gt; 와 마찬가지로 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 데이터 는 일시적이므로 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">이진 용어 &lt;code&gt;bin_term&lt;/code&gt; 에 대한 정보 로 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 구조를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 초기화</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">데이터베이스 초기화</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">해당 데이터베이스를 운영 할 노드를 지정하는 속성을 사용하여 새 데이터베이스 스키마를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">처음에 768 단어 + 각 요소의 크기 (6 단어 + Erlang 데이터의 크기). 필요한 경우 테이블이 커집니다.</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">처음에 코드 경로는 현재 작업 디렉토리와 라이브러리 디렉토리 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 아래의 모든 Erlang 오브젝트 코드 디렉토리로 구성됩니다 . 여기서 &lt;code&gt;$OTPROOT&lt;/code&gt; 는 Erlang / OTP의 설치 디렉토리, &lt;code&gt;code:root_dir()&lt;/code&gt; 입니다. 디렉토리 이름을 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 지정할 수 있으며 기본적으로 코드 서버는 동일한 &lt;code&gt;Name&lt;/code&gt; 을 가진 디렉토리 중에서 가장 높은 버전 번호를 가진 디렉토리를 선택합니다 . 접미사 &lt;code&gt;-Vsn&lt;/code&gt; 은 선택 사항입니다. &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 아래에 있으면 이 디렉토리가 코드 경로에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">처음에 코드 경로는 현재 작업 디렉토리와 &lt;code&gt;ROOT/lib&lt;/code&gt; 아래의 모든 객체 코드 디렉토리로 구성됩니다 . 여기서 &lt;code&gt;ROOT&lt;/code&gt; 는 Erlang / OTP의 설치 디렉토리입니다. 디렉토리 이름은 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 지정할 수 있습니다 . 코드 서버는 기본적으로 &lt;code&gt;Name&lt;/code&gt; 이 같은 디렉토리 중에서 버전 번호가 가장 높은 디렉토리를 선택합니다 . &lt;code&gt;-Vsn&lt;/code&gt; 접미사는 선택 사항입니다. &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 디렉토리 아래에 있으면 이 디렉토리가 코드 경로에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">알림 &lt;code&gt;Notification&lt;/code&gt; 을 사용하여 &lt;code&gt;TargetName&lt;/code&gt; 으로 식별 된 관리자와 함께 발견 프로세스를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">전송 서비스를 시작하고 megaco : user_info / 2에서받은 수신 핸들을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Addr&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 로 지정된 피어 (SCTP 서버 소켓)를 사용하여 &lt;code&gt;Socket&lt;/code&gt; 에 대한 새 연관을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">새로운 핸드 셰이크를 시작합니다. 주목할만한 리턴 값은 &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; 이며 피어가 재협상을 거치지 않았지만 이전에 협상 된 세션을 사용하여 연결이 여전히 활성 상태임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">압축을 위해 zlib 스트림을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">하트 비트를 즉시 시작합니다</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러를 시작합니다. &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; 호출에 사용될 &lt;code&gt;Args&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">관리자에 대한 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 는 감지 기능 을 호출하여 수행됩니다 . &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; 파일 에서 대상 (관리자) 항목 의 &lt;code&gt;EngineId&lt;/code&gt; 필드는 &lt;code&gt;discovery&lt;/code&gt; 값을 가져야합니다 . 관리자가 응답하지 않으면 &lt;code&gt;Timeout&lt;/code&gt; 및 &lt;code&gt;RetryCount&lt;/code&gt; 필드는 함수가 반환되기 전에 얼마나 오래 중단 될지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시스템 추적 프로그램 시작 추적 포트가 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 로 시작되면 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">인라인이 반드시 실행 시간을 개선하지는 않습니다. 예를 들어, 인라인은 빔 스택 사용을 증가시킬 수 있으며, 이는 재귀 함수의 성능에 해로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">인라인은 기본값이 아닙니다. 소스 모듈에서 컴파일러 옵션 또는 &lt;code&gt;-compile()&lt;/code&gt; 속성을 사용하여 명시 적으로 사용 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력 한 내용이다 &lt;code&gt;modify_algs_list()&lt;/code&gt; 및 알고리즘의 집합 &lt;code&gt;A&lt;/code&gt; 는 로부터 얻어진 &lt;code&gt;preferred_algorithms&lt;/code&gt; 의 , 또는 그 밖의 경우에서의 기존 옵션 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">SSL 애플리케이션 로컬 캐시에 CRL을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">사전 항목을 삽입하고 등록 된 모든 구독자에게 {et, {dict_insert, Key, Val}} 튜플을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 및 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블에서 삽입 및 조회 시간 은 테이블 크기에 관계없이 일정합니다. 들어 &lt;code&gt;ordered_set&lt;/code&gt; 데이터 유형, 시간은 개체의 수의 (이진) 대수에 비례한다.</target>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">이전에 죽인 텍스트 삽입</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">일부 데이터 삽입</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">이벤트를 삽입하면 다른 이벤트보다 먼저 삽입 된 이벤트를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 과 같이 자주 사용하는 상태 처리 함수를 호출하는 트릭이 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">추상 Erlang 구문 트리에 주석 삽입</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">추상 Erlang 구문 트리에 주석 삽입</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">큰 테이블에서는 삽입 및 삭제가 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 테일 항목으로 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 새로운 큐 &lt;code&gt;Q2&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 앞에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 결과 큐 &lt;code&gt;Q2&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 헤드에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 새로운 큐 &lt;code&gt;Q2&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 뒷면에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 결과 큐 &lt;code&gt;Q2&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">값이 &lt;code&gt;Value&lt;/code&gt; 인 &lt;code&gt;Key&lt;/code&gt; 를 &lt;code&gt;Tree1&lt;/code&gt; 에 삽입 하고 새 트리를 반환합니다. 키가 트리에 존재하지 않으면 충돌이 발생한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">삽입 &lt;code&gt;Key&lt;/code&gt; 값 &lt;code&gt;Value&lt;/code&gt; 에 &lt;code&gt;Tree1&lt;/code&gt; 키가 트리에없는 경우, 그렇지 않으면 갱신 &lt;code&gt;Key&lt;/code&gt; 값에 &lt;code&gt;Value&lt;/code&gt; 에 &lt;code&gt;Tree1&lt;/code&gt; . 새로운 트리를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">&lt;code&gt;List1&lt;/code&gt; 의 각 요소 사이에 &lt;code&gt;Sep&lt;/code&gt; 를 삽입합니다 . 빈 목록과 싱글 톤 목록에는 영향을 미치지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">색인 구조에 새 키 값 튜플을 삽입합니다. 동일한 키를 가진 항목이 이미 존재하면 새 &lt;code&gt;Value&lt;/code&gt; 이 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 인 행을 포함하여 이전 데이터를 모두 삭제합니다 . 구성 파일에서 작성된 행은 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 모든 이전 데이터를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 StorageType &lt;code&gt;volatile&lt;/code&gt; 을 사용 하여 이전 행을 모두 삭제합니다 . 구성 파일에서 작성된 행은 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">하나 이상의 객체를 테이블 &lt;code&gt;Name&lt;/code&gt; 에 삽입합니다 . 지정된 개체의 키와 일치하는 키가있는 개체가 이미 있으면 테이블이 업데이트되지 않고 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 객체가 삽입되고 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">테이블 &lt;code&gt;Name&lt;/code&gt; 에 하나 이상의 객체를 삽입합니다 . 주어진 객체 중 일부의 키와 일치하는 키를 가진 객체가 이미 존재하고 테이블 유형이 &lt;code&gt;set&lt;/code&gt; 있으면 이전 객체가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ObjectOrObjects&lt;/code&gt; 목록의 객체 또는 모든 객체 를 테이블 &lt;code&gt;Tab&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">Dets 테이블 &lt;code&gt;Name&lt;/code&gt; 의 오브젝트를 ETS 테이블 &lt;code&gt;EtsTab&lt;/code&gt; 에 삽입 합니다. 개체가 삽입되는 순서는 지정되지 않았습니다. 덮어 쓰지 않으면 ETS 테이블의 기존 개체가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">문자 클래스 안에서 \ b는 다른 의미를 가지고 있습니다. 백 스페이스 문자와 일치합니다. 이러한 어설 션 중 하나라도 문자 클래스에 나타나는 경우 기본적으로 해당 리터럴 문자와 일치합니다 (예 : \ B는 문자 B와 일치).</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">문자 클래스 내에서 또는 \ 다음에 오는 10 진수가&amp;gt; 7이고 캡처하는 하위 패턴이 많지 않은 경우 PCRE는 \ 8과 \ 9를 리터럴 문자 &quot;8&quot;과 &quot;9&quot;로 처리하고 그렇지 않으면 다시 읽습니다. 백 슬래시 다음에 3 자리 8 진수를 사용하고이를 사용하여 데이터 문자를 생성합니다. 모든 후속 숫자는 자체를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">옵션 검사 및 테이블 정보 수집. 결과적으로 한정자는 최적화 단계에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">프로세스의 메시지 큐를 검사합니다. 큐가 평가자 영역에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">스택에서 다음 함수 호출을 검사하여 위치 및 변수 바인딩을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">스택에서 이전 함수 호출을 검사하여 위치 및 변수 바인딩을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test Hooks&lt;/code&gt; 설치하십시오 ( &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;event_handler&lt;/code&gt; 플러그인을 설치하십시오 ( &lt;code&gt;ct_run -event_handler&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">Microsoft Windows SDK 8.1 설치</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">Visual Studio 12.0 (2013) 설치</target>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">작성된 대상 시스템 설치</target>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">pgm 폴더에 설치하거나 압축을 풉니 다 : Cygwin : &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS : &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2 : &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">꼭 필요한대로 로트, 특히 최신 사용자 인터페이스 구성 요소를 설치하십시오. 넣어 &lt;code&gt;makensis&lt;/code&gt; 를 내 경우, 경로에 :</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; 대상을 사용하여 설치하십시오 . &lt;code&gt;make install&lt;/code&gt; 을 수행하는 대신 &lt;code&gt;release&lt;/code&gt; 대상을 사용하여 원하는 디렉토리 에 &lt;code&gt;Install&lt;/code&gt; 작성 하고 Install 스크립트를 직접 실행할 수 있습니다. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 는 설치를 작성해야하는 디렉토리를 지정하는 데 사용됩니다. &lt;code&gt;make install&lt;/code&gt; 을 사용하여 설치하는 경우 기본적으로 &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; 아래에 있습니다 . &lt;code&gt;configure&lt;/code&gt; 단계 에서 제공된 모든 설치 경로 와 &lt;code&gt;DESTDIR&lt;/code&gt; 및 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 가 무시됩니다 . 특정 &lt;code&gt;bin&lt;/code&gt; 에서 링크를 원하는 경우설치 디렉토리를 직접 설정해야합니다. Erlang / OTP가 &lt;code&gt;/home/me/OTP&lt;/code&gt; 에 위치해야하는 예 :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">수동 설치</target>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">configure에 의해 결정된 경로를 사용하여 설치</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">폴백 설치는 분산 작업이며 모든 &lt;code&gt;db_nodes&lt;/code&gt; &lt;strong&gt;에서만&lt;/strong&gt; 수행됩니다 . 폴백은 다음에 시스템이 시작될 때 데이터베이스를 복원합니다. 경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 대체와 노드가 감지를 설치 &lt;code&gt;Mnesia&lt;/code&gt; 다른 노드가 사망했다, 그것은 무조건 자신을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">시스템에 프로세스가 많은 경우 새 릴리스를 설치하는 데 시간이 오래 걸릴 수 있습니다. 그 이유는 모듈을 제거하기 전에 각 프로세스에서 이전 코드에 대한 참조를 확인해야하기 때문입니다. 이 검사는 가비지 수집 및 데이터 복사로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">임베디드 시스템 설치</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">애플리케이션 os_mon에 os_sup 모듈 설치</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">백업을 폴백으로 설치합니다. 폴백은 다음에 시작할 때 데이터베이스를 복원하는 데 사용됩니다. 폴백을 설치하려면 관련된 모든 노드에서 Erlang이 작동해야하지만 Mnesia가 실행 중인지 여부는 중요하지 않습니다. 로컬 노드가 백업에서 디스크 상주 노드 중 하나가 아닌 경우 대체 설치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">릴리스 구조에 릴리스 종속 파일을 설치합니다. 새 릴리스가 설치 될 때 릴리스 종속 파일은 릴리스 구조에 있어야합니다 ( &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;relup&lt;/code&gt; 및 &lt;code&gt;sys.config&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">구성 파일 및 이벤트 핸들러를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">릴리스 의 지정된 버전 &lt;code&gt;Vsn&lt;/code&gt; 을 설치합니다 . 현재 버전에서 업그레이드 하기 위해 &lt;code&gt;Vsn&lt;/code&gt; 의 &lt;code&gt;relup&lt;/code&gt; 파일 과이 파일 의 스크립트 &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; 을 먼저 찾습니다 . 찾을 수없는 경우에 대한 기능 외모 &lt;code&gt;relup&lt;/code&gt; 의 현재 버전과 스크립트 파일 &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; 으로 다운 그레이드이 파일에서 &lt;code&gt;Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; 및 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 대신 &lt;code&gt;information object class&lt;/code&gt; , &lt;code&gt;table constraints&lt;/code&gt; 및 &lt;code&gt;parameterization&lt;/code&gt; 를 사용하는 것이 좋습니다 . 특히 &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; 구문 은 더 이상 사용되지 않는 &lt;code&gt;ANY&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">타임 아웃을 취소 할 때 방해하지 않고 늦은 타임 아웃 이벤트는 지연된 것으로 알려진 상태에 도달하면 무시하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">이 옵션은 디렉토리로 추출하는 대신 결과를 튜플 &lt;code&gt;{Filename, Binary}&lt;/code&gt; 목록으로 제공합니다 . 여기서 &lt;code&gt;Binary&lt;/code&gt; 는 tar 파일에 &lt;code&gt;Filename&lt;/code&gt; 이라는 파일 의 추출 된 데이터를 포함하는 이진 입니다.</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">현재 디렉토리로 추출하는 대신 결과는 튜플 목록 &lt;code&gt;{Filename, Binary}&lt;/code&gt; . 여기서 &lt;code&gt;Binary&lt;/code&gt; 는 zip 아카이브에 &lt;code&gt;Filename&lt;/code&gt; 파일의 추출 된 데이터를 포함하는 이진 입니다.</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">인코딩 / 디코딩 방식을 발명하는 대신 &lt;code&gt;term_to_binary/1&lt;/code&gt; 및 &lt;code&gt;binary_to_term/1&lt;/code&gt; BIF가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">파일에 기록한 후 이벤트를 유지하는 대신 파일에 성공적으로 기록한 후 저장된 모든 이벤트를 제거 할 수 있습니다 (지우기).</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">하나는 서버에, 하나는 수신인에 두 개의 &lt;strong&gt;완전한 디코드&lt;/strong&gt; (일반적인 디코딩의 경우) 를 만드는 대신 , 하나의 &lt;strong&gt;전문화 된 디코드&lt;/strong&gt; (서버에서)와 다른 하나의 완전한 디코드 (어드레스에서) 만 수행하면됩니다. 이 섹션에서는이 문제와 비슷한 문제를 해결하기 위해 지원되는 다음과 같은 두 가지 특수한 디코딩에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">테스트 사례간에 데이터를 전달하는 대신 테스트 사례는 SUT에서 상태를 읽고 어설 션을 수행하는 것이 좋습니다 (즉, 상태가 예상 한 경우 테스트 사례를 실행하도록하고 그렇지 않으면 재설정 또는 실패). 상태를 사용하여 테스트 케이스가 올바르게 실행되는 데 필요한 변수를 설정하는 것이 좋습니다. 공통 조치는 종종 테스트 케이스가 SUT를 필수 상태로 설정하기 위해 호출하는 라이브러리 함수로 구현 될 수 있습니다. (필요한 경우 이러한 공통 작업을 별도로 테스트하여 예상대로 작동하는지 확인할 수도 있습니다). 테스트를 하나의 테스트 케이스로 그룹화하는 것이 가능하지만 항상 바람직한 것은 아닙니다. 즉, 테스트 케이스가 &quot;시나리오&quot;테스트 (하위 테스트로 구성된 테스트)를 수행하게 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">메시지를 보내고받는 대신 사용할 수있는 여러 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">&lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; 을 사용하여 호출 스택 역 추적을 검색하는 대신 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">F 또는 x F y에 (x, y)를 쓰지 않고 F가 함수일 때 F (x) = y를 쓰고 F가 x를 y에 매핑하거나 x의 F 값이 y라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">대신 &lt;code&gt;ordsets&lt;/code&gt; 에서 ordsets 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">대신 처음부터 또는 생성 된 버전을 편집하여 올바른 &lt;code&gt;relup&lt;/code&gt; 파일을 수동으로 만들 수 있습니다. &lt;code&gt;ch_app&lt;/code&gt; 시작 / 중지 지시 사항은 응용 프로그램로드 / 언로드 지시 사항으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">대신 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">네트워크 인터페이스 프로세스에 응답 (확인)을 정보 요청으로 보내도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이에 대한 지침 은 위 순서대로 &lt;code&gt;relup&lt;/code&gt; 파일에 추가됩니다 . 응용 프로그램 버전 간 업그레이드 또는 다운 그레이드 지침은 관련 응용 프로그램 업그레이드 파일 &lt;code&gt;App.appup&lt;/code&gt; 에서 가져와 부팅 스크립트 생성시와 동일한 순서로 정렬됩니다 ( &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; 참조) . 고수준 명령어는 저수준 명령어로 변환되고 결과는 &lt;code&gt;relup&lt;/code&gt; 파일로 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">컴파일러가 &lt;code&gt;Directory&lt;/code&gt; 에서 포함 파일을 검색하도록 지시합니다 . &lt;code&gt;-include&lt;/code&gt; 또는 &lt;code&gt;-include_lib&lt;/code&gt; 지시문 이 발생하면 컴파일러는 다음 디렉토리에서 헤더 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 HTTP / 1.1 규격이라고 주장 할 때 영구 연결을 사용할지 서버에 지시합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">계측 플래그</target>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">SNMP-COMMUNITY-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">SNMP-FRAMEWORK-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">SNMP-NOTIFICATION-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">SNMP-TARGET-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">STANDARD-MIB 및 SNMPv2-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">인스 트루먼 테이션은 Distributed Erlang을 사용하여 애플리케이션과 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">스칼라 변수 및 테이블의 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 및 테이블의 &lt;code&gt;get-next&lt;/code&gt; 에 대한 계측 기능을 작성해야합니다 . &lt;code&gt;get-bulk&lt;/code&gt; 작업은하는 일련의 호출로 번역 &lt;code&gt;get-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">시스템의 저장 공간이 부족합니다 [452].</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">정수 (24 비트 부호 없음). DoS 공격을 피하기 위해 유효한 TLS 핸드 셰이크 패킷의 크기를 제한하는 데 사용됩니다. 기본값은 256 * 1024입니다.</target>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">정수 &lt;code&gt;PreviousSerial&lt;/code&gt; 은 추적 토큰을 전달한 마지막으로받은 메시지에 전달 된 직렬 카운터를 나타냅니다. 프로세스가 새로운 순차 추적에서 첫 번째 인 경우 &lt;code&gt;PreviousSerial&lt;/code&gt; 은 프로세스 내부 &quot;추적 클럭&quot;의 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">정수 &lt;code&gt;ThisSerial&lt;/code&gt; 은 프로세스가 발신 메시지에 설정하는 직렬 카운터입니다. 메시지 내부의 추적 토큰에 연결되기 전에 1 씩 증가하는 프로세스 내부 &quot;추적 클록&quot;을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">정수 나누기</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">X / Y의 정수 나머지</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">유효한 유니 코드 코드 포인트를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">예를 들어 &lt;code&gt;SIZE&lt;/code&gt; 표현식의 정수 값 은 16 진 또는 비트 구문이 아닌 10 진수 구문으로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">base &lt;strong&gt; &lt;code&gt;base&lt;/code&gt; &lt;/strong&gt; 인 정수로, 2..36 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">정수는 마이크로 초 여야합니다. 오프셋 &lt;code&gt;7200000000&lt;/code&gt; 은 &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">정수가 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">909로 시작하는 정수 (예 : &lt;code&gt;9091&lt;/code&gt; 또는 &lt;code&gt;909123&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">테스트를 용이하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS, 커널, STDLIB 또는 SASL이 업그레이드 될 때 사용됩니다. &lt;code&gt;relup&lt;/code&gt; 파일이 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성 될 때 자동으로 추가됩니다 . 다른 모든 업그레이드 지침 전에 실행됩니다. 이 명령어에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_new_emulator (낮은 수준)를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">의도적으로 문서화하지 않은 채로 두었습니다.</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">인터 콜 그래프 에지 (*).</target>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">상호 작용 데이터는 모듈 종속성을 강제하며 가능한 경우 피해야합니다. 이는 modules 속성의 모듈 순서가 중요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">SSL (Secure Socket Layer)을위한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">SNMP 툴킷 MIB 컴파일러에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">SNMP 툴킷 에이전트에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">클라이언트와 메신저 사이의 인터페이스 정의</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">SNMP 툴킷에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">SNMP 툴킷 관리자에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">XML 스키마 유효성 검사를위한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">XML 스키마 유효성 검사를위한 인터페이스 모듈. 이 문서는 2004 년 10 월 28 일자 XML Schema 제 2 판 의 W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; 을 다루고있다 . XML Schema 연구 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; 소개를 위해 xmerl_xsd : validate / [2,3]에 의해 XML 구조가 검증된다.</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 어플리케이션을 위한 인터페이스 모듈 .</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">ET (Event Trace) 애플리케이션을위한 인터페이스 모듈</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Megaco 애플리케이션을위한 인터페이스 모듈</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco / H.248 용 TPKT 전송 프로토콜에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco / H.248 용 UDP 전송 프로토콜에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">드라이버에 연결된 플렉스 스캐너에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">OS 시스템 메시지에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">TCP / IP 소켓에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">UDP 소켓에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">Windows 이벤트 로그에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">동적 추적에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">표준 Erlang I / O 서버에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Erlang 내장 용어 스토리지 BIF에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">내부 얼랭 정의.</target>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">잠금 세트의 내부 ID이며 항상 고유하지는 않습니다. ets 테이블의 테이블 이름 (db_tab), 포트의 포트 ID, 할당 자의 정수 식별자 등이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">내부 서버 오류는 오류 로그 파일에 기록됩니다. 이 파일의 형식은 Common Logfile 형식을 사용하는 로그보다 계획되지 않은 형식이지만 다음 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">채널의 내부 상태</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">내부적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 여러 커밋 프로토콜을 사용합니다. 선택된 프로토콜은 트랜잭션에서 업데이트 된 테이블에 따라 다릅니다. 관련된 모든 테이블이 대칭 적으로 복제되는 경우 (즉, 모두 코디네이터 노드에서 현재 액세스 할 수 있는 동일한 &lt;code&gt;ram_nodes&lt;/code&gt; , &lt;code&gt;disc_nodes&lt;/code&gt; 및 &lt;code&gt;disc_only_nodes&lt;/code&gt; 가 있는 경우) 경량 트랜잭션 커밋 프로토콜이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">내부적으로 &lt;code&gt;alloc_util&lt;/code&gt; 이라는 프레임 워크 가 할당자를 구현하는 데 사용됩니다. &lt;code&gt;sys_alloc&lt;/code&gt; 및 &lt;code&gt;mseg_alloc&lt;/code&gt; 은이 프레임 워크를 사용하지 &lt;strong&gt;않으므로&lt;/strong&gt; 다음이 적용 되지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">각 우선 순위 수준에서 내부적으로 프로세스는 라운드 로빈 방식으로 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">내부적으로 Erlang 런타임 시스템 잠금은 치명적인 방식으로 여러 스레드에서 자원이 업데이트되지 않도록 보호하는 데 사용됩니다. 런타임 시스템이 올바르게 작동하도록하려면 잠금이 필요하지만 몇 가지 제한 사항이 있습니다. 경합 및 잠금 오버 헤드를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">런타임 시스템에서 내부적으로 Erlang 단조 시간은 시간과 관련이있는 거의 모든 것에 사용되는 &quot;시간 엔진&quot;입니다. 타이머, BIF 타이머 또는 &lt;code&gt;timer(3)&lt;/code&gt; 모듈의 타이머에 관계없이 모든 타이머는 &lt;code&gt;receive ... after&lt;/code&gt; 관계없이 Erlang 단조 시간에 대해 트리거됩니다. &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 조차도 Erlang 단조 시간을 기준으로합니다. 현재 시간 오프셋과 함께 현재 Erlang 단조 시간을 추가하면 현재 Erlang 시스템 시간을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">내부적으로 바이너리와 비트 스트링은 같은 방식으로 구현됩니다. 이 섹션에서는 에뮬레이터 소스 코드에서 호출되기 때문에 &lt;strong&gt;바이너리&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">내부적으로 레코드는 태그가 지정된 튜플을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">내부적으로 감독자는 자식 프로세스 의 pid &lt;code&gt;Child&lt;/code&gt; 을 추적 하거나 pid가없는 경우 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">국제화 된 도메인 이름은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">해석 모듈은되는 모듈입니다 &lt;code&gt;.beam&lt;/code&gt; 의 옵션을 사용하여 컴파일 된 파일, &lt;code&gt;debug_info&lt;/code&gt; 세트, 소스 코드와 동일한 디렉토리에있는, 또는에서 &lt;code&gt;ebin&lt;/code&gt; 옆에 디렉토리.</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">통역 인터페이스.</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">세계시로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">mode 속성 값에 관계없이 escript를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">지정된 모듈을 해석합니다. &lt;code&gt;i/1&lt;/code&gt; 은 현재 노드에서만 모듈을 해석합니다. &lt;code&gt;ni/1&lt;/code&gt; 은 알려진 모든 노드에서 모듈을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈을 해석합니다. &lt;code&gt;ii/1&lt;/code&gt; 은 현재 노드에서만 모듈을 해석합니다 ( &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; 참조) . &lt;code&gt;ini/1&lt;/code&gt; 은 알려진 모든 노드에서 모듈을 해석합니다 ( &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">현지 시간으로 설정된 시간을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">빈 패밀리를 교차하면 &lt;code&gt;badarg&lt;/code&gt; 메시지 와 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">빈 세트 세트를 교차 &lt;code&gt;badarg&lt;/code&gt; 메시지 와 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">ERTS 8.1.2 (Erlang / OTP 19.2)에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">ERTS 8.3에 도입 (Erlang / OTP 19.3)</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">잘못된 주제 대체 이름 확장자입니다.</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">잘못된 유니 코드 코드 포인트는 0xd800에서 0xdfff (소위 &quot;대리&quot;코드 포인트) 범위 및 0xffef입니다.</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">잘못된 인수 : &lt;code&gt;to&lt;/code&gt; 는 유효한 Erlang pid가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">잘못된 사용자 이름 또는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">mib 서버 캐시를 무효화하십시오.</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">수량 자의 &quot;greediness&quot;를 반전시켜 기본적으로 욕심이 없지만 &quot;?&quot;가 오면 욕심이됩니다. Perl과 호환되지 않습니다. 패턴 내에서 &lt;code&gt;(?U)&lt;/code&gt; 옵션 설정 으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">각 트랜잭션 요청에 대해 호출</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">연결이 끊어졌을 때 호출</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">새 연결이 설정되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">수신 된 메시지에 구문 오류가있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">수신 된 메시지에 트랜잭션 목록 대신 오류가 포함되어있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">트랜잭션 요청이 중단되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">예기치 않은 메시지가 수신되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">파일 전송이 중단되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; 및 &lt;code&gt;To&lt;/code&gt; 를 &lt;code&gt;FromTo&lt;/code&gt; 로 설정하여 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">메모리 검사를 호출하고 결과로 시스템에 의존하는 데이터를 태그가 지정된 튜플 목록으로 반환합니다. 여기서 &lt;code&gt;Tag&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">Erlang / OTP 3.3에서 이전 Erlang 쉘을 호출합니다. 오래된 쉘을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">&lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; 를 호출하면 실패하거나, 최적이 아닌 코드를 자동으로 생성하거나, 잘못된 코드를 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">는 &lt;code&gt;0&lt;/code&gt; 일반 NIF 위해 (그 값은 정적으로 초기화를 위해 생략 될 수 &lt;code&gt;ErlNifFunc&lt;/code&gt; 의 경우).</target>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 조작 의 경우 열 번호 목록 및 &lt;code&gt;set&lt;/code&gt; 조작 의 경우 열 번호 및 값 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">도구에서 제공하는 meas.sh.skel 스켈레톤 스크립트를 수정하여 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">도구에서 제공하는 mstone1.sh.skel 스켈레톤 스크립트를 수정하여 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;height&lt;/code&gt; 가 정의되어 있으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 가 정의되어 있으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">함수 호출 횟수를 줄일 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">실제 프로토콜 버전입니다. 대부분의 경우 프로토콜 버전은 처리 된 메시지에서 검색되지만 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">플렉스 스캐너가 재진입입니까?</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">과 동일 &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">동일하다 &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">클라이언트 채널 프로세스가 호출하여 사용자 기본 쉘 (일반적으로 Unix 시스템의 / etc / passwd에 정의 됨)이 서버 측에서 실행되도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">서버에서 사전 정의 된 서브 시스템 실행을 요청하기 위해 클라이언트 채널 프로세스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">서버가 주어진 명령의 실행을 시작하도록 요청하기 위해 클라이언트 채널 프로세스에 의해 호출됩니다. 결과는 다음 패턴에 따라 여러 메시지가 나타납니다. 마지막 메시지는 &lt;code&gt;exec&lt;/code&gt; 요청이 완료되면 채널을 닫는 일회성 실행이므로 채널 닫기 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">서버의 채널 프로세스에 의해 호출되어 명령의 종료 상태를 클라이언트에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">클라이언트와 서버 채널 프로세스가 서로에게 데이터를 보내기 위해 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 인수로 사용됩니다. &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 의 반환 값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt; 과 함께 사용</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">&lt;code&gt;get next&lt;/code&gt; SNMP 동기화 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">동기식 SNMP &lt;code&gt;get&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">동기 SNMP &lt;code&gt;set&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;timer&lt;/code&gt; 가 &lt;code&gt;tracer/2&lt;/code&gt; 로 지정된 경우이 명령을 실행하면이 추적에 대한 타이머가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">F는 패밀리이며, F는 &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; 의 서브 세트입니다 . &lt;code&gt;union_of_family(F)&lt;/code&gt; 가 &lt;code&gt;domain(F)&lt;/code&gt; 의 하위 집합 인 경우 같음이 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">다른 테이블을이 노드에 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">또한 일부 SNMP 카운터를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">운영자가 시스템에 연결할 수 있도록 설정하는 &lt;code&gt;run_erl&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">그것은 호출 &lt;code&gt;start_erl&lt;/code&gt; 의 올바른 버전 호출 &lt;code&gt;erlexec&lt;/code&gt; (에 위치한 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; 올바른로) &lt;code&gt;boot&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">Erlang 프로그램 내부에서도 사용할 수 있습니다. 이 ASN.1 코드가 ASN.1 모듈 &lt;code&gt;Values&lt;/code&gt; 에 정의 된 경우 다음 예제와 같이 Erlang에서 ASN.1 값 &lt;code&gt;tt&lt;/code&gt; 에 &lt;code&gt;'Values':tt()&lt;/code&gt; 대한 함수 호출로 도달 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">다음과 같이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">로컬 노드에서 빠른 읽기 작업을 수행하기 위해 데이터를 자주 읽지 만 거의 쓰지 않는 분산 응용 프로그램에 대한 테이블 복제본을 만드는 것이 유리할 수 있습니다. 복제의 주요 단점은 데이터 쓰기 시간이 증가한다는 것입니다. 테이블에 두 개의 복제본이있는 경우 모든 쓰기 작업은 두 테이블 복제본에 모두 액세스해야합니다. 이러한 쓰기 작업 중 하나는 네트워크 작업이어야하므로 복제되지 않은 테이블보다 복제 된 테이블에 대한 쓰기 작업을 수행하는 것이 상당히 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">&lt;code&gt;sign&lt;/code&gt; 또는 &lt;code&gt;verify&lt;/code&gt; 를 호출하기 전에 메시지 요약을 계산 한 다음 두 번째 인수로 &lt;code&gt;none&lt;/code&gt; 을 사용 하는 것이 적절할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">다른 OTP 릴리스의 다양한 OTP 설치에서 코드를 실행해야 할 수도 있습니다. 그렇다면이 OTP (18) 전에 릴리스에서 사용할 수 없습니다, 당신은이 솔루션은, 상자의 새 API를 사용할 수 &lt;strong&gt;없는&lt;/strong&gt; 코드는 다음 확장 성 및 정확도 개선에서 혜택을받지 것처럼, 새로운 API를 사용하지 만든. 대신 사용 가능한 경우 새 API를 사용 하고 새 API를 사용할 수없는 경우 &lt;code&gt;erlang:now/0&lt;/code&gt; 으로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">DBMS가 일반 텍스트 파일에서 시작되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">이와 같은 목록에서 최대 및 최소 온도를 찾는 것이 유용 할 수 있습니다. 이를 위해 프로그램을 확장하기 전에 목록에서 요소의 최대 값을 찾는 함수를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">데이터가 Ets 테이블에 삽입되면 공유가 유실되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">그것은 될 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">선택적으로 다음 중 일부 또는 전부를 내보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">때때로 자신의 상태 머신에 이벤트를 생성 할 수있는 것이 유리할 수 있습니다. 이는 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">지정된 시간 동안 추적을 활성화하는 것이 도움이 될 수 있습니다 (예 : 24 시간 또는 0.5 초 동안 시스템을 모니터링하는 경우). &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; 옵션으로이를 수행 할 수 있습니다 . 경우 &lt;code&gt;TimerSpec&lt;/code&gt; 이 의 형태가 &lt;code&gt;MSec&lt;/code&gt; , 추적은 후 정지 &lt;code&gt;MSec&lt;/code&gt; 사용하여 밀리 초 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; . 추가 옵션이 제공되는 경우 ( &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ) &lt;code&gt;Opts&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 이 대신 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">선택 / 완전 디코딩 또는 배타적 / 부분 디코딩의 조합이 가장 빠른 경우에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">URL 참조로 인터넷에서 외부 엔티티를 검색 할 수없고 로컬 파일 시스템의 자원 만 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">그것은 원인 &lt;code&gt;Mnesia&lt;/code&gt; 을 디스크 전체 노드의 시작시 노드에 접속을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">동기 요청에 대한 늦은 응답 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">실제로 자체적으로 관리 기능을 구현하지는 않습니다. 그것은 &lt;strong&gt;사용자&lt;/strong&gt; 에게 달려 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 에서 응답을 기다리는 호출자에게 응답 합니다. &lt;code&gt;From&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 에 대한 호출 에서 인수 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 의 용어 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">UDP (User Datagram Protocol) 위에 구현되었으므로 UDP를 구현하는 다른 네트워크의 시스템간에 파일을 이동하는 데 사용될 수 있습니다. 작고 구현하기 쉽도록 설계되었습니다. 따라서 일반 FTP의 기능 대부분이 부족합니다. 그것이 할 수있는 유일한 것은 원격 서버와 파일을 읽거나 쓰는 것입니다. 디렉토리를 나열 할 수 없으며 현재 사용자 인증에 대한 규정이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">이전에는 각 테이블에 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 과 같은 여러 시스템 속성이있는 것으로 나타났습니다 .</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">목록의 모든 요소에 적용된 술어 가 &lt;code&gt;true&lt;/code&gt; 인 경우에 &lt;code&gt;true&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">쉘 및 명령 실행을 구현하는 채널 콜백 모듈입니다. 쉘의 읽기 평가 후면 인쇄 루프가 옵션을 사용하여 사용자 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; . 이는 자체 CLI 채널을 구현하는 것보다 적은 작업을 의미합니다. 경우 &lt;code&gt;ssh_cli&lt;/code&gt; 가 설정되어 &lt;code&gt;no_cli&lt;/code&gt; 의 CLI의 같은 채널 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 장애인 전용 서브 채널이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">이 항목이 작성되지 않은 이전 OTP 릴리스의 덤프입니다.</target>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">&lt;code&gt;deterministic&lt;/code&gt; 옵션이 지원되고 사용자가 제공 한 경우 컴파일러는 모든 비 결정적 정보를 제거하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Class&lt;/code&gt; 와 &lt;code&gt;Stacktrace&lt;/code&gt; 를 생략 할 수 있습니다. 생략 된 &lt;code&gt;Class&lt;/code&gt; 는 &lt;code&gt;throw&lt;/code&gt; 의 약자입니다 .</target>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">그것은 또한의 홈 디렉토리에 있다고 가정 &lt;code&gt;otpuser&lt;/code&gt; 라는 디렉토리가 &lt;code&gt;otp&lt;/code&gt; , 전체 경로는이다 :</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">또한 &lt;code&gt;ERL_ERROR&lt;/code&gt; (오류가 발생 함) 및 &lt;code&gt;ERL_TICK&lt;/code&gt; (다른 노드의 점검은 무시 됨) 유형을 처리해야합니다. 다른 가능한 유형은 링크, 링크 해제 및 종료와 같은 프로세스 이벤트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">또한, 완전한 디코드, 배타적 디코드 다음에 배제 된 부분의 &lt;code&gt;decode_part&lt;/code&gt; , 및 선택적 디코드 및 완전한 디코드 사이의 관계를 알고있는 것도 흥미 롭다 . 일부 상황은이 시뮬레이션과 비교할 수 있습니다 (예 : 하위 값 검사 및 나중에 전체 값 검사). 다음 표는이 테스트의 수치를 보여줍니다. 루프 수와 시간 단위는 이전 테스트와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">일반적인 Erlang 쉘 프롬프트에서 직접 &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; 를 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">예를 들어 건너 뛰거나 실패한 여러 가지 이유에 대해 더 깊이 파고 패턴 일치를 수행 할 수도 있습니다. 것을 알 수 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 튜플로 번역 &lt;code&gt;{error,Reason}&lt;/code&gt; . 경우주의 또한 &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; 결과를 수신, 테스트 케이스가 성공하지만, &lt;code&gt;end_per_testcase&lt;/code&gt; 경우에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">xmerl을 사용하여 구문 분석 된 XML을 추가로 처리 할 수도 있습니다. XML 문서의 형식을 예를 들어 HTML, 텍스트 또는 다른 XML 형식으로 변경하려는 경우이를 변환 할 수 있습니다. xmerl에서 이러한 변환을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; 와 같은 방식으로 OTP 응용 프로그램에서 MIB를 가져올 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">다음 호출 형식을 사용하는 경우 파서가 필요할 때 더 많은 입력 토큰을 요구하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">Erlang 에뮬레이터에서 내장 된 추적 지원을 사용하여 실행중인 시스템의 실시간 추적을 수행 할 수도 있습니다. 이러한 Erlang 추적은 파일 또는 포트로 전달 될 수 있습니다. 자세한 정보는 &lt;code&gt;erlang:trace/4&lt;/code&gt; , &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; , &lt;code&gt;dbg&lt;/code&gt; 및 &lt;code&gt;ttb&lt;/code&gt; 의 참조 매뉴얼을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">다음 리턴을 사용하여 문자를 입력 문자로 푸시 백 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">다음 구문을 사용하여 다른 모듈에 정의 된 함수를 참조 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">(? +2)와 같은 참조를 작성하여 나중에 열린 괄호를 참조 할 수도 있습니다. 그러나 참조가 참조 된 괄호 안에 없기 때문에 이들은 재귀적일 수 없습니다. 다음 섹션에서 설명하는 것처럼 항상 비 재귀 서브 루틴 호출입니다.</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">통지에는 보내야하지만 통지 스펙에는 정의되지 않은 추가 변수의 이름과 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">원시 프로파일 데이터를 작성하는 프로파일 링 프로세스, 즉 추적 및 프로파일 링 단계를 단락시켜 파일 시스템을 사용하지 않도록 즉시 추적 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">프로세스가있는 경우 자신 만의 Net을 작성할 수도 있으며이 섹션에서는이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">자신의 Net if 프로세스를 작성할 수도 있습니다. 기본 Net if 프로세스는 &lt;code&gt;snmpa_net_if&lt;/code&gt; 모듈에서 구현되며 전송 도메인, 즉 전송 도메인 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 및 / 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 로 UDP를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">&lt;code&gt;end_per_group/2&lt;/code&gt; 에서 하위 그룹의 상태를 확인하는 것도 가능 합니다 (현재 그룹이 어떤 상태를 반환할지 결정할 수 있음). 이는 이전 예에서 설명한 것처럼 간단하지만 그룹 이름 만 튜플 &lt;code&gt;{group_result,GroupName}&lt;/code&gt; 에 저장되며 상태 목록에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">&lt;code&gt;ct.hrl&lt;/code&gt; 헤더 파일은 모든 테스트 스위트 모듈에 포함되는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">여러 프로세스가 동일한 레코드를 동시에 업데이트하는 경우 트랜잭션 내에서 데이터베이스를 업데이트하는 것도 유용합니다. 예를 들어, 사람의 급여 필드에 &lt;code&gt;Amount&lt;/code&gt; 을 추가하는 &lt;code&gt;raise(Name, Amount)&lt;/code&gt; 함수 는 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">타이머가있는 프로그램은 디버깅 할 때 다르게 동작 할 수 있다는 점도 명심해야합니다. 프로세스 실행을 중지 할 때 (예 : 중단 점에서) 특히 그렇습니다. 그런 다음 정상적으로 실행되는 다른 프로세스에서 시간 초과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 모든 문자를 사용하지 않으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">다음과 같이 Erlang에 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">드라이버는 다른 드라이버에 액세스하지 않는 것으로 가정합니다. 드라이버가 서로 액세스하는 경우 스레드 안전 동기화를위한 고유 한 메커니즘을 제공해야합니다. 이러한 &quot;드라이버 간 통신&quot;은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">독자가 일부 프로그래밍을 수행했으며 데이터 유형 및 프로그래밍 언어 구문과 같은 개념에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어에 익숙하고 공개 키 및 디지털 인증서 사용의 개념을 기본적으로 이해하고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, &lt;strong&gt;OTP&lt;/strong&gt; 개념에 익숙하고 &lt;strong&gt;공개 키에&lt;/strong&gt; 대한 기본 지식을 가지고 있다고 가정 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 SNMP에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP의 개념에 익숙하고 관계형 데이터베이스 및 SQL에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 HTTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 FTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 TFTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 ASN.1 표기법에 익숙하다고 가정합니다. ASN.1 표기법은 기본 텍스트 인 표준 정의 X.680에 문서화되어 있습니다. 표준 정의 X.681, X.682, X.683, X.690 및 X.691을 읽는 것이 도움이되지만 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, 시스템 개발 원칙 및 데이터베이스 관리 시스템에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP의 개념에 익숙하고 SSL / TLS / DTLS에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">추적이 이미 사용 가능하다고 가정 &lt;code&gt;enable_trace&lt;/code&gt; 위의 enable_trace 참조).</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">Erlang 데이터 유형, 프로세스, 메시지 및 오류 처리와 같은 개념에 익숙한 숙련 된 Erlang 프로그래머라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">Erlang 프로그래밍 언어 및 OTP 개념에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">운전자에 대해 잘 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">OTP 설계 원칙에 따라 작동하는 Erlang / OTP 시스템이 작동한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">체계 문자열이 체계 원자로 변환되기 전에 호출되므로 원자 누출을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">ASN.1 모듈은 정의 된 유형, 값 및 기타 엔티티를 다른 ASN.1 모듈에서 가져 오는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">SNMP를 사용하여 시스템을 조작하고 제어하는 ​​응용 프로그램을 쉽게 설계 할 수 있습니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 SNMP 제어 응용 프로그램을 구성하는 논리 테이블과 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 구성하는 실제 데이터를 직접 매핑 합니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">하위 에이전트를 등록 할 때 실수를 저지르기 쉽고이 활동은 신중하게 수행해야합니다. 예를 들어 다음 구성에서 이상한 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">정규화 된 모델 대신 비정규 화 된 데이터 모델을 사용하면 더 빠르게 실행되는 코드의 예를 쉽게 보여줄 수 있습니다. 주된 이유는 더 적은 테이블이 필요하기 때문입니다. 따라서 조인 작업에서 다른 테이블의 데이터를보다 쉽게 ​​결합 할 수 있습니다. 이전 예에서 &lt;code&gt;get_emps/2&lt;/code&gt; 함수 는 결합 조작에서 하나의 단일 테이블에 대한 선택과 프로젝션으로 구성된 단순 조회로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">빈 디렉토리는 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">각 드라이버 인스턴스에 대해 &lt;code&gt;myKey&lt;/code&gt; 를 한 번만 초기화 하면 충분 합니다.</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">이 섹션에 설명 된 유형 언어는 &lt;code&gt;@spec&lt;/code&gt; 사용되는 순수 주석 기반 &lt;code&gt;@type&lt;/code&gt; 및 @spec 선언을 대체하고 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">생성 될 때마다 빈 목록을 생성하거나 단일 테스트 케이스와 나머지 테스트를 생성하는 새로운 생성기를 포함하는 목록을 생성하는 생성기를 작성하는 것은 매우 쉽습니다. 기본 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">매크로 정의가 유효한 Erlang 구문 형식인지 확인하는 것은 좋은 프로그래밍 관행이지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">테이블에 객체를위한 충분한 수의 슬롯이 있어야합니다. 그렇지 않으면, &lt;code&gt;init_table/2&lt;/code&gt; 가 리턴 될 때 해시 목록이 커지기 시작하여 일정 시간 동안 테이블에 대한 액세스 속도가 현저히 느려집니다. 최소 슬롯 수는 &lt;code&gt;open_file/2&lt;/code&gt; 옵션 &lt;code&gt;min_no_slots&lt;/code&gt; 에 의해 설정되고 &lt;code&gt;info/2&lt;/code&gt; 항목 &lt;code&gt;no_slots&lt;/code&gt; 에 의해 리턴됩니다 . 아래의 옵션 &lt;code&gt;min_no_slots&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">옵션 세트에 따라 리턴 된 데이터가 올바른 유형이어야합니다. 따라서 &lt;strong&gt;가능하면&lt;/strong&gt; 리턴하기 전에 목록을 올바른 인코딩으로 바이너리로 변환하십시오 . &lt;code&gt;get_until&lt;/code&gt; 요청 튜플에 제공된 함수 는 최종 결과가 무엇이든 리턴하므로 목록을 리턴하는 함수 만 바이너리로 변환 할 수 있습니다. 요청에 인코딩 태그 &lt;code&gt;unicode&lt;/code&gt; 가 포함 된 경우 목록에 모든 유니 코드 코드 포인트가 포함될 수 있으며 이진은 UTF-8이어야합니다. 인코딩 태그가 &lt;code&gt;latin1&lt;/code&gt; 인 경우 클라이언트는 &lt;code&gt;0..255&lt;/code&gt; 범위의 문자 만 가져옵니다 . 기능 &lt;code&gt;check/2&lt;/code&gt; 인코딩이 &lt;code&gt;latin1&lt;/code&gt; 로 지정된 경우 목록에서 임의의 유니 코드 코드 포인트를 반환하지 않도록 처리합니다 . 기능이 목록을 반환하지 않으면 점검을 수행 할 수 없으며 결과는 제공된 기능을 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">더티 작업을 올바르게 분류하는 것이 중요합니다. I / O 바운드 작업은 이와 같이 분류되어야하고 CPU 바운드 작업은 이와 같이 분류되어야합니다. CPU 바운드 작업을 I / O 바운드 작업으로 분류해야하는 경우 더티 I / O 스케줄러가 일반 스케줄러에 굶주릴 수 있습니다. I / O 바운드 작업은 I / O 대기를 차단하거나 데이터 이동에 제한된 시간을 소비해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">일치를 제한 할 때 &quot;재귀&quot;라고하는 것은 Erlang 시스템의 C 스택 또는 Erlang 프로세스 스택에서 재귀가 아님을 이해하는 것이 중요합니다. Erlang VM으로 컴파일 된 PCRE 버전은 머신 &quot;힙&quot;메모리를 사용하여 정규 표현식 일치에서 재귀를 통해 유지되어야하는 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">분기없이 &lt;code&gt;receive..after&lt;/code&gt; 표현식 을 사용하는 것이 합법적입니다 .</target>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">정규화 된 데이터베이스에서 일반화 된 검색을 수행하는 것이 더 효율적입니다. 정규화 된 데이터 모델에서 일부 작업을 수행하기도 쉽습니다. 예를 들어 다음 예제와 같이 하나의 프로젝트를 쉽게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">네트워크 잠금을 설정하는 것보다 로컬 잠금을 설정하는 것이 더 효율적입니다. 따라서 고정 잠금은 복제 된 테이블을 사용하고 하나의 노드에서만 대부분의 작업을 수행하는 응용 프로그램에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">예제에서 형식화 된 출력을 수행하는 것이 좋으므로 다음 예제는 &lt;code&gt;io:format&lt;/code&gt; 함수 를 사용하는 간단한 방법을 보여줍니다 . 내 보낸 다른 모든 함수와 마찬가지로 쉘에서 &lt;code&gt;io:format&lt;/code&gt; 함수를 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">여러 Erlang 프로세스에서 포트 드라이버를 생성 할 수 있으므로 전역 변수를 사용하는 것은 좋지 않습니다. 이 드라이버 구조는 여러 번 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">어떤 함수를 호출 할 수 없습니다 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;stop_select&lt;/code&gt; . 이 엄격한 제한은 &lt;code&gt;stop_select&lt;/code&gt; 라는 휘발성 컨텍스트를 호출 할 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">추적 된 노드 중 하나에서 과부하 보호가 활성화되면 추적 세부 사항 ( &lt;code&gt;ttb:p&lt;/code&gt; 및 &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ) 을 변경할 수 없습니다 . 이는 노드간에 추적 설정이 일치하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">이름은 같지만 &lt;code&gt;Path&lt;/code&gt; 매개 변수 가 다른 여러 드라이버를로드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">반출 된 것으로 선언되지 않은 유형은 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">원자 &lt;code&gt;asn1_VALUE&lt;/code&gt; 및 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 를 맵과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">일반 괄호가 두 가지 기능을 수행하는 것이 항상 도움이되는 것은 아닙니다. 종종 캡처 요구 사항없이 그룹화 서브 패턴이 필요합니다. 여는 괄호 뒤에 물음표와 콜론이 있으면 하위 패턴은 캡처를 수행하지 않으며 후속 캡처 하위 패턴의 수를 계산할 때 계산되지 않습니다. 예를 들어, 문자열 &quot;white queen&quot;이 다음 패턴과 일치하는 경우 캡처 된 하위 문자열은 &quot;white queen&quot;및 &quot;queen&quot;이며 1과 2로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">아직 구성되지 않은 서비스에 전송을 추가하는 것은 오류가 아닙니다. 전송을 구성한 후 서비스를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">아직 존재하지 않는 서비스의 이벤트를 구독하는 것은 오류가 아닙니다. 모든 운송 관련 이벤트의 수신을 보장하려면 전송을 추가하기 전에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">양식이 &lt;code&gt;AbstVersion&lt;/code&gt; 이 나타내는 추상 형식을 따르는 지 확인하지 않습니다 . &lt;code&gt;no_abstract_code&lt;/code&gt; 는 &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; 청크 가 있지만 비어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">애플리케이션이 직접 호출하도록 설계되지 않았지만 다음과 같은 방법으로 애플리케이션에서 일반적으로 호출 할 수있는 i / o 시스템을 통해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">분산 디스크 로그의 모든 로그 파일에 동일한 로그 항목이 포함되어있는 것은 아닙니다. 파일 내용을 동기화하려고 시도하지 않습니다. 그러나 관련된 노드 중 하나 이상이 매번 살아있는 한 모든 항목이 기록됩니다. 항목을 분산 로그에 기록하거나 로그를 변경하려고하면 개별 로그의 회신이 무시됩니다. 모든 노드가 작동 중지되면 디스크 로그 기능이 &lt;code&gt;nonode&lt;/code&gt; 오류로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">테이블이 고정 된 경우에도 &lt;code&gt;first/1&lt;/code&gt; , &lt;code&gt;next/2&lt;/code&gt; 또는 select and match 함수에 대한 호출이 예상대로 작동 한다고 보장 할 수는 없습니다 . &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 모듈 에서 제공하는 동시성에 대한 제한된 지원 은 아직 Dets에서 제공하지 않습니다. 테이블을 수정하면 현재 테이블의 해시 목록 크기 조정 만 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">이 프로그램이 숫자 값을 두 배로 늘린다는 것을 추측하는 것은 어렵지 않습니다. 코드의 처음 두 줄은 나중에 설명합니다. 프로그램을 컴파일하자. 이것은 다음과 같이 Erlang 쉘에서 수행 할 수 있습니다. 여기서 &lt;code&gt;c&lt;/code&gt; 는 컴파일을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">&lt;code&gt;Module:format_status/2&lt;/code&gt; 함수 를 구현할 필요는 없습니다 . 그렇지 않으면 민감한 정보를 포함하는이 예제에서 &lt;code&gt;Data&lt;/code&gt; 용어 를 필터링하지 않고이 예제 기능과 동일한 기본 구현 ( &lt;code&gt;StateData = {State,Data}&lt;/code&gt; )이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">기능을 내보낼 필요는 없습니다. 새로 생성 된 프로세스에서 호출됩니다 (함수가 반환되는 즉시 종료됩니다).</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">직경 자체가 적절한 값을 설정하므로 발신 메시지에서 헤더 필드를 명시 적으로 설정할 필요는 없습니다. 부적절한 값을 설정하면 테스트 목적으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">시작 스크립트를 &lt;code&gt;/usr/local/bin&lt;/code&gt; 과 같은 표준 디렉토리에 링크 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">\ 50과 같은 시퀀스가 ​​8 진수로 정의 된 문자로 해석되므로이 구문을 사용하여 숫자가 10 이상인 하위 패턴에 대한 숫자 &quot;순방향 역 참조&quot;를 가질 수 없습니다. 백 슬래시 뒤의 숫자 처리에 대한 자세한 내용은 앞에서 &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 . 명명 된 괄호를 사용하는 경우에는 이러한 문제가 없습니다. 명명 된 괄호를 사용하여 하위 패턴에 대한 역 참조가 가능합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">식 이외의 다른 위치에서는 알 수없는 형태에 대한 후크 함수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">테스트를 통해 프로그램이 올바른지 증명할 수는 없습니다. 반대로, 테스트를 통해 일반적으로 프로그램을 증명할 수 없다는 것이 공식적으로 입증되었습니다. 프로그램의 정확성을 증명하고자하는 사람들에게는 이론적 인 프로그램 증명 또는 코드의 평범한 검사가 실행 가능한 옵션이 될 수 있습니다. 테스트를 기반으로하는 테스트 서버는 인증에 사용할 수 없습니다. 의도 된 용도는 &lt;strong&gt;버그&lt;/strong&gt; 를 (비용 효율적으로) &lt;strong&gt;찾는 것&lt;/strong&gt; 입니다. 성공적인 테스트 스위트는 버그를 드러내는 것입니다. 테스트 스위트 결과가 정상이면, 우리는 이전에 몰랐던 것을 거의 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">상태 다이어그램이 다이어그램에서 특정 상태로 설명되지 않은 이벤트를 처리하는 방법을 지정하지 않는 것은 드문 일이 아닙니다. 바라건대 이것은 관련 텍스트 또는 컨텍스트에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">현재 시간보다 늦은 시작 시간을 지정하는 것은 유효하지 않습니다. 로그가 지원할 수있는 것보다 &lt;code&gt;StartTime&lt;/code&gt; 이 더 일찍 지정된 경우 재생은 가능한 가장 빠른 알림으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">정의되지 않은 함수에 대한 호출에 대한 릴리스를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;long_request_timer&lt;/code&gt; (위 참조)도 증분 타이머 ( &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; )로 설정 하지 않는 한이 값을 &lt;strong&gt;true&lt;/strong&gt; 로 설정하는 것은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">물론 둘 이상의 목록을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">물론이 두 가지 옵션을 모두 함께 사용하려는 이유는 의심의 여지가 있지만, 예상치 못한 필요가 발생하면 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">이 작업으로 인해 발신자를 오랫동안 차단하지 않는 것이 매우 중요합니다. 연결 관리자로부터 호출 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">그러한 원 안에 쿼리 변수를 표시하는 것이 종종 명확합니다. 이것은 사전 정의 된 분석 중 일부에 대해 아래 그림에 설명되어 있습니다. 로컬 함수에서만 사용되는 로컬 함수는 &lt;code&gt;locals_not_used&lt;/code&gt; 서클에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">테이블을 수정할 때 특정 조치를 수행해야하는 경우가 종종 있습니다. 이는 계측 기능으로 수행됩니다. 테이블이 설정되면 특정 코드를 실행하고 다른 모든 요청을 미리 정의 된 함수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">Erlang / OTP 시스템을 그대로 사용하는 것은 바람직하지 않습니다. 개발자는 특정 목적을 위해 새로운 Erlang / OTP 호환 응용 프로그램을 만들 수 있으며, 원래의 Erlang / OTP 응용 프로그램은 해당 목적과 관련이 없을 수 있습니다. 따라서, 주어진 Erlang / OTP 시스템을 기반으로 새로운 응용 프로그램을 작성할 수 있어야합니다. 여기서 분배 가능한 응용 프로그램이 제거되고 새 응용 프로그램이 포함됩니다. 설명서 및 소스 코드는 관련이 없으므로 새 시스템에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">특히 유닉스 플랫폼에서 escript에 헤더를 갖는 것이 매우 편리합니다. 그러나 헤더는 선택 사항이므로 헤더를 추가하지 않고 Erlang 모듈, Beam 파일 또는 아카이브 파일을 직접 &quot;실행&quot;할 수 있습니다. 그러나 다음과 같이 스크립트를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">FIPS 모드에서 인증 및 개인 정보 보호에 각각 &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; 및 &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; 을 사용할 수 있습니다. 그러나 snmp 응용 프로그램은 어떤 방식 으로든 비활성화 된 프로토콜 선택을 제한하지 않으며이를 사용하면 런타임 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">엔 클로징 조치 목록이없는 경우에도 상태 전이 조치 &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 또는 정수 &lt;code&gt;Time&lt;/code&gt; 순서로 정렬됩니다 (후자는 &lt;code&gt;gen_fsm&lt;/code&gt; 에서 상속 된 양식 입니다).</target>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">이 옵션을 통해 이전 유효성 검사의 프로세스 정보를 상태에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">버퍼를 표시 할 때 Emacs가 색상을 사용할 수 있습니다. &quot;구문 강조 표시&quot;는 키워드 및 함수 이름과 같은 구문 구성 요소에 색상이 지정됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">처리기는 충돌없이 최고로드의 피크를 성공적으로 관리 할 수 ​​있더라도 큰 메시지 큐를 만들거나 많은 양의 메모리를 사용할 수 있습니다. 과부하 보호 메커니즘에는 핸들러가 범위를 벗어나지 않도록하기 위해 자동 종료 및 재시작 기능이 포함되어 있습니다. 기능은 다음 매개 변수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">에이전트에 &lt;strong&gt;알림 필터&lt;/strong&gt; 를 추가 할 수 있습니다 . 이 필터는 알림이 전송 될 때 호출됩니다. 그들의 목적은 수정, 억제 또는 다른 유형의 행동을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">해당 프로세스 ID 만 제공하여 해석 된 프로세스에 첨부 할 수 있습니다. 기본적으로 첨부 파일 창이 표시됩니다. 다른 Erlang 노드의 프로세스는 수동 또는 자동으로 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템과 함께 &lt;code&gt;escript&lt;/code&gt; 를 번들 로 제공하여 자급 자족하고 재배치 할 수 있습니다. 이러한 독립형 시스템에서 &lt;code&gt;escript&lt;/code&gt; 는 독립형 시스템 의 최상위 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 있으며 파일 확장자로 &lt;code&gt;.escript&lt;/code&gt; 를 제공해야합니다. 또한 (내장) &lt;code&gt;escript&lt;/code&gt; 프로그램을 동일한 디렉토리에 복사하고 스크립트의 원래 이름 ( &lt;code&gt;.escript&lt;/code&gt; 확장자 없이 )을 지정해야합니다. 번들로 제공되는 Erlang 런타임 시스템을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">어설 션 결과에 따라 또는 특정 캡처 하위 패턴이 이미 일치했는지 여부에 따라 일치 프로세스가 조건에 따라 하위 패턴을 따르거나 두 개의 대체 하위 패턴 중에서 선택하도록 할 수 있습니다. 다음은 두 가지 가능한 조건부 하위 패턴 양식입니다.</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">688과 다른 3588 의미를 얻기 위해 3588 사전을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램의 모든 (감독자가 아닌) 프로세스 (에이전트 및 관리자 모두)를 디버깅 할 수 있습니다. 가능하면 응용 프로그램의 사용자가 제공 할 수있는 net_if 모듈을 제외하고는 가능합니다. 이는 &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; 및 &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; 함수를 호출하거나 &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 사용하여 수행 됩니다 . 세부 사항 자체에는 여러 &lt;strong&gt;레벨이 있습니다&lt;/strong&gt; . &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; . 가장 낮은 &lt;code&gt;silence&lt;/code&gt; 경우 아무 것도 인쇄되지 않습니다. 상세도가 높을수록 더 많이 인쇄됩니다. 기본값은 항상 &lt;code&gt;silence&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">컴파일 된 MIB 파일에서 Erlang 상수의 정의가 포함 된 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 생성 할 수 있습니다. 이 파일은 Erlang 소스 코드에 포함될 수 있습니다. 파일에는 다음에 대한 상수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">한 노드에는 &lt;code&gt;disc_copies&lt;/code&gt; 유형의 복제 된 테이블이 있고 다른 노드에는 다른 유형의 테이블이있을 수 있습니다 . 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">한 노드에 &lt;code&gt;disc_copies&lt;/code&gt; 유형의 복제 된 테이블이 있고 다른 노드에 다른 테이블로 저장된 동일한 테이블이있을 수 있습니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 다음과 같은 작동 특성이 필요한 경우이 배열이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">다음 ASN.1 유형 정의를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">관리자에 밉을로드 할 수 있지만 정상적인 작동에는 필요하지 않으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">비정상 종료 신호를 수신 할 때 종료되지 않도록 프로세스의 기본 동작을 수정할 수 있습니다. 대신, 모든 신호는 &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; 형식의 일반 메시지로 바뀌고 수신 프로세스의 메시지 큐 끝에 추가됩니다. 이 동작은 다음에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">사전 정의 된 매크로를 제외하고 매크로를 오버로드 할 수 있습니다. 오버로드 된 매크로에는 각각 다른 수의 인수를 가진 둘 이상의 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;{compress, What}&lt;/code&gt; 및 &lt;code&gt;{uncompress, What}&lt;/code&gt; 옵션을 사용하여 기본 작동을 대체하고 압축 할 파일 유형을 제어 할 수 있습니다 . 많은 &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 옵션 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">그래프의 일부 제한된 조작을 수행 할 수 있습니다. 노드를 이동, 선택, 잠 그거나 삭제할 수 있습니다. 마우스 왼쪽 버튼을 누른 상태에서 마우스를 움직여 단일 노드 또는 전체 그래프를 이동하십시오. 마우스 왼쪽 버튼을 놓을 때 Shift 버튼을 누르면 노드가 고정 위치에 고정 될 수 있습니다. 컨트롤 키와 마우스 왼쪽 버튼을 누른 상태에서 마우스를 움직여 여러 노드를 선택하십시오. 적절한 버튼을 클릭하여 선택한 노드를 잠 그거나 잠금 해제하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; 를 사용하여 런타임 오류 및 기타 예외로 인해 프로세스가 종료되는 것을 방지 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 &lt;code&gt;DataOrStats&lt;/code&gt; 를 먼저 조작하여보다 구체적인 통계 유형을 인쇄 할 수 있습니다 . 예를 들어 각 스레드에 대한 런타임 백분율을 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">모듈이 &lt;strong&gt;동작에&lt;/strong&gt; 대한 콜백 모듈임을 지정할 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">IPv4 대신 IPv6을 통한 SSL / TLS 배포를 사용할 수 있습니다. 이렇게하려면 옵션을 통과 &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; 대신 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 를 명령 줄이나에 중, 얼랑를 시작할 때 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 의 환경 변수.</target>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">특정 원칙에 따라 C로 드라이버를 작성하고이를 Erlang 런타임 시스템에 동적으로 링크 할 수 있습니다. 링크 된 드라이버는 Erlang 프로그래머의 관점에서 포트처럼 보이고 &lt;strong&gt;포트 드라이버&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">노드가 서로 간섭하여 일관되지 않은 동작이 발생하므로 네트워크의 둘 이상의 노드에서 전역 모드로 디버거를 시작하는 것이 가능하지만 반드시 권장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">레코드 필드를 원자 &lt;code&gt;'_'&lt;/code&gt; 로 설정 하기 위해 주로 &lt;code&gt;ets:match/2&lt;/code&gt; 및 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 에서 사용됩니다 . ( &lt;code&gt;ets:match/2&lt;/code&gt; 의 와일드 카드입니다 .)</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">벽시계 측정과 CPU 시간 측정을 모두 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">프로세스를 최대 절전 모드로 전환하는 데 비용이 많이 듭니다. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 를 참조하십시오 . 모든 행사 후에하고 싶은 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">SSH 연결 프로토콜에서이 메시지를 보내는 것이 좋지만 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">꼭 필요한 경우가 아니면 &lt;code&gt;LogFileOpts&lt;/code&gt; 를 지정 하지 않는 것이 좋습니다 . 핸들러가 로깅을 위해 파일을 여는 데 사용하는 기본 옵션은 &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;delayed_write&lt;/code&gt; 입니다. 표준 핸들러는 순환 로깅을 지원하지 않습니다. disk_log 핸들러 사용 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 이를 들어,.</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 디렉토리는 응용 프로그램으로 이름 지정되고 대시와 버전 번호가 뒤 따르는 것이 좋습니다. 예를 들어, &lt;code&gt;myapp&lt;/code&gt; 또는 &lt;code&gt;myapp-1.1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 실행되는 동안 데이터 파일이 변경되지 않는 것이 좋습니다 . 금지되지는 &lt;code&gt;Mnesia&lt;/code&gt; 의 행동 은 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">임베디드 환경은 일반 사용자, 즉 수퍼 유저 권한이없는 사용자가 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">충돌을 피하기 위해이 줄을 추가하는 것이 좋습니다. 충돌로 인해 시스템을 부팅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">필요한 경우 외부 엔터티와의 통신에 외부 인코딩 만 사용하는 것이 좋습니다. Erlang / OTP 환경에서 작업 할 때는 유니 코드 문자를 나타낼 때 바이너리를 UTF-8로 유지하는 것이 좋습니다. ISO Latin-1 인코딩은 이전 버전과의 호환성 및 유니 코드 문자 집합을 지원하지 않는 외부 엔터티와의 통신을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">각 프로세스 메모리 검사에서 전체 프로세스 목록을 순회하므로 동시 프로세스가 많은 시스템에서는 이 매개 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">가독성을 위해 가능한 경우 대신 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 를 사용하는 것이 좋습니다 . 그러나이 기능은 호환성을 위해 인터페이스에 유지 되며 향후 릴리스에서 사전 통지없이 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">Erlang / OTP MIB 컴파일러가 생성 한 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 사용하여 OID (Object Identifier)를 정의하는 것이 좋습니다 . 예를 들어, OTP-MIB의 &lt;code&gt;erlNodeTable&lt;/code&gt; 에서 Erlang 노드 이름을 가져 오려면 다음 을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">프로그램을 유지 관리하기가 더 쉬워지고 향후 레코드 변경과 관련하여 프로그램이 더 강력 해 지므로 &lt;code&gt;record_info/2&lt;/code&gt; 표기법 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때때로 사용자 정의 부팅 스크립트를 작성하는 것이 유용하거나 필요합니다. 임베디드 모드에서 Erlang을 실행할 때 특히 그렇습니다 ( &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">이 기능을 사용하고 비표준 방식으로 줄을 들여 쓰지 않는 것이 좋습니다. 몇 가지 동기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">나중에 배열을 해제하는 것은 호출자의 책임입니다. &lt;code&gt;malloc()&lt;/code&gt; 대한 단일 호출로 함수에 의해 할당 되었으므로 단일 &lt;code&gt;free()&lt;/code&gt; 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">배열을 해제하는 것은 호출자의 책임입니다. &lt;code&gt;erl_global_names&lt;/code&gt; 는 &lt;code&gt;malloc()&lt;/code&gt; 대한 단일 호출을 사용하여 배열과 모든 문자열을 할당 하므로 &lt;code&gt;free(names)&lt;/code&gt; 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;ETERM&lt;/code&gt; 구조와 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 가 가리키는 메모리 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; , &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 이 가리키는 메모리를 해제하는 것은 호출자의 책임 입니다 .</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">그런 다음 다음과 같이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; 에 지정된 Fun 내부의 코드 가 순수해야합니다. 예를 들어 트랜잭션 Fun이 메시지를 보낸 경우 이상한 결과가 발생할 수 있습니다. 다음 예제는이 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">따라서 코드를 가능한 한 작은 단계로 변경하고 항상 이전 버전과 호환되는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">다음 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">&lt;code&gt;split_binary/2&lt;/code&gt; 함수 를 호출하는 대신 매칭을 사용하여 바이너리를 분할하는 것이 일반적으로 더 효율적 입니다. 또한 비트 구문 일치와 &lt;code&gt;split_binary/2&lt;/code&gt; 를 혼합하면 비트 구문 일치의 일부 최적화를 막을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">소스에서 작동하는 OpenSSL FIPS 오브젝트 모듈 및 라이브러리를 작성하는 것은 매우 쉽습니다. 그러나 그것은 &lt;strong&gt;하지 않는&lt;/strong&gt; 보안 정책에 많은 제한을 제대로 준수하지 않을 경우 FIPS 140-2 검증 자격.</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">인코딩과 유니 코드 문자의 차이점을 이해하는 것이 중요합니다. 유니 코드 문자는 유니 코드 표준에 따른 코드 포인트 인 반면, 인코딩은 이러한 코드 포인트를 나타내는 방법입니다. 인코딩은 표현의 표준 일뿐입니다. 예를 들어 UTF-8을 사용하면 유니 코드 문자 집합의 매우 제한된 부분 (예 : ISO-Latin-1) 또는 전체 유니 코드 범위를 나타낼 수 있습니다. 인코딩 형식 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">대안 세트를 현지화합니다. 예를 들어 다음 패턴은 &quot;cataract&quot;, &quot;caterpillar&quot;또는 &quot;cat&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">오류가 발생하는 것과 다른 테스트 사례에서 문제가 발생할 수 있으므로 디버깅이 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">테스트 케이스를 다른 순서로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">테스트 케이스를 개별적으로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">제목 &quot;aab&quot;에서 &quot;ab&quot;와 일치합니다. 역 추적 제어 동사 (* PRUNE) 및 (* SKIP)를 사용하면이 최적화가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">요소 수를 미리 모르면 목록을 만들 수있는 방법이없는 것 같습니다. 그러나 실제로 방법이 있습니다. 리스트 &lt;code&gt;[a, b, c]&lt;/code&gt; 는 &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; . 이를 사용하여 목록을 결과로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">보안 문제를 해결하기 위해 호환되지 않는 변경 사항을 도입해야 할 수도 있습니다. 이러한 종류의 비 호환성은 패치에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">모든 응용 프로그램의 새 버전으로 에뮬레이터를 다시 시작하는 대신 2 단계 업그레이드를 수행하는 것이 이상하게 보일 수 있습니다. 이 설계 결정의 이유는 &lt;code&gt;code_change&lt;/code&gt; 함수가 디스크에서 데이터를 변경하는 등의 부작용을 갖도록하기위한 것입니다. 또한 핵심 응용 프로그램이 동시에 변경되는지 여부에 따라 비 핵심 응용 프로그램의 업그레이드 메커니즘이 다르지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">더 이상 (성능 관점에서) 작성 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">구성 파일에 다음 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">리스트의 모든 인수에 함수를 적용하여 얻은리스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">그것은의 값 반환 &lt;code&gt;Exprs&lt;/code&gt; (표현의 순서 &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; 예외가 평가하는 동안 발생하지 않는 한)입니다. 이 경우 예외가 포착되고 올바른 예외 클래스가 &lt;code&gt;Class&lt;/code&gt; &lt;code&gt;ExceptionPattern&lt;/code&gt; 패턴이 포착 된 예외 와 순차적으로 일치합니다. 일치가 성공하고 선택적 가드 시퀀스 &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; 가 true 인 경우 해당 &lt;code&gt;ExceptionBody&lt;/code&gt; 가 리턴 값이되도록 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">&lt;code&gt;io_reply&lt;/code&gt; 튜플을 클라이언트로 다시 보내 요청에 수신 한 &lt;code&gt;ReplyAs&lt;/code&gt; 요소를 요청 결과와 함께 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하위 패턴을 캡처 하위 패턴으로 설정합니다. 즉, 완전한 패턴이 일치하면 하위 패턴과 일치하는 주제 문자열의 해당 부분이 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 통해 호출자에게 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">추적 프로그램 서버를 시작한 다음 &lt;code&gt;Level&lt;/code&gt; 에 따라 적절한 일치 스펙을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">32 비트 솔트 값을 취하고 &lt;code&gt;0..2^32-1&lt;/code&gt; 내에 해시를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">숫자 또는 비트 연산자 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">이 응답이 도착하면 &quot;Ping received pong&quot;을 쓴 다음 &quot;ping&quot;이 &lt;code&gt;ping&lt;/code&gt; 기능을 다시 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">독자는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; 익숙하다고 가정합니다 . 응용 프로그램을 패치하려면 다음이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">그러나 힙에 가비지를 작성하지 않고 약간 더 나은 성능을 제공하는 기본 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">항목 (? p {...})은 런타임에 Perl 코드를 보간하며이 경우 표시되는 패턴을 재귀 적으로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 항목을 &lt;strong&gt;동 기적&lt;/strong&gt; 으로 로그 할 수 있습니다 . 이러한 각 기능에 대해 항목이 기록 될 때까지 호출자가 보류됩니다 (필수는 아니지만 반드시 &lt;code&gt;sync/1&lt;/code&gt; 을 사용 하여 확인하십시오). 언급 된 각 함수 이름에 &lt;code&gt;a&lt;/code&gt; 를 추가하여 항목을 &lt;strong&gt;비동기 적으로&lt;/strong&gt; 로그하는 함수를 얻습니다 . 비동기 함수는 디스크 로그 프로세스가 파일에 항목을 쓸 때까지 기다리지 않고 즉시 제어자를 호출자에게 리턴합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">현재 저장된 이벤트를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">백업을 반복하여 새 백업으로 변환하거나 읽습니다. 여기에 논증이 간략하게 설명되어 있습니다. 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">현재 저장된 이벤트를 반복하고 각 이벤트에 대한 기능을 적용합니다. 반복은 정방향 또는 역방향으로 수행 될 수 있으며 최대 이벤트 수 (abs (Limit))로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Table&lt;/code&gt; 을 반복하고 테이블의 각 &lt;code&gt;Record&lt;/code&gt; 에 대해 &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; 을 호출 합니다. &lt;code&gt;Function&lt;/code&gt; 에서 반환 된 용어 는 다음에 &lt;code&gt;Function&lt;/code&gt; 호출시 두 번째 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">준수 할 때 해당 값을 상수로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">James가 c2 @ kosken에 로그온합니다.</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">제임스는 이제 프레드에게 메시지를 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-Erlang / OTP R7B에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jive는 Erlang 프로그램과 Java 프로그램 사이에 간단한 인터페이스를 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">작업을 시작, 종료, 분리 및 연결할 수있는 작업 제어 모드 ( &lt;code&gt;JCL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">결합 된 사양은 &lt;code&gt;config&lt;/code&gt; 파일 목록 또는 &lt;code&gt;include&lt;/code&gt; 디렉토리 와 같은 일반적인 구성 설정을 공유합니다 . &lt;code&gt;logdir&lt;/code&gt; 또는 &lt;code&gt;verbosity&lt;/code&gt; 설정과 같이 결합 할 수없는 구성의 경우 테스트 사양을 결합 할 때 충돌이 없는지 사용자가 결정해야합니다. &lt;code&gt;separate&lt;/code&gt; 옵션에 포함 된 사양은 구성 사양을 소스 사양과 공유하지 않습니다. 예를 들어 포함 된 사양에 충돌하는 구성 설정이있어 가입 할 수없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">테스트 사양 파일 포함을 사용하여 여러 사양을 결합하거나 별도로 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">디렉토리 구분 기호를 사용하여 파일 이름 &lt;code&gt;Components&lt;/code&gt; 목록을 결합합니다 . &lt;code&gt;Components&lt;/code&gt; 의 요소 중 하나에 &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; 와 같은 절대 경로가 포함 된 경우 이전 요소가 있으면 결과에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">멀티 캐스트 그룹에 가입합니다.</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">상대 파일 이름으로 절대 디렉토리를 결합합니다. &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 원시 파일 이름 길이에 대한 엄격한 제한이 있고 기호 링크를 지원하지 않는 플랫폼 (VxWorks)에서는 &lt;code&gt;Filename&lt;/code&gt; 의 선행 상위 디렉토리 구성 요소가 &lt;code&gt;Dir&lt;/code&gt; 의 후행 디렉토리 구성 요소와 일치 하므로 결과에서 제거 될 수 있습니다. -길이를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">개별 주석 행을 여러 줄 주석으로 결합합니다. 입력은 &lt;strong&gt;줄 번호의 내림차순으로&lt;/strong&gt; 개별 주석 줄을 나타내는 항목 목록입니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오. 결과는 &lt;strong&gt;줄 번호를 내림차순으로 나열한 &lt;/strong&gt;&lt;strong&gt;여러 줄&lt;/strong&gt; 주석을 나타내는 항목 목록 이지만 각 항목에 대해 &lt;code&gt;Text&lt;/code&gt; 는 줄 번호 를 &lt;strong&gt;증가시키는&lt;/strong&gt; 순서로 연속 주석 줄의 목록입니다 (예 : 하향식). ).&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">호출 스레드를 다른 스레드와 결합합니다. 즉, 호출 스레드는 &lt;code&gt;tid&lt;/code&gt; 로 식별 된 스레드 가 종료 될 때까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 그룹 &lt;code&gt;Name&lt;/code&gt; 에 결합시킵니다 . 프로세스는 그룹에 여러 번 참여할 수 있으며 같은 수의 그룹을 떠나야합니다.</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">두 개의 파일 이름 구성 요소를 디렉토리 구분 기호와 결합합니다. 등가 &lt;code&gt;join([Name1, Name2])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">점프 기능 : 2 ^ 512 호출과 동일</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">점프 기능 : 2 ^ 64 호출과 동일</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트 를 실행할 때 &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; 옵션을 명령에 추가하십시오 . systemtap을 사용하는 경우 configure 옵션은 &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">현재 파일과 줄 번호를 표시하는 마커를 인쇄합니다. 이것은 인수가없는 매크로입니다. 결과는 항상 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">연결 유지 (연결이 유휴 상태 인 경우 8 초마다 NOP를 서버에 전송) = &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">외부 명령은 운영 체제에 따라 크게 달라집니다. 테스트 생성기 함수에서 표준 라이브러리 함수 &lt;code&gt;os:type()&lt;/code&gt; 을 사용하여 현재 운영 체제에 따라 다른 테스트 세트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">모니터링 프로세스를 깔끔하게 유지하고 시스템 모니터 제한을 너무 세게 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">인덱스 테이블을 유지하면 테이블에 레코드를 삽입 할 때 약간의 오버 헤드가 발생합니다. 따라서 테이블에서 얻은 조작 수를 테이블에 오브젝트를 삽입하는 조작 수와 비교해야합니다. 그러나 키를 사용하여 요소를 조회 할 수있는 경우 게인이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">커널-Erlang을 실행하는 데 필요한 기능</target>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">감독 트리로 구현 된 응용 프로그램에는 키 &lt;code&gt;mod&lt;/code&gt; 가 필요합니다. 그렇지 않으면 응용 프로그램 컨트롤러가이를 시작하는 방법을 모릅니다. 프로세스가없는 응용 프로그램, 일반적으로 코드 라이브러리 (예 : STDLIB)의 경우 &lt;code&gt;mod&lt;/code&gt; 를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">키 교환.</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">키 길이는 128, 192 또는 256 비트입니다.</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">키 길이는 64 비트입니다 (CBC 모드에서는 8 비트 만 사용됨)</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">스레드 특정 데이터를 연관시킬 수있는 키입니다.</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">순서 목록으로서의 키-값 사전.</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">키-값 사전.</target>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">키와 값은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 화살표로 구분되고 연결은 쉼표 ( &lt;code&gt;,&lt;/code&gt; ) 로 구분 됩니다.</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">키는 문자열, 즉 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자 배열이며 값은 임의의 개체입니다. 정수와 부동 소수점 숫자는 레지스트리에서 특별히 처리되지만 문자열이나 이진 객체를 포인터로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">킬 라인</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">현재 쉘을 죽이거나 일시 중단</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">수신 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">실행중인 죽이는 &lt;code&gt;epmd&lt;/code&gt; 경우에만 허용된다 &lt;code&gt;epmd -names&lt;/code&gt; 쇼 빈 데이터베이스를 경우 또는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 의 실행중인 인스턴스 때 지정된 &lt;code&gt;epmd&lt;/code&gt; 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">작업 번호 &lt;code&gt;nn&lt;/code&gt; 또는 현재 작업을 종료합니다. &lt;code&gt;group_leader/1&lt;/code&gt; BIF를 평가하지 않고 로컬 시스템에있는 경우 작업에서 생성 된 모든 프로세스가 종료 됩니다. 원격 노드에서 생성 된 프로세스는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">현재 실행중인 &lt;code&gt;epmd&lt;/code&gt; 를 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">알려진 호스트-OpenSSH 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">알려진 문제 : 동일한 노드 이름으로 노드를 여러 번 다시 시작하면 새로운 노드에서 작성된 참조가 동일한 노드 이름을 가진 이전 노드에서 작성된 참조로 오인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">알려진 노드</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">LALR-1 파서 생성기</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAP 클라이언트</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST : 사용자 공간 추적 라이브러리.</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-tools : 추적 세션을 제어하기위한 명령 행 인터페이스.</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">이벤트의 레이블 (유형).</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">간단한 이벤트 요약을 제공하기위한 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">테스트 실행에 레이블을 지정하십시오 ( &lt;code&gt;ct_run -label&lt;/code&gt; 과 유사 ).</target>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">레이블은 OTP 21 이전에 작은 부호있는 정수 (28 비트)로 제한되었습니다. 추적 토큰이 레이블을 지원하지 않는 노드로 넘어 가면 추적 토큰이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">지원 부족. HiPE 컴파일 된 모듈을위한 NIF 라이브러리 로딩과 같은.</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">일치 스펙에없는 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 와 같은 언어 구성 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">언어 또는 로케일 특정 입력 처리는 어떤 기능에서도 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">대문자 (또는 소문자) 개념이없는 언어</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">대용량 파일 지원</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">큰지도 (&amp;gt; 32 키)</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">처리기에서 짧은 시간 내에 많은 이벤트를 수신 한 대량의 로그 이벤트는 다음과 같은 문제를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">큰 정수</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">대규모 자동 테스트에는 여러 개의 독립적 인 테스트 세션을 병렬로 실행해야합니다. 이는 하나 이상의 호스트에서 일부 &lt;code&gt;Common Test&lt;/code&gt; 노드를 실행 하여 다른 대상 시스템을 테스트하여 수행됩니다. 테스트 노드를 독립적으로 구성, 시작 및 제어하는 ​​것은 번거로운 작업 일 수 있습니다. 이러한 종류의 자동화 된 대규모 테스트를 지원하기 위해 &lt;code&gt;Common Test&lt;/code&gt; 는 분산 &lt;code&gt;Common Test&lt;/code&gt; 노드 시스템에서 중앙 구성 및 제어를 처리 하는 마스터 테스트 노드 구성 요소 인 &lt;code&gt;Common Test&lt;/code&gt; 마스터를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">더 큰 프로그램은 일반적으로 다양한 부분 사이에 잘 ​​정의 된 인터페이스를 가진 파일 모음으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">테스트 케이스가 클수록 실패 할 경우 무엇이 잘못되었는지 알기가 더 어렵습니다. 또한 오류가 발생할 때 테스트 코드 위험의 대부분이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">가장 큰 ( &lt;code&gt;mseg_alloc&lt;/code&gt; ) 멀티 블록 캐리어 크기 (킬로바이트). &lt;code&gt;mseg_alloc&lt;/code&gt; 멀티 블록 캐리어의 크기가 &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 섹션에서 결정되는 방법에 대한 설명을 참조하십시오 . 32 비트 Unix 스타일 OS에서는이 제한을 128MB보다 크게 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">에 마지막 인수 &lt;code&gt;start_link/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">마지막 거래 ID</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">마지막으로 응용 프로그램 마스터가 종료됩니다. 응용 프로그램 마스터를 그룹 리더로 사용하는 모든 프로세스, 즉 응용 프로그램에 속하는 프로세스에서 생성 된 프로세스도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">나중에 응용 프로그램 my_app에서 버그를 수정하면 다음에 Dialyzer를 실행할 때 새로워 지도록 PLT를 업데이트하려고합니다. 이 경우 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">tar 멤버 이름의 선행 슬래시는 파일을 쓰기 전에 제거됩니다. 즉, 절대 경로는 상대 경로로 바뀝니다. 이러한 방식으로 경로가 변경되면 오류 로거에 정보 메시지가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">멀티 캐스트 그룹을 떠납니다.</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">기록 된 데이터를 읽고 해석 할 수 있도록 사용자에게 맡깁니다. &lt;code&gt;disk_log&lt;/code&gt; 모듈은 외부 형식의 로그를 복구 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leex는 확장자가 &lt;code&gt;.hrl&lt;/code&gt; 인 경우 포함 &lt;code&gt;Includefile&lt;/code&gt; 이름에 확장자 &lt;code&gt;.erl&lt;/code&gt; 을 &lt;code&gt;Scannerfile&lt;/code&gt; 이름에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">왼쪽 연관</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; 인수가있는 레거시 API 함수 &lt;code&gt;process_msg/7&lt;/code&gt; 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; &lt;code&gt;send_pdu/7&lt;/code&gt; 레거시 API 함수 send_pdu / 7 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">전송 도메인을 지정하지 않는 레거시 API 함수 &lt;code&gt;add_addr/10&lt;/code&gt; 및 별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; 인수가있는 &lt;code&gt;add_addr/11&lt;/code&gt; 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">모든 &lt;code&gt;TDomain&lt;/code&gt; , &lt;code&gt;Ip&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 요소 뿐만 아니라 &lt;code&gt;Domain&lt;/code&gt; 요소가 없는 튜플을 사용하는 레거시 구성은 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">레거시 네트워크 인터페이스 필터 모듈 은 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; 대신 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 형식의 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 에이전트가 실행되는 경우 네트워크 인터페이스 필터 여전히 오래된 주장을 얻고 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">레거시 네트워크 인터페이스 필터 모듈 은 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; 대신 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 형식의 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 관리자가 실행되는 경우 네트워크 인터페이스 필터 여전히 오래된 주장을 얻고 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">레거시 알림 배달 정보 수신기 모듈 은 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 대신 &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; 형식의 대상 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 에이전트를 실행하는 경우 알림 배달 정보 수신기는 여전히 이전 주장과 이전처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">레거시 솔루션은 결국 제거해야 할 수도 있습니다. 이러한 경우, 사용자에게 적응할 시간을주기에 충분한 시간 동안 단계적으로 제거됩니다. 기능을 제거하기 전에 향후 릴리스에 대한 명시적인 발표와 함께 최소한 한 번의 릴리스 동안 더 이상 사용되지 않습니다. 새로운 지원 중단은 최소한 릴리스 노트와 문서에서 발표 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">CGI에서 사용되는 레거시 문자열은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">노드 이름의 길이</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">하자 &lt;code&gt;SetOfSets&lt;/code&gt; 이 세트의 세트하고 &lt;code&gt;BinRel&lt;/code&gt; 이진 관계. 각 요소의 매핑 기능 &lt;code&gt;Set&lt;/code&gt; 의 &lt;code&gt;SetOfSets&lt;/code&gt; 을 상 &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Set&lt;/code&gt; 아래 &lt;code&gt;BinRel&lt;/code&gt; 은 다음 함수에 의해 리턴된다 :</target>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">각 프로세스에 두 개의 카운터 &lt;code&gt;prev_cnt&lt;/code&gt; 및 &lt;code&gt;curr_cnt&lt;/code&gt; 가 있고 프로세스가 작성 될 때 둘 다 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 카운터는 다음과 같은 경우에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">Megaco 스택이 플렉스 스캐너를 시작하게하십시오 (드라이버로드).</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">추적 토큰의 일련 번호를 &lt;code&gt;tprev&lt;/code&gt; 및 &lt;code&gt;tcurr&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">이 프로세스에서 &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; 함수 를 호출하여 flex 스캐너를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">도시 목록에 온도를 다시 인쇄합시다.</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">골룸과 코스 켄이라는 두 대의 컴퓨터가 있다고 가정 해 봅시다. 먼저 ping이라는 kosken에서 노드를 시작한 다음 pong이라는 gollum에서 노드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">출력물을 계속 찾아서 다음을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; 항목을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">먼저 수행되지 않는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">실행 후 출력물을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">몇 가지 흥미로운 기능을 사용하는 예제를 통해 딥 엔드로 바로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">이제 전화 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">이제 도시와 온도 목록을 살펴보고 모두 섭씨로 변환하는 데 사용할 수있는 재미를 정의합시다.</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">이제 테스트 코드로 돌아가 봅시다 :</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">우리가 지금을 사용하여 탁구의 예를 다시 작성하고 이름 보겠습니다 &lt;code&gt;pong&lt;/code&gt; 은 &quot;퐁&quot;프로세스 :</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">메신저 프로그램으로 돌아가서 변경 사항을 추가하여 더욱 강력하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">이전 섹션의 시작 부분에서 예제를 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">다른 컴퓨터에서 &quot;ping&quot;과 &quot;pong&quot;을 사용하여 핑퐁 프로그램을 다시 작성해 보겠습니다. 먼저 이것을 작동시키기 위해 몇 가지 사항이 필요합니다. 분산 Erlang 구현은 다른 컴퓨터의 Erlang 시스템에 의도하지 않은 액세스를 방지하는 매우 기본적인 인증 메커니즘을 제공합니다. 서로 대화하는 Erlang 시스템은 동일한 &lt;strong&gt;매직 쿠키를&lt;/strong&gt; 가져야합니다 . 이를 달성하는 가장 쉬운 방법은 Erlang 시스템이 서로 통신하는 모든 시스템의 홈 디렉토리에 &lt;code&gt;.erlang.cookie&lt;/code&gt; 라는 파일을 두는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;centimeter&lt;/code&gt; 나 &lt;code&gt;inch&lt;/code&gt; 이외의 것이 &lt;code&gt;convert&lt;/code&gt; 함수에 입력 되면 어떻게되는지 보자 :</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 에 설명 된 예제 데이터베이스 &lt;code&gt;Company&lt;/code&gt; 를 사용하여 &lt;code&gt;a@gin&lt;/code&gt; 및 &lt;code&gt;b@skeppet&lt;/code&gt; 라는 두 개의 개별 노드에서 데이터베이스를 실행하는 방법을 설명합니다 . 이러한 노드 각각은 있어야합니다 &lt;code&gt;Mnesia&lt;/code&gt; 의 이전 디렉토리 및 초기화 된 스키마 &lt;code&gt;Mnesia&lt;/code&gt; 을 시작할 수 있습니다. 사용할 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리를 지정하는 두 가지 방법 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">알 수없는 기능 및 유형에 대한 경고는 명령 행 버전의 종료 상태에 영향을줍니다. 기본값은 종료 상태를 설정할 때 알 수없는 기능 및 유형에 대한 경고를 무시하는 것입니다. Erlang의 Dialyzer를 사용할 때 알 수없는 기능 및 유형에 대한 경고가 반환됩니다. 기본값은 이러한 경고를 반환하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">추적 된 프로세스로 작성된 모든 프로세스가 추적 된 프로세스의 추적 플래그를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스가 &lt;code&gt;P2&lt;/code&gt; 에 링크 될 때마다 다른 프로세스 인 &lt;code&gt;P2&lt;/code&gt; 가 추적 된 프로세스의 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">더 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">그럼 가자! 짧은 버전의 설정 절차부터 시작하여 FAQ가 나온 다음 설정에 대한 자세한 내용을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;epmd&lt;/code&gt; 인스턴스는 쉼표로 구분 된 IP 주소 목록과 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신 할 수 있습니다. 환경 변수 &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; 를 사용하여 설정할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;epmd&lt;/code&gt; 인스턴스 가 기본값 4369 이외의 다른 TCP 포트를 청취 할 수 있습니다 . 환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 를 사용하여 설정할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">문자 번호</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">문자와 숫자</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">패턴의 문자는 대문자와 소문자가 모두 일치합니다. Perl 옵션 &lt;code&gt;/i&lt;/code&gt; 와 동일 하며 &lt;code&gt;(?i)&lt;/code&gt; 옵션 설정 으로 패턴 내에서 변경할 수 있습니다 . 대문자와 소문자는 ISO 8859-1 문자 세트에서와 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">레벨 1 : 함수 헤더, 예약어, 주석, 문자열, 인용 원자 및 문자 상수가 색상으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">2 단계 : 위의 속성, Erlang bif : s, guards 및 작은 따옴표로 묶은 주석의 단어에는 색상이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">레벨 3 : 위의 변수, 레코드 및 매크로가 색상으로 표시됩니다. 이 수준은 크리스마스 트리 수준이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Erlang 용 어휘 분석기 생성기</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">라이브러리 디렉토리를 추가, 편집 또는 삭제할 수 있습니다. 라이브러리 디렉토리 경로가 표시되는 행을 선택하고 마우스 오른쪽 버튼을 클릭하면됩니다. 팝업 메뉴에서 추가, 편집 또는 삭제를 선택하십시오. 라인 &lt;code&gt;Library directories&lt;/code&gt; 를 선택하고 마우스 오른쪽 버튼을 클릭하여 새 라이브러리 디렉토리를 추가 할 수도 있습니다 . 팝업 메뉴에서 추가를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">이진 데이터 처리를위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">이진 데이터를 처리하기위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">라이브러리 모듈-프로세스를 구현하지 않는 모듈의 골격.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;#&lt;/code&gt; 하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 처럼 ,리스트는 오른쪽에서 왼쪽으로 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 하지만, 더 많은 데이터가 압축 해제되지 통해 구성된 버퍼에 맞는보다 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; . 소량의 압축 입력이 최대 1000 배까지 확장 될 수 있도록 높은 압축 비율로 스트림을 압축 해제 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 만 반환은 작은 구현 정의 임계 값을 초과 확대되면. 시스템에 메모리가 부족할 때까지 확장되도록 악의적으로 제작 된 신뢰할 수없는 입력을 압축 해제 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 최상위 주석 만 삽입합니다. 함수 정의 나 선언 ( &quot;양식&quot;) 내의 주석은 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@custom_types&lt;/code&gt; 와 유사 하지만 &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; 대신 &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; 을 내보내려면 지정된 모듈이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; ,하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; , 얼랑 스타일로하지만 인쇄 번호 &lt;code&gt;#&lt;/code&gt; 는 기본 접두사를 단락 지어진. 예:</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; (있는 경우),하지만, 숫자 앞에 삽입하는 접두어 추가 인수를 걸리지 만 대시 후.</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;X&lt;/code&gt; ,하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">마찬가지로 &lt;code&gt;any&lt;/code&gt; ,하지만 첫 번째 필터의 정지는 많은 동료가있을 때 훨씬 더 효율적이 될 수 일치,있다. 예를 들어, 다음 필터는 호스트 및 영역 필터 모두에 가장 일치하는 피어 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">&lt;code&gt;debugVal(Expr)&lt;/code&gt; 과 유사 하지만 주어진 깊이로 잘린 항을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">마찬가지로 &lt;code&gt;lists:foldl/3&lt;/code&gt; ,하지만리스트의 목록 이상.</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">마찬가지로 &lt;code&gt;lists:mapfoldl/3&lt;/code&gt; ,하지만리스트의 목록 이상. 결과의 목록 목록은 주어진 목록 목록과 동일한 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">마찬가지로 &lt;code&gt;new_variable_name/1&lt;/code&gt; ,하지만 목록을 생성 &lt;code&gt;N&lt;/code&gt; 새 이름을.</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">&lt;code&gt;new_variable_name/2&lt;/code&gt; 와 유사 하지만 &lt;code&gt;N&lt;/code&gt; 개의 새 이름 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">주제 시작 부분에없는 빈 문자열 일치가 허용된다는 점을 제외하고 &lt;code&gt;notempty&lt;/code&gt; 와 같습니다 . 패턴이 고정 된 경우 패턴에 \ K가 포함 된 경우에만 이러한 일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{inparallel, Tests}&lt;/code&gt; 하지만,보다 더 이상 실행 &lt;code&gt;N&lt;/code&gt; 의 동시에 하위 검사.</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{spawn, Tests}&lt;/code&gt; 하지만, 주어진 얼랑 노드에서 지정된 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">포트 프로그램과 마찬가지로 포트는 Erlang 프로세스와 통신합니다. 모든 통신은 포트 드라이버 의 &lt;strong&gt;연결된 프로세스&lt;/strong&gt; 인 하나의 Erlang 프로세스를 거 &lt;strong&gt;칩니다&lt;/strong&gt; . 이 프로세스를 종료하면 포트 드라이버가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">가장 좋아하는 &lt;code&gt;gen_&lt;/code&gt; 행동, &lt;code&gt;gen_statem&lt;/code&gt; 는 서버 유지 &lt;code&gt;Data&lt;/code&gt; 상태 외에. 이로 인해 상태 수 (가상 머신 메모리가 충분하다고 가정) 또는 별개의 입력 이벤트 수에 대한 제한이 없으므로이 동작으로 구현 된 상태 머신은 실제로 Turing 완료입니다. 그러나 그것은 주로 이벤트 중심의 Mealy 머신처럼 느껴집니다.</target>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">subst / 2와 비슷하지만 결과를 템플릿에서 다시 트리로 변환하지 않습니다. 여러 개의 개별 대체를 수행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">등 &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; , 반환 상태 값이 아닌 경우 매크로하지만, 예외를 생성 &lt;code&gt;N&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">위와 같이 USTAR 호환 상태를 유지해야하는 경우 기호 / 하드 링크의 경로가 100 바이트를 넘지 않아야합니다. 그렇지 않으면 PAX 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">마찬가지로 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에서 레지스트리를 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">제한 사항 : 명령 문자열 &lt;code&gt;Cmd&lt;/code&gt; 는 에뮬레이터의 파일 이름 인코딩 모드에 따라 ISO Latin-1 또는 UTF-8로 인코딩 된 바이너리로 &lt;code&gt;heart&lt;/code&gt; 프로그램으로 전송됩니다 ( &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 참조 ). 인코딩 된 이진의 크기는 2047 바이트보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">첫 번째 일치 위치에서 &lt;code&gt;run/3&lt;/code&gt; 을 일치로 제한 합니다 . 패턴이 컴파일 된 경우 &lt;code&gt;anchored&lt;/code&gt; , 또는 그 내용의 미덕에 의해 고정 밝혀졌다, 따라서 더 없다, 시간을 일치에서 비 고정 할 수 없습니다 &lt;code&gt;unanchored&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">구문 트리를 지정된 깊이로 제한합니다. 지정된 &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;Tree&lt;/code&gt; 의 모든 비 리프 하위 트리를 바꿉니다 . 경우 &lt;code&gt;Depth&lt;/code&gt; 부의 경우, 결과는 항상 &lt;code&gt;Node&lt;/code&gt; 경우에도, &lt;code&gt;Tree&lt;/code&gt; 더 하위 트리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">&lt;code&gt;match_limit&lt;/code&gt; 와 매우 유사한 구현 별 방식으로 일치의 실행 시간 및 메모리 소비를 제한합니다 . PCRE 설명서에 다음과 같이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">구현 별 방식으로 일치하는 실행 시간을 제한합니다. PCRE 설명서에 다음과 같이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">Erlang 런타임 시스템에서 읽기 조작에 최적화 된 읽기 / 쓰기 잠금에 사용되는 리더 그룹 수를 제한합니다. 기본적으로 독자 그룹 제한은 64입니다.</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">지원할 수있는 동시 요청 수를 제한합니다. 기본값은 &lt;code&gt;150&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">HTTP 요청 URI의 크기를 제한합니다. 기본값은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">HTTP 요청의 메시지 본문 크기를 제한합니다. 기본값은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">HTTP 요청의 메시지 헤더 크기를 제한합니다. 기본값은 &lt;code&gt;10240&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">diffie-hellman-group-exchange에서 고객이 요청할 수있는 것을 제한합니다. 제한은 &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; 여기서 &lt;code&gt;MaxClient&lt;/code&gt; 및 &lt;code&gt;MinClient&lt;/code&gt; 는 연결 클라이언트가 제안한 값입니다.</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">줄 1 ( &lt;code&gt;%% 1&lt;/code&gt; 주석으로 표시됨) 은 &lt;code&gt;Bin0&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; 에 힙 바이너리 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">2 행은 추가 작업입니다. 으로 &lt;code&gt;Bin0&lt;/code&gt; 이 _가 작업에 참여하지 않은, 새로운 &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; 만들어지고의 내용 &lt;code&gt;Bin0&lt;/code&gt; 는 그것으로 복사됩니다. refc 이진 의 &lt;strong&gt;ProcBin&lt;/strong&gt; 부분은 이진에 저장된 데이터의 크기로 크기가 설정되어 있으며 이진 객체에는 추가 공간이 할당되어 있습니다. 이진 개체의 크기는 &lt;code&gt;Bin1&lt;/code&gt; 크기의 두 배 또는 256 중 큰 쪽입니다. 이 경우 256입니다.</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">3 호선이 더 흥미 롭습니다. &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 추가 작업에 사용되었으며 끝에 252 바이트의 사용되지 않은 스토리지가 있으므로 3 바이트의 새 바이트가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">네 번째 줄도 마찬가지입니다. 249 바이트가 남아 있으므로 다른 3 바이트를 저장하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">5 행. 여기서 &lt;strong&gt;흥미로운&lt;/strong&gt; 일이 발생합니다. 결과에 이전 결과에 추가되지 않도록주의 &lt;code&gt;Bin3&lt;/code&gt; 만에 &lt;code&gt;Bin1&lt;/code&gt; 을 . &lt;code&gt;Bin4&lt;/code&gt; 에 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; 값이 할당 될 것으로 예상 됩니다 . &lt;code&gt;Bin3&lt;/code&gt; 은 그 값 ( &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; )을 유지할 것으로 예상 됩니다 . 분명히 런타임 시스템은 바이트 &lt;code&gt;17&lt;/code&gt; 을 바이너리에 쓸 수 없습니다 . &lt;code&gt;Bin3&lt;/code&gt; 의 값이 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; 로 변경되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">줄 바꿈</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">줄 바꿈 (LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">줄 바꿈 (16 진수 0A)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">선 구분자</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">주석이 포함 된 행은 사용 된 % 문자 수에 따라 다르게 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">코드 오른쪽에 하나의 % 문자가있는 줄이 들여 쓰기됩니다. 열은 변수 &lt;code&gt;comment-column&lt;/code&gt; 에 의해 지정 되며 기본적으로 열 48이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">% 문자가 3 개 이상있는 줄은 왼쪽 여백에 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">% 문자가 두 개인 줄은 코드가 같은 상황에 있었던 것과 같은 깊이로 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">링크 된 드라이버에는 C로 특정 콜백 함수를 작성하는 것이 포함됩니다. 코드가 Erlang 런타임 시스템에 링크되어 있으므로 매우 우수한 기술이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">코드 연결</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">링크는 양방향이며 두 프로세스간에 하나의 링크 만있을 수 있습니다. &lt;code&gt;link(Pid)&lt;/code&gt; 에 대한 반복 호출 은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">링크는 다른 프로세스의 동작을 모니터링하는 데 사용됩니다 ( &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">Linux (Aurora)가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">Linux (Yellow Dog) 및 OS X 10.4가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (커널 2.6.15-2054 이상 필요)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">UTRACE를 지원하는 Linux 커널</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">리눅스가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">SystemTap 호환성을 통한 Linux. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">Linux : Fedora Core가 지원됩니다. 32 비트 및 64 비트 모드가 모두 지원됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
