<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f82ed6c2be9cde928b716896e0b7750e4269ef66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_server&lt;/code&gt; process handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 에서 의 설명에 따라 처리 시스템에서 메시지를 처리 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;sys&lt;/code&gt; 모듈 디버깅을 위해 사용될 수 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스.</target>
        </trans-unit>
        <trans-unit id="9183aff59e51eee9e3ac3b923db0e1df5aa748f5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 모든 특정 부품이 기능의 미리 정의 된 수출 콜백 모듈에 위치하는 가정합니다. 비헤이비어 함수와 콜백 함수의 관계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c088e6c3ad593b97e2719e3a7f2ef3d25643973c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 는 에 설명 된대로 시스템 메시지를 처리 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;sys&lt;/code&gt; 모듈은 디버깅에 사용할 수 있습니다 &lt;code&gt;gen_statem&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="cb679bbc4a894da7c683af08fece335a0b2f7f3a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;host&lt;/code&gt; filter is not typically desirable when setting Destination-Host since it will remove peer agents from the candidates list.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 는 후보리스트에서 피어 제를 제거하기 때문에 필터는 목적지 호스트 설정시 일반적으로 바람직하지 않다.</target>
        </trans-unit>
        <trans-unit id="3136f605b2f92ac3277fb1aa4fb5ac14a0ceaca5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; , 기본값은 &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687a85ac1691431ae16424f09a8711efd93e00b8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to [].</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; , []로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8945c1936d6e5ae6093c7d0fe2fcd18eac87d001" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;message_error()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">&lt;code&gt;message_error()&lt;/code&gt; 원격 사용자가 명시 적으로 transactionError 응답했음을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="e9dc2723fde49808f2786f42dd59628134c7bdff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;nowarn_xxx&lt;/code&gt; form, to turn off the warning.</source>
          <target state="translated">&lt;code&gt;nowarn_xxx&lt;/code&gt; 의 형태는 경고를 끕니다.</target>
        </trans-unit>
        <trans-unit id="c1871757dec2ac832830f5a635684899bd5b3db1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;permanent&lt;/code&gt; child process is always restarted.</source>
          <target state="translated">&lt;code&gt;permanent&lt;/code&gt; 자식 프로세스는 항상 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="adff669099f0ada70cada77f613b34ae862107ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor by name resolves the &lt;code&gt;RegisteredName&lt;/code&gt; to &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; only once at the moment of monitor instantiation, later changes to the name registration will not affect the existing monitor.</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 이름으로 모니터가 해결 &lt;code&gt;RegisteredName&lt;/code&gt; 에 &lt;code&gt;pid()&lt;/code&gt; 또는 &lt;code&gt;port()&lt;/code&gt; 이상, 한 번만 모니터 인스턴스의 순간을 기존의 모니터에 영향을주지 않습니다 이름 등록으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b4a4e8cecf512f5c76654bdb793223d7fff4380d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered only once, after that it is removed from both monitoring process and the monitored entity. Monitors are fired when the monitored process or port terminates, does not exist at the moment of creation, or if the connection to it is lost. If the connection to it is lost, we do not know if it still exists. The monitoring is also turned off when &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 가 모니터링 및 프로세스 모니터링 엔티티 모두로부터 제거 그 후 모니터 번만 트리거된다. 모니터 된 프로세스 또는 포트가 종료되거나 작성 시점에 존재하지 않거나 연결이 끊어지면 모니터가 시작됩니다. 연결이 끊어지면 여전히 존재하는지 알 수 없습니다. &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 이 호출 되면 모니터링도 꺼집니다 .</target>
        </trans-unit>
        <trans-unit id="faabc209db7c57f4dac9a885c73eaefbaad312f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in a test case information function</source>
          <target state="translated">테스트 케이스 정보 함수 의 &lt;code&gt;require&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="84c08b930b637efc74e4be68d8d836d66a78b1ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the suite information function (&lt;code&gt;suite/0&lt;/code&gt;)</source>
          <target state="translated">스위트 정보 기능 ( &lt;code&gt;suite/0&lt;/code&gt; ) 의 &lt;code&gt;require&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="c43c43f9ed4d600c7d71b45d8ac9c7203e0f6da6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the test suite information case or test case information-list is to look like &lt;code&gt;{require,CfgVarName}&lt;/code&gt; or &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt;. The arguments &lt;code&gt;AliasName&lt;/code&gt; and &lt;code&gt;CfgVarName&lt;/code&gt; are the same as the arguments to &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;AliasName&lt;/code&gt; becomes an alias for the configuration variable, and can be used as reference to the configuration data value. The configuration variable can be associated with any number of alias names, but each name must be unique within the same test suite. The two main uses for alias names follows:</source>
          <target state="translated">테스트 스위트 정보 케이스 또는 테스트 케이스 정보 목록 의 &lt;code&gt;require&lt;/code&gt; 문은 &lt;code&gt;{require,CfgVarName}&lt;/code&gt; 또는 &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt; 과 같습니다 . 인수 &lt;code&gt;AliasName&lt;/code&gt; 및 &lt;code&gt;CfgVarName&lt;/code&gt; 가 의 인수와 동일한 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;AliasName&lt;/code&gt; 은 구성 변수의 별명이되고 구성 데이터 값에 대한 참조로 사용될 수 있습니다. 구성 변수는 여러 개의 별명 ​​이름과 연관 될 수 있지만 각 이름은 동일한 테스트 스위트 내에서 고유해야합니다. 별명 이름의 두 가지 주요 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ff9958a6d15c210b3259bc6e40de68c3b9fa571" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;resend_indication()&lt;/code&gt;, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;resend_indication()&lt;/code&gt; , 기본값은 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0153a022671e7ff3f8f28950553457e8d9526f45" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;scanner&lt;/code&gt; to pre-process the text (program, etc.) to be parsed is not provided in the &lt;code&gt;yecc&lt;/code&gt; module. The scanner serves as a kind of lexicon look-up routine. It is possible to write a grammar that uses only character tokens as terminal symbols, thereby eliminating the need for a scanner, but this would make the parser larger and slower.</source>
          <target state="translated">구문 분석 할 텍스트 (프로그램 등)를 사전 처리 하는 &lt;code&gt;scanner&lt;/code&gt; 는 &lt;code&gt;yecc&lt;/code&gt; 모듈에 제공되지 않습니다 . 스캐너는 일종의 사전 검색 루틴 역할을합니다. 문자 토큰 만 터미널 기호로 사용하는 문법을 작성할 수 있으므로 스캐너가 필요하지 않지만 파서는 더 크고 느립니다.</target>
        </trans-unit>
        <trans-unit id="87ac317ef6fe7f30b73d95244c9d1336c4280f0e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;segment_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError for this segment. This is of course only possible if the reply was segmented.</source>
          <target state="translated">&lt;code&gt;segment_reason()&lt;/code&gt; 원격 사용자가이 세그먼트에 대한 명시 transactionError에 응답했음을 나타낸다. 이것은 물론 답장이 분할 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b6458c8e12fe0d6e7fcbb7cf092bd2f54ade6bdd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_error()&lt;/code&gt;, indicates that the send function of the megaco transport callback module failed to send the request. There are two separate cases: &lt;code&gt;send_cancelled_reason()&lt;/code&gt; and &lt;code&gt;send_failed_reason()&lt;/code&gt;. The first is the result of the send function returning &lt;code&gt;{cancel, Reason}&lt;/code&gt; and the second is some other kind of erroneous return value. See the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function for more info.</source>
          <target state="translated">&lt;code&gt;send_error()&lt;/code&gt; 상기 MEGACO 전송 콜백 모듈의 전송 기능은 요구를 송신하지 못했음을 나타낸다. &lt;code&gt;send_cancelled_reason()&lt;/code&gt; 과 &lt;code&gt;send_failed_reason()&lt;/code&gt; 두 가지 경우가 있습니다 . 첫 번째는 send 함수가 &lt;code&gt;{cancel, Reason}&lt;/code&gt; 리턴 한 결과이고 두 번째는 다른 종류의 잘못된 리턴 값입니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2afcbf56605493e5cb096c43726f60e7b25a7e6c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_reason()&lt;/code&gt;, indicates that the transport module &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function did not send the message. The reason for this can be:</source>
          <target state="translated">&lt;code&gt;send_reason()&lt;/code&gt; , 전송 모듈을 나타냅니다 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 의 기능은 메시지를 보내지 않았다. 그 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c9e5cf1fc1ef1d9c81cf8a83bbb2c92cb7facff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_mib_storage&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">&lt;code&gt;snmpa_mib_storage&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="be1b2110a34fe49a492c740fc6d2a1e353485a6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">&lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="da19f426ecc187ba7aec2fbddba35e35ebdc8cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;supervisor&lt;/code&gt; and a &lt;code&gt;supervisor_bridge&lt;/code&gt; are also &lt;code&gt;gen_server&lt;/code&gt; processes. To return information that this process is a supervisor and the name of the callback module, &lt;code&gt;Module&lt;/code&gt; is &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; is the name of the supervisor callback module. &lt;code&gt;Arity&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, as the &lt;code&gt;init/1&lt;/code&gt; function is called initially in the callback module.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 와 &lt;code&gt;supervisor_bridge&lt;/code&gt; 은 또한 &lt;code&gt;gen_server&lt;/code&gt; 처리합니다. 이 프로세스가 수퍼바이저이고 콜백 모듈의 이름이라는 정보를 리턴하려면 &lt;code&gt;Module&lt;/code&gt; 은 &lt;code&gt;supervisor&lt;/code&gt; 이고 &lt;code&gt;Function&lt;/code&gt; 은 수퍼바이저 콜백 모듈의 이름입니다. &lt;code&gt;Arity&lt;/code&gt; 있다 &lt;code&gt;1&lt;/code&gt; 은 AS, &lt;code&gt;init/1&lt;/code&gt; 기능은 콜 모듈 초기 불린다.</target>
        </trans-unit>
        <trans-unit id="9e84ddb3d1abb6010ba95215374a2c3fda587dad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;temporary&lt;/code&gt; child process is never restarted (not even when the supervisor restart strategy is &lt;code&gt;rest_for_one&lt;/code&gt; or &lt;code&gt;one_for_all&lt;/code&gt; and a sibling death causes the temporary process to be terminated).</source>
          <target state="translated">&lt;code&gt;temporary&lt;/code&gt; (감독자 재시작 전략이없는 경우에도 자식 프로세스가 다시 시작되지 않습니다 &lt;code&gt;rest_for_one&lt;/code&gt; 가 또는 &lt;code&gt;one_for_all&lt;/code&gt; 와 형제의 죽음이 종료되는 임시 공정의 원인).</target>
        </trans-unit>
        <trans-unit id="1d2a39bc2849b9b4ae106fb8032df69b5cf6fefa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp&lt;/code&gt; behavior and export the functions listed in the following.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 콜백 모듈은로 구현 될 &lt;code&gt;tftp&lt;/code&gt; 행동과 다음에 나열된 기능을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27cee850217202e8dabaf2537514f0583ea52228" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp_logger&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp_logger&lt;/code&gt; behavior and export the following functions:</source>
          <target state="translated">&lt;code&gt;tftp_logger&lt;/code&gt; 의 콜백 모듈은로 구현 될 &lt;code&gt;tftp_logger&lt;/code&gt; 의 행동과 수출 다음과 같은 기능 :</target>
        </trans-unit>
        <trans-unit id="6a934fbaa0dfee55a432f14191eb1f24df633cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tooBig&lt;/code&gt; error in an SNMPv1 packet will always use the &lt;code&gt;'NULL'&lt;/code&gt; value in all variable bindings.</source>
          <target state="translated">SNMPv1 패킷 의 &lt;code&gt;tooBig&lt;/code&gt; 오류 는 모든 변수 바인딩에서 항상 &lt;code&gt;'NULL'&lt;/code&gt; 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="33cb62d5e14ba5b3198337c7ba3cd6fbbcb1589c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transaction_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">&lt;code&gt;transaction_reason()&lt;/code&gt; 원격 사용자가 명시 적으로 transactionError 응답했음을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="e53d6f03dc678459ddffb4d98f7b557780e96fef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transient&lt;/code&gt; child process is restarted only if it terminates abnormally, that is, with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;transient&lt;/code&gt; 자식 프로세스는 그 이외의 종료 사유, 즉, 비정상적으로 종료하는 경우에만 다시 시작 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9eb9caf239b9bb7b398b87222c53f550da50ad9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_error()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;user_cancel_error()&lt;/code&gt; 상기 요청이 사용자에 의해 취소되었음을 나타낸다. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; 함수 호출에 제공된 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="caaac6e0eeba26f0e8f05cc72836874db9f304d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_reason()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;user_cancel_reason()&lt;/code&gt; 상기 요청이 사용자에 의해 취소되었음을 나타낸다. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; 함수 호출에 제공된 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5c86492d0dd649ce209af387e79b667ae92d9b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;warn_xxx&lt;/code&gt; form, to turn on the warning.</source>
          <target state="translated">&lt;code&gt;warn_xxx&lt;/code&gt; 의 형태는 경고를 켭니다.</target>
        </trans-unit>
        <trans-unit id="d4775dc55315e4de3bfb697e86b747e1981e9aa0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;components&quot;&gt;connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices, considering all edges undirected.</source>
          <target state="translated">&lt;strong id=&quot;components&quot;&gt;접속 요소는&lt;/strong&gt; 방향성이 모든 에지를 고려하여, 각 정점의 쌍 사이의 경로가되는 최대 서브 그래프의 예이다.</target>
        </trans-unit>
        <trans-unit id="c5c8116d1626ee6ce9e1eb9f966086aa8cd78606" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;depth_first_traversal&quot;&gt;depth-first traversal&lt;/strong&gt; of a directed digraph can be viewed as a process that visits all vertices of the digraph. Initially, all vertices are marked as unvisited. The traversal starts with an arbitrarily chosen vertex, which is marked as visited, and follows an edge to an unmarked vertex, marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no edge leading to an unvisited vertex. At that point the process backtracks, and the traversal continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated.</source>
          <target state="translated">지시 된 digraph 의 &lt;strong id=&quot;depth_first_traversal&quot;&gt;깊이 우선 탐색&lt;/strong&gt; 은 digraph의 모든 정점을 방문하는 프로세스로 볼 수 있습니다. 처음에는 모든 정점이 방문하지 않은 것으로 표시됩니다. 순회는 임의로 선택된 정점으로 시작하여 방문으로 표시되고 표시되지 않은 정점의 가장자리를 따라 해당 정점을 표시합니다. 그러면 검색되지 않은 정점으로 이어지는 가장자리가 없을 때까지 동일한 방식으로 해당 정점에서 검색이 진행됩니다. 이 시점에서 프로세스가 역 추적하고 가장자리가 검사되지 않는 한 순회가 계속됩니다. 첫 번째 정점의 모든 모서리를 검사 할 때 방문하지 않은 정점이 남아있는 경우, 지금까지 방문하지 않은 정점이 일부 선택되고 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="1b2506dfb79fff8f12c8b8a1cad93d4f54d6d800" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;digraph&quot;&gt;directed graph&lt;/strong&gt; (or just &quot;digraph&quot;) is a pair (V, E) of a finite set V of &lt;strong id=&quot;vertex&quot;&gt;vertices&lt;/strong&gt; and a finite set E of &lt;strong id=&quot;edge&quot;&gt;directed edges&lt;/strong&gt; (or just &quot;edges&quot;). The set of edges E is a subset of V &amp;times; V (the Cartesian product of V with itself).</source>
          <target state="translated">유 &lt;strong id=&quot;digraph&quot;&gt;방향 그래프&lt;/strong&gt; (또는 &quot;digraph&quot;)는 &lt;strong id=&quot;vertex&quot;&gt;정점&lt;/strong&gt; 의 유한 세트 V 와 &lt;strong id=&quot;edge&quot;&gt;유향 모서리&lt;/strong&gt; 의 유한 세트 E (또는 &quot;에지&quot;) 의 쌍 (V, E)입니다 . 에지 세트 (E)는 V &amp;times; V (V 자체의 데카르트 곱)의 서브 세트이다.</target>
        </trans-unit>
        <trans-unit id="d772fcf249486473885a86b1e0fb07e1b81cc558" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;function&quot;&gt;function&lt;/strong&gt; F is a relation, a subset of X &amp;times; Y, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x, y) in F. The latter condition can be formulated as follows: if x F y and x F z, then y = z. In this module, it is not required that the domain of F is equal to X for a relation to be considered a function.</source>
          <target state="translated">&lt;strong id=&quot;function&quot;&gt;함수&lt;/strong&gt; F는 관계, X &amp;times; Y의 서브 세트, 예 F의 도메인은 X와 동일하며 있다는 것을마다 X의 X F.의 (X, Y)와 Y의 독특한 원소 Y가 후자의 조건은 다음과 같이 공식화 될 수있다 : x F y 및 x F z이면, y = z. 이 모듈에서 관계를 함수로 간주하기 위해 F의 도메인이 X와 같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e6750400d02e17360f35f2ed9e1616f594d887a" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;loop&quot;&gt;loop&lt;/strong&gt; is a cycle of length one.</source>
          <target state="translated">&lt;strong id=&quot;loop&quot;&gt;루프는&lt;/strong&gt; 길이 하나의주기이다.</target>
        </trans-unit>
        <trans-unit id="7c11e23c2588408ff5e86ef238bc8fcbf38b7c2f" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partial_ordering&quot;&gt;partial ordering&lt;/strong&gt; of a set S is a transitive, antisymmetric, and reflexive relation between the objects of S.</source>
          <target state="translated">세트 S 의 &lt;strong id=&quot;partial_ordering&quot;&gt;부분 순서&lt;/strong&gt; 는 S의 객체들 사이의 전이, 비대칭 및 반사 관계이다.</target>
        </trans-unit>
        <trans-unit id="ac7ee38ffc1b59180cff85a400c6326e6a6aab8c" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partition&quot;&gt;partition&lt;/strong&gt; of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint.</source>
          <target state="translated">집합 X 의 &lt;strong id=&quot;partition&quot;&gt;파티션&lt;/strong&gt; 은 공용체가 X이고 요소가 쌍으로 분리되어있는 X의 비어 있지 않은 하위 집합의 컬렉션 S입니다.</target>
        </trans-unit>
        <trans-unit id="d7deee876d2b62ea04d66ac5c3791065935e84a9" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;path&quot;&gt;path&lt;/strong&gt; P from v[1] to v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &amp;lt;= i &amp;lt; k.</source>
          <target state="translated">digraph (V, E)에서 v [1]에서 v [k]까지 의 &lt;strong id=&quot;path&quot;&gt;경로&lt;/strong&gt; P는 V에서 꼭짓점의 비어 있지 않은 시퀀스 v [1], v [2], ..., v [k]입니다. 1 &amp;lt;= i &amp;lt;k 동안 E에 에지 (v [i], v [i + 1])가 있다는 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="e8aedf35788745c62222f34810b580741df0e0a0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;relation&quot;&gt;relation&lt;/strong&gt; is a subset of X &amp;times; Y. Let R be a relation. The fact that (x, y) belongs to R is written as x R y. As relations are sets, the definitions of the last item (subset, union, and so on) apply to relations as well.</source>
          <target state="translated">&lt;strong id=&quot;relation&quot;&gt;관계는&lt;/strong&gt; X &amp;times; Y를하자 R의 부분 집합의 관계가 될 것입니다. (x, y)가 R에 속한다는 사실은 x R y로 기록됩니다. 관계가 집합이므로 마지막 항목 (하위 집합, 공용체 등)의 정의가 관계에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="95446742f2edee92dac5319d85b31460c32015fe" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;simple_cycle&quot;&gt;simple cycle&lt;/strong&gt; is a path that is both a cycle and simple.</source>
          <target state="translated">&lt;strong id=&quot;simple_cycle&quot;&gt;간단한 사이클&lt;/strong&gt; 주기와 간단한 둘 수있는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="39c00c45dee614b6888498650b2a3b294abd94c1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;strong_components&quot;&gt;strongly connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices.</source>
          <target state="translated">&lt;strong id=&quot;strong_components&quot;&gt;강하게 연결된 구성 요소는&lt;/strong&gt; 정점의 각 쌍 사이의 경로가되는 최대 서브 그래프의 예이다.</target>
        </trans-unit>
        <trans-unit id="77ea1ecd6a8be92c17cbe1f20f7156f6526977e8" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;sub_binary&quot;&gt;sub binary&lt;/strong&gt; is created by &lt;code&gt;split_binary/2&lt;/code&gt; and when a binary is matched out in a binary pattern. A sub binary is a reference into a part of another binary (refc or heap binary, but never into another sub binary). Therefore, matching out a binary is relatively cheap because the actual binary data is never copied.</source>
          <target state="translated">&lt;strong id=&quot;sub_binary&quot;&gt;서브 바이너리&lt;/strong&gt; 의해 생성 &lt;code&gt;split_binary/2&lt;/code&gt; 때 이진가 이진 패턴에서 일치한다. 하위 이진은 다른 이진의 일부 (refc 또는 heap 이진이지만 다른 하위 이진에 대한 참조는 아님)에 대한 참조입니다. 따라서 실제 이진 데이터는 절대로 복사되지 않으므로 이진을 일치시키는 것이 상대적으로 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="0025b1cc50f1b9268b28c701eca602b36605c8b7" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;subgraph&quot;&gt;subgraph&lt;/strong&gt; G' of G is a digraph whose vertices and edges form subsets of the vertices and edges of G.</source>
          <target state="translated">G 의 &lt;strong id=&quot;subgraph&quot;&gt;서브 그래프&lt;/strong&gt; G '는 버텍스 및 에지가 G의 버텍스 및 에지의 서브 세트를 형성하는 디 그래프이다.</target>
        </trans-unit>
        <trans-unit id="0039a610746b5b7e8cb57b8cba5ce780934ff7d1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;tree&quot;&gt;tree&lt;/strong&gt; is an acyclic non-empty digraph such that there is a unique path between every pair of vertices, considering all edges undirected.</source>
          <target state="translated">&lt;strong id=&quot;tree&quot;&gt;나무는&lt;/strong&gt; 방향성이 모든 가장자리를 고려, 정점의 모든 쌍 사이의 고유 경로가있는 비순환 비어 있지 않은 소리를 나타내는 두 글자와 같은 것입니다.</target>
        </trans-unit>
        <trans-unit id="b32ebe8bef0eb8997c83afb4f754eff3d04ebc28" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;type&quot;&gt;type&lt;/strong&gt; is an element of the domain of Sets.</source>
          <target state="translated">&lt;strong id=&quot;type&quot;&gt;유형&lt;/strong&gt; 설정의 도메인의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c01dd20588e862d2bb347c0df2cf5a5ed91552dc" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;C node&lt;/strong&gt; is a C program written to act as a hidden node in a distributed Erlang system. The library &lt;strong&gt;Erl_Interface&lt;/strong&gt; contains functions for this purpose. For more information about C nodes, see the &lt;code&gt;Erl_Interface&lt;/code&gt; application and &lt;code&gt;Interoperability Tutorial.&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;C 노드는&lt;/strong&gt; 분산 얼랑 시스템의 숨겨진 노드의 역할을하도록 작성된 C 프로그램입니다. 라이브러리 &lt;strong&gt;Erl_Interface&lt;/strong&gt; 에는이 목적을위한 함수가 포함되어 있습니다. C 노드에 대한 자세한 정보는 &lt;code&gt;Erl_Interface&lt;/code&gt; 애플리케이션 및 &lt;code&gt;Interoperability Tutorial.&lt;/code&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="66dcfd2061a6be3ffc5089c446867b8415893bb3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;basic target system&lt;/strong&gt; that can be started by calling the ordinary &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">&lt;strong&gt;기본 대상 시스템&lt;/strong&gt; 일반 호출하여 시작할 수 있습니다 &lt;code&gt;erl&lt;/code&gt; 스크립트를.</target>
        </trans-unit>
        <trans-unit id="55d83db79d583006717a0aeac0080dc553b75d98" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bit string generator&lt;/strong&gt; is written as:</source>
          <target state="translated">&lt;strong&gt;비트 문자열 발생기&lt;/strong&gt; 로 작성된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="afe2abf552bd26d880de2e2001d284ae41c0e744" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bitstring&lt;/strong&gt; is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8. If the number of bits is divisible by 8, the bitstring is also a binary.</source>
          <target state="translated">&lt;strong&gt;비트 스트링이&lt;/strong&gt; 비트 수가 비트 수는 8로 나누어 경우 8의 배수 일 필요는 없다 0 개 이상의 비트들의 시퀀스이며, 비트 스트링은 이진이다.</target>
        </trans-unit>
        <trans-unit id="a2d735f3a5066ecc4d1454fc4b0afd8407d709de" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;configuration file&lt;/strong&gt; contains values for configuration parameters for the applications in the system. The &lt;code&gt;erl&lt;/code&gt; command-line argument &lt;code&gt;-config Name&lt;/code&gt; tells the system to use data in the system configuration file &lt;code&gt;Name.config&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;구성 파일은&lt;/strong&gt; 시스템의 응용 프로그램에 대한 구성 매개 변수의 값이 포함되어 있습니다. &lt;code&gt;erl&lt;/code&gt; 명령 줄 인수 &lt;code&gt;-config Name&lt;/code&gt; 시스템 구성 파일에 사용 된 데이터로 시스템을 말한다 &lt;code&gt;Name.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f0a033b07b19b645b9f720df2987e2a2450883" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;distributed Erlang system&lt;/strong&gt; consists of a number of Erlang runtime systems communicating with each other. Each such runtime system is called a &lt;strong&gt;node&lt;/strong&gt;. Message passing between processes at different nodes, as well as links and monitors, are transparent when pids are used. Registered names, however, are local to each node. This means that the node must be specified as well when sending messages, and so on, using registered names.</source>
          <target state="translated">&lt;strong&gt;분산 얼랑 시스템은&lt;/strong&gt; 서로 통신 얼랑 런타임 시스템의 다수로 구성된다. 이러한 각 런타임 시스템을 &lt;strong&gt;노드&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 링크 및 모니터뿐만 아니라 다른 노드의 프로세스 간 메시지 전달은 pid가 사용될 때 투명합니다. 그러나 등록 된 이름은 각 노드에 대해 로컬입니다. 이는 등록 된 이름을 사용하여 메시지 등을 보낼 때 노드도 지정해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="35fc39aba9120eb638121a4fd00b0aff5c8df307" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression that evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;필터는&lt;/strong&gt; 표현입니다 평가가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af58fb7b10794b226c8b033e42961c724b6386f1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression, which evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;필터&lt;/strong&gt; 계산되는 식이다 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7239a397a4de1f7e0f662d28e63db77e29a8a038" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function clause&lt;/strong&gt; consists of a clause head and a clause body, separated by &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;기능 절&lt;/strong&gt; 의해 분리 절 헤드 절 본체 구성 &lt;code&gt;-&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702433f39c9e775694cb8f7f07b7d2e088b91814" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function declaration&lt;/strong&gt; is a sequence of function clauses separated by semicolons, and terminated by period (.).</source>
          <target state="translated">&lt;strong&gt;함수 선언&lt;/strong&gt; 기능 절 세미콜론으로 분리하고, 기간 종료의 서열이다 (.).</target>
        </trans-unit>
        <trans-unit id="e0718a97c18e8111eccdd99489900e93dcc235d2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is written as:</source>
          <target state="translated">&lt;strong&gt;발전기&lt;/strong&gt; 로 작성된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="49fb24f8d2c4665a71b9fb75a2c85a70a1e64874" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard sequence&lt;/strong&gt; is a sequence of guards, separated by semicolon (;). The guard sequence is true if at least one of the guards is true. (The remaining guards, if any, are not evaluated.)</source>
          <target state="translated">&lt;strong&gt;가드 시퀀스&lt;/strong&gt; 는 세미콜론 (;)으로 구분 된 &lt;strong&gt;가드 시퀀스&lt;/strong&gt; 입니다. 가드 순서 중 하나 이상이 참이면 가드 순서가 참입니다. (만약 있다면 나머지 경비원은 평가되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="981eab14479daed48688de4a5ee56b2147f16eb8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard&lt;/strong&gt; is a sequence of guard expressions, separated by comma (,). The guard is true if all guard expressions evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;가드&lt;/strong&gt; 쉼표로 구분 가드 표현식의 서열이다 (). 모든 가드 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가되면 가드는 true 입니다 .</target>
        </trans-unit>
        <trans-unit id="a741610f94ddf021d50b6a4ce0ea1ba4c3d40351" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;list&lt;/strong&gt; is any number of items. For example, an argument list can consist of zero, one, or more arguments.</source>
          <target state="translated">&lt;strong&gt;목록&lt;/strong&gt; 항목의 수입니다. 예를 들어, 인수 목록은 0 개 이상의 인수로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc9678f26cf6461a8a6b9764f2f492dda8d420f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;log event&lt;/strong&gt; consists of a &lt;strong&gt;log level&lt;/strong&gt;, the &lt;strong&gt;message&lt;/strong&gt; to be logged, and &lt;strong&gt;metadata&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;로그 이벤트&lt;/strong&gt; (A)의 구성되어 &lt;strong&gt;로그 레벨&lt;/strong&gt; 은 &lt;strong&gt;메시지를&lt;/strong&gt; 기록하고있다 &lt;strong&gt;메타&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bec719f540faf5ce29c281150ca7c1acd29a54" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;match context&lt;/strong&gt; is similar to a sub binary, but is optimized for binary matching. For example, it contains a direct pointer to the binary data. For each field that is matched out of a binary, the position in the match context is incremented.</source>
          <target state="translated">&lt;strong&gt;검색 콘텍스트&lt;/strong&gt; 서브 이진 유사하지만, 이진 정합을 위해 최적화된다. 예를 들어, 이진 데이터에 대한 직접 포인터가 포함되어 있습니다. 이진에서 일치하는 각 필드에 대해 일치 컨텍스트의 위치가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="1e9bc69d9c0a74c78cd0265b7c282de9ccd749ff" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;module attribute&lt;/strong&gt; defines a certain property of a module.</source>
          <target state="translated">&lt;strong&gt;모듈 속성은&lt;/strong&gt; 모듈의 특정 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e8190f1687ae12b86f4402d53955920f9bd416c8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;node&lt;/strong&gt; is an executing Erlang runtime system that has been given a name, using the command-line flag &lt;code&gt;-name&lt;/code&gt; (long names) or &lt;code&gt;-sname&lt;/code&gt; (short names).</source>
          <target state="translated">&lt;strong&gt;노드는&lt;/strong&gt; 명령 줄 플래그를 사용하여 이름이 부여되지 않은 실행 얼랑 런타임 시스템 &lt;code&gt;-name&lt;/code&gt; (긴 이름) 또는 &lt;code&gt;-sname&lt;/code&gt; (짧은 이름).</target>
        </trans-unit>
        <trans-unit id="6e89fa647f29644ee120e6617c0ff85024742693" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;raw filename&lt;/strong&gt; is a filename specified as a binary. The Erlang VM does not translate a filename specified as a binary on systems with transparent naming.</source>
          <target state="translated">&lt;strong&gt;원시 파일 이름은&lt;/strong&gt; 바이너리로 지정된 파일 이름입니다. Erlang VM은 투명한 이름을 가진 시스템에서 바이너리로 지정된 파일 이름을 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a275977fa1312a664ffd71817618e729388e7ac1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release package&lt;/strong&gt; is a compressed tar file containing code for a certain version of a release, created by calling &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt;. The release package is to be located in the &lt;code&gt;$ROOT/releases&lt;/code&gt; directory of the previous version of the release, where &lt;code&gt;$ROOT&lt;/code&gt; is the installation root directory, &lt;code&gt;code:root_dir()&lt;/code&gt;. Another &lt;code&gt;releases&lt;/code&gt; directory can be specified using the SASL configuration parameter &lt;code&gt;releases_dir&lt;/code&gt; or the OS environment variable &lt;code&gt;RELDIR&lt;/code&gt;. The release handler must have write access to this directory to install the new release. The persistent state of the release handler is stored there in a file called &lt;code&gt;RELEASES&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;릴리스 패키지&lt;/strong&gt; 호출에 의해 생성 된 방출의 특정 버전에 대한 코드를 포함하는 압축 된 tar 파일 &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt; . 릴리스 패키지는 이전 버전의 &lt;code&gt;$ROOT/releases&lt;/code&gt; 의 $ ROOT / releases 디렉토리에 있습니다. 여기서 &lt;code&gt;$ROOT&lt;/code&gt; 는 설치 루트 디렉토리 &lt;code&gt;code:root_dir()&lt;/code&gt; 입니다. SASL 구성 매개 변수 &lt;code&gt;releases_dir&lt;/code&gt; 또는 OS 환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 을 사용하여 다른 &lt;code&gt;releases&lt;/code&gt; 디렉토리를 지정할 수 있습니다 . 새 릴리스를 설치하려면 릴리스 핸들러에이 디렉토리에 대한 쓰기 권한이 있어야합니다. 릴리스 핸들러의 지속적 상태는 &lt;code&gt;RELEASES&lt;/code&gt; 라는 파일에 저장됩니다..</target>
        </trans-unit>
        <trans-unit id="b0e927f4d2edf71fc5d44ab43ed17efe8434b72b" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release&lt;/strong&gt; is a complete system made out from a subset of Erlang/OTP applications and a set of user-specific applications.</source>
          <target state="translated">&lt;strong&gt;릴리스&lt;/strong&gt; 얼랑 / OTP 애플리케이션의 하위 집합 및 사용자 별 애플리케이션의 집합에서 만든 완전한 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="976ea0cb3408e08f1ff1f8752455df14d099e36d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;sequence&lt;/strong&gt; is one or more items. For example, a clause body consists of a sequence of expressions. This means that there must be at least one expression.</source>
          <target state="translated">&lt;strong&gt;시퀀스는&lt;/strong&gt; 하나 개 이상의 항목이다. 예를 들어, 절 본문은 일련의 식으로 구성됩니다. 이것은 최소한 하나의 표현이 있어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="17f419c4c64396cd3eddb7f3ce76e4edf856d5d9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple target system&lt;/strong&gt; where also code replacement in runtime can be performed.</source>
          <target state="translated">&lt;strong&gt;간단한 타겟 시스템&lt;/strong&gt; 런타임 코드 대체는 수행 될 수도.</target>
        </trans-unit>
        <trans-unit id="bd639259721f11093866111b359fef2a8236a3eb" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple test object&lt;/strong&gt; is one of the following:</source>
          <target state="translated">&lt;strong&gt;간단한 테스트 객체는&lt;/strong&gt; 다음 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="82a1fd7cbded9d1d8965325e8da4ad9119bb1b3f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;start type&lt;/strong&gt; is defined when starting the application:</source>
          <target state="translated">&lt;strong&gt;시작 유형은&lt;/strong&gt; 응용 프로그램을 시작할 때 정의된다 :</target>
        </trans-unit>
        <trans-unit id="a0236d18c08e4a43e425435b87053806e35cfab2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;symmetric key&lt;/strong&gt; algorithm has one key only. The key is used for both encryption and decryption. These algorithms are fast, compared to public key algorithms (using two keys, one public and one private) and are therefore typically used for encrypting bulk data.</source>
          <target state="translated">&lt;strong&gt;대칭 키&lt;/strong&gt; 알고리즘은 하나의 키가 있습니다. 이 키는 암호화 및 암호 해독에 모두 사용됩니다. 이 알고리즘은 공개 키 알고리즘 (공개 키와 개인 키 두 개 사용)에 비해 빠르므로 일반적으로 대량 데이터를 암호화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90e12c45690a2d90b9b7c27b63616643b3b02e6c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;token&lt;/strong&gt; is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms:</source>
          <target state="translated">&lt;strong&gt;토큰&lt;/strong&gt; 통사 카테고리 토큰 주석 및 터미널 심볼에 대한 정보를 포함하는 튜플이다. 문장 부호 문자 (예 : &lt;code&gt;;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; )와 예약어의 경우 범주와 기호가 일치하며 토큰은 두 개의 튜플로 표시됩니다. 3 개의 튜플은 다음 형식 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c710c4620cfaa2e0ecb80d9dcbf14cd7cba3ca83" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;user&lt;/strong&gt; in this context is basically a module implementing the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour. A &lt;strong&gt;user&lt;/strong&gt; can issue snmp requests and receive notification/traps.</source>
          <target state="translated">&lt;strong&gt;사용자&lt;/strong&gt; 이러한 맥락에서 기본적으로 구현하는 모듈입니다 &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; 의 동작을. &lt;strong&gt;사용자는&lt;/strong&gt; SNMP 요청을 발행 및 알림 / 트랩을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2d133d1504025586739d14579afcf2a4b16f56" translate="yes" xml:space="preserve">
          <source>A Bin does not need to consist of a whole number of bytes.</source>
          <target state="translated">Bin은 전체 바이트 수로 구성 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="446abf7d28572cb4c16319d9159e9f73428ea954" translate="yes" xml:space="preserve">
          <source>A Bin is a low-level sequence of bits or bytes. The purpose of a Bin is to enable construction of binaries:</source>
          <target state="translated">Bin은 하위 수준의 비트 또는 바이트 시퀀스입니다. Bin의 목적은 바이너리를 생성 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e18b65283e058fbced7bffdbd923450b434dd1e6" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the abstract code is compiler-generated. The Erlang Compiler does not emit warnings for such code.</source>
          <target state="translated">추상 코드가 컴파일러에서 생성되는지 여부를 나타내는 부울입니다. Erlang 컴파일러는 이러한 코드에 대한 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fafe519eed7d47dd4061f1954b6119a2c8bfca3" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the origin of the abstract code is a record. Used by &lt;code&gt;Dialyzer&lt;/code&gt; to assign types to tuple elements.</source>
          <target state="translated">추상 코드의 원점이 레코드인지 여부를 나타내는 부울입니다. &lt;code&gt;Dialyzer&lt;/code&gt; 에서 튜플 요소에 유형을 할당하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6de41a093bc1801677e67b2a06074305f2cfcbb9" translate="yes" xml:space="preserve">
          <source>A Boolean specifying if the data has been transmitted over the wire.</source>
          <target state="translated">와이어를 통해 데이터가 전송되었는지 여부를 지정하는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="0384327244e40e6c1e6266a9b063a6ad9f121c59" translate="yes" xml:space="preserve">
          <source>A C node has access to names registered through the &lt;code&gt;global&lt;/code&gt; module in Kernel. Names can be looked up, allowing the C node to send messages to named Erlang services. C nodes can also register global names, allowing them to provide named services to Erlang processes or other C nodes.</source>
          <target state="translated">AC 노드는 커널 의 &lt;code&gt;global&lt;/code&gt; 모듈을 통해 등록 된 이름에 액세스 할 수 있습니다 . C 노드가 명명 된 Erlang 서비스에 메시지를 보낼 수 있도록 이름을 조회 할 수 있습니다. C 노드는 글로벌 이름을 등록하여 Erlang 프로세스 또는 다른 C 노드에 이름 지정된 서비스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="682f01848ff412b810853a147adc8683eb3445ca" translate="yes" xml:space="preserve">
          <source>A C node server using long node names:</source>
          <target state="translated">긴 노드 이름을 사용하는 AC 노드 서버 :</target>
        </trans-unit>
        <trans-unit id="bb35db3d2e0c2f3a8f1ad0dde3a30bca6441edc6" translate="yes" xml:space="preserve">
          <source>A C program that uses the Erl_Interface functions for setting up a connection to, and communicating with, a distributed Erlang node is called a &lt;strong&gt;C node&lt;/strong&gt;, or a &lt;strong&gt;hidden node&lt;/strong&gt;. The main advantage with a C node is that the communication from the Erlang programmer's perspective is extremely easy, as the C program behaves as a distributed Erlang node.</source>
          <target state="translated">분산 Erlang 노드와의 연결을 설정하고 통신하기 위해 Erl_Interface 함수를 사용하는 AC 프로그램을 &lt;strong&gt;C 노드&lt;/strong&gt; 또는 &lt;strong&gt;숨겨진 노드&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . C 노드의 주요 장점은 C 프로그램이 분산 Erlang 노드로 작동하므로 Erlang 프로그래머의 관점에서 통신하는 것이 매우 쉽다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa24a183415b610afc89cc8dcdc9ea0fca45c74b" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">서버 역할을하는 C 노드에는 &lt;code&gt;ei_publish()&lt;/code&gt; 호출 할 때 작성 번호가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c7aba44f58b6222686f74dc17e0b3bd8f16425" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;erl_publish()&lt;/code&gt;.</source>
          <target state="translated">서버 역할을하는 C 노드에는 &lt;code&gt;erl_publish()&lt;/code&gt; 호출 할 때 작성 번호가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e5f9a2d3d932ac1d27aa18a6752ebffe6998981" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name does not appear in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">C 노드는 Erlang에 &lt;strong&gt;숨겨진 노드&lt;/strong&gt; 로 나타납니다 . 즉, C 노드의 이름을 알고있는 Erlang 프로세스는 일반적인 방식으로 C 노드와 통신 할 수 있지만 &lt;code&gt;ERTS&lt;/code&gt; 의 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 에서 제공 한 목록에는 노드 이름이 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e583adab7ce74410cb0c7c1feef4181103360c0c" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name is not shown in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">C 노드는 Erlang에 &lt;strong&gt;숨겨진 노드&lt;/strong&gt; 로 나타납니다 . 즉, C 노드의 이름을 알고있는 Erlang 프로세스는 일반적인 방식으로 C 노드와 통신 할 수 있지만 &lt;code&gt;ERTS&lt;/code&gt; 의 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 에 의해 제공되는 목록에는 노드 이름이 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08059f968b0ad7c0b01718559289e25bd4f10ee5" translate="yes" xml:space="preserve">
          <source>A CPU Load and CPU Utilization Supervisor Process</source>
          <target state="translated">CPU로드 및 CPU 사용률 감독자 프로세스</target>
        </trans-unit>
        <trans-unit id="5d2433f698f9b491166c109983414e1ff91ef2ab" translate="yes" xml:space="preserve">
          <source>A CPU topology can consist of both processor external, and processor internal NUMA nodes as long as each logical processor belongs to only one NUMA node. If &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; is omitted, its default position is before &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt;. That is, the default is processor external NUMA nodes.</source>
          <target state="translated">각 논리 프로세서가 하나의 NUMA 노드에만 속하는 한 CPU 토폴로지는 프로세서 외부 및 프로세서 내부 NUMA 노드로 구성 될 수 있습니다. 경우 &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; 가 생략, 기본 위치는 앞에있는 &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt; . 즉, 기본값은 프로세서 외부 NUMA 노드입니다.</target>
        </trans-unit>
        <trans-unit id="8ed401286c11a4167b9153f2763d08ee22a748c5" translate="yes" xml:space="preserve">
          <source>A CTH can be installed in multiple ways in your test run. You can do it for all tests in a run, for specific test suites, and for specific groups within a test suite. If you want a CTH to be present in all test suites within your test run, there are three ways to accomplish that, as follows:</source>
          <target state="translated">CTH는 테스트 실행에서 여러 가지 방법으로 설치할 수 있습니다. 실행의 모든 ​​테스트, 특정 테스트 스위트 및 테스트 스위트 내의 특정 그룹에 대해이를 수행 할 수 있습니다. 테스트 실행 내의 모든 테스트 스위트에 CTH를 제공하려면 다음과 같이 세 가지 방법으로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2484fb91ce1c0711415802f1c1e1b2f011ddea08" translate="yes" xml:space="preserve">
          <source>A Coverage Analysis Tool for Erlang</source>
          <target state="translated">Erlang의 범위 분석 도구</target>
        </trans-unit>
        <trans-unit id="462cfacaa4707242a4aec32251bf3187a68a4056" translate="yes" xml:space="preserve">
          <source>A Cross Reference Tool for analyzing dependencies between functions, modules, applications and releases.</source>
          <target state="translated">기능, 모듈, 응용 프로그램 및 릴리스 간의 종속성을 분석하기위한 상호 참조 도구입니다.</target>
        </trans-unit>
        <trans-unit id="52283e056d3171a619c0cac0805fc7102c861750" translate="yes" xml:space="preserve">
          <source>A DBMS query language, Query List Comprehension (QLC) as an add-on library.</source>
          <target state="translated">애드온 라이브러리 인 DBMS 쿼리 언어 인 QLC (Query List Comprehension)</target>
        </trans-unit>
        <trans-unit id="bb6bc7a0a2c07a2fe54be2405da37b62f7c39bde" translate="yes" xml:space="preserve">
          <source>A DSA private key can look as follows:</source>
          <target state="translated">DSA 개인 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0b5e71146772a786dbb1661b191c55af9cb0b9a" translate="yes" xml:space="preserve">
          <source>A Diameter application supported by the service.</source>
          <target state="translated">서비스에서 지원하는 직경 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="d177fdf4f1cf327fbf5fecfc4fa72345624b5d5f" translate="yes" xml:space="preserve">
          <source>A Diameter message as passed over the transport interface.</source>
          <target state="translated">전송 인터페이스를 통해 전달되는 직경 메시지</target>
        </trans-unit>
        <trans-unit id="62bfb25c7e21e8b536daf6c9f716b0eb6fa490c9" translate="yes" xml:space="preserve">
          <source>A Diameter node is implemented by configuring a &lt;strong&gt;service&lt;/strong&gt; and one or more &lt;strong&gt;transports&lt;/strong&gt; using the interface module &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt;. The service configuration defines the Diameter applications to be supported by the node and, typically, the capabilities that it should send to remote peers at capabilities exchange upon the establishment of transport connections. A transport is configured on a service and provides protocol-specific send/receive functionality by way of a transport interface defined by diameter and implemented by a transport module. The diameter application provides two transport modules: &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; for transport over TCP (using &lt;code&gt;gen_tcp&lt;/code&gt;) and SCTP (using &lt;code&gt;gen_sctp&lt;/code&gt;) respectively. Other transports can be provided by any module that implements diameter's &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">직경 노드는 인터페이스 모듈 &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;strong&gt;서비스&lt;/strong&gt; 및 하나 이상의 &lt;strong&gt;전송&lt;/strong&gt; 을 구성하여 구현됩니다 . 서비스 구성은 노드가 지원할 Diameter 애플리케이션과 일반적으로 전송 연결 설정시 기능 교환시 원격 피어에 전송해야하는 기능을 정의합니다. 전송은 서비스에서 구성되며 직경에 의해 정의되고 전송 모듈에 의해 구현되는 전송 인터페이스를 통해 프로토콜 특정 송신 / 수신 기능을 제공합니다. 직경 응용 프로그램은 TCP를 통한 전송 ( &lt;code&gt;gen_tcp&lt;/code&gt; 사용 ) 및 SCTP (사용)의 두 가지 전송 모듈을 제공합니다 : &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_sctp&lt;/code&gt; ). 직경의 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt; 를 구현하는 모든 모듈에서 다른 운송 수단을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6f02eb64bbe780dfde9efd8754001ee09c7d316" translate="yes" xml:space="preserve">
          <source>A Disk Supervisor Process</source>
          <target state="translated">디스크 감독자 프로세스</target>
        </trans-unit>
        <trans-unit id="cfe5d3f52e1bab9a63a7df0c0c6f4e1c0567b94a" translate="yes" xml:space="preserve">
          <source>A File Transfer Protocol client.</source>
          <target state="translated">파일 전송 프로토콜 클라이언트</target>
        </trans-unit>
        <trans-unit id="8d70bbe040a2f8306532e86a99c772dde2300f04" translate="yes" xml:space="preserve">
          <source>A GUI tool for observing an Erlang system.</source>
          <target state="translated">Erlang 시스템을 관찰하기위한 GUI 도구.</target>
        </trans-unit>
        <trans-unit id="412558260339ef39924a36cedb4746b92b39860e" translate="yes" xml:space="preserve">
          <source>A MIB compiler, which understands SMIv1 (RFC1155, 1212, and 1215) and SMIv2 (RFC1902, 1903, and 1904).</source>
          <target state="translated">SMIv1 (RFC1155, 1212 및 1215) 및 SMIv2 (RFC1902, 1903 및 1904)를 이해하는 MIB 컴파일러</target>
        </trans-unit>
        <trans-unit id="465e342200f443fe19bf77c7c55e103eb0525cf5" translate="yes" xml:space="preserve">
          <source>A Make Utility for Erlang</source>
          <target state="translated">Erlang을위한 Make Utility</target>
        </trans-unit>
        <trans-unit id="4dfa6d3d81a250e09767148c068c430d43e6542a" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to #megaco_incr_timer{}.</source>
          <target state="translated">Megaco Timer (위 설명 참조)의 기본값은 #megaco_incr_timer {}입니다.</target>
        </trans-unit>
        <trans-unit id="b68589e1526f4c0bee999a382123018413ba14b2" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to 30000.</source>
          <target state="translated">Megaco Timer (위 설명 참조)의 기본값은 30000입니다.</target>
        </trans-unit>
        <trans-unit id="cbd6f555dff6fd8042f699c901ba913734ef4278" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;.</source>
          <target state="translated">Megaco Timer (위 설명 참조)의 기본값은 &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2dad93e1d5d1ceeacd635b8d583372b48511bbd3" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;10000&lt;/code&gt;.</source>
          <target state="translated">Megaco 타이머 (위 설명 참조)의 기본값은 &lt;code&gt;10000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c141bdf1ede3294bead601d72060262ea844d853" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;60 seconds&lt;/code&gt;.</source>
          <target state="translated">Megaco Timer (위 설명 참조)의 기본값은 &lt;code&gt;60 seconds&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b0881b9c745a291d82b3b71d65651beef69c53b" translate="yes" xml:space="preserve">
          <source>A Memory Supervisor Process</source>
          <target state="translated">메모리 관리자 프로세스</target>
        </trans-unit>
        <trans-unit id="ae5893b089e2986872b8d9a34ac398cb97910587" translate="yes" xml:space="preserve">
          <source>A NIF does not have to be exported, it can be local to the module. However, unused local stub functions will be optimized away by the compiler, causing loading of the NIF library to fail.</source>
          <target state="translated">NIF는 내보낼 필요가 없으며 모듈에 로컬 일 수 있습니다. 그러나 사용하지 않는 로컬 스텁 함수는 컴파일러에 의해 최적화되어 NIF 라이브러리로드에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae9dbde8e133cef08c1e749be3a70e95b4ade2c3" translate="yes" xml:space="preserve">
          <source>A NIF is a function that is implemented in C instead of Erlang. NIFs appear as any other functions to the callers. They belong to a module and are called like any other Erlang functions. The NIFs of a module are compiled and linked into a dynamic loadable, shared library (SO in UNIX, DLL in Windows). The NIF library must be loaded in runtime by the Erlang code of the module.</source>
          <target state="translated">NIF는 Erlang 대신 C로 구현되는 함수입니다. NIF는 호출자에게 다른 기능으로 나타납니다. 그것들은 모듈에 속하며 다른 Erlang 함수처럼 호출됩니다. 모듈의 NIF는 컴파일되어 동적으로로드 가능한 공유 라이브러리 (UNIX의 SO, Windows의 DLL)에 링크됩니다. 모듈의 Erlang 코드로 NIF 라이브러리를 런타임에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="84d9be08ac04a1b8855fd49f7405173d0e59dc63" translate="yes" xml:space="preserve">
          <source>A NIF is thread-safe without any explicit synchronization as long as it acts as a pure function and only reads the supplied arguments. When you write to a shared state either through static variables or &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;, you need to supply your own explicit synchronization. This includes terms in process-independent environments that are shared between threads. Resource objects also require synchronization if you treat them as mutable.</source>
          <target state="translated">NIF는 순수 함수로 작동하고 제공된 인수 만 읽는 한 명시적인 동기화없이 스레드로부터 안전합니다. 정적 변수 또는 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 를 통해 공유 상태에 쓸 때는 고유 한 명시 적 동기화를 제공해야합니다. 여기에는 스레드간에 공유되는 프로세스 독립적 환경의 용어가 포함됩니다. 자원 객체는 변경 가능한 것으로 취급하는 경우 동기화가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8a60c02f399b39b76528cae89a210e7ba95c129a" translate="yes" xml:space="preserve">
          <source>A NIF library contains native implementation of some functions of an Erlang module. The native implemented functions (NIFs) are called like any other functions without any difference to the caller. Each NIF must have an implementation in Erlang that is invoked if the function is called before the NIF library is successfully loaded. A typical such stub implementation is to throw an exception. But it can also be used as a fallback implementation if the NIF library is not implemented for some architecture.</source>
          <target state="translated">NIF 라이브러리에는 Erlang 모듈의 일부 기능이 기본적으로 구현되어 있습니다. 기본 구현 함수 (NIF)는 호출자와 아무런 차이없이 다른 함수처럼 호출됩니다. 각 NIF에는 Erlang에 구현이 있어야하며 NIF 라이브러리가 성공적으로로드되기 전에 함수가 호출되면 호출됩니다. 이러한 스텁 구현은 일반적으로 예외를 발생시키는 것입니다. 그러나 NIF 라이브러리가 일부 아키텍처에 대해 구현되지 않은 경우 대체 구현으로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="16083aaa52c81a0267780218bf0e70427a08f38c" translate="yes" xml:space="preserve">
          <source>A NIF library is already loaded for this module instance. The previously deprecated &lt;code&gt;reload&lt;/code&gt; feature was removed in OTP 20.</source>
          <target state="translated">이 모듈 인스턴스에 대해 NIF 라이브러리가 이미로드되어 있습니다. 이전에 더 이상 사용되지 않는 &lt;code&gt;reload&lt;/code&gt; 기능이 OTP 20에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a1f48477831047343a1f8bf95917f0e713f592c" translate="yes" xml:space="preserve">
          <source>A NIF that cannot be split and cannot execute in a millisecond or less is called a &quot;dirty NIF&quot;, as it performs work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. This is handled by executing dirty jobs on a separate set of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the same duration restriction as a normal NIF.</source>
          <target state="translated">분할 할 수없고 밀리 초 이내에 실행할 수없는 NIF를 &quot;더티 NIF&quot;라고합니다. Erlang 런타임 시스템의 일반 스케줄러가 깨끗하게 처리 할 수없는 작업을 수행하기 때문입니다. 이러한 기능을 사용하는 응용 프로그램은 런타임에 해당 기능이 더럽다는 것을 표시하여 특수하게 처리 할 수 ​​있어야합니다. 이는 더티 스케줄러라는 별도의 스케줄러 세트에서 더티 작업을 실행하여 처리됩니다. 더티 스케줄러에서 실행되는 더티 NIF는 일반 NIF와 동일한 기간 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="af197bff7b3c7ea0c0e795a6e3fce23b4ca646b1" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP agent &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Net if 프로세스는 SNMP 에이전트 &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4682baf7bf989ecc09c30378539a80083913f72a" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP manager &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Net if 프로세스는 SNMP 관리자 &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5ce5e0afdd417aa616eb37eb871e57129530691" translate="yes" xml:space="preserve">
          <source>A POSIX error value if something else goes wrong, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; for possible error values</source>
          <target state="translated">다른 문제가 발생하면 POSIX 오류 값 입니다. 가능한 오류 값 은 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66a3f3d7962a2ff38d3eb0fc27400ec7705ecedf" translate="yes" xml:space="preserve">
          <source>A POSIX thread like API for multi-threading is provided. The Erlang driver thread API only provides a subset of the functionality provided by the POSIX thread API. The subset provided is more or less the basic functionality needed for multi-threaded programming:</source>
          <target state="translated">멀티 스레딩을위한 API와 같은 POSIX 스레드가 제공됩니다. Erlang 드라이버 스레드 API는 POSIX 스레드 API에서 제공하는 기능의 서브 세트 만 제공합니다. 제공된 서브 세트는 멀티 스레드 프로그래밍에 필요한 기본 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0bd457a7ac87a208b16a149cb348e99367ad82ba" translate="yes" xml:space="preserve">
          <source>A PPID can be configured with a a gen_sctp sctp_default_send_param option.</source>
          <target state="translated">PPID는 gen_sctp sctp_default_send_param 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c511d3ccb60e7dc830ac553725bdc5da3a2e9fa" translate="yes" xml:space="preserve">
          <source>A Route-Record AVP is appended by diameter when the return value of a request callback asks that a request be forwarded. Appending the AVP in other cases is the responsibility of the user.</source>
          <target state="translated">라우트 레코드 AVP는 요청 콜백의 리턴 값이 요청을 전달하도록 요청할 때 직경으로 추가됩니다. 다른 경우에 AVP를 추가하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="094734567e030c7a3c51ff51fd0000a24bb2ce28" translate="yes" xml:space="preserve">
          <source>A SAX parser for XML that sends the events through a callback interface. SAX is the &lt;strong&gt;Simple API for XML&lt;/strong&gt;, originally a Java-only API. SAX was the first widely adopted API for XML in Java, and is a &lt;strong&gt;de facto&lt;/strong&gt; standard where there are versions for several programming language environments other than Java.</source>
          <target state="translated">콜백 인터페이스를 통해 이벤트를 보내는 XML 용 SAX 파서. SAX는 &lt;strong&gt;XML 용 Simple API&lt;/strong&gt; 이며 원래 Java 전용 API입니다. SAX는 Java에서 XML에 가장 널리 채택 된 API 이며 Java 이외의 여러 프로그래밍 언어 환경에 대한 버전 이있는 &lt;strong&gt;사실상의&lt;/strong&gt; 표준입니다.</target>
        </trans-unit>
        <trans-unit id="248ee08e6a02ab2fc5bc7400b653c53caa52bbda" translate="yes" xml:space="preserve">
          <source>A Set of Release Handling Tools</source>
          <target state="translated">릴리스 처리 도구 세트</target>
        </trans-unit>
        <trans-unit id="60186d2f270382eb00ad49b3e5e34efc25a7eb30" translate="yes" xml:space="preserve">
          <source>A TAR program that understands the GNU TAR format for long filenames.</source>
          <target state="translated">긴 파일 이름에 대한 GNU TAR 형식을 이해하는 TAR 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="7a5eb9a2cf5198242ce83b7910f56bb7256b5a72" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool for Erlang</source>
          <target state="translated">Erlang을위한 시간 프로파일 링 도구</target>
        </trans-unit>
        <trans-unit id="02d15da22619453c9a967ff17ef23dbd1a99ec4f" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool using trace to file for minimal runtime performance impact.</source>
          <target state="translated">런타임 성능에 미치는 영향을 최소화하기 위해 추적 파일을 사용하는 시간 프로파일 링 도구입니다.</target>
        </trans-unit>
        <trans-unit id="b6a932a694249ceff9de8c32f16fd50b0a78a087" translate="yes" xml:space="preserve">
          <source>A URI is an identifier consisting of a sequence of characters matching the syntax rule named &lt;strong&gt;URI&lt;/strong&gt; in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">URI는 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 에서 &lt;strong&gt;URI&lt;/strong&gt; 라는 구문 규칙과 일치하는 문자 시퀀스로 구성된 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="e149e0b4c1a1c105b7f889d32cd56c5262fc2226" translate="yes" xml:space="preserve">
          <source>A Unicode extended grapheme cluster</source>
          <target state="translated">유니 코드 확장 grapheme 클러스터</target>
        </trans-unit>
        <trans-unit id="91c776c2572caac7dae19c58dc677fab9b2bc760" translate="yes" xml:space="preserve">
          <source>A Unix-specific example:</source>
          <target state="translated">유닉스 관련 예제 :</target>
        </trans-unit>
        <trans-unit id="44f895c061c338a2c4f6db51cc29f383c116fdd5" translate="yes" xml:space="preserve">
          <source>A User is an entity identified by a MID, e.g. a MGC or a MG.</source>
          <target state="translated">사용자는 MID (예 : MGC 또는 MG)로 식별되는 엔터티입니다.</target>
        </trans-unit>
        <trans-unit id="32b6de1aa97b29f50e5912a12d7ac4a95b0cfea8" translate="yes" xml:space="preserve">
          <source>A WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Erlang 크래시 덤프를 찾아보기위한 WxWidgets 기반 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e4bde50404582298e3cf270bb8ccc3daf0ea5444" translate="yes" xml:space="preserve">
          <source>A back reference (see the next section)</source>
          <target state="translated">역 참조 (다음 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="53d6a047b6dd3ed0e849f25a2c3fb01b061ee975" translate="yes" xml:space="preserve">
          <source>A back reference matches whatever matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (section &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; describes a way of doing that). So, the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;:</source>
          <target state="translated">역 참조는 서브 패턴 자체와 일치하는 것이 아니라 현재 주제 문자열에서 캡처 서브 패턴과 일치하는 항목과 일치합니다 (서브 &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; 패턴 섹션 은이를 수행하는 방법을 설명합니다). 따라서 다음 패턴은 &quot;감각과 감성&quot;및 &quot;응답과 책임&quot;과 일치하지만 &quot;감각과 책임&quot;과는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7a2ff223aa7f1180c7a5c0c761648542d8226fb" translate="yes" xml:space="preserve">
          <source>A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a\1) never matches. However, such references can be useful inside repeated subpatterns. For example, the following pattern matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot;, and so on:</source>
          <target state="translated">하위 패턴을 처음 사용할 때 참조하는 괄호 안에서 발생하는 역 참조는 실패하므로 예를 들어 (a \ 1)이 일치하지 않습니다. 그러나 이러한 참조는 반복 서브 패턴 내에서 유용 할 수 있습니다. 예를 들어, 다음 패턴은 &quot;a&quot;및 &quot;aba&quot;, &quot;ababbaa&quot;등과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ffc1ebbafbdaba3dd7477ee36631ba1276292a19" translate="yes" xml:space="preserve">
          <source>A back reference to a numbered subpattern uses the most recent value that is set for that number by any subpattern. The following pattern matches &quot;abcabc&quot; or &quot;defdef&quot;:</source>
          <target state="translated">번호가 매겨진 하위 패턴에 대한 역 참조는 하위 패턴에 의해 해당 숫자에 대해 설정된 최신 값을 사용합니다. 다음 패턴은 &quot;abcabc&quot;또는 &quot;defdef&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0d402fcdbef693771940455e9ef73fd921c03b39" translate="yes" xml:space="preserve">
          <source>A base for building trace tools for distributed systems.</source>
          <target state="translated">분산 시스템을위한 추적 도구를 빌드하기위한 기반입니다.</target>
        </trans-unit>
        <trans-unit id="c418f2ac7b109d9e422eb741c2ec0065dcef710c" translate="yes" xml:space="preserve">
          <source>A basic concept in Erlang/OTP is the &lt;strong&gt;supervision tree&lt;/strong&gt;. This is a process structuring model based on the idea of &lt;strong&gt;workers&lt;/strong&gt; and &lt;strong&gt;supervisors&lt;/strong&gt;:</source>
          <target state="translated">Erlang / OTP의 기본 개념은 &lt;strong&gt;감독 트리&lt;/strong&gt; 입니다. 이는 &lt;strong&gt;근로자&lt;/strong&gt; 와 &lt;strong&gt;감독자&lt;/strong&gt; 의 아이디어에 기반한 프로세스 구조화 모델입니다 .</target>
        </trans-unit>
        <trans-unit id="a7814d9e97780d5bb1e4072e8590cdbb3e3d0929" translate="yes" xml:space="preserve">
          <source>A better solution for a real module is to take advantage of the new directive &lt;code&gt;on_load&lt;/code&gt; (see section &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; in the Erlang Reference Manual) to load the NIF library automatically when the module is loaded.</source>
          <target state="translated">실제 모듈에 대한 더 나은 해결책 &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; 새로운 지시문 &lt;code&gt;on_load&lt;/code&gt; ( Erlang 참조 매뉴얼에 모듈이로드 될 때 기능 실행 섹션 참조)를 사용하여 NIF 라이브러리를 자동으로로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e748c424b491ef4e2b424caaa0193f66560cd4" translate="yes" xml:space="preserve">
          <source>A binary data object, structured according to the Erlang external term format.</source>
          <target state="translated">Erlang 외부 용어 형식에 따라 구조화 된 이진 데이터 개체입니다.</target>
        </trans-unit>
        <trans-unit id="298c689646b297768a8fb73aa045eb2812167789" translate="yes" xml:space="preserve">
          <source>A binding structure.</source>
          <target state="translated">바인딩 구조.</target>
        </trans-unit>
        <trans-unit id="e77e3889fe8c014ea8612f275ae6ccbea02093b9" translate="yes" xml:space="preserve">
          <source>A bit string comprehension returns a bit string, which is created by concatenating the results of evaluating &lt;code&gt;BitString&lt;/code&gt; for each combination of bit string generator elements, for which all filters are true.</source>
          <target state="translated">비트 열 이해는 비트 열을 반환하는데 , 이는 모든 필터가 참인 비트 열 생성기 요소의 각 조합에 대해 &lt;code&gt;BitString&lt;/code&gt; 평가 결과를 연결하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c30114629b8426a6ada7d40a7f0ce097c95413d5" translate="yes" xml:space="preserve">
          <source>A bit string is used to store an area of untyped memory.</source>
          <target state="translated">비트 문자열은 형식화되지 않은 메모리 영역을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36bc1be2e2bdda5bcfbb5daa59af1b7decd47b95" translate="yes" xml:space="preserve">
          <source>A bitstring. By default, a &lt;code&gt;BIT STRING&lt;/code&gt; with no symbolic names is decoded to an Erlang bitstring.</source>
          <target state="translated">비트 스트링. 기본적으로 기호 이름이없는 &lt;code&gt;BIT STRING&lt;/code&gt; 은 Erlang 비트 열로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c215287a4d613c8262ada2c7133754a941970ff4" translate="yes" xml:space="preserve">
          <source>A body B is a non-empty sequence of expressions &lt;code&gt;E_1, ..., E_k&lt;/code&gt;, and Rep(B) = &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt;.</source>
          <target state="translated">본문 B는 비어 있지 않은 일련의 표현식 &lt;code&gt;E_1, ..., E_k&lt;/code&gt; 및 Rep (B) = &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d107afa764d6c26d14d3133c85da34202dfafd4f" translate="yes" xml:space="preserve">
          <source>A boot script (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;) can be used that automatically starts the application.</source>
          <target state="translated">응용 프로그램을 자동으로 시작 하는 부팅 스크립트 ( &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; 참조 )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919bef16600e113be86a5b24871b84665ab0d813" translate="yes" xml:space="preserve">
          <source>A boot script can be written manually. However, it is recommended to create a boot script by generating it from a release resource file &lt;code&gt;Name.rel&lt;/code&gt;, using the function &lt;code&gt;systools:make_script/1,2&lt;/code&gt;. This requires that the source code is structured as applications according to the OTP design principles. (The program does not have to be started in terms of OTP applications, but can be plain Erlang).</source>
          <target state="translated">부팅 스크립트는 수동으로 작성할 수 있습니다. 그러나 &lt;code&gt;systools:make_script/1,2&lt;/code&gt; 함수를 사용하여 릴리스 자원 파일 &lt;code&gt;Name.rel&lt;/code&gt; 에서 부트 스크립트를 생성하여 작성하는 것이 좋습니다 . 이를 위해서는 소스 코드가 OTP 설계 원칙에 따라 애플리케이션으로 구성되어야합니다. (프로그램은 OTP 응용 프로그램의 관점에서 시작될 필요는 없지만 일반 Erlang 일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="c5fdc6fd4567d3a558e76cbc7f894eaa5a1c1eee" translate="yes" xml:space="preserve">
          <source>A boot script file has the extension &lt;code&gt;.script&lt;/code&gt;. The runtime system uses a binary version of the script. This &lt;strong&gt;binary boot script&lt;/strong&gt; file has the extension &lt;code&gt;.boot&lt;/code&gt;.</source>
          <target state="translated">부팅 스크립트 파일의 확장자는 &lt;code&gt;.script&lt;/code&gt; 입니다. 런타임 시스템은 이진 버전의 스크립트를 사용합니다. 이 &lt;strong&gt;바이너리 부팅 스크립트&lt;/strong&gt; 파일의 확장자는 &lt;code&gt;.boot&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a38a18422668a20d746ea102449e8109a669766e" translate="yes" xml:space="preserve">
          <source>A boot script generated using &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; is already transformed to the binary form.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 를 사용하여 생성 된 부팅 스크립트 는 이미 이진 형식으로 변환되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4418a28f4bc85f1e896a145b5a8fb062a5cafe33" translate="yes" xml:space="preserve">
          <source>A boot script, &lt;code&gt;Name.boot&lt;/code&gt;</source>
          <target state="translated">부팅 스크립트, &lt;code&gt;Name.boot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506ee8bd04d892c57686f10406bfc1fa492da78c" translate="yes" xml:space="preserve">
          <source>A breakpoint can be either &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. Inactive breakpoints are ignored.</source>
          <target state="translated">중단 점은 &lt;strong&gt;active&lt;/strong&gt; 또는 &lt;strong&gt;inactive 일&lt;/strong&gt; 수 있습니다 . 비활성 중단 점은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1dbb3701c56d51053c806657654df88416bde25" translate="yes" xml:space="preserve">
          <source>A breakpoint has the following:</source>
          <target state="translated">중단 점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f64f15640358c275e2397b778cc1de26c7a69372" translate="yes" xml:space="preserve">
          <source>A brief example in C of how to set the console control handler:</source>
          <target state="translated">C에서 콘솔 제어 핸들러를 설정하는 방법에 대한 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="f6e88d46ec95e4e6ad69aee75cf44a13d46cf46a" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message being decoded can also have trailing bytes. If those trailing bytes are important, they can be returned along with the decoded value by compiling the ASN.1 specification with option &lt;code&gt;+undec_rest&lt;/code&gt;. The return value from the decoder is &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; where &lt;code&gt;Rest&lt;/code&gt; is a binary containing the trailing bytes.</source>
          <target state="translated">디코딩중인 메시지를 보유하는 버퍼에도 후행 바이트가있을 수 있습니다. 후행 바이트가 중요한 경우 &lt;code&gt;+undec_rest&lt;/code&gt; 옵션으로 ASN.1 스펙을 컴파일하여 디코딩 된 값과 함께 리턴 될 수 있습니다 . 디코더의 리턴 값은 &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; 입니다. 여기서 &lt;code&gt;Rest&lt;/code&gt; 는 후행 바이트를 포함하는 2 진입니다.</target>
        </trans-unit>
        <trans-unit id="233c3de16098dc52e49751db996b0afab4a44df9" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message, being decoded it can also have some following bytes. Those following bytes can now be returned together with the decoded value. If an ASN.1 specification is compiled with this option, a tuple &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; is returned. &lt;code&gt;Rest&lt;/code&gt; can be a list or a binary. Earlier versions of the compiler ignored those following bytes.</source>
          <target state="translated">메시지를 보유하고 디코딩되는 버퍼는 다음과 같은 바이트를 가질 수 있습니다. 다음 바이트는 이제 디코딩 된 값과 함께 반환 될 수 있습니다. ASN.1 스펙이이 옵션으로 컴파일되면 튜플 &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; 가 리턴됩니다. &lt;code&gt;Rest&lt;/code&gt; 는 목록 또는 이진일 수 있습니다. 이전 버전의 컴파일러는 다음 바이트를 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="1919a9845de02d3849d0b2e74c7851b7ee8c5506" translate="yes" xml:space="preserve">
          <source>A built-in function is called.</source>
          <target state="translated">내장 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="99e307ba4f985ee1b328ac24d026a83d768b7e31" translate="yes" xml:space="preserve">
          <source>A call has been made to another transfer function during chunk sending, that is, before a call to &lt;code&gt;send_chunk_end/1&lt;/code&gt;.</source>
          <target state="translated">청크 전송 중, 즉 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 에 대한 호출 전에 다른 전송 함수에 대한 호출이 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c058e649153aa49de98647d3ad23a2d22b4f3cbb" translate="yes" xml:space="preserve">
          <source>A call is made to &lt;code&gt;send_chunk/2&lt;/code&gt; or &lt;code&gt;send_chunk_end/1&lt;/code&gt; before a call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">호출을하려고했을 &lt;code&gt;send_chunk/2&lt;/code&gt; 또는 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 호출 전에 &lt;code&gt;send_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74dd8fdb8624f61745c3d9662e7a1e10a90a4feb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;ei&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is &lt;code&gt;[7, current release]&lt;/code&gt;. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">&lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; 호출 하면 &lt;code&gt;ei&lt;/code&gt; 라이브러리가 &lt;code&gt;release_number&lt;/code&gt; 릴리스의 호환 모드로 설정됩니다 . &lt;code&gt;release_number&lt;/code&gt; 의 유효 범위 는 &lt;code&gt;[7, current release]&lt;/code&gt; 입니다. 이를 통해 이전 릴리스의 Erlang / OTP 구성 요소와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e817aa48e70b9f9cfae211dd9da7a5a9ccf5b654" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;Erl_Interface&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is [7, current release]. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">&lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; 호출 하면 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리가 &lt;code&gt;release_number&lt;/code&gt; 릴리스의 호환 모드로 설정됩니다 . &lt;code&gt;release_number&lt;/code&gt; 의 유효 범위 는 [7, 현재 릴리스]입니다. 이를 통해 이전 릴리스의 Erlang / OTP 구성 요소와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0712fa3986f50d28ad07c76a65c1ecbb80736c35" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;get_system_memory_data/0&lt;/code&gt; is more costly than a call to &lt;code&gt;get_memory_data/0&lt;/code&gt; as data is collected synchronously when this function is called.</source>
          <target state="translated">를 호출 &lt;code&gt;get_system_memory_data/0&lt;/code&gt; 호출보다 더 비싸다 &lt;code&gt;get_memory_data/0&lt;/code&gt; 이 함수가 호출 될 때 데이터를 동 기적으로 수집된다.</target>
        </trans-unit>
        <trans-unit id="2f677dc037cd69c670e9e88e5bc616a216192d94" translate="yes" xml:space="preserve">
          <source>A call to the call-back function &lt;code&gt;F&lt;/code&gt; will be</source>
          <target state="translated">콜백 함수 &lt;code&gt;F&lt;/code&gt; 에 대한 호출 은</target>
        </trans-unit>
        <trans-unit id="64cfccc0b7ce97122769d167098947b39055c31f" translate="yes" xml:space="preserve">
          <source>A call to validate/2 or validate/3 must provide a well formed parsed XML element &lt;code&gt;#xmlElement{}&lt;/code&gt; and a State, &lt;code&gt;global_state()&lt;/code&gt;, which holds necessary information from an already processed schema. Thus validate enables reuse of the schema information and therefore if one shall validate several times towards the same schema it reduces time consumption.</source>
          <target state="translated">validate / 2 또는 validate / 3에 대한 호출은 올바르게 구성된 구문 분석 된 XML 요소 &lt;code&gt;#xmlElement{}&lt;/code&gt; 및 State, &lt;code&gt;global_state()&lt;/code&gt; 를 제공해야하며, 이미 처리 된 스키마에서 필요한 정보를 보유합니다. 따라서 validate는 스키마 정보의 재사용을 가능하게하므로 동일한 스키마에 대해 여러 번 유효성을 검증해야하는 경우 시간 소비가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4d8d381879044ee596ec7ee05db7b89483e7064a" translate="yes" xml:space="preserve">
          <source>A call-back function for user-controlled formatting. See &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 제어 형식화를위한 콜백 기능. &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df69379f9325d6a9fdffa360b63f0ee0eab09db5" translate="yes" xml:space="preserve">
          <source>A callback function that is called when the scanner has found an unquoted atom. If the function returns &lt;code&gt;true&lt;/code&gt;, the unquoted atom itself becomes the category of the token. If the function returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;atom&lt;/code&gt; becomes the category of the unquoted atom.</source>
          <target state="translated">스캐너가 인용되지 않은 원자를 찾았을 때 호출되는 콜백 함수입니다. 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 인용되지 않은 원자 자체가 토큰의 카테고리가됩니다. 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;atom&lt;/code&gt; 은 인용되지 않은 원자의 범주가됩니다.</target>
        </trans-unit>
        <trans-unit id="d91fce55e4034ef8ef725ab8525f555ff39cf2b9" translate="yes" xml:space="preserve">
          <source>A callback interface on top of Common Test.</source>
          <target state="translated">공통 테스트 위에있는 콜백 인터페이스.</target>
        </trans-unit>
        <trans-unit id="5e9caf8f98e50d5cd26b8f05e66b990f8b3c6d79" translate="yes" xml:space="preserve">
          <source>A callback module can inherit definitions from other callback modules, through the required function &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈은 필수 함수 &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt; 통해 다른 콜백 모듈의 정의를 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb141abb3a89c44d4c462fec76a604e27632ab05" translate="yes" xml:space="preserve">
          <source>A callback module is a functional module, and for code extensions simple code replacement is sufficient.</source>
          <target state="translated">콜백 모듈은 기능적 모듈이며 코드 확장에는 간단한 코드 교체만으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="b46a19092f99a8ba307ae9376469c5315dc6fe6f" translate="yes" xml:space="preserve">
          <source>A callback module to customize the inets HTTP servers behaviour see &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">inets HTTP 서버 동작을 사용자 정의하기위한 콜백 모듈은 &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dc7be0b141d438c4483859c6c7d158a83325e8d" translate="yes" xml:space="preserve">
          <source>A cancelled timetrap is not automatically reactivated after the break, but must be started exlicitly with &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">취소 된 타임 트랩은 중단 후 자동으로 다시 활성화되지 않지만 &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 로 명시 적 으로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80902d7e7f7cef8831c2f630fc53d4cb3659cebe" translate="yes" xml:space="preserve">
          <source>A certificate is similar to a driver's license, or a passport. The holder of the certificate is called the &lt;strong&gt;subject&lt;/strong&gt;. The certificate is signed with the private key of the issuer of the certificate. A chain of trust is built by having the issuer in its turn being certified by another certificate, and so on, until you reach the so called root certificate, which is self-signed, that is, issued by itself.</source>
          <target state="translated">인증서는 운전 면허증 또는 여권과 유사합니다. 인증서 보유자를 &lt;strong&gt;주체&lt;/strong&gt; 라고합니다 . 인증서는 인증서 발행자의 개인 키로 서명됩니다. 신뢰 체인은 자체 서명 된 자체 인증서 즉 자체적으로 발급 한 루트 인증서에 도달 할 때까지 발급자가 다른 인증서로 인증되도록하는 방식으로 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="f2fd43ae2e93cd58a77e25d50c236c265a71aa31" translate="yes" xml:space="preserve">
          <source>A chain of calls is represented by a list of &lt;code&gt;constant()&lt;/code&gt;. The list contains the From vertex of every call and the To vertex of the last call.</source>
          <target state="translated">호출 체인은 &lt;code&gt;constant()&lt;/code&gt; 목록으로 표시됩니다 . 이 목록에는 모든 호출의 시작 정점과 마지막 호출의 종료 정점이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="85a537a33d3a97006da5ac79a03e13d4e08816a8" translate="yes" xml:space="preserve">
          <source>A chain of module calls from &lt;code&gt;toolbar&lt;/code&gt; to &lt;code&gt;debugger&lt;/code&gt;, if there is such a chain, otherwise &lt;code&gt;false&lt;/code&gt;. The chain of calls is represented by a list of modules, &lt;code&gt;toolbar&lt;/code&gt; being the first element and &lt;code&gt;debugger&lt;/code&gt;the last element.</source>
          <target state="translated">그러한 체인이 있으면 &lt;code&gt;toolbar&lt;/code&gt; 에서 &lt;code&gt;debugger&lt;/code&gt; 로 모듈 체인이 호출되고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 호출 체인은 모듈 목록으로 표시되며, &lt;code&gt;toolbar&lt;/code&gt; 는 첫 번째 요소이고 &lt;code&gt;debugger&lt;/code&gt; 는 마지막 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c963de72e2f1d6300c000423f7ebb85156dc2f81" translate="yes" xml:space="preserve">
          <source>A challenge is a 32-bit integer in big-endian order. Below the function &lt;code&gt;gen_challenge()&lt;/code&gt; returns a random 32-bit integer used as a challenge.</source>
          <target state="translated">문제는 빅 엔디안 순서의 32 비트 정수입니다. &lt;code&gt;gen_challenge()&lt;/code&gt; 함수 아래에서 시도로 사용되는 임의의 32 비트 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39b14f10c5b55097c8101f85c3f9aa51d49c3b22" translate="yes" xml:space="preserve">
          <source>A change in time offset can be observed at slightly different points in time by different processes.</source>
          <target state="translated">시간 오프셋의 변화는 프로세스마다 약간 다른 시점에서 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="542fbe84d9ce4598795bc891dcdfd8b000e68f19" translate="yes" xml:space="preserve">
          <source>A character class</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="61e7e6e3a9874a828dada509dcc75ed9b8baa957" translate="yes" xml:space="preserve">
          <source>A character class matches a single character in the subject. In a UTF mode, the character can be more than one data unit long. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is required as a member of the class, ensure that it is not the first character, or escape it with a backslash.</source>
          <target state="translated">캐릭터 클래스는 주제의 단일 문자와 일치합니다. UTF 모드에서 문자는 둘 이상의 데이터 단위 길이 일 수 있습니다. 클래스 정의의 첫 번째 문자가 곡절이 아닌 경우 일치하는 문자는 클래스가 정의한 문자 세트에 있어야합니다.이 경우 주제 문자가 클래스에 의해 정의 된 세트에 없어야합니다. 클래스의 일원으로 곡절이 필요한 경우, 첫 번째 문자가 아닌지 확인하거나 백 슬래시로 이스케이프 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="9c9c4d2679cf888b556f5d6ffced7246bbf40eb2" translate="yes" xml:space="preserve">
          <source>A character preceded by &lt;code&gt;\&lt;/code&gt; loses its special meaning. Note that &lt;code&gt;\&lt;/code&gt; must be written as &lt;code&gt;\\&lt;/code&gt; in a string literal. For example, &quot;\\?*&quot; will match any filename starting with &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; 앞에 오는 문자 는 특별한 의미를 잃습니다. 참고 &lt;code&gt;\&lt;/code&gt; 가 로 작성해야 &lt;code&gt;\\&lt;/code&gt; 문자열 리터럴에. 예를 들어 &quot;\\? *&quot;는 &lt;code&gt;?&lt;/code&gt; 로 시작하는 모든 파일 이름과 일치합니다 . .</target>
        </trans-unit>
        <trans-unit id="142cc4bd716c781df84ea694767d7514165b6796" translate="yes" xml:space="preserve">
          <source>A character with property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;xx&lt;/strong&gt; 속성을 가진 문자&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf738d3d1defd49ac7c9b392cd81c1e47fcf59d0" translate="yes" xml:space="preserve">
          <source>A character without property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;xx&lt;/strong&gt; 속성이없는 문자&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377286b10e032ac7b156b224cfe02d4aa3b5ac8" translate="yes" xml:space="preserve">
          <source>A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and presents a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</source>
          <target state="translated">체크 포인트는 시스템의 일관된 뷰입니다. 체크 포인트는 테이블 세트에서 활성화 될 수 있습니다. 그런 다음이 체크 포인트를 순회 할 수 있으며 테이블이 조작 중이거나 조작 된 경우에도 체크 포인트가 활성화 될 때 존재했던 시스템의 뷰를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="edd44bafd2855e97c83bfe1495556b1997dac899" translate="yes" xml:space="preserve">
          <source>A checkpoint is a transaction consistent state that spans over one or more tables. When a checkpoint is activated, the system remembers the current content of the set of tables. The checkpoint retains a transaction consistent state of the tables, allowing the tables to be read and updated while the checkpoint is active. A checkpoint is typically used to back up tables to external media, but they are also used internally in &lt;code&gt;Mnesia&lt;/code&gt; for other purposes. Each checkpoint is independent and a table can be involved in several checkpoints simultaneously.</source>
          <target state="translated">체크 포인트는 하나 이상의 테이블에 걸쳐있는 트랜잭션 일관성 상태입니다. 체크 포인트가 활성화되면 시스템은 테이블 세트의 현재 컨텐츠를 기억합니다. 검사 점은 테이블의 트랜잭션 일관성 상태를 유지하므로 검사 점이 활성화되어있는 동안 테이블을 읽고 업데이트 할 수 있습니다. 검사 점은 일반적으로 테이블을 외부 미디어에 백업하는 데 사용되지만 다른 목적으로 &lt;code&gt;Mnesia&lt;/code&gt; 에서 내부적으로 사용 되기도 합니다. 각 검사 점은 독립적이며 테이블은 여러 검사 점에 동시에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af90dbef0975afb7b45bd12517b2d0b310aad09" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is activated and the current node is involved in the checkpoint. Checkpoints can be activated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; or implicitly at backup, when adding table replicas, at internal transfer of data between nodes, and so on. By default this event is ignored.</source>
          <target state="translated">이름이 &lt;code&gt;Checkpoint&lt;/code&gt; 인 검사 점이 활성화되고 현재 노드가 검사 점에 포함됩니다. 검사 점은 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명시 적으로 활성화 하거나 테이블 복제본을 추가 할 때, 노드 간 내부 데이터 전송 등에서 백업시 내재적 으로 활성화 할 수 있습니다 . 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce168e38a6f2a63614deb75483a5c4e60dab573e" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is deactivated and the current node is involved in the checkpoint. Checkpoints can be deactivated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; or implicitly when the last replica of a table (involved in the checkpoint) becomes unavailable, for example, at node-down. By default this event is ignored.</source>
          <target state="translated">이름이 &lt;code&gt;Checkpoint&lt;/code&gt; 인 검사 점이 비활성화되고 현재 노드가 검사 점에 포함됩니다. 검사 점은 &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명시 적으로 비활성화 하거나 검사 점에 포함 된 테이블의 마지막 복제본을 노드 다운과 같이 사용할 수 없게 될 때 암시 적으로 비활성화 할 수 있습니다 . 기본적으로이 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="757093a3c3c4440d97791337c35337b6b5b5acf3" translate="yes" xml:space="preserve">
          <source>A child under a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can be terminated with the following:</source>
          <target state="translated">&lt;code&gt;simple_one_for_one&lt;/code&gt; 감독자 아래의 자식 은 다음과 같이 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b7cb7b3462b17e43bbfe35864d2ca8d80d92e7" translate="yes" xml:space="preserve">
          <source>A circumflex can conveniently be used with the uppercase character types to specify a more restricted set of characters than the matching lowercase type. For example, class [^\W_] matches any letter or digit, but not underscore, while [\w] includes underscore. A positive character class is to be read as &quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT something AND NOT ...&quot;.</source>
          <target state="translated">대문자 문자 유형과 함께 곡절 문자를 편리하게 사용하여 일치하는 소문자 유형보다 더 제한된 문자 세트를 지정할 수 있습니다. 예를 들어, 클래스 [^ \ W_]는 밑줄이 아닌 문자 나 숫자와 일치하지만 [\ w]는 밑줄을 포함합니다. 포지티브 문자 클래스는 &quot;무언가 또는 무언가 OR ...&quot;로, 네거티브 클래스는 &quot;무언가가 아닌 NOT NOT&quot;으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0a95d789d7844b6626f4da863b5eea766e7744a0" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;body&lt;/strong&gt; consists of a sequence of expressions separated by comma (,):</source>
          <target state="translated">절 &lt;strong&gt;본문&lt;/strong&gt; 은 쉼표 (,)로 구분 된 일련의 표현식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="19e13c276c19b62374e61b0b7fc25118ed9d5cf8" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;head&lt;/strong&gt; consists of the function name, an argument list, and an optional guard sequence beginning with the keyword &lt;code&gt;when&lt;/code&gt;:</source>
          <target state="translated">절 &lt;strong&gt;헤드&lt;/strong&gt; 는 함수 이름, 인수 목록 및 선택 &lt;code&gt;when&lt;/code&gt; 키워드로 시작하는 선택적 가드 시퀀스로 구성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="58a6114240a04a860a349454adf52142f50d9abd" translate="yes" xml:space="preserve">
          <source>A clause C is one of the following:</source>
          <target state="translated">조항 C는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d1f7a0040d46c009ca43441ed2b3e8cecbe10566" translate="yes" xml:space="preserve">
          <source>A client application that is dependent on the SNMP manager will use this function in order to be notified of when the manager has started. There are two situations when this is useful:</source>
          <target state="translated">SNMP 관리자에 종속 된 클라이언트 응용 프로그램은이 기능을 사용하여 관리자가 시작된시기를 알립니다. 이것이 유용한 두 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b63c3639a0d3be7790653a4cf98a0c37efe2e2" translate="yes" xml:space="preserve">
          <source>A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit. If the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus, the following matches at least three successive vowels, but can match many more:</source>
          <target state="translated">닫는 중괄호 자체는 특별한 특성이 아닙니다. 두 번째 숫자는 생략했지만 쉼표가 있으면 상한이 없습니다. 두 번째 숫자와 쉼표를 모두 생략하면 수량자는 정확한 일치 수를 지정합니다. 따라서 다음은 적어도 세 개의 연속 모음과 일치하지만 더 많이 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df59142009d0a2f0174628ac8c696397e059c32" translate="yes" xml:space="preserve">
          <source>A collection of annotations.</source>
          <target state="translated">주석 모음.</target>
        </trans-unit>
        <trans-unit id="03e8d201bb4d1ea3a3e042cc7f432a7b21d3da31" translate="yes" xml:space="preserve">
          <source>A collection of list processing functions can be found in the &lt;code&gt;lists&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">리스트 처리 함수의 콜렉션은 STDLIB의리 &lt;code&gt;lists&lt;/code&gt; 매뉴얼 페이지에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cdd7d34c0f5f7115114bd571785b83e151e658b" translate="yes" xml:space="preserve">
          <source>A collection of maps processing functions can be found in &lt;code&gt;maps&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">맵 처리 함수의 콜렉션은 STDLIB의 &lt;code&gt;maps&lt;/code&gt; 매뉴얼 페이지에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3e3cce83083c2f4eda9342971b0fd43678fa41c" translate="yes" xml:space="preserve">
          <source>A collection of mathematical functions that return floats. Arguments are numbers.</source>
          <target state="translated">float를 반환하는 수학 함수 모음입니다. 인수는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="605e87ed4414816e773ab8b3750564d7de25784e" translate="yes" xml:space="preserve">
          <source>A collection of open disk logs with the same name running on different nodes is said to be a &lt;strong&gt;distributed disk log&lt;/strong&gt; if requests made to any of the logs are automatically made to the other logs as well. The members of such a collection are called individual distributed disk logs, or just distributed disk logs if there is no risk of confusion. There is no order between the members of such a collection. For example, logged terms are not necessarily written to the node where the request was made before written to the other nodes. However, a few functions do not make requests to all members of distributed disk logs, namely &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 노드에서 실행되는 동일한 이름의 열린 디스크 로그 모음은 로그에 대한 요청이 다른 로그에도 자동으로 수행되는 경우 &lt;strong&gt;분산 디스크&lt;/strong&gt; 로그라고합니다. 이러한 콜렉션의 구성원을 개별 분산 디스크 로그 또는 혼동의 위험이없는 경우 분산 디스크 로그라고합니다. 이러한 컬렉션의 멤버 간에는 주문이 없습니다. 예를 들어, 로그 된 용어는 다른 노드에 쓰기 전에 요청이 작성된 노드에 반드시 쓰여지는 것은 아닙니다. 그러나 일부 함수는 분산 디스크 로그의 모든 멤버 (예 : &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt; )에 요청을하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c28e602c295299b55b61e9e0432393728a24bb97" translate="yes" xml:space="preserve">
          <source>A collection of test cases, generally with a specific, common target for testing, such as a single function, module, or subsystem. A test suite may also be recursively composed by smaller test suites.</source>
          <target state="translated">일반적으로 단일 기능, 모듈 또는 하위 시스템과 같이 테스트를위한 특정 공통 대상이있는 테스트 사례 모음입니다. 테스트 스위트는 소규모 테스트 스위트로 재귀 적으로 구성 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1465092184b8e8294117483f6254c408114fee45" translate="yes" xml:space="preserve">
          <source>A command file for restarting a service looks as follows:</source>
          <target state="translated">서비스를 다시 시작하기위한 명령 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9252c2a7f2a4db9009910e3b44326441724181d8" translate="yes" xml:space="preserve">
          <source>A common interoperability situation is when you want to incorporate a piece of code, solving a complex problem, in your Erlang program. Suppose for example, that you have the following C functions that you would like to call from Erlang:</source>
          <target state="translated">일반적인 상호 운용성 상황은 Erlang 프로그램에서 복잡한 문제를 해결하면서 코드를 통합하려는 경우입니다. 예를 들어 Erlang에서 호출하려는 다음 C 함수가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b06198c1c89c922d52dc5340ce3b2b05bb39280d" translate="yes" xml:space="preserve">
          <source>A common method of identifying encoding in text files is to put a Byte Order Mark (BOM) first in the file. The BOM is the code point 16#FEFF encoded in the same way as the remaining file. If such a file is to be read, the first few bytes (depending on encoding) are not part of the text. This code outlines how to open a file that is believed to have a BOM, and sets the files encoding and position for further sequential reading (preferably using the &lt;code&gt;io&lt;/code&gt; module).</source>
          <target state="translated">텍스트 파일에서 인코딩을 식별하는 일반적인 방법은 파일에서 BOM (Byte Order Mark)을 먼저 두는 것입니다. BOM은 나머지 파일과 같은 방식으로 인코딩 된 코드 포인트 16 # FEFF입니다. 이러한 파일을 읽으려면 인코딩에 따라 처음 몇 바이트가 텍스트의 일부가 아닙니다. 이 코드는 BOM이있는 것으로 여겨지는 파일을 여는 방법을 설명하고 추가 순차 읽기를위한 파일 인코딩 및 위치를 설정합니다 (바람직하게는 &lt;code&gt;io&lt;/code&gt; 모듈 사용).</target>
        </trans-unit>
        <trans-unit id="5647ae6e936ad55169d59c790e8343814c809ae6" translate="yes" xml:space="preserve">
          <source>A common situation in more complex systems is that the data in a table is distributed. Different table rows are implemented in different places. Some SNMP tool-kits dedicate an SNMP sub-agent for each part of the table and load the corresponding MIB into all sub-agents. The Master Agent is responsible for presenting the distributed table as a single table to the manager. The toolkit supplied uses a different method.</source>
          <target state="translated">보다 복잡한 시스템의 일반적인 상황은 테이블의 데이터가 분산되는 것입니다. 다른 테이블 행이 다른 위치에 구현됩니다. 일부 SNMP 툴킷은 테이블의 각 부분에 대한 SNMP 서브 에이전트를 전용하고 해당 MIB를 모든 서브 에이전트에로드합니다. 마스터 에이전트는 분산 테이블을 관리자에게 단일 테이블로 제공합니다. 제공된 툴킷은 다른 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7eeae65f0479a03e33632169a4331231e0f176a" translate="yes" xml:space="preserve">
          <source>A common way to send a zero-terminated string to a port is the following:</source>
          <target state="translated">0으로 끝나는 문자열을 포트로 보내는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a45a7f5aa5a20b6c21f0a78bd8f6845034a8417e" translate="yes" xml:space="preserve">
          <source>A compile-time error, for example a syntax error, does not cause much trouble as it is caught by the compiler.</source>
          <target state="translated">컴파일 타임 오류 (예 : 구문 오류)는 컴파일러에 의해 잡히기 때문에 많은 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4602d9b41e423bca7841f2df941cffa70742972" translate="yes" xml:space="preserve">
          <source>A compiled MIB for SNMP. It generates a &lt;code&gt;.hrl&lt;/code&gt; file.</source>
          <target state="translated">SNMP 용 컴파일 된 MIB &lt;code&gt;.hrl&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f5f98caa0ae9cf0f1bdae4ba51cfa598afa6c9ca" translate="yes" xml:space="preserve">
          <source>A compiled match specification.</source>
          <target state="translated">컴파일 된 일치 사양.</target>
        </trans-unit>
        <trans-unit id="9d939a33ffd17f021de49031e6a1518334f87b64" translate="yes" xml:space="preserve">
          <source>A compiled regular expression</source>
          <target state="translated">컴파일 된 정규식</target>
        </trans-unit>
        <trans-unit id="f8e9759655ec875d9026034a3b0994a59f1ef864" translate="yes" xml:space="preserve">
          <source>A compiled regular expression and the options for running it</source>
          <target state="translated">컴파일 된 정규 표현식 및 실행 옵션</target>
        </trans-unit>
        <trans-unit id="d4c9209a41f5a084f05f289c557f295094459659" translate="yes" xml:space="preserve">
          <source>A completly different storage could be interfaced by writing call-back modules using the behaviours &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. A callback module is installed with the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; to the client and/or the daemon.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 동작을 사용하여 콜백 모듈을 작성하여 완전히 다른 스토리지를 인터페이스 할 수 있습니다 . 콜백 모듈은 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션과 함께 클라이언트 및 / 또는 데몬에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="952ff2aeda160eb34af5c137f617385ffdf99591" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 의 구성 요소 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="246870fe4fc14eed479b16bbb7b62bf284297f4b" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 의 구성 요소는 디렉토리 가 아닙니다. 일부 플랫폼에서는 대신 &lt;code&gt;enoent&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="402962cd392724e5760c55baa6887c10aa95a217" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 의 구성 요소는 디렉토리 가 아닙니다. 일부 플랫폼에서는 &lt;code&gt;enoent&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60b48fcc9f23ddcda04bff0fa0292b7348897642" translate="yes" xml:space="preserve">
          <source>A component of the filename does not exist.</source>
          <target state="translated">파일 이름의 구성 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="135c8c2d97ee75d613c98cc3cf13f66a7bede390" translate="yes" xml:space="preserve">
          <source>A component of the filename is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">파일 이름의 구성 요소가 디렉토리가 아닙니다. 일부 플랫폼에서는 대신 &lt;code&gt;enoent&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="821747f02cfeb9e5714e2b19ea3b50b461a99dfe" translate="yes" xml:space="preserve">
          <source>A compression level can be specified by giving option &lt;code&gt;{compressed, Level}&lt;/code&gt;. &lt;code&gt;Level&lt;/code&gt; is an integer with range 0..9, where:</source>
          <target state="translated">&lt;code&gt;{compressed, Level}&lt;/code&gt; 옵션을 제공하여 압축 레벨을 지정할 수 있습니다 . &lt;code&gt;Level&lt;/code&gt; 은 0..9 범위의 정수입니다. 여기서,</target>
        </trans-unit>
        <trans-unit id="d0e574bf3fa3da4f1323956974511982101a1711" translate="yes" xml:space="preserve">
          <source>A concept of table fragmentation has been introduced to cope with large tables. The idea is to split a table into several manageable fragments. Each fragment is implemented as a first class &lt;code&gt;Mnesia&lt;/code&gt; table and can be replicated, have indexes, and so on, as any other table. But the tables cannot have &lt;code&gt;local_content&lt;/code&gt; or have the &lt;code&gt;snmp&lt;/code&gt; connection activated.</source>
          <target state="translated">큰 테이블에 대처하기 위해 테이블 ​​조각화 개념이 도입되었습니다. 아이디어는 테이블을 여러 개의 관리 가능한 조각으로 나누는 것입니다. 각 조각은 첫 번째 클래스 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 로 구현되며 다른 테이블과 같이 복제하거나 인덱스 등을 가질 수 있습니다. 그러나 테이블에 &lt;code&gt;local_content&lt;/code&gt; 또는 &lt;code&gt;snmp&lt;/code&gt; 연결을 활성화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e49ca9c3184442cd50035d353e0e9f2682e7441b" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint calling &lt;code&gt;c_test:c_break/1&lt;/code&gt; is added at line 6 in module &lt;code&gt;fact&lt;/code&gt;. Each time the breakpoint is reached, the function is called. When &lt;code&gt;N&lt;/code&gt; is equal to 3, the function returns &lt;code&gt;true&lt;/code&gt; and the process stops.</source>
          <target state="translated">&lt;code&gt;c_test:c_break/1&lt;/code&gt; 을 호출하는 조건부 중단 점 은 모듈 &lt;code&gt;fact&lt;/code&gt; 의 6 행에 추가됩니다 . 중단 점에 도달 할 때마다 함수가 호출됩니다. 경우 &lt;code&gt;N&lt;/code&gt; 은 3과 동일하다, 함수 리턴 &lt;code&gt;true&lt;/code&gt; 하고, 처리를 정지한다.</target>
        </trans-unit>
        <trans-unit id="420493b84dd5c17e043c6b4089d0760ab787da6f" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint is created at a certain line in the module, but a process reaching the breakpoint stops only if a specified condition is true.</source>
          <target state="translated">조건부 중단 점은 모듈의 특정 라인에 작성되지만 지정된 조건이 참인 경우에만 중단 점에 도달하는 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f2032c66ce1d764483fb75f184dda9191dfa8a90" translate="yes" xml:space="preserve">
          <source>A configuration example:</source>
          <target state="translated">구성 예 :</target>
        </trans-unit>
        <trans-unit id="fca2493f0bfcfddaa7857841304efa4715628d65" translate="yes" xml:space="preserve">
          <source>A configuration file can contain any number of elements of the type:</source>
          <target state="translated">구성 파일에는 다음과 같은 유형의 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78ca415df4713a5dc750b7b27876e4c151d1fefd" translate="yes" xml:space="preserve">
          <source>A configuration file for using the FTP client to access files on a remote host can look as follows:</source>
          <target state="translated">FTP 클라이언트를 사용하여 원격 호스트의 파일에 액세스하기위한 구성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3a7bd9523a05d54af1d3003cdb3950dec94457" translate="yes" xml:space="preserve">
          <source>A configuration file is created or extended with &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt;. Configuration files are binary files and can therefore only be read and written with functions provided by &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">구성 파일은 &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 작성 또는 확장됩니다 . 구성 파일은 이진 파일이므로 &lt;code&gt;ttb&lt;/code&gt; 에서 제공하는 기능으로 만 읽고 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="671d2cc5723fde16b3b1db23f40f7f8a98edafae" translate="yes" xml:space="preserve">
          <source>A configuration is created in the following way:</source>
          <target state="translated">다음과 같은 방식으로 구성이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c8ccb5edfb531730a93bb64572c6648008c39609" translate="yes" xml:space="preserve">
          <source>A configuration key which exists in a configuration file</source>
          <target state="translated">구성 파일에 존재하는 구성 키</target>
        </trans-unit>
        <trans-unit id="390f275edabaf65d38db27499e0d752ebcf76daa" translate="yes" xml:space="preserve">
          <source>A confirmation that the test has started and information about how many test cases are executed in total.</source>
          <target state="translated">테스트가 시작되었다는 확인 및 총 몇 개의 테스트 사례가 실행되는지에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="16cfc1e11c18feed4f6e01ecf44d3ed97a53d652" translate="yes" xml:space="preserve">
          <source>A confirmation when the test run is complete.</source>
          <target state="translated">테스트 실행이 완료되면 확인.</target>
        </trans-unit>
        <trans-unit id="a8db6e97290afb25f8da08685474a76274ab963c" translate="yes" xml:space="preserve">
          <source>A connected socket (or accepted socket) in &lt;code&gt;command&lt;/code&gt; mode mentioned earlier.</source>
          <target state="translated">앞에서 언급 한 &lt;code&gt;command&lt;/code&gt; 모드 의 연결된 소켓 (또는 수락 된 소켓)</target>
        </trans-unit>
        <trans-unit id="b989a34ee0dda9766c669da2f15eb2969efbeba6" translate="yes" xml:space="preserve">
          <source>A connected socket returned from &lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; inherits the &lt;code&gt;show_econnreset&lt;/code&gt; setting from the listening socket.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; 에서 리턴 된 연결된 소켓 은 청취 소켓에서 &lt;code&gt;show_econnreset&lt;/code&gt; 설정을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="16798b95a6178eace7c7e27d49d5ae81b52eea7c" translate="yes" xml:space="preserve">
          <source>A connecting transport is attempting to establish/reestablish a transport connection with a peer following &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry.</source>
          <target state="translated">연결 전송이 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 만료 후 피어와 전송 연결을 설정 / 재설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2de4335ce6ca183161a25e425035c54728e74d6f" translate="yes" xml:space="preserve">
          <source>A connection can be associated with a target name and/or a handle. If &lt;code&gt;Connection&lt;/code&gt; has no associated target name, it can only be closed with the handle value (see &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">연결은 대상 이름 및 / 또는 핸들과 연관 될 수 있습니다. &lt;code&gt;Connection&lt;/code&gt; 에 연관된 대상 이름이없는 경우 핸들 값으로 만 닫을 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="84ef649954a73cf1383ab5bc1d54652a8c9eadd0" translate="yes" xml:space="preserve">
          <source>A connection is closed by simply closing the socket. For information about how to close the socket gracefully (when there are outgoing packets before close), see the relevant system documentation.</source>
          <target state="translated">소켓을 간단히 닫으면 연결이 종료됩니다. 소켓을 정상적으로 닫는 방법 (닫기 전에 나가는 패킷이있는 경우)에 대한 내용은 관련 시스템 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17e6c50bbb1f711f9fede53cf0df05d82936b396" translate="yes" xml:space="preserve">
          <source>A connection may be established in several ways:</source>
          <target state="translated">여러 가지 방법으로 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a37d94bb6ad00988b64d647642ebc7cb8c0abb3c" translate="yes" xml:space="preserve">
          <source>A connection to the node is already active, which either means that node &lt;code&gt;A&lt;/code&gt; is confused or that the TCP connection breakdown of a previous node with this name has not yet reached node &lt;code&gt;B&lt;/code&gt;. See step 3B below.</source>
          <target state="translated">노드에 대한 연결이 이미 활성화되어 있습니다. 이는 노드 &lt;code&gt;A&lt;/code&gt; 가 혼동되었거나이 이름을 가진 이전 노드의 TCP 연결이 아직 노드 &lt;code&gt;B&lt;/code&gt; 에 도달하지 않았 음을 의미합니다 . 아래의 3B 단계를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7ac923ae2612ff651e35e68a8cf52b6bfffc763" translate="yes" xml:space="preserve">
          <source>A consequence of the rules for importing variables into a list comprehensions is that certain pattern matching operations must be moved into the filters and cannot be written directly in the generators.</source>
          <target state="translated">변수를 목록으로 가져 오는 규칙의 결과로 특정 패턴 일치 작업을 필터로 이동해야하며 생성기에 직접 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="13bd8527f949ed0966879c517d0b7fc761771b34" translate="yes" xml:space="preserve">
          <source>A constant value &lt;code&gt;H&lt;/code&gt; for the topmost &lt;code&gt;32-N&lt;/code&gt; bits of of 32-bit End-to-End and Hop-by-Hop Identifiers generated by the service, either explicitly or as a return value of a function to be evaluated at &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. In particular, an identifier &lt;code&gt;Id&lt;/code&gt; is mapped to a new identifier as follows.</source>
          <target state="translated">상수 값 &lt;code&gt;H&lt;/code&gt; 최상위에 대한 &lt;code&gt;32-N&lt;/code&gt; 의 32 비트의 엔드 - 엔드 및 홉별 명시 적으로 또는 함수의 리턴 값으로서, 서비스에 의해 생성 된 식별자의 비트에 평가 될 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; . 특히, 식별자 &lt;code&gt;Id&lt;/code&gt; 는 다음과 같이 새로운 식별자에 매핑된다.</target>
        </trans-unit>
        <trans-unit id="18d886af02e0496aa48e2b5d6a6f92d0202ac37e" translate="yes" xml:space="preserve">
          <source>A container for incoming and outgoing Diameter messages. Fields have the following types.</source>
          <target state="translated">들어오고 나가는 Diameter 메시지를위한 컨테이너입니다. 필드는 다음과 같은 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1dd9fe6f6d7543e1cad9aacae9f7f895fe2c259" translate="yes" xml:space="preserve">
          <source>A context is a collection of management information accessible by an SNMP entity. An instance of a management object may exist in more than one context. An SNMP entity potentially has access to many contexts.</source>
          <target state="translated">컨텍스트는 SNMP 엔티티가 액세스 할 수있는 관리 정보의 모음입니다. 관리 개체의 인스턴스는 둘 이상의 컨텍스트에 존재할 수 있습니다. SNMP 엔티티는 많은 컨텍스트에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="734dc478d1f1465863bbde8232d6c6d77c880f57" translate="yes" xml:space="preserve">
          <source>A continuation as returned by &lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt; 에서 반환 된 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="e6381830ad9a3607ffa3055f5bcf56d4da1d20cb" translate="yes" xml:space="preserve">
          <source>A convenient way to specify arguments to Erlang is to use environment variable &lt;code&gt;ERL_FLAGS&lt;/code&gt;. All the flags needed to use the SSL/TLS distribution can be specified in that variable and are then interpreted as command-line arguments for all subsequent invocations of Erlang.</source>
          <target state="translated">Erlang에 인수를 지정하는 편리한 방법은 환경 변수 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 를 사용하는 것 입니다. SSL / TLS 분배를 사용하는 데 필요한 모든 플래그를 해당 변수에 지정할 수 있으며 이후 Erlang의 모든 후속 호출에 대한 명령 행 인수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca49f6e451d0d84b06716dddb10383b5981e929" translate="yes" xml:space="preserve">
          <source>A correctly encoded map cannot have duplicate keys.</source>
          <target state="translated">올바르게 인코딩 된 맵은 중복 키를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d121637a1d8220cf7197c40025c0f7398d773f8f" translate="yes" xml:space="preserve">
          <source>A cross configuration file can be passed to &lt;code&gt;otp_build configure&lt;/code&gt; using the &lt;code&gt;--xcomp-conf&lt;/code&gt; command line argument. Note that &lt;code&gt;configure&lt;/code&gt; does not accept this command line argument. When using the &lt;code&gt;configure&lt;/code&gt; script directly, pass the configuration variables as arguments to &lt;code&gt;configure&lt;/code&gt; using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax. Variables can also be passed as environment variables to &lt;code&gt;configure&lt;/code&gt;. However, if you pass the configuration in the environment, make sure to unset all of these environment variables before invoking &lt;code&gt;make&lt;/code&gt;; otherwise, the environment variables might set make variables in some applications, or parts of some applications, and you may end up with an erroneously configured build.</source>
          <target state="translated">&lt;code&gt;--xcomp-conf&lt;/code&gt; 명령 줄 인수를 사용하여 교차 구성 파일을 &lt;code&gt;otp_build configure&lt;/code&gt; 로 전달할 수 있습니다 . 참고 &lt;code&gt;configure&lt;/code&gt; 이 명령 줄 인수를 허용하지 않습니다. &lt;code&gt;configure&lt;/code&gt; 스크립트를 직접 사용하는 경우 구성 변수를 인수로 전달 하여 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 구문을 사용하여 &lt;code&gt;configure&lt;/code&gt; . 변수를 &lt;code&gt;configure&lt;/code&gt; 할 환경 변수로 전달할 수도 있습니다 . 당신은 환경의 구성을 전달할 경우, 호출하기 전에이 모든 환경 변수를 설정 해제해야합니다 &lt;code&gt;make&lt;/code&gt; ; 그렇지 않으면 환경 변수가 일부 응용 프로그램 또는 일부 응용 프로그램에서 변수를 만들 수 있으며 잘못 구성된 빌드로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1583ce679c6d2d53d418e62301c75ea7be08c45" translate="yes" xml:space="preserve">
          <source>A current restriction, which currently results in a warning (not an error) by the compiler, is that the domains of the argument types cannot overlap. For example, the following specification results in a warning:</source>
          <target state="translated">현재 컴파일러에서 경고 (오류가 아님)를 발생시키는 현재 제한 사항은 인수 유형의 도메인이 겹칠 수 없다는 것입니다. 예를 들어, 다음 사양은 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="88d09c4bad655176f525dc30f98c229dc5d52beb" translate="yes" xml:space="preserve">
          <source>A customized prompt function is stated as a tuple &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt;. The function is called as &lt;code&gt;Mod:Func(L)&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is a list of key-value pairs created by the shell. Currently there is only one pair: &lt;code&gt;{history, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the current command number. The function is to return a list of characters or an atom. This constraint is because of the Erlang I/O protocol. Unicode characters beyond code point 255 are allowed in the list and the atom. Notice that in restricted mode the call &lt;code&gt;Mod:Func(L)&lt;/code&gt; must be allowed or the default shell prompt function is called.</source>
          <target state="translated">사용자 정의 프롬프트 기능은 튜플 &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt; 됩니다. 이 함수는 &lt;code&gt;Mod:Func(L)&lt;/code&gt; 로 불립니다 . 여기서 &lt;code&gt;L&lt;/code&gt; 은 셸에서 만든 키-값 쌍의 목록입니다. 현재 &lt;code&gt;{history, N}&lt;/code&gt; 한 쌍만 있습니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 현재 명령 번호입니다. 이 기능은 문자 또는 원자 목록을 반환하는 것입니다. 이 제약 조건은 Erlang I / O 프로토콜 때문입니다. 코드 포인트 255를 초과하는 유니 코드 문자는 목록과 원자에서 허용됩니다. 제한 모드에서는 &lt;code&gt;Mod:Func(L)&lt;/code&gt; 호출 이 허용되거나 기본 쉘 프롬프트 기능이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8c9abdbda17aa95d8e0108392fe6c0db5b6c523d" translate="yes" xml:space="preserve">
          <source>A database schema must be initiated, using the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 데이터베이스 스키마를 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="49e3317b1ebd7518e2b7a6cb468c8efab693a0e3" translate="yes" xml:space="preserve">
          <source>A decimal integer is expected.</source>
          <target state="translated">십진 정수가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c1c59bae41554e9820138c5a12e4fa4d04d13249" translate="yes" xml:space="preserve">
          <source>A default set of socket &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; is used. In particular, the socket is opened in &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode, with SockType &lt;code&gt;seqpacket&lt;/code&gt;, and with reasonably large &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; and driver &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 소켓 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; 세트 가 사용됩니다. 특히, 소켓은 SockType &lt;code&gt;seqpacket&lt;/code&gt; 및 상당히 큰 &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; 및 드라이버 &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt; 하여 &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; 모드로 열립니다 .</target>
        </trans-unit>
        <trans-unit id="0a0192ce6ab3cadd73202466e0233a173404e218" translate="yes" xml:space="preserve">
          <source>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this definition. With the MIB-compiler option &lt;code&gt;{deprecated,true}&lt;/code&gt; the MIB-compiler does not ignore the deprecated definitions.</source>
          <target state="translated">정의에는 일반적으로 상태 필드가 있습니다. 상태 필드의 값이 더 이상 사용되지 않으면 MIB 컴파일러는이 정의를 무시합니다. MIB 컴파일러 옵션 &lt;code&gt;{deprecated,true}&lt;/code&gt; 를 사용 하면 MIB 컴파일러는 더 이상 사용되지 않는 정의를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08538f938c9e3f97e154e5c1ebc56ab69364db2a" translate="yes" xml:space="preserve">
          <source>A department is managed by an employee, hence the &lt;code&gt;manager&lt;/code&gt; relationship.</source>
          <target state="translated">부서는 직원이 관리하므로 &lt;code&gt;manager&lt;/code&gt; 관계입니다.</target>
        </trans-unit>
        <trans-unit id="534a5700b1818fc0d3d69084b7c41aaeecf9a10e" translate="yes" xml:space="preserve">
          <source>A destroyed key is very likely to be reused soon. Therefore, if you fail to clear the thread-specific data using this key in a thread before destroying the key, you will &lt;strong&gt;very likely&lt;/strong&gt; get unexpected errors in other parts of the system.</source>
          <target state="translated">파괴 된 키는 곧 재사용 될 가능성이 높습니다. 따라서 키를 삭제하기 전에 스레드에서이 키를 사용하여 스레드 특정 데이터를 지우지 않으면 시스템의 다른 부분에서 예기치 않은 오류가 발생할 &lt;strong&gt;가능성이 큽니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6c06f3920fbc20d8a33902857e2e1dbbe9185ab8" translate="yes" xml:space="preserve">
          <source>A diameter service, as configured with &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, specifies one or more supported Diameter applications. Each Diameter application specifies a dictionary module that knows how to encode and decode its messages and AVPs. The dictionary module is in turn generated from a file that defines these messages and AVPs. The format of such a file is defined in &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; below. Users add support for their specific applications by creating dictionary files, compiling them to Erlang modules using either &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; and configuring the resulting dictionaries modules on a service.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 로 구성된 Diameter 서비스는 하나 이상의 지원되는 Diameter 응용 프로그램을 지정합니다. 각 Diameter 응용 프로그램은 메시지와 AVP를 인코딩하고 디코딩하는 방법을 알고있는 사전 모듈을 지정합니다. 사전 모듈은 이러한 메시지와 AVP를 정의하는 파일에서 생성됩니다. 이러한 파일의 형식은 아래의 &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. 사용자는 사전 파일을 작성하고 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; 사용하여 Erlang 모듈로 컴파일하고 서비스에서 결과 사전 모듈을 구성하여 특정 애플리케이션에 대한 지원을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="7a9137875cffe6b05cd927e970323d3a0b3eea26" translate="yes" xml:space="preserve">
          <source>A dictionary file consists of distinct sections. Each section starts with a tag followed by zero or more arguments and ends at the the start of the next section or end of file. Tags consist of an ampersand character followed by a keyword and are separated from their arguments by whitespace. Whitespace separates individual tokens but is otherwise insignificant.</source>
          <target state="translated">사전 파일은 개별 섹션으로 구성됩니다. 각 섹션은 태그로 시작하고 그 뒤에 0 개 이상의 인수가 오며 다음 섹션의 시작 또는 파일 끝에서 끝납니다. 태그는 앰퍼샌드 문자와 키워드로 구성되며 인수와 공백으로 구분됩니다. 공백은 개별 토큰을 분리하지만 그렇지 않으면 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e33a8495150bb32e7f8b820523060366bf248c7" translate="yes" xml:space="preserve">
          <source>A difference is how messages are sent to a registered process on another node:</source>
          <target state="translated">차이점은 메시지가 다른 노드에서 등록 된 프로세스로 전송되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="94b01ef26ce08428a3ba5531da74cc6167159294" translate="yes" xml:space="preserve">
          <source>A digest is a (16 bytes) MD5 hash of the challenge (as text) concatenated with the cookie (as text). Below, the function &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; generates a digest as described above.</source>
          <target state="translated">다이제스트는 쿠키 (텍스트)와 연결된 챌린지 (텍스트)의 (16 바이트) MD5 해시입니다. 아래에서 &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; 함수 는 위에서 설명한대로 다이제스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="97a4d843c861dcb7b6c4243c19ad5c6f32cf1f75" translate="yes" xml:space="preserve">
          <source>A digraph as returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 의해 반환 같이 소리를 나타내는 두 글자 &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92134ca8f685d563f60794a6f2cd96898218a3f1" translate="yes" xml:space="preserve">
          <source>A direct one-to-one mapping can be established between Mnesia tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between Mnesia and SNMP makes it simple and convenient to achieve this mapping.</source>
          <target state="translated">Mnesia 테이블과 SNMP 테이블간에 직접 일대일 매핑을 설정할 수 있습니다. 많은 통신 응용 프로그램은 SNMP 프로토콜에 의해 제어 및 모니터링됩니다. Mnesia와 SNMP 간의 이러한 연결로이 매핑을 간단하고 편리하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a14fb204056be345e895dd5aa7d44f25878907a" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; is created, where the &lt;code&gt;.rel&lt;/code&gt; file, the boot script &lt;code&gt;start.boot&lt;/code&gt;, the system configuration file &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt; are placed. For applications with new version numbers, the application directories are placed under &lt;code&gt;$ROOT/lib&lt;/code&gt;. Unchanged applications are not affected.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 파일, 부팅 스크립트 &lt;code&gt;start.boot&lt;/code&gt; , 시스템 구성 파일 &lt;code&gt;sys.config&lt;/code&gt; 및 &lt;code&gt;relup&lt;/code&gt; 이있는 &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; 디렉토리 가 작성 됩니다. 새 버전 번호가있는 응용 프로그램의 경우 응용 프로그램 디렉토리는 &lt;code&gt;$ROOT/lib&lt;/code&gt; 아래에 있습니다. 변경되지 않은 응용 프로그램은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6621117e99280c08a6a5c251265a94569f71ef2" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;releases&lt;/code&gt; is also included in the release package, containing &lt;code&gt;Name.rel&lt;/code&gt; and a subdirectory &lt;code&gt;RelVsn&lt;/code&gt;. &lt;code&gt;RelVsn&lt;/code&gt; is the release version as specified in &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name.rel&lt;/code&gt; 및 하위 디렉토리 &lt;code&gt;RelVsn&lt;/code&gt; 을 포함 하는 디렉토리 &lt;code&gt;releases&lt;/code&gt; 도 릴리스 패키지에 포함 되어 있습니다. &lt;code&gt;RelVsn&lt;/code&gt; 는 로 지정된 릴리스 버전입니다 &lt;code&gt;Name.rel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4500d0e224c17fb948b0cb9c7625fe0de15c6f3" translate="yes" xml:space="preserve">
          <source>A directory containing one or more test suite modules, that is, a group of test suites.</source>
          <target state="translated">하나 이상의 테스트 스위트 모듈, 즉 테스트 스위트 그룹을 포함하는 디렉토리.</target>
        </trans-unit>
        <trans-unit id="e1df29d5aaa8b080fbaa691c505a19d49ce3028b" translate="yes" xml:space="preserve">
          <source>A dirty CPU scheduler thread.</source>
          <target state="translated">더티 CPU 스케줄러 스레드</target>
        </trans-unit>
        <trans-unit id="ac9d98b43f6ed325d229760f35e5424d98091c99" translate="yes" xml:space="preserve">
          <source>A dirty I/O scheduler thread.</source>
          <target state="translated">더티 I / O 스케줄러 스레드</target>
        </trans-unit>
        <trans-unit id="bf9457e20d0f94d641c3b38efb00a54afdb0494c" translate="yes" xml:space="preserve">
          <source>A dirty operation ensures a certain level of consistency. For example, dirty operations cannot return garbled records. Hence, each individual read or write operation is performed in an atomic manner.</source>
          <target state="translated">더러운 작업은 일정한 수준의 일관성을 보장합니다. 예를 들어, 더티 조작은 잘못된 레코드를 리턴 할 수 없습니다. 따라서, 각각의 개별적인 판독 또는 기록 동작은 원자적인 방식으로 수행된다.</target>
        </trans-unit>
        <trans-unit id="7ebf083e79a4bab181933e594cee2d9370b9ab7c" translate="yes" xml:space="preserve">
          <source>A disk-based term logging facility.</source>
          <target state="translated">디스크 기반 용어 로깅 기능.</target>
        </trans-unit>
        <trans-unit id="0d96f2972ef274a3b4c3377bf6357c2926605d52" translate="yes" xml:space="preserve">
          <source>A disk-based term storage.</source>
          <target state="translated">디스크 기반 용어 저장소</target>
        </trans-unit>
        <trans-unit id="47c69df1e3667dcfedb432994923493351c17966" translate="yes" xml:space="preserve">
          <source>A disk_log based handler for Logger</source>
          <target state="translated">로거에 대한 disk_log 기반 핸들러</target>
        </trans-unit>
        <trans-unit id="d5a1bc14ede3681f787b432535890d0cd273d420" translate="yes" xml:space="preserve">
          <source>A distributed telecommunications DBMS</source>
          <target state="translated">분산 통신 DBMS</target>
        </trans-unit>
        <trans-unit id="ce830ece0130879215c67d6a63d5c97d8a7c48e3" translate="yes" xml:space="preserve">
          <source>A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option &lt;code&gt;multiline&lt;/code&gt; is specified. There is no equivalent option in Perl, and it cannot be set within a pattern.</source>
          <target state="translated">패턴의 달러 메타 문자는 제목 문자열의 끝에서만 일치합니다. 이 옵션을 사용하지 않으면 달러는 문자열의 끝에서 개행 직전에 일치하지만 다른 개행 앞에는 일치하지 않습니다. 옵션의 경우이 옵션은 무시됩니다 &lt;code&gt;multiline&lt;/code&gt; 지정됩니다. Perl에는 동등한 옵션이 없으며 패턴 내에서 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ade8b69a85608bc000b53cc0bb10d32bd6f4e1e4" translate="yes" xml:space="preserve">
          <source>A domain field must be a list of atoms, creating smaller and more specialized domains as the list grows longer. The greatest domain is &lt;code&gt;[]&lt;/code&gt;, which comprises all possible domains.</source>
          <target state="translated">도메인 필드는 원자 목록이어야하며 목록이 길어질수록 작고 전문화 된 도메인을 만들어야합니다. 가장 큰 도메인은 &lt;code&gt;[]&lt;/code&gt; 이며 가능한 모든 도메인을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3633cdcde13dc5b95a07d9cdccf61ad19b7292b3" translate="yes" xml:space="preserve">
          <source>A door with a code lock can be seen as a state machine. Initially, the door is locked. When someone presses a button, an event is generated. The pressed buttons are collected, up to the number of buttons in the correct code. If correct, the door is unlocked for 10 seconds. If not correct, we wait for a new button to be pressed.</source>
          <target state="translated">코드 잠금 장치가있는 문은 상태 머신으로 볼 수 있습니다. 처음에는 문이 잠겨 있습니다. 누군가 버튼을 누르면 이벤트가 생성됩니다. 누른 버튼은 올바른 코드의 버튼 수까지 수집됩니다. 올바른 경우 도어가 10 초 동안 잠금 해제됩니다. 정확하지 않은 경우 새 버튼을 누를 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9d2a5945a95873dd7f235759b1053935e86a971f" translate="yes" xml:space="preserve">
          <source>A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option &lt;code&gt;/s&lt;/code&gt; and it can be changed within a pattern by a &lt;code&gt;(?s)&lt;/code&gt; option setting. A negative class, such as &lt;code&gt;[^a]&lt;/code&gt;, always matches newline characters, independent of the setting of this option.</source>
          <target state="translated">패턴의 점은 개행을 나타내는 문자를 포함하여 모든 문자와 일치합니다. 그렇지 않으면 현재 위치가 줄 바꿈에있을 때 점이 일치하지 않습니다. 이 옵션은 Perl 옵션 &lt;code&gt;/s&lt;/code&gt; 와 동일 하며 &lt;code&gt;(?s)&lt;/code&gt; 옵션 설정 으로 패턴 내에서 변경할 수 있습니다 . &lt;code&gt;[^a]&lt;/code&gt; 와 같은 음수 클래스 는이 옵션의 설정에 관계없이 항상 줄 바꿈 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="885bb765c3b45bdf4bc945235d9e2dd16052f6ab" translate="yes" xml:space="preserve">
          <source>A drawback of simple test functions is that you must write a separate function (with a separate name) for each test case. A more compact way of writing tests (and much more flexible, as we shall see), is to write functions that &lt;strong&gt;return&lt;/strong&gt; tests, instead of &lt;strong&gt;being&lt;/strong&gt; tests.</source>
          <target state="translated">간단한 테스트 함수의 단점은 각 테스트 케이스에 대해 별도의 이름으로 별도의 함수를 작성해야한다는 것입니다. (우리가 살펴 보 겠지만, 그리고 훨씬 더 유연) 테스트를 작성하는 컴팩트 방법은 함수를 작성하는 것입니다 &lt;strong&gt;반환&lt;/strong&gt; 대신에 시험 &lt;strong&gt;되는&lt;/strong&gt; 시험.</target>
        </trans-unit>
        <trans-unit id="b000c1146f0c1ed1dc5a3aabc97ba084c853c614" translate="yes" xml:space="preserve">
          <source>A drawback with implementing an SNMP table as a Mnesia table is that the internal resource is forced to use the table definition from the MIB, which means that the external data model must be used internally. Actually, this is only partially true. The Mnesia table may extend the SNMP table, which means that the Mnesia table may have columns which are use internally and are not seen by SNMP. Still, the data model from SNMP must be maintained. Although this is undesirable, it is a pragmatic compromise in many situations where simple and efficient implementation is preferable to abstraction.</source>
          <target state="translated">SNMP 테이블을 Mnesia 테이블로 구현할 때의 단점은 내부 자원이 MIB에서 테이블 정의를 사용해야한다는 것입니다. 즉, 외부 데이터 모델을 내부적으로 사용해야합니다. 실제로 이것은 부분적으로 만 사실입니다. Mnesia 테이블은 SNMP 테이블을 확장 할 수 있습니다. 이는 Mnesia 테이블에 내부적으로 사용되고 SNMP에서 보이지 않는 열이있을 수 있음을 의미합니다. 여전히 SNMP의 데이터 모델을 유지해야합니다. 이것은 바람직하지 않지만, 단순하고 효율적인 구현이 추상화보다 선호되는 많은 상황에서 실질적인 타협입니다.</target>
        </trans-unit>
        <trans-unit id="dc70d1fd3885c3da6699390fff4e736e7393cca0" translate="yes" xml:space="preserve">
          <source>A driver binary allocated in the driver, with &lt;code&gt;driver_alloc_binary&lt;/code&gt;, is to be freed in the driver (unless otherwise stated) with &lt;code&gt;driver_free_binary&lt;/code&gt;. (Notice that this does not necessarily deallocate it, if the driver is still referred in the emulator, the ref-count will not go to zero.)</source>
          <target state="translated">&lt;code&gt;driver_alloc_binary&lt;/code&gt; 와 함께 드라이버에 할당 된 드라이버 바이너리 는 &lt;code&gt;driver_free_binary&lt;/code&gt; 와 함께 드라이버에서 해제됩니다 (달리 명시되지 않는 한) . (드라이버가 여전히 에뮬레이터에서 참조되는 경우 참조 카운트가 0이되지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="54bf6555831bbcbb33a1143a231274fb8310abec" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">돌아 오기 전에 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 수행하는 드라이버 콜백 은 VM의 응답 성을 저하시키고 기타 이상한 동작을 일으킬 수 있습니다. 이러한 이상한 동작에는 과도한 메모리 사용 및 스케줄러 간의 잘못된로드 밸런싱이 포함되지만 이에 국한되지는 않습니다. 긴 작업으로 인해 발생할 수있는 이상한 동작도 Erlang / OTP 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a40326bca24e22884109edb9057e64a36e9d19f" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">돌아 오기 전에 &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 수행하는 드라이버 콜백 은 VM의 응답 성을 저하시키고 기타 이상한 동작을 유발할 수 있습니다. 이러한 이상한 동작에는 과도한 메모리 사용 및 스케줄러 간의 잘못된로드 밸런싱이 포함되지만 이에 국한되지는 않습니다. 긴 작업으로 인해 발생할 수있는 이상한 동작도 Erlang / OTP 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5eb508da3e1d5ef4a4f999ab3b5ee6a71a758f" translate="yes" xml:space="preserve">
          <source>A driver callback is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the driver callback function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">드라이버 콜백은 VM의 기본 코드를 직접 확장하여 실행됩니다. 안전한 환경에서 실행되지 않습니다. 선점 예약 또는 메모리 보호와 같이 Erlang 코드를 실행할 때 VM에서 제공 한 것과 동일한 서비스를 제공 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; . 드라이버 콜백 함수가 제대로 작동하지 않으면 전체 VM이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5fe6680281eb2602c7b531134d6486d21c3966d" translate="yes" xml:space="preserve">
          <source>A driver callback that crash will crash the whole VM.</source>
          <target state="translated">충돌이 발생한 드라이버 콜백은 전체 VM을 충돌시킵니다.</target>
        </trans-unit>
        <trans-unit id="35f6d76692e5c5a3a8bc9ae237376468c696b57c" translate="yes" xml:space="preserve">
          <source>A driver can add and later remove drivers.</source>
          <target state="translated">드라이버는 드라이버를 추가하고 나중에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db720ccab1ee2294dd6583e58238e6ff531fde9" translate="yes" xml:space="preserve">
          <source>A driver can be configured to have one lock for each port instead.</source>
          <target state="translated">대신 각 포트마다 하나의 잠금을 갖도록 드라이버를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea8de0f635aa82b9e3262bc25c0681bf5ef9e25f" translate="yes" xml:space="preserve">
          <source>A driver can be dynamically loaded, as a shared library (known as a DLL on Windows), or statically loaded, linked with the emulator when it is compiled and linked. Only dynamically loaded drivers are described here, statically linked drivers are beyond the scope of this section.</source>
          <target state="translated">드라이버는 공유 라이브러리 (Windows에서는 DLL이라고 함)로 동적으로로드되거나 컴파일 및 링크 될 때 에뮬레이터와 링크되어 정적으로로드 될 수 있습니다. 여기에는 동적으로로드 된 드라이버 만 설명되어 있으며 정적으로 링크 된 드라이버는이 섹션에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a7bb769b863c9b98696f02891a10946d65061a" translate="yes" xml:space="preserve">
          <source>A driver can monitor a process that does not own a port.</source>
          <target state="translated">드라이버는 포트를 소유하지 않은 프로세스를 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c998e9cdc2a7831f2ce7666b5692240829ea93b5" translate="yes" xml:space="preserve">
          <source>A driver in Erlang is a library written in C, which is linked to the Erlang emulator and called from Erlang. Drivers can be used when C is more suitable than Erlang, to speed up things, or to provide access to OS resources not directly accessible from Erlang.</source>
          <target state="translated">Erlang의 드라이버는 C로 작성된 라이브러리이며, Erlang 에뮬레이터에 연결되고 Erlang에서 호출됩니다. C가 Erlang보다 적합한 경우 드라이버를 사용하여 속도를 높이거나 Erlang에서 직접 액세스 할 수없는 OS 리소스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="485795b556efcb079ba1f2cce0c02a2d6a8f0346" translate="yes" xml:space="preserve">
          <source>A driver monitor for unload eventually results in one of the following messages being sent:</source>
          <target state="translated">언로드에 대한 드라이버 모니터는 결국 다음 메시지 중 하나가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="776db06c979c20584411a6ff4cdf277b51cad201" translate="yes" xml:space="preserve">
          <source>A drop-down box in the toolbar contains the command history. Selecting a command in the drop-down box inserts the command at the prompt, as if you used the keyboard to retrieve the command.</source>
          <target state="translated">도구 모음의 드롭 다운 상자에는 명령 기록이 포함되어 있습니다. 드롭 다운 상자에서 명령을 선택하면 키보드를 사용하여 명령을 검색 한 것처럼 프롬프트에 명령이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="6861853bee0f535fea0e16450c99ed3515493ce2" translate="yes" xml:space="preserve">
          <source>A failed user authentication.</source>
          <target state="translated">사용자 인증에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="9db63409ec19fe48d435b1817d57ade59ec9240c" translate="yes" xml:space="preserve">
          <source>A fallback is typically used when a system upgrade is performed. A system typically involves the installation of new software versions, and &lt;code&gt;Mnesia&lt;/code&gt; tables are often transformed into new layouts. If the system crashes during an upgrade, it is highly probable that reinstallation of the old applications is required, and restoration of the database to its previous state. This can be done if a backup is performed and installed as a fallback before the system upgrade begins.</source>
          <target state="translated">대체는 일반적으로 시스템 업그레이드가 수행 될 때 사용됩니다. 시스템은 일반적으로 새로운 소프트웨어 버전의 설치를 포함하며 &lt;code&gt;Mnesia&lt;/code&gt; 테이블은 종종 새로운 레이아웃으로 변환됩니다. 업그레이드 중에 시스템이 충돌하면 이전 응용 프로그램을 다시 설치하고 데이터베이스를 이전 상태로 복원해야 할 가능성이 높습니다. 시스템 업그레이드가 시작되기 전에 백업이 수행되고 폴백으로 설치된 경우 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="318a05f034b1325fb1731c6625436c4ea96c2dba" translate="yes" xml:space="preserve">
          <source>A family of options that selectively turn on/off warnings. (For help on the names of warnings, use &lt;code&gt;dialyzer -Whelp&lt;/code&gt;.) Notice that the options can also be specified in the file with a &lt;code&gt;-dialyzer()&lt;/code&gt; attribute. For details, see section &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고를 선택적으로 켜거나 끄는 옵션 모음. 경고 이름에 대한 도움말을 &lt;code&gt;dialyzer -Whelp&lt;/code&gt; 사용 하십시오 . &lt;code&gt;-dialyzer()&lt;/code&gt; 속성 을 사용하여 파일에서 옵션을 지정할 수도 있습니다 . 자세한 내용 &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f11118ca381dffc41f3188bffb0c43a4c650f1ba" translate="yes" xml:space="preserve">
          <source>A fast allocator used for some frequently used fixed size data types.</source>
          <target state="translated">자주 사용되는 고정 크기 데이터 유형에 사용되는 빠른 할당 자입니다.</target>
        </trans-unit>
        <trans-unit id="3744509be8dd70aa593f301a9795a7c56c7a0de4" translate="yes" xml:space="preserve">
          <source>A faulty linked-in driver causes the entire Erlang runtime system to leak memory, hang, or crash.</source>
          <target state="translated">링크 된 드라이버에 결함이 있으면 전체 Erlang 런타임 시스템이 메모리 누수, 정지 또는 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="89cefbb8feb5d084db82b500bebe6a7d1dfbb558" translate="yes" xml:space="preserve">
          <source>A few applications, such as HiPE, do not support upgrade. This is indicated by an application upgrade file containing only &lt;code&gt;{Vsn,[],[]}&lt;/code&gt;. Any attempt at creating a release upgrade file with such input fails. The only way to force an upgrade involving applications like this is to handwrite the file &lt;code&gt;relup&lt;/code&gt;, preferably as described above with only the &lt;code&gt;restart_emulator&lt;/code&gt; instruction.</source>
          <target state="translated">HiPE와 같은 일부 응용 프로그램은 업그레이드를 지원하지 않습니다. 이것은 &lt;code&gt;{Vsn,[],[]}&lt;/code&gt; 만 포함 된 응용 프로그램 업그레이드 파일로 표시됩니다 . 이러한 입력으로 릴리스 업그레이드 파일을 작성하려는 시도가 실패합니다. 이와 같은 응용 프로그램과 관련된 업그레이드를 강제하는 유일한 방법은 바람직하게는 &lt;code&gt;restart_emulator&lt;/code&gt; 명령 만으로 위에서 설명한 것처럼 파일 &lt;code&gt;relup&lt;/code&gt; 을 손으로 쓰는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ff07fbc6aad7ee78f12be074f853b050b49851ab" translate="yes" xml:space="preserve">
          <source>A few basic match specifications are provided in the tool, and you can provide your own match specifications. The syntax of match specifications is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. To simplify the writing of a match specification, they can also be written as &lt;code&gt;fun/1&lt;/code&gt;. For details, see module &lt;code&gt;ms_transform&lt;/code&gt; in application STDLIB.</source>
          <target state="translated">몇 가지 기본 일치 사양이 도구에 제공되며 고유 한 일치 사양을 제공 할 수 있습니다. 일치 스펙 구문은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다. 일치 스펙 작성을 단순화하기 위해 &lt;code&gt;fun/1&lt;/code&gt; 로 작성할 수도 있습니다 . 자세한 내용은 모듈 참조 &lt;code&gt;ms_transform&lt;/code&gt; 애플리케이션 STDLIB에 있습니다.</target>
        </trans-unit>
        <trans-unit id="09ac9a5c3fa6e165b6c50df51a6215981d75c01d" translate="yes" xml:space="preserve">
          <source>A few cases when it can be useful to change &lt;code&gt;fullsweep_after&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fullsweep_after&lt;/code&gt; 를 변경하는 것이 유용 할 수있는 몇 가지 경우 :</target>
        </trans-unit>
        <trans-unit id="fd821a8e6f09efd8fb5370148d4ea4ec2ea95138" translate="yes" xml:space="preserve">
          <source>A few exceptions are documented for each property that behaves differently, and the special cases &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; and &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt;, are represented as:</source>
          <target state="translated">다르게 동작하는 각 특성에 대해 몇 가지 예외가 문서화되어 있으며 특수한 경우 &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; 및 &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt; 는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fce4084ca7f83d86aff3d0d9ecf63d0ad90bd23a" translate="yes" xml:space="preserve">
          <source>A few functions of this module (&lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt;) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt;, or an integer:</source>
          <target state="translated">이 모듈의 몇몇 함수 ( &lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt; 수단은 순서화 주어진 각 요소를 수정하는 등) 얼랑 기능을 허용 세트. 다음에서 SetFun이라고하는 이러한 함수는 함수형 객체 (fun), 튜플 &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt; 또는 정수 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ace938c1e5c889a1c9155b08dfea0b539e2fd8" translate="yes" xml:space="preserve">
          <source>A few more ways of retrieving parts of the result set when the driver supports scrollable cursors. Note that next will work even without support for scrollable cursors.</source>
          <target state="translated">드라이버가 스크롤 가능한 커서를 지원할 때 결과 집합의 일부를 검색하는 몇 가지 방법. 다음은 스크롤 가능한 커서를 지원하지 않아도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="69178368f8f421dd7829a950db37217d05913e11" translate="yes" xml:space="preserve">
          <source>A file &lt;code&gt;test.config&lt;/code&gt; is created with the following contents:</source>
          <target state="translated">&lt;code&gt;test.config&lt;/code&gt; 파일 은 다음 내용으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c8d336412b7f7b3198bf244f5e66fc7122fd82ab" translate="yes" xml:space="preserve">
          <source>A file can be included as follows:</source>
          <target state="translated">파일은 다음과 같이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbeaf69644d74ca16d734d345aa0a129a3918826" translate="yes" xml:space="preserve">
          <source>A file can contain several &lt;code&gt;BEGIN/END&lt;/code&gt; blocks. Text lines between blocks are ignored. Attributes, if present, are ignored except for &lt;code&gt;Proc-Type&lt;/code&gt; and &lt;code&gt;DEK-Info&lt;/code&gt;, which are used when &lt;code&gt;DER&lt;/code&gt; data is encrypted.</source>
          <target state="translated">파일은 여러 &lt;code&gt;BEGIN/END&lt;/code&gt; 블록을 포함 할 수 있습니다 . 블록 사이의 텍스트 줄은 무시됩니다. &lt;code&gt;DER&lt;/code&gt; 데이터가 암호화 될 때 사용되는 &lt;code&gt;Proc-Type&lt;/code&gt; 및 &lt;code&gt;DEK-Info&lt;/code&gt; 를 제외하고 속성이 있으면 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="9565a924f37de4be5c2226f5018cb7da0db985af" translate="yes" xml:space="preserve">
          <source>A file can have an encoding option that makes it generally usable by the &lt;code&gt;io&lt;/code&gt; module (for example &lt;code&gt;{encoding,utf8}&lt;/code&gt;), but is by default opened as a byte-oriented file. The &lt;code&gt;file&lt;/code&gt; module is byte-oriented, so only ISO Latin-1 characters can be written using that module. Use the &lt;code&gt;io&lt;/code&gt; module if Unicode data is to be output to a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding). It is slightly confusing that a file opened with, for example, &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; cannot be properly read using &lt;code&gt;file:read(File,N)&lt;/code&gt;, but using the &lt;code&gt;io&lt;/code&gt; module to retrieve the Unicode data from it. The reason is that &lt;code&gt;file:read&lt;/code&gt; and &lt;code&gt;file:write&lt;/code&gt; (and friends) are purely byte-oriented, and should be, as that is the way to access files other than text files, byte by byte. As with ports, you can write encoded data into a file by &quot;manually&quot; converting the data to the encoding of choice (using the &lt;code&gt;unicode&lt;/code&gt; module or the bit syntax) and then output it on a bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoded file.</source>
          <target state="translated">파일에는 일반적으로 &lt;code&gt;io&lt;/code&gt; 모듈 (예 : &lt;code&gt;{encoding,utf8}&lt;/code&gt; )에서 사용할 수있는 인코딩 옵션이있을 수 있지만 기본적으로 바이트 지향 파일로 열립니다. &lt;code&gt;file&lt;/code&gt; 모듈은 너무에만 ISO 라틴어 1 문자가 해당 모듈을 사용하여 작성 될 수있다, 바이트 지향이다. &lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; (바이트 단위 인코딩)을 사용하여 유니 코드 데이터를 파일로 출력 하려면 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하십시오 . &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; &lt;code&gt;file:read(File,N)&lt;/code&gt; 을 file : read (File, N)을 사용하여 제대로 읽을 수 없지만 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 검색 하는 것은 약간 혼란 스럽습니다 . 그것으로부터의 Unicode 데이터 그 이유는 &lt;code&gt;file:read&lt;/code&gt; 및 &lt;code&gt;file:write&lt;/code&gt; (및 친구)는 순전히 바이트 지향적이며 텍스트 파일 이외의 파일을 바이트 단위로 액세스하는 방법이어야합니다. 포트와 마찬가지로, 데이터를 선택한 인코딩 ( &lt;code&gt;unicode&lt;/code&gt; 모듈 또는 비트 구문 사용) 으로 &quot;수동으로&quot;변환하여 인코딩 된 데이터를 파일에 쓴 다음 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩 된 파일 로 출력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d89c7591289fd3005e1bbfce5efe617ceee10df" translate="yes" xml:space="preserve">
          <source>A file containing data related to a test and/or an SUT, for example, protocol server addresses, client login details, and hardware interface addresses. That is, any data that is to be handled as variable in the suite and not be hard-coded.</source>
          <target state="translated">테스트 및 / 또는 SUT와 관련된 데이터 (예 : 프로토콜 서버 주소, 클라이언트 로그인 세부 정보 및 하드웨어 인터페이스 주소)가 포함 된 파일입니다. 즉, 제품군에서 변수로 처리되고 하드 코딩되지 않은 모든 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="616a73250d7af5692f557f0fc3d8f0aefbf16ef9" translate="yes" xml:space="preserve">
          <source>A file descriptor representing a file opened in &lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; 모드로 열린 파일을 나타내는 파일 설명자 .</target>
        </trans-unit>
        <trans-unit id="2d71dcec01ab246a78607a17cbd7cd28847c46b5" translate="yes" xml:space="preserve">
          <source>A file or directory named &lt;code&gt;Dir&lt;/code&gt; exists already.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 이라는 파일 또는 디렉토리 가 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="26be688763e641b3a9dfad11fde8db2842f3801c" translate="yes" xml:space="preserve">
          <source>A filename.</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="7e18ad0e74d1cf4a7f98aab6228b1e84c7680443" translate="yes" xml:space="preserve">
          <source>A filter is defined as:</source>
          <target state="translated">필터는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5fa771ebe9bef523c8171150923d10ee3e8517" translate="yes" xml:space="preserve">
          <source>A filter which can be installed as a handler filter, or as a primary filter in Logger.</source>
          <target state="translated">처리기 필터 또는 Logger의 기본 필터로 설치할 수있는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="1e3cb0a88c21fc9cb93d8900a90dbffadc95b7ff" translate="yes" xml:space="preserve">
          <source>A filter_fun() takes an event record as sole argument and returns false | true | {true, NewEvent}.</source>
          <target state="translated">filter_fun ()은 이벤트 레코드를 유일한 인수로 취하고 false를 리턴합니다. 참 | {true, NewEvent}.</target>
        </trans-unit>
        <trans-unit id="520861380e77fff7b333b5642ccc63edc6c4108c" translate="yes" xml:space="preserve">
          <source>A final massage of the environment is needed, and that is done by the script &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt;. Start bash and do the following, note the &quot;back-ticks&quot; (`), can be quite hard to get on some keyboards, but pressing the back-tick key followed by the space bar might do it...</source>
          <target state="translated">환경의 최종 마사지가 필요하며 스크립트 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 의해 수행됩니다 . bash를 시작하고 다음을 수행하십시오. &quot;back-ticks&quot;(`)에주의하십시오. 일부 키보드는 다루기가 매우 어려울 수 있지만 back-tick 키를 누른 다음 스페이스 바를 누르면 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f744119c16fd9fb8932446ccb5476df4faf187" translate="yes" xml:space="preserve">
          <source>A fixed number of characters is requested using the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">다음 &lt;code&gt;Request&lt;/code&gt; 사용하여 고정 된 수의 문자를 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="0a7d5da9ebedb8e232edc49649003f18ee79c791" translate="yes" xml:space="preserve">
          <source>A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry:</source>
          <target state="translated">고정 크기 배열은 자동으로 커지지 않으며 마지막 설정 항목 이후의 액세스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bad05ad914ca3ed5e8df973848616692506d53e" translate="yes" xml:space="preserve">
          <source>A flag starting with a plus (&lt;code&gt;+&lt;/code&gt;) rather than a hyphen is converted to an Erlang term and passed unchanged to the compiler. For example, option &lt;code&gt;export_all&lt;/code&gt; for the Erlang compiler can be specified as follows:</source>
          <target state="translated">하이픈 대신 플러스 ( &lt;code&gt;+&lt;/code&gt; )로 시작하는 플래그 는 Erlang 용어로 변환되어 변경되지 않은 채 컴파일러로 전달됩니다. 예를 들어, Erlang 컴파일러에 대한 &lt;code&gt;export_all&lt;/code&gt; 옵션 은 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b632ad7a686b2d7a96c3959bf12e04c0566f52" translate="yes" xml:space="preserve">
          <source>A float is stored as 8 bytes in big-endian IEEE format.</source>
          <target state="translated">float는 big-endian IEEE 형식으로 8 바이트로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e5201aedcab16b3adecdda5a3e12ff8098d3d7" translate="yes" xml:space="preserve">
          <source>A float is stored in string format. The format used in sprintf to format the float is &quot;%.20e&quot; (there are more bytes allocated than necessary). To unpack the float, use sscanf with format &quot;%lf&quot;.</source>
          <target state="translated">float는 문자열 형식으로 저장됩니다. float를 포맷하기 위해 sprintf에서 사용되는 포맷은 &quot;% .20e&quot;입니다 (필요한 것보다 더 많은 바이트가 할당되어 있습니다). 플로트를 풀려면 &quot;% lf&quot;형식의 sscanf를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6f6fcdac9b179d5523fd1d6e88e1a598a905d83" translate="yes" xml:space="preserve">
          <source>A floating point number is expected. It must follow the Erlang floating point number syntax.</source>
          <target state="translated">부동 소수점 숫자가 예상됩니다. Erlang 부동 소수점 숫자 구문을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="b4d0580dc8d2afb0f4c6adffa439752a5472ac02" translate="yes" xml:space="preserve">
          <source>A format handler is a fun taking four arguments. This fun is called for each trace message in the binary log(s). A simple example that only prints each trace message can be as follows:</source>
          <target state="translated">형식 핸들러는 네 가지 인수를 취하는 재미입니다. 이 재미는 이진 로그의 각 추적 메시지에 대해 호출됩니다. 각 추적 메시지 만 인쇄하는 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="685c2f489be151735ae38f24a353d5faae37fc17" translate="yes" xml:space="preserve">
          <source>A formatter can be used by the handler implementation to do the final formatting of a log event, before printing to the handler's destination. The handler callback receives the formatter information as part of the handler configuration, which is passed as the second argument to &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러의 대상으로 인쇄하기 전에 핸들러 구현에서 포맷터를 사용하여 로그 이벤트의 최종 형식을 지정할 수 있습니다. 핸들러 콜백은 핸들러 구성의 일부로 포맷터 정보를 수신하며, 이는 &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt; 에 두 번째 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ddabb55af8280ef44d4873b2fe6f87c2ff0d592" translate="yes" xml:space="preserve">
          <source>A framework for automated testing of any target nodes.</source>
          <target state="translated">모든 대상 노드의 자동 테스트를위한 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="aee4c7374225cff97b384f5e8f0444105623df6f" translate="yes" xml:space="preserve">
          <source>A fun created by &lt;code&gt;fun M:F/A&lt;/code&gt; is called an &lt;strong&gt;external&lt;/strong&gt; fun. Calling it will always call the function &lt;code&gt;F&lt;/code&gt; with arity &lt;code&gt;A&lt;/code&gt; in the latest code for module &lt;code&gt;M&lt;/code&gt;. Notice that module &lt;code&gt;M&lt;/code&gt; does not even need to be loaded when the fun &lt;code&gt;fun M:F/A&lt;/code&gt; is created.</source>
          <target state="translated">&lt;code&gt;fun M:F/A&lt;/code&gt; 가 만든 재미를 &lt;strong&gt;외부&lt;/strong&gt; 재미 라고합니다 . 이를 호출하면 항상 모듈 &lt;code&gt;M&lt;/code&gt; 의 최신 코드에서 arity &lt;code&gt;A&lt;/code&gt; 로 함수 &lt;code&gt;F&lt;/code&gt; 를 호출합니다 . 재미있는 &lt;code&gt;fun M:F/A&lt;/code&gt; 가 생성 될 때 모듈 &lt;code&gt;M&lt;/code&gt; 을 로드 할 필요조차 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fe82f35844a581a23e9acd45f2d705a836415f6f" translate="yes" xml:space="preserve">
          <source>A fun expression begins with the keyword &lt;code&gt;fun&lt;/code&gt; and ends with the keyword &lt;code&gt;end&lt;/code&gt;. Between them is to be a function declaration, similar to a &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt;, except that the function name is optional and is to be a variable, if any.</source>
          <target state="translated">재미있는 표현은 키워드로 시작 &lt;code&gt;fun&lt;/code&gt; 키워드와 끝 &lt;code&gt;end&lt;/code&gt; . 그들 사이 에는 함수 이름이 선택적이며 변수가있는 경우를 제외하고 는 &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt; 과 비슷한 함수 선언 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">재미는 기능적인 대상입니다. 재미있는 기능을 통해 익명 함수를 만들고 이름이 아닌 함수 자체를 다른 함수의 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">잘못된 수의 인수에 재미가 적용됩니다. &lt;code&gt;F&lt;/code&gt; 는 재미와 논쟁을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">재미는 메모리를 소비하는 재미 테이블을 말합니다.</target>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">다음과 같은 시그니처 재미</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수 ( &lt;code&gt;fun/0&lt;/code&gt; 또는 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) 튜플)는 스위트, 그룹 및 테스트 사례 정보 함수에서 타임 트랩 값으로 지정하고 함수 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 에 대한 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">함수 중단 점은 지정된 함수에서 각 절의 첫 번째 줄에 하나씩있는 일련의 줄 중단 점입니다.</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">함수는 많은 인수를 가질 수 있습니다. 두 개의 숫자를 곱하는 함수로 &lt;code&gt;tut1&lt;/code&gt; 모듈을 확장 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">이러한 기능을 준수하는 기능입니다. 자세한 내용은 &lt;code&gt;supervisor(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">함수 제약 조건 Fc는 제약 조건 &lt;code&gt;C_1, ..., C_k&lt;/code&gt; 및 Rep (Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; 비어 있지 않은 시퀀스입니다 .</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">구성 파일에서 사용자가 결정한 배타적 디코딩 기능</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">SUT (System Under Test) 및 / 또는 &lt;code&gt;Common Test&lt;/code&gt; 호스트 노드 에서 상태 및 환경을 설정, 정리 및 / 또는 확인하는 데 사용되는 테스트 스위트의 기능으로, 테스트 케이스 ( 또는 일련의 테스트 사례)가 올바르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">스위트 에서 테스트 케이스를 실행하기위한 조건을 설명하는 특성 목록 ( &lt;code&gt;Common Test&lt;/code&gt; 서버 에서 읽음)을 리턴하는 테스트 스위트의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 모듈 의 함수 는 프로세스를 시작하는 데 사용됩니다. 비동기 시작의 경우 &lt;code&gt;spawn_link/3,4&lt;/code&gt; 및 동기 시작의 경우 start_link &lt;code&gt;start_link/3,4,5&lt;/code&gt; 와 같은 여러 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;F&lt;/code&gt; 가 원자 또는 표현식 인 &lt;code&gt;M:F&lt;/code&gt; 구문을 사용하여 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 라는 이름의 함수 와 arity &lt;code&gt;N&lt;/code&gt; 을 갖는 함수 는 종종 &lt;code&gt;m:f/N&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">스레드 안전으로 명시 적으로 문서화되지 않은 함수는 특정 시점에 런타임 시스템에서 스레드 안전 구현을 가질 수 있습니다. 그러나 이러한 구현은 &lt;strong&gt;사전 통지없이 언제든지&lt;/strong&gt; 스레드 &lt;strong&gt;안전하지 않은&lt;/strong&gt; 구현으로 변경 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">하나의 인수의 함수를 출력으로 지정할 수 있습니다. 입력을 정렬하거나 병합 한 결과는 형식에 따라 이진 또는 용어의 가변 길이 목록이 비어 있지 않은 순서로 수집됩니다. 출력 함수는 한 번에 하나의 목록으로 호출되며 새 출력 함수를 리턴한다고 가정합니다. 다른 반환 값은 즉시 sort 또는 merge 함수에 대한 현재 호출의 값으로 반환됩니다. 각 출력 함수는 정확히 한 번 호출됩니다. 일부 출력 함수가 모든 결과에 적용되었거나 오류가 발생하면 마지막 함수가 인수 &lt;code&gt;close&lt;/code&gt; 로 호출되고 sort 또는 merge 함수에 대한 현재 호출의 값으로 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">기능 사양이 오버로드 될 수 있습니다. 즉, 세미콜론 ( &lt;code&gt;;&lt;/code&gt; ) 으로 구분 된 여러 유형을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; 구조가 있으면 데이터베이스에 패밀리를 추가하는 함수를 다음과 같이 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">추적 할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">함수 유형 Ft는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;is_set_ok&lt;/code&gt; 를 사용하여 호출 된 함수는 오류가없는 경우 &lt;code&gt;set&lt;/code&gt; 을 사용하거나 오류가 발생한 경우 &lt;code&gt;undo&lt;/code&gt; 를 사용하여 다시 호출됩니다 . 이런 식으로, 자원은 &lt;code&gt;is_set_ok&lt;/code&gt; 작업 에서 예약 되거나 &lt;code&gt;undo&lt;/code&gt; 작업 에서 해제 되거나 &lt;code&gt;set&lt;/code&gt; 작업 에서 영구적이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">이름이 &lt;code&gt;..._test()&lt;/code&gt; 끝나는 함수 는 EUnit에 의해 간단한 테스트 함수로 인식됩니다. 인수가없고 실행이 성공하거나 (EUnit이 버릴 임의의 값을 반환 함) 어떤 종류의 예외 (또는 종료하지 않으면 잠시 후에 중단됩니다).</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">이름이 &lt;code&gt;..._test_()&lt;/code&gt; 로 끝나는 함수 (마지막 밑줄 참고)는 EUnit에서 &lt;strong&gt;테스트 생성기&lt;/strong&gt; 함수 로 인식 합니다. 테스트는 발전기 복귀 &lt;strong&gt;표현&lt;/strong&gt; (A)의 &lt;strong&gt;테스트 세트&lt;/strong&gt; EUNIT에 의해 실행된다.</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">시스템 메시지에 대한 기능 인터페이스.</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">기능적 객체 (fun)가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">기능적이고 확장 가능한 배열입니다. 표현은 문서화되어 있지 않으며 사전 통지없이 변경 될 수 있습니다. 배열이 동일한 지 직접 비교할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">일반적인 밸런스 세트 반복자.</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">일반적인 밸런스 세트.</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">균형 잡힌 트리 반복자.</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">균형 잡힌 나무.</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 작동 하는 방식과 같이 형식 지정자와 해당 인수 세트를 사용하여 Erlang 용어를 작성하는 일반적인 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">레지스트리에서 모든 종류의 객체를 검색하는 일반적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">생성 된 오류는 코드 자체가 &lt;code&gt;exit/1&lt;/code&gt; 또는 &lt;code&gt;throw/1&lt;/code&gt; 을 호출하는 경우 입니다. 에뮬레이트 된 런타임 오류는 여기에서 생성 된 오류로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">일반적인 예쁜 프린터 라이브러리.</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">일반적인 예쁜 프린터 라이브러리. 이 모듈은 &quot;Pretty-Printing Library의 디자인&quot;에 설명 된 John Hughes 알고리즘의 엄격한 스타일 컨텍스트 전달 구현을 사용합니다. 단락 스타일 서식, 빈 문서, 부동 문서 및 null 문자열은 알고리즘에 추가 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">일반적인 단일 객체 비교 및 ​​스왑 작업 :</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하여 구현 된 일반 상태 머신 프로세스 ( &lt;code&gt;gen_statem&lt;/code&gt; )에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함되어 있습니다. 또한 OTP 감독 트리에도 적합합니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 과 같은 &lt;code&gt;PublishType&lt;/code&gt; 으로 정의 된 글로벌 그룹 은 숨겨진 글로벌 그룹이라고합니다. 숨겨진 글로벌 그룹의 모든 노드는 명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; 으로 시작했는지 여부에 관계없이 숨겨진 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">세계적인 이름 등록 시설.</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">플래그 &lt;code&gt;timestamp&lt;/code&gt; 스탬프를 사용하는 모든 추적 타임 스탬프를 벽시계 시간이 아닌 CPU 시간으로 만드는 Erlang 노드의 글로벌 추적 플래그입니다 . 즉, &lt;code&gt;cpu_timestamp&lt;/code&gt; 는 경우에 사용되지 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 또는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 이 활성화됩니다. &lt;code&gt;PidPortSpec==all&lt;/code&gt; 에만 허용됩니다 . 호스트 시스템 OS가 고해상도 CPU 시간 측정을 지원하지 않으면 &lt;code&gt;trace/3&lt;/code&gt; 가 &lt;code&gt;badarg&lt;/code&gt; 로 종료됩니다 . 대부분의 OS는 코어간에이 값을 동기화하지 않으므로이 옵션을 사용할 때 시간이 거꾸로 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 문헌을 설명하는 좋은 책은 Dubuisson입니다. ASN.1-이기종 시스템 간 통신은 &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; 에서 무료로 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">효율적으로 프로그래밍 할 때 좋은 시작은 서로 다른 데이터 유형과 작업에 필요한 메모리 양을 아는 것입니다. Erlang 데이터 유형 및 기타 항목이 소비하는 메모리 양은 구현에 따라 다르지만 다음 표는 OTP 19.0 의 &lt;code&gt;erts-8.0&lt;/code&gt; 시스템에 대한 일부 수치를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">더 많은 IO 폴 스레드가 필요한지 확인하는 좋은 방법은 &lt;code&gt;microstate accounting&lt;/code&gt; 을 사용 하고 IO 폴 스레드의로드가 무엇인지 확인하는 것입니다. 높으면 스레드를 더 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">목록 표현식을 구문 분석하는 문법 (빈 관련 코드 포함) :</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">병렬 그룹 아래에 중첩 된 그룹은 중첩 된 그룹의 속성에 관계없이 이전 (병렬) 테스트 사례와 병렬로 실행을 시작합니다. 그러나 테스트 케이스는 동일한 그룹의 &lt;code&gt;init_per_group/2&lt;/code&gt; 또는 &lt;code&gt;end_per_group/2&lt;/code&gt; 와 병렬로 실행되지 않으므로 중첩 그룹이 완료된 후에 만 ​​이전 그룹의 나머지 병렬 케이스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">트랜잭션 내에서 함수 또는 프로세스 그룹을 호출 할 수 있습니다. 트랜잭션에는 DBMS에서 데이터를 읽거나 쓰거나 삭제하는 명령문이 포함될 수 있습니다. 이러한 많은 트랜잭션이 동시에 실행될 수 있으며 프로그래머는 데이터를 조작하는 프로세스를 명시 적으로 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">프로세스 그룹은 공통 이름으로 액세스 할 수 있습니다. 예를 들어, &lt;code&gt;foobar&lt;/code&gt; 라는 그룹이 있으면 그룹 &lt;code&gt;foobar&lt;/code&gt; 의 모든 구성원 인 프로세스 세트 (다른 ​​노드에 위치 할 수 있음)가있을 수 있습니다 . 그룹에 메시지를 보내기위한 특별한 기능은 없습니다. 대신 클라이언트 함수를 &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; 함수로 작성 하여 그룹의 구성원 인 프로세스를 판별하십시오. 그런 다음 메시지를 하나 이상의 그룹 구성원에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">(? |로 시작하는 그룹은 각 대안에서 캡처 괄호 번호를 재설정합니다 (섹션 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 참조 ). 각 분기의 시작 부분에있는 어설 션은 다음 UTF-8 문자에서 인코딩이 1, 2, 3, 그런 다음 문자의 개별 바이트는 적절한 수의 그룹에 의해 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">가드 G는 비어 있지 않은 가드 테스트 &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; 및 Rep (G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">가드 시퀀스 Gs는 가드 시퀀스 &lt;code&gt;G_1; ...; G_k&lt;/code&gt; 및 Rep (Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; 입니다. 가드 시퀀스가 ​​비어 있으면 Rep (Gs) = &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">가드 테스트 Gt는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">드라이버 별 데이터에 대한 핸들로 드라이버 콜백에 전달됩니다. 포인터이며 대부분 드라이버의 특정 포인터로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">핸들러 콜백 모듈은 다음을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; 호출하여 핸들러를 제거 할 수 있습니다 . 로거는 &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; 호출 하고 구성 데이터베이스에서 처리기 구성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">핸들러는 최소한 다음 콜백 함수를 내보내는 모듈로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">숨겨진 노드는 명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; 으로 시작된 노드입니다 . 숨겨진 노드와 다른 노드 사이의 연결은 전 이적이지 않으므로 명시 적으로 설정해야합니다. 또한 숨겨진 노드는 &lt;code&gt;nodes()&lt;/code&gt; 반환 한 노드 목록에 나타나지 않습니다 . 대신 &lt;code&gt;nodes(hidden)&lt;/code&gt; 또는 &lt;code&gt;nodes(connected)&lt;/code&gt; 사용해야합니다. 예를 들어 숨겨진 노드는 &lt;code&gt;global&lt;/code&gt; 이 추적하는 노드 세트에 추가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">각 간격의 상한이 이전보다 두 배 높은 블록 크기의 히스토그램입니다.</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">후크 함수 ( &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; 유형)는 현재 구문 트리 노드, 컨텍스트 및 연속으로 전달됩니다. 컨텍스트는 &lt;code&gt;get_ctxt_user/1&lt;/code&gt; 및 &lt;code&gt;set_ctxt_user/2&lt;/code&gt; 와 같은 함수로 검사하고 조작 할 수 있습니다 . 후크는 &quot;문서&quot;데이터 구조를 리턴해야합니다 ( &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; 참조 ). 이것은 연속 기능을 적용함으로써 부분적으로 또는 전체적으로 구성 될 수있다. 예를 들어, 다음은 사소한 후크입니다.</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enif_schedule_nif&lt;/code&gt; 를 사용하여 I / O 바운드와 CPU 바운드를 번갈아가는 작업을 다시 분류하고 다시 예약하여 항상 올바른 유형의 더티 스케줄러에서 실행할 수 있습니다 . 자세한 내용은 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">버퍼 제한이 크면 프로세스가 분배를 통해 더 많은 발신 메시지를 버퍼링 할 수 있습니다. 버퍼 제한에 도달하면 버퍼 크기가 줄어들 때까지 전송 프로세스가 일시 중단됩니다. 버퍼 한계는 분배 채널당입니다. 제한이 높을수록 메모리 사용률이 높아지면서 대기 시간과 처리량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">항목이 하나만 있고 &lt;code&gt;InfoList&lt;/code&gt; 가 비어 있으면 &lt;code&gt;CpuTopology&lt;/code&gt; 라는 용어의 레벨을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">시작하거나 중지 할 수없는 라이브러리 응용 프로그램은 응용 프로그램 콜백 모듈이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">모듈이 모듈보기 창 또는 프로세스 연결 창에 표시 될 때 줄을 두 번 클릭하여 줄 바꿈 지점을 만들거나 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">줄 바꿈 지점은 모듈의 특정 줄에 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;channel&lt;/code&gt; 의 라인 레벨 호출 분석은 &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; 을 사용하여 파일에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; 호출하여 링크를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">충돌시 로컬 프로세스와 원격 프로세스 사이에 링크가 존재했습니다.</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">링크가 끊어졌습니다. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 에는 링크 된 프로세스의 pid가 포함되고 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 에는 종료 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">특정 디렉토리에서 실행 된 모든 실행에 대한 링크는 &lt;code&gt;all_runs.html&lt;/code&gt; 로그에 작성되며 모든 테스트 (최신 결과)에 대한 직접 링크는 최상위 &lt;code&gt;index.html&lt;/code&gt; 에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">목록 이해는 목록을 반환합니다. 여기서 요소는 모든 필터가 참인 생성기 목록 요소와 비트 문자열 생성기 요소의 각 조합에 대해 &lt;code&gt;Expr&lt;/code&gt; 을 평가 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">목록 이해 :</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">리스트는 가변 개수의 항을 갖는 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 앞에 오는 마지막 용어 인 꼬리를 포함하여 여러 요소로 목록을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">오류 표시가 포함 된 'ActionReply'레코드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">개체 내에서 많은 업데이트 작업을 수행하기 위해 &lt;code&gt;UpdateOp&lt;/code&gt; 목록을 제공 할 수 있습니다. 작업은 목록에 지정된 순서대로 수행됩니다. 동일한 카운터 위치가 목록에서 두 번 이상 나타나면 해당 카운터가 이전 결과에 따라 매번 여러 번 업데이트됩니다. 반환 값은 작업 목록과 동일한 순서로 각 업데이트 작업의 새 카운터 값 목록입니다. 빈 목록이 지정되면 아무것도 업데이트되지 않고 빈 목록이 반환됩니다. 기능이 실패하면 업데이트가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">&lt;code&gt;{Name, Memory}&lt;/code&gt; 튜플 의 목록 . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 조각 &lt;code&gt;Name&lt;/code&gt; 이며 &lt;code&gt;Memory&lt;/code&gt; 는 차지하는 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">&lt;code&gt;{Name, Size}&lt;/code&gt; 튜플 의 목록 . 여기서 &lt;code&gt;Name&lt;/code&gt; 은 조각 &lt;code&gt;Name&lt;/code&gt; 이며 &lt;code&gt;Size&lt;/code&gt; 는 포함 된 레코드 수입니다.</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">&lt;code&gt;{Pos,Value}&lt;/code&gt; 목록을 제공하여 동일한 오브젝트 내에서 많은 요소를 업데이트 할 수 있습니다. 동일한 위치가 목록에서 두 번 이상 나타나면 목록의 마지막 값이 기록됩니다. 목록이 비어 있거나 기능이 실패하면 업데이트가 수행되지 않습니다. 이 기능은 다른 프로세스가 중간 결과를 볼 수 없다는 의미에서 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">목록 &lt;strong&gt;릴리스 업그레이드 지침은&lt;/strong&gt; 참조 &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; . 고급 지침 만 사용하는 것이 좋습니다. 이 자동으로 낮은 수준의 지침을 번역 &lt;code&gt;systools&lt;/code&gt; 만들 때 &lt;code&gt;relup&lt;/code&gt; 의 파일을.</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">피어 인증서로 끝나는 트러스트 순서의 DER로 인코딩 된 인증서 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">활성 체크 포인트 목록은 다음 기능을 통해 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유효한 모든 Erlang Top 구성 매개 변수 목록은 &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">해당 응용 프로그램의 사전에 의해 정의되지 않은 AVP를 인코딩 / 디코딩하는 대체 사전 모듈 목록입니다. 디코딩시, 그러한 &lt;code&gt;'AVP'&lt;/code&gt; 는 디코딩 된 메시지 의 'AVP' 필드 또는 그룹화 된 AVP의 레코드 _ 값 필드를 디코딩하는 첫 번째 대안 인 그룹화 된 AVP 에서 diameter_avp 레코드로 표현된다 . 인코딩시 &lt;code&gt;'AVP'&lt;/code&gt; 목록의 값은 AVP 이름 / 값 2 튜플로 전달 될 수 있으며 이러한 튜플의 AVP를 대체하는 것은 대체 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">응용 프로그램이 의존하는 응용 프로그램 버전 목록. 이러한 응용 프로그램 버전의 예는 &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; 입니다. 런타임 종속성으로 지정된 응용 프로그램 버전은 최소 요구 사항입니다. 즉, 종속성에 지정된 버전보다 큰 애플리케이션 버전이 요구 사항을 충족시킵니다. 응용 프로그램 버전을 비교하는 방법에 대한 자세한 내용은 시스템 원칙 사용 설명서의 &lt;code&gt;Versions&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">릴리스에 포함 된 응용 프로그램에 포함 된 응용 프로그램 목록입니다. 목록은 애플리케이션 자원 파일 ( &lt;code&gt;Application.app&lt;/code&gt; )에 지정된 포함 된 애플리케이션의 서브 세트 여야 하며이 값을 대체합니다. 기본적으로 응용 프로그램 자원 파일과 같은 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 정의 에서 &lt;code&gt;NamedBitList&lt;/code&gt; 의 원자에 해당하는 원자 목록 . 기호 이름이 있는 &lt;code&gt;BIT STRING&lt;/code&gt; 은 항상 다음 예제에 표시된 형식으로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 목록입니다. 이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 와 함께 사용하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Startup&lt;/code&gt; 옵션에 지정된 기능 목록은 노드 시작 후 실행됩니다. 사용 된 모든 모듈이 &lt;code&gt;Host&lt;/code&gt; 의 코드 경로에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">구성 함수에서 테스트 케이스로 전달 된 런타임 구성 데이터를 포함하는 키-값 튜플 목록 (즉, 특성 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">저수준 릴리스 업그레이드 지침의 목록은 &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 시작 스크립트와 동일한 순서로 각 응용 프로그램 업그레이드 파일의 릴리스 업그레이드 지침 (높은 수준의 지침이 낮은 수준의 지침으로 변환 됨)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 같습니다 . 일치 사양에 대한 설명은 사용자 안내서 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; 목록에서 일치 합니다. &lt;code&gt;Node&lt;/code&gt; 는 발신자의 노드 이름입니다. &lt;code&gt;Sender&lt;/code&gt; 은 보낸 사람 의 프로세스 또는 포트 ID이거나 , 보낸 사람을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 아톰 (원격 보낸 사람의 경우 일 수 있음)입니다. &lt;code&gt;Msg&lt;/code&gt; 메시지 용어입니다. 수신 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치 사양 목록입니다. 일치는 &lt;code&gt;[Receiver, Msg]&lt;/code&gt; 목록에서 수행됩니다 . &lt;code&gt;Receiver&lt;/code&gt; 는 수신자 의 프로세스 또는 포트 ID이고 &lt;code&gt;Msg&lt;/code&gt; 는 메시지 용어입니다. 전송 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 . 빈 목록은 &lt;code&gt;true&lt;/code&gt; 와 동일 합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">프로세스에 대해 활성 인 모니터 목록 ( &lt;code&gt;monitor/2&lt;/code&gt; 로 시작 ). 프로세스 ID 별 로컬 프로세스 모니터 또는 원격 프로세스 모니터의 경우 목록은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">노드 이름 (원자), 그룹 노드 목록.</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">현재 노드 이름과 로컬 노드와 동기화 된 노드 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">현재 연결이없는 그룹 노드 인 노드 이름 목록.</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">로컬 노드가 동기화하지 못한 그룹 노드 인 노드 이름 목록.</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 개체 목록과 연속이 반환됩니다.이 경우 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 추가 객체를 일치시킬 때 연속이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;nodeup&lt;/code&gt; 및 &lt;code&gt;nodedown&lt;/code&gt; 메시지를 구독 한 프로세스를 지정하는 pid 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">프로세스를 모니터링하는 프로세스 식별자 목록 ( &lt;code&gt;monitor/2&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">응용 프로그램의 시작 단계 및 해당 시작 인수 목록. 이 키가 존재하는 경우, 응용 프로그램의 마스터에 일반 전화뿐만 아니라 &lt;code&gt;Module:start/2&lt;/code&gt; , 또한 호출 &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; 키에 의해 정의 된 각 시작 단계에 &lt;code&gt;start_phases&lt;/code&gt; . 이 확장 된 시작 절차 후에 만 &lt;code&gt;application:start(Application)&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">일치하는 토큰의 문자 목록.</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">존재하지 않는 노드 목록</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">서버가 존재하지 않는 노드 목록</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">응답을 보내기 전에 서버가 종료 된 노드 목록.</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">스캐너가 생성 한 토큰 목록은 파서가 찾고 있는 특별한 &lt;code&gt;end_of_input&lt;/code&gt; 튜플로 끝나야 합니다. 이 튜플의 형식은 &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; 이어야합니다 . 여기서 &lt;code&gt;Endsymbol&lt;/code&gt; 은 구문 규칙의 모든 터미널 및 비 터미널 범주와 구별되는 식별자입니다. &lt;code&gt;Endsymbol&lt;/code&gt; 은 문법 파일에 선언 할 수있다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">개별 스케줄러의 결과와 집계 평균이 포함 된 튜플 목록입니다. &lt;code&gt;Util&lt;/code&gt; 은 0.0과 1.0 사이의 부동 소수점 값으로 스케줄러 사용률입니다. &lt;code&gt;Percent&lt;/code&gt; 은 백분율 로 표현 된 사람이 읽을 수있는 문자열과 동일한 활용률입니다.</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">&lt;code&gt;FuncCallCount&lt;/code&gt; 순서 를 줄이면서 모듈의 각 함수에 대해 하나씩 튜플 목록 .</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">튜플들의 목록을 제외한 각 모듈에 대한 하나 &lt;code&gt;cprof&lt;/code&gt; 감소 시키는데, &lt;code&gt;ModCallCount&lt;/code&gt; 의 순서.</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">list &lt;code&gt;t&lt;/code&gt; 의 tail 요소를 나타내는 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">다음과 같이 정렬 된 목록 :</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">꼬리가 목록 인 목록을 &lt;strong&gt;적절한 목록&lt;/strong&gt; 이라고도 &lt;strong&gt;합니다&lt;/strong&gt; . 테일이 목록이 아닌 목록을 가질 수 있습니다 (예 : &lt;code&gt;[a|b]&lt;/code&gt; . 그러나이 유형의 목록은 거의 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">&lt;code&gt;Cols&lt;/code&gt; 목록 만큼 많은 요소가있는 목록 각 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">&lt;code&gt;Cols&lt;/code&gt; 목록 만큼 많은 요소가있는 목록. 각 요소는 해당 열의 값입니다. 각 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">유니 코드 변환 수정자가 지정되지 않은 경우 정수가 255보다 큰 목록은 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">해석 된 모든 모듈의 이름이 포함 된 목록 상자</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">수신 전송은 동일한 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 대해 여러 개의 허용 된 연결이있을 수 있으므로 해당 정보를 약간 다르게 표시 합니다. &lt;code&gt;transport&lt;/code&gt; 으로 보일 수 있습니다 단일 클라이언트 연결을 서버에 의해 반환되는 정보는 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리터럴 &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">리터럴 데이터 문자</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">요소 대신 리터럴 문자열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로드 된 NIF 라이브러리는이를로드 한 Erlang 모듈 인스턴스에 연결됩니다. 모듈이 업그레이드되면 새 모듈 인스턴스는 자체 NIF 라이브러리를로드해야합니다 (또는 선택하지 않을 수도 있음). 그러나 새 모듈 인스턴스는 원하는 경우 이전 코드와 동일한 NIF 라이브러리를로드하도록 선택할 수 있습니다. 동적 라이브러리를 공유한다는 것은 라이브러리에 의해 정의 된 정적 데이터도 공유됨을 의미합니다. 모듈 인스턴스간에 의도하지 않게 공유되는 정적 데이터를 피하기 위해 각 Erlang 모듈 버전은 고유 한 개인 데이터를 유지할 수 있습니다. 이 개인 데이터는 NIF 라이브러리가로드 된 후 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 를 호출하여 나중에 검색 될 때 설정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">옵션 &lt;code&gt;name&lt;/code&gt; 다른 값을 지정 하거나 다른 노드에 로그를 분배 할 때 동일한 파일을 사용하여 로그 파일을 두 번 이상 열 수 있습니다 . 하나의 디스크 로그 프로세스가 파일에 대한 쓰기 액세스 권한을 갖지 않도록하는 것은 &lt;code&gt;disk_log&lt;/code&gt; 모듈의 사용자에게 달려 있습니다. 그렇지 않으면 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">하나의 특정 테스트 사례에 대한 로그 파일. 테스트 케이스 로그 파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">논리적 오류는 프로그램이 의도 한대로 작동하지 않지만 충돌하지 않는 경우입니다. 그래픽 사용자 인터페이스의 버튼을 클릭해도 아무런 변화가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">이전 요청이 완료되는 데 시간이 오래 걸리므로 요청 대기열이 길면 사용자 인식 지연이 발생할 수 있습니다. HTTP / 1.1 스펙은 서버 당 두 개의 영구 연결 제한을 제안합니다. 이는 &lt;code&gt;max_sessions&lt;/code&gt; 옵션의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">매크로 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 로 대체되는 &lt;code&gt;Replacement&lt;/code&gt; 변수의 모든 항목, &lt;code&gt;Var&lt;/code&gt; 매크로 정의에서의 대응하는 인자로 대체 &lt;code&gt;Arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">&lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 있는 (비어있을 수있는) 인수 목록이 있는 매크로 ? Func (Arg1, ..., ArgN) 은 인수가있는 &lt;code&gt;Func&lt;/code&gt; 정의가 하나 이상 있지만 N 개의 인수가없는 경우 오류 메시지를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">매크로 정의는 모듈의 속성 및 함수 선언 중 어디에나 배치 할 수 있지만 정의는 매크로를 사용하기 전에 이루어져야합니다.</target>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">서버 프로세스를 생성 할 때에도 매크로가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">매크로는 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">관리자는 명령을 생성하고 에이전트로부터 알림을받습니다. 일반적으로 시스템에는 관리자가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">특정 스레드에 대한 정보가 포함 된 맵입니다. &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;runtime&lt;/code&gt; 또는 &lt;code&gt;realtime&lt;/code&gt; 이 요청 되었는지에 따라 맵의 백분율은 런타임 또는 실시간 일 수 있습니다. &lt;code&gt;system&lt;/code&gt; 은이 특정 스레드에 대한 총 시스템 시간의 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">다른 마이크로 스테이트 회계 상태 및 마이크로 초 수를 포함하는 맵.</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">다른 마이크로 스테이트 회계 상태를 포함하는 맵. 맵의 각 값에는이 스레드가 특정 상태에서 보낸 시간의 백분율을 가진 다른 맵이 포함됩니다. &lt;code&gt;system&lt;/code&gt; 시간 의 백분율 과 해당 특정 &lt;code&gt;thread&lt;/code&gt; 의 시간 은 모두 맵의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">맵은 가변 개수의 키-값 연관을 갖는 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">지도 반복자는 환경의 수명 동안에만 유용 &lt;code&gt;env&lt;/code&gt; 것을 &lt;code&gt;map&lt;/code&gt; 에 속한다. &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; 를 호출하여 반복자를 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">키-값 쌍 &lt;code&gt;N&lt;/code&gt; 의 수로 맵을 지정해야합니다 . 키-값 쌍은 &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; 순서로 &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; 앞에 와야합니다 . 중복 키는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">일치 스펙은 순차 추적을 켜거나 끌 수 있습니다. 이 함수는 일치 스펙을 리턴하며 지정된 &lt;code&gt;Flags&lt;/code&gt; 사용하여 순차적 추적을 켭니다 .</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'receive'&lt;/code&gt; 추적에 대한 일치 스펙은 &lt;code&gt;caller&lt;/code&gt; , &lt;code&gt;is_seq_trace&lt;/code&gt; , &lt;code&gt;get_seq_token&lt;/code&gt; , &lt;code&gt;set_seq_token&lt;/code&gt; , &lt;code&gt;enable_trace&lt;/code&gt; , &lt;code&gt;disable_trace&lt;/code&gt; , &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;silent&lt;/code&gt; 및 &lt;code&gt;process_dump&lt;/code&gt; 를 제외한 모든 가드 및 본문 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 추적에 대한 일치 스펙은 &lt;code&gt;caller&lt;/code&gt; 제외한 모든 가드 및 본문 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">&lt;code&gt;ets(3)&lt;/code&gt; 사용 된 일치 스펙 은 다음과 같은 &lt;strong&gt;비공식&lt;/strong&gt; 문법 으로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">추적에 사용 된 일치 스펙은 다음과 같은 &lt;strong&gt;비공식&lt;/strong&gt; 문법에 설명 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">일치 사양은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">문자열 &quot;aaaa&quot;와의 일치는 항상 실패하지만 각 역 추적이 발생하기 전에 콜 아웃이 수행됩니다 (이 예에서는 10 번).</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">메모리 세그먼트 할당 자. 다른 할당자가 메모리 세그먼트를 할당하는 데 사용하며 &lt;code&gt;mmap&lt;/code&gt; 시스템 호출 이있는 시스템에서만 사용할 수 있습니다 . 할당이 해제 된 메모리 세그먼트는 삭제되기 전에 세그먼트 캐시에 잠시 동안 유지됩니다. 세그먼트가 할당되면 가능한 경우 새 세그먼트를 작성하는 대신 캐시 된 세그먼트가 사용됩니다. 시스템 호출 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">NIF 라이브러리의 최소 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">네트워킹이 포함 된 최소 Windows NT 설치에는 250MB가 필요하고 스왑 파일에는 130MB가 추가로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">오작동하는 필터가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">모듈 속성은 태그와 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">테스트 세트를 나타내는 데 모듈을 사용할 수도 있습니다. 아래 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 아래의 &lt;code&gt;ModuleName&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">모듈은 모듈 이름 (아톰) 또는 파일 이름으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">모듈은 일부 유형을 내보내 다른 모듈이 해당 유형을 &lt;strong&gt;원격 유형&lt;/strong&gt; 으로 참조 할 수 있음을 선언 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 이 선언의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">모듈은 Erlang 웹 서버 API 모듈 순서에서 이전 모듈에 의해 생성 된 데이터를 사용하거나 연속적인 Erlang 웹 서버 API 모듈에 의해 사용될 데이터를 생성 할 수 있습니다. 상호 작용 데이터라고하는 내부 키-값 튜플 목록으로 인해 가능합니다.</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">모듈에는 &lt;code&gt;-on_load function&lt;/code&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">모듈 선언은 함수 선언 또는 속성 인 일련의 양식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 . 이 모듈의 정보 기능은 다양한 전달 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">모듈은 더에 한 번 이상 포함되어있는 &lt;code&gt;Modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; &lt;code&gt;transport_module&lt;/code&gt; 로 지정된 모듈은 여기에 문서화 된 인터페이스를 구현해야합니다. 인터페이스는 직경이 전송 프로세스를 시작하는 기능과 전송 프로세스가 시작 프로세스 (일명 상위)와 통신하는 메시지 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; 호출하여 모니터를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">&lt;code&gt;unloaded_only&lt;/code&gt; 로 생성 된 모니터 는 &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; 메시지가 전송되지 않는다는 점을 제외하고는 &lt;code&gt;unloaded&lt;/code&gt; 생성 된 것과 동일하게 동작 하지만 대신 모니터는 드라이버가 &lt;strong&gt;실제로&lt;/strong&gt; 언로드 될 때까지 지속 됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템이 제공하는 단조 증가 시간. 얼랭 단조 시간은 지정되지 않은 특정 시점부터 증가합니다. 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">OS가 제공하는 단조 증가 시간. 이 시간은 완전히 정확하지는 않지만 도약하지 않고 상대적으로 안정적인 주파수를 갖습니다. 그러나 시스템이 일시 중단 된 경우 OS 단조로운 시간이 중지되는 것은 드문 일이 아닙니다. 이 시간은 일반적으로 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 연결되지 않은 지정되지 않은 특정 시점이기 때문에 증가 합니다 . 이 유형의 시간이 모든 OS에서 제공되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">두 개의 쿼드 코어 프로세서 (각각 자체 프로세서는 NUMA 노드에 있음)를 사용하는보다 복잡한 예입니다. 논리 프로세서의 순서는 약간 이상합니다. 이것은 식별자 목록의 더 좋은 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">이 프로세스의 상태에 대한 자세한 내부 표현.</target>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">MIB 사양을위한보다 정확한 언어</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">이 형식 핸들러의보다 세련된 버전은 관찰자 애플리케이션의 디렉토리 &lt;code&gt;src&lt;/code&gt; 에 포함 된 &lt;code&gt;multitrace.erl&lt;/code&gt; 모듈의 &lt;code&gt;handle_gc/4&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">다국어 SNMP 관리자.</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">구성 파일에서 읽은 데이터 값과 연관된 이름 (Erlang atom)입니다.</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">A는 문을 통해 필요한 구성 데이터 이름과 연관 도입하거나 호출 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 예를 들어, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">생성 된 함수의 이름으로 구성된 이름</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">데이터 이름은 &lt;code&gt;require&lt;/code&gt; 를 사용하여 제품군에 할당되어야 합니다 (위 예 참조). 인수로이 이름을 통과 &lt;code&gt;SnmpAppConfName&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ct_snmp&lt;/code&gt; 는 일부 &lt;code&gt;SNMP&lt;/code&gt; 응용 프로그램 구성 매개 변수의 기본값을 지정합니다 (예 : 매개 변수 &lt;code&gt;config&lt;/code&gt; 의 &lt;code&gt;{verbosity,trace}&lt;/code&gt; ). 이 기본값 세트는 사용자가 지정한 매개 변수와 병합됩니다. 사용자 값은 &lt;code&gt;ct_snmp&lt;/code&gt; 기본값 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">이 동사에는 항상 이름이 필요합니다. 패턴에서 원하는만큼 (* MARK) 인스턴스가있을 수 있으며 해당 이름은 고유하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">돌아 오기 전에 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 수행하는 기본 함수 는 VM의 응답 성을 저하 시키며 기타 이상한 동작을 유발할 수 있습니다. 이러한 이상한 동작에는 과도한 메모리 사용 및 스케줄러 간의 잘못된로드 밸런싱이 포함되지만 이에 국한되지는 않습니다. 긴 작업으로 인해 발생할 수있는 이상한 동작도 Erlang / OTP 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">기본 기능은 VM의 기본 코드를 직접 확장하여 실행됩니다. 안전한 환경에서 실행되지 않습니다. 선점 예약 또는 메모리 보호와 같이 Erlang 코드를 실행할 때 VM에서 제공 한 것과 동일한 서비스를 제공 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; . 기본 기능이 제대로 작동하지 않으면 전체 VM이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">충돌하는 기본 기능은 전체 VM을 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">기본 부호있는 64 비트 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">기본 부호없는 64 비트 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">음수의 &lt;code&gt;WindowBits&lt;/code&gt; 값은 zlib가 스트림에서 zlib 헤더 (및 체크섬)를 무시하게합니다. zlib 소스는이를 문서화되지 않은 기능으로 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">2 진의 끝에서 바이트를 추출하는 데 음수 길이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">부정적인 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">값이 음수이면 크래시 덤프 파일이 완전히 작성 될 때까지 런타임 시스템 종료가 무기한 대기합니다. 이 옵션의 경우 기본값은 &lt;code&gt;-heart&lt;/code&gt; 되어 &lt;strong&gt;하지&lt;/strong&gt; 에 전달 &lt;code&gt;erl&lt;/code&gt; 과 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 가 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">네트워크 인터페이스 필터는 예를 들어 테스트 또는로드 레귤레이션에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">네트워크 인터페이스 필터는 예를 들어 테스트 또는로드 레귤레이션에 사용될 수 있습니다. 의도 된 용도가 부하 조절 인 경우 &lt;code&gt;req_limit&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">다음과 같이 새 &lt;code&gt;person&lt;/code&gt; 레코드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">릴리스 패키지가 작성되기 전에 &lt;code&gt;local&lt;/code&gt; 옵션이 설정 되지 않은 새 부트 스크립트가 생성 되었습니다. 릴리스 패키지에서 모든 응용 프로그램 디렉토리는 &lt;code&gt;lib&lt;/code&gt; 아래에 있습니다. 릴리스 패키지를 설치할 위치를 모르므로 하드 코드 된 절대 경로는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">프로세스가 인덱스 테이블을 버리려고 할 때 (즉, 완전히 새로운 것을 구축하려는 경우)를 처리하기 위해 새로운 인터페이스 &lt;code&gt;delete/1&lt;/code&gt; 이 추가되었습니다. 이를 처리하려면 임시 snmp 색인을 사용하는 모든 응용 프로그램을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt; 를 적용하면 새로운 프로세스가 시작됩니다 . 프로세스가 동시에 모니터링됩니다. 프로세스 식별자와 모니터에 대한 참조를 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">새로운 기록이 작성되었습니다. &lt;code&gt;NewRecord&lt;/code&gt; 는 새 레코드 값을 포함 하고 &lt;code&gt;OldRecords&lt;/code&gt; 는 작업이 수행되기 전에 레코드를 포함합니다. 새 내용은 테이블 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">새로운 기록이 작성되었습니다. &lt;code&gt;NewRecord&lt;/code&gt; 는 새로운 레코드 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">&lt;code&gt;ch_app.app&lt;/code&gt; 파일 의 새 버전 이 생성되어 버전이 업데이트됩니다 :</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">다음 다섯 가지 시퀀스 중 하나를 사용하여 패턴 문자열을 시작하여 줄 바꿈 규칙을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">새로 생성 된 Erlang 프로세스는 HiPE 지원없이 비 SMP 에뮬레이터에서 309 워드의 메모리를 사용합니다. (SMP 지원 및 HiPE 지원 모두이 크기에 추가됩니다.) 크기는 다음과 같이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">좋은 특징은 노드 정보를 포함하는 테스트 사양을 여전히 일반 &lt;code&gt;Common Test&lt;/code&gt; 서버 에 대한 입력으로 사용할 수 있다는 것 입니다 ( &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 ). 결과적으로 문제의 &lt;code&gt;Common Test&lt;/code&gt; 노드 와 동일한 이름을 가진 노드 (일반적으로 &lt;code&gt;ct_run&lt;/code&gt; 프로그램으로 시작한 경우 &lt;code&gt;ct@somehost&lt;/code&gt; 에서 실행되도록 지정된 테스트 가 수행됩니다. 물론 명시적인 노드 연결이없는 테스트도 항상 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">노드가 충돌 할 수 있습니다 (아마도 버그가있는 노드이므로 추적 됨). 노드가 다시 돌아올 때 자동으로 추적을 재개 하려면 &lt;code&gt;resume&lt;/code&gt; 을 사용하십시오 . 실패한 노드 는 &lt;code&gt;Runtime_Tools&lt;/code&gt; 가 시작될 때 추적 제어 노드에 다시 연결을 시도합니다 . 이는 &lt;code&gt;Runtime_Tools&lt;/code&gt; 가 다른 노드의 시작 체인에 포함되어 있어야 함을 의미합니다 (그렇지 않은 경우, RPC 호출에 의해 &lt;code&gt;Runtime_Tools&lt;/code&gt; 를 수동으로 시작하여 추적을 재개 할 수 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">노드는 EPMD를 통해 (다른 호스트에서) 다른 노드의 포트 번호를 가져와 연결 요청을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map_expr&lt;/code&gt; 유형의 노드는 인수가 없고 필드가없는 경우에만 리프 노드입니다. &lt;code&gt;map_type&lt;/code&gt; 유형의 노드는 필드 ( &lt;code&gt;any_size&lt;/code&gt; ) 가없는 경우에만 리프 노드 입니다. &lt;code&gt;tuple&lt;/code&gt; 유형의 노드는 arity가 0 인 경우에만 리프 노드입니다. &lt;code&gt;tuple_type&lt;/code&gt; 유형의 노드는 요소가없는 경우 ( &lt;code&gt;any_size&lt;/code&gt; ) 리프 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">Windows에서 실행중인 노드는 실행중인 호스트에서만 슬레이브 노드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">이 방법으로 시작된 노드는 분배 프로토콜로 TLS를 사용하여 완전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">이 방법으로 시작된 노드는 IPv6을 통한 SSL / TLS 배포를 사용하는 다른 노드와 만 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-hidden&lt;/code&gt; ( &lt;code&gt;erl(1)&lt;/code&gt; 참조)으로 시작된 노드 는 &lt;strong&gt;숨겨진&lt;/strong&gt; 노드 라고 합니다. 숨겨진 노드는 동일한 글로벌 그룹의 일부가 아닌 동일한 글로벌 그룹의 노드에 대한 일반 (보이는) 연결에 대한 숨겨진 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">노드는 등록시 설정된 EPMD에 대한 TCP 연결을 닫아 EPMD에서 자체 등록을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">노드 이름이 긴 노드는 노드 이름이 짧은 노드와 통신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">&lt;code&gt;Name@Host&lt;/code&gt; 라는 이름 의 노드가 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">함수에서 로컬이 아닌 리턴. &lt;code&gt;catch&lt;/code&gt; 내에서 평가 되면 &lt;code&gt;catch&lt;/code&gt; 는 &lt;code&gt;Any&lt;/code&gt; 값을 반환합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">비단 자 범주는 문법 규칙 의 왼쪽 (= &lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;head&lt;/code&gt; ) 에서 사용할 수 있습니다 . 규칙의 오른쪽에 나타날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">구문 트리 의 비어 있지 않은 목록 &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; 이것은 &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; 를 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">구문 트리의 목록 비어 있지 않은 목록 &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; , 통과에 상당하는 &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">일반 파일은 실제로 프로세스이므로 I / O 장치로 사용할 수 있습니다 ( &lt;code&gt;io&lt;/code&gt; 참조 ). 따라서 데이터가 일반 파일에 기록 될 때 파일 프로세스로 데이터를 보내면 이진이 아닌 모든 데이터가 복사됩니다. 따라서 바이너리 모드에서 파일을 열고 바이너리를 작성하는 것이 좋습니다. 파일이 다른 노드에서 열리거나 파일 서버가 다른 노드의 파일 서버에 대한 슬레이브로 실행되면 바이너리도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">OTP를 실행하는 내장 된 Windows NT에는 서비스 팩 4 이상과 함께 Windows NT 4.0을 정상적으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">일반적인 스케줄러 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">주목할만한 리턴 값은 소켓이 닫 혔음을 나타내는 &lt;code&gt;{error, closed}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">디코딩 할 형식의 부분을 알려주는 표기법</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">메시지 구조에서 디코딩에서 제외 할 부분을 알려주는 표기법</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">경고주의 사항 : 원격 함수의 이름이 내장 함수에 전달 될 때 이고르 사건에 대해 아무것도 할 수 없습니다 &lt;code&gt;apply&lt;/code&gt; 하고 &lt;code&gt;spawn&lt;/code&gt; &lt;strong&gt;하지 않는&lt;/strong&gt; 모듈 및 기능 이름이 명시 적으로 호출에 명시되어 예에서와 같이하는 &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; . 다른 모든 경우에 Igor는 이러한 호출을 변경하지 않고 수동 편집이 필요할 수 있음을 사용자에게 경고합니다.</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">알림 필터는 &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; 동작을 구현하는 모듈 입니다. &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 필터가 추가 / 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">nullary 기능 값 (즉, 인수가 0 인 재미) 예 :</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">해당 함수 내에서 해당 재미의 숫자를 나타내는 숫자 (0으로 시작)</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 응용 프로그램이 작동하려면 많은 개체가 있어야합니다. 선택한 객체는 기본적으로 파일에 저장됩니다. 기본 이름, 경로 및 파일 형식은 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 와 동일 합니다 . OpenSSH 의 &lt;code&gt;ssh-keygen&lt;/code&gt; 프로그램으로 키를 생성 할 수 있습니다 . 사용 &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">응용 프로그램에 대한 한 줄 설명.</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">one-shot 타이머, 즉 &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; 함수를 평가하여 작성된 타이머 가 연결되지 않았습니다. 어떤 프로세스. 따라서 이러한 타이머는 시간 초과에 도달하거나 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 호출로 명시 적으로 제거 된 경우에만 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">패킷은 구분 기호 바이트로 끝나는 행이며 기본값은 라틴 -1 개행 문자입니다. &lt;code&gt;line_length&lt;/code&gt; 옵션에 따라 행이 잘리지 않으면 분리 문자 바이트가 리턴 된 패킷에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; 쌍 . 여기서 &lt;code&gt;LineNumber&lt;/code&gt; 는 음이 아닌 정수이고 &lt;code&gt;SimpleTest&lt;/code&gt; 는 또 다른 간단한 테스트 오브젝트입니다. &lt;code&gt;LineNumber&lt;/code&gt; 는 테스트의 소스 라인을 나타내야합니다. 이와 같은 쌍은 일반적으로 &lt;code&gt;?_test(...)&lt;/code&gt; 매크로 를 통해서만 생성됩니다 . &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">병렬 테스트 케이스에는 그룹 리더로서 개인 I / O 서버가 있습니다. (그룹 리더 개념에 대한 설명은 &lt;code&gt;ERTS&lt;/code&gt; 를 참조하십시오 ). 일반 테스트 케이스 및 구성 기능의 출력을 처리하는 중앙 I / O 서버 프로세스는 병렬 그룹을 실행하는 동안 I / O 메시지에 응답하지 않습니다. 다음과 같은 특정 트랩을 피하려면 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">매개 변수화 된 유형은 임베디드 유형으로 간주됩니다. 이러한 유형이 참조 될 때마다 해당 유형의 인스턴스가 정의됩니다. 따라서 다음 예에서 이름이 &lt;code&gt;'Seq_b'&lt;/code&gt; 인 레코드 는 &lt;code&gt;.hrl&lt;/code&gt; 파일 에서 생성되며 값을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">괄호로 묶인 하위 패턴 (어설 션 포함)</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">재미있는 구문을 일치 스펙으로 변환하는 구문 분석 변환입니다.</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부분 배달 실패 Erlang / SCTP 바인딩의 현재 구현에서이 이벤트는 내부적 으로 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;error&lt;/code&gt; 용어로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">프로파일 링 범위를 좁히기 위해 패턴을 선택할 수 있습니다. 예를 들어 특정 모듈을 선택할 수 있으며 해당 모듈에서 실행 된 코드 만 프로파일 링됩니다.</target>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">패턴은 용어와 구조는 동일하지만 언 바운드 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">패턴은 다음을 포함 할 수있는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">특정 레코드와 일치하는 패턴은 레코드가 작성되는 것과 같은 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">연결을 시작할 때 피어의 DiameterIdentity는 필요하지 않습니다. 식별은 기능 교환시 수신되며,이 때 ID가 불쾌 할 경우 연결을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">모든 데이터 유형의 데이터를 &lt;strong&gt;용어&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">작성된 스레드에서 실행할 함수에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">스레드 식별자 변수에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">정수를 가리키는 포인터. 정수는 입력 및 출력 크기를 전달하는 데 사용됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">출력 버퍼에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">다른 포트 구조에 대한 포인터.이 포트는 연결을 허용하는 청취 포트이거나 반대로입니다. &quot;파트너 관계&quot;는 항상 양방향입니다.</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 함수 에 대한 인수를 가리키는 포인터 .</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 의 내용에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">NIF를 구현하는 함수에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">사용할 스레드 옵션에 대한 포인터 또는 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">바이트 목록 대신 바이너리를 사용하도록 포트를 설정할 수 있습니다. 그러면 인코딩 / 디코딩 체계를 발명 할 필요가 없습니다. Erl_Interface 함수는 바이너리 압축을 풀고 Erlang 용어와 유사한 구조체로 변환하는 데 사용됩니다. 이러한 구조체는 다른 방식으로 조작하고 Erlang 외부 형식으로 변환하여 Erlang으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금은 참조 횟수로 계산되며 참조 횟수가 0에 도달하면 소멸됩니다. 에뮬레이터는 잠금이 작성 될 때 최소한 참조 횟수를 한 번 증가시키고 잠금과 연관된 포트가 종료되면이를 감소시킵니다. 또한 에뮬레이터는 비동기 작업이 대기열에있을 때 참조 횟수를 증가시키고 비동기 작업이 호출 될 때 참조 횟수를 감소시킵니다. 또한 드라이버는 드라이버가 마지막으로 잠금을 사용하기 전에 참조 카운트가 0에 도달하지 않도록해야합니다. 참조 카운트는 각각 &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; 에 의해 읽히고, 증가 및 감소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">포트 드라이버는 Erlang 프로그램에서 포트로 액세스 할 수있는 링크 된 드라이버입니다. 특별한 진입 점이있는 공유 라이브러리 (UNIX의 경우 SO, Windows의 경우 DLL)입니다. Erlang 런타임 시스템은 드라이버가 시작되고 데이터가 포트로 전송 될 때 이러한 진입 점을 호출합니다. 포트 드라이버는 데이터를 Erlang으로 전송할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">포트 식별자는 Erlang 포트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">포트 식별자는 포트 테이블과 노드 테이블을 나타내며 메모리도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">포트 식별자. 포트 ID 조건 (인스턴스 달리 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; ) &lt;code&gt;ErlNifPort&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPort&lt;/code&gt; 는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">청취 소켓에 연결된 포트입니다. 이 포트는 많은 작업을 수행하지 않고이 소켓에서 데이터 펌핑이 수행되지 않지만 포트에서 승인을 시도 할 때 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">양의 정수 또는 &lt;code&gt;infinity&lt;/code&gt; 는 기본적으로 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">양의 정수 또는 원자 &lt;code&gt;undefined_serial&lt;/code&gt; (메시지가 전송 되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">이 포맷터에서 반환 된 문자열이 가질 수있는 절대 최대 크기를 나타내는 양의 정수입니다. 형식화 된 문자열이 더 길면 가능한 경우 &lt;code&gt;chars_limit&lt;/code&gt; 또는 &lt;code&gt;depth&lt;/code&gt; 로 제한된 후 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">용어가이 포맷터에 의해 인쇄 될 최대 깊이를 나타내는 양의 정수. 이 포맷터에 전달 된 형식 문자열이 다시 작성됩니다. 형식 제어 ~ p 및 ~ w는 각각 ~ P 및 ~ W로 대체되며 값은 깊이 매개 변수로 사용됩니다. 자세한 내용 은 STDLIB의 &lt;code&gt;io:format/2,3&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io_lib:format/3&lt;/code&gt; 을 호출 할 때 사용할 이름과 동일한 옵션 값을 나타내는 양의 정수 . 이 값은 각 로그 이벤트에 대해 인쇄되는 총 문자 수를 제한합니다. 이것은 소프트 한계입니다. 하드 자르기 제한에 대해서는 &lt;code&gt;max_size&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">양의 정수이며 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">시스템의 &lt;code&gt;sequential_tracer&lt;/code&gt; 에서 가능한 출력은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">술어 &lt;code&gt;Big(X)&lt;/code&gt; 가 정의 되며 인수가 10보다 크면 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">술어는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 함수입니다 . &lt;code&gt;any&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 텀이 경우 &lt;code&gt;X&lt;/code&gt; 되도록리스트 &lt;code&gt;P(X)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">접두어는 선택 사항이지만 다른 직경 응용 프로그램에서 비슷한 이름의 메시지와 AVP로 인해 레코드와 상수 이름을 명확하게 구분하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">이전에로드 된 모듈에는 완료되지 않은 &lt;code&gt;-on_load&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">한 노드에서 복제 된 테이블이 시작되었지만 &lt;code&gt;Mnesia&lt;/code&gt; 는 다른 (원격) 복제본이 로컬 노드에있는 복제본보다 최신 버전이라고 추론하고 초기화 절차가 진행되지 않는 경우 문제가 발생할 수 있습니다 . 이 상황에서 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; 에 대한 호출은 원격 노드가 로컬 디스크에서 테이블을 초기화하고 노드가 네트워크를 통해 테이블을 로컬 노드에 복사 할 때까지 호출자를 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; , &lt;code&gt;spawn_link&lt;/code&gt; , &lt;code&gt;spawn_monitor&lt;/code&gt; 또는 &lt;code&gt;spawn_opt&lt;/code&gt; 호출 프로세스는 호출 완료 후 즉시 스케줄됩니다. 더 높은 수정 된 타이밍 레벨이 사용되면, 호출자는 스케줄 된 후 잠시 동안 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 &lt;code&gt;normal&lt;/code&gt; 아닌 다른 종료 이유가있는 종료 신호를 수신하면 프로세스를 종료 할 수도 있습니다 ( &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">프로세스는 함수 &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; 호출 할 수도 있습니다 . 종료 이유 &lt;code&gt;Reason&lt;/code&gt; 가 &lt;code&gt;Pid&lt;/code&gt; 로 방출되는 종료 신호 가 발생 하지만 호출 프로세스에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">다음을 호출하여 종료 신호를 트랩하도록 프로세스를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">프로세스는 여러 프로세스에 의해 일시 중단 될 수 있으며 단일 프로세스에 의해 여러 번 일시 중단 될 수 있습니다. 일시 중단 된 프로세스는 일시 중단 횟수가 0에 도달 할 때까지 일시 중단 된 상태를 벗어나지 않습니다. &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; 와 동일한 프로세스에서 &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; 를 호출 하면 &lt;code&gt;Suspendee&lt;/code&gt; 의 일시 중단 횟수 가 줄어 듭니다 . 프로세스에 의해 획득 된 다른 프로세스에 대한 증가 된 일시 중단 횟수는 프로세스가 종료 될 때 자동으로 감소합니다.</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">프로세스는 다음 BIF 중 하나를 호출하여 자체적으로 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">프로세스는 &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; 호출하여 테이블을 수정합니다 . &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; 를 호출하여 프로세스가 해제 할 때까지 또는 프로세스가 종료 될 때까지 테이블은 고정 된 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">프로세스 식별자 (pid) PID 용어는 달리 (인스턴스 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 는 ) &lt;code&gt;ErlNifPid&lt;/code&gt; 의 S 자 급식하고 결합하지 않은 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ErlNifPid&lt;/code&gt; 는 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 와 같은 프로세스 식별자 . 재미가 만들어진 과정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">프로세스 식별자는 메모리를 소비하는 프로세스 테이블과 노드 테이블을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">프로세스 식별자 인 pid는 프로세스를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">감독 트리의 프로세스는 상위와 같은 이유로 종료 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 을 호출하여 프로세스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">프로세스가 프로세스 를 시작하는 데 사용 된 하위 스펙 의 &lt;code&gt;Modules&lt;/code&gt; 부분에 &lt;code&gt;Mod&lt;/code&gt; 가 나열된 경우 프로세스는 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 &lt;strong&gt;사용&lt;/strong&gt; 한다고합니다 &lt;code&gt;supervisor(3)&lt;/code&gt; 참조 ) . &lt;code&gt;gen_event&lt;/code&gt; 의 경우 , &lt;code&gt;Mod&lt;/code&gt; 가 설치된 이벤트 핸들러 인 경우 이벤트 관리자 프로세스는 &lt;code&gt;Mod&lt;/code&gt; 를 사용한다고 합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">종료 이유가 원자 &lt;code&gt;normal&lt;/code&gt; 경우 프로세스가 &lt;strong&gt;정상적으로&lt;/strong&gt; 종료된다고합니다 . 더 이상 실행할 코드가없는 프로세스는 정상적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">이러한 기능 중 하나를 사용하여 시작된 프로세스는 감독 트리의 프로세스에 필요한 정보 (예 : 조상 및 초기 호출)를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">더 이상 할 일이 없으면 프로세스가 종료됩니다. 즉, 마지막으로 호출하는 함수는 단순히 반환하고 다른 함수를 호출하지 않습니다. 프로세스를 종료하는 또 다른 방법은 &lt;code&gt;exit/1&lt;/code&gt; 을 호출하는 것 입니다. &lt;code&gt;exit/1&lt;/code&gt; 에 대한 인수 는 특별한 의미를 갖습니다. 이는 나중에 설명합니다. 이 예에서는 &lt;code&gt;exit(normal)&lt;/code&gt; 가 수행되며 호출 할 함수가 부족한 프로세스와 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임 오류가 발생 하면 종료 이유 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 으로 프로세스가 종료 됩니다. &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">가입 한 프로세스 는 그룹 노드가 각각 연결 또는 연결 해제 될 때 &lt;code&gt;{nodeup, Node}&lt;/code&gt; 및 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">수명이 짧은 데이터가있는 프로세스는 거의 사용되지 않거나 전혀 사용되지 않습니다. 즉, 이전 힙에 대부분 가비지가 포함됩니다. 풀 스윕을 가끔씩하려면 &lt;code&gt;Number&lt;/code&gt; 를 10 또는 20과 같은 적절한 값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">종료하는 프로세스 는 &lt;strong&gt;종료 이유&lt;/strong&gt; 가 있는 &lt;strong&gt;종료 신호&lt;/strong&gt; 를 발생시켜 어떤 오류가 발생했는지 알려줍니다. 일반적으로 오류에 대한 일부 정보는 터미널에 인쇄됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">프로세스의 이름이 프로세스의 하위 스펙에있는 &lt;code&gt;Modules&lt;/code&gt; 에 나열된 경우 프로세스는 모듈을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">런타임 오류 (예 : 0으로 나누기, 일치하지 않음, 존재하지 않는 함수를 호출하려고 시도하는 등)가 발생하는 프로세스는 오류로 종료됩니다. 즉, &lt;strong&gt;비정상&lt;/strong&gt; 종료입니다. 실행하는 프로세스 &lt;code&gt;exit(Reason)&lt;/code&gt; &lt;code&gt;Reason&lt;/code&gt; 원자를 제외한 얼랑 용어 &lt;code&gt;normal&lt;/code&gt; 또한 비정상적인 종료를 갖는다.</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">&lt;code&gt;exit(normal)&lt;/code&gt; 를 실행하거나 단순히 수행 할 작업이 부족한 프로세스 에는 &lt;strong&gt;정상&lt;/strong&gt; 종료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">프로세스 바운드 환경에는 호출 Erlang 프로세스에 대한 임시 정보가 포함됩니다. 환경은 NIF가 리턴 될 때까지 인수로 제공된 스레드에서만 유효합니다. 따라서 NIF 호출 사이에 프로세스 바운드 환경에 대한 포인터를 저장하는 것은 쓸모없고 위험합니다.</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">해당 테스트를 통과해야하는 코드를 구현 &lt;strong&gt;하기 전에&lt;/strong&gt; 테스트를 지속적으로 작성하는 프로그램 개발 기술 입니다. 이를 통해 단위 테스트에서 프로그램이 &quot;완료된&quot;시기를 결정하게하여 올바른 문제를 해결하는 데 집중하고 필요 이상으로 복잡한 구현을 수행 할 수 있습니다. 사양이 충족되면 기능을 계속 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">프로그램은 데이터 위치에 관계없이 작동합니다. 데이터가 로컬 노드에 있는지 또는 원격 노드에 있는지는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">쉘에서 코드를 실행할 수만 있다면 프로그래밍 언어는 많이 사용되지 않습니다. 여기 작은 Erlang 프로그램이 있습니다. 적절한 텍스트 편집기를 사용하여 &lt;code&gt;tut.erl&lt;/code&gt; 파일에 파일을 입력하십시오 . 파일 이름 &lt;code&gt;tut.erl&lt;/code&gt; 은 중요하며 또한 &lt;code&gt;erl&lt;/code&gt; 을 시작한 디렉토리와 동일한 디렉토리에 있습니다 . 운이 좋으면 편집기에 코드를 쉽게 입력하고 형식을 쉽게 지정할 수 &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; 있지만 (도구 사용자 안내서의 Emacs 용 Erlang 모드 참조), 완벽하게 관리 할 수 ​​있습니다. 입력 할 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">감독자가 자녀를 시작하거나 다시 시작할 때 진행 보고서가 발행됩니다. 진행 보고서에는 다음 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">위 의 &lt;code&gt;tos&lt;/code&gt; 와 같은 프로토콜 독립적 . 우선 순위를 설정하면 설정을 의미한다 &lt;code&gt;tos&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하는 프록시 인증 헤더가 요청에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의사 터미널이 세션에 요청되었습니다. &lt;code&gt;Terminal&lt;/code&gt; 은 TERM 환경 변수 값의 값, 즉 &lt;code&gt;vt100&lt;/code&gt; 입니다. 제로 치수 매개 변수는 무시해야합니다. 문자 / 행 치수는 픽셀 치수보다 우선합니다 (0이 아닌 경우). 픽셀 치수는 창의 드로어 블 영역을 나타냅니다. &lt;code&gt;TerminalModes&lt;/code&gt; 목록의 &lt;code&gt;Opcode&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; , 섹션 8에 정의 된 소문자 Erlang 원자로 표시되는 니모닉 이름입니다. 니모닉 이름이 RFC에 나열되지 않은 경우 &lt;code&gt;Opcode&lt;/code&gt; 일 수도 있습니다 . 예 : &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; . 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">한정자 Q는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">쿼리 핸들은 다음 순서로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">Raw 옵션 요청 &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; 을 사용하여 에뮬레이터에서 지원하지 않는 소켓 옵션에 대한 정보를 얻을 수 있습니다. 원시 소켓 옵션을 사용하면 코드를 이식 할 수 없지만 Erlang 프로그래머는 현재 플랫폼에있는 비정상적인 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">처음 사용하는 사용자에게 권장되는 시작점은 &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; 데이터 유형 및 함수 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">레코드 정의는 모듈의 속성 및 함수 선언 중 어디에나 배치 할 수 있지만 정의는 레코드를 사용하기 전에 이루어져야합니다.</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">레코드 정의는 레코드 이름과 레코드의 필드 이름으로 구성됩니다. 레코드 및 필드 이름은 원자 여야합니다. 각 필드에는 선택적 기본값이 제공 될 수 있습니다. 기본값이 제공 &lt;code&gt;undefined&lt;/code&gt; 않으면 undefined 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; 로 레코드가 삭제되었을 수 있습니다 . &lt;code&gt;OldRecord&lt;/code&gt; 는 응용 프로그램에서 인수로 언급 한대로 이전 레코드의 값을 포함합니다. &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 동일한 키를 가진 다른 레코드가 테이블에 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">레코드는 고정 된 수의 요소를 저장하기위한 데이터 구조입니다. 필드의 이름을 지정했으며 C의 구조체와 비슷합니다. 그러나 레코드는 실제 데이터 형식이 아닙니다. 대신, 레코드 표현식은 컴파일 중에 튜플 표현식으로 변환됩니다. 따라서 특별한 조치를 취하지 않으면 쉘은 레코드 표현식을 이해하지 못합니다. 자세한 내용 은 STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">레코드는 고정 된 수의 요소를 저장하기위한 데이터 구조입니다. 필드 이름이 지정되었으며 C의 구조체와 유사합니다. 레코드 표현식은 컴파일 중에 튜플 표현식으로 변환됩니다. 따라서 특별한 조치를 취하지 않으면 쉘은 레코드 표현식을 이해하지 못합니다. 자세한 내용 은 STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">레코드는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">직원을 설명하는 레코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">참조는 Erlang 런타임 시스템에서 고유 한 용어로 &lt;code&gt;make_ref/0&lt;/code&gt; 을 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">참조는 메모리를 소비하는 노드 테이블을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">등록 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">등록 된 전송 조작이 발생했으며 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 에 발신자의 pid가 포함되어 있습니다. 메시지는 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">등록 된 전송 조작이 발생했습니다. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 은 발신자의 pid 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">이전에 &lt;code&gt;ei_reg_open()&lt;/code&gt; 으로 작성된 레지스트리 가 닫히고 여기에 포함 된 모든 오브젝트가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">Erlang 용 정규 표현식 기반 어휘 분석기 생성기로서 lex 또는 flex와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">정규식은 왼쪽에서 오른쪽으로 제목 문자열과 일치하는 패턴입니다. 대부분의 문자는 패턴으로 표시되며 주제의 해당 문자와 ​​일치합니다. 간단한 예로, 다음 패턴은 제목 문자열의 일부와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">X의 모든 원소 x에 대해 x R x이면 X의 관계 R은 &lt;strong&gt;반사적&lt;/strong&gt; 이며, x R y가 y R x를 암시하면 &lt;strong&gt;대칭&lt;/strong&gt; 이며, x R y 및 y R z가 x R z를 암시하면 &lt;strong&gt;전 이적&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">세트의 관계는 그것이 반사적이고 대칭 적이며 전 이적이라면 &lt;strong&gt;등가 관계&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">통신 애플리케이션에 적합한 관계형 / 개체 하이브리드 데이터 모델.</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">릴리스 패키지에는 다음이 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">릴리즈 패키지는 항상 다음을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">릴리즈 리소스 파일 인 &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">이형 업그레이드 파일, &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">출시 된 응용 프로그램은 특정 구조를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">relup 스크립트는 하나의 &lt;code&gt;restart_emulator&lt;/code&gt; 명령 만 가질 수 있으며 항상 끝에 배치해야합니다. reltools가 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성되면 자동으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">원격 Erlang 파일 서버를 사용할 수 없습니다. Erlang 노드가 실행중인 컴퓨터는 파일 시스템 (직접 또는 NFS를 통해)에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">신호로 인해 원격 실행이 심하게 종료 될 수 있습니다. 그러면이 메시지를받을 수 있습니다. 유효한 문자열 값에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 섹션 6.10을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">X의 Y에 pid, 포트, 참조 또는 fun (Erlang 데이터 유형)이 있거나 X와 Y가 연결된 경우 원격 노드 Y를 노드 X에 알려야합니다. 동시에 / 노드에 알려진 최대 원격 노드 수는 노드 이름에 사용 가능한 &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; 수에 의해 제한됩니다 . 노드 이름 atom을 제외한 원격 노드와 관련된 모든 데이터는 가비지 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">이 기능과 함께 전송 된 응답은 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 디버그 출력에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">포맷터는 보고서 콜백을 사용하여 보고서 양식의 로그 메시지를 형식 문자열 및 인수로 변환합니다. 보고서 콜백은 로그 이벤트의 메타 데이터에 지정할 수 있습니다. 메타 데이터에 보고서 콜백이 없으면 &lt;code&gt;logger_formatter&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; 을 기본 콜백으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">이진에서 부품 (또는 범위)을 나타냅니다. &lt;code&gt;Start&lt;/code&gt; 은 &lt;code&gt;binary()&lt;/code&gt; 대한 0부터 시작 하는 오프셋 이며 &lt;code&gt;Length&lt;/code&gt; 는 해당 부분의 길이입니다. 이 모듈의 기능에 대한 입력으로, 음수 &lt;code&gt;Length&lt;/code&gt; 로 구성된 반전 부품 지정이 허용 되므로 2 진 부분이 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; 에서 시작 하고 &lt;code&gt;Length&lt;/code&gt; 길어집니다. 이진 의 마지막 &lt;code&gt;N&lt;/code&gt; 바이트를 &lt;code&gt;{size(Binary), -N}&lt;/code&gt; 참조 할 때 유용합니다 . 이 모듈의 함수는 항상 양의 &lt;code&gt;Length&lt;/code&gt; 를 가진 &lt;code&gt;part()&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">프리티 프린터의 현재 상황을 나타냅니다. 후크 기능으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">http://your.server.org/cgi-bin/example/httpd_example:yahoo에 대한 요청은 httpd_example : yahoo / 3를 참조하거나 존재하지 않는 경우 httpd_example : yahoo / 2 및 http : // your을 나타냅니다. server.org/cgi-bin/example/other:yahoo는 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">DPR에 대한 응답으로 DPA를받은 후 전송 프로세스 종료 요청. 전송 프로세스가 종료되어야합니다. &lt;code&gt;Pid&lt;/code&gt; 는 부모 프로세스의 pid ()입니다.</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">구성 파일에서 변수를 찾을 수없는 경우 필요한 변수에 기본값을 지정할 수도 있습니다. 기본값을 지정하려면 &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; 형식의 튜플을 테스트 케이스 정보 목록에 추가하십시오 (목록의 위치는 관련이 없음).</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">자원 용어는 &lt;code&gt;term_to_binary&lt;/code&gt; 로 직렬화 할 수 있으며 &lt;code&gt;binary_to_term&lt;/code&gt; 이 호출 될 때 자원 오브젝트가 여전히 활성 상태이면 나중에 완전히 다시 작성됩니다 . &lt;strong&gt;부실&lt;/strong&gt; 리소스 용어에서 반환됩니다 &lt;code&gt;binary_to_term&lt;/code&gt; 자원 객체가 해제 된 경우. 부실 리소스 조건에 대해서는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 가 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">관리 할 자원은 MIB에 상주하는 관리 대상 오브젝트로 표시됩니다. SNMP MIB에서 관리 대상 객체는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 된 오류 이유는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 읽을 수있는 문자열로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">기초적인 DNS 클라이언트.</target>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:error(Reason)&lt;/code&gt; 또는 &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; 를 호출하여 런타임 오류를 에뮬레이트 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">런타임 오류는 class &lt;code&gt;error&lt;/code&gt; 예외의 다른 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">런타임 오류는 충돌이 발생할 때입니다. 예를 들어 연산자가 잘못된 유형의 인수에 적용되는 경우가 있습니다. Erlang 프로그래밍 언어에는 런타임 오류 처리를위한 기능이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">런타임 시스템 잠금 프로파일 링 도구.</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">백 슬래시를 두 번째로 사용하면 인쇄 할 수없는 문자를 패턴으로 시각적으로 인코딩하는 방법이 제공됩니다. 패턴을 종료하는 2 진 0을 제외하고 비 인쇄 문자의 모양에는 제한이 없습니다. 텍스트 편집으로 패턴을 준비 할 때, 이진 문자보다 다음 이스케이프 시퀀스 중 하나를 사용하는 것이 더 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">구성 파일을 지정하는 두 번째 방법은 환경 변수 &lt;code&gt;ERL_INETRC&lt;/code&gt; 를 파일의 전체 이름으로 설정하는 것입니다. 예 (bash) :</target>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">&lt;code&gt;utf16&lt;/code&gt; 유형의 세그먼트는 2 진에서 2 또는 4 바이트와 일치 할 수 있습니다. 일치 위치의 바이너리에 유니 코드 코드 포인트의 유효한 UTF-16 인코딩이 포함되어 있지 않으면 일치가 실패합니다. RFC-2781 또는 유니 코드 표준을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">&lt;code&gt;utf32&lt;/code&gt; 유형의 세그먼트 는 &lt;code&gt;integer&lt;/code&gt; 세그먼트가 32 비트와 동일한 방식으로 2 진에서 4 바이트를 일치 시킬 수 있습니다 . 결과 정수가 위에서 언급 한 법적 범위를 벗어나면 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">일치 위치의 이진에 유효한 UTF-8 시퀀스가 ​​포함 된 경우 &lt;code&gt;utf8&lt;/code&gt; 유형의 세그먼트가 이진의 1-4 바이트와 일치합니다. RFC-3629 또는 유니 코드 표준을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">receive 문이 &lt;code&gt;gen_*&lt;/code&gt; 엔진 자체에 있기 때문에 &lt;code&gt;gen_*&lt;/code&gt; 동작과 마찬가지로 &lt;code&gt;gen_statem&lt;/code&gt; 동작 에서 선택적 수신을 사용할 수 없습니다 . 모든 &lt;code&gt;sys&lt;/code&gt; 호환 가능 동작은 시스템 메시지에 응답해야하므로 엔진 수신 루프에서 비 시스템 메시지를 콜백 모듈로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">시퀀스 그룹에는 하위 그룹이있을 수 있습니다. 이러한 부분 군은 임의의 특성을 가질 수 있는데, 즉 이들은 또한 서열 일 필요는 없다. 하위 그룹의 상태가 위 레벨의 순서에 영향을 미치려면 테스트 스위트 작성의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 를 리턴 하십시오 . 실패한 하위 그룹 ( &lt;code&gt;Status == failed&lt;/code&gt; )으로 인해 테스트 케이스와 동일한 방식으로 시퀀스 실행이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 테스트 사례는 &lt;code&gt;sequence&lt;/code&gt; 속성이 있는 테스트 사례 그룹으로 정의됩니다 . 테스트 케이스 그룹은 테스트 스위트에서 기능 &lt;code&gt;groups/0&lt;/code&gt; 을 통해 정의됩니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">서버 (데몬)는 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; 로 시작 됩니다. 데몬이 시작될 때 가능한 채널 핸들러 (서브 시스템)가 &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; 옵션으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">서버는 &lt;code&gt;verify_peer&lt;/code&gt; 모드에서 x509-path 유효성 검사 만 수행 하고 클라이언트에게 인증서 요청을 보냅니다 (이 옵션은 verify 옵션이 &lt;code&gt;verify_none&lt;/code&gt; 이면 전송되지 않습니다 ). 그런 다음 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; 옵션을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">결코 유휴 상태가되지 않을만큼의 요청 만받는 서버는 CPU 사용률이 100 %입니다. 서버가 50 % 더 많은 요청을 받으면 여전히 100 %의 점수를받습니다. 앞에서 설명한 백분율 공식을 사용하여 시스템로드를 계산하면로드가 80 %에서 87 %로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">서버 또는 클라이언트 채널 프로세스는 닫기 이벤트를 전송하여 세션을 닫도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서버 측 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; (채널) 서버는 클라이언트가 ssh_connection : subsystem / 4를 사용 하여 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서비스는 로컬로 구현 된 Diameter 노드를 정의하여 기능 교환 중에 보급 할 기능을 지정합니다. &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송이 서비스에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">서비스는 지원하려는 각 Diameter 응용 프로그램마다 하나의 튜플을 구성해야합니다. 발신 요청의 경우 관련 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 전달되는 반면 수신 요청의 경우 메시지 헤더의 애플리케이션 식별자가 애플리케이션을 결정하며 애플리케이션의 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; 파일 에 지정된 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">&lt;code&gt;stand_alone&lt;/code&gt; 으로 시작된 서비스 , 즉 서비스가 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램의 일부로 시작되지 않으면 소프트 업그레이드와 같은 모든 OTP 응용 프로그램의 이점을 잃게됩니다. &lt;code&gt;stand_alone&lt;/code&gt; 의 - 서비스가 먼저 시작 프로세스에 연결되어 있습니다. 일반적으로 일부 감독 기능이 여전히 존재하며 어떤 의미에서는 통화 프로세스가 최고 감독자가됩니다.</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">공유 피어를 사용하지 않는 서비스는 항상 빈 목록을 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백 의 두 번째 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">내부적으로 포맷 된 랩 디스크 로그를 읽는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이런 방식으로 열린 세션은 함수 &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 사용하여 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">강력하게 연결된 컴포넌트 간의 호출 세트는 &lt;code&gt;ComponentCall&lt;/code&gt; 과 중복되지 않은 정렬 된 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">일련의 호출은 &lt;code&gt;call()&lt;/code&gt; 중복없이 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">상수 세트는 &lt;code&gt;constant()&lt;/code&gt; 중복없이 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">원격 파일에 저장 될 파일의 ​​연속 부분을 송수신하기위한 기능 세트가 제공됩니다. send에 대해서는 &lt;code&gt;send_chunk_start/2&lt;/code&gt; , &lt;code&gt;send_chunk/2&lt;/code&gt; 및 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 을 참조하십시오 . 수신은 &lt;code&gt;recv_chunk_start/2&lt;/code&gt; 및 &lt;code&gt;recv_chunk/&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">일련 번호가 지정된 함수 호출은 &lt;code&gt;CallAt&lt;/code&gt; 와 중복되지 않은 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">라인 번호가 지정된 함수 및 함수 호출 세트는 &lt;code&gt;AllLines&lt;/code&gt; 와 중복되지 않고 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">행 번호가 매겨진 함수 세트는 &lt;code&gt;DefineAt&lt;/code&gt; 와 중복되지 않은 정렬 된 목록으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">강력하게 연결된 컴포넌트 세트는 &lt;code&gt;Component&lt;/code&gt; 와 중복되지 않은 정렬 된 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블 세트가 작성됩니다. &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 함수 는 필요한 데이터베이스 테이블을 작성합니다. &lt;code&gt;ArgList&lt;/code&gt; 와 함께 사용할 수있는 옵션 은 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; 에서 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">구성 기능 및 실행 특성을 공유하는 테스트 케이스 세트입니다. 실행 속성은 그룹의 테스트 사례가 임의의 순서로, 병렬로 또는 순서대로 실행 될지 여부와 그룹의 실행이 반복되는지 여부를 지정합니다. 테스트 사례 그룹도 중첩 될 수 있습니다. 즉, 그룹은 테스트 사례 외에 하위 그룹을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 및 &lt;code&gt;report_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return_errors&lt;/code&gt; 및 &lt;code&gt;return_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">다음 메시지를 사용하여 원격 프로세스 / 서비스에 신호를 전달할 수 있습니다. 일부 시스템은 신호를 지원하지 않으므로이 메시지를 무시해야합니다. 참조 된 신호가 Erlang 프로그램에 의해 생성 된 것이 아니라 OS 레벨에 있으므로이 이벤트를 생성하는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">시간 표현을위한 부호있는 64 비트 정수 유형.</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">시간 표현을위한 부호있는 64 비트 정수 유형.</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">부호있는 정수 유형으로, &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">모듈 속성과 유사한 구문이 유형 및 기능 사양을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">런타임 성능에 미치는 영향을 최소화하기 위해 중단 점을 사용하는 간단한 통화 수 프로파일 링 도구입니다.</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">&lt;code&gt;connect_init&lt;/code&gt; API 를 사용하는 간단한 Erlang SCTP 클라이언트 :</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">외부 서버에 구성 데이터를 요청하는 간단한 구성 처리 드라이버는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">하위 에이전트없이 간단한 분산 에이전트를 관리 할 수 ​​있습니다. 인스 트루먼 테이션 기능은 분산 Erlang을 사용하여 응용 프로그램의 다른 부분과 통신 할 수 있습니다. 그러나 불필요한 트래픽을 너무 많이 생성하면 각 노드에서 하위 에이전트를 사용할 수 있습니다. 하위 에이전트는 변수가 아닌 들어오는 SNMP 요청마다 요청을 처리합니다. 따라서 네트워크 트래픽이 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">SNMP Development Toolkit의 관리자 구성 요소를 사용하는 방법에 대한 간단한 예.</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">새 관리자를 사용하여 에이전트 테스트 사례를 작성하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">간단한 예입니다. 단일 쿼드 코어 프로세서는 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">터미널에 인쇄하는 간단한 핸들러는 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">간단한 대화식 구성 도구입니다. 간단한 구성 파일을 생성 할 수 있지만 더 복잡한 구성은 여전히 ​​수동으로 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">간단한 해결책은 &lt;code&gt;idno&lt;/code&gt; 필드 대신 &lt;code&gt;name&lt;/code&gt; 필드를 키로 사용 하는 것이지만 이름이 고유하지 않으면 문제가 발생할 수 있습니다. 보다 일반적인 해결책은 &lt;code&gt;name&lt;/code&gt; 을 key로, &lt;code&gt;idno&lt;/code&gt; 를 데이터 로 사용하여 두 번째 테이블을 작성하는 것 , 즉 &lt;code&gt;name&lt;/code&gt; 필드 와 관련된 테이블을 색인화 (반전)하는 것 입니다. 분명히 두 번째 테이블은 마스터 테이블과 일관성을 유지해야합니다. Mnesia가이를 수행 할 수 있지만 Mbrewia 사용과 관련된 오버 헤드에 비해 가정용 추출 인덱스 테이블이 매우 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">입력에서 단일 &lt;code&gt;~&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">단일 아톰은 모듈 이름을 나타내며 &lt;code&gt;{module, ModuleName}&lt;/code&gt; . 이것은 종종 &lt;code&gt;eunit:test(some_module)&lt;/code&gt; 호출에서와 같이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;driver_output_binary()&lt;/code&gt; 로 단일 바이너리를 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">이전 요청에서와 같이 한 줄은 다음 &lt;code&gt;Request&lt;/code&gt; 과 함께 요청됩니다 .</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">단일 문자열은 파일 또는 디렉토리의 &lt;code&gt;Path&lt;/code&gt; 나타내며 파일 시스템에서 Path가 참조하는 내용에 따라 각각 &lt;code&gt;{file, Path}&lt;/code&gt; 또는 &lt;code&gt;{dir, Path}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">테스트 스위트에 포함 된 단일 테스트. 테스트 케이스는 테스트 스위트 모듈에서 함수로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">어떻게 든 고유하게 식별 할 수있는 잘 정의 된 단일 테스트입니다. 테스트 케이스가 실행되면 &lt;strong&gt;통과&lt;/strong&gt; 하거나 &lt;strong&gt;실패합니다&lt;/strong&gt; . 테스트 보고서는 실패한 테스트 사례를 정확히 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">알고리즘을 추가하는 것이 유용한 상황은 지원되지만 비활성화 된 알고리즘을 사용해야하는 경우입니다. 예를 들어 &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; 은 오늘날 매우 안전하지 않으므로 비활성화되어 있습니다. 그러나 여전히 지원되며 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">스켈레톤은 버퍼에 삽입 할 수있는 미리 작성된 코드입니다. 얼랭 모드는 사전 정의 된 스켈레톤 세트와 함께 제공됩니다. 스켈레톤은 표준 Emacs 패키지 &quot;tempo&quot;를 사용하여 정의 &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; 라는 명령의 Erlang 메뉴에서 스켈레톤에 액세스 할 수 있습니다 . 다음은 사용 가능한 스켈레톤에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">사용 된 절차의 스케치 :</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">덤프 이유를 나타내는 슬로건</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">N 바이트를 에코 하는 작은 &lt;code&gt;ssh&lt;/code&gt; 서브 시스템은 다음 예제와 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">실패한 각 테스트 사례에 대한 작은 메모.</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">실제로는 에뮬레이터 플래그 인 소수의 &quot;-&quot;플래그가 존재합니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">반환되는 문자 수에 대한 소프트 제한입니다. 문자 수에 도달하면 나머지 구조는 &quot; &lt;code&gt;...&lt;/code&gt; &quot; 로 바뀝니다 . &lt;code&gt;CharsLimit&lt;/code&gt; 의 기본값은 -1이며 반환되는 문자 수에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">A는 목록 분류 &lt;code&gt;{Node, Count}&lt;/code&gt; 증가에 분류되어 튜플 &lt;code&gt;Count&lt;/code&gt; 순서를. &lt;code&gt;Count&lt;/code&gt; 는이 조각난 테이블이 각 &lt;code&gt;Node&lt;/code&gt; 호스트하는 총 복제본 수입니다 . 목록에는 항상 &lt;code&gt;node_pool&lt;/code&gt; 의 모든 노드가 포함 됩니다 . &lt;code&gt;node_pool&lt;/code&gt; 에 속하지 않은 노드는 &lt;code&gt;Count&lt;/code&gt; 가 더 낮 더라도 목록의 마지막에 놓 입니다.</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">실행할 프로그램을 지정하는 공백으로 구분 된 문자열입니다. 두 번째 필드는 일반적으로 &lt;code&gt;erl&lt;/code&gt; 과 같은 명령 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">(? 뒤에 숫자&amp;gt; 0 및 닫는 괄호로 구성되는 특수 항목은 해당 서브 패턴 내부에서 발생하는 경우 주어진 번호의 서브 패턴에 대한 재귀 서브 루틴 호출입니다 (그렇지 않은 경우 비 재귀 서브 루틴 호출입니다). 특수 항목 (? R) 또는 (? 0)은 전체 정규식을 재귀 적으로 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 으로 호출 된 특수 루틴 . Erlang 드라이버의 &quot;ioctl&quot;과 약간 비슷합니다. &lt;code&gt;port_control/3&lt;/code&gt; 에 지정된 데이터 는 &lt;code&gt;buf&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; 에 도착합니다 . 드라이버는 &lt;code&gt;*rbuf&lt;/code&gt; 및 &lt;code&gt;rlen&lt;/code&gt; 을 사용하여 데이터를 다시 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">특수한 유형의 오류는 실제로 유효하지 않은 정수 나 바이트를 찾을 수 없지만 후행 &lt;code&gt;binary()&lt;/code&gt; 가 너무 적은 바이트로 구성되어 마지막 문자를 디코딩 할 수 없습니다. 이 오류는 파일에서 청크 단위로 바이트를 읽거나 다른 방법으로 바이너리가 비 UTF 문자 경계에서 분할 된 경우 발생할 수 있습니다. &lt;code&gt;incomplete&lt;/code&gt; 튜플은 다음 대신의 반환되는 &lt;code&gt;error&lt;/code&gt; 튜플. &lt;code&gt;error&lt;/code&gt; 튜플 과 동일한 부분으로 구성 되지만 &lt;code&gt;error&lt;/code&gt; 대신 태그가 &lt;code&gt;incomplete&lt;/code&gt; 하며 마지막 요소는 항상 유효한 UTF 문자의 첫 번째 부분으로 구성된 이진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">함수의 스펙 (또는 계약)은 &lt;code&gt;-spec&lt;/code&gt; 속성을 사용하여 제공됩니다 . 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">상태 변경은 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 취소 하고이 유형의 새로운 전환 옵션은 새로운 상태에 속합니다.</target>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">인 상태, &lt;strong&gt;활성&lt;/strong&gt; 또는 &lt;strong&gt;비활성&lt;/strong&gt; . 비활성 중단 점은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">고정 잠금은 잠금을 처음 획득 한 트랜잭션이 종료 된 후 노드에서 유지되는 잠금입니다. 이를 설명하기 위해 다음 트랜잭션이 실행되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">OTP 릴리스 번호가 포함 된 문자열입니다 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; 리턴 한 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">정규식을 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">런타임 시스템의 버전 ​​번호를 포함하는 문자열입니다 ( &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; 리턴 한 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하는 환경 변수 이름에 대해 특정 OS에서 유효한 문자를 포함하는 문자열 입니다. 특히 null 문자 (정수 값 0) 및 &lt;code&gt;$=&lt;/code&gt; 문자는 허용되지 않습니다. 그러나 모든 유효하지 않은 문자가 반드시 primitiv 조작을 실패하게하는 것은 아니지만 대신 유효하지 않은 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하는 환경 변수 값에 대해 특정 OS에서 유효한 문자를 포함하는 문자열 입니다. 특히 널 문자 (정수 값 0)는 허용되지 않습니다. 그러나 모든 유효하지 않은 문자가 반드시 primitiv 조작을 실패하게하는 것은 아니지만 대신 유효하지 않은 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">오류를 설명하는 문자열은 다음 호출로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">작성된 스레드를 식별하는 문자열입니다. 계획된 향후 디버그 기능에서 스레드를 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">이 모듈의 문자열은 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 즉, 코드 포인트 목록, UTF-8 인코딩 코드 포인트가있는 &lt;strong&gt;바이너리&lt;/strong&gt; ( &lt;strong&gt;UTF-8 바이너리&lt;/strong&gt; ) 또는이 둘의 혼합으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">공백이 아닌 문자열을 읽습니다. 필드 너비가 지정된 경우이 문자 수를 읽고 모든 후행 공백 문자가 제거됩니다. Erlang 문자열 (문자 목록)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">원자 나타내는 문자열 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">오류를 설명하는 문자열은 다음 호출로 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; 의 문자열 버전입니다 . 쿼리 핸들이 평가 될 때 구문 분석 변환으로 작성된 재미는 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 의해 해석됩니다 . 쿼리 문자열은 마침표로 끝나는 하나의 단일 QLC입니다.</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">인접한 점이없는 문자열</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">스텁 모듈 설명자는 모듈 이름, 내 보낸 함수 목록 및 모듈 속성 목록을 포함합니다. 각 함수는 이름 (arity 포함)과 해당 모듈과 함수가 호출합니다. 속성은 항상 일치해야합니다. 속성은 단순히 키-값 쌍으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">|를 포함하지 않는 서브 패턴 성격은 둘러싸는 대안의 일부일뿐입니다. 단 하나의 대안으로 중첩 된 대안이 아닙니다. (* THEN)의 효과는 이러한 서브 패턴을 넘어 대체 대안으로 확장됩니다. A, B 등이 다음을 포함하지 않는 복잡한 패턴 조각 인 다음 패턴을 고려하십시오. 이 레벨의 문자 :</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">이름으로 참조되는 하위 패턴은 참조 전후 패턴에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">서브 패턴에 대한 서브 루틴 호출 (재귀 적 또는 기타)</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">형식에 대한 모든 의미 검사의 하위 집합이 구현됩니다. 예를 들어, 엄격히 &lt;code&gt;TimeTicks&lt;/code&gt; 는 서브 클래스로 분류되지 않을 수 있지만 컴파일러는이를 허용합니다 (표준 MIB는 컴파일러를 통과해야 함) (SMIv2에서만 다름).</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">&lt;code&gt;utf&lt;/code&gt; 유형 의 세그먼트가 성공적으로 일치 하면 0..16 # D7FF 또는 16 # E000..16 # 10FFFF 범위의 정수가됩니다. 반환 된 값이 해당 범위를 벗어나면 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">사용할 스택의 크기에 대한 제안 (킬로 단어)입니다. &amp;lt;0 값은 기본 크기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">다음 예제 코드 를 통해 &lt;code&gt;ei_cnode&lt;/code&gt; 구조 에서 적절한 &lt;code&gt;erlang_pid&lt;/code&gt; 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">모든 실행 된 테스트 사례 요약</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; 및 &lt;code&gt;Type&lt;/code&gt; 별로 그룹화 된 할당 된 블록 크기 (헤더 포함) 요약 .</target>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">수퍼바이저 브리지는 사전 정의 된 기능 세트를 내보내는 콜백 모듈에서 서브 시스템을 시작 및 중지하기위한 기능을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">감독자는 위의 맵에서 &lt;code&gt;strategy&lt;/code&gt; 키로 지정된 다음 &lt;strong&gt;재시작 전략&lt;/strong&gt; 중 하나를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">감독자는 사전 정의 된 함수 세트를 내보내는 콜백 모듈에서 감독 할 하위 프로세스의 정의를 예상합니다.</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">SNMP 에이전트 프로세스의 감독자</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">감독자는 자식 프로세스의 시작, 중지 및 모니터링을 담당합니다. 감독자의 기본 아이디어는 필요할 때 다시 시작하여 자식 프로세스를 활성 상태로 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">감독 자녀가 예기치 않게 종료되면 감독자 보고서가 발행됩니다. 감독자 보고서에는 다음 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">재시작 전략이 &lt;code&gt;simple_one_for_one&lt;/code&gt; 인 감독자 는 단순화 된 &lt;code&gt;one_for_one&lt;/code&gt; 감독자로 모든 하위 프로세스가 동일한 프로세스의 인스턴스에 동적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">일시 중단 요청은 &lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스로 전송됩니다 . &lt;code&gt;Suspendee&lt;/code&gt; 는 중단되기 전에 재개되지 않는 한 결국 중단됩니다. &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 의 호출자는 &lt;code&gt;Suspendee&lt;/code&gt; 가 일시 중단 되었는지 여부에 관계없이 즉시 반환합니다 . &lt;code&gt;Suspendee&lt;/code&gt; 가 일시 중단 되는 시점 은 시스템의 다른 이벤트에서 추론 할 수 없습니다. &lt;code&gt;Suspendee&lt;/code&gt; 가 재개되지 않는 한 &lt;strong&gt;결국 &lt;/strong&gt;Suspendee &lt;strong&gt;가&lt;/strong&gt; 일시 중단 되는 것이 보장 됩니다. &lt;code&gt;asynchronous&lt;/code&gt; 옵션이 전달 되지 않은 경우 &lt;code&gt;Suspendee&lt;/code&gt; 가 일시 중단 될 때까지 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 의 호출자 가 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">일시 중단 요청은 &lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스로 전송됩니다 . 일시 중단 요청이 처리되면이 기능의 호출자에게 응답 메시지가 전송됩니다. 회신은 &lt;code&gt;{ReplyTag, State}&lt;/code&gt; 이며 &lt;code&gt;State&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">구문 트리는 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; 표현 으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">Unix의 &lt;code&gt;writev&lt;/code&gt; 와 Win32의 &lt;code&gt;WSASend&lt;/code&gt; 에 사용되는 시스템 I / O 벡터 . &lt;code&gt;ErlIOVec&lt;/code&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Unix의 &lt;code&gt;writev&lt;/code&gt; 와 Win32의 &lt;code&gt;WSASend&lt;/code&gt; 에 사용되는 시스템 I / O 벡터 . &lt;code&gt;ErlNifIOVec&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">시스템 구성 파일 인 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">시스템 구성 소스 파일 &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">시스템 한도에 도달했습니다. 시스템 한계에 대한 정보는 &lt;code&gt;Efficiency Guide&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">탭 뒤에 문자 &quot;3&quot;</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myTable&lt;/code&gt; 이라는 테이블 에는 5 개의 열이 있습니다. 처음 두 개는 키 (액세스 할 수 없음)이며 테이블에는 세 개의 행이 있습니다. 이 테이블의 인스 트루먼 테이션 함수는 &lt;code&gt;my_table&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 테이블 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">테이블에는 내부적으로 사용되는 열이 포함될 수 있지만 관리자에게는 보이지 않아야합니다. 이 내부 열은 테이블의 마지막 열이어야합니다. &lt;code&gt;set&lt;/code&gt; 열이 있기 때문에 작업이 배치하지 작업, 에이전트가 알지 못하는 것이다. 이 상황은 &lt;code&gt;set&lt;/code&gt; 함수 에서 내부 열의 값을 추가하여 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">테이블 객체</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; 유형의 테이블에는 키당 0 개 또는 1 개의 레코드가있는 반면 &lt;code&gt;bag&lt;/code&gt; 유형의 테이블 에는 키당 임의의 수의 레코드가있을 수 있습니다. 각 레코드의 키는 항상 레코드의 첫 번째 특성입니다.</target>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">용어를 전혀 구성하지 않는 꼬리 재귀 함수 (예 : 모든 정수를 합산하는 함수)와 같이 끝에서 목록을 뒤집을 필요가없는 꼬리 재귀 함수는 신체 재귀 함수보다 빠릅니다. 목록).</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">대상 시스템에 여러 릴리스가있을 수 있지만 시스템을 부팅 할 때 &lt;code&gt;boot_rel&lt;/code&gt; 로 지정된 릴리스 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">상태 머신 구현이 필요한 서버 데이터를 저장하는 용어입니다. 이것과 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 자체 의 차이점은이 데이터의 변경으로 인해 연기 된 이벤트가 재 시도되지 않는다는 것입니다. 따라서이 데이터의 변경으로 인해 처리되는 이벤트 세트가 변경되면 해당 데이터 항목이 상태의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">오류로 인해 이벤트 핸들러가 제거 된 경우의 용어입니다. 어떤 용어는 오류에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">테스트 케이스는 테스트에 필요한 조치를 수행하기 위해 하나 이상의 대상 시스템, 계측기 및 트래픽 생성기에 대한 여러 연결을 병렬로 처리 할 수 ​​있습니다. &lt;code&gt;Common Test&lt;/code&gt; 사용자가 활용할 수 있는 Erlang 런타임 시스템의 동시성에 대한 효율적인 지원 덕분 에 많은 연결을 병렬로 처리하는 것이 &lt;code&gt;Common Test&lt;/code&gt; 의 주요 강점 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">테스트 케이스 실패는 종료 이유가 무엇이든 런타임 오류 (충돌)로 지정됩니다. Erlang 패턴 일치를 효과적으로 사용하면이 속성을 활용할 수 있습니다. 결과는 실제 프로그램보다 훨씬 스크립트처럼 보이는 간결하고 읽기 쉬운 테스트 케이스 함수입니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">테스트 케이스 그룹은 특정 횟수 (정수로 지정됨) 또는 무한정 ( &lt;code&gt;forever&lt;/code&gt; 지정됨)으로 반복 될 수 있습니다 . 또한 모든 경우에 실패하거나 성공한 경우 (즉, &lt;code&gt;repeat_until_any_fail&lt;/code&gt; , &lt;code&gt;repeat_until_any_ok&lt;/code&gt; , &lt;code&gt;repeat_until_all_fail&lt;/code&gt; 또는 &lt;code&gt;repeat_until_all_ok&lt;/code&gt; 특성 중 하나가 사용 된 경우) 반복을 너무 일찍 중지 할 수도 있습니다 . 기본 &lt;code&gt;repeat&lt;/code&gt; 속성을 사용하는 경우 테스트 사례의 상태는 반복 작업과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">테스트 케이스 그룹은 구성 기능 및 실행 특성을 공유하는 테스트 케이스 세트입니다. 테스트 케이스 그룹은 다음 구문에 따라 기능 &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">테스트 케이스는 리턴 된 값이 무엇이든 호출자에게 리턴되면 성공한 것으로 간주됩니다. 그러나 몇 가지 반환 값은 다음과 같은 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">테스트는 하나 이상의 테스트 스위트를 실행하여 수행됩니다. 테스트 스위트는 테스트 케이스, 구성 기능 및 정보 기능으로 구성됩니다. 테스트 케이스는 테스트 케이스 그룹으로 그룹화 할 수 있습니다. 테스트 스위트는 Erlang 모듈이며 테스트 케이스는 Erlang 함수로 구현됩니다. 테스트 스위트는 테스트 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">일련의 테스트 개체를 목록에 배치하여 테스트 세트를 쉽게 만들 수 있습니다. 경우 &lt;code&gt;T_1&lt;/code&gt; 이 , ..., &lt;code&gt;T_N&lt;/code&gt; 이 후 개별 테스트 객체이다 &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; (순서)에 해당 개체로 이루어진 테스트 세트이다.</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">테스트 스위트는 테스트 케이스를 포함하는 일반적인 Erlang 모듈입니다. 모듈은 &lt;code&gt;*_SUITE.erl&lt;/code&gt; 형식의 이름을 갖는 것이 좋습니다 . 그렇지 않으면 &lt;code&gt;Common Test&lt;/code&gt; 의 디렉토리 및 자동 컴파일 기능이 이를 찾을 수 없습니다 (적어도 기본적으로는 아님).</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">테스트 용어는 건너 뛸 하나 이상의 테스트 스위트, 그룹 또는 테스트 케이스를 지정할 수도 있습니다. 건너 뛴 제품군, 그룹 및 사례는 실행되지 않으며 HTML 로그 파일에 &lt;code&gt;SKIPPED&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">서비스를 설명하는 텍스트 설명입니다. 필수는 아니지만 Windows 서비스 관리자에서 서비스 설명으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">이 글을 쓰는 시점에서 SystemTap의 최신 릴리스 버전은 1.6입니다. Erlang의 DTrace 지원에는 해당 릴리스 이후에 도입 된 MACRO가 필요합니다. 따라서 최신 릴리스를 얻거나 직접 git에서 SystemTap을 빌드하십시오 (http://sourceware.org/systemtap/getinvolved.html 참조)</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">세 번째 대안은 다음에서 MSYS2를 다운로드하여 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">세 번째 사용법은 잘못 동작하는 피어의 로그인 시도를 차단하는 것입니다. &lt;code&gt;State&lt;/code&gt; 위의 설명이 사용할 수 있습니다. 리턴 값 &lt;code&gt;disconnect&lt;/code&gt; 가이 기능에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">스레드는 한 번만 결합 될 수 있습니다. 두 번 이상 결합하는 동작은 정의되어 있지 않으며 에뮬레이터 충돌이 발생할 수 있습니다. 경우 &lt;code&gt;exit_value == NULL&lt;/code&gt; , 종료 된 스레드의 종료 값이 무시되고, 그렇지 않으면 종료 된 스레드의 종료 값이 저장됩니다 &lt;code&gt;*exit_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">스레드 식별자는 스레드가 종료 된 후 매우 빠르게 재사용 할 수 있습니다. 따라서 스레드 식별자를 저장 한 후 관련된 스레드 식별자 중 하나에 해당하는 스레드가 종료 된 경우 &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; 의 결과 는 예상 된 결과를 제공하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;now()&lt;/code&gt; 에서 리턴 한 시간 소인 .</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">타임 워프는 시간이 앞뒤로 도약하는 것입니다. 즉, 시간 왜곡 전후의 시간 값 차이는 실제 경과 시간과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 선행 작업 &lt;code&gt;gen_fsm&lt;/code&gt; 에서 상속 된 시간 초과 기능 은 이벤트 시간 초과입니다. 즉, 이벤트가 도착하면 타이머가 취소됩니다. 이벤트 또는 시간 제한이 있지만 둘다는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">시간 종료 값이 &lt;code&gt;0&lt;/code&gt; 이면 시간 종료가 사용 불가능 함을 의미합니다. 따라서 마지막 인수를 &lt;code&gt;0&lt;/code&gt; 으로하여 &lt;code&gt;_tmo&lt;/code&gt; 함수를 호출하는 것은 &lt;code&gt;_tmo&lt;/code&gt; 접미사 없이 함수를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">&lt;code&gt;memsup&lt;/code&gt; 프로세스가 메모리 검사 결과를 기다리는 시간 (초)입니다 . 시간 종료가 만료되면 &lt;code&gt;error_logger&lt;/code&gt; 를 통해 경고 메시지 &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; 가 발행 되고 보류중인 모든 동기 클라이언트 호출은 더미 값을 리턴합니다. 일반적으로이 상황은 발생하지 않아야합니다. 그러나 Linux에는 시스템 데이터가 많이로드 될 때 시스템 데이터를 읽는 의사 파일을 일시적으로 사용할 수없는 경우가있었습니다.</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 타이머를 항상 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">타이머 참조.</target>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; 생성 된 타임 스탬프 입니다.</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">테스트 케이스 또는 구성 기능을 실행하는 동안 타임 트랩을 동적으로 설정하거나 재설정 할 수도 있습니다. &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 을 호출하면됩니다 . 이 기능은 현재 타임 트랩을 취소하고 새로운 타임 트랩을 시작합니다 (타임 아웃 또는 현재 기능이 끝날 때까지 활성 상태로 유지됨).</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSLT 스타일 시트를 XML 문서에 적용하기위한 도구입니다. &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; 에서 xsltproc을 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">추적 포트는 추적 메시지를 Erlang 가상 머신에서 메시지로 전송하지 않고 직접 추적 메시지를 처리하는 동적으로 연결된 드라이버에 대한 Erlang 포트입니다.</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">이런 방식으로 시작된 추적 서버는 추적 메시지를 Erlang 셸에서 형식화 된 방식으로 표시합니다 (예 : io : format 사용). 추적 메시지 핸들러를 사용자 정의하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">추적 토큰에는 레이블과 플래그 세트가 포함됩니다. 레이블과 플래그 모두 위의 두 가지 대안으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 엄격한 단조 시간 소인을 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 타임 스탬프는 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 과 단조 증가 정수로 구성됩니다. 타임 스탬프는 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 엄격한 단조 시간 소인을 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 타임 스탬프는 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 합니다. 타임 스탬프는 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">각 추적 이벤트에 대해 타임 스탬프를 생성 / 비활성화하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; )입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seq_trace:print/1&lt;/code&gt; 에 대한 명시 적 호출에서 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; )입니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메시지 수신시 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메시지 전송에 대한 추적을 활성화 / 비활성화 하는 추적 토큰 플래그 ( &lt;code&gt;true | false&lt;/code&gt; ). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">트랜잭션 시스템을 사용하면 동일한 레코드를 조작하는 둘 이상의 프로세스를 동시에 실행할 수 있습니다. 프로그래머는 업데이트가 동기 적인지 확인할 필요가 없습니다. 이것은 트랜잭션 핸들러가 감독합니다. 트랜잭션 시스템을 통해 데이터베이스에 액세스하는 모든 프로그램은 마치 데이터에 단독으로 액세스하는 것처럼 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">트랜스 포트는 서비스 기능을 재정의하고 지원되는 직경 애플리케이션을 제한 할 수 있으므로 &quot;서비스 = Origin-Host에 의해 식별 된 직경 노드&quot;가 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">전송 프로세스는 상위에서 다음 유형의 메시지를 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">전송 프로세스는 아래에 설명 된 메시지 인터페이스를 구현해야합니다. 부모의 pid를 유지하고 부모를 모니터링하고 죽으면 종료해야합니다. 부모에게 연결해서는 안됩니다. 피어와의 전송 연결이 끊어지면 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">전송 프로세스는 다음 유형의 메시지를 부모에게 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">방아쇠 행동. 중단 점에 도달하면 트리거 조치는 중단 점이 활성으로 계속되는지 ( &lt;strong&gt;enable&lt;/strong&gt; ) 또는 비활성 상태 가되는지 ( &lt;strong&gt;disable&lt;/strong&gt; ) 또는 제거 되는지 ( &lt;strong&gt;delete&lt;/strong&gt; )를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">시스템이 부팅 될 때 진정한 임베디드 시스템이 시작되어야합니다. 이 섹션에서는이를 달성하는 데 필요한 구성을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">튜플 &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; . &lt;code&gt;HashAlgoSpec&lt;/code&gt; 의 지문을 계산하는 데 사용되어야한다 해시 알고리즘의 지정이 호출에 사용 &lt;code&gt;accept_callback()&lt;/code&gt; . &lt;code&gt;HashALgoSpec&lt;/code&gt; 는 원자 또는 제 인수 원자들의 목록이다 &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; . 해시 알고리즘 이름 목록 인 경우 &lt;code&gt;accept_callback()&lt;/code&gt; 의 &lt;code&gt;FingerPrint&lt;/code&gt; 인수 는 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 목록 의 해당 이름과 동일한 순서로 지문 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">ETS 테이블 덤프에 대한 파일 형식의 주 버전과 부 버전을 포함 하는 튜플 &lt;code&gt;{Major,Minor}&lt;/code&gt; . 이 버전 필드는 STDLIB 1.5.1부터 추가되었습니다. 이전 버전으로 덤프 된 파일 은이 필드에서 &lt;code&gt;{0,0}&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">함수 호출을위한 튜플 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;{registered_name,node_name}&lt;/code&gt; 대신 상대의 사용 &lt;code&gt;registered_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">튜플 &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; (여기서 &lt;code&gt;ModuleName&lt;/code&gt; 및 &lt;code&gt;FunctionName&lt;/code&gt; 은 원 자임) , &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">튜플은 고정 된 수의 항을 갖는 복합 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">튜플은 요소 수와 함께 지정해야합니다. 요소는 &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; 용어 앞에옵니다 .</target>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 동일한 크기의 튜플 이 반환됩니다. 튜플 요소는 정수 또는 원자 &lt;code&gt;unbound&lt;/code&gt; 입니다. 논리 프로세서 식별자는 정수로 표시됩니다. 튜플 의 &lt;code&gt;N&lt;/code&gt; 번째 요소는 스케줄러 식별자가 &lt;code&gt;N&lt;/code&gt; 인 스케줄러의 현재 바인딩과 같습니다 . 예를 들어 스케줄러가 바인딩 된 경우 &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; 는 호출 프로세스가 실행중인 논리 프로세서의 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">크기 3의 튜플 : 세그먼트 번호, &lt;code&gt;last segment indicator&lt;/code&gt; 및 마지막으로 오류 표시가 포함 된 'ActionReply'레코드 목록. 이것은 물론 답장이 분할 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 바인딩의 튜플과 연속이 반환됩니다.이 경우 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 추가 객체를 일치시킬 때 연속이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블이 비어 있지 않으면 일치 스펙 및 연속을 적용한 결과의 튜플이 리턴 &lt;code&gt;'$end_of_table'&lt;/code&gt; 경우 '$ end_of_table' 이 리턴됩니다. 연속체는 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 더 많은 객체를 일치시킬 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">튜플은 외부 형식의 Erlang을 사용하여 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">요소가 &lt;code&gt;T&lt;/code&gt; 형인 튜플 .</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">문자열과 컴파일 옵션이있는 튜플</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">비트 열 요소에 대한 타입 지정자리스트 TSL은 타입 지정자 &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; 및 Rep (TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">일반적인 (압축) 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">일반적인 &lt;code&gt;.erlang&lt;/code&gt; 파일에는 다음과 같은 검색 경로 세트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">&lt;code&gt;ct_property_test&lt;/code&gt; 를 사용 하는 일반적인 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트 는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">일반적인 오류 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">일반적인 오류 이유 :</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">유닉스에서 일반적인 구현은 &lt;code&gt;close((int)event)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">일반적인 작업에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">일반적인 과부하 상황은 응용 프로그램이 &lt;code&gt;Mnesia&lt;/code&gt; 가 처리 할 수있는 것보다 디스크 상주 테이블에서 더 많은 업데이트를 수행 할 때 발생합니다 . 이러한 종류의 과부하를 무시하면 디스크에 저장된 테이블의 크기에 관계없이 디스크 공간이 부족한 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">이 기능은 일반적 으로 로거와 같이 텍스트로 형식을 지정하기 전에 &lt;code&gt;~w&lt;/code&gt; 및 &lt;code&gt;~p&lt;/code&gt; 와 같은 무한 크기 제어 시퀀스를 깊이 제한 변형 인 &lt;code&gt;~W&lt;/code&gt; 및 &lt;code&gt;~P&lt;/code&gt; 로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">필터의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">핸들러 인스턴스의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">클라이언트 함수에서 사용할 수있는 유용한 디스패치 함수입니다. 프로세스가 존재하는 경우 로컬 노드에서 프로세스를 리턴합니다. 그렇지 않으면 무작위로 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">유용한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">목록의 일부를 보는 유용한 방법은 &quot;|&quot;를 사용하는 것입니다. 이것은 쉘을 사용한 예제로 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">이 알림 전송 작업을 나타내는 사용자 정의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">사용자의 액세스가 차단되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">차단 목록에서 사용자가 제거되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">사용자는 유효한 Megaco MID 여야하는 UserMid로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">사용자는 Erlang / OTP의 애플리케이션 개념에 따라 .config 파일에서 정적으로 구성되거나 megaco : start_user / 2에 대한 인수로 구성 설정으로 동적으로 시작될 수 있습니다. 이러한 구성 설정은 나중에 megaco : update_conn_info / 2로 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">사용자는 다른 사용자와 다수의 &quot;가상&quot;연결을 가질 수 있습니다. MG는 최대 하나의 MGC에 연결되며 MGC는 여러 개의 MG에 연결될 수 있습니다. 각 연결에 대해 사용자는 전송 서비스, 인코딩 체계 및 사용자 콜백 모듈을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">사용자 프로세스는 &lt;code&gt;Mnesia&lt;/code&gt; 가 생성 한 이벤트를 구독 할 수 있습니다 . 다음 두 가지 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">많은 쿼리에서 사용하기 위해 함수 그래프 의 &lt;code&gt;digraph&lt;/code&gt; 표현 을 보유하기 위해 사용자 변수가 사용됩니다 . 그 이유는 효율성입니다. 받는 반대로 &lt;code&gt;=&lt;/code&gt; 연산자는 &lt;code&gt;:=&lt;/code&gt; 연산자는 후속 분석에 대한 값을 저장한다. 쿼리 내에서 동일한 하위 표현식이 한 번만 평가된다는 점에 주목할 수 있습니다. &lt;code&gt;=&lt;/code&gt; 속도를 높이는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">각 객체에 대한 사용자 정의 계측 기능은 관리 객체를 실제 리소스에 연결합니다. 이 기능은 에이전트가 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 조작 에서 호출 합니다. 이 함수는 일부 하드웨어 레지스터를 읽거나 계산을 수행하거나 개념적 변수와 관련된 의미를 구현하는 데 필요한 모든 것을 수행 할 수 있습니다. 이 함수는 스칼라 변수와 테이블 모두에 대해 작성해야합니다. 텍스트 파일 인 연관 파일에 지정됩니다. 이 파일에서 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 또는 각 관리 오브젝트의 기호 이름은 Erlang 튜플 &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 함수에서 전달 된 사용자 정의 매개 변수 입니다. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; 의 반환 값에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">하나 이상의 코드 포인트로 구성된 사용자 인식 문자입니다.</target>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">유효한 체인에는 최소한 ROOT와 피어 인증서가 있어야합니다. 루트 인증서는 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 에 의해 사전 생성 된 인증서 또는 루트 인증서 생성 옵션으로 제공 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 루트 인증서 . 사용 가능한 옵션은 아래 &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; 참조하십시오. 이것은 &lt;code&gt;ssl:ssl_option()&lt;/code&gt; 유형의 서브 세트입니다 . &lt;code&gt;PrivateKey&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 SMP를 지원하는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 더티 스케줄러 스레드를 지원하는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템에 스레드 지원이있는 경우 값은 &lt;code&gt;!= 0&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 필드 의 값 이 디코드 오류 가 &lt;strong&gt;없음을&lt;/strong&gt; 의미하지는 &lt;strong&gt;않습니다&lt;/strong&gt; . &lt;code&gt;errors&lt;/code&gt; 필드도 검토되어야한다.</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">MIB에 기본값이없는 모든 변수에 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">값의 길이는 1 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">이 유형의 값은 &lt;code&gt;open type&lt;/code&gt; 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">변수를 먼저 제거하지 않으면 새 값을 할당 할 수 없습니다. &lt;code&gt;=&lt;/code&gt; 연산자 에 의해 할당 된 변수 는 쿼리 끝에서 제거되는 반면 &lt;code&gt;:=&lt;/code&gt; 연산자 에 의해 할당 된 변수 는 &lt;code&gt;forget&lt;/code&gt; 호출로만 제거 할 수 있습니다 . 모듈 데이터를 다시 설정해야 할 때 사용자 변수가 없습니다. 모듈 데이터를 다시 설정하는 데 필요한 기능이 호출되면 모든 사용자 변수를 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">변수는 표현식입니다. 변수가 값에 바인드되면 리턴 값이이 값입니다. 언 바운드 변수는 패턴에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">환경에없는 변수 이름은 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">이것의 변형은 사용하는 &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; . 그런 다음 상태는 예를 들어 튜플 &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; 로 모델링됩니다 .</target>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">웹 서버는 &lt;code&gt;Inets&lt;/code&gt; 애플리케이션 을 시작할 때 시작 하거나 &lt;code&gt;Inets&lt;/code&gt; 애플리케이션 API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; 또는 &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; 를 호출하여 런타임에 동적으로 시작되도록 구성 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 참조 ) . 속성이라고도하는 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">단어 경계는 제목 문자열에서 현재 문자와 이전 문자가 모두 \ w 또는 \ W와 일치하지 않거나 (즉, 하나는 \ w와 일치하고 다른 하나는 \ W와 일치 함) 제목의 시작 또는 끝입니다. 첫 번째 또는 마지막 문자가 각각 \ w와 일치하면 문자열입니다. UTF 모드에서는 옵션 &lt;code&gt;ucp&lt;/code&gt; 를 설정하여 \ w 및 \ W의 의미를 변경할 수 있습니다 . 이 작업이 완료되면 \ b 및 \ B에도 영향을줍니다. PCRE와 Perl에는 별도의 &quot;단어 시작&quot;또는 &quot;단어 끝&quot;메타 시퀀스가 ​​없습니다. 그러나 \ b 뒤에 오는 것은 일반적으로 그것이 무엇인지 결정합니다. 예를 들어, \ ba 조각은 단어의 시작 부분에서 &quot;a&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">랩 디스크 로그 파일은 인덱스 파일이라는 많은 파일로 구성됩니다. 로그 파일을 열고 닫을 수 있습니다. 또한 단일 인덱스 파일을 별도로 열 수 있습니다. 존재하지 않거나 내부 형식이 아닌 파일을 열면 오류 메시지가 반환됩니다. 파일이 손상되면 복구를 시도하지 않지만 오류 메시지가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">랩 파일 스펙은 추적에 사용되는 디스크 공간을 제한하는 데 사용됩니다. 추적은 각각 크기가 제한된 제한된 수의 파일에 기록됩니다. 실제 파일 이름은 &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; , 어디 &lt;code&gt;SeqCnt&lt;/code&gt; 의 에서 진수 문자열로 카운트를 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;WrapCnt&lt;/code&gt; 다시 주위에서 다음과 &lt;code&gt;0&lt;/code&gt; . 현재 파일에 작성된 추적 용어가 &lt;code&gt;WrapSize&lt;/code&gt; 보다 길어지면 해당 파일이 닫힙니다.이 랩 추적의 파일 수가 가장 오래된 파일 을 &lt;code&gt;WrapCnt&lt;/code&gt; 만큼 삭제하면 새 파일이 현재 파일로 열립니다. 따라서 랩 추적이 중지되면 최대 &lt;code&gt;WrapCnt&lt;/code&gt; 가 있습니다.비어있을 수도있는 마지막 파일을 제외하고 적어도 &lt;code&gt;WrapSize&lt;/code&gt; (그러나 더 크지 않은) 크기로 저장된 추적 파일 . 기본값은 &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; 및 &lt;code&gt;WrapCnt = 8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 에 대한 랩퍼 함수 . 적절한 &lt;code&gt;attributes&lt;/code&gt; 세트로 테이블을 작성합니다 (기존 테이블이없는 경우) . 속성과 &lt;code&gt;TabDef&lt;/code&gt; 는 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; 로 전달됩니다 . 예를 들어, 테이블이 모든 노드에서 &lt;code&gt;disc_only_copies&lt;/code&gt; 로 상주 하는 경우 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 에 대한 랩퍼 함수 . 적절한 &lt;code&gt;attributes&lt;/code&gt; 세트로 테이블을 작성합니다 (기존 테이블이없는 경우) . 테이블은 로컬 노드에만 상주하며 스토리지 유형은 로컬 노드의 &lt;code&gt;schema&lt;/code&gt; 테이블 과 동일 합니다 (즉, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; 또는 &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">&lt;code&gt;disc_copies&lt;/code&gt; 테이블 복제본 에 대한 쓰기 작업 은 두 단계로 수행됩니다. 먼저 쓰기 작업이 로그 파일에 추가 된 다음 실제 작업이 RAM에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ZLIB 스트림은 참조 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">A : Cygwin, MSYS 또는 MSYS2는 Unix 머신에서 발견되는 환경과 매우 유사한 환경입니다. Windows에 가상 Unix 컴퓨터가있는 것과 거의 같습니다. 특정 매개 변수가 주어지면 환경의 gnu-make가 시스템을 빌드하는 데 사용하는 make 파일을 작성하십시오. 그러나 대부분의 실제 컴파일러는 Cygwin / MSYS / MSYS2 도구가 아니므로 &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; 있는 몇 개의 래퍼 (Bourne-shell 스크립트)를 작성했습니다. / win32 / msys_tools. 이들은 모두 기본 Windows 도구에 맞게 Unix 환경에서 공통적 인 매개 변수 및 스위치를 변환합니다. 물론 가장 주목할만한 경로는 Cygwin / MSYS / MSYS2에서 &quot;슬래시&quot;(/)가 있고 드라이브 문자가없는 Unix와 유사한 경로입니다. Cygwin 특정 명령 &lt;code&gt;cygpath&lt;/code&gt; Cygwin 환경에서 대부분의 경로 변환에 사용됩니다. 해당하는 MSYS 및 MSYS2 환경에서 다른 도구가 사용됩니다 (필요한 경우). 운 좋게도 대부분의 컴파일러는 백 슬래시 대신 슬래시를 경로 구분 기호로 사용하지만 여전히 드라이브 문자 등을 가져와야합니다. 래퍼 스크립트는 cc.sh가 가능한 모든 gcc 옵션을 이해하고 번역하고 올바른 옵션을 cl.exe에 전달한다는 의미에서 일반적이지 않습니다. 원칙은 스크립트가 Erlang / OTP를 구축 할 수있을만큼 강력하다는 것입니다. Erlang 개발 과정에서 변경 사항을 처리하기 위해 확장 기능이 필요할 수 있으며 이것이 Perl 스크립트가 아닌 쉘 스크립트로 만든 이유 중 하나입니다. 우리는 그들이 이해하고 변경하는 것이 더 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">A : Cygwin, MSYS 및 MSYS2 모두 빌드 할 때 사용 가능한 최신 릴리스를 사용하려고합니다. 사용하는 버전은 중요하지 않습니다. 다른 Cygwin / MSYS / MSYS2 릴리스에서 발견 된 버그에 대한 해결 방법을 포함 시키려고합니다. 새로운 Cygwin / MSYS / MSYS2 관련 버그가 발생하자마자 해결 방법을 추가하도록 도와주세요. 또한 적절한 Cygwin, MSYS 및 / 또는 MSYS2 개발자에게 버그 보고서를 제출하십시오. 21에 사용한 GCC는 버전 4.8.1 (MinGW 32 비트) 및 4.8.5 (MSYS2 64 비트)입니다. VC ++ 12.0 (예 : Visual Studio 2013), Sun의 JDK 1.6.0_45 (32 비트) 및 Sun의 JDK 1.7.0_1 (64 비트), NSIS 2.46 및 Win32 OpenSSL 1.0.2d를 사용했습니다. 필요한 사항에 대한 자세한 내용은 다음 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">A : 아닙니다. 프로젝트 파일을 최신 상태로 유지하고 VC ++ GUI 내에서 OTP 빌드를 구성하는 모든 단계를 수행하는 번거 로움은 그다지 가치가 없으며 어쩌면 불가능할 수도 있습니다. Erlang / OTP 용 VC ++ 프로젝트 파일은 절대 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">A : 아니요, 실제로는 아니지만 올바른 방향의 단계라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">A : 아니요. 결과는 순수한 Windows 바이너리이며, 내가 아는 한 Cygwin 바이너리를 만들 수는 없습니다. 물론 바람직한 일이지만 Cygwin의 TCP / IP 에뮬레이션뿐만 아니라 동적 링크 (동적 Erlang 드라이버 로딩)에는 여전히 몇 가지 문제가 있습니다. . 이러한 문제를 해결하는 것은 쉽지 않거나 어려울 수 있습니다. 나는 당신 자신을 시도하고 경험을 공유하는 것이 좋습니다. 단순한 &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; 가 완전한 Cygwin 바이너리를 생성 한다면 아무도 행복하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">A : 안타깝게도 아닙니다. 여전히 Microsoft의 Visual C ++이 필요합니다. Bourne-shell 스크립트 (cc.sh)는 Visual C ++ 컴파일러를 래핑하여 Cygwin 환경에서 실행합니다. Erlang을 빌드하는 데 필요한 다른 모든 도구는 프리웨어 / 오픈 소스이지만 C 컴파일러는 아닙니다. 그러나 Windows SDK는 Erlang을 구축하기에 충분합니다. Visual C ++를 구입할 필요가 없으며 SDK (SDK 버전 8.1 == Visual studio 2013) 만 다운로드하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">A : 아니요, 불행히도 Cygwin / MSYS / MSYS2 관련 사용자 문제를 도와 드릴 시간이 없습니다. 관련 웹 사이트, 뉴스 그룹 및 메일 링리스트를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">A : 좋습니다. 파일 중 하나가 Cygwin 또는 MinGW의 GCC를 사용하여 컴파일 된 후 결과 개체 코드가 작은 C 핵을 사용하여 MS VC ++ 호환 coff로 변환됩니다. 특정 파일 인 &lt;code&gt;beam_emu.c&lt;/code&gt; 는 GCC 레이블 값 확장을 사용할 수있게되므로 에뮬레이터 성능을 최대 50 % 향상시킵니다. 불행히도 (아직) 모든 OTP가 GCC를 사용하여 컴파일 될 수 있음을 의미하지는 않습니다. 이 특정 소스 코드는 시스템 특정 작업을 수행하지 않으며 실제로 GCC가 Windows에서 컴파일하는 데 사용된다는 사실에 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">A : 글쎄요, 비싸지 않고 무료입니다 (무료 맥주 에서처럼). Microsoft에서 최신 Windows SDK와 필요한 모든 도구를 다운로드하여 설치하십시오. 포함 된 디버거 (WinDbg)도 사용할 수 있습니다. 이것이 Erlang을 64 비트 Windows로 포팅 할 때 사용한 것입니다. 이후 Microsoft 컴파일러를 사용해야하는 또 다른 이유는 DLL 호환성입니다. VM이 이전 VC ++ 버전으로 컴파일 된 경우 새 버전의 표준 라이브러리를 사용하는 DLL이로드되지 않을 수 있습니다. 따라서 무료로 제공되는 최신 SDK 및 컴파일러를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">A : 글쎄요, 부분적으로는 좋은 컴파일러이기 때문입니다. 정말로! 실제로 R11 이후 릴리스에서는 시각적 C ++ 대신 mingw를 사용하여 빌드 할 수있었습니다 (일부 스크립트 및 디렉토리에서 나머지를 볼 수 있음). 불행히도 Windows 용 SMP 버전의 개발은 mingw 빌드를 중단했으며 VC ++ 버전에서 성능이 훨씬 향상되었으므로 VC ++ 빌드에 중점을두기로 선택했습니다. mingw 빌드가 다시 시작될 수 있지만 VC ++가 더 나은 성능을 제공하는 한 상용 빌드는 VC ++ 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">A : 그렇습니다. 우리는 똑같은 빌드 절차를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">SSL / TLS CRL (인증서 해지 목록) 캐시 용 API.</target>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Erlang NIF 라이브러리를위한 API 함수.</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Erlang 드라이버를위한 API 함수.</target>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">사용자 정의 SSH 클라이언트 및 서버 애플리케이션을 작성하기위한 API 기능</target>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">Erlang / OTP의 표준 로깅 기능인 Logger 용 API 모듈.</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">공개 키 인프라 용 API 모듈.</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM : ARMv5TE (예 : XScale) 프로세서가 작동해야합니다. 빅 엔디안 및 리틀 엔디안 모드가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM : 리눅스</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">ASCII 값 또는 문자의 유니 코드 코드 포인트 &lt;strong&gt; &lt;code&gt;char&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">Erlang 바이너리로 ASN.1 DER 인코딩 된 엔터티.</target>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">ASN.1 컴파일러 및 컴파일 타임 지원 기능</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1에는 기본 유형과 생성 된 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1은 분산 컴퓨터 시스템간에 교환 될 데이터 구조를 설명하기위한 공식 언어입니다. ASN.1의 목적은 정의 된 유형의 값을 바이트 스트림으로 변환하기 위해 표준화 된 규칙 세트를 사용하여 유형을 표현하는 플랫폼 및 프로그래밍 언어 독립적 표기법을 갖는 것입니다. 이 바이트 스트림은 모든 유형의 통신 채널에서 전송 될 수 있습니다. 이러한 방식으로, 서로 다른 컴퓨터에서 실행되는 서로 다른 프로그래밍 언어로 작성된 서로 다른 내부 데이터 표현으로 작성된 두 개의 응용 프로그램은 구조화 된 데이터 유형의 인스턴스를 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1은 SNMP에서 두 가지 방식으로 사용됩니다. SMI는 ASN.1을 기반으로하며 프로토콜의 메시지는 ASN.1을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">ASN.1 자체는 무한정 큰 정수를 지정합니다. 버전 4.3 이상의 Erlang 시스템은 실제로 무한정 큰 정수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">ASN.1 모듈 &lt;code&gt;People&lt;/code&gt; 이 승인되었으며 추상 구문 트리가 &lt;code&gt;People.asn1db&lt;/code&gt; 파일에 저장됩니다 . 생성 된 Erlang 코드는 Erlang 컴파일러를 사용하여 컴파일되어 Erlang 런타임 시스템에로드됩니다. &lt;code&gt;People&lt;/code&gt; 모듈 에 &lt;code&gt;encode/2&lt;/code&gt; 및 &lt;code&gt;decode/2&lt;/code&gt; 를 위한 API가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1은 다양한 문자 집합을 지원합니다. &lt;code&gt;OCTET STRING&lt;/code&gt; 과 문자열 의 주요 차이점 은 &lt;code&gt;OCTET STRING&lt;/code&gt; 이 전달 된 바이트에 의미를 부과하지 않았다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">공개 키 응용 프로그램 ASN.1 사양에 ASN.1 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1 파일. 그것은 생성 &lt;code&gt;.erl&lt;/code&gt; , &lt;code&gt;.hrl&lt;/code&gt; 및 &lt;code&gt;.asn1db&lt;/code&gt; 에서 파일 &lt;code&gt;.asn1&lt;/code&gt; 의 파일을. 옵션 &lt;code&gt;+noobj&lt;/code&gt; 를 지정 하지 않으면 Erlang 컴파일러를 사용 하여 &lt;code&gt;.erl&lt;/code&gt; 을 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP 코드</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">AVP 고려 사항</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">AVP 플래그</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">AVP 헤더</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">AVP 발생 테이블</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">AVP 값</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">기능 교환 중에 발신 CER 또는 CEA 메시지로 전송 된 AVP 값. 서비스와 전송 모두에서 구성 될 수 있으며, 후자가 우선합니다. 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVPs에 diameter_avp는 레코드의리스트로 디코딩 &lt;code&gt;avps&lt;/code&gt; 독립적 diameter_packet 레코드 필드 &lt;code&gt;decode_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">RFC에 정의 된 AVP는 직경으로 제공되는 사전으로 정의됩니다. 응용 프로그램 메시지에서의 올바른 사용은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">발신 CER / CEA 메시지를 작성하는 데 사용되는 AVP. 해당 서비스에 지정된 값보다 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">이진 숫자 목록 (0 또는 1) 이 형식은 인코딩 함수에 대한 입력으로 허용되며 &lt;strong&gt;legacy_bit_string&lt;/strong&gt; 옵션이 제공되면 &lt;code&gt;BIT STRING&lt;/code&gt; 이이 형식으로 디코딩됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">캐리어 프리 블록 최소 한계를 포기하십시오. 유효한 &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; 는 블록 크기 제한을 나타내는 양의 정수입니다. 반송파를 폐기하려면 반송파 에서 가장 큰 여유 블록이 &lt;code&gt;bytes&lt;/code&gt; 이상이어야합니다 . 기본값은 0이지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">운송 업체 수 제한을 포기합니다. 유효한 &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; 는 할당 자 인스턴스 당 최대 포기 된 반송파 수를 나타내는 양의 정수입니다. 기본값은 1000으로 설정되어 실제로 제한을 비활성화하지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">운송 업체 이용 한도를 포기합니다. 유효한 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; 은 사용률을 백분율로 나타내는 &lt;code&gt;[0, 100]&lt;/code&gt; 범위의 정수입니다 . 활용도 값&amp;gt; 0을 사용하면 할당 자 인스턴스는 멀티 블록 캐리어를 포기할 수 있습니다. 경우 &lt;code&gt;de&lt;/code&gt; (기본값은 활성화)를 대신 전달 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; , 권장되는 비 제로 사용 값이 사용됩니다. 선택한 값은 할당 자 유형에 따라 다르며 ERTS 버전간에 변경 될 수 있습니다. 기본값은 &lt;code&gt;de&lt;/code&gt; 이지만 나중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">더 많은 플래그를 사용하여 Erlang 에뮬레이터를 시작하는 기능 ( &lt;code&gt;erl&lt;/code&gt; 에서 지원하는 모든 플래그 가 지원됨).</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">보내지 않은 데이터를 플러시하지 않고 &lt;code&gt;Assoc&lt;/code&gt; 에 의해 지정된 연관을 비정상적으로 종료합니다 . 소켓 자체는 열려 있습니다. 이 소켓에서 열린 다른 연관은 여전히 ​​유효하며 소켓은 새 연관에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">세션 중단</target>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">보내지 않은 데이터를 플러시하지 않고 현재 연결을 중단합니다</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">현재 실행중인 테스트 사례를 중단합니다. 사용자는 현재 실행중인 테스트 사례를 확실하게 알고 있어야합니다. 따라서 함수는 테스트 케이스에 의해 호출 된 (또는 동 기적으로 호출 된) 함수에서만 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">하나 이상의 스위트가 컴파일에 실패한 경우 (앞서 설명) 테스트 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">절대 &lt;code&gt;Time&lt;/code&gt; 값. &lt;code&gt;Time&lt;/code&gt; 값은 밀리 초로 절대 얼랑 단조 시간으로 해석된다.</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">절대 최대 캐시에 맞지 않음 (킬로바이트). 메모리 세그먼트 캐시의 세그먼트는 크기가이 매개 변수 값보다 큰 값으로 요청 된 크기를 초과하면 재사용되지 않습니다. 기본값은 &lt;code&gt;4096&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">절대 오프셋.</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">절대 단일 블록 캐리어 축소 임계 값 (KB). &lt;code&gt;mseg_alloc&lt;/code&gt; 단일 블록 캐리어 에 위치한 블록 이 축소 될 때, 사용되지 않은 메모리의 양이이 임계 값보다 작 으면 캐리어가 변경되지 않은 채로 남아 있고, 그렇지 않으면 캐리어가 축소됩니다. &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">절대 시간 초과 시간</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">SNMP 인덱싱을위한 추상 데이터 유형</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">Erlang 구문 트리를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">FIFO 대기열에 대한 추상 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Erlang 컴파일러의 주석에 대한 추상 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">Erlang 절의 추상 형식.</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Erlang 표현식의 추상 형태.</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">Erlang 양식의 추상 양식.</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Erlang 타입의 추상 형태.</target>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">청취 소켓에서 들어오는 연결 요청을 수락합니다. &lt;code&gt;ListenSocket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 소켓이어야합니다 . 리턴 된 소켓은 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 을 완료하기 위해, 즉 SSL / TLS / DTLS 연결을 설정 하기 위해 handshake / [2,3] 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">청취 소켓에서 들어오는 연결 요청을 수락합니다. &lt;code&gt;Socket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 소켓 이어야합니다 . &lt;code&gt;Timeout&lt;/code&gt; 는 시간 초과 값을 밀리 초 단위로 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">지정된 식별 번호로 식별 된 청취 소켓에서 승인합니다. 식별 번호는 &lt;code&gt;uds_control&lt;/code&gt; 루틴으로 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">전 세계적으로 등록 된 이름에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">풀의 모든 노드가 서로 액세스 할 수있는 권한을 갖도록 액세스 권한을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">TCP / IP 프로토콜에 액세스</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">http://your.server.org/cgi-bin/17/foo에 액세스하면 서버가 / web / 17 / cgi-bin / foo 스크립트를 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">http://your.server.org/cgi-bin/foo에 액세스하면 서버가 / web / cgi-bin / foo 스크립트를 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">http://your.server.org/docs/에 액세스하면 색인 인 경우 http://your.server.org/docs/index.html 또는 http://your.server.org/docs/welcome.html을 반환합니다. html이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">http://your.server.org/image/foo.gif에 대한 액세스는 /ftp/pub/image/foo.gif 파일을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">http://your.server.org/~bob/foo.gif에 대한 액세스는 /home/bob/public/foo.gif 파일을 참조합니다. Apache와 같은 구성 파일에서 &lt;code&gt;Re&lt;/code&gt; 는 하나의 단일 공간으로 &lt;code&gt;Replacement&lt;/code&gt; 와 분리 되며 예상되는 백 슬래시를 백 슬래시 이스케이프 할 필요가 없으므로 동일한 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod : all_keys (ActivityId, 불투명, 탭, LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod : delete (ActivityId, 불투명, 탭, 키, LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod : delete_object (ActivityId, Opaque, Tab, RecXS, LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod : first (ActivityId, 불투명, 탭)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod : index_match_object (ActivityId, 불투명, 탭, 패턴, 속성, LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod : index_read (ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod : last (ActivityId, 불투명, 탭)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod : lock (ActivityId, Opaque, LockItem, LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod : match_object (ActivityId, 불투명, 탭, 패턴, LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod : next (ActivityId, 불투명, 탭, 키)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod : prev (ActivityId, 불투명, 탭, 키)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod : read (ActivityId, 불투명, 탭, 키, LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod : table_info (ActivityId, Opaque, Tab, InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod : write (ActivityId, Opaque, Tab, Rec, LockKind)</target>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">QLC 목록 이해에서 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에 액세스 하는 것은 항상 트랜잭션 내에서 수행해야합니다. 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">배열의 크기가 고정되어 있지 않으면 마지막 설정 항목 이외의 항목에 액세스하면 기본값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">설정되지 않은 항목에 액세스하면 기본값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">모범 사례에 따르면 인증서는 IP 주소를 &quot;서버 이름&quot;으로 사용해서는 안됩니다. 폐쇄 된 네트워크 외부에서 이런 일이 발생하면 매우 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">신화에 따르면, 역순으로 목록을 작성하는 꼬리 재귀 함수를 사용하고 그 다음에 목록을 호출하면 &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; 은 올바른 순서로 목록을 작성하는 본문 재귀 함수보다 빠릅니다. body-recursive 함수가 tail-recursive 함수보다 더 많은 메모리를 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">회계 AVP 테이블</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">회계 AVP</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">회계 응용 프로그램 확장 및 요구 사항</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">회계 명령 코드</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">회계 기록</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">회계 세션 상태 머신</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">회계는 사용자의 책임입니다. 직경은이 상태 머신을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">회계 실시간 필수 AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">회계 실시간 필수 AVP 값</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">회계 기록 번호 AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">회계 기록 유형 AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">회계 기록 유형 AVP 값</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">회계 서브 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">회계 관련 메시지 및 AVP는 제공된 사전에 정의되어 있습니다. 올바른 사용은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">계정 신청 ID AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">계정-간격-간격 AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">계정 다중 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">계정 세션 ID AVP</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">이 잠금에 대한 누적 대기 시간입니다. 이것은 실제 벽시계 시간보다 클 수 있으며 모든 스레드에 대해 누적됩니다. Trylock 충돌은 시간을 누적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">여러 테스트에 대한 커버 결과를 누적합니다. 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 의 정확성 및 정밀도</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 의 정확성 및 정밀도</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">포트의 시작을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">성공적인 TLS 핸드 셰이크 승인. &lt;code&gt;Ref&lt;/code&gt; 는 응답이 전송 된 &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; 메시지에 수신 된 reference () 입니다. 핸드 셰이크에 실패하면 전송을 종료해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
