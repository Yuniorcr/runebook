<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="389d84201c8d9fc72ea3759187e87ed97f94a3cc" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see below).</source>
          <target state="translated">그 결과, 한 쌍 &lt;code&gt;{Tree, Stubs}&lt;/code&gt; , &lt;code&gt;Tree&lt;/code&gt; 모두 코드 병합의 결과 인 소스 코드를 나타내는 &lt;code&gt;Sources&lt;/code&gt; 및 &lt;code&gt;Stubs&lt;/code&gt; 스터브 모듈 디스크립터 (아래 참조)의리스트이다.</target>
        </trans-unit>
        <trans-unit id="1812142f22d2ec8fea49815c861b9d307af9e096" translate="yes" xml:space="preserve">
          <source>The result is an utf8 encoded binary.</source>
          <target state="translated">결과는 utf8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="163326ca75ef4e4877fd05e7489373dbafc7e29a" translate="yes" xml:space="preserve">
          <source>The result is as follows:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96bc7dfc5e6c338c6e144779bbc57eea9d034108" translate="yes" xml:space="preserve">
          <source>The result is given as a list of &quot;strings&quot;, the preferred data type specified in option &lt;code&gt;return&lt;/code&gt; (default &lt;code&gt;iodata&lt;/code&gt;).</source>
          <target state="translated">결과는 &quot;문자열&quot;의 목록으로 주어집니다, 선호하는 데이터 타입이 옵션에 지정된 &lt;code&gt;return&lt;/code&gt; (기본 &lt;code&gt;iodata&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36b8ec2df33b161570c66397c14edb7740f68481" translate="yes" xml:space="preserve">
          <source>The result is sent to the calling process as &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt; 로 호출 프로세스에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a900f3ce3edf2d3ac29948402338e0f316e3fe94" translate="yes" xml:space="preserve">
          <source>The result is that the child process is started by calling &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt;, or actually:</source>
          <target state="translated">결과적으로 &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt; 하거나 실제로 다음 을 수행하여 하위 프로세스가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c3fa086682c777519a4e26ac33755c0fbf61a9a" translate="yes" xml:space="preserve">
          <source>The result is that the test case is skipped with &lt;code&gt;Reason&lt;/code&gt; printed to the log file (as described earlier) and &lt;code&gt;ConfigList&lt;/code&gt; is saved for the next test case. &lt;code&gt;ConfigList&lt;/code&gt; can be read using &lt;code&gt;?config(saved_config, Config)&lt;/code&gt;, as described earlier. &lt;code&gt;skip_and_save&lt;/code&gt; can also be returned from &lt;code&gt;init_per_suite&lt;/code&gt;. In this case, the saved data can be read by &lt;code&gt;init_per_suite&lt;/code&gt; in the suite that follows.</source>
          <target state="translated">결과는 테스트 케이스가 생략되고 (이전에 설명 된대로) 로그 파일에 &lt;code&gt;Reason&lt;/code&gt; 인쇄되고 다음 테스트 케이스에 대해 &lt;code&gt;ConfigList&lt;/code&gt; 가 저장됩니다. &lt;code&gt;ConfigList&lt;/code&gt; 는 앞에서 설명한대로 &lt;code&gt;?config(saved_config, Config)&lt;/code&gt; 사용하여 읽을 수 있습니다 . &lt;code&gt;skip_and_save&lt;/code&gt; 는 도에서 반환 할 수 &lt;code&gt;init_per_suite&lt;/code&gt; . 이 경우 저장된 제품군은 다음 제품군에서 &lt;code&gt;init_per_suite&lt;/code&gt; 로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6438c51f348652f581a109f7cba2e137928b4597" translate="yes" xml:space="preserve">
          <source>The result of &lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; is an &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; event that contains, in particular, the new &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; 의 결과는 특히 새로운 &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt; 를 포함 하는 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 이벤트입니다 .</target>
        </trans-unit>
        <trans-unit id="ea5e27a92975d3fafc60ea5040ed17aae30c19cc" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (참고 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; 원본과 동일한 소스 코드 텍스트를 나타냄) &lt;code&gt;Node&lt;/code&gt; 라고 가정, &lt;code&gt;subtrees(Node)&lt;/code&gt; 비어 있지 않은리스트를 산출한다. 그러나 반드시 &lt;code&gt;Node&lt;/code&gt; 와 동일한 데이터 표현을 가질 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fda083e58e6dac620272874f82b040b4ce2c7034" translate="yes" xml:space="preserve">
          <source>The result of a call to &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt; 호출의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="935e389e977d887f2bcee20a8d60eab32fcf9be1" translate="yes" xml:space="preserve">
          <source>The result of a successful parsing is a tuple &lt;code&gt;{DataStructure,M}&lt;/code&gt;. &lt;code&gt;M&lt;/code&gt; is the XML production Misc, which is the mark-up that comes after the element of the document. It is returned &quot;as is&quot;. &lt;code&gt;DataStructure&lt;/code&gt; is an &lt;code&gt;xmlElement&lt;/code&gt; record, that among others have the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;parents&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; like:</source>
          <target state="translated">성공적인 구문 분석의 결과는 튜플 &lt;code&gt;{DataStructure,M}&lt;/code&gt; 입니다. &lt;code&gt;M&lt;/code&gt; 은 XML 프로덕션 기타이며 문서의 요소 다음에 나오는 마크 업입니다. &quot;있는 그대로&quot;반환됩니다. &lt;code&gt;DataStructure&lt;/code&gt; 는 &lt;code&gt;xmlElement&lt;/code&gt; 레코드이며, 특히 필드 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;parents&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; 및 &lt;code&gt;content&lt;/code&gt; 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bdf97f5167b1c9ccc6355ba9b80fe296b53b3fa" translate="yes" xml:space="preserve">
          <source>The result of executing the command can be only one line or thousands of lines depending on the command.</source>
          <target state="translated">명령 실행 결과는 명령에 따라 한 줄 또는 수천 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d72cb2c002561132566b627196b081cc82e743" translate="yes" xml:space="preserve">
          <source>The result of passing the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) as a value is platform-dependent. On some platforms the variable value is set to the empty string, on others the environment variable is removed.</source>
          <target state="translated">빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )을 값 으로 전달한 결과 는 플랫폼에 따라 다릅니다. 일부 플랫폼에서는 변수 값이 빈 문자열로 설정되고 다른 플랫폼에서는 환경 변수가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="176ec7aa5b60be46f47fbe0fe14c3723b77fddec" translate="yes" xml:space="preserve">
          <source>The result of setting up module data is the  &lt;strong id=&quot;call_graph&quot;&gt;Call Graph&lt;/strong&gt;. A (directed) graph consists of a set of vertices and a set of (directed) edges. The edges represent  &lt;strong id=&quot;call&quot;&gt;calls&lt;/strong&gt; (From, To) between functions, modules, applications or releases. From is said to call To, and To is said to be used by From. The vertices of the Call Graph are the functions of all module data: local and exported functions of analyzed modules; used BIFs; used exported functions of library modules; and unknown functions. The functions &lt;code&gt;module_info/0,1&lt;/code&gt; added by the compiler are included among the exported functions, but only when called from some module. The edges are the function calls of all module data. A consequence of the edges being a set is that there is only one edge if a function is locally or externally used several times on one and the same line of code.</source>
          <target state="translated">모듈 데이터를 설정 한 결과는 &lt;strong id=&quot;call_graph&quot;&gt;Call Graph&lt;/strong&gt; 입니다. (방향) 그래프는 정점 세트와 (방향) 에지 세트로 구성됩니다. 가장자리는 기능, 모듈, 응용 프로그램 또는 릴리스 간의 &lt;strong id=&quot;call&quot;&gt;호출&lt;/strong&gt; (보낸 사람,받는 사람)을 나타냅니다 . From은 To를 호출한다고하며 To는 From에서 사용한다고합니다. 콜 그래프의 정점은 모든 모듈 데이터의 기능입니다. 분석 된 모듈의 로컬 및 내 보낸 기능; 중고 BIF; 라이브러리 모듈의 익스포트 된 함수 사용; 알 수없는 기능. &lt;code&gt;module_info/0,1&lt;/code&gt; 함수컴파일러가 추가 한 기능은 내 보낸 함수에 포함되지만 일부 모듈에서 호출 된 경우에만 포함됩니다. 에지는 모든 모듈 데이터의 함수 호출입니다. 에지가 세트의 결과는 하나의 동일한 코드 라인에서 함수가 로컬 또는 외부에서 여러 번 사용되는 경우 하나의 에지 만 존재한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6d992ed8fa86e71532f265c49bcbb4dc25bd864" translate="yes" xml:space="preserve">
          <source>The result of the call is:</source>
          <target state="translated">전화 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aec8dee4e2044b61dfd39541deba480b6fc0f212" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="translated">포트 초기화 결과. &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; 의 리턴 값 , 즉 이 포트에 사용될 오류 코드 또는 &lt;code&gt;ErlDrvData&lt;/code&gt; 와 동일한 값일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c00d452be45830984444ced9bba7583a3c4c38e3" translate="yes" xml:space="preserve">
          <source>The result shows that &amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt; is selected instead of the shorter match &amp;lt;&amp;lt;&quot;bc&quot;&amp;gt;&amp;gt; (which would have given raise to one more match, &amp;lt;&amp;lt;&quot;de&quot;&amp;gt;&amp;gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in &lt;code&gt;re&lt;/code&gt; (and Perl), where instead lexical ordering in the search pattern selects which string matches.</source>
          <target state="translated">결과는 짧은 일치 &amp;lt;&amp;lt; &quot;bc&quot;&amp;gt;&amp;gt; 대신 &amp;lt;&amp;lt; &quot;bcde&quot;&amp;gt;&amp;gt;가 선택되었음을 나타냅니다 (&amp;lt;&amp;lt; &quot;de&quot;&amp;gt;&amp;gt;를 하나 더 일치시킵니다). 이는 POSIX 정규식 (및 awk와 같은 프로그램)의 동작에 해당하지만 &lt;code&gt;re&lt;/code&gt; (및 Perl)의 대체 일치와 일치하지 않습니다 . 대신 검색 패턴의 어휘 순서가 일치하는 문자열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ea7c245c3de8a57733480ff4f2d83525a81309ec" translate="yes" xml:space="preserve">
          <source>The result value is the tuple &lt;code&gt;{ok, List}&lt;/code&gt;, where &lt;code&gt;List&lt;/code&gt; contains the zip archive comment as the first element.</source>
          <target state="translated">결과 값은 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 이며, 여기서 &lt;code&gt;List&lt;/code&gt; 는 첫 번째 요소로 zip 아카이브 주석을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b29ae4d5e694ab8389bf2e90d3d34997e8aec86" translate="yes" xml:space="preserve">
          <source>The result would be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f25af746c0ce14546dc62a293ebeb0fa347f8166" translate="yes" xml:space="preserve">
          <source>The result, ValidElement, is the valid element that conforms to the post-schema-validation infoset. When the validator finds an error it tries to continue and reports a list of all errors found. In those cases an unexpected error is found it may cause a single error reason.</source>
          <target state="translated">결과 ValidElement는 스키마 유효성 검사 후 정보 집합을 따르는 유효한 요소입니다. 유효성 검사기가 오류를 발견하면 계속하려고 시도하고 발견 된 모든 오류 목록을보고합니다. 이러한 경우 예기치 않은 오류가 발견되면 단일 오류 이유가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c0cc39b7355bd656ef96e65ce99409f2da03cd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ETERM&lt;/code&gt; struct is converted into the Erlang external term format using the function &lt;code&gt;erl_encode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; and sent to Erlang using &lt;code&gt;write_cmd()&lt;/code&gt;:</source>
          <target state="translated">얻어진 &lt;code&gt;ETERM&lt;/code&gt; 의 구조체는 함수를 사용하여 외부 얼랑 용어 포맷으로 변환된다 &lt;code&gt;erl_encode()&lt;/code&gt; 에서 &lt;code&gt;erl_marshal&lt;/code&gt; 을 하고 사용 얼랑 전송 &lt;code&gt;write_cmd()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c67db894cf4a73ec37644dab582a90190d4ea154" translate="yes" xml:space="preserve">
          <source>The resulting C program is as follows:</source>
          <target state="translated">결과 C 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76387c891c14647ed37c7c26b256256d64b3a197" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program is as follows:</source>
          <target state="translated">결과 Erlang 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dde85e9e8384430e4dfd5c8f18cbf940581018ee" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functionality for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">포트 중지 및 포트 실패 감지 기능을 포함한 결과 Erlang 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6e57ccb1752b17aec9fbb1ccc1b61f1ccbf9235" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functions for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">포트 중지 및 포트 실패 감지 기능을 포함한 결과 Erlang 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f57a31a3619a4eacb10fbb043b62b825bcea6a9d" translate="yes" xml:space="preserve">
          <source>The resulting output from the command can be read with &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">명령의 결과 출력은 &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt; 으로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2db028a846be38d0f5b491dc0acc0c2de71c7201" translate="yes" xml:space="preserve">
          <source>The resulting source code is written to a file named &quot;&lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt;&quot; in the current directory, unless otherwise specified by the options &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; described below.</source>
          <target state="translated">아래에 설명 된 &lt;code&gt;dir&lt;/code&gt; 및 &lt;code&gt;outfile&lt;/code&gt; 옵션으로 달리 지정하지 않는 한 결과 소스 코드는 현재 디렉토리의 &quot; &lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt; &quot; 이라는 파일에 기록 됩니다.</target>
        </trans-unit>
        <trans-unit id="0942845035c845f735b01ad27ac6b970e03ffed1" translate="yes" xml:space="preserve">
          <source>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</source>
          <target state="translated">결과 구문 트리는 일반적으로 예쁜 인쇄 또는 유사한 시각적 형식화에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3fac0a475f9b69478ab11507fafdcda6f58da223" translate="yes" xml:space="preserve">
          <source>The results from the measurement run (meas) is four excel-compatible textfiles:</source>
          <target state="translated">측정 실행 (meas)의 결과는 다음과 같은 네 가지 Excel 호환 텍스트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f095f8b68579bff1b0c6a6018ac10269dfd93fd4" translate="yes" xml:space="preserve">
          <source>The results of calling the instrumentation are propagated back to the Master Agent.</source>
          <target state="translated">계측을 호출 한 결과는 마스터 에이전트로 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="f749a3c0024a4110d2c9ec3020e59247d2fa1de4" translate="yes" xml:space="preserve">
          <source>The results, the mstone value(s), are written to stdout.</source>
          <target state="translated">결과, mstone 값이 stdout에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="68b25f8a798e229a222e707ac3c343b84eeef3a3" translate="yes" xml:space="preserve">
          <source>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</source>
          <target state="translated">이 함수의 리턴은 Erlang / OTP 컴파일에 사용 된 시스템의 PCRE 버전이있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a5daa3a58a54feb209df655b37c5e59522b9e4ee" translate="yes" xml:space="preserve">
          <source>The return type is always a list of binaries that are all referencing &lt;code&gt;Subject&lt;/code&gt;. This means that the data in &lt;code&gt;Subject&lt;/code&gt; is not copied to new binaries, and that &lt;code&gt;Subject&lt;/code&gt; cannot be garbage collected until the results of the split are no longer referenced.</source>
          <target state="translated">리턴 유형은 항상 &lt;code&gt;Subject&lt;/code&gt; 모두 참조하는 바이너리 목록입니다 . 이는 &lt;code&gt;Subject&lt;/code&gt; 의 데이터 가 새 바이너리로 복사 되지 않으며 분할 결과가 더 이상 참조되지 않을 때까지 &lt;code&gt;Subject&lt;/code&gt; 를 가비지 수집 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cc16505451734ce394057d5190ddadeecb680cef" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Pid&lt;/code&gt; is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</source>
          <target state="translated">반환 값 &lt;code&gt;Pid&lt;/code&gt; 는 다른 모든 기능에서 새로 생성 된 FTP 클라이언트에 대한 참조로 사용되며 연결을 생성 한 프로세스에 의해 호출됩니다. FTP 클라이언트 프로세스는이를 생성 한 프로세스를 모니터링하고 해당 프로세스가 종료되면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f78465bb43d8aa089c1a2e5e2c700b8de6570b00" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">반환 값 &lt;code&gt;Reply&lt;/code&gt; 는 &lt;code&gt;Module:handle_call/2&lt;/code&gt; 의 반환 값에 정의되어 있습니다. 지정된 이벤트 핸들러가 설치되지 않은 경우 함수는 &lt;code&gt;{error,bad_module}&lt;/code&gt; 을 리턴합니다 . 콜백 함수가 &lt;code&gt;Reason&lt;/code&gt; 과 함께 실패 하거나 예기치 않은 값 &lt;code&gt;Term&lt;/code&gt; 을 리턴하는 경우이 함수는 각각 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 또는 &lt;code&gt;{error,Term}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a6289ce75177b974046367704a47c1b35eb2e270" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">반환 값 &lt;code&gt;Reply&lt;/code&gt; 는 &lt;code&gt;Module:handle_call/3&lt;/code&gt; 의 반환 값에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e65900c2497a0e4adbf3bab8d430efb090697d7" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Result&lt;/code&gt; is not further defined, and is always to be ignored.</source>
          <target state="translated">리턴 값 &lt;code&gt;Result&lt;/code&gt; 는 더 이상 정의되지 않으며 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c23fe4eff7b888efd68f97990dace6d93d015ba" translate="yes" xml:space="preserve">
          <source>The return value and the handling of errors and warnings are the same as described for &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 값과 오류 및 경고 처리는 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 에 설명 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ba22696e46bcb1ab14efe031c40d755d114fc6e5" translate="yes" xml:space="preserve">
          <source>The return value can have one of the following types.</source>
          <target state="translated">리턴 값은 다음 유형 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="741aa2cae249c15277ff6de1b81ff1f7de2350e9" translate="yes" xml:space="preserve">
          <source>The return value consists of a &lt;code&gt;Listen&lt;/code&gt; handle (which is later passed to the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback), &lt;code&gt;Address&lt;/code&gt; which is a &lt;code&gt;#net_address{}&lt;/code&gt; record with information about the address for the node (the &lt;code&gt;#net_address{}&lt;/code&gt; record is defined in &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt;), and &lt;code&gt;Creation&lt;/code&gt; which (currently) is an integer &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;Listen&lt;/code&gt; 핸들 (나중에 &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; 콜백 으로 &lt;code&gt;#net_address{}&lt;/code&gt; ), 노드의 주소에 대한 정보 가있는 #net_address {} 레코드 인 &lt;code&gt;Address&lt;/code&gt; 로 구성됩니다 ( &lt;code&gt;#net_address{}&lt;/code&gt; 레코드는 &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt; ) 및 &lt;code&gt;Creation&lt;/code&gt; (현재)는 정수 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab79f181d05026b86f1878e51d4d3441d03c4055" translate="yes" xml:space="preserve">
          <source>The return value follow the same style as for &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 과 동일한 스타일을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="346315afa40134fb62265d734d0e42452e705832" translate="yes" xml:space="preserve">
          <source>The return value for all output functions is &lt;code&gt;0&lt;/code&gt; for normal use. If the driver is used for distribution, it can fail and return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">모든 출력 기능의 반환 값 은 정상 사용시 &lt;code&gt;0&lt;/code&gt; 입니다. 드라이버가 분배에 사용되면 실패하고 &lt;code&gt;-1&lt;/code&gt; 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afe44e353cb6821f37b9d4bc7c2c6cb33639ce4d" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">의 반환 값 &lt;code&gt;enif_make_badarg&lt;/code&gt; 은 전용 (직접 또는 간접적으로)을 호출하거나 통과 할 것을 NIF의 반환 값으로 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; 아니라 다른 NIF의 API 함수.</target>
        </trans-unit>
        <trans-unit id="10dc23a005ca2cd50fc7c1d7990584e9fd2be429" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">의 반환 값 &lt;code&gt;enif_raise_exception&lt;/code&gt; 은 단지 그것을 호출 NIF (직접 또는 간접적으로)에서 반환 값으로 사용하거나 전달 될 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; 하지만 다른 NIF의 API 함수.</target>
        </trans-unit>
        <trans-unit id="41dab507981d86110830d0fd24280799a5b4ee46" translate="yes" xml:space="preserve">
          <source>The return value from the filter fun.</source>
          <target state="translated">필터 fun의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="001a5abd75600054653994ccb358aab2ae66f787" translate="yes" xml:space="preserve">
          <source>The return value from the function is in this case a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</source>
          <target state="translated">이 경우 함수의 반환 값은 &lt;code&gt;list()&lt;/code&gt; 의 &lt;code&gt;list()&lt;/code&gt; 입니다. 각 하위 목록은 제목 문자열에서 선택된 문자열로 시작하고 정규 표현식에서 발생하는 순서대로 각 하위 표현식과 일치하는 부분이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5ccdc21b3308e8b9c79db59288c10d44a28814f7" translate="yes" xml:space="preserve">
          <source>The return value from this function is ignored by Logger.</source>
          <target state="translated">이 함수의 반환 값은 로거에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a4da786e1a06fe4c80b86166fcf1fc85113c7b88" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;-1&lt;/code&gt; if the &lt;code&gt;driver_async&lt;/code&gt; call fails.</source>
          <target state="translated">반환 값은 &lt;code&gt;-1&lt;/code&gt; 경우 생성 &lt;code&gt;driver_async&lt;/code&gt; 의 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e5c3504d0b1f9c55bafbdc1d0b5cee931f0f08b2" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt; for normal use.</source>
          <target state="translated">정상적인 사용을위한 반환 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a5dc674809351c5092cd01b94fa3534964ae836" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless &lt;code&gt;ready_input&lt;/code&gt;/&lt;code&gt;ready_output&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, in which case it is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ready_input&lt;/code&gt; / &lt;code&gt;ready_output&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 반환 값은 &lt;code&gt;0&lt;/code&gt; 이며,이 경우 값 은 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4d60964b41244106524f6879c28f2c548eae606" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless the &lt;code&gt;now&lt;/code&gt; pointer is invalid, in which case it is &amp;lt; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;now&lt;/code&gt; 포인터가 유효하지 않은 경우를 제외하고 리턴 값은 &lt;code&gt;0&lt;/code&gt; 이며, 이 경우 &amp;lt; &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d105bd7aa7f6ee8eda692ca7d456479ff1aacb66" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e56d80f6b96cb9980b29b64b5003509e50ff6732" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Item, Value}&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the requested information as described earlier. If a pid for a dead process was specified, or the name of a non-existing function, &lt;code&gt;Value&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;{Item, Value}&lt;/code&gt; . 여기서 &lt;code&gt;Value&lt;/code&gt; 는 앞에서 설명한 요청 된 정보입니다. 사용 불능 프로세스에 대한 pid가 지정되었거나 존재하지 않는 함수의 이름 인 경우 &lt;code&gt;Value&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c03446d5b267ccb3efe0ace7759b550ebc06efd8" translate="yes" xml:space="preserve">
          <source>The return value is a list of 0, 1, or 2 possible UTC times:</source>
          <target state="translated">리턴 값은 0, 1 또는 2 개의 가능한 UTC 시간 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ce9057d164fb05944ea3d2ae98a443e394d333df" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">반환 값은 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3da23e054f258b1199e04f5ad3b9dd62d3edb83" translate="yes" xml:space="preserve">
          <source>The return value is constructed using the &quot;match variables&quot; bound in &lt;code&gt;MatchHead&lt;/code&gt; or using the special match variables &lt;code&gt;'$_'&lt;/code&gt; (the whole matching object) and &lt;code&gt;'$$'&lt;/code&gt; (all match variables in a list), so that the following &lt;code&gt;match/2&lt;/code&gt; expression:</source>
          <target state="translated">반환 값은 &lt;code&gt;MatchHead&lt;/code&gt; 에 바인딩 된 &quot;일치 변수&quot;를 사용하거나 특수 일치 변수 &lt;code&gt;'$_'&lt;/code&gt; (전체 일치하는 개체) 및 &lt;code&gt;'$$'&lt;/code&gt; (목록의 모든 일치 변수)을 사용하여 다음과 &lt;code&gt;match/2&lt;/code&gt; 표현 :</target>
        </trans-unit>
        <trans-unit id="37128074a43cf6aae3aba83c9d932bd47e3048e4" translate="yes" xml:space="preserve">
          <source>The return value is ignored by Logger.</source>
          <target state="translated">로거는 반환 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c1dfea7d28396da4de4489ef281ff15cca821d15" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;*rbuf&lt;/code&gt; 로 리턴 된 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a34c82452edda3fc5f857c3e407fba4f89b70680" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;. If &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; is returned (or in fact, anything &amp;lt; 0), &lt;code&gt;erlang:port_call/3&lt;/code&gt; throws a &lt;code&gt;BAD_ARG&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;*rbuf&lt;/code&gt; 로 리턴 된 바이트 수입니다 . &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; 이 리턴 되면 (또는 실제로 &amp;lt;0 인 경우) &lt;code&gt;erlang:port_call/3&lt;/code&gt; 은 &lt;code&gt;BAD_ARG&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="eb09cfa81ef1177832f57170b310c9386fb04033" translate="yes" xml:space="preserve">
          <source>The return value is the number of characters written to the file or string, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;buf[index]&lt;/code&gt; does not contain a valid term. Unfortunately, I/O errors on &lt;code&gt;fp&lt;/code&gt; is not checked.</source>
          <target state="translated">리턴 값은 파일 또는 문자열에 기록 된 문자 수 또는 &lt;code&gt;buf[index]&lt;/code&gt; 에 유효한 용어가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 불행히도 &lt;code&gt;fp&lt;/code&gt; 의 I / O 오류 는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d80fb99a8a27fa381ecc5c817818b46b3ab15dd8" translate="yes" xml:space="preserve">
          <source>The return value is the resulting match specification.</source>
          <target state="translated">리턴 값은 결과 일치 스펙입니다.</target>
        </trans-unit>
        <trans-unit id="57668a668af4374fe9545618abb646616a496fcc" translate="yes" xml:space="preserve">
          <source>The return value is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,module_not_found}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;Module:terminate/2&lt;/code&gt; 의 리턴 값입니다 . 지정된 이벤트 핸들러가 설치되지 않은 경우 함수는 &lt;code&gt;{error,module_not_found}&lt;/code&gt; 를 리턴합니다 . 콜백 함수가 &lt;code&gt;Reason&lt;/code&gt; 과 함께 실패하면 함수는 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f156a768e7d53f51540a13419deed4e225aae89a" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1dfedeee7a3af1d51782288cef9cd7e711ef3e94" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. The number of matched events are never larger than 1 as &lt;code&gt;tpe/2&lt;/code&gt; does not accept any form of wildcards for argument &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. &lt;code&gt;tpe/2&lt;/code&gt; 는 &lt;code&gt;Event&lt;/code&gt; 인수에 대해 와일드 카드 양식을 허용하지 않으므로 일치하는 이벤트 수는 1보다 크지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9518162065c311fec4cb8d7246362f3b51e7aea" translate="yes" xml:space="preserve">
          <source>The return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;{error, noconnection}&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not a connected node or &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">리턴 값에서 동일하다 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;{error, noconnection}&lt;/code&gt; 만약 &lt;code&gt;Node&lt;/code&gt; 연결된 노드인지 아닌지 &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a43749a23c3f85f80f04d4b8d3793842d7c78d0b" translate="yes" xml:space="preserve">
          <source>The return value is the space left in the buffer, that is, if &lt;code&gt;ev&lt;/code&gt; contains less than &lt;code&gt;len&lt;/code&gt; bytes it is the difference, and if &lt;code&gt;ev&lt;/code&gt; contains &lt;code&gt;len&lt;/code&gt; bytes or more, it is &lt;code&gt;0&lt;/code&gt;. This is faster if there is more than one header byte, as the binary syntax can construct integers directly from the binary.</source>
          <target state="translated">리턴 값은 버퍼에 남아있는 공간입니다. 즉, &lt;code&gt;ev&lt;/code&gt; 에 &lt;code&gt;len&lt;/code&gt; 바이트 미만이 포함되어 있으면 차이이며, &lt;code&gt;ev&lt;/code&gt; 에 &lt;code&gt;len&lt;/code&gt; 바이트 이상이 포함되어 있으면 &lt;code&gt;0&lt;/code&gt; 입니다. 이진 구문은 이진에서 직접 정수를 생성 할 수 있기 때문에 둘 이상의 헤더 바이트가 있으면 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ac2f53a327ddcef69bcfc81c81e743ec02f58d49" translate="yes" xml:space="preserve">
          <source>The return value is to be any of the following values, indicating if the specified configuration parameter is valid:</source>
          <target state="translated">리턴 값은 지정된 구성 매개 변수가 유효한지 여부를 나타내는 다음 값 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="a53de66b6befed22fef727bcfc1593e2a3510e89" translate="yes" xml:space="preserve">
          <source>The return value is to be either of the following:</source>
          <target state="translated">리턴 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ceafeb40fcc33ae37d1bb500d86c43da7ff973a6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;case&lt;/code&gt; expression.</source>
          <target state="translated">의 반환 값 &lt;code&gt;Body&lt;/code&gt; 의 반환 값 인 &lt;code&gt;case&lt;/code&gt; 식입니다.</target>
        </trans-unit>
        <trans-unit id="667b4e9527fb89bbee21bc3c659692855e17e45e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">의 반환 값 &lt;code&gt;Body&lt;/code&gt; 의 반환 값 인 &lt;code&gt;if&lt;/code&gt; 식입니다.</target>
        </trans-unit>
        <trans-unit id="12267bfd95ce2e9cae7b8fb4988fa796d16c0a33" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;receive&lt;/code&gt; expression.</source>
          <target state="translated">의 반환 값 &lt;code&gt;Body&lt;/code&gt; 의 반환 값입니다 &lt;code&gt;receive&lt;/code&gt; 식입니다.</target>
        </trans-unit>
        <trans-unit id="ea4fae033ca5b8c06d8b471ec021531504980c6e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;end_per_testcase/2&lt;/code&gt; is ignored by the test server, with exception of the &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;fail&lt;/code&gt; 튜플 을 제외하고 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 의 반환 값은 테스트 서버에서 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="56770d741c762804a23c8684019a89bbb9d3b32f" translate="yes" xml:space="preserve">
          <source>The return value of calling this function is intended to be used in the &lt;code&gt;match_fun&lt;/code&gt; option in &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수 호출의 리턴 값은 &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;match_fun&lt;/code&gt; 옵션에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="76590aed6da8a4573a438a60f16632978a2bec67" translate="yes" xml:space="preserve">
          <source>The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;. If you do not want the callback to affect the outcome of the test, return the &lt;code&gt;Return&lt;/code&gt; data as it is given to the CTH. You can also modify the test result. By returning the &lt;code&gt;Config&lt;/code&gt; list with element &lt;code&gt;tc_status&lt;/code&gt; removed, you can recover from a test failure. As in all the pre hooks, it is also possible to fail/skip the test case in the post hook.</source>
          <target state="translated">CTH 함수의 반환 값은 항상 suite / group / test에 대한 결과와 업데이트 된 &lt;code&gt;CTHState&lt;/code&gt; 의 조합 입니다. 콜백이 테스트 결과에 영향을 미치지 않도록하려면 CTH에 제공된대로 &lt;code&gt;Return&lt;/code&gt; 데이터를 리턴하십시오 . 테스트 결과를 수정할 수도 있습니다. &lt;code&gt;tc_status&lt;/code&gt; 요소 가 제거 된 &lt;code&gt;Config&lt;/code&gt; 목록 을 리턴하면 테스트 실패에서 복구 할 수 있습니다. 모든 사전 후크에서와 같이 테스트 후크를 포스트 후크에서 실패 / 건너 뛸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc96c849cea9a13470890e82d87865cfd4ec3cde" translate="yes" xml:space="preserve">
          <source>The return value of the expression is the resulting fun.</source>
          <target state="translated">식의 반환 값이 결과 재미입니다.</target>
        </trans-unit>
        <trans-unit id="ca104835aa5ad01d1fa3d939ad04e391832ceb22" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handler callback:</source>
          <target state="translated">fun의 리턴 값은 로그 이벤트를 버릴 것인지 핸들러 콜백으로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d4e70786797f2c0c82a992fd6de3d9da04e6d44f" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handlers:</source>
          <target state="translated">fun의 리턴 값은 로그 이벤트를 버릴 것인지 핸들러로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8a15ba4a5d207f8ff27af670138d14092b913977" translate="yes" xml:space="preserve">
          <source>The return value of this call is:</source>
          <target state="translated">이 호출의 반환 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad0e0fbdd470e29f0445d4c32a3c5589be7037b8" translate="yes" xml:space="preserve">
          <source>The return value of this function is the same as the result of the commands &lt;code&gt;openssl crl -hash&lt;/code&gt; and &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt;, when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the &lt;code&gt;c_rehash&lt;/code&gt; tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.</source>
          <target state="translated">이 함수의 리턴 값은 각각 CRL 또는 인증서의 발행자 이름을 전달할 때 &lt;code&gt;openssl crl -hash&lt;/code&gt; 및 &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt; 명령의 결과와 동일합니다 . 이 해시는 &lt;code&gt;c_rehash&lt;/code&gt; 도구에서 발급자 이름으로 CRL을 쉽게 찾을 수 있도록 CRL 파일에 대한 심볼릭 링크 디렉토리를 유지 관리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="556ae7c31e2eeb819041e01f0988fe1443eb20ac" translate="yes" xml:space="preserve">
          <source>The return value reflects how many functions that matched, and is constructed as described in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. No tuple &lt;code&gt;{saved, N}&lt;/code&gt; is however ever returned (for obvious reasons).</source>
          <target state="translated">리턴 값은 일치 한 함수 수를 반영하며 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 에 설명 된대로 구성됩니다 . 그러나 튜플 &lt;code&gt;{saved, N}&lt;/code&gt; 은 반환되지 않습니다 (명백한 이유로).</target>
        </trans-unit>
        <trans-unit id="a2493a1b75922ce60ff03955e74f63fe68c01230" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;disabled&lt;/code&gt; , &lt;code&gt;blocked&lt;/code&gt; , &lt;code&gt;blocked_normal&lt;/code&gt; 또는 &lt;code&gt;enabled&lt;/code&gt; 됩니다. 반환 된 값은 &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; 를 호출 한 직후의 상태 를 나타냅니다. 리턴 값에 대한 정보는 &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7a5c4a4e2556d9fc5599788448978bc86e18491" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; 의 경우 와 동일하며 , &lt;code&gt;Reply&lt;/code&gt; 라는 용어도 포함합니다. 이 응답은 &lt;code&gt;call/3,4&lt;/code&gt; 의 리턴 값으로 클라이언트에 대한 응답 입니다.</target>
        </trans-unit>
        <trans-unit id="16402449b6bab46b6acb25bee9687ea3d1da1cef" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="34736dd65ea7c5f985adcd3b21d438aa1d48110e" translate="yes" xml:space="preserve">
          <source>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;nlist&lt;/code&gt; varies. Often real errors are not reported as errors by &lt;code&gt;ls&lt;/code&gt;, even if, for example, a file or directory does not exist. &lt;code&gt;nlist&lt;/code&gt; is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</source>
          <target state="translated">다음 기능의 반환 값은 원격 호스트에서 FTP 서버의 구현에 따라 다릅니다. 특히 &lt;code&gt;ls&lt;/code&gt; 및 &lt;code&gt;nlist&lt;/code&gt; 의 결과는 다양합니다. 파일이나 디렉토리가 존재하지 않더라도 실제 오류는 &lt;code&gt;ls&lt;/code&gt; 에 의해 오류로보고되지 않는 경우가 종종 있습니다. &lt;code&gt;nlist&lt;/code&gt; 는 일반적으로 더 엄격하지만 일부 구현에는 요청이 존재하지만 비어있는 디렉토리 내용의 목록 인 경우 오류로 응답하는 고유 한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e4973c70cdd56da241fcf626185e66a1c55705" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UtilDesc&lt;/code&gt;(s) will be even more detailed.</source>
          <target state="translated">반환 된 &lt;code&gt;UtilDesc&lt;/code&gt; (s)가 더 자세 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea4255b1bb88d05e61ad743eab72330c07b40c58" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;outbound_streams&lt;/code&gt; and &lt;code&gt;inbound_streams&lt;/code&gt; are the stream numbers on the socket. These can be different from the requested values (&lt;code&gt;OutStreams&lt;/code&gt; and &lt;code&gt;MaxInStreams&lt;/code&gt;, respectively) if the peer requires lower values.</source>
          <target state="translated">리턴 된 &lt;code&gt;outbound_streams&lt;/code&gt; 및 &lt;code&gt;inbound_streams&lt;/code&gt; 는 소켓의 스트림 번호입니다. 피어가 더 낮은 값을 요구하는 경우 요청 된 값 ( 각각 &lt;code&gt;OutStreams&lt;/code&gt; 및 &lt;code&gt;MaxInStreams&lt;/code&gt; ) 과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78c4a176ab5344343a3680d64f0f87276de46ba2" translate="yes" xml:space="preserve">
          <source>The returned array is suitable to use with the Unix system call &lt;code&gt;writev&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열은 Unix 시스템 호출 &lt;code&gt;writev&lt;/code&gt; 와 함께 사용하기에 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="45ff48530f77dbc6cc0743bbf1b0bea13f7efa44" translate="yes" xml:space="preserve">
          <source>The returned continuation either is or is not valid in the next call to this function. This is because the log can wrap and delete the file into which the continuation points. To ensure this does not occur, the log can be blocked during the search.</source>
          <target state="translated">반환 된 연속은 다음에이 함수를 호출 할 때 유효하거나 유효하지 않습니다. 로그가 연속 지점이있는 파일을 랩핑하고 삭제할 수 있기 때문입니다. 이 문제가 발생하지 않도록 검색 중에 로그를 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563414bf21c4083de3c0b515b0ae801f03daf271" translate="yes" xml:space="preserve">
          <source>The returned fun augments the verify hostname matching according to the specific rules for the protocol in the argument.</source>
          <target state="translated">리턴 된 fun은 인수의 프로토콜에 대한 특정 규칙에 따라 호스트 이름 확인 기능을 보강합니다.</target>
        </trans-unit>
        <trans-unit id="1f4757970518220fdc7fe112f9433dc5ad370dd2" translate="yes" xml:space="preserve">
          <source>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</source>
          <target state="translated">리턴 된 포인터는 할당 된 메모리에 맞는 내장 유형에 맞게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f0dd9c815f2da7d427b069f2a9894879c7f90c" translate="yes" xml:space="preserve">
          <source>The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established.</source>
          <target state="translated">리턴 된 참조는 서비스 범위 내에서 전송을 고유하게 식별합니다. 전송 연결이 설정되기 전에 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4e5ed52f640bec9583fe09c321a1dc7cfa7d394d" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;ListenSocket&lt;/code&gt; should be used in calls to &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; to accept incoming connection requests.</source>
          <target state="translated">리턴 된 소켓 &lt;code&gt;ListenSocket&lt;/code&gt; 은 들어오는 연결 요청을 승인 하기 위해 &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; 호출에 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ab1d27e257509f8da3d8e76915e7736db74a82b0" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;Socket&lt;/code&gt; is used to send packets from this port with &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt;. When UDP packets arrive at the opened port, if the socket is in an active mode, the packets are delivered as messages to the controlling process:</source>
          <target state="translated">리턴 된 소켓 &lt;code&gt;Socket&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt; 로이 포트에서 패킷을 보내는 데 사용됩니다 . UDP 패킷이 열린 포트에 도착하면 소켓이 활성 모드 인 경우 패킷이 제어 프로세스에 메시지로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ba58f4a868c9920a0accc2470109df28ce1c8b33" translate="yes" xml:space="preserve">
          <source>The returned value equals &lt;code&gt;How&lt;/code&gt; before flag &lt;code&gt;scheduler_bind_type&lt;/code&gt; was changed.</source>
          <target state="translated">리턴 된 값은 &lt;code&gt;scheduler_bind_type&lt;/code&gt; _bind_type 플래그 가 변경 되기 전의 &lt;code&gt;How&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ad1f4738d1ee235637e8713b2fb0e1aed7b3c9ff" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;info&lt;/code&gt; is part of &lt;code&gt;OptionList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 가 &lt;code&gt;OptionList&lt;/code&gt; 의 일부가 아닌 한 , 반환 값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="704d94c2e818c260decb81dbc9e54e317cedcd87" translate="yes" xml:space="preserve">
          <source>The returned value is one of the following:</source>
          <target state="translated">리턴 된 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="17c9f8dadb89f1f4731e454e478946ba8977d737" translate="yes" xml:space="preserve">
          <source>The returned value of the first call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt; by a process will on most systems be the CPU utilization since system boot, but this is not guaranteed and the value should therefore be regarded as garbage. This also applies to the first call after a restart of &lt;code&gt;cpu_sup&lt;/code&gt;.</source>
          <target state="translated">프로세스에 의한 &lt;code&gt;util/0&lt;/code&gt; 또는 &lt;code&gt;util/1&lt;/code&gt; 에 대한 첫 번째 호출의 반환 된 값은 시스템 부팅 이후 대부분의 시스템에서 CPU 사용률이되지만 보장되지 않으므로 값을 가비지로 간주해야합니다. 이것은 &lt;code&gt;cpu_sup&lt;/code&gt; 재시작 후 첫 번째 호출에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bbb8b0494dfde82da9ec11120fc8e7694cd4f11" translate="yes" xml:space="preserve">
          <source>The right hand side of a grammar rule may be empty. This is indicated by using the special symbol &lt;code&gt;'$empty'&lt;/code&gt; as rhs. Then the list grammar above may be simplified to:</source>
          <target state="translated">문법 규칙의 오른쪽이 비어있을 수 있습니다. 이는 특수 기호 &lt;code&gt;'$empty'&lt;/code&gt; 를 rhs 로 사용하여 표시됩니다 . 그런 다음 위의 목록 문법을 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc75d0c89181a304f45200607807515a4ebde020" translate="yes" xml:space="preserve">
          <source>The role of a Diameter node is determined by the user's implementation.</source>
          <target state="translated">직경 노드의 역할은 사용자의 구현에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="416c824ca6a43adb95da91e2cb1751ab089f31b7" translate="yes" xml:space="preserve">
          <source>The room number is an attribute of the employee record. This is a structured attribute that consists of a tuple. The first element of the tuple identifies a corridor, and the second element identifies the room in that corridor. An alternative is to represent this as a record &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; instead of an anonymous tuple representation.</source>
          <target state="translated">회의실 번호는 직원 레코드의 속성입니다. 이것은 튜플로 구성된 구조적 속성입니다. 튜플의 첫 번째 요소는 복도를 식별하고 두 번째 요소는 해당 복도의 방을 식별합니다. 대안은 이것을 레코드 &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; 익명의 튜플 표현 대신.</target>
        </trans-unit>
        <trans-unit id="577f0039c4fa2f0d1ea23b58d0300c235c47b7fd" translate="yes" xml:space="preserve">
          <source>The root certificate is a trusted certificate that is present in the trusted certificate database kept by the peer.</source>
          <target state="translated">루트 인증서는 피어가 유지하는 신뢰할 수있는 인증서 데이터베이스에있는 신뢰할 수있는 인증서입니다.</target>
        </trans-unit>
        <trans-unit id="52dbe02f6473ea542b1777651fa34126c38819b1" translate="yes" xml:space="preserve">
          <source>The root certificate name.</source>
          <target state="translated">루트 인증서 이름</target>
        </trans-unit>
        <trans-unit id="53cd33d8adcdb9225af5611f87476b60c6686390" translate="yes" xml:space="preserve">
          <source>The root directory (&lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt;)</source>
          <target state="translated">루트 디렉토리 ( &lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59cc46abe2ddea6a9a499abb0a284b3438d6e2bb" translate="yes" xml:space="preserve">
          <source>The routine above is called from the &lt;code&gt;uds_output&lt;/code&gt; routine:</source>
          <target state="translated">위의 루틴은 &lt;code&gt;uds_output&lt;/code&gt; 루틴 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="899ef76204638a6cfef4214df04665f53c56597c" translate="yes" xml:space="preserve">
          <source>The routine builds an I/O vector containing the header bytes and the buffer (the opcode has been removed and the buffer length decreased by the output routine). If the queue is empty, we write the data directly to the socket (or at least try to). If any data is left, it is stored in the queue and then we try to send the queue (line 38). An acknowledgement is sent when the message is delivered completely (line 22). The &lt;code&gt;send_out_queue&lt;/code&gt; sends acknowledgements if the sending is completed there. If the port is in &lt;code&gt;command&lt;/code&gt; mode, the Erlang code serializes the send operations so that only one packet can be waiting for delivery at a time. Therefore the acknowledgement can be sent whenever the queue is empty.</source>
          <target state="translated">루틴은 헤더 바이트와 버퍼를 포함하는 I / O 벡터를 빌드합니다 (오피 코드가 제거되었고 버퍼 길이는 출력 루틴에 의해 감소했습니다). 대기열이 비어 있으면 데이터를 소켓에 직접 씁니다 (적어도 시도합니다). 남아있는 데이터가 있으면 대기열에 저장된 다음 대기열을 보내려고합니다 (38 행). 메시지가 완전히 배달되면 승인이 전송됩니다 (22 행). &lt;code&gt;send_out_queue&lt;/code&gt; 는 전송이 완료되면 승인을 보냅니다. 포트가 &lt;code&gt;command&lt;/code&gt; 모드 인 경우 Erlang 코드는 전송 작업을 직렬화하여 한 번에 하나의 패킷 만 전달 대기 할 수 있습니다. 따라서 큐가 비어있을 때마다 승인을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="673662eb2121ca41425305edda42a80c288cd1e9" translate="yes" xml:space="preserve">
          <source>The routine initializes the single global data structure and returns a pointer to the driver entry. The routine is called when &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; is called from Erlang.</source>
          <target state="translated">루틴은 단일 전역 데이터 구조를 초기화하고 드라이버 항목에 대한 포인터를 리턴합니다. Erlang에서 &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; 를 호출하면 루틴이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c17dc336612f84d4c81b404a94002b4ef123f628" translate="yes" xml:space="preserve">
          <source>The routine is simple: it first handles the fact that the output select will concern a socket in the business of connecting (and the connecting blocked). If the socket is in a connected state, it simply sends the output queue. This routine is called when it is possible to write to a socket where we have an output queue, so there is no question what to do.</source>
          <target state="translated">루틴은 간단합니다. 먼저 출력 선택이 연결 및 연결 차단 비즈니스에서 소켓과 관련이 있다는 사실을 처리합니다. 소켓이 연결 상태 인 경우 단순히 출력 큐를 보냅니다. 이 루틴은 출력 대기열이있는 소켓에 쓸 수있을 때 호출되므로 수행 할 작업에 의문의 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="77a723120b7e543c1800db7036e53529bcbbae13" translate="yes" xml:space="preserve">
          <source>The routine tries to read data until a packet is read or the &lt;code&gt;buffered_read_package&lt;/code&gt; routine returns a &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (an internally defined constant for the module, which means that the read operation resulted in an &lt;code&gt;EWOULDBLOCK&lt;/code&gt;). If the port is in &lt;code&gt;command&lt;/code&gt; mode, the reading stops when one package is read. If the port is in &lt;code&gt;data&lt;/code&gt; mode, the reading continues until the socket buffer is empty (read failure). If no more data can be read and more is wanted (which is always the case when the socket is in &lt;code&gt;data&lt;/code&gt; mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_input&lt;/code&gt; callback be called when more data is available for reading.</source>
          <target state="translated">루틴은 패킷을 읽거나 &lt;code&gt;buffered_read_package&lt;/code&gt; 루틴이 &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (모듈에 대해 내부적으로 정의 된 상수를 리턴 할 때까지 데이터를 읽으려고 시도합니다. 즉, 읽기 조작으로 인해 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 이 발생 함 ). 포트가 &lt;code&gt;command&lt;/code&gt; 모드에 있으면 하나의 패키지를 읽을 때 읽기가 중지됩니다. 포트가 &lt;code&gt;data&lt;/code&gt; 모드 인 경우 소켓 버퍼가 비워 질 때까지 읽기가 계속됩니다 (읽기 실패). 더 이상 데이터를 읽을 수없고 더 많은 것을 원한다면 (소켓이 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 항상 &lt;code&gt;driver_select&lt;/code&gt; ) 더 많은 데이터를 읽을 수있을 때 &lt;code&gt;uds_input&lt;/code&gt; 콜백을 호출하기 위해 driver_select 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="594d38181d8b0e2c57da4b81cceed123220efbd4" translate="yes" xml:space="preserve">
          <source>The row for the &lt;strong&gt;marked&lt;/strong&gt; function simply contains the sum of all &lt;strong&gt;calling&lt;/strong&gt; rows.</source>
          <target state="translated">&lt;strong&gt;표시된&lt;/strong&gt; 함수 의 행 에는 모든 &lt;strong&gt;호출&lt;/strong&gt; 행 의 합계가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="f63f268b5b1ba7e518b6ca9840895c249dbd9600" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;called&lt;/strong&gt; functions contains statistics for the &lt;strong&gt;row's&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;marked&lt;/strong&gt; to the &lt;strong&gt;row's&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">에 대한 행 &lt;strong&gt;이라는&lt;/strong&gt; 기능은 통계가 포함되어 &lt;strong&gt;행의&lt;/strong&gt; 전화가에서 만들어진만을 행사하는 제약 조건 기능 &lt;strong&gt;표시&lt;/strong&gt; 받는 &lt;strong&gt;행의&lt;/strong&gt; 기능이 회계를.</target>
        </trans-unit>
        <trans-unit id="b591b9ee5241f27713065c70477c2cb23e6ae07b" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;calling&lt;/strong&gt; functions contain statistics for the &lt;strong&gt;marked&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;row's&lt;/strong&gt; function to the &lt;strong&gt;marked&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">에 대한 행 &lt;strong&gt;호출&lt;/strong&gt; 기능은 통계가 포함 &lt;strong&gt;표시된&lt;/strong&gt; 전화가에서 만들어진만을 행사하는 제약 조건 기능 &lt;strong&gt;행의&lt;/strong&gt; 받는 기능 &lt;strong&gt;표시된&lt;/strong&gt; 기능이 회계를.</target>
        </trans-unit>
        <trans-unit id="23c9bc526d84923d88d3f3c4aca6eb88d00853db" translate="yes" xml:space="preserve">
          <source>The rules for handling the two address passing options are:</source>
          <target state="translated">두 가지 주소 전달 옵션을 처리하기위한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65d47d40f9e3322daa06f6a9cc9586d8bced1031" translate="yes" xml:space="preserve">
          <source>The rules for importing variables into a fun has the consequence that certain pattern matching operations must be moved into guard expressions and cannot be written in the head of the fun. For example, you might write the following code if you intend the first clause of &lt;code&gt;F&lt;/code&gt; to be evaluated when the value of its argument is &lt;code&gt;Y&lt;/code&gt;:</source>
          <target state="translated">변수를 재미로 가져 오기위한 규칙은 특정 패턴 일치 작업을 가드 표현식으로 이동해야하며 재미의 머리에 쓸 수 없습니다. 예를 들어, 인수 값이 &lt;code&gt;Y&lt;/code&gt; 일 때 &lt;code&gt;F&lt;/code&gt; 의 첫 번째 절을 평가 하려는 경우 다음 코드를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b91da3a1a048b58314c1c111db21a5595f2f19a" translate="yes" xml:space="preserve">
          <source>The rules in an access file apply to files in the same directory and in subdirectories. If there exists more than one access file in the path to an asset, the rules in the access file nearest the requested asset is applied.</source>
          <target state="translated">액세스 파일의 규칙은 동일한 디렉토리 및 하위 디렉토리에있는 파일에 적용됩니다. 자산 경로에 둘 이상의 액세스 파일이 있으면 요청 된 자산에 가장 가까운 액세스 파일의 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d38dd44eba1bb3a7ed4f14eaa12a0a33476ba0b" translate="yes" xml:space="preserve">
          <source>The running configuration cannot be deleted and &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; must be advertised by the server.</source>
          <target state="translated">실행중인 구성은 삭제할 수 없으며 서버에서 &lt;code&gt;:candidate&lt;/code&gt; 또는 &lt;code&gt;:startup&lt;/code&gt; 을 보급해야합니다.</target>
        </trans-unit>
        <trans-unit id="c79b5264357f5534cee7c6ef4abc2fbac9660cbd" translate="yes" xml:space="preserve">
          <source>The runtime encoders and decoders execute within a catch and return &lt;code&gt;{ok, Data}&lt;/code&gt; or &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; where &lt;code&gt;Description&lt;/code&gt; is an Erlang term describing the error.</source>
          <target state="translated">런타임 인코더 및 디코더는 catch 내에서 실행되며 &lt;code&gt;{ok, Data}&lt;/code&gt; 또는 &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; 여기서 &lt;code&gt;Description&lt;/code&gt; 은 오류를 설명하는 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="1bd1e0cd445f2587e2d274da2e56ba41b0124a77" translate="yes" xml:space="preserve">
          <source>The runtime for the process, that is, the time that the process has been scheduled in.</source>
          <target state="translated">프로세스의 런타임, 즉 프로세스가 예약 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0477f575396c2d31573bf1177d25d393514ae802" translate="yes" xml:space="preserve">
          <source>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</source>
          <target state="translated">런타임 오버 헤드는 사용 가능한 경우 할당 당 한 단어입니다. 향후 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b52f5dd159b93b951f3b921ca939f057c72f0232" translate="yes" xml:space="preserve">
          <source>The runtime system aborts producing a core dump, if that is enabled in the OS.</source>
          <target state="translated">OS에서 코어 덤프가 활성화되어 있으면 런타임 시스템이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="aedc7575975308f8d984dc3da045923bc133d996" translate="yes" xml:space="preserve">
          <source>The runtime system always takes a lock before running any code in a driver.</source>
          <target state="translated">런타임 시스템은 드라이버에서 코드를 실행하기 전에 항상 잠금을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0b7cb9b63bdfde371041fe9ecc549e2d3f8291fb" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in &lt;strong&gt;interactive&lt;/strong&gt; or &lt;strong&gt;embedded&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;:</source>
          <target state="translated">런타임 시스템은 &lt;strong&gt;대화식&lt;/strong&gt; 또는 &lt;strong&gt;내장&lt;/strong&gt; 모드 에서 시작할 수 있습니다 . 다음 중 명령 행 플래그 &lt;code&gt;-mode&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f194749f9a0abb8f1fc16278fdf82b7ab426657" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in either &lt;strong&gt;embedded&lt;/strong&gt; or &lt;strong&gt;interactive&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템은 &lt;strong&gt;임베디드&lt;/strong&gt; 또는 &lt;strong&gt;대화식&lt;/strong&gt; 모드 에서 시작할 수 있습니다 . 어느 것이 명령 행 플래그 &lt;code&gt;-mode&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="15f0b229ab22b4247144711faf8addfff0acec04" translate="yes" xml:space="preserve">
          <source>The runtime system can represent binaries up to 64 bytes as heap binaries. They are always copied when sent in messages, but they require less memory if they are not sent to another process and garbage collection is cheaper.</source>
          <target state="translated">런타임 시스템은 최대 64 바이트의 바이너리를 힙 바이너리로 나타낼 수 있습니다. 메시지로 보낼 때 항상 복사되지만 다른 프로세스로 보내지 않고 가비지 수집이 더 저렴하면 메모리가 더 적게 필요합니다.</target>
        </trans-unit>
        <trans-unit id="52f7c1d9fec74d1d87c2aa61e92b2f7031396fc6" translate="yes" xml:space="preserve">
          <source>The runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors.</source>
          <target state="translated">런타임 시스템은 기본적으로 스케줄러를 논리 프로세서에 바인드 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fc86dfe1cb0ce649fa9cfc863da2e29d5456fcde" translate="yes" xml:space="preserve">
          <source>The runtime system exits with integer value &lt;code&gt;Status&lt;/code&gt; as status code to the calling environment (OS).</source>
          <target state="translated">런타임 시스템 은 호출 환경 (OS)에 대한 상태 코드로서 정수 값 &lt;code&gt;Status&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="d758492b235e5ae70fd740805f185d0f947792cf" translate="yes" xml:space="preserve">
          <source>The runtime system is halted by calling &lt;code&gt;halt/0,1&lt;/code&gt;. For details, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">&lt;code&gt;halt/0,1&lt;/code&gt; 을 호출하여 런타임 시스템이 정지됩니다 . 자세한 내용 은 ERTS 의 &lt;code&gt;erlang(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="737f6644d46fc0b71dce7d366db4bb2df97d5f28" translate="yes" xml:space="preserve">
          <source>The runtime system is started using a &lt;strong&gt;boot script&lt;/strong&gt;. The boot script contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">런타임 시스템은 &lt;strong&gt;부트 스크립트를&lt;/strong&gt; 사용하여 시작 &lt;strong&gt;됩니다&lt;/strong&gt; . 부팅 스크립트에는로드 할 코드와 시작할 프로세스 및 응용 프로그램에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56dfcd70ad1156309d29b60e153328381d89995" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries can however fail if deprecated features are used.</source>
          <target state="translated">주 버전이 다르거 나 주 버전이 같고 NIF 라이브러리가 사용하는 부 버전이 런타임 시스템에서 사용하는 부 버전보다 큰 경우 런타임 시스템은 일반적으로 NIF 라이브러리로드를 거부합니다. 그러나 메이저 버전이 낮은 이전 NIF 라이브러리는 두 개의 메이저 릴리스 전환 기간 동안 메이저 버전이 충돌 한 후에 허용됩니다. 그러나 더 이상 사용되지 않는 기능을 사용하면 이러한 이전 NIF 라이브러리가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08dd149e2b409426602405250d51453a541efc1d" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a driver if the major versions differ, or if the major versions are equal and the minor version used by the driver is greater than the one used by the runtime system. Old drivers with lower major versions are however allowed after a bump of the major version during a transition period of two major releases. Such old drivers can, however, fail if deprecated features are used.</source>
          <target state="translated">주 버전이 다르거 나 주 버전이 같고 드라이버에서 사용하는 부 버전이 런타임 시스템에서 사용하는 것보다 큰 경우 런타임 시스템은 일반적으로 드라이버로드를 거부합니다. 그러나 메이저 버전이 낮은 구형 드라이버는 두 개의 메이저 릴리스의 전환 기간 동안 메이저 버전이 충돌 한 후에 허용됩니다. 그러나 더 이상 사용되지 않는 기능을 사용하면 이러한 오래된 드라이버가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc8941217d6f38b36e1857530b5476e0fe59285c" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템은 사용 가능한 CPU 정보를 다시 읽고 &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt; 논리 프로세서 수에 대한 내부 저장된 정보를 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="1318205b88fb228dd3bc1e3526e8e8a8014305b4" translate="yes" xml:space="preserve">
          <source>The runtime system sees that &lt;code&gt;Bin1&lt;/code&gt; is the result from a previous append operation (not from the latest append operation), so it &lt;strong&gt;copies&lt;/strong&gt; the contents of &lt;code&gt;Bin1&lt;/code&gt; to a new binary, reserve extra storage, and so on. (Here is not explained how the runtime system can know that it is not allowed to write into &lt;code&gt;Bin1&lt;/code&gt;; it is left as an exercise to the curious reader to figure out how it is done by reading the emulator sources, primarily &lt;code&gt;erl_bits.c&lt;/code&gt;.)</source>
          <target state="translated">런타임 시스템은 &lt;code&gt;Bin1&lt;/code&gt; 이 이전 추가 작업 (최신 추가 작업이 아닌)의 결과이므로 &lt;code&gt;Bin1&lt;/code&gt; 의 내용을 새 바이너리로 &lt;strong&gt;복사&lt;/strong&gt; 하고 추가 스토리지를 예약하는 등의 작업을 수행합니다. (여기에는 런타임 시스템이 &lt;code&gt;Bin1&lt;/code&gt; 에 쓸 수 없다는 것을 어떻게 알 수 있는지 설명되어 있지 않습니다 . 호기심 독자에게는 연습 문제로 남겨 &lt;code&gt;erl_bits.c&lt;/code&gt; 에뮬레이터 소스 (주로 erl_bits.c )를 읽는 방법을 알아 내야 합니다.)</target>
        </trans-unit>
        <trans-unit id="68dc9c39652a0fdf0a0c35a5221cd9cab865f995" translate="yes" xml:space="preserve">
          <source>The runtime system terminates if the Erlang shell is terminated.</source>
          <target state="translated">Erlang 쉘이 종료되면 런타임 시스템이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6b04664129c94fdc81f4426dc13b0df0dd9a3c" translate="yes" xml:space="preserve">
          <source>The runtime system thread that caused the crash dump</source>
          <target state="translated">크래시 덤프를 유발 한 런타임 시스템 스레드</target>
        </trans-unit>
        <trans-unit id="788e5f8c02e60181a54b252b202da78929f68515" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템은 드라이버가 SMP 지원 런타임 시스템에서 실행될 때 드라이버 레벨 잠금 대신이 드라이버를 실행하는 모든 포트에서 포트 레벨 잠금을 사용합니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="625eb63fcb0f8ad6e285974d83dcb34f448ce002" translate="yes" xml:space="preserve">
          <source>The runtime user interface for exclusive decode consists of the following two functions:</source>
          <target state="translated">단독 디코딩을위한 런타임 사용자 인터페이스는 다음 두 가지 기능으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8b6a0c2dcea74f8fdf356aa85c68643c16e46c9" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;ct_hooks&lt;/code&gt; statement without the configuration file would cause HTML logging of all NETCONF connections in to the test case HTML log.</source>
          <target state="translated">구성 파일이없는 동일한 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 테스트 케이스 HTML 로그에 모든 NETCONF 연결의 HTML 로깅을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="c6d70dc4cc333eac788e481d9bbdc225c08c481a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f2aaed7b59951ec082934bf672a9d13e59338ac6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Actions = []&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered. This creates an anonymous server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 이 등록 되지 않았 음을 제외하고 &lt;code&gt;Actions = []&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 과 동일 합니다. 이것은 익명 서버를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="01deb53c6f9077db7db997ce628218c4238aba6e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="85756b3d7fbfe5ef4170983b9b2a6fc5fb5e5087" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="1e5fb0bebe29ee84d11970a1ce3108bad78b288e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="74fa8e723ce6c07be8e482111c905cf750f679e8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="translated">같은 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt; 하지만 부울 반환 값.</target>
        </trans-unit>
        <trans-unit id="d2197ab46f758634a9dcf871583d61827a00cf65" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="translated">같은 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt; 만 반환 &lt;code&gt;true&lt;/code&gt; 메시지가 전송 된 경우 &lt;code&gt;false&lt;/code&gt; 를 보낸 사람이 일시 중단해야했습니다 때문에 메시지가 전송되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="1075e0e25bfb14e858cab7e38be5445bc5ac4682" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;, except that it also include information about all dirty I/O schedulers.</source>
          <target state="translated">같은 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; , 또한 모든 더러운 I / O 스케줄러에 대한 정보를 포함하는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="f4ceb7a27c576e85ef9e754da89ddaf1dfd654ed" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4b72b3a948c1e65ff99938c20b299ba036c263f7" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="feaf6b5c71e3fafb1e75897b45c0e3840025bb7c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="translated">동일한 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt; , 역방향 호환성을 유지한다.</target>
        </trans-unit>
        <trans-unit id="d5a1ef850fec5e3df173bd9dd2c7e3dbb0636f60" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt;.</source>
          <target state="translated">같은 &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="619006029171444306cc4c87f6a95f63bb972338" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;compile(Regexp,[])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;compile(Regexp,[])&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="17d52831ded701ec877189bfcc53acad1352798f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;eval/1&lt;/code&gt;, but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. For information about the variable bindings, see &lt;code&gt;erl_eval(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eval/1&lt;/code&gt; 과 동일 하지만 변수 바인딩 &lt;code&gt;Bindings&lt;/code&gt; 가 평가에 사용됩니다. 변수 바인딩에 대한 정보는 &lt;code&gt;erl_eval(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08c1e708a98116e2d68d4f0a5026b6a10643e95a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">동일한 &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebcfaf2f1268befcb2c2ddd0543f3e6acf79842" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">동일하게 &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47b9133116b8c5faac32e3c70f25a2bffa651d8f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;path_script/2&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">&lt;code&gt;path_script/2&lt;/code&gt; 와 동일 하지만 변수 바인딩 &lt;code&gt;Bindings&lt;/code&gt; 이 평가에 사용됩니다. 변수 바인딩에 대해서는 &lt;code&gt;erl_eval(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40cc315183d06f20b4fd979426474e04d552a45f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;script/1&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">&lt;code&gt;script/1&lt;/code&gt; 과 동일 하지만 변수 바인딩 &lt;code&gt;Bindings&lt;/code&gt; 가 평가에 사용됩니다. 변수 바인딩에 대해서는 &lt;code&gt;erl_eval(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1e8982b6aae2a82fb446c9ac15561cf18afb817" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{bof, Offset}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{bof, Offset}&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b0277407f00337c8bdaf1cca96cdd266e8ea8198" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; with reasonable default values for &lt;code&gt;Size&lt;/code&gt; and &lt;code&gt;Delay&lt;/code&gt; (roughly some 64 KB, 2 seconds).</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 및 &lt;code&gt;Delay&lt;/code&gt; 대한 적절한 기본값 (약 64KB, 2 초)을 가진 &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7228431770d5bb25829bb566f3e53142c058363b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{read_ahead, Size}&lt;/code&gt; with a reasonable default value for &lt;code&gt;Size&lt;/code&gt; (roughly some 64 KB).</source>
          <target state="translated">같은 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 을위한 합리적인 디폴트 값 &lt;code&gt;Size&lt;/code&gt; (약 64- KB).</target>
        </trans-unit>
        <trans-unit id="cb4ea9e9c62a5f384a690dd1c1b7a864f413d95a" translate="yes" xml:space="preserve">
          <source>The same as above with &lt;code&gt;Offset&lt;/code&gt; 0.</source>
          <target state="translated">&lt;code&gt;Offset&lt;/code&gt; 0 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c0b12e07cbe44403181759c4034c4f3d2fe0c1ce" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">&lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 호출과 동일 하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="71c6f84a59f77755e69a52beb91ed4b1a4c03ff2" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">&lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 호출과 동일 하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ee4e69e3e7435faa22aa0647b7b837e57300ad5e" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">&lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 호출과 동일 하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4780b4915f09916bc2a903be56062c7fb948d806" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">&lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 호출과 동일 하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="bf890bcea15d91e1f7af9ee8721c2b6276c19354" translate="yes" xml:space="preserve">
          <source>The same as eariler with &lt;code&gt;Offset&lt;/code&gt; 0, that is, &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Offset&lt;/code&gt; 0 인 Eariler와 동일합니다 . 즉 &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efec8691cd75c256c32c494b80c6d71a6ded7b5a" translate="yes" xml:space="preserve">
          <source>The same example as the first sign example, except that a password protects the key down in the Engine.</source>
          <target state="translated">비밀번호가 엔진에서 키를 보호한다는 점을 제외하고 첫 번째 부호 예제와 동일한 예제입니다.</target>
        </trans-unit>
        <trans-unit id="11685d22af41c7bdec311d8efb6717608cc97597" translate="yes" xml:space="preserve">
          <source>The same failure as for &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 과 동일한 실패 입니다.</target>
        </trans-unit>
        <trans-unit id="37284fa9bdbec3125fb6f5f2938b0a9140415e5c" translate="yes" xml:space="preserve">
          <source>The same happens if you insert a binary into an Ets table, send it to a port using &lt;code&gt;erlang:port_command/2&lt;/code&gt;, or pass it to &lt;code&gt;enif_inspect_binary&lt;/code&gt; in a NIF.</source>
          <target state="translated">바이너리를 Ets 테이블에 삽입하거나 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 를 사용하여 포트로 보내 거나 NIF의 &lt;code&gt;enif_inspect_binary&lt;/code&gt; 로 전달하는 경우 에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="8dd676fc032f39da8f11e805e928df982b381e69" translate="yes" xml:space="preserve">
          <source>The same logic applies to explicitly imported functions from other modules, as to locally defined functions. It is not allowed to both import a function from another module and have the function declared in the module at the same time:</source>
          <target state="translated">로컬로 정의 된 함수와 다른 논리에서 명시 적으로 가져온 함수에 동일한 논리가 적용됩니다. 다른 모듈에서 함수를 가져오고 동시에 모듈에서 함수를 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9a8dd64d3d825a10122f8306efa89f8d1dff40d" translate="yes" xml:space="preserve">
          <source>The same occurs if &lt;code&gt;Dest&lt;/code&gt; refers to a local port that is busy. For all other destinations (allowed for the ordinary send operator &lt;code&gt;'!'&lt;/code&gt;), this function sends the message and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dest&lt;/code&gt; 가 사용중인 로컬 포트를 참조하는 경우에도 마찬가지 입니다. 다른 모든 대상 (일반 전송 연산자 &lt;code&gt;'!'&lt;/code&gt; 에 허용 )의 경우이 함수는 메시지를 전송하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4c986670ac5f53fe5b7d5d769f706fae8b44b1bd" translate="yes" xml:space="preserve">
          <source>The same principles of serialization apply when passing resource terms in messages to remote nodes and back again. A resource term will act stale on all nodes except the node where its resource object is still alive in memory.</source>
          <target state="translated">메시지의 자원 용어를 원격 노드로 전달하고 다시 되돌릴 때 동일한 직렬화 원칙이 적용됩니다. 자원 용어는 자원 오브젝트가 여전히 메모리에있는 노드를 제외한 모든 노드에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f281f033368479cef02a66d827c4b8a6fe27bfd" translate="yes" xml:space="preserve">
          <source>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to &lt;code&gt;error_logger.&lt;/code&gt;</source>
          <target state="translated">더티 업데이트에서도 동일한 문제가 발생할 수 있습니다. 과부하는 현재 노드에서 로컬로 감지되지만 그 원인은 다른 노드에있을 수 있습니다. 테이블이 다른 노드에있는 경우 (복제 여부에 관계없이) 응용 프로그램 프로세스는 높은로드를 유발할 수 있습니다. 기본적으로이 이벤트는 &lt;code&gt;error_logger.&lt;/code&gt; 에보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb9bbb6e34766185444c1af2a9a7f778b5a58e67" translate="yes" xml:space="preserve">
          <source>The same program can also be written as:</source>
          <target state="translated">동일한 프로그램을 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc6942530a03944111630cfbde674aeb2b9833c" translate="yes" xml:space="preserve">
          <source>The same reasons for using the parse transformation apply to &lt;code&gt;dbg&lt;/code&gt;, maybe even more, as filtering using Erlang code is not a good idea when tracing (except afterwards, if you trace to file). The concept is similar to that of &lt;code&gt;ets:fun2ms/1&lt;/code&gt; except that you usually use it directly from the shell (which can also be done with &lt;code&gt;ets:fun2ms/1&lt;/code&gt;).</source>
          <target state="translated">구문 분석시 구문 분석 변환을 사용하는 것과 동일한 이유는 &lt;code&gt;dbg&lt;/code&gt; 에 적용될 수 있습니다. Erlang 코드를 사용한 필터링은 추적 할 때 좋지 않습니다 (나중에 파일을 추적하는 경우 제외). 개념은 비슷하다 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 은 일반적으로 (또한 함께 할 수있는 쉘에서 직접 사용하는 것을 제외 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="be2c67bb51461ede16f91f4276fe7a51514360a8" translate="yes" xml:space="preserve">
          <source>The same result can be obtained by using the flag &lt;code&gt;call&lt;/code&gt; only and setting a match specification on local or global function calls as follows:</source>
          <target state="translated">플래그 &lt;code&gt;call&lt;/code&gt; 만 사용하고 다음과 같이 로컬 또는 글로벌 함수 호출에서 일치 스펙을 설정 하여 동일한 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6367b3aadbf1b22efb4fe6d60edce34f7915ed4d" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used by the preprocessor, which supports file inclusion, macros, and conditional compilation:</source>
          <target state="translated">파일 속성, 매크로 및 조건부 컴파일을 지원하는 프리 프로세서에서 모듈 속성과 동일한 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1ba61a6106c571f4543444dde7af8861fee4288b" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for changing the pre-defined macros &lt;code&gt;?FILE&lt;/code&gt; and &lt;code&gt;?LINE&lt;/code&gt;:</source>
          <target state="translated">사전 정의 된 매크로 &lt;code&gt;?FILE&lt;/code&gt; 및 &lt;code&gt;?LINE&lt;/code&gt; 을 변경하는 데 모듈 속성과 동일한 구문이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="49b27eed80040be071f7bd6b90b55a6ca7a1a602" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for record definitions:</source>
          <target state="translated">모듈 정의와 동일한 구문이 레코드 정의에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="652d4a8a5d229c7cd102ddf9155b41205986af36" translate="yes" xml:space="preserve">
          <source>The same, provided there are &amp;lt; 40 previous capturing subpatterns</source>
          <target state="translated">&amp;lt;40 개의 이전 캡처 하위 패턴이있는 경우 동일</target>
        </trans-unit>
        <trans-unit id="1f8c820898fda9a674e186f206f12995037f99bb" translate="yes" xml:space="preserve">
          <source>The scanner will, by default, be built as a reentrant scanner &lt;strong&gt;if&lt;/strong&gt; the flex utility supports this (it depends on the version of flex). It is possible to explicitly disable this even when flex support this. Use &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; when configuring the application.</source>
          <target state="translated">flex 유틸리티가이를 지원하는 &lt;strong&gt;경우&lt;/strong&gt; 스캐너는 기본적으로 재진입 스캐너로 구축됩니다 (flex 버전에 따라 다름). flex가 이것을 지원하는 경우에도 이것을 명시 적으로 비활성화 할 수 있습니다. 사용 &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; 응용 프로그램을 구성 할 때.</target>
        </trans-unit>
        <trans-unit id="0106bb004e9ef4cae180d81bd2193ccedbf77a79" translate="yes" xml:space="preserve">
          <source>The scanning was successful. &lt;code&gt;Tokens&lt;/code&gt; is the list of tokens including &lt;strong&gt;dot&lt;/strong&gt;.</source>
          <target state="translated">스캔이 성공했습니다. &lt;code&gt;Tokens&lt;/code&gt; 은 &lt;strong&gt;dot을&lt;/strong&gt; 포함한 토큰 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="5b2eae5d531637391bdf1a2942db36f759f3d1ab" translate="yes" xml:space="preserve">
          <source>The scenario is illustrated in the following figure:</source>
          <target state="translated">시나리오는 다음 그림에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bb445fb55208c8d6300f1c0c3c7ddd0fdd5dffb" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt;+sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">스케줄러 바인드 유형은 명령 행 인수 &lt;code&gt;+sbt&lt;/code&gt; 를 &lt;code&gt;erl(1)&lt;/code&gt; 에 전달하여 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9aa6c41e456afc02a165b00e6454af974767459" translate="yes" xml:space="preserve">
          <source>The scheduler ids whose allocator instances will be searched. A scheduler id of 0 will refer to the global instance that is not tied to any particular scheduler. Defaults to all schedulers and the global instance.</source>
          <target state="translated">할당 자 인스턴스가 검색 될 스케줄러 ID입니다. 스케줄러 ID 0은 특정 스케줄러에 연결되지 않은 글로벌 인스턴스를 나타냅니다. 모든 스케줄러 및 글로벌 인스턴스가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f8238b4700efd0d55eb3ba098718fdc8466aa0bb" translate="yes" xml:space="preserve">
          <source>The schema file and all other files that Mnesia needs are kept in the Mnesia directory. The command-line option &lt;code&gt;-mnesia dir Dir&lt;/code&gt; can be used to specify the location of this directory to the Mnesia system. If no such command-line option is found, the name of the directory defaults to &lt;code&gt;Mnesia.Node&lt;/code&gt;.</source>
          <target state="translated">Mnesia에 필요한 스키마 파일 및 기타 모든 파일은 Mnesia 디렉토리에 보관됩니다. 명령 행 옵션 &lt;code&gt;-mnesia dir Dir&lt;/code&gt; 을 사용하여이 디렉토리의 위치를 ​​Mnesia 시스템에 지정할 수 있습니다. 이러한 명령 행 옵션이 &lt;code&gt;Mnesia.Node&lt;/code&gt; 디렉토리 이름의 기본값은 Mnesia.Node 입니다.</target>
        </trans-unit>
        <trans-unit id="e3f92f1963a15447bf5f1771a2c485f240d49382" translate="yes" xml:space="preserve">
          <source>The schema functions are as follows:</source>
          <target state="translated">스키마 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c514498238aab18641162374c9ebc46e751b79e" translate="yes" xml:space="preserve">
          <source>The schema in the backup file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been used to generate the file &lt;code&gt;schema.DAT&lt;/code&gt;. Since there are no other disc resident tables than the schema, no other data files were created. The file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; was removed after the successful &quot;restoration&quot;. You also see some files that are for internal use by &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">백업 파일 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 의 스키마 는 파일 &lt;code&gt;schema.DAT&lt;/code&gt; 를 생성하는 데 사용되었습니다 . 스키마 외에 다른 디스크 상주 테이블이 없으므로 다른 데이터 파일이 작성되지 않았습니다. &quot;복원&quot;성공 후 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 파일 이 제거되었습니다. 또한 &lt;code&gt;Mnesia&lt;/code&gt; 가 내부 용으로 사용하는 파일도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c0d7180f9e8c49acad7689271d60b75c4177036" translate="yes" xml:space="preserve">
          <source>The schema itself is a table and is possibly included in the backup. Each node where the schema table resides is regarded as a &lt;code&gt;db_node&lt;/code&gt;.</source>
          <target state="translated">스키마 자체는 테이블이며 백업에 포함될 수 있습니다. 스키마 테이블이있는 각 노드는 &lt;code&gt;db_node&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cd14602cf9237e1ff86bf0c3f394217395aea3d" translate="yes" xml:space="preserve">
          <source>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;ram_copies&lt;/code&gt; (but not &lt;code&gt;disc_only_copies&lt;/code&gt;). At startup, &lt;code&gt;Mnesia&lt;/code&gt; uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; contains a list of nodes that &lt;code&gt;Mnesia&lt;/code&gt; also is to establish contact with besides those found in the schema. Default is &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">다른 테이블처럼 스키마 테이블은 하나 이상의 노드에 상주 할 수 있습니다. 스키마 테이블의 스토리지 유형은 &lt;code&gt;disc_copies&lt;/code&gt; 또는 &lt;code&gt;ram_copies&lt;/code&gt; 일 수 있지만 &lt;code&gt;disc_only_copies&lt;/code&gt; 는 아닙니다 . 시작시 &lt;code&gt;Mnesia&lt;/code&gt; 는 해당 스키마를 사용하여 컨택을 설정하려는 노드를 결정합니다. 다른 노드가 이미 시작된 경우 시작 노드는 테이블 정의를 다른 노드에서 가져온 테이블 정의와 병합합니다. 이는 스키마 테이블 자체의 정의에도 적용됩니다. 응용 프로그램 매개 변수 &lt;code&gt;extra_db_nodes&lt;/code&gt; 에는 Mnesia 가 스키마에서 찾은 노드 &lt;code&gt;Mnesia&lt;/code&gt; 의 노드 와 연결을 설정 해야하는 노드 목록이 포함되어 있습니다 . 기본값은 &lt;code&gt;[]&lt;/code&gt; (빈 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="503d5a4fc67df91a919a603a14d890c204b2864e" translate="yes" xml:space="preserve">
          <source>The scheme portion of the URI gets converted into atom, meaning that atom leak may occur. Specifying a scheme validation fun is recommended unless the URI is already sanitized.</source>
          <target state="translated">URI의 체계 부분은 원자로 변환되어 원자 누출이 발생할 수 있음을 의미합니다. URI가 이미 삭제되지 않은 경우 스키마 유효성 검사 재미를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d3677cc5dde8dec9f0943fbc75e45b112aeaf536" translate="yes" xml:space="preserve">
          <source>The scope for a variable is its function clause. Variables bound in a branch of an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, or &lt;code&gt;receive&lt;/code&gt; expression must be bound in all branches to have a value outside the expression. Otherwise they are regarded as 'unsafe' outside the expression.</source>
          <target state="translated">변수의 범위는 함수 절입니다. &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;receive&lt;/code&gt; 표현식 의 분기에 바인드 된 변수 는 표현식 외부의 값을 갖도록 모든 분기에 바인드되어야합니다. 그렇지 않으면 표현 외부에서 '안전하지 않은'것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c6288b2668a38169687226d8d788cc7da7e3e234" translate="yes" xml:space="preserve">
          <source>The scope of a &lt;code&gt;::&lt;/code&gt; constraint is the &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; specification after which it appears. To avoid confusion, it is suggested that different variables are used in different constituents of an overloaded contract, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 제약 조건 의 범위는 &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; 사양입니다. 혼동을 피하기 위해 다음 예에 표시된 것처럼 과부하 된 계약의 다른 구성 요소에 다른 변수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6888ff9909aa4d3472400691e9c55573d784edc2" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in funs are as follows:</source>
          <target state="translated">재미로 발생하는 변수의 범위 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4404d931933003579634af4e100185e648005e9e" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in list comprehensions are as follows:</source>
          <target state="translated">목록 이해에서 발생하는 변수의 범위 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57d16d66e3e9f378f0fafcdd50a83455cdc8ed0f" translate="yes" xml:space="preserve">
          <source>The script is checked for syntactic and semantic correctness before it is run. If there are warnings (such as unused variables), they are printed and the script will still be run. If there are errors, they are printed and the script will not be run and its exit status is &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">스크립트가 실행되기 전에 구문 및 의미의 정확성을 검사합니다. 사용되지 않는 변수와 같은 경고가있는 경우 경고가 인쇄되고 스크립트가 계속 실행됩니다. 오류가있는 경우 오류가 인쇄되고 스크립트가 실행되지 않고 종료 상태는 &lt;code&gt;127&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2eb62b1588228fdb2e00bea0a69e7992a3a90205" translate="yes" xml:space="preserve">
          <source>The search is retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (&lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">동일한 위치에서 &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; 옵션을 사용하여 검색을 재 시도 하므로 더 긴 길이의 흥미로운 결과를 얻지 못하므로 검색 위치가 다음 문자 ( &lt;code&gt;a&lt;/code&gt; )로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4117f8cd43f5fed32f2aebfe701accad0f731400" translate="yes" xml:space="preserve">
          <source>The search once again matches the empty string, giving &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt;.</source>
          <target state="translated">검색은 다시 빈 문자열과 일치하여 &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt; 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2957d4c2e73e120f5160a9d5de1e8eab79ab85bf" translate="yes" xml:space="preserve">
          <source>The search results in &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt;, so this search is also repeated with the extra options.</source>
          <target state="translated">검색 결과는 &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt; 이므로 추가 옵션을 사용하여이 검색을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="7019ec1c2fea8d709b52cfb8681127b05dd6a6ce" translate="yes" xml:space="preserve">
          <source>The second argument is a string defining the magic cookie.</source>
          <target state="translated">두 번째 인수는 매직 쿠키를 정의하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5d7c556937d2f0d9d84069b86f16a68647203e8c" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;code&gt;Config&lt;/code&gt; key-value list of runtime configuration data, which has the same value as the list returned by &lt;code&gt;init_per_suite&lt;/code&gt;. &lt;code&gt;init_per_testcase/2&lt;/code&gt; can modify this parameter or return it &quot;as is&quot;. The return value of &lt;code&gt;init_per_testcase/2&lt;/code&gt; is passed as parameter &lt;code&gt;Config&lt;/code&gt; to the test case itself.</source>
          <target state="translated">두 번째 인수는 런타임 구성 데이터 의 &lt;code&gt;Config&lt;/code&gt; 키-값 목록이며 &lt;code&gt;init_per_suite&lt;/code&gt; 가 반환 한 목록과 동일한 값을 갖습니다 . &lt;code&gt;init_per_testcase/2&lt;/code&gt; 는이 매개 변수를 수정하거나 &quot;있는 그대로&quot;리턴 할 수 있습니다. &lt;code&gt;init_per_testcase/2&lt;/code&gt; 의 리턴 값은 매개 변수 &lt;code&gt;Config&lt;/code&gt; 로 테스트 케이스 자체에 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab475df1b91ae9d944e6820d1389807d78bf68f6" translate="yes" xml:space="preserve">
          <source>The second argument is the array of &lt;code&gt;ErlNifFunc&lt;/code&gt; structures containing name, arity, and function pointer of each NIF.</source>
          <target state="translated">두 번째 인수는 각 NIF의 이름, 속성 및 함수 포인터를 포함하는 &lt;code&gt;ErlNifFunc&lt;/code&gt; 구조 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="0886faad82449f45fc6af07be32433d58c83fd99" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the module (&lt;code&gt;ch4&lt;/code&gt;).</source>
          <target state="translated">두 번째 인수는 모듈의 이름입니다 ( &lt;code&gt;ch4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ae91f868e0e36c5aab81d0643e970c9ad85647d4" translate="yes" xml:space="preserve">
          <source>The second argument is the plain node name.</source>
          <target state="translated">두 번째 인수는 일반 노드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="68aa2b0acb6c307f4edca5d2585ef7f3b4bc172b" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;erl_accept&lt;/code&gt; is a struct &lt;code&gt;ErlConnect&lt;/code&gt; which contains useful information when a connection has been established, for example, the name of the Erlang node.</source>
          <target state="translated">&lt;code&gt;erl_accept&lt;/code&gt; 의 두 번째 인수 는 연결이 설정 될 때 유용한 정보 (예 : Erlang 노드 이름)를 포함 하는 struct &lt;code&gt;ErlConnect&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa4ea88aab8e44c4912833f7bf79be8a3c8b83f1" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;select&lt;/code&gt; is a &lt;code&gt;MatchSpecification&lt;/code&gt;. A &lt;code&gt;MatchSpecification&lt;/code&gt; is a list of &lt;code&gt;MatchFunction&lt;/code&gt;s, where each &lt;code&gt;MatchFunction&lt;/code&gt; consists of a tuple containing &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 두 번째 인수 는 &lt;code&gt;MatchSpecification&lt;/code&gt; 입니다. &lt;code&gt;MatchSpecification&lt;/code&gt; 는 목록이다 &lt;code&gt;MatchFunction&lt;/code&gt; 각 S, &lt;code&gt;MatchFunction&lt;/code&gt; 를 포함하는 튜플 구성 &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="859328262eb9b89de95770488ed8f287011c831c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;ttb:format/2&lt;/code&gt; is a list of options as follows:</source>
          <target state="translated">&lt;code&gt;ttb:format/2&lt;/code&gt; 의 두 번째 인수 는 다음과 같은 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d294655854fb12427e99c41c78c6470facb9f485" translate="yes" xml:space="preserve">
          <source>The second argument to the filter fun.</source>
          <target state="translated">필터 재미에 대한 두 번째 주장.</target>
        </trans-unit>
        <trans-unit id="c06be8768f8415da3e4862a8bcd381b621322fa1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located, which is this module.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;?MODULE&lt;/code&gt; 은 콜백 모듈의 이름, 즉 콜백 함수가있는 모듈 (이 모듈)입니다.</target>
        </trans-unit>
        <trans-unit id="e11f122b81a9ab6f35f17499a7c2e31dc0343a63" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;[]&lt;/code&gt; 는 콜백 함수 &lt;code&gt;init&lt;/code&gt; 에 그대로 전달되는 용어입니다 . 여기서 &lt;code&gt;init&lt;/code&gt; 에는 데이터가 필요하지 않으며 인수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b862edb2184436a21646c9503b2f3762af04c9d1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;ch3&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located.</source>
          <target state="translated">두 번째 인수 인 &lt;code&gt;ch3&lt;/code&gt; 은 콜백 모듈의 이름, 즉 콜백 함수가있는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="12a6cc1ddca791145f200b7b0393d7c9270fb068" translate="yes" xml:space="preserve">
          <source>The second clause sends a message to &quot;pong&quot;:</source>
          <target state="translated">두 번째 절은 &quot;pong&quot;에 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7315fa80ba44205c16b829da74dfc058d1a1d7a4" translate="yes" xml:space="preserve">
          <source>The second element of the PEM-entry is the ASN.1 &lt;code&gt;DER&lt;/code&gt; encoded key data:</source>
          <target state="translated">PEM 항목의 두 번째 요소는 ASN.1 &lt;code&gt;DER&lt;/code&gt; 인코딩 된 키 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="c40944389ed2e7f80311414a40c89625de90b8fe" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function.</source>
          <target state="translated">튜플의 두 번째 요소는 함수 소스 파일의 파일 이름을 나타내는 문자열 (문자 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="30419a9fbcf62ba4094ad4eff3e638ac58c744c8" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is the line number (an integer &amp;gt; 0) in the source file where the exception occurred or the function was called.</source>
          <target state="translated">튜플의 두 번째 요소는 예외가 발생하거나 함수가 호출 된 소스 파일의 줄 번호 (정수&amp;gt; 0)입니다.</target>
        </trans-unit>
        <trans-unit id="bc7d989f87dede2e2ca73a50e9ef9b041bd4465f" translate="yes" xml:space="preserve">
          <source>The second instruction, &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt;, takes component &lt;code&gt;number&lt;/code&gt; in the &lt;code&gt;handle&lt;/code&gt; component of type &lt;code&gt;Action&lt;/code&gt;. If the value is &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt;, the internal value 4711 is to be picked by &lt;code&gt;selected_decode_Action&lt;/code&gt;. In an Erlang terminal it looks as follows:</source>
          <target state="translated">두 번째 명령어 인 &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt; 은 &lt;code&gt;Action&lt;/code&gt; 유형 의 &lt;code&gt;handle&lt;/code&gt; 구성 요소 에서 구성 요소 &lt;code&gt;number&lt;/code&gt; 를 사용합니다 . 값이 &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt; 경우, 내부 값 4711은 &lt;code&gt;selected_decode_Action&lt;/code&gt; 에 의해 선택 됩니다. Erlang 터미널에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09b4b4758afce0f888fa8c4488323d46e48b894d" translate="yes" xml:space="preserve">
          <source>The second is the maximum value since the last call to &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">두 번째는 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 대한 마지막 호출 이후 최대 값 입니다.</target>
        </trans-unit>
        <trans-unit id="4cb423e42dd15bcd7222df4611672554d769f082" translate="yes" xml:space="preserve">
          <source>The second level is at the MPD entry / exit point, i.e. immediately after the basic message processing (accept_recv_pdu) / immediately before the basic message processing (accept_send_pdu).</source>
          <target state="translated">두 번째 레벨은 MPD 시작 / 종료 지점에 있습니다. 즉 기본 메시지 처리 직후 (accept_recv_pdu) / 기본 메시지 처리 직전 (accept_send_pdu).</target>
        </trans-unit>
        <trans-unit id="774b9d51f0c992a280af87374e7739fea47b5a73" translate="yes" xml:space="preserve">
          <source>The second line also says that this function can be called from outside the module &lt;code&gt;tut&lt;/code&gt;. More about this later. Again, notice the &quot;.&quot; at the end of the line.</source>
          <target state="translated">두 번째 줄은이 함수가 모듈 &lt;code&gt;tut&lt;/code&gt; 외부에서 호출 될 수 있다고 말합니다 . 나중에 이것에 대해 자세히 알아보십시오. 다시 &quot;.&quot;에 주목하십시오. 줄의 끝에서.</target>
        </trans-unit>
        <trans-unit id="ea3a8607657a10cb904d6d19adb9e7a687aaf47e" translate="yes" xml:space="preserve">
          <source>The second line in the example contains an optional directive to the &lt;code&gt;Emacs&lt;/code&gt; editor, which causes it to enter the major mode for editing Erlang source files. If the directive is present, it must be located on the second line.</source>
          <target state="translated">예제의 두 번째 줄에는 &lt;code&gt;Emacs&lt;/code&gt; 편집기에 대한 선택적 지시문이 포함되어있어 Erlang 소스 파일을 편집하기위한 주 모드로 들어갑니다. 지시문이 있으면 두 번째 행에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e7ea568009a70c36f6990dad1c35ac2c65ca7ebb" translate="yes" xml:space="preserve">
          <source>The second line says that the module &lt;code&gt;tut&lt;/code&gt; contains a function called &lt;code&gt;double&lt;/code&gt;, which takes one argument (&lt;code&gt;X&lt;/code&gt; in our example):</source>
          <target state="translated">두 번째 줄은 모듈 &lt;code&gt;tut&lt;/code&gt; 에 &lt;code&gt;double&lt;/code&gt; 이라는 함수가 포함되어 있으며 하나의 인수 (이 예에서는 &lt;code&gt;X&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1dd56257c238ab45a9b4f237dd6d44c5ddae2994" translate="yes" xml:space="preserve">
          <source>The second occurrence of &lt;code&gt;Age&lt;/code&gt; causes a test for equality between the terms, as &lt;code&gt;Age&lt;/code&gt; is already bound to &lt;code&gt;21&lt;/code&gt;. As &lt;code&gt;Age&lt;/code&gt; is bound to &lt;code&gt;21&lt;/code&gt;, the equality test succeeds and the match continues until the end of the pattern.</source>
          <target state="translated">두번째 발생 &lt;code&gt;Age&lt;/code&gt; 된 용어 등가 테스트 발생 &lt;code&gt;Age&lt;/code&gt; 이미 결합된다 &lt;code&gt;21&lt;/code&gt; . 으로 &lt;code&gt;Age&lt;/code&gt; 결합되어 &lt;code&gt;21&lt;/code&gt; , 평등 테스트는 성공하고 경기는 패턴이 끝날 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="382e51e975a6ee94aa9da00eaf8c1fd3b5f3d623" translate="yes" xml:space="preserve">
          <source>The second part says that the factorial of N is N multiplied by the factorial of N - 1:</source>
          <target state="translated">두 번째 부분은 N의 계승에 N에 N-1의 계승을 곱한 값입니다.</target>
        </trans-unit>
        <trans-unit id="30c810f9bece7434133db436ed3f6c1cf5d3af46" translate="yes" xml:space="preserve">
          <source>The second sublist contains all elements that are greater than, or equal to, the first element in the list.</source>
          <target state="translated">두 번째 하위 목록에는 목록의 첫 번째 요소보다 크거나 같은 모든 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="627c2faa2a7cc1454aac523f61132caf4581e1f2" translate="yes" xml:space="preserve">
          <source>The second test to run is for system &lt;code&gt;t2&lt;/code&gt;. The included suites are &lt;code&gt;t2B&lt;/code&gt; and &lt;code&gt;t2C&lt;/code&gt;. Test cases &lt;code&gt;test4&lt;/code&gt;, &lt;code&gt;test1&lt;/code&gt;, and &lt;code&gt;test7&lt;/code&gt; in suite &lt;code&gt;t2A&lt;/code&gt; are also included. The test cases are executed in the specified order.</source>
          <target state="translated">실행할 두 번째 테스트는 시스템 &lt;code&gt;t2&lt;/code&gt; 에 대한 것 입니다. 포함 된 스위트는 &lt;code&gt;t2B&lt;/code&gt; 및 &lt;code&gt;t2C&lt;/code&gt; 입니다. 스위트 &lt;code&gt;t2A&lt;/code&gt; 의 테스트 케이스 &lt;code&gt;test4&lt;/code&gt; , &lt;code&gt;test1&lt;/code&gt; 및 &lt;code&gt;test7&lt;/code&gt; 도 포함됩니다. 테스트 케이스는 지정된 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="55d61df65623e70a8f8d590c69696f032eeda08b" translate="yes" xml:space="preserve">
          <source>The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern:</source>
          <target state="translated">PCRE와 Perl의 재귀 처리가 다른 두 번째 방법은 캡처 된 값을 처리하는 것입니다. Perl에서 하위 패턴이 재귀 적으로 또는 하위 패턴으로 호출되면 (다음 섹션 참조) 재귀 외부에서 캡처 된 값에 액세스 할 수 없습니다. PCRE에서이 값을 참조 할 수 있습니다. 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="80e6aee2483553449b41d11b56e552008e4da471" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Definition of Instrumentation Functions&lt;/strong&gt; describes the user defined functions, which the agent calls at different times.</source>
          <target state="translated">&lt;strong&gt;계측 기능 정의&lt;/strong&gt; 섹션에서는 상담원이 다른 시간에 호출하는 사용자 정의 &lt;strong&gt;기능에&lt;/strong&gt; 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8504a92d5b318cac713f3b2e89234cb14dbccfe1" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send and be able to receive.</source>
          <target state="translated">&lt;strong&gt;메시지&lt;/strong&gt; 섹션 은 필수 &lt;strong&gt;메시지를&lt;/strong&gt; 설명합니다. Net에서 보내야하고 수신 할 수 있어야하는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="a2e0f488aa581aec3c47fd790570dbca655fc2d9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send to the manager server process.</source>
          <target state="translated">&lt;strong&gt;메시지&lt;/strong&gt; 섹션에서는 필수 &lt;strong&gt;메시지에&lt;/strong&gt; 대해 설명합니다. Net은 관리자 서버 프로세스로 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5bc25d5302176ca65d13f47ab8764077fb82e9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;When to use a Sub-agent&lt;/strong&gt; describes situations where the mechanism of loading and unloading MIBs is insufficient. In these cases a sub-agent is needed.</source>
          <target state="translated">&lt;strong&gt;하위 에이전트 사용시기&lt;/strong&gt; 섹션에서는 MIB로드 및 언로드 메커니즘이 충분하지 않은 상황에 대해 설명합니다. 이 경우 하위 에이전트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e27ee525c2d7a1c95013bf055cd814b7495974ff" translate="yes" xml:space="preserve">
          <source>The section is a step-by-step explanation of the &lt;code&gt;uds_dist&lt;/code&gt; example application (in the Kernel application &lt;code&gt;examples&lt;/code&gt; directory). The &lt;code&gt;uds_dist&lt;/code&gt; application implements distribution over Unix domain sockets and is written for the Sun Solaris 2 operating environment. The mechanisms are however general and apply to any operating system Erlang runs on. The reason the C code is not made portable, is simply readability.</source>
          <target state="translated">이 섹션은 &lt;code&gt;uds_dist&lt;/code&gt; 예제 애플리케이션 (커널 애플리케이션 &lt;code&gt;examples&lt;/code&gt; 디렉토리에 있음)에 대한 단계별 설명입니다 . &lt;code&gt;uds_dist&lt;/code&gt; 응용 프로그램 구현의 유닉스 도메인 소켓을 통해 분포와는 썬 솔라리스이 운영 환경에 기록됩니다. 그러나 메커니즘은 일반적이며 Erlang이 실행되는 모든 운영 체제에 적용됩니다. C 코드가 이식 가능하지 않은 이유는 단순히 가독성입니다.</target>
        </trans-unit>
        <trans-unit id="10205e6d7e5decf9f073a8f33e8e352f8ecad2b8" translate="yes" xml:space="preserve">
          <source>The sections about release structure and release handling have been moved to section &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">릴리스 구조 및 릴리스 처리에 대한 섹션 이 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;OTP Design Principles&lt;/code&gt; 섹션으로 이동되었습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2ce648e32ac1ae793549c46cd55a4f21a2abef" translate="yes" xml:space="preserve">
          <source>The security level depends on the parameters provided to the TLS connection setup. Erlang node cookies are however always used, as they can be used to differentiate between two different Erlang networks.</source>
          <target state="translated">보안 수준은 TLS 연결 설정에 제공된 매개 변수에 따라 다릅니다. 그러나 Erlang 노드 쿠키는 두 개의 다른 Erlang 네트워크를 구별하는 데 사용될 수 있으므로 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d926590307164245688269e8d14c40ab7bc091d" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes implicitly &lt;code&gt;open&lt;/code&gt; to postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="translated">이 경우 선택적 수신은 모든 이벤트를 &lt;code&gt;locked&lt;/code&gt; 상태 로 연기하기 위해 암시 적으로 &lt;code&gt;open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd2a7b375c615e788c6695ee553f4da41abbaa4" translate="yes" xml:space="preserve">
          <source>The semantics is that a trace message is sent when a call traced function returns, that is, when a chain of tail recursive calls ends. Only one trace message is sent per chain of tail recursive calls, so the properties of tail recursiveness for function calls are kept while tracing with this flag. Using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; trace together makes it possible to know exactly in which function a process executes at any time.</source>
          <target state="translated">의미는 호출 추적 함수가 리턴 될 때, 즉 꼬리 재귀 호출 체인이 종료 될 때 추적 메시지가 전송된다는 것입니다. 꼬리 재귀 호출 체인마다 하나의 추적 메시지 만 전송되므로이 플래그로 추적하는 동안 함수 호출에 대한 꼬리 재귀 속성이 유지됩니다. 사용하여 &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;return_to&lt;/code&gt; 의 추적은 함께 가능한 정확히 알고있는 언제든지 프로세스가 실행을 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4de46ccd64eaf7c6a99ec541d1cbcc55c06b408c" translate="yes" xml:space="preserve">
          <source>The semantics of the protocol has jointly been defined by two standardization bodies:</source>
          <target state="translated">프로토콜의 의미는 두 개의 표준화 기관에 의해 공동으로 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ff24da2ee4416d81d99c41d0ad247bd1489bb83" translate="yes" xml:space="preserve">
          <source>The semantics of them and their exact signatures are explained below.</source>
          <target state="translated">이들의 의미와 정확한 서명이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1fa04e102f76c0ed958b51776ec1323ba2b420c" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; in the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트에서는 레코드에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 현재 잠금 유형 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;sticky_write&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4dec37a1381140705a37e8b22974825983130016" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트 에서 전체 테이블 또는 단일 레코드에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 현재 잠금 유형 &lt;code&gt;read&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="544565c18f11c3bd2d1b3b57f9c37bb23e28513e" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or on a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트 에서 전체 테이블 또는 단일 레코드에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 현재 잠금 유형 &lt;code&gt;read&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac9b81a840d90d3353dd0dc88e91326c5df9221" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트 에서 레코드에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 현재 잠금 유형 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;sticky_write&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="398f5d70441c50ce9d5e9fd6b232c3ecc7fd8dc0" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. Currently, the lock types &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 현재 잠금 유형 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;sticky_write&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cb63a329083b4ebe624da3e57823d281920ca895" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. The lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 잠금 유형 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;sticky_write&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="03d20c7795cec81709642f2df218bc112e235d99" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a read lock on the entire table.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트에서 전체 테이블에 대한 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="06b7f2394cceb9a5d1549e5bd69d686fb86fba7d" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires locks, otherwise it ignores the request.</source>
          <target state="translated">이 함수의 의미는 상황에 따라 다릅니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 를 참조하십시오 . 트랜잭션 컨텍스트에서 잠금을 획득하고 그렇지 않으면 요청을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c555e927f36b7c980e9c0d2dd029f5af17719b16" translate="yes" xml:space="preserve">
          <source>The send handle is provided by the preferred transport module, e.g. megaco_tcp, megaco_udp. Read the documentation about each transport module about the details.</source>
          <target state="translated">전송 핸들은 선호 전송 모듈 (예 : megaco_tcp, megaco_udp)에 의해 제공됩니다. 자세한 내용은 각 전송 모듈에 대한 설명서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="8783fac7786ee217686c1dc22e76c11e2bd7dd7d" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes no use of this info, so the only use for it in such a configuration (when using the built in net-if) would be tracing.</source>
          <target state="translated">send 옵션 &lt;code&gt;extra&lt;/code&gt; 는 net-if 프로세스로 전달되는 불투명 한 데이터 구조를 지정합니다. 이 응용 프로그램에 포함 된 net-if 프로세스는이 정보를 사용하지 않으므로 이러한 구성 (내장 net-if를 사용하는 경우)에서만 정보를 사용하면 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="461af368454e12216cec44ca03086a38551ee6d2" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes, with one exception, no use of this info, so the only use for it in such a option (when using the built in net-if) would be tracing. The one usage exception is: &lt;strong&gt;Any&lt;/strong&gt; tuple with &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; as its first element is reserved for internal use.</source>
          <target state="translated">send 옵션 &lt;code&gt;extra&lt;/code&gt; 는 net-if 프로세스로 전달되는 불투명 한 데이터 구조를 지정합니다. 이 응용 프로그램에 포함 된 net-if 프로세스는 한 가지 예외를 제외하고이 정보를 사용하지 않으므로 이러한 옵션 (내장 net-if를 사용하는 경우)에서만 정보를 사용하는 것이 추적입니다. 한 사용 예외입니다 : &lt;strong&gt;모든&lt;/strong&gt; 튜플에 &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; 로서의 첫 번째 요소는 내부에서 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f927792dbf5cf189b45274ee4c9fa05e9b3d6c92" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the management targets. The &lt;code&gt;receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">송신 옵션 &lt;code&gt;receiver&lt;/code&gt; 는 Inform-Requests 전달에 대한 정보를 보낼 위치를 지정합니다. 에이전트는 Inform-Requests를 전송하고 관리 대상의 승인을 기다립니다. &lt;code&gt;receiver&lt;/code&gt; 세 가지 값을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b674ec7cb2a069afaa45f294232597630bb8d191" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;timeout&lt;/code&gt; specifies for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">보내기 옵션 &lt;code&gt;timeout&lt;/code&gt; 은 요청이 유효한 기간을 지정합니다 (이후 관리자가 자유롭게 삭제할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a653cc1f1926ea809d716348869498af401847a8" translate="yes" xml:space="preserve">
          <source>The sender can receive this event if a send operation fails.</source>
          <target state="translated">송신 조작이 실패하면 송신자가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab6737312426170b7d594e871570564adefdefd" translate="yes" xml:space="preserve">
          <source>The sender of a transaction request has the option of deciding, whether the originating Erlang process should synchronously wait (&lt;code&gt;megaco:call/3&lt;/code&gt;) for a reply or if the message should be sent asynchronously (&lt;code&gt;megaco:cast/3&lt;/code&gt;) and the processing of the reply should be delegated this callback function.</source>
          <target state="translated">트랜잭션 요청의 발신자는 발신 Erlang 프로세스가 응답을 동 기적으로 대기 &lt;code&gt;megaco:call/3&lt;/code&gt; ( megaco : call / 3 ) 또는 메시지를 비동기 적으로 전송 &lt;code&gt;megaco:cast/3&lt;/code&gt; ( megaco : cast / 3 ) 여부와 처리를 결정할 수 있습니다. 회신은이 콜백 함수에 위임되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4cb9ec2065f8938c37ab4fe9dffa3ac54b3a9dd" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file &quot;as is&quot; without any formatting. A link to the file is added to the test case HTML log.</source>
          <target state="translated">송수신 된 NETCONF 데이터는 형식없이 &quot;있는 그대로&quot;별도의 텍스트 파일에 기록됩니다. 파일에 대한 링크가 테스트 케이스 HTML 로그에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9c5717f02ffea08eb9b9a69a645cb0063d78fe" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log.</source>
          <target state="translated">보내고받은 NETCONF 데이터는 XML 데이터가 잘 들여 쓰기 된 별도의 텍스트 파일에 기록됩니다. 파일에 대한 링크가 테스트 케이스 HTML 로그에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="97f2e4431b5646badaae5263442c80d42e8a09b1" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF traffic is pretty printed directly in the test case HTML log.</source>
          <target state="translated">전송 및 수신 된 NETCONF 트래픽은 테스트 사례 HTML 로그에 직접 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="526a6b0c86f2a163790ccae9cdeca981359b2f9f" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">순서 (? #는 다음 닫는 괄호까지 계속되는 주석의 시작을 나타냅니다. 중첩 된 괄호는 허용되지 않습니다. PCRE_EXTENDED 옵션이 설정되어 있으면 이스케이프되지 않은 # 문자도 주석을 표시합니다. 다음 줄 바꿈 문자 또는 문자 시퀀스 패턴에서 줄 바꿈 문자로 해석되는 문자는 이전 &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 컴파일 기능에 전달 된 옵션 또는 패턴 시작시 특수 순서에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="17d5ba7a2bea4311848902de65874e5e13256c29" translate="yes" xml:space="preserve">
          <source>The sequence \g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">선택적으로 중괄호로 묶인 부호없는 또는 음수 뒤에 오는 시퀀스 \ g는 절대 또는 상대적인 역 참조입니다. 명명 된 역 참조는 \ g {name}으로 코딩 할 수 있습니다. 역 참조는 괄호로 묶인 하위 패턴에 대한 논의에 따라 나중에 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="cf397042cff1c5cb3ebfe293ff40d06f71fdc8c2" translate="yes" xml:space="preserve">
          <source>The sequence \g{-1} is a reference to the most recently started capturing subpattern before \g, that is, it is equivalent to \2 in this example. Similarly, \g{-2} would be equivalent to \1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves.</source>
          <target state="translated">\ g {-1} 시퀀스는 \ g 이전에 가장 최근에 시작된 하위 패턴 캡처에 대한 참조입니다. 즉,이 예에서는 \ 2와 같습니다. 마찬가지로 \ g {-2}는 \ 1과 같습니다. 상대 참조를 사용하면 긴 패턴과 참조가 포함 된 조각을 조인하여 만든 패턴에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78acc7e07953d38a1ab22f1d92af436b05725d02" translate="yes" xml:space="preserve">
          <source>The sequence number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 의 시퀀스 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="a730581ed9394e9f512b17bf00122fa40d5d6a8c" translate="yes" xml:space="preserve">
          <source>The sequence number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">포트의 시퀀스 번호 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9835c9de2ba951e30c90819750512630463b537" translate="yes" xml:space="preserve">
          <source>The sequence of steps shown is probably more complex than normal, but it illustrates the amount of functionality which is available. The following points should be noted:</source>
          <target state="translated">표시된 단계 순서는 보통보다 더 복잡하지만 사용 가능한 기능의 양을 보여줍니다. 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="8ad58d75452c7e291a38fc9baa9ff4ed0360940a" translate="yes" xml:space="preserve">
          <source>The sequences \h, \H, \v, and \V are features that were added to Perl in release 5.10. In contrast to the other sequences, which match only ASCII characters by default, these always match certain high-valued code points, regardless if &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">시퀀스 \ h, \ H, \ v 및 \ V는 릴리스 5.10에서 Perl에 추가 된 기능입니다. 기본적으로 ASCII 문자 만 일치하는 다른 시퀀스와 달리, &lt;code&gt;ucp&lt;/code&gt; 가 설정되어 있는지 여부에 관계없이 항상 높은 값의 특정 코드 포인트와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="7cc5373a2646de360aa46ef11847fc92698bb563" translate="yes" xml:space="preserve">
          <source>The serial number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 의 일련 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="8111e7055dd7801086cd5e9dd759c58638f73514" translate="yes" xml:space="preserve">
          <source>The server always sends a certificate chain as part of the TLS handshake, but the client only sends one if requested by the server. If the client does not have an appropriate certificate, it can send an &quot;empty&quot; certificate to the server.</source>
          <target state="translated">서버는 항상 TLS 핸드 셰이크의 일부로 인증서 체인을 보내지 만 클라이언트는 서버에서 요청한 경우에만 인증서 체인을 보냅니다. 클라이언트에 적절한 인증서가 없으면 &quot;빈&quot;인증서를 서버로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229d25bbfa88632fdde58ad8585ae739c0a0640c" translate="yes" xml:space="preserve">
          <source>The server can also take the options &lt;code&gt;dhfile&lt;/code&gt; and &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (also prefixed).</source>
          <target state="translated">서버는 옵션 &lt;code&gt;dhfile&lt;/code&gt; 및 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (접두사)도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1700b3d48eb2b123d28d0da14b6deae45c75c3b4" translate="yes" xml:space="preserve">
          <source>The server implements numerous features, such as:</source>
          <target state="translated">서버는 다음과 같은 다양한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a419e1724123900e8550b29498eed9bbee902340" translate="yes" xml:space="preserve">
          <source>The server interprets the message headers and most of them are transformed into HTTP headers and sent back to the client together with the message-body.</source>
          <target state="translated">서버는 메시지 헤더를 해석하고 대부분 헤더를 HTTP 헤더로 변환하여 메시지 본문과 함께 클라이언트로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="35e7a7b10ff76bf44d32ec3e60b336ed7bd9d091" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;. For backwards compatibility, apache-like configuration files are also supported.</source>
          <target state="translated">서버는 Erlang 등록 정보 목록을 사용하여 구성됩니다. 사용 가능한 속성은 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 이전 버전과의 호환성을 위해 아파치와 같은 구성 파일도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5e64a9d0d0fd7079393371b1454efd0dd5fbdc81" translate="yes" xml:space="preserve">
          <source>The server name, in this example the atom &lt;code&gt;ch2&lt;/code&gt;, is hidden from the users of the client functions. This means that the name can be changed without affecting them.</source>
          <target state="translated">서버 이름 (이 예제에서 atom &lt;code&gt;ch2&lt;/code&gt; )은 클라이언트 함수 사용자에게 숨겨져 있습니다. 이는 이름이 영향을받지 않고 변경 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="281168d64e74220aa9892e9cc7f847641edee61a" translate="yes" xml:space="preserve">
          <source>The server receives this message and calls:</source>
          <target state="translated">서버는이 메시지를 수신하고 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e465284becdbbb53a7c1b2b2feedaf65818bc0a6" translate="yes" xml:space="preserve">
          <source>The server side must abort any ongoing operations, release any locks and resources associated with the session, and close any associated connections.</source>
          <target state="translated">서버 측은 진행중인 작업을 중단하고 세션과 관련된 잠금 및 리소스를 해제하고 관련 연결을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="eada9e87d673d14717c1c6d8d19ed52103f05b62" translate="yes" xml:space="preserve">
          <source>The service is being started or stopped. No event precedes a &lt;code&gt;start&lt;/code&gt; event. No event follows a &lt;code&gt;stop&lt;/code&gt; event, and this event implies the termination of all transport processes.</source>
          <target state="translated">서비스가 시작 또는 중지되고 있습니다. &lt;code&gt;start&lt;/code&gt; 이벤트 앞에 이벤트가 없습니다 . &lt;code&gt;stop&lt;/code&gt; 이벤트 다음에 이벤트가 없으며이 이벤트는 모든 전송 프로세스가 종료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0bb9705bf71fb4b8fce2bf74aeec82fd5334268d" translate="yes" xml:space="preserve">
          <source>The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer (&lt;code&gt;connect&lt;/code&gt;) or by accepting incoming connection requests (&lt;code&gt;listen&lt;/code&gt;). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many.</source>
          <target state="translated">서비스는 피어에 연결 ( &lt;code&gt;connect&lt;/code&gt; )하거나 수신 연결 요청을 수신 ( &lt;code&gt;listen&lt;/code&gt; ) 하여 피어와 연결을 설정하는 데 필요한 전송 프로세스를 시작합니다 . 연결 전송은 최대 하나의 피어와 전송 연결을 설정하며, 잠재적으로 많은 사람들이 수신하는 전송입니다.</target>
        </trans-unit>
        <trans-unit id="d2cadccf6e95d9c9b64838c77b38958e4188f878" translate="yes" xml:space="preserve">
          <source>The session is closed.</source>
          <target state="translated">세션이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7cd1dac17852f58fd5b35cb68eccba90aabb1d2d" translate="yes" xml:space="preserve">
          <source>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP, and generic &lt;code&gt;inet&lt;/code&gt; options. Only options listed here are allowed for SCTP sockets. Options can be set on the socket using &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, retrieved using &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt;. Options can be changed when calling &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">허용 가능한 SCTP 소켓 옵션 세트는 TCP, UDP 및 일반 &lt;code&gt;inet&lt;/code&gt; 옵션 세트와 직교합니다 . 여기에 나열된 옵션 만 SCTP 소켓에 허용됩니다. &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 소켓에서 옵션을 설정하고 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 검색 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 옵션을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab0f75a569127c073d8755a64ed39c5868d2acc4" translate="yes" xml:space="preserve">
          <source>The set of algorithms that the SSH app uses by default depends on the algoritms supported by the:</source>
          <target state="translated">SSH 앱이 기본적으로 사용하는 알고리즘 세트는 다음에서 지원하는 알고리즘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="735c513e608e0b547b56dcea8d9766ffad148df8" translate="yes" xml:space="preserve">
          <source>The set of integers returned by &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; using different sets of &lt;code&gt;Modifier&lt;/code&gt;s &lt;strong&gt;will overlap&lt;/strong&gt;. For example, by calling &lt;code&gt;unique_integer([monotonic])&lt;/code&gt;, and &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; repeatedly, you will eventually see some integers that are returned by both calls.</source>
          <target state="translated">리턴하여 정수의 집합 &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; 의 상이한 세트하여 &lt;code&gt;Modifier&lt;/code&gt; 의 &lt;strong&gt;의지 오버랩&lt;/strong&gt; . 예를 들어 &lt;code&gt;unique_integer([monotonic])&lt;/code&gt; 및 &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; 반복해서 호출하면 두 호출에서 모두 반환되는 정수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="192a51abc57907a3173222d0f7d8aab02a2d5adc" translate="yes" xml:space="preserve">
          <source>The set of nodes that makes up a Mnesia system is kept in a schema. Mnesia nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function &lt;code&gt;mnesia:create_schema/1&lt;/code&gt;. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the startup procedure, Mnesia exchanges schema information between the nodes to verify that the table definitions are compatible.</source>
          <target state="translated">Mnesia 시스템을 구성하는 노드 세트는 스키마에 보관됩니다. Mnesia 노드는 스키마에 추가하거나 스키마에서 제거 할 수 있습니다. 초기 스키마는 일반적으로 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 함수를 사용하여 디스크에 작성됩니다 . 디스크가없는 노드에서는 Mnesia가 시작될 때마다 작은 기본 스키마가 생성됩니다. 시작 절차 중에 Mnesia는 노드간에 스키마 정보를 교환하여 테이블 정의가 호환되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e6b6ca74b9f0531554c93c10cb1c7070b93217b8" translate="yes" xml:space="preserve">
          <source>The set of predefined types and the syntax for types follows:</source>
          <target state="translated">사전 정의 된 유형 세트 및 유형의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d57bb3e21d7efc4c4d6d866577c535b86827e6e3" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; (sometimes called guard tests) is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="translated">유효한 &lt;strong&gt;가드 표현식&lt;/strong&gt; 세트 (가드 테스트라고도 함)는 유효한 Erlang 표현식 세트의 서브 세트입니다. 유효한 표현식 세트를 제한하는 이유는 가드 표현식의 평가에 부작용이 없어야하기 때문입니다. 유효한 보호 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b4e6c237902f03c9d37f0c7a6d60075f64b2cbe" translate="yes" xml:space="preserve">
          <source>The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that:</source>
          <target state="translated">이 모듈이 인식하는 세트는 관계 세트의 요소로 표시되며, 다음과 같이 가장 작은 세트로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd8e823885a626feb78a98cd7d6126c5141df4e" translate="yes" xml:space="preserve">
          <source>The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms:</source>
          <target state="translated">Sets로 표시되는 집합은 Set에서 Erlang 용어 및 Erlang 용어 집합의 기능 범위 요소입니다.</target>
        </trans-unit>
        <trans-unit id="1e6bfb67315ff8c660eaf25c1733e37c10bf2a84" translate="yes" xml:space="preserve">
          <source>The setting has no effect on a halt log.</source>
          <target state="translated">설정은 정지 로그에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="708e1c55726f99e92712010fcf842caa93f6beee" translate="yes" xml:space="preserve">
          <source>The settings of the Perl-compatible options &lt;code&gt;caseless&lt;/code&gt;, &lt;code&gt;multiline&lt;/code&gt;, &lt;code&gt;dotall&lt;/code&gt;, and &lt;code&gt;extended&lt;/code&gt; can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows:</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; , &lt;code&gt;multiline&lt;/code&gt; , &lt;code&gt;dotall&lt;/code&gt; 및 &lt;code&gt;extended&lt;/code&gt; Perl 호환 옵션의 설정은 &quot;(?&quot;와 &quot;)&quot;사이에있는 일련의 Perl 옵션 문자에 의해 패턴 내에서 변경 될 수 있습니다. 옵션 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20fbd9576783a14ac9df5dccf183005898be344d" translate="yes" xml:space="preserve">
          <source>The severity level for the message to be logged.</source>
          <target state="translated">메시지가 기록 될 심각도 수준입니다.</target>
        </trans-unit>
        <trans-unit id="906ae5d296f5eecb26331f0380669f16fbcadddb" translate="yes" xml:space="preserve">
          <source>The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.</source>
          <target state="translated">쉘은 또한 사용자가 여러 개의 동시 작업을 시작할 수 있도록합니다. 작업은 쉘과 통신 할 수있는 일련의 프로세스로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5f2ea6c7e1929748b9a3f26e85b7652daf0ffd" translate="yes" xml:space="preserve">
          <source>The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag &lt;code&gt;+Bi&lt;/code&gt;).</source>
          <target state="translated">쉘은 제한 모드에서 시작할 수 있습니다. 이 모드에서 쉘은 허용 된 경우에만 함수 호출을 평가합니다. 예를 들어이 기능을 사용하면 실행중인 시스템을 손상시킬 수있는 프롬프트에서 사용자가 실수로 함수를 호출하지 못하게 할 수 있습니다 (시스템 플래그 &lt;code&gt;+Bi&lt;/code&gt; 와 함께 사용하면 유용함 ).</target>
        </trans-unit>
        <trans-unit id="6b1db3783eaf47b941529ec43e9feba2a87d50ce" translate="yes" xml:space="preserve">
          <source>The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules &lt;code&gt;shell_default&lt;/code&gt; and &lt;code&gt;user_default&lt;/code&gt; (if loaded) are read each time a new job is started. For example, adding the following line to &lt;code&gt;user_default&lt;/code&gt; makes the definition of &lt;code&gt;file_info&lt;/code&gt; readily available in the shell:</source>
          <target state="translated">레코드 읽기, 정의, 잊기, 나열 및 인쇄를위한 쉘 명령이 아래에 설명되어 있습니다. 각 작업에는 고유 한 레코드 정의 세트가 있습니다. 문제를 용이하게하기 위해 새 작업이 시작될 때마다 &lt;code&gt;shell_default&lt;/code&gt; 및 &lt;code&gt;user_default&lt;/code&gt; (로드 된 경우) 모듈의 레코드 정의를 읽습니다. 예를 들어, &lt;code&gt;user_default&lt;/code&gt; 에 다음 행을 추가 하면 쉘에서 &lt;code&gt;file_info&lt;/code&gt; 의 정의를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dffc89af87f5c93512d139994f93842341103ef" translate="yes" xml:space="preserve">
          <source>The shell escape key &lt;code&gt;^G&lt;/code&gt; (Control G) detaches the current job and activates &lt;code&gt;JCL&lt;/code&gt; mode. The &lt;code&gt;JCL&lt;/code&gt; mode prompt is &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt;. If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is entered at the prompt, the following help message is displayed:</source>
          <target state="translated">쉘 이스케이프 키 &lt;code&gt;^G&lt;/code&gt; (Control G)는 현재 작업을 분리하고 &lt;code&gt;JCL&lt;/code&gt; 모드를 활성화 합니다. &lt;code&gt;JCL&lt;/code&gt; 의 모드 프롬프트는 &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; . 만약 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 프롬프트에를 입력하면 다음 도움말 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f22132507cc2cbecae41be645fa330c7e74cc00c" translate="yes" xml:space="preserve">
          <source>The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt;, or by setting the application configuration parameters &lt;code&gt;shell_history_length&lt;/code&gt; and &lt;code&gt;shell_saved_results&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">쉘은 표현식 순서를 입력하기위한 사용자 인터페이스 프로그램입니다. 식이 평가되고 값이 반환됩니다. 히스토리 메커니즘은 이전 명령과 해당 값을 저장 한 후 나중에 명령에 통합 할 수 있습니다. 저장하는 명령 및 결과 수는 대화식으로 &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 STDLIB 애플리케이션에 대한 애플리케이션 구성 매개 변수 &lt;code&gt;shell_history_length&lt;/code&gt; 및 &lt;code&gt;shell_saved_results&lt;/code&gt; 를 설정하여 사용자가 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b3c2d38847db4b9d384443450a1704fbe5a9310" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt;os:find_executable/1&lt;/code&gt;.</source>
          <target state="translated">쉘은 일반적으로 프로그램을 시작하기 위해 호출되지 않으며 직접 실행됩니다. &lt;code&gt;PATH&lt;/code&gt; (또는 동등한 항목)는 검색되지 않습니다. &lt;code&gt;PATH&lt;/code&gt; 에서 실행할 프로그램을 찾으려면 &lt;code&gt;os:find_executable/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ba8c777e2892e18ef92162fb3ae948b677e7e96" translate="yes" xml:space="preserve">
          <source>The shell mode is useful, for example, for debugging test suites, analyzing and debugging the SUT during &quot;simulated&quot; test case execution, and trying out various operations during test suite development.</source>
          <target state="translated">쉘 모드는 예를 들어 테스트 스위트 디버깅, &quot;시뮬레이션 된&quot;테스트 케이스 실행 중 SUT 분석 및 디버깅, 테스트 스위트 개발 중 다양한 조작 시도에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dccc3d081d31c25afe702e15e4a49fe7f5d58e4e" translate="yes" xml:space="preserve">
          <source>The shell runs in two modes:</source>
          <target state="translated">쉘은 두 가지 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="547a340a87f4e04c610a24150bcba68bc72ae2d3" translate="yes" xml:space="preserve">
          <source>The shell script &lt;code&gt;start&lt;/code&gt;, which is generated from erts-5.10.4/bin/start.src during installation, is only an example. Edit it to suite your needs. Typically it is executed when the UNIX system boots.</source>
          <target state="translated">설치하는 동안 erts-5.10.4 / bin / start.src에서 생성되는 쉘 스크립트 &lt;code&gt;start&lt;/code&gt; 는 예제 일뿐입니다. 필요에 맞게 편집하십시오. 일반적으로 UNIX 시스템이 부팅 될 때 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49dd983c72c713d084adde4deb3fce82550d00d2" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="translated">쉘은 히스토리 메커니즘을 예외로부터 보호하기 위해 명령을 평가하기 위해 헬퍼 프로세스를 사용합니다. 예외가 발생하면 기본적으로 평가 기 프로세스가 종료되지만 &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 STDLIB 애플리케이션에 대한 애플리케이션 구성 매개 변수 &lt;code&gt;shell_catch_exception&lt;/code&gt; 을 설정 하여이 동작을 변경할 수 있습니다. 아래 예제도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa42edd7ea14c7efba24c3aff26f9dcace9d4328" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one event handler function per state; please read on...</source>
          <target state="translated">짧은 버전 : choose &lt;code&gt;state_functions&lt;/code&gt; - &lt;code&gt;gen_fsm&lt;/code&gt; 과 가장 유사한 것 입니다. 그러나 상태가 원자 여야한다는 제한을 원하지 않거나 상태 당 하나의 이벤트 핸들러 함수를 작성하지 않으려는 경우; 읽어주세요 ...</target>
        </trans-unit>
        <trans-unit id="8fc2135229ea382a9e721c2e40582626084b92c6" translate="yes" xml:space="preserve">
          <source>The shortcuts are as follows:</source>
          <target state="translated">바로 가기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecbf2eb1175e2e5b06e38c7c0a22fd7f8f8611cd" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished repeatedly and reliably when reading time values. Precision is limited by the &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt;, but resolution and precision can differ significantly.</source>
          <target state="translated">시간 값을 읽을 때 반복적이고 안정적으로 구별 할 수있는 가장 짧은 시간 간격. 정밀도는 &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 의해 제한 되지만 해상도와 정밀도는 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f84d7886a0f9257a8fa3cb849cd4e77cfe8aa126" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished when reading time values.</source>
          <target state="translated">시간 값을 읽을 때 구별 할 수있는 가장 짧은 시간 간격.</target>
        </trans-unit>
        <trans-unit id="d2bb1e51130dab7f5283d9470e62aab2d5f6ca06" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저의 하위 스펙에 정의 된 종료 전략은 &lt;code&gt;brutal_kill&lt;/code&gt; 이 아닌 정수 시간 종료 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c80708d1012fab3c8f472912a306a1e18b063172" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저의 자식 사양에 정의 된 종료 전략은 &lt;code&gt;brutal_kill&lt;/code&gt; 이 아닌 정수 시간 초과 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c9028aec69bf73d6c7de5318e8338d0a2f1c2357" translate="yes" xml:space="preserve">
          <source>The signal &lt;code&gt;SIGUSR2&lt;/code&gt; is reserved for internal usage. No other signals are handled.</source>
          <target state="translated">&lt;code&gt;SIGUSR2&lt;/code&gt; 신호 는 내부 용으로 예약되어 있습니다. 다른 신호는 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d074b9e825fff0fd1ebfc3258cb4dafc95050e70" translate="yes" xml:space="preserve">
          <source>The signal carries information about the pid it was sent from and the exit reason.</source>
          <target state="translated">신호는 전송 된 pid 및 종료 이유에 대한 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="186b6e9957386fe2a5f08032e0ba5ef2925f605f" translate="yes" xml:space="preserve">
          <source>The signedness specification can be either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. Notice that signedness only matters for matching.</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 사양은 서명 되거나 &lt;code&gt;unsigned&lt;/code&gt; 않을 수 있습니다 . 서명은 일치에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0a422acc04b6a76708f58fc88d786a11c4476b80" translate="yes" xml:space="preserve">
          <source>The simple event handler sends all alarms as info reports to the error logger, and saves all in a list. This list can be passed to a user-defined event handler, which can be installed later. The list can grow large if many alarms are generated. This is a good reason to install a better user-defined handler.</source>
          <target state="translated">단순 이벤트 핸들러는 모든 알람을 정보 보고서로 오류 로거에 전송하고 모든 알람을 목록에 저장합니다. 이 목록은 사용자 정의 이벤트 핸들러로 전달되어 나중에 설치할 수 있습니다. 많은 알람이 생성되면 목록이 커질 수 있습니다. 이것이 더 나은 사용자 정의 처리기를 설치하는 좋은 이유입니다.</target>
        </trans-unit>
        <trans-unit id="863023573a43dd8e0ae2605daf1e7cad870d2b5e" translate="yes" xml:space="preserve">
          <source>The simple server from &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;, implemented using &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; so it fits into a supervision tree:</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 및 &lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 구현 된 &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; 의 간단한 서버 는 감독 트리에 맞습니다.</target>
        </trans-unit>
        <trans-unit id="2b9f3602307725a54911301be89734f09963d9b4" translate="yes" xml:space="preserve">
          <source>The simple-form structure is any of &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt;, &lt;code&gt;{Tag, Content}&lt;/code&gt; or &lt;code&gt;Tag&lt;/code&gt; where:</source>
          <target state="translated">단순 양식 구조는 &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt; , &lt;code&gt;{Tag, Content}&lt;/code&gt; 또는 &lt;code&gt;Tag&lt;/code&gt; 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="020fdda90aa20fcb7b4204c69ad0944a63e101ce" translate="yes" xml:space="preserve">
          <source>The simplest SSL/TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="translated">옵션 이름에 접두어 &lt;code&gt;server_&lt;/code&gt; 또는 &lt;code&gt;client_&lt;/code&gt; 를 추가하여 다음 목록에서 가장 간단한 SSL / TLS 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67ab52b7039e217a939df83566a221e65ed54107" translate="yes" xml:space="preserve">
          <source>The simplest applications do not have any processes, but consist of a collection of functional modules. Such an application is called a &lt;strong&gt;library application&lt;/strong&gt;. An example of a library application is STDLIB.</source>
          <target state="translated">가장 간단한 응용 프로그램에는 프로세스가 없지만 기능 모듈 모음으로 구성됩니다. 이러한 응용 프로그램을 &lt;strong&gt;라이브러리 응용 프로그램&lt;/strong&gt; 이라고합니다 . 라이브러리 애플리케이션의 예는 STDLIB입니다.</target>
        </trans-unit>
        <trans-unit id="9d81d04034c8d22db20deb185b1f215da194b3b1" translate="yes" xml:space="preserve">
          <source>The simplest boot script possible includes only the Kernel and STDLIB applications. Such a script is located in the &lt;code&gt;bin&lt;/code&gt; directory of the Erlang distribution. The source for the script is found under the Erlang installation top directory under &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 부팅 스크립트에는 커널 및 STDLIB 응용 프로그램 만 포함됩니다. 이러한 스크립트는 Erlang 배포 의 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 있습니다. 스크립트의 소스는 &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt; 아래의 Erlang 설치 최상위 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6fd995f7841419eb481c6384fc5f636193cf5af" translate="yes" xml:space="preserve">
          <source>The simplest case is to segment the input string into a list of identifiers (atoms) and use those atoms both as categories and values of the tokens. For example, the input string &lt;code&gt;aaa bbb 777, X&lt;/code&gt; may be scanned (tokenized) as:</source>
          <target state="translated">가장 간단한 경우는 입력 문자열을 식별자 (원자) 목록으로 분할하고 해당 원자를 토큰의 범주 및 값으로 사용하는 것입니다. 예를 들어, 입력 문자열 &lt;code&gt;aaa bbb 777, X&lt;/code&gt; 는 다음과 같이 스캔 (토큰 화) 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="010ac940341106a56ccca622ae5fd2705ac4ec5a" translate="yes" xml:space="preserve">
          <source>The simplest form of expression is a term, that is an integer, float, atom, string, list, map, or tuple. The return value is the term itself.</source>
          <target state="translated">가장 간단한 표현 형식은 정수, 부동 소수점, 원자, 문자열, 목록, 맵 또는 튜플이라는 용어입니다. 반환 값은 용어 자체입니다.</target>
        </trans-unit>
        <trans-unit id="da4929ec0fe8e8e239995092f36e1eed41d6db7c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 사용법은 &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cc802fe07c47aed57126bce485b313dc00cf24cf" translate="yes" xml:space="preserve">
          <source>The simplest way of tracing from the Erlang shell is to use &lt;code&gt;dbg:c/3&lt;/code&gt; or &lt;code&gt;dbg:c/4&lt;/code&gt;, e.g. tracing the function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt;:</source>
          <target state="translated">Erlang 쉘에서 추적하는 가장 간단한 방법은 &lt;code&gt;dbg:c/3&lt;/code&gt; 또는 &lt;code&gt;dbg:c/4&lt;/code&gt; 를 사용하는 것입니다 (예 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 함수 추적) .</target>
        </trans-unit>
        <trans-unit id="fd591e91084c3f463556c98ff8fcc73c0b642942" translate="yes" xml:space="preserve">
          <source>The simplest way to send a notification is to call the function &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt;. In this case, the agent performs a get-operation to retrieve the object values that are defined in the notification specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros). The notification is sent to all managers defined in the target and notify tables, either unacknowledged as traps, or acknowledged as inform requests.</source>
          <target state="translated">알림을 보내는 가장 간단한 방법은 &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt; 함수를 호출하는 것 입니다. 이 경우 에이전트는 get-operation을 수행하여 알림 스펙에 정의 된 오브젝트 값 (TRAP-TYPE 또는 NOTIFICATION-TYPE 매크로 사용)을 검색합니다. 알림은 대상 및 알림 테이블에 정의 된 모든 관리자에게 트랩으로 확인되지 않거나 알림 요청으로 확인되어 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="67648b768786640bf14fe9b8b58cbe1c7d6f3c6d" translate="yes" xml:space="preserve">
          <source>The simplest way to use EUnit in an Erlang module is to add the following line at the beginning of the module (after the &lt;code&gt;-module&lt;/code&gt; declaration, but before any function definitions):</source>
          <target state="translated">Erlang 모듈에서 EUnit을 사용하는 가장 간단한 방법은 모듈의 시작 부분 ( &lt;code&gt;-module&lt;/code&gt; 선언 후, 함수 정의 전에)에 다음 행을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="94829f2b959259f751a0e01f1565faf0e83453ae" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="translated">이 설정을 사용하는 가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; 을 호출하는 것입니다. 이 함수는이 함수의 반환 값을 사용하여 목록이 인쇄 가능한 문자열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="410ab688ad74fcb927d318148676d55f9fa41dc2" translate="yes" xml:space="preserve">
          <source>The sixth argument is the instance number.</source>
          <target state="translated">여섯 번째 인수는 인스턴스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="09584020841c67187a5e4c45090a98af5e53582d" translate="yes" xml:space="preserve">
          <source>The size and offset of the specific field</source>
          <target state="translated">특정 필드의 크기와 오프셋</target>
        </trans-unit>
        <trans-unit id="04a41d7d5ebfc159ad47e6d9484bf8d344a4ee18" translate="yes" xml:space="preserve">
          <source>The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later.</source>
          <target state="translated">테이블이 공용이고 덤프 중 테이블에서 레코드가 추가되거나 제거되면 헤더의 크기 필드가 파일의 레코드 수와 일치하지 않을 수 있습니다. 덤프 중에 업데이트되고 읽기시 확인하려는 공용 테이블은 나중에 읽기 확인 프로세스를 신뢰할 수 있도록 하나 이상의 확장 정보 필드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="15a82dee25c7ae3a3f7d6659ea3993b106858ed6" translate="yes" xml:space="preserve">
          <source>The size includes 233 words for the heap area (which includes the stack). The garbage collector increases the heap as needed.</source>
          <target state="translated">크기는 힙 영역 (스택 포함)에 대해 233 워드를 포함합니다. 가비지 수집기는 필요에 따라 힙을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b0f54d25af981835a640f1718c86bf5f2b930bc6" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;Dgram&lt;/code&gt; is less than &lt;code&gt;4*HLen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 의 크기 가 &lt;code&gt;4*HLen&lt;/code&gt; 미만 입니다.</target>
        </trans-unit>
        <trans-unit id="240cf2840ab83e06087b3c823b3105d452ce4e2c" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;struct tcp_info&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;struct tcp_info&lt;/code&gt; 의 크기</target>
        </trans-unit>
        <trans-unit id="1b6bd4cbaa0c4a01c449ef3a984d1775fb023405" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="translated">&quot;이전 힙&quot;의 크기입니다. Erlang 가상 머신은 2 세대의 세대 가비지 콜렉션을 사용합니다. 새로운 데이터 항목에 대한 하나의 힙과 두 개의 가비지 콜렉션에서 살아남은 데이터에 대한 하나의 힙이 있습니다. (거의 항상 올바른) 가정은 두 가비지 수집에서 살아남은 데이터는 오래 살지 않기 때문에 더 적은 수의 가비지 수집으로 &quot;보존&quot;될 수 있다는 것입니다. 이것은 가상 머신에서 일반적인 기술입니다. 힙과 스택의 합은 프로세스의 할당 된 메모리의 대부분을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="8045fd58723fbeefad6762911d1edbd926bdac7b" translate="yes" xml:space="preserve">
          <source>The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is used, where N is public modulus of the RSA key.</source>
          <target state="translated">의 크기 &lt;code&gt;PlainText&lt;/code&gt; 보다 작아야 &lt;code&gt;byte_size(N)-11&lt;/code&gt; 경우 &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; 가 사용되고, &lt;code&gt;byte_size(N)&lt;/code&gt; 경우 &lt;code&gt;rsa_no_padding&lt;/code&gt; 가 N은 RSA 공개 키의 모듈러스이고, 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a866d073ca584886db7c9d897f09b98c62abbf" translate="yes" xml:space="preserve">
          <source>The size of the call counters is the host machine word size. One bit is used when pausing the counter, so the maximum counter value for a 32-bit host is 2147483647.</source>
          <target state="translated">콜 카운터의 크기는 호스트 머신 워드 크기입니다. 카운터를 일시 정지 할 때 1 비트가 사용되므로 32 비트 호스트의 최대 카운터 값은 2147483647입니다.</target>
        </trans-unit>
        <trans-unit id="fb56015c8eab043674edf8d83f2180e86ae9a77a" translate="yes" xml:space="preserve">
          <source>The size of the compressed file (the size of the uncompressed file is found in &lt;code&gt;info&lt;/code&gt;)</source>
          <target state="translated">압축 파일의 크기 (압축되지 않은 파일의 크기는 &lt;code&gt;info&lt;/code&gt; 에 있습니다 )</target>
        </trans-unit>
        <trans-unit id="2f0d2a526b810e744210895a97ddddfb9dfdd679" translate="yes" xml:space="preserve">
          <source>The size of the data that survived the previous garbage collection.</source>
          <target state="translated">이전 가비지 수집에서 살아남은 데이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="e9d65b80debf675400c50641feff8560b459d932" translate="yes" xml:space="preserve">
          <source>The size of the encoded values was 458 bytes for &lt;code&gt;GUI&lt;/code&gt; and 464 bytes for &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt;.</source>
          <target state="translated">인코딩 된 값의 크기는 &lt;code&gt;GUI&lt;/code&gt; 의 경우 458 바이트 이고 &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 의 경우 464 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="6de9b33cf1949c23faaaa88b249a1008b2802a9a" translate="yes" xml:space="preserve">
          <source>The size of the largest contiguous free memory block available to the Erlang emulator.</source>
          <target state="translated">Erlang 에뮬레이터에서 사용할 수있는 가장 큰 연속 여유 메모리 블록의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6d118a2b54a2818588ac5a0110de6ef29741d438" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the heap and the stack.</source>
          <target state="translated">힙 및 스택을 저장하는 데 사용되는 메모리 블록의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="e6c71457bdeadfc9d10261846b10fe6f6d7f7a91" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the old heap.</source>
          <target state="translated">이전 힙을 저장하는 데 사용되는 메모리 블록의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="dc966159ad664aaf70a48fd1f0edce70ddc61365" translate="yes" xml:space="preserve">
          <source>The size of the process in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 호출로 얻은 프로세스 크기 (바이트 ) 입니다.</target>
        </trans-unit>
        <trans-unit id="764453484226497e0bb92b39542a42c4b18f03bf" translate="yes" xml:space="preserve">
          <source>The size of the process, in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 호출로 얻은 프로세스 크기 (바이트 ) 입니다.</target>
        </trans-unit>
        <trans-unit id="191298b20bbe06d47611b490fefa2f8a4b372b8e" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap (they share memory segment).</source>
          <target state="translated">스택 및 힙의 크기 (메모리 세그먼트를 공유)</target>
        </trans-unit>
        <trans-unit id="178ae932ebc1af7c2dda4dfd8f46a38ebd32810a" translate="yes" xml:space="preserve">
          <source>The size of the stack.</source>
          <target state="translated">스택의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8f1488fc1dd7db66c80f3a57b0e5af0af66de229" translate="yes" xml:space="preserve">
          <source>The size of the tail must be evenly divisible by 8.</source>
          <target state="translated">꼬리의 크기는 8로 균등하게 나눌 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0d0d88986d4bbf13803d8e24b41f46f6997c4e2c" translate="yes" xml:space="preserve">
          <source>The size of the used part of the heap.</source>
          <target state="translated">힙에서 사용 된 부분의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="2b09e2b23bece918b025556de700326cad53b8b5" translate="yes" xml:space="preserve">
          <source>The size of the used part of the old heap.</source>
          <target state="translated">이전 힙에서 사용 된 부분의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6b3a8f533f48a479fd53920b8d4e9fa6257ad510" translate="yes" xml:space="preserve">
          <source>The size of the user-level software buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. It is recommended to have &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; to avoid performance issues because of unnecessary copying. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when values &lt;code&gt;sndbuf&lt;/code&gt; or &lt;code&gt;recbuf&lt;/code&gt; are set. However, as the sizes set for &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="translated">드라이버가 사용하는 사용자 레벨 소프트웨어 버퍼의 크기입니다. 커널 소켓 버퍼에 해당하는 &lt;code&gt;sndbuf&lt;/code&gt; 및 &lt;code&gt;recbuf&lt;/code&gt; 옵션 과 혼동하지 마십시오 . 가지고하는 것이 좋습니다 &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; 때문에 불필요한 복사 피하기 성능 문제를. &lt;code&gt;sndbuf&lt;/code&gt; 또는 &lt;code&gt;recbuf&lt;/code&gt; 값 이 설정 되면 &lt;code&gt;val(buffer)&lt;/code&gt; 는 위의 최대 값으로 자동 설정됩니다 . 그러나 &lt;code&gt;sndbuf&lt;/code&gt; 및 &lt;code&gt;recbuf&lt;/code&gt; 에 대해 설정된 크기 가 일반적으로 커짐에 따라 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 운영 체제의 동작을 분석하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0337cb0052fe5c48f17d9708364b5583f847dcf3" translate="yes" xml:space="preserve">
          <source>The size used by the atom table.</source>
          <target state="translated">아톰 테이블에서 사용하는 크기입니다.</target>
        </trans-unit>
        <trans-unit id="e83812695b4a0e2f148a81a290a4a4d654c89eac" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of a log file before switching to a new log file. Defaults to 100000, minimum is 1000, maximum is about 2^30.</source>
          <target state="translated">새 로그 파일로 전환하기 전에 로그 파일의 크기 (바이트)입니다. 기본값은 100000이며, 최소값은 1000이며 최대 값은 약 2 ^ 30입니다.</target>
        </trans-unit>
        <trans-unit id="50b5375e0c8bae3f537af36dd5bfe134a6c1fd3a" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel receive buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(recbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">이 소켓에 대한 OS 커널 수신 버퍼의 크기 (바이트)입니다. &lt;code&gt;val(recbuf)&lt;/code&gt; 보다 큰 데이터 그램의 경우 전송 오류가 발생합니다 . 이 옵션을 설정하면 드라이버 버퍼의 크기도 조정됩니다 ( 위의 &lt;code&gt;buffer&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="744f9981cac8532f8de991a560a3c78c830d93a6" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel send buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(sndbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">이 소켓에 대한 OS 커널 송신 버퍼의 크기 (바이트)입니다. &lt;code&gt;val(sndbuf)&lt;/code&gt; 보다 큰 데이터 그램의 경우 전송 오류가 발생합니다 . 이 옵션을 설정하면 드라이버 버퍼의 크기도 조정됩니다 ( 위의 &lt;code&gt;buffer&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="80ca8cbf4860dc45abcab2ee816502487d967651" translate="yes" xml:space="preserve">
          <source>The sizes of the log events affect the memory needs of the handler. For information about how to limit the size of log events, see the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">로그 이벤트의 크기는 핸들러의 메모리 요구에 영향을줍니다. 로그 이벤트 크기를 제한하는 방법에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2bdd08787f901adfc9bda5806a8294e711f82f7" translate="yes" xml:space="preserve">
          <source>The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used.</source>
          <target state="translated">슬레이브 노드는 마스터에서 동일한 파일 시스템을 사용해야합니다. 최소한 Erlang / OTP는 두 컴퓨터 모두에서 동일한 위치에 설치해야하며 동일한 버전의 Erlang을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f96a0c0475b2702681a975d50f5c5275575ff811" translate="yes" xml:space="preserve">
          <source>The slave node resets its &lt;code&gt;user&lt;/code&gt; process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master.</source>
          <target state="translated">슬레이브 노드 는 슬레이브에서 생성 된 모든 터미널 I / O가 자동으로 마스터에 릴레이되도록 &lt;code&gt;user&lt;/code&gt; 프로세스를 재설정합니다 . 또한 파일 프로세스가 마스터로 릴레이됩니다.</target>
        </trans-unit>
        <trans-unit id="c5dfcb751ff28f219d1d581b79806c8ef4c53f7f" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt;, passing along &lt;code&gt;Name&lt;/code&gt; and, if provided, &lt;code&gt;Args&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; is used as the first part of the node names, &lt;code&gt;Args&lt;/code&gt; is used to specify command-line arguments.</source>
          <target state="translated">슬레이브 노드는 시작된다 &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt; , 함께 통과 &lt;code&gt;Name&lt;/code&gt; 제공된 경우, 및 &lt;code&gt;Args&lt;/code&gt; . &lt;code&gt;Name&lt;/code&gt; 은 노드 이름의 첫 번째 부분으로 사용되며 &lt;code&gt;Args&lt;/code&gt; 는 명령 줄 인수를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a9facae6762d3a2d983123523a049078f4b929" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with the &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; module. This effects terminal I/O, file I/O, and code loading.</source>
          <target state="translated">슬레이브 노드는 &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; 모듈 로 시작됩니다 . 이는 터미널 I / O, 파일 I / O 및 코드로드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="eff695ae8a9be5c2401875ebeb79790be1f1fe68" translate="yes" xml:space="preserve">
          <source>The slave nodes send regular reports to the master about their current load.</source>
          <target state="translated">슬레이브 노드는 현재로드에 대한 정기적 인 보고서를 마스터에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1bd8d8ae05660e3f8d1c448fac43b54c3d2e34e2" translate="yes" xml:space="preserve">
          <source>The smallest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">가장 작은 &lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt; 블록 캐리어 크기 ( smbcs )</target>
        </trans-unit>
        <trans-unit id="aa74489ccfd55ad582b4db554e67d3965db81df4" translate="yes" xml:space="preserve">
          <source>The smallest unit that the test server is concerned with is a test case. Each test case can test many things, for example, make several calls to the same interface function with different parameters.</source>
          <target state="translated">테스트 서버와 관련된 가장 작은 단위는 테스트 케이스입니다. 각 테스트 케이스는 여러 가지를 테스트 할 수 있습니다. 예를 들어, 다른 매개 변수를 사용하여 동일한 인터페이스 기능을 여러 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9ea79c809c45352a9e00179e7da2c36055d038e8" translate="yes" xml:space="preserve">
          <source>The snmp application provides two different modules, &lt;code&gt;snmpm_net_if&lt;/code&gt; (the default) and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;, both uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;. The difference between the two modules is that the latter is &quot;multi-threaded&quot;, i.e. for each message/request a new process is created that processes the message/request and then exits.</source>
          <target state="translated">snmp 애플리케이션은 &lt;code&gt;snmpm_net_if&lt;/code&gt; (기본값) 및 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; 라는 두 가지 모듈을 제공합니다 . 둘 다 UDP를 전송 프로토콜로 사용합니다 (예 : 전송 도메인 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 및 / 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; ) . 두 모듈의 차이점은 후자가 &quot;멀티 스레드&quot;라는 것입니다. 즉, 각 메시지 / 요청에 대해 메시지 / 요청을 처리 한 다음 종료하는 새 프로세스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="890d257b12c0103c2f2773954dbb3903b79d49e7" translate="yes" xml:space="preserve">
          <source>The socket is set to a busy state when the amount of data queued internally by the ERTS socket implementation reaches this limit. Defaults to 8 kB.</source>
          <target state="translated">ERTS 소켓 구현에 의해 내부적으로 대기중인 데이터의 양이이 한계에 도달하면 소켓이 사용 중 상태로 설정됩니다. 기본값은 8kB입니다.</target>
        </trans-unit>
        <trans-unit id="ab70c80adb0296ab4476e7326e05623f1d1b81ea" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be from &lt;code&gt;gen_tcp:connect&lt;/code&gt; or &lt;code&gt;gen_tcp:accept&lt;/code&gt; with option &lt;code&gt;{active,false}&lt;/code&gt;</source>
          <target state="translated">소켓은 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 또는 &lt;code&gt;gen_tcp:accept&lt;/code&gt; ( &lt;code&gt;{active,false}&lt;/code&gt; 옵션 사용)에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="44cb3c6e112d60616f61ce3179ae2f5db9db0cba" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be result of a &lt;code&gt;gen_tcp:connect&lt;/code&gt; or a &lt;code&gt;gen_tcp:accept&lt;/code&gt;. The socket must be in passive mode (that is, opened with the option &lt;code&gt;{active,false})&lt;/code&gt;.</source>
          <target state="translated">소켓은 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 또는 &lt;code&gt;gen_tcp:accept&lt;/code&gt; 의 결과입니다 . 소켓은 수동 모드에 있어야합니다 (즉, &lt;code&gt;{active,false})&lt;/code&gt; 옵션으로 열림 ) .</target>
        </trans-unit>
        <trans-unit id="925659a2ced1ee88f823aa52063a42e6955489e2" translate="yes" xml:space="preserve">
          <source>The socket message queue is set to a busy state when the amount of data on the message queue reaches this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 8 kB.</source>
          <target state="translated">메시지 큐의 데이터 양이이 한계에 도달하면 소켓 메시지 큐가 사용 중 상태로 설정됩니다. 이 한계는 아직 ERTS 내부 소켓 구현에 도달하지 않은 데이터에만 적용됩니다. 기본값은 8kB입니다.</target>
        </trans-unit>
        <trans-unit id="f02f850d90c7fd6701fa67a1c73724ba84ac1faf" translate="yes" xml:space="preserve">
          <source>The socket owner process.</source>
          <target state="translated">소켓 소유자 프로세스</target>
        </trans-unit>
        <trans-unit id="72f50e8cca44d427ecdea919b729a9f976d4b8f1" translate="yes" xml:space="preserve">
          <source>The socket returned can only be used with &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt;. No traffic can be sent or received before that call.</source>
          <target state="translated">반환 된 소켓은 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 에만 사용할 수 있습니다 . 해당 통화 전에는 트래픽을 보내거나받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68853c7896ab72f079055456a599e669b94ec773" translate="yes" xml:space="preserve">
          <source>The socket, in format &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;, depending on &lt;code&gt;socket_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket_type&lt;/code&gt; 에 따라 &lt;code&gt;ip_comm&lt;/code&gt; 또는 &lt;code&gt;ssl&lt;/code&gt; 형식의 소켓 입니다.</target>
        </trans-unit>
        <trans-unit id="2268a9a9dea928b5f653dddc6d70d3d7abdecd4b" translate="yes" xml:space="preserve">
          <source>The software the client claims to be using (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">클라이언트가 사용한다고 주장하는 소프트웨어 (결정할 수없는 경우이 필드에 빼기 부호가 표시됨)</target>
        </trans-unit>
        <trans-unit id="59919acf7ad71bce9fc6539c387deaefebd73d43" translate="yes" xml:space="preserve">
          <source>The sorter uses temporary files only if &lt;code&gt;QH1&lt;/code&gt; does not evaluate to a list and the size of the binary representation of the answers exceeds &lt;code&gt;Size&lt;/code&gt; bytes, where &lt;code&gt;Size&lt;/code&gt; is the value of option &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">정렬 &lt;code&gt;QH1&lt;/code&gt; 이 목록으로 평가되지 않고 응답의 2 진 표현 &lt;code&gt;Size&lt;/code&gt; 가 크기 바이트를 초과하는 경우에만 임시 파일을 사용 합니다. 여기서 &lt;code&gt;Size&lt;/code&gt; 는 옵션 &lt;code&gt;size&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="881ec9a1f2e48b94ddfd3fa755f8d866af15e90d" translate="yes" xml:space="preserve">
          <source>The source code can be downloaded from the official site of Erlang/OTP or GitHub.</source>
          <target state="translated">소스 코드는 Erlang / OTP의 공식 사이트 또는 GitHub에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e180c78c274b1e63d26ec543874e277c8a7cd9c" translate="yes" xml:space="preserve">
          <source>The source code is indented and each line is prefixed with its line number.</source>
          <target state="translated">소스 코드가 들여 쓰기되고 각 줄 앞에 줄 번호가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="772cf36afe48c0ca08d944464d6f5613843516b5" translate="yes" xml:space="preserve">
          <source>The source file is compiled with the the original options appended to the given &lt;code&gt;Options&lt;/code&gt;, the output replacing the old object file if and only if compilation succeeds. A function &lt;code&gt;Filter&lt;/code&gt; can be specified for removing elements from from the original compiler options before the new options are added.</source>
          <target state="translated">소스 파일은 지정된 &lt;code&gt;Options&lt;/code&gt; 에 추가 된 원래 옵션으로 컴파일되며, 출력은 컴파일이 성공한 경우에만 이전 오브젝트 파일을 대체합니다. 새 옵션이 추가되기 전에 원래 컴파일러 옵션에서 요소를 제거하기 위해 함수 &lt;code&gt;Filter&lt;/code&gt; 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06894cd41dc043df906ea8b5e56fb15f704aa5a" translate="yes" xml:space="preserve">
          <source>The source for a backup is an activated checkpoint. The backup function &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; is most commonly used and returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;. It has the following arguments:</source>
          <target state="translated">백업 소스는 활성화 된 체크 포인트입니다. 백업 기능 &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; 가 가장 일반적으로 사용되며 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴합니다 . 다음과 같은 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ba4b6f6db86323236436d5d356017eead9a57a" translate="yes" xml:space="preserve">
          <source>The source of the message, usually the name of the application that generated it. This could be almost any string. When matching messages from certain applications, the version number of the application may have to be accounted for. This is what the NT event viewer calls &quot;source&quot;.</source>
          <target state="translated">메시지 소스, 일반적으로 메시지를 생성 한 응용 프로그램의 이름 이것은 거의 모든 문자열이 될 수 있습니다. 특정 응용 프로그램의 메시지를 일치시킬 때 응용 프로그램의 버전 번호를 고려해야합니다. 이것이 NT 이벤트 뷰어가 &quot;소스&quot;라고 부르는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcf8739969b05c2227a6f3526a3eecacb416317d" translate="yes" xml:space="preserve">
          <source>The source release is delivered with a lot of platform independent build results already pre-built. If you want to remove these pre-built files, invoke &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; from the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. After you have done this, you can build exactly the same way as before, but the build process will take a much longer time.</source>
          <target state="translated">소스 릴리스는 이미 사전 빌드 된 많은 플랫폼 독립적 빌드 결과와 함께 제공됩니다. 사전 빌드 된 파일을 제거 하려면 &lt;code&gt;$ERL_TOP&lt;/code&gt; 디렉토리 에서 &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; 를 호출 하십시오 . 이 작업을 수행 한 후에는 이전과 동일한 방식으로 빌드 할 수 있지만 빌드 프로세스에는 시간이 훨씬 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="61ba3eb61829a7833d7384b19b027906c4b3feb1" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$ROOT&lt;/code&gt; variable can only be used in the script, not as a command-line argument. The given directory is relative the Erlang installation directory.</source>
          <target state="translated">특수 &lt;code&gt;$ROOT&lt;/code&gt; 변수는 명령 행 인수가 아닌 스크립트에서만 사용할 수 있습니다. 주어진 디렉토리는 Erlang 설치 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="fd2015df355d448e0a3bd19ecbc252e161ab2cfb" translate="yes" xml:space="preserve">
          <source>The special match specification variables &lt;code&gt;'$_'&lt;/code&gt; and &lt;code&gt;'$*'&lt;/code&gt; can be accessed through the pseudo functions &lt;code&gt;object()&lt;/code&gt; (for &lt;code&gt;'$_'&lt;/code&gt;) and &lt;code&gt;bindings()&lt;/code&gt; (for &lt;code&gt;'$*'&lt;/code&gt;). As an example, one can translate the following &lt;code&gt;ets:match_object/2&lt;/code&gt; call to a &lt;code&gt;ets:select/2&lt;/code&gt; call:</source>
          <target state="translated">특수 일치 스펙 변수 &lt;code&gt;'$_'&lt;/code&gt; 및 &lt;code&gt;'$*'&lt;/code&gt; 는 의사 함수 &lt;code&gt;object()&lt;/code&gt; ( &lt;code&gt;'$_'&lt;/code&gt; ) 및 &lt;code&gt;bindings()&lt;/code&gt; ( &lt;code&gt;'$*'&lt;/code&gt; )를 통해 액세스 할 수 있습니다 . 예를 들어, 다음 &lt;code&gt;ets:match_object/2&lt;/code&gt; 호출을 &lt;code&gt;ets:select/2&lt;/code&gt; 호출로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d184230e40d23967b4ecaa91bc5e82ccd5cf4c3" translate="yes" xml:space="preserve">
          <source>The special property L&amp;amp; is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or &quot;other&quot;.</source>
          <target state="translated">특수 속성 L &amp;amp;도 지원됩니다. Lu, Ll 또는 Lt 속성이있는 문자, 즉 수정 자 또는 &quot;other&quot;로 분류되지 않은 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d78a416b1fb043fc9e7a30712c95b72e4af2747" translate="yes" xml:space="preserve">
          <source>The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.</source>
          <target state="translated">특수 쉘 명령에는 모두 (로컬) 함수 호출 구문이 있습니다. 그것들은 정상적인 함수 호출로 평가되며 하나의 표현식 시퀀스에서 많은 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63aa3b1e5890590b0f6ee8261569fec19c3e02cf" translate="yes" xml:space="preserve">
          <source>The special term &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; is used to &quot;splice&quot; in a string in a list, a string specified this way is not a list in itself, but the elements are elements of the surrounding list.</source>
          <target state="translated">특수 용어 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 는 목록의 문자열에서 &quot; 분할 &quot;하는 데 사용되며, 이러한 방식으로 지정된 문자열은 목록 자체가 아니지만 요소는 주변 목록의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="9f706ef9a4d4e07f69004ede757b96ff5ef984e0" translate="yes" xml:space="preserve">
          <source>The special value &lt;strong&gt;flag&lt;/strong&gt; instead indicates that the function &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; shall be used.</source>
          <target state="translated">대신 특수 값 &lt;strong&gt;플래그&lt;/strong&gt; 는 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; 함수가 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bcbf785b1e1daf48fbb6ef71da6f40a7025aba2b" translate="yes" xml:space="preserve">
          <source>The specification key does not exist.</source>
          <target state="translated">사양 키가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6b11d2daf1d2fe5ce8435f49d6f63466ec21923" translate="yes" xml:space="preserve">
          <source>The specification of &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; can be hard-coded as &lt;code&gt;{index, [2]}&lt;/code&gt; and &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;attributes&lt;/code&gt; 의 스펙은 각각 &lt;code&gt;{index, [2]}&lt;/code&gt; 및 &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt; 로 하드 코딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="569ad77b917c89cf2cb18ed8978c4e321b16e950" translate="yes" xml:space="preserve">
          <source>The specifications &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; were used in the test.</source>
          <target state="translated">사양 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; 은 시험에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="3c9f9bb6dda1817bac37a46fe84e1fbe4666f5af" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Filename&lt;/code&gt; is prefixed with the node name. Default &lt;code&gt;Filename&lt;/code&gt; is &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Filename&lt;/code&gt; 앞에 노드 이름이 붙습니다. 기본 &lt;code&gt;Filename&lt;/code&gt; 은 &lt;code&gt;ttb&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a78dd1ea59140a32308f444a3d3f489add93983" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;comparing equal&lt;/strong&gt; the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table, or &lt;strong&gt;matching&lt;/strong&gt; in other types of tables (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지정된 &lt;code&gt;Key&lt;/code&gt; 는 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 에서 오브젝트의 키를 &lt;strong&gt;비교&lt;/strong&gt; 하거나 다른 유형의 테이블에서 &lt;strong&gt;일치&lt;/strong&gt; 시켜 오브젝트를 식별하는 데 사용됩니다 (차이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 참조 ).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="832d1f70c554be8c643c3c3c0c699e86c09d600d" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;matching&lt;/strong&gt; the key of an object in a &lt;code&gt;set&lt;/code&gt; table, or &lt;strong&gt;compare equal&lt;/strong&gt; to the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지정된 &lt;code&gt;Key&lt;/code&gt; 는 &lt;code&gt;set&lt;/code&gt; 테이블 에서 오브젝트의 키를 &lt;strong&gt;일치&lt;/strong&gt; 시켜 오브젝트를 식별 하거나 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 의 오브젝트 키와 &lt;strong&gt;비교&lt;/strong&gt; 하여 사용됩니다 (차이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 참조). ).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c6caca78cf0733387e75985a561e3ed41d83af2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;logdir&lt;/code&gt; directory is used for storing the HTML log files (in subdirectories tagged with node name, date, and time).</source>
          <target state="translated">지정된 &lt;code&gt;logdir&lt;/code&gt; 디렉토리는 HTML 로그 파일 (노드 이름, 날짜 및 시간으로 태그가 지정된 서브 디렉토리)을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8f4d5f198f549cf59998ab6e9b38627280804f7" translate="yes" xml:space="preserve">
          <source>The specified XML document is sent &quot;as is&quot; to the server. This function can be used for sending XML documents that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">지정된 XML 문서는 &quot;있는 그대로&quot;서버로 전송됩니다. 이 함수는이 모듈의 다른 인터페이스 함수로는 표현할 수없는 XML 문서를 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67af2595bd4825418d486d6611387842fada4fe3" translate="yes" xml:space="preserve">
          <source>The specified XML document is wrapped in a valid NETCONF &lt;code&gt;rpc&lt;/code&gt; request and sent to the server. The &lt;code&gt;message-id&lt;/code&gt; and namespace attributes are added to element &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">지정된 XML 문서는 유효한 NETCONF &lt;code&gt;rpc&lt;/code&gt; 요청으로 랩핑되어 서버로 전송됩니다. &lt;code&gt;message-id&lt;/code&gt; 와 네임 스페이스 속성은 요소에 추가됩니다 &lt;code&gt;rpc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ace5a3a9ee7abec7d82aa98cb78832103cfb00" translate="yes" xml:space="preserve">
          <source>The specified application is not loaded.</source>
          <target state="translated">지정된 응용 프로그램이로드되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7d093a57604a6ecaca53b3ce36fbb95e4bc18f8a" translate="yes" xml:space="preserve">
          <source>The specified module flows from your instantiation of the &lt;code&gt;Viewer&lt;/code&gt;, to the &lt;code&gt;Collector&lt;/code&gt; that it automatically creates, gets stashed in as the &lt;code&gt;Trace Pattern&lt;/code&gt;, and eventually goes down into the bowels of the &lt;code&gt;Selector&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈은 당신의 인스턴스에서 흘러 &lt;code&gt;Viewer&lt;/code&gt; 받는 사람, &lt;code&gt;Collector&lt;/code&gt; 가 자동으로 생성하는 등의 은닉 가져옵니다 &lt;code&gt;Trace Pattern&lt;/code&gt; 의 창자로 내려 간다 결국, 및 &lt;code&gt;Selector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d37865ea2af043489e228e4a87a6f2db90cb4c8d" translate="yes" xml:space="preserve">
          <source>The specified release version &lt;code&gt;Vsn&lt;/code&gt; does not exist.</source>
          <target state="translated">지정된 릴리스 버전 &lt;code&gt;Vsn&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b8bce2d65b733b38425b28f665ddd56d541e379" translate="yes" xml:space="preserve">
          <source>The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged</source>
          <target state="translated">지정된 문자열 또는 문자가 대소 문자 변환됩니다. 지원되는 문자 세트는 ISO / IEC 8859-1 (라틴어 1이라고도 함)입니다. 이 세트 밖의 모든 값은 변경되지 않습니다</target>
        </trans-unit>
        <trans-unit id="a909f58eed86dcb459bb7e97f8bf0f61f50ce1e8" translate="yes" xml:space="preserve">
          <source>The spelling &lt;code&gt;behavior&lt;/code&gt; is also accepted.</source>
          <target state="translated">철자 &lt;code&gt;behavior&lt;/code&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5309c7fe313dda17e9facd4377c48f36ec3201cb" translate="yes" xml:space="preserve">
          <source>The stack back-trace (&lt;strong&gt;stacktrace&lt;/strong&gt;) is a list of &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; tuples. The field &lt;code&gt;Arity&lt;/code&gt; in the first tuple can be the argument list of that function call instead of an arity integer, depending on the exception.</source>
          <target state="translated">스택 역 추적 ( &lt;strong&gt;stacktrace&lt;/strong&gt; )은 &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; 튜플 의 목록입니다 . 첫 번째 튜플의 &lt;code&gt;Arity&lt;/code&gt; 필드 는 예외에 따라 arity 정수 대신 해당 함수 호출의 인수 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ce8e9f1c15d0274292ea0288412d440ab1701d" translate="yes" xml:space="preserve">
          <source>The stack dump is a dump of the Erlang process stack. Most of the live data (that is, variables currently in use) are placed on the stack; thus this can be interesting. One has to &quot;guess&quot; what is what, but as the information is symbolic, thorough reading of this information can be useful. As an example, we can find the state variable of the Erlang primitive loader online &lt;code&gt;(5)&lt;/code&gt; and &lt;code&gt;(6)&lt;/code&gt; in the following example:</source>
          <target state="translated">스택 덤프는 Erlang 프로세스 스택의 덤프입니다. 대부분의 라이브 데이터 (즉, 현재 사용중인 변수)가 스택에 배치됩니다. 따라서 이것은 흥미로울 수 있습니다. 무엇이 무엇인지 &quot;추측&quot;해야하지만, 정보가 상징적이므로이 정보를 철저히 읽는 것이 유용 할 수 있습니다. 예를 들어, 다음 예에서 Erlang 기본 로더 온라인의 상태 변수를 찾을 수 있습니다 &lt;code&gt;(5)&lt;/code&gt; 및 &lt;code&gt;(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4779fab4d980187187f7b568fd5d1cecf627b61" translate="yes" xml:space="preserve">
          <source>The stack trace can be be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="translated">스택 추적은 &lt;code&gt;try&lt;/code&gt; 표현식 내에서 변수에 바인딩 될 수 있으며 &lt;code&gt;catch&lt;/code&gt; 표현식 에서 클래스 &lt;code&gt;error&lt;/code&gt; 예외에 대해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fe8ca8ba7f9cf2f1cf34954b8c2fda1504010ff" translate="yes" xml:space="preserve">
          <source>The stacktrace is the same data as operator &lt;code&gt;catch&lt;/code&gt; returns, for example:</source>
          <target state="translated">스택 &lt;code&gt;catch&lt;/code&gt; 은 연산자 캐치 리턴 과 동일한 데이터 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc5e2be1fd73b3184fa33140f882adc2e4eaf503" translate="yes" xml:space="preserve">
          <source>The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the current maximum stacktrace depth.</source>
          <target state="translated">stacktrace는 호출 프로세스의 예외 스택 추적으로 사용됩니다. 현재 최대 스택 트레이스 깊이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="95f65f456f73c264cfc1076a4ff37600ccf76a4a" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP behaviours are:</source>
          <target state="translated">표준 Erlang / OTP 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf7122f2f75170b13714d7076b64a347b292a606" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP system can be reconfigured to change the default behavior on startup.</source>
          <target state="translated">시작시 기본 동작을 변경하도록 표준 Erlang / OTP 시스템을 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7b586ddbaa84cea01ad2740636b956444f85f5b" translate="yes" xml:space="preserve">
          <source>The standard behaviours (&lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, and so on) send progress and error information to Logger. Progress reports are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;. Supervisor reports, crash reports and other error and information reports are by default logged through the log handler which is set up when the Kernel application is started.</source>
          <target state="translated">표준 비헤이비어 ( &lt;code&gt;supervisor&lt;/code&gt; , &lt;code&gt;gen_server&lt;/code&gt; 등)는 진행 및 오류 정보를 Logger에 보냅니다. 진행률 보고서는 기본적으로 로그되지 않지만 기본 로그 레벨을 &lt;code&gt;info&lt;/code&gt; 로 설정하여 ( 예 : 커널 구성 매개 변수 &lt;code&gt;logger_level&lt;/code&gt; 사용) 사용 가능하게 할 수 있습니다 . 관리자 보고서, 충돌 보고서 및 기타 오류 및 정보 보고서는 기본적으로 커널 응용 프로그램이 시작될 때 설정되는 로그 처리기를 통해 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2005b81eb265a1528dcd843192ed7f5d98a0c04c" translate="yes" xml:space="preserve">
          <source>The standard binary encoding is used whenever a library function in Erlang is to handle Unicode data in binaries, but is of course not enforced when communicating externally. Functions and bit syntax exist to encode and decode both UTF-8, UTF-16, and UTF-32 in binaries. However, library functions dealing with binaries and Unicode in general only deal with the default encoding.</source>
          <target state="translated">표준 이진 인코딩은 Erlang의 라이브러리 함수가 이진에서 유니 코드 데이터를 처리 할 때마다 사용되지만 물론 외부 통신시에는 적용되지 않습니다. 바이너리에서 UTF-8, UTF-16 및 UTF-32를 모두 인코딩하고 디코딩하기위한 함수와 비트 구문이 있습니다. 그러나 바이너리 및 유니 코드를 다루는 라이브러리 함수는 일반적으로 기본 인코딩 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4183835861454020cbfc8b77885a3f621959b27b" translate="yes" xml:space="preserve">
          <source>The standard certificate extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">표준 인증서 확장 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8da6740394a506d3316b11fa47e1c984ea529f7" translate="yes" xml:space="preserve">
          <source>The standard documents that define SNMPv2 are incomplete, in the sense that they do not specify how an SNMPv2 message looks like. The message format and security issues are left to a special Administrative Framework. One such framework is the Community-based SNMPv2 Framework (SNMPv2c), which uses the same message format and framework as SNMPv1. Other experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.</source>
          <target state="translated">SNMPv2를 정의하는 표준 문서는 SNMPv2 메시지의 모양을 지정하지 않는다는 점에서 불완전합니다. 메시지 형식 및 보안 문제는 특별한 관리 프레임 워크에 맡겨져 있습니다. 이러한 프레임 워크 중 하나는 SNMPv1과 동일한 메시지 형식 및 프레임 워크를 사용하는 커뮤니티 기반 SNMPv2 프레임 워크 (SNMPv2c)입니다. 존재하는 다른 실험 프레임 워크 (예 : SNMPv2u 및 SNMPv2 *)</target>
        </trans-unit>
        <trans-unit id="dc54a83b77765211d993fa09d8d0f6be7eb0aa1e" translate="yes" xml:space="preserve">
          <source>The standard example is when formatting source code as HTML to be placed within &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; markup, and using e.g. &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; to make parts of the source code stand out. In this case, the markup does not add to the width of the text when viewed in an HTML browser, so the layout engine should simply pretend that the markup has zero width.</source>
          <target state="translated">표준 예는 소스 코드를 HTML로 형식화하여 &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; 태그 내에 배치 하고 예를 들어 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 를 사용하여 소스 코드의 일부를 두드러지게하는 경우입니다. 이 경우 HTML 브라우저에서 볼 때 마크 업이 텍스트 너비에 추가되지 않으므로 레이아웃 엔진은 단순히 마크 업의 너비가 0 인 것처럼 가장해야합니다.</target>
        </trans-unit>
        <trans-unit id="913db80fae0242e7eb7aa0597b7610d00dd2e55e" translate="yes" xml:space="preserve">
          <source>The standard list encoding for strings was therefore easily extended to handle the whole Unicode range. A Unicode string in Erlang is a list containing integers, where each integer is a valid Unicode code point and represents one character in the Unicode character set.</source>
          <target state="translated">따라서 문자열의 표준 목록 인코딩이 전체 유니 코드 범위를 처리하도록 쉽게 확장되었습니다. Erlang의 유니 코드 문자열은 정수를 포함하는 목록입니다. 여기서 각 정수는 유효한 유니 코드 코드 포인트이며 유니 코드 문자 집합에서 한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96e137cd77a79e26488628d7b4bc6d3c818af033" translate="yes" xml:space="preserve">
          <source>The standard module &lt;code&gt;lists&lt;/code&gt; also contains a function &lt;code&gt;sort(Fun, List)&lt;/code&gt; where &lt;code&gt;Fun&lt;/code&gt; is a fun with two arguments. This fun returns &lt;code&gt;true&lt;/code&gt; if the first argument is less than the second argument, or else &lt;code&gt;false&lt;/code&gt;. Sorting is added to the &lt;code&gt;convert_list_to_c&lt;/code&gt;:</source>
          <target state="translated">표준 모듈 &lt;code&gt;lists&lt;/code&gt; 에는 함수 &lt;code&gt;sort(Fun, List)&lt;/code&gt; 도 포함되어 있습니다. 여기서 &lt;code&gt;Fun&lt;/code&gt; 은 두 개의 인수를 갖는 재미입니다. 이 재미 반환 &lt;code&gt;true&lt;/code&gt; 첫 번째 인수가 두 번째 인수, 또는 다른보다 작은 경우 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;convert_list_to_c&lt;/code&gt; 에 정렬이 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b21571b3224dc79a2851fad7a8fdb257c1dfd3c9" translate="yes" xml:space="preserve">
          <source>The standard shell is set for &lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;latin1&lt;/code&gt; encoding when the system is started. The encoding is set with the help of the &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in &lt;code&gt;{encoding, unicode}&lt;/code&gt; mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option.</source>
          <target state="translated">시스템이 시작될 때 표준 쉘은 &lt;code&gt;unicode&lt;/code&gt; 또는 &lt;code&gt;latin1&lt;/code&gt; 인코딩으로 설정됩니다. 인코딩은 Unix 계열 시스템 의 &lt;code&gt;LANG&lt;/code&gt; 또는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 환경 변수를 사용하거나 다른 시스템의 다른 방법으로 설정됩니다. 따라서 사용자는 유니 코드 문자를 입력 할 수 있으며 I / O 장치가 지원하는 경우 I / O 장치는 &lt;code&gt;{encoding, unicode}&lt;/code&gt; 모드입니다. 이 옵션을 설정하여 런타임 시스템의 가정이 잘못된 경우 모드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bbcd01c05d5bf0aeb5fe03e942b16191c94a69" translate="yes" xml:space="preserve">
          <source>The start function &lt;strong&gt;must create and link to&lt;/strong&gt; the child process, and must return &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, where &lt;code&gt;Child&lt;/code&gt; is the pid of the child process and &lt;code&gt;Info&lt;/code&gt; any term that is ignored by the supervisor.</source>
          <target state="translated">시작 함수 &lt;strong&gt;는&lt;/strong&gt; 하위 프로세스 &lt;strong&gt;를 작성하고 링크&lt;/strong&gt; 해야하며 &lt;code&gt;{ok,Child}&lt;/code&gt; 또는 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 를 리턴해야합니다 . 여기서 &lt;code&gt;Child&lt;/code&gt; 는 하위 프로세스의 pid이고 감독자가 무시하는 모든 용어는 &lt;code&gt;Info&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32924ed60f44bfc045cee6cadfb10d688a40ff5d" translate="yes" xml:space="preserve">
          <source>The start function can also return &lt;code&gt;ignore&lt;/code&gt; if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored.</source>
          <target state="translated">어떤 이유로 하위 프로세스를 시작할 수 &lt;code&gt;ignore&lt;/code&gt; 경우 시작 함수는 무시 를 리턴 할 수도 있습니다.이 경우 하위 스펙이 감독자에 의해 유지되지만 (하위 하위가 아닌 경우) 존재하지 않는 하위 프로세스는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a860e23df31c942b2bc0c3412b761a4dcef25730" translate="yes" xml:space="preserve">
          <source>The start function required by &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 필요한 시작 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="27f87c72bb318d024045b5c43b6afc31f6ec794d" translate="yes" xml:space="preserve">
          <source>The start function should use the &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; and/or &lt;code&gt;Config&lt;/code&gt; to select and return an appropriate list of local IP addresses. In the connecting case, the local address list can instead be communicated in a &lt;code&gt;connected&lt;/code&gt; message (see &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; below) following connection establishment. In either case, the local address list is used to populate &lt;code&gt;Host-IP-Address&lt;/code&gt; AVPs in outgoing capabilities exchange messages if &lt;code&gt;Host-IP-Address&lt;/code&gt; is unspecified.</source>
          <target state="translated">시작 기능은 &lt;code&gt;Svc&lt;/code&gt; 및 / 또는 &lt;code&gt;Config&lt;/code&gt; 의 &lt;code&gt;Host-IP-Address&lt;/code&gt; 목록을 사용 하여 적절한 로컬 IP 주소 목록을 선택하고 반환해야합니다. 연결하는 경우 연결 설정 후 로컬 주소 목록을 &lt;code&gt;connected&lt;/code&gt; 메시지 로 전달할 수 있습니다 (아래 &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; 참조). 두 경우 모두 로컬 주소 목록은 &lt;code&gt;Host-IP-Address&lt;/code&gt; 가 지정되지 않은 경우 발신 기능 교환 메시지에서 &lt;code&gt;Host-IP-Address&lt;/code&gt; AVP 를 채우는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cef6600c64628b5df747acb2766fd1cbe1d3b19" translate="yes" xml:space="preserve">
          <source>The start phases are defined by the application specification key &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt;. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</source>
          <target state="translated">시작 단계는 응용 프로그램 스펙 키 &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt; 의해 정의됩니다 . 포함 된 애플리케이션의 경우 단계 세트는 포함 애플리케이션에 대해 정의 된 단계 세트의 서브 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7acb8d9625f3baf5a2f8a4a89f3e914252275eb8" translate="yes" xml:space="preserve">
          <source>The start program must call &lt;code&gt;run_erl&lt;/code&gt; as shown below. It must also take an optional parameter, which defaults to &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">시작 프로그램은 아래와 같이 &lt;code&gt;run_erl&lt;/code&gt; 을 호출해야합니다 . 또한 선택적 매개 변수를 사용해야하며 기본값은 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dadcd9880753a230e08e39eb7ab7929eb5a6e0c2" translate="yes" xml:space="preserve">
          <source>The startup procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory is referred to as the Mnesia directory. Mnesia can also be started on disc-less nodes. For more information about disc-less nodes, see &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">일련의 Mnesia 노드에 대한 시작 절차는 상당히 복잡한 작업입니다. Mnesia 시스템은 일련의 노드로 구성되며 Mnesia는 모든 참여 노드에서 로컬로 시작됩니다. 일반적으로 각 노드에는 모든 Mnesia 파일이 작성되는 디렉토리가 있습니다. 이 디렉토리를 Mnesia 디렉토리라고합니다. 디스크없는 노드에서 Mnesia를 시작할 수도 있습니다. 디스크없는 노드에 대한 자세한 내용은 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ec6e88891409b6ff8f9a27843da0963ec7c3164" translate="yes" xml:space="preserve">
          <source>The state can be any term and the callback function &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; is used for all states.</source>
          <target state="translated">상태는 임의의 용어 일 수 있으며 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 는 모든 상태에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="77f821816af50887b3f025a4e6599280206657b6" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt;, the event dependent &lt;code&gt;EventContent&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">상태는 함수 자체의 이름이거나 인수입니다. 다른 인수는 &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt; , 이벤트 종속 &lt;code&gt;EventContent&lt;/code&gt; 및 현재 서버 &lt;code&gt;Data&lt;/code&gt; 설명 된 &lt;code&gt;EventType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9426ff2ed56deac331065c555f73deceea5d2d1f" translate="yes" xml:space="preserve">
          <source>The state must be of type &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; and one callback function per state, that is, &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;, is used.</source>
          <target state="translated">상태는 &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; 유형이어야하며 상태 당 하나의 콜백 함수, 즉 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d13d42182a76700706e21237d549fc59709fd9b9" translate="yes" xml:space="preserve">
          <source>The state of the handler.</source>
          <target state="translated">핸들러의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="15825c6d947625e874b105c1baf6a684fccb64cc" translate="yes" xml:space="preserve">
          <source>The state of the process. This can be one of the following:</source>
          <target state="translated">프로세스 상태. 이것은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="289e59e1fe9a8e03ffb9d797627caef032453480" translate="yes" xml:space="preserve">
          <source>The state returned from each call of &lt;code&gt;Function&lt;/code&gt; is passed to the next call, even if the next call is to format a message from another log file.</source>
          <target state="translated">다음 호출이 다른 로그 파일의 메시지를 형식화하는 경우에도 각 &lt;code&gt;Function&lt;/code&gt; 호출에서 리턴 된 상태 는 다음 호출로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="dd050ef7cc16c451eba6404d640a1ee02e6c6b42" translate="yes" xml:space="preserve">
          <source>The state returned from this function can not be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="translated">이 기능에서 반환 된 상태는 다른 &lt;code&gt;rand&lt;/code&gt; 기능 과 같이 재현 가능한 임의 순서를 얻는 데 사용할 수 없습니다. 재현성은 암호 적으로 안전하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3fae0626bf69d79a71c33c9da2c9ae7fb12888d7" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt; 호출 할 때 지정된 상태 입니다. 추적 프로그램 상태는 &lt;code&gt;erl_tracer&lt;/code&gt; 콜백에 전달되는 변경 불가능한 값이며 추적 이벤트를 생성하는 데 필요한 모든 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1ab345b32e922b70cc7799981ef1e76b747d4f17" translate="yes" xml:space="preserve">
          <source>The state.</source>
          <target state="translated">상태.</target>
        </trans-unit>
        <trans-unit id="43d74fe2df87f64ba71d3e82fa6cf8b2cdbfe68c" translate="yes" xml:space="preserve">
          <source>The status bar at the bottom of the window shows a warning if the currently loaded dump is truncated.</source>
          <target state="translated">현재로드 된 덤프가 잘린 경우 창의 맨 아래에있는 상태 표시 줄에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7fb7334448d68c19546b3da05bde0756339f62d8" translate="yes" xml:space="preserve">
          <source>The status of a subgroup can be returned (&lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;failed&lt;/code&gt;), to affect the execution of the group on the level above. This is accomplished by, in &lt;code&gt;end_per_group/2&lt;/code&gt;, looking up the value of &lt;code&gt;tc_group_properties&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list and checking the result of the test cases in the group. If status &lt;code&gt;failed&lt;/code&gt; is to be returned from the group as a result, &lt;code&gt;end_per_group/2&lt;/code&gt; is to return the value &lt;code&gt;{return_group_result,failed}&lt;/code&gt;. The status of a subgroup is taken into account by &lt;code&gt;Common Test&lt;/code&gt; when evaluating if execution of a group is to be repeated or not (unless the basic &lt;code&gt;repeat&lt;/code&gt; property is used).</source>
          <target state="translated">하위 그룹의 상태를 반환 ( &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;failed&lt;/code&gt; )하여 위 레벨에서 그룹 실행에 영향을 줄 수 있습니다 . 이것은에 의해 달성된다 &lt;code&gt;end_per_group/2&lt;/code&gt; 의 값을 찾고 &lt;code&gt;tc_group_properties&lt;/code&gt; 의 &lt;code&gt;Config&lt;/code&gt; 목록 및 그룹의 테스트 케이스의 결과를 검사합니다. 결과적으로 &lt;code&gt;failed&lt;/code&gt; 상태 가 그룹에서 리턴되면 &lt;code&gt;end_per_group/2&lt;/code&gt; 는 &lt;code&gt;{return_group_result,failed}&lt;/code&gt; 값을 리턴하는 것 입니다. 하위 그룹의 상태는 그룹의 실행이 반복되는지 여부를 평가할 때 &lt;code&gt;Common Test&lt;/code&gt; 의해 기본 &lt;code&gt;repeat&lt;/code&gt; 특성이 사용 되지 않는 한 고려 됩니다.</target>
        </trans-unit>
        <trans-unit id="b85c37fec76de27c56e3406adaafa6e8b1d27921" translate="yes" xml:space="preserve">
          <source>The status of a test case explicitly skipped in any of the ways described in section &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된 방식으로 테스트 사례의 상태를 명시 적으로 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="6ae5f35d675d1272e78fb3eaf4d81a316518f52b" translate="yes" xml:space="preserve">
          <source>The step functionality can be used together with flag/option &lt;code&gt;suite&lt;/code&gt; and &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt;, but not together with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">단계 기능은 flag / option &lt;code&gt;suite&lt;/code&gt; 및 &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt; 와 함께 사용할 수 있지만 &lt;code&gt;dir&lt;/code&gt; 과 함께 사용할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="23a47861a1df8e95627b42341a8487a2338f8876" translate="yes" xml:space="preserve">
          <source>The stop callback was called directly by &lt;code&gt;enif_select&lt;/code&gt;.</source>
          <target state="translated">중지 콜백은 &lt;code&gt;enif_select&lt;/code&gt; 에 의해 직접 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eff8dcd2a113b22b62950f59f611b3549632ee05" translate="yes" xml:space="preserve">
          <source>The stop callback was scheduled to run on some other thread or later by this thread.</source>
          <target state="translated">중지 콜백은 다른 스레드에서 또는 나중에이 스레드에서 실행되도록 예약되었습니다.</target>
        </trans-unit>
        <trans-unit id="6eb9b8c23b1b206be09c84ebb2950996bdcd33b8" translate="yes" xml:space="preserve">
          <source>The storage engine must call &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; and &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt;. See the OpenSSL cryptolib's &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스토리지 엔진은 &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; 및 &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt; 을 호출해야합니다 . OpenSSL cryptolib의 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1ee5838e32832bdcc704cd56398a34eb2a5f6f" translate="yes" xml:space="preserve">
          <source>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</source>
          <target state="translated">스토리지 유형이 유지됩니다. 예를 들어 한 노드에서 이동 한 RAM 테이블은 새 노드의 RAM으로 남아 있습니다. 다른 트랜잭션은 테이블이 이동되는 동안 여전히 테이블에서 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29dd2c34d1090a0d800c2e247d0fc176342cf1f0" translate="yes" xml:space="preserve">
          <source>The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first &lt;code&gt;next_event&lt;/code&gt; in the containing list becomes the first to process.</source>
          <target state="translated">저장된 이벤트는 이미 큐에있는 이벤트 전에 처리 할 다음으로 큐에 삽입됩니다. 이러한 저장된 이벤트의 순서가 유지되므로 포함 목록 의 첫 번째 &lt;code&gt;next_event&lt;/code&gt; 가 가장 먼저 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c05a53cb68134dabc5d7bae05169ae1a11647b27" translate="yes" xml:space="preserve">
          <source>The stream hasn't been initialized, eg. if &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; wasn't called prior to a call to &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 스트림이 초기화되지 않았습니다. 경우 &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; 이전에 전화로 호출되지 않은 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6455104e94ea1d2cc707927b01ebea3a44bfd27f" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="translated">스트림을 제어하지 않는 프로세스에서 스트림을 사용했습니다. 스트림을 다른 프로세스로 전송해야하는 경우 &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e2fdb4e651b9aa41fcc3bc6966fd38ca9895ed9" translate="yes" xml:space="preserve">
          <source>The string is copied to &lt;code&gt;p&lt;/code&gt;, and enough space must be allocated. The returned string is &lt;code&gt;NULL&lt;/code&gt;-terminated, so you must add an extra byte to the memory requirement.</source>
          <target state="translated">문자열이 &lt;code&gt;p&lt;/code&gt; 에 복사 되고 충분한 공간이 할당되어야합니다. 반환 된 문자열은 &lt;code&gt;NULL&lt;/code&gt; 로 끝나므로 메모리 요구 사항에 추가 바이트를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="68785b1bbdb54c599efe5a2a41d523ae7b013997" translate="yes" xml:space="preserve">
          <source>The string length of &quot;&amp;szlig;&amp;uarr;e̊&quot; is 3, even though it is represented by the codepoints &lt;code&gt;[223,8593,101,778]&lt;/code&gt; or the UTF-8 binary &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;&amp;szlig; &amp;uarr; e̊&quot;의 문자열 길이는 코드 포인트 &lt;code&gt;[223,8593,101,778]&lt;/code&gt; 또는 UTF-8 이진 &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt; 로 표시되지만 3 입니다.</target>
        </trans-unit>
        <trans-unit id="4cf40fddbed63f7ac0d755d714db5efcb0dab3f9" translate="yes" xml:space="preserve">
          <source>The string the daemon will present to a connecting peer initially. The default value is &quot;Erlang/VSN&quot; where VSN is the ssh application version number.</source>
          <target state="translated">데몬이 처음에 연결 피어에 제공 할 문자열입니다. 기본값은 &quot;Erlang / VSN&quot;입니다. 여기서 VSN은 ssh 응용 프로그램 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="36753c090f707fe68109d16ad9e5e9da7b79ac27" translate="yes" xml:space="preserve">
          <source>The string was read, but more input is needed to complete the original format string. &lt;code&gt;RestFormat&lt;/code&gt; is the remaining format string, &lt;code&gt;Nchars&lt;/code&gt; is the number of characters scanned, and &lt;code&gt;InputStack&lt;/code&gt; is the reversed list of inputs matched up to that point.</source>
          <target state="translated">문자열을 읽었지만 원래 형식 문자열을 완료하려면 더 많은 입력이 필요합니다. &lt;code&gt;RestFormat&lt;/code&gt; 은 나머지 형식 문자열이고 &lt;code&gt;Nchars&lt;/code&gt; 는 스캔 된 문자 수이며 &lt;code&gt;InputStack&lt;/code&gt; 은 해당 지점과 일치하는 반전 된 입력 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6cf01db782c53881c8e9b381ef1af37e91bea8ec" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the input characters not used.</source>
          <target state="translated">문자열을 읽었습니다. &lt;code&gt;InputList&lt;/code&gt; 는 성공적으로 일치하고 읽은 항목의 목록이며 &lt;code&gt;LeftOverChars&lt;/code&gt; 는 사용되지 않는 입력 문자입니다.</target>
        </trans-unit>
        <trans-unit id="45cb7749daf0319866610d1f7a6f2fda868e24e9" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the remaining characters.</source>
          <target state="translated">문자열을 읽었습니다. &lt;code&gt;InputList&lt;/code&gt; 는 성공적으로 일치하고 읽은 항목의 목록이며 &lt;code&gt;LeftOverChars&lt;/code&gt; 는 나머지 문자입니다.</target>
        </trans-unit>
        <trans-unit id="7023fc710fcbee2ee1b2d0076f2bbb73fe92a4c8" translate="yes" xml:space="preserve">
          <source>The structure defines six tables in the database. In &lt;code&gt;Mnesia&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. &lt;code&gt;Name&lt;/code&gt; is the table name.</source>
          <target state="translated">이 구조는 데이터베이스에서 6 개의 테이블을 정의합니다. 에서 &lt;code&gt;Mnesia&lt;/code&gt; , 함수 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 테이블을 생성합니다. &lt;code&gt;Name&lt;/code&gt; 은 테이블 이름입니다.</target>
        </trans-unit>
        <trans-unit id="39d9e3d6533e72d537d969467d83db3f839ba80c" translate="yes" xml:space="preserve">
          <source>The structured types of ASN.1 are constructed from other types in a manner similar to the concepts of array and struct in C.</source>
          <target state="translated">ASN.1의 구조화 된 유형은 C의 배열 및 구조 개념과 유사한 방식으로 다른 유형으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3d28e19e96e7591f2c1e234739ca3d285e1425a0" translate="yes" xml:space="preserve">
          <source>The structured types previously described can have other named types as their components. The general syntax to assign a value to component &lt;code&gt;C&lt;/code&gt; of a named ASN.1 type &lt;code&gt;T&lt;/code&gt; in Erlang is the record syntax &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt;. Here &lt;code&gt;Value&lt;/code&gt; can be a value of yet another type &lt;code&gt;T2&lt;/code&gt;, for example:</source>
          <target state="translated">앞에서 설명한 구조화 된 유형에는 다른 명명 된 유형이 구성 요소로있을 수 있습니다. Erlang에서 명명 된 ASN.1 유형 &lt;code&gt;T&lt;/code&gt; 의 컴포넌트 &lt;code&gt;C&lt;/code&gt; 에 값을 지정하는 일반적인 구문 은 레코드 구문 &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt; 입니다. 여기서 &lt;code&gt;Value&lt;/code&gt; 는 다른 유형 &lt;code&gt;T2&lt;/code&gt; 의 값일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fc0372505592d800b784db4902cf9621fae67f0" translate="yes" xml:space="preserve">
          <source>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; The syntax is as follows:</source>
          <target state="translated">구독 기능은 이벤트 구독을 활성화합니다. 이벤트는 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 함수를 평가하는 프로세스에 메시지로 전달됩니다 . 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6fc9553c48dee56909efc052afcae5e3f5e6f87" translate="yes" xml:space="preserve">
          <source>The subset of calls from any of the vertices.</source>
          <target state="translated">정점의 통화 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5f5b8c212a6fee019c36df2950bd77268424ff70" translate="yes" xml:space="preserve">
          <source>The subset of calls to and from any of the vertices. For all sets of calls &lt;code&gt;CS&lt;/code&gt; and all sets of vertices &lt;code&gt;VS&lt;/code&gt;, &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; is equivalent to &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt;.</source>
          <target state="translated">정점과의 통화 하위 집합입니다. 모든 호출 집합 &lt;code&gt;CS&lt;/code&gt; 및 모든 정점 집합 &lt;code&gt;VS&lt;/code&gt; , &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; 는 &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt; 와 같습니다. | VS * CS || VS .</target>
        </trans-unit>
        <trans-unit id="d5085549ad982bc38493bd15cfb61ace15049e68" translate="yes" xml:space="preserve">
          <source>The subset of calls to any of the vertices.</source>
          <target state="translated">정점에 대한 호출의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="2fe87376a37704db2bf21986e270c17fe93f1cb0" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 생성 된 키를 사용하여 서브 시스템을 호스트 &lt;strong&gt;tarlop&lt;/strong&gt; 에서 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7163b547fafca1e1a01c6c85101dafd95545463" translate="yes" xml:space="preserve">
          <source>The subtype constraint (&lt;code&gt;CONTAINING&lt;/code&gt;/&lt;code&gt;ENCODED BY&lt;/code&gt;) to constrain the content of an octet string or a bit string is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">8 진수 문자열 또는 비트 문자열의 내용을 제한하는 하위 유형 제약 조건 ( &lt;code&gt;CONTAINING&lt;/code&gt; / &lt;code&gt;ENCODED BY&lt;/code&gt; )은 컴파일 할 때 구문 분석되지만 추가 조치는 수행되지 않습니다. 이 제한 조건은 PER 표시 제한 조건이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="996c8474dfc5442a02a67e994d403bba3cebf442" translate="yes" xml:space="preserve">
          <source>The subtype constraint by regular expressions (&lt;code&gt;PATTERN&lt;/code&gt;) for character string types is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">문자열 유형에 대한 정규 표현식 ( &lt;code&gt;PATTERN&lt;/code&gt; )에 의한 부속 유형 제한 조건 은 컴파일 할 때 구문 분석되지만 추가 조치는 수행되지 않습니다. 이 제한 조건은 PER 표시 제한 조건이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="449b6a9e34717e9034f068e9ddd7557ac6068822" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;FuncCallCount&lt;/code&gt; values for all functions in module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;Mod&lt;/code&gt; 의 모든 함수에 대한 &lt;code&gt;FuncCallCount&lt;/code&gt; 값 의 합입니다 .</target>
        </trans-unit>
        <trans-unit id="3234d4076f0843a2b33750a12acc0b2c6ea1ad8f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;ModCallCount&lt;/code&gt; values for all modules concerned in &lt;code&gt;ModAnalysisList&lt;/code&gt;.</source>
          <target state="translated">합계 &lt;code&gt;ModCallCount&lt;/code&gt; 는 에 관련된 모든 모듈 값 &lt;code&gt;ModAnalysisList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7d6e1d3697888bda0178100688b0ec34a104aff" translate="yes" xml:space="preserve">
          <source>The sum of all memory categories.</source>
          <target state="translated">모든 메모리 범주의 합입니다.</target>
        </trans-unit>
        <trans-unit id="ff0037c4e027cabbd2193a3640bbe8630c8ea4e3" translate="yes" xml:space="preserve">
          <source>The sum of all off-heap binaries allocated.</source>
          <target state="translated">할당 된 모든 힙 외부 바이너리의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="b154828ab69194ef3277c5a0a09ca37fe5a5d84e" translate="yes" xml:space="preserve">
          <source>The sum of all process memory used.</source>
          <target state="translated">사용 된 모든 프로세스 메모리의 합.</target>
        </trans-unit>
        <trans-unit id="44dab01c88ded1b7b32e51ef73e1252818de000b" translate="yes" xml:space="preserve">
          <source>The supervision tree is a hierarchical arrangement of code into supervisors and workers, which makes it possible to design and program fault-tolerant software.</source>
          <target state="translated">감독 트리는 감독자 및 작업자에게 계층 적으로 코드를 배열하여 내결함성 소프트웨어를 설계하고 프로그래밍 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b52420c5f524763cf64a935f578714dd96d159c" translate="yes" xml:space="preserve">
          <source>The supervisor behaviour supports changing the internal state, that is, changing the restart strategy and maximum restart frequency properties, as well as changing the existing child specifications.</source>
          <target state="translated">수퍼바이저 동작은 내부 상태 변경, 즉 재시작 전략 및 최대 재시작 빈도 특성 변경과 기존 하위 스펙 변경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cffb4f2e0dfb75d9604922d437c1a8dd8826e6a0" translate="yes" xml:space="preserve">
          <source>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">감독자는 자식 프로세스의 시작, 중지 및 모니터링을 담당합니다. 감독자의 기본 아이디어는 필요할 때 다시 시작하여 자식 프로세스를 활성 상태로 유지해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="768e22d6442b06516d91f5426c41a68d034c3f04" translate="yes" xml:space="preserve">
          <source>The supervisor must be registered as &lt;code&gt;ch_sup&lt;/code&gt; for the script to work. If the supervisor is not registered, it cannot be accessed directly from the script. Instead a help function that finds the pid of the supervisor and calls &lt;code&gt;supervisor:restart_child&lt;/code&gt;, and so on, must be written. This function is then to be called from the script using the &lt;code&gt;apply&lt;/code&gt; instruction.</source>
          <target state="translated">스크립트가 작동 하려면 수퍼바이저가 &lt;code&gt;ch_sup&lt;/code&gt; 으로 등록되어 있어야합니다 . 수퍼바이저가 등록되어 있지 않으면 스크립트에서 직접 액세스 할 수 없습니다. 대신 수퍼바이저의 pid를 찾고 &lt;code&gt;supervisor:restart_child&lt;/code&gt; 등을 호출하는 도움말 함수를 작성해야합니다. 그런 다음 &lt;code&gt;apply&lt;/code&gt; 명령어를 사용하여이 함수를 스크립트에서 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="dd784bb324ef894ad782bd6fc54c8cbffbd00c9c" translate="yes" xml:space="preserve">
          <source>The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows:</source>
          <target state="translated">수퍼바이저 속성은 수퍼바이저 플래그로 정의됩니다. 감독자 플래그의 유형 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="445d5aae8f507ca020cd700c1e982027b7aa04d5" translate="yes" xml:space="preserve">
          <source>The supervisor then starts all its child processes according to the child specifications in the start specification. In this case there is one child process, &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">감독자는 시작 사양의 하위 사양에 따라 모든 하위 프로세스를 시작합니다. 이 경우 하나의 자식 프로세스 인 &lt;code&gt;ch3&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ea33c0638456c050fb5c1069b48715bb9e4c7a" translate="yes" xml:space="preserve">
          <source>The supervisor tree of an included application is started as part of the supervisor tree of the including application. If there is a need for synchronization between processes in the including and included applications, this can be achieved by using &lt;strong&gt;start phases&lt;/strong&gt;.</source>
          <target state="translated">포함 된 애플리케이션의 수퍼바이저 트리는 포함하는 애플리케이션의 수퍼바이저 트리의 일부로 시작됩니다. 포함 및 포함 된 애플리케이션에서 프로세스 간 동기화가 필요한 경우 &lt;strong&gt;시작 단계&lt;/strong&gt; 를 사용하여이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a588b6125bf699dd160cdf7a903456eed3b8cbe9" translate="yes" xml:space="preserve">
          <source>The supervisors have a built-in mechanism to limit the number of restarts which can occur in a given time interval. This is specified by the two keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">수퍼바이저에는 지정된 시간 간격으로 발생할 수있는 재시작 횟수를 제한하는 내장 메커니즘이 있습니다. 이것은 콜백 함수 &lt;code&gt;init&lt;/code&gt; 에 의해 반환 된 수퍼바이저 플래그 맵에서 두 개의 키 &lt;code&gt;intensity&lt;/code&gt; 와 &lt;code&gt;period&lt;/code&gt; 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b2633e4167b1433781a2f1a62c27832d676f8d6" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;Reason&lt;/code&gt; becomes the exit reason for the server process. Default Any &lt;code&gt;Reason&lt;/code&gt; other than &lt;code&gt;kill&lt;/code&gt; sends a request to the server and waits for it to clean up, reply and exit. If &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;kill&lt;/code&gt;, the server is bluntly killed.</source>
          <target state="translated">제공된 &lt;code&gt;Reason&lt;/code&gt; 는 서버 프로세스의 종료 이유가됩니다. 기본 &lt;code&gt;kill&lt;/code&gt; 이외의 모든 &lt;code&gt;Reason&lt;/code&gt; 는 서버에 요청을 보내고 정리, 응답 및 종료를 기다립니다. 경우 &lt;code&gt;Reason&lt;/code&gt; 있다 &lt;code&gt;kill&lt;/code&gt; , 서버가 퉁명스럽게 사망한다.</target>
        </trans-unit>
        <trans-unit id="96f30a73bfb2b83438049030688c67e96198fa91" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. It is released before it is ready to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release.</source>
          <target state="translated">아카이브 파일에서 코드로드 지원은 실험적입니다. 조기 피드백을받을 준비가되기 전에 해제됩니다. 파일 형식, 의미, 인터페이스 등은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7908060a0b898a45469fbc25ab16112e1c77d124" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. The purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The function &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; and flag &lt;code&gt;-code_path_choice&lt;/code&gt; are also experimental.</source>
          <target state="translated">아카이브 파일에서 코드를로드하기위한 지원은 실험적입니다. 준비하기 전에 릴리스하는 목적은 조기 피드백을 얻는 것입니다. 파일 형식, 의미, 인터페이스 등은 다음 릴리스에서 변경 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;-code_path_choice&lt;/code&gt; 플래그 도 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="0fc1d82ce90810c32581e8a0920c335e0c517632" translate="yes" xml:space="preserve">
          <source>The support for loading of code from archive files is experimental. The only purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The &lt;code&gt;-code_path_choice&lt;/code&gt; flag is also experimental.</source>
          <target state="translated">아카이브 파일에서 코드로드 지원은 실험적입니다. 그것이 준비되기 전에 그것을 릴리스하는 유일한 목적은 조기 피드백을 얻는 것입니다. 파일 형식, 의미, 인터페이스 등은 다음 릴리스에서 변경 될 수 있습니다. &lt;code&gt;-code_path_choice&lt;/code&gt; 의 플래그는 실험이다.</target>
        </trans-unit>
        <trans-unit id="e2394cc20beed2954b20caec09868b8789fdcf8c" translate="yes" xml:space="preserve">
          <source>The support for sequential tracing provided by Trace Tool Builder includes the following:</source>
          <target state="translated">Trace Tool Builder가 제공하는 순차 추적 지원에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6228d25d9b25f4927da788e40437ce4f4ff23407" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;'-&amp;gt;'&lt;/code&gt;, and &lt;code&gt;':'&lt;/code&gt; have to be treated in a special way, as they are meta symbols of the grammar notation, as well as terminal symbols of the Yecc grammar.</source>
          <target state="translated">기호는 &lt;code&gt;'-&amp;gt;'&lt;/code&gt; 및 &lt;code&gt;':'&lt;/code&gt; 가 문법 표기법의 메타 문자뿐만 아니라 Yecc 문법의 터미널 상징으로, 특별한 방법으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5b1fca95a16b28d8128e58b5512a0179363f6cf" translate="yes" xml:space="preserve">
          <source>The symbols in front of the application names are intended to describe the status of the application. There are error and warning symbols to signalize that there is something which needs attention. The tick symbol means that the application is included or derived and no problem has been detected. The cross symbol means that the application is excluded or available and no problem has been detected. Applications with error symbols are listed first in each category and are followed by the warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">응용 프로그램 이름 앞에있는 기호는 응용 프로그램의 상태를 설명하기위한 것입니다. 주의가 필요한 것이 있음을 나타내는 오류 및 경고 기호가 있습니다. 틱 기호는 응용 프로그램이 포함되거나 파생되었으며 문제가 감지되지 않았 음을 나타냅니다. 십자 기호는 응용 프로그램이 제외되거나 사용 가능하며 문제가 감지되지 않았 음을 나타냅니다. 오류 기호가있는 응용 프로그램은 각 범주에서 먼저 나열되고 끝에 경고와 일반 경고 (틱 및 교차)가옵니다.</target>
        </trans-unit>
        <trans-unit id="4ff1d477dc7a2e1cb7c0f348638a12a2059b2005" translate="yes" xml:space="preserve">
          <source>The symbols in front of the module names are intended to describe the status of the module. There are error and and warning symbols to signalize that there is something that needs attention. The tick symbol means that the module is included or derived and no problem has been detected. The cross symbol means that the module is excluded or available and no problem has been detected. Modules with error symbols are listed first in each category and are followed by warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">모듈 이름 앞에있는 기호는 모듈의 상태를 설명하기위한 것입니다. 주의가 필요한 것이 있음을 나타내는 오류 및 경고 기호가 있습니다. 틱 기호는 모듈이 포함 또는 파생되었으며 문제가 감지되지 않았 음을 나타냅니다. 십자 기호는 모듈이 제외되었거나 사용 가능하며 문제가 발견되지 않았 음을 나타냅니다. 오류 기호가있는 모듈은 각 범주에서 첫 번째로 나열되며 끝에 경고와 일반 항목 (틱 및 십자 표시)이옵니다.</target>
        </trans-unit>
        <trans-unit id="9cf67be71d81d661199fd8c3ef66c9bc2a23e743" translate="yes" xml:space="preserve">
          <source>The synchronous request &lt;code&gt;alloc()&lt;/code&gt; is implemented using &lt;code&gt;gen_server:call/2&lt;/code&gt;:</source>
          <target state="translated">동기 요청 &lt;code&gt;alloc()&lt;/code&gt; 은 &lt;code&gt;gen_server:call/2&lt;/code&gt; 를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="63eb54580b86c06f3268ea4e7b5bcac96de253d8" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material.</source>
          <target state="translated">PCRE가 지원하는 정규식의 구문과 의미는 다음 섹션에 자세히 설명되어 있습니다. Perl의 정규 표현식은 자체 문서에 설명되어 있으며 일반적으로 정규 표현식은 많은 책에서 다루고 있으며 일부는 풍부한 예가 있습니다. O'Reilly가 출판 한 Jeffrey Friedl의 &quot;마스터 링 정규 표현식&quot;은 정규 표현식을 매우 자세하게 다룹니다. PCRE 정규식에 대한이 설명은 참조 자료로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7e6289b406769100c4fe1cdd3bffd156db1884" translate="yes" xml:space="preserve">
          <source>The syntax highlighting can be activated from the Erlang menu. There are four different alternatives:</source>
          <target state="translated">구문 강조는 Erlang 메뉴에서 활성화 할 수 있습니다. 네 가지 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="817a7b6234953ff285a5cf26b3d3913052cb1f96" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows (requires a list within the groups list):</source>
          <target state="translated">Erlang 쉘의 구문은 다음과 같습니다 (그룹 목록 내의 목록이 필요함).</target>
        </trans-unit>
        <trans-unit id="c11a6d8aa6d68bd5c6fc23a6b8b784283b982fbc" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows:</source>
          <target state="translated">Erlang 쉘의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21b1becf4be6592870e0896862b9b302a4959623" translate="yes" xml:space="preserve">
          <source>The syntax of  &lt;strong id=&quot;variable&quot;&gt;variables&lt;/strong&gt; is simple:</source>
          <target state="translated">&lt;strong id=&quot;variable&quot;&gt;변수&lt;/strong&gt; 구문 은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5861c6322d86304cb4290ee33a8caf450460f" translate="yes" xml:space="preserve">
          <source>The syntax of Erlang tokens allow the use of the full ISO-8859-1 (Latin-1) character set. This is noticeable in the following ways:</source>
          <target state="translated">Erlang 토큰의 구문을 통해 전체 ISO-8859-1 (라틴 -1) 문자 세트를 사용할 수 있습니다. 이것은 다음과 같은 방식으로 눈에 :니다.</target>
        </trans-unit>
        <trans-unit id="dc8d5f699e53e1bdc1770774109fbc1b5599f479" translate="yes" xml:space="preserve">
          <source>The system call failed to add the event object to the poll set.</source>
          <target state="translated">시스템 호출이 이벤트 오브젝트를 폴링 세트에 추가하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="401fca03bc6c302beb7da6e4fb8eca70f288ed7b" translate="yes" xml:space="preserve">
          <source>The system can become inconsistent as a result of a power failure. The UNIX feature &lt;code&gt;fsck&lt;/code&gt; can possibly repair the file system, but there is no guarantee that the file content is consistent.</source>
          <target state="translated">정전으로 인해 시스템이 일치하지 않을 수 있습니다. UNIX 기능 &lt;code&gt;fsck&lt;/code&gt; 는 파일 시스템을 복구 할 수 있지만 파일 내용이 일관성을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="11ac012ee2a6049d1c81dbfe5e5bcc868023bccc" translate="yes" xml:space="preserve">
          <source>The system configuration files for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;cp3@cave&lt;/code&gt; are identical, except for the list of mandatory nodes, which is to be &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; for &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">위한 시스템 구성 파일 &lt;code&gt;cp2@cave&lt;/code&gt; 와 &lt;code&gt;cp3@cave&lt;/code&gt; 이어야한다 필수 노드 목록을 제외하고 동일하다 &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; 대한 &lt;code&gt;cp2@cave&lt;/code&gt; 및 &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; 대한 &lt;code&gt;cp3@cave&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a86df323fb5ec0c1b444523d82be4cff548c59" translate="yes" xml:space="preserve">
          <source>The system configuration is to be called &lt;code&gt;Name.config&lt;/code&gt; and Erlang is to be started with the command-line argument &lt;code&gt;-config Name&lt;/code&gt;. For details, see the &lt;code&gt;config(4)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">시스템 구성은 &lt;code&gt;Name.config&lt;/code&gt; 이며 Erlang은 명령 행 인수 &lt;code&gt;-config Name&lt;/code&gt; 으로 시작 합니다. 자세한 내용 은 커널 의 &lt;code&gt;config(4)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f6cd0cc01a1dae027af31ac2b3320efd5d91c8a" translate="yes" xml:space="preserve">
          <source>The system events are as follows:</source>
          <target state="translated">시스템 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40222a7fb3caf074645df66a48dca922ad535e5b" translate="yes" xml:space="preserve">
          <source>The system has run out of memory. &amp;lt;A&amp;gt; is the allocator that failed to allocate memory, &amp;lt;N&amp;gt; is the number of bytes that &amp;lt;A&amp;gt; tried to allocate, and &amp;lt;T&amp;gt; is the memory block type that the memory was needed for. The most common case is that a process stores huge amounts of data. In this case &amp;lt;T&amp;gt; is most often &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;old_heap&lt;/code&gt;, &lt;code&gt;heap_frag&lt;/code&gt;, or &lt;code&gt;binary&lt;/code&gt;. For more information on allocators, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시스템 메모리가 부족합니다. &amp;lt;A&amp;gt;는 메모리 할당에 실패한 할당 자이고, &amp;lt;N&amp;gt;은 &amp;lt;A&amp;gt;가 할당하려고 시도한 바이트 수이며, &amp;lt;T&amp;gt;는 메모리에 필요한 메모리 블록 유형입니다. 가장 일반적인 경우는 프로세스가 대량의 데이터를 저장하는 것입니다. 이 경우 &amp;lt;T&amp;gt;는 대부분 &lt;code&gt;heap&lt;/code&gt; , &lt;code&gt;old_heap&lt;/code&gt; , &lt;code&gt;heap_frag&lt;/code&gt; 또는 &lt;code&gt;binary&lt;/code&gt; 입니다. 할당 자에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6876d9a2709d42d9bf8117946f6bf8730f5ef93a" translate="yes" xml:space="preserve">
          <source>The system information should be stored in a file called &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">시스템 정보는 &lt;code&gt;standard.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b6783eebca0127687dc6f7166b232d99095419a8" translate="yes" xml:space="preserve">
          <source>The system is delivered as a Windows Installer executable. Get it from http://www.erlang.org/download.html</source>
          <target state="translated">시스템은 Windows Installer 실행 파일로 제공됩니다. http://www.erlang.org/download.html에서 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="bd0ed26a1f271e06db89ef0fba3d2b075b59188d" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started. The same &lt;code&gt;BootArgs&lt;/code&gt; are used again.</source>
          <target state="translated">실행중인 Erlang 노드 &lt;strong&gt;내&lt;/strong&gt; 에서 시스템이 다시 시작 되므로 에뮬레이터가 다시 시작되지 않습니다. 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 시스템이 처음 시작된 것과 같은 방식으로 다시 부팅되기 전에 모든 포트가 닫힙니다. 동일한 &lt;code&gt;BootArgs&lt;/code&gt; 가 다시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92a035d0281caa4cfae8d815a43e248cd4f5e42d" translate="yes" xml:space="preserve">
          <source>The system keeps information about which versions are old and permanent in the files &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">시스템은 &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; 및 &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt; 파일에서 이전 버전과 영구 버전에 대한 정보를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="6da0e848ff2fa7a0109efc8207e6e2b2e7ad33b9" translate="yes" xml:space="preserve">
          <source>The system must be configured using only one system configuration file, called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">시스템은 &lt;code&gt;sys.config&lt;/code&gt; 라는 하나의 시스템 구성 파일 만 사용하여 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="534f8510b4ab2486a116f82477cc86a51046615f" translate="yes" xml:space="preserve">
          <source>The system settings page is rather incomplete.</source>
          <target state="translated">시스템 설정 페이지가 다소 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="b9d981657e3a5548cb7241507be1ea948d7f1448" translate="yes" xml:space="preserve">
          <source>The system tracer only receives those trace events that occur locally within the Erlang node. To get the whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system tracer on each involved node must be merged (offline).</source>
          <target state="translated">시스템 추적 프로그램은 Erlang 노드 내에서 로컬로 발생하는 추적 이벤트 만받습니다. 많은 Erlang 노드의 프로세스를 포함하는 순차 추적의 전체 그림을 얻으려면 관련된 각 노드의 시스템 추적 프로그램 출력이 병합 (오프라인)되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d708a25f112a938c386e67dff885572e579436bd" translate="yes" xml:space="preserve">
          <source>The system version of the node from which the dump originates</source>
          <target state="translated">덤프가 시작된 노드의 시스템 버전</target>
        </trans-unit>
        <trans-unit id="bc82ebf34afcabbe0cf21d28525ebd613647d5a2" translate="yes" xml:space="preserve">
          <source>The system window consists of four main pages (tabs):</source>
          <target state="translated">시스템 창은 4 개의 기본 페이지 (탭)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b7bde4446c570b77fe2a6f9c4779d3be956d8d0b" translate="yes" xml:space="preserve">
          <source>The system window is started with the function &lt;code&gt;reltool:start/1&lt;/code&gt;. At startup the tool will process all &lt;code&gt;beam&lt;/code&gt; files and &lt;code&gt;app&lt;/code&gt; files in order to find out dependencies between applications and their modules. Once all this information has been derived, it will be possible to explore the tool.</source>
          <target state="translated">시스템 창은 &lt;code&gt;reltool:start/1&lt;/code&gt; 기능으로 시작됩니다 . 시작시 도구는 응용 프로그램과 해당 모듈 간의 종속성을 찾기 위해 모든 &lt;code&gt;beam&lt;/code&gt; 파일과 &lt;code&gt;app&lt;/code&gt; 파일을 처리 합니다. 이 모든 정보가 도출되면 도구를 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041698f829edd5b26d5d0d6979109c4827078e80" translate="yes" xml:space="preserve">
          <source>The system writes the crash dump in the current directory of the emulator or in the file pointed out by the environment variable (whatever that means on the current operating system) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt;. For a crash dump to be written, a writable file system must be mounted.</source>
          <target state="translated">시스템은 에뮬레이터의 현재 디렉토리 또는 환경 변수가 가리키는 파일 (현재 운영 체제에서 무엇이든) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt; 에 충돌 덤프를 기록합니다 . 크래시 덤프를 쓰려면 쓰기 가능한 파일 시스템을 마운트해야합니다.</target>
        </trans-unit>
        <trans-unit id="279b6ca3b37adc0893d23faefa9739dedcc3dbfa" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;Tab&lt;/code&gt; must have an index on position &lt;code&gt;Pos&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Tab&lt;/code&gt; 에는 &lt;code&gt;Pos&lt;/code&gt; 위치에 대한 색인이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3dc16fbae2468b67b551f7fca9afb369e0f25872" translate="yes" xml:space="preserve">
          <source>The table access rights.</source>
          <target state="translated">테이블 액세스 권한</target>
        </trans-unit>
        <trans-unit id="4c50c3a237a03f8cc2707518e27535b691ad5345" translate="yes" xml:space="preserve">
          <source>The table below summarizes the diameter application's compliance with RFC 6733. Since the diameter application isn't a Diameter node on its own, compliance is strictly the responsibility of the user in many cases, diameter providing the means for the user to be compliant rather than being compliant on its own.</source>
          <target state="translated">아래 표는 직경 응용 프로그램의 RFC 6733 준수 여부를 요약 한 것입니다. 직경 응용 프로그램은 자체적으로 직경 노드가 아니기 때문에 많은 경우 준수는 전적으로 사용자의 책임이며, 직경은 사용자가 아닌 준수하는 수단을 제공합니다. 자체적으로 준수합니다.</target>
        </trans-unit>
        <trans-unit id="25afd1e5876ef9e8eeb6a3459a04948d4b88d14d" translate="yes" xml:space="preserve">
          <source>The table content is placed in a &lt;code&gt;.DCD&lt;/code&gt; file on the disc. When the &lt;code&gt;Mnesia&lt;/code&gt; system is started, the RAM table is initially loaded with data from its &lt;code&gt;.DCD&lt;/code&gt; file.</source>
          <target state="translated">테이블 내용은 디스크 의 &lt;code&gt;.DCD&lt;/code&gt; 파일에 저장됩니다. 때 &lt;code&gt;Mnesia&lt;/code&gt; 의 시스템이 시작되면, RAM 테이블은 초기의 데이터로로드 &lt;code&gt;.DCD&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="1a0aa2d29620215b66b862b74a258da9f0952597" translate="yes" xml:space="preserve">
          <source>The table identifier.</source>
          <target state="translated">테이블 식별자</target>
        </trans-unit>
        <trans-unit id="d6e8f6600b6898b285183c9a2efcd8e9919e547e" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;bag&lt;/code&gt; table, which can have many objects, but only one instance of each object, per key.</source>
          <target state="translated">테이블은 &lt;code&gt;bag&lt;/code&gt; 테이블이며 키당 많은 오브젝트를 가질 수 있지만 각 오브젝트의 인스턴스는 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1326636cb8d9d2c6e8abd48a67ecc64dc60e8dbf" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;duplicate_bag&lt;/code&gt; table, which can have many objects, including multiple copies of the same object, per key.</source>
          <target state="translated">테이블은 &lt;code&gt;duplicate_bag&lt;/code&gt; 테이블이며, 키당 동일한 오브젝트의 여러 사본을 포함하여 많은 오브젝트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f70ade515d71247538e9584965be02630fd1a515" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;ordered_set&lt;/code&gt; table: one key, one object, ordered in Erlang term order, which is the order implied by the &amp;lt; and &amp;gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the &lt;code&gt;ordered_set&lt;/code&gt; tables regard keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt;, not only when they match. This means that to an &lt;code&gt;ordered_set&lt;/code&gt; table, &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; and &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; are regarded as equal. This also means that the key used to lookup an element not necessarily &lt;strong&gt;matches&lt;/strong&gt; the key in the returned elements, if &lt;code&gt;float()&lt;/code&gt;'s and &lt;code&gt;integer()&lt;/code&gt;'s are mixed in keys of a table.</source>
          <target state="translated">이 테이블은 &lt;code&gt;ordered_set&lt;/code&gt; 테이블입니다. 하나의 키, 하나의 객체, Erlang 용어 순서로 정렬되며 &amp;lt;및&amp;gt; 연산자가 암시하는 순서입니다. 이 유형의 테이블은 일부 상황에서 다른 유형의 테이블과는 약간 다른 동작을합니다. 대부분의 특히, &lt;code&gt;ordered_set&lt;/code&gt; 그들이 때 테이블은 같은 것으로 키를 생각 &lt;strong&gt;동등 비교&lt;/strong&gt; 가 일치하지 경우에만. 이는 &lt;code&gt;ordered_set&lt;/code&gt; 테이블에서 &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; 이 동일한 것으로 간주 됨을 의미합니다 . 또한 &lt;code&gt;float()&lt;/code&gt; 및 &lt;code&gt;integer()&lt;/code&gt; 인 경우 요소 를 조회하는 데 사용 된 키가 반환 된 요소의 키 &lt;strong&gt;와&lt;/strong&gt; 반드시 &lt;strong&gt;일치&lt;/strong&gt; 할 필요 &lt;strong&gt;는&lt;/strong&gt; 없습니다.은 테이블의 키에 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="272d7513098b30b16e878b3eb48399c3327cbbea" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;set&lt;/code&gt; table: one key, one object, no order among objects. This is the default table type.</source>
          <target state="translated">테이블은 하나의 키, 하나의 객체, 객체 간 순서가없는 &lt;code&gt;set&lt;/code&gt; 테이블입니다. 이것이 기본 테이블 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b9f8a5943e8075893eb3b3474ba785f08fed2473" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;match/3&lt;/code&gt; 를 호출하기 전에 항상 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블을 보호해야합니다 . 그렇지 않으면 &lt;code&gt;match/1&lt;/code&gt; 을 호출 할 때 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9881ec6398c8615af13073d22ceceab6e1d017fd" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match_object/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match_object/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;match_object/3&lt;/code&gt; 를 호출하기 전에 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블을 항상 보호해야합니다 . 그렇지 않으면 &lt;code&gt;match_object/1&lt;/code&gt; 을 호출 할 때 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2da56b6127d8f8b1f1475a198ead6fa8576cef3" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;select/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;select/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select/3&lt;/code&gt; 를 호출하기 전에 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블을 항상 보호해야합니다 . 그렇지 않으면 &lt;code&gt;select/1&lt;/code&gt; 을 호출 할 때 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a15b4f96977744e9f06d4a053061f2ae406c3cc5" translate="yes" xml:space="preserve">
          <source>The table is read or written in chunks of &lt;code&gt;?CHARS_PER_REC&lt;/code&gt;, overwriting when necessary. The implementation is clearly not efficient, it is just working.</source>
          <target state="translated">테이블은 &lt;code&gt;?CHARS_PER_REC&lt;/code&gt; 청크 단위로 읽거나 쓰며 필요할 때 겹쳐 씁니다. 구현은 분명히 효율적이지 않고 단지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="216abe432d30c693518496ed41d4537b67851e03" translate="yes" xml:space="preserve">
          <source>The table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. Option &lt;code&gt;n_objects&lt;/code&gt; determines the number of objects returned (the third argument of &lt;code&gt;select/3&lt;/code&gt;); the default is to return &lt;code&gt;100&lt;/code&gt; objects at a time. The &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (the second argument of &lt;code&gt;select/3&lt;/code&gt;) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 테이블을 순회합니다 . 옵션 &lt;code&gt;n_objects&lt;/code&gt; 는 리턴 된 오브젝트 수 ( &lt;code&gt;select/3&lt;/code&gt; 의 세 번째 인수 )를 결정합니다. 기본값은 한 번에 &lt;code&gt;100&lt;/code&gt; 개의 객체 를 반환 하는 것입니다. &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (두 번째 인수 &lt;code&gt;select/3&lt;/code&gt; QLC에 의해 조립되는) 더 복잡한 필터에 의해 반환 개체 모두에 적용되어야하는 동안 간단한 필터는 동등한 매치 사양으로 변환되는 &lt;code&gt;select/3&lt;/code&gt; 모든 오브젝트 일치하는 매치 사양 주어진.</target>
        </trans-unit>
        <trans-unit id="3e9b781613899199f74480c8df4e129f831967a1" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블은 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 한 번에 하나의 키를 순회 합니다.</target>
        </trans-unit>
        <trans-unit id="7b596d446b0a8770a2196be90fa1f23b7bdccfe0" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 테이블이 한 번에 하나의 키로 순회 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8716b30387dd883800492663d7d3d90e4516d46" translate="yes" xml:space="preserve">
          <source>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP.</source>
          <target state="translated">이 테이블은 SNMP를 통해 표시되는 동시에 응용 프로그램에서 Mnesia API를 사용하여 일반 Mnesia 테이블로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d172554a6c6306bf28a607a5a2963fa7455c502" translate="yes" xml:space="preserve">
          <source>The table must be created in Mnesia before the manager can use it. The table must be declared as type &lt;code&gt;snmp&lt;/code&gt;. This makes the table ordered in accordance with the lexicographical ordering rules of SNMP. The name of the Mnesia table must be identical to the SNMP table name. The types of the INDEX fields in the corresponding SNMP table must be specified.</source>
          <target state="translated">관리자가 테이블을 사용하려면 테이블을 Mnesia에서 작성해야합니다. 테이블은 &lt;code&gt;snmp&lt;/code&gt; 유형으로 선언되어야합니다 . 그러면 SNMP의 사전 순서 규칙에 따라 테이블이 정렬됩니다. Mnesia 테이블의 이름은 SNMP 테이블 이름과 동일해야합니다. 해당 SNMP 테이블에서 INDEX 필드의 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="75b5a69a501aab4ff4e7aeebea0d27ed7fcb4181" translate="yes" xml:space="preserve">
          <source>The table name, regardless of if it is a &lt;code&gt;named_table&lt;/code&gt; or not.</source>
          <target state="translated">&lt;code&gt;named_table&lt;/code&gt; 인지 여부에 관계없이 테이블 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="905054fe1aefc5725eea1173de784dd765e8936b" translate="yes" xml:space="preserve">
          <source>The table name.</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="aba015ed958a70d6fa81d83ffe73faad038149fe" translate="yes" xml:space="preserve">
          <source>The table property &lt;code&gt;frag_properties&lt;/code&gt; can be read with the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt;. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers &lt;code&gt;Mnesia&lt;/code&gt; to regard the table as fragmented. The fragmentation properties are as follows:</source>
          <target state="translated">테이블 속성 &lt;code&gt;frag_properties&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt; 함수로 읽을 수 있습니다 . 조각화 속성은 arity 2가있는 태그가 지정된 튜플의 목록입니다. 기본적으로 목록은 비어 있지만 비어 있지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 가 테이블을 조각난 것으로 간주합니다. 조각화 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d01afc3037ddbf804c41230f3010100787c86042" translate="yes" xml:space="preserve">
          <source>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function.</source>
          <target state="translated">이 기능으로 덤프 된 경우 디스크 또는 디스크에서 테이블 복제본을 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="015f395b52e0bf9602a397e1f420732c71594a61" translate="yes" xml:space="preserve">
          <source>The table type is not &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">테이블 타입이 아닌 &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e38c104619f1b370bd6dfa294f10929d5f26c0d" translate="yes" xml:space="preserve">
          <source>The table type, that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;dublicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">테이블 유형, 즉 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; , &lt;code&gt;dublicate_bag&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d2206ddd6a97bccbdb41e1737af06cd4da0bcb9" translate="yes" xml:space="preserve">
          <source>The table type.</source>
          <target state="translated">테이블 타입.</target>
        </trans-unit>
        <trans-unit id="d1da328209adecc0d90374bccf49a5ac8565208f" translate="yes" xml:space="preserve">
          <source>The table-related events that can occur are as follows:</source>
          <target state="translated">발생할 수있는 테이블 관련 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b7e8b80ac770e54ad2093b66bc38848a1574359" translate="yes" xml:space="preserve">
          <source>The tables are backed up to external media using backup module &lt;code&gt;BackupMod&lt;/code&gt;. Tables with the local contents property are backed up as they exist on the current node. &lt;code&gt;BackupMod&lt;/code&gt; is the default backup callback module obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;. For information about the exact callback interface (the &lt;code&gt;mnesia_backup behavior&lt;/code&gt;), see the User's Guide.</source>
          <target state="translated">백업 모듈 &lt;code&gt;BackupMod&lt;/code&gt; 를 사용하여 테이블이 외부 미디어에 백업 됩니다 . 로컬 컨텐츠 특성이있는 테이블은 현재 노드에 존재하는대로 백업됩니다. &lt;code&gt;BackupMod&lt;/code&gt; 는 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 얻은 기본 백업 콜백 모듈 입니다. 정확한 콜백 인터페이스 ( &lt;code&gt;mnesia_backup behavior&lt;/code&gt; )에 대한 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf13625217c16a91aadb6ca3932c666df7c246ce" translate="yes" xml:space="preserve">
          <source>The tag for the messages that are sent to the error logger in the Erlang runtime system</source>
          <target state="translated">Erlang 런타임 시스템에서 오류 로거로 전송 된 메시지의 태그</target>
        </trans-unit>
        <trans-unit id="dea673760fa272778aeb2296bada6c28ed936886" translate="yes" xml:space="preserve">
          <source>The tags, their arguments and the contents of each corresponding section are as follows. Each section can occur multiple times unless otherwise specified. The order in which sections are specified is unimportant.</source>
          <target state="translated">해당 섹션의 태그, 인수 및 내용은 다음과 같습니다. 별도로 지정하지 않는 한 각 섹션은 여러 번 발생할 수 있습니다. 섹션이 지정된 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="043e9fad0f693d524a84cb1e4b574f9675842439" translate="yes" xml:space="preserve">
          <source>The tail variables &lt;code&gt;RestDgram&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; bind to binaries, as all tail variables do. Both can bind to empty binaries.</source>
          <target state="translated">테일 변수 &lt;code&gt;RestDgram&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 는 모든 테일 변수와 마찬가지로 이진에 바인딩됩니다. 둘 다 빈 바이너리에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9693ae2473d33274921bc96471864fb339cde4" translate="yes" xml:space="preserve">
          <source>The target data must exist in a configuration file. The connection can be associated with &lt;code&gt;Name&lt;/code&gt; and/or the returned &lt;code&gt;Handle&lt;/code&gt;. To allocate a name for the target, use one of the following alternatives:</source>
          <target state="translated">대상 데이터는 구성 파일에 있어야합니다. 연결은 &lt;code&gt;Name&lt;/code&gt; 및 / 또는 반환 된 &lt;code&gt;Handle&lt;/code&gt; 과 연관 될 수 있습니다 . 대상의 이름을 할당하려면 다음 대안 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bba902f624a3f363faa2c1c1baf548942d9ee3b6" translate="yes" xml:space="preserve">
          <source>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, &quot;\\r\\n&quot; has been removed.</source>
          <target state="translated">FTP 프로토콜 정의 CRLF의 텔넷 끝 문자 (예 : &quot;\\ r \\ n&quot;)가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="85e11e994e429cc2b8651f58111eb62a63c0aeb2" translate="yes" xml:space="preserve">
          <source>The template describes how the formatted string is composed by combining different data values from the log event. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information about this.</source>
          <target state="translated">템플리트는 로그 이벤트와 다른 데이터 값을 결합하여 형식화 된 문자열이 구성되는 방법을 설명합니다. 이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 유형에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb1a8be6676238f92f5d9b5d87374d91e2e26ce8" translate="yes" xml:space="preserve">
          <source>The template is a list of atoms, atom lists, tuples and strings. The atoms &lt;code&gt;level&lt;/code&gt; or &lt;code&gt;msg&lt;/code&gt;, are treated as placeholders for the severity level and the log message, respectively. Other atoms or atom lists are interpreted as placeholders for metadata, where atoms are expected to match top level keys, and atom lists represent paths to sub keys when the metadata is a nested map. For example the list &lt;code&gt;[key1,key2]&lt;/code&gt; is replaced by the value of the &lt;code&gt;key2&lt;/code&gt; field in the nested map below. The atom &lt;code&gt;key1&lt;/code&gt; on its own is replaced by the complete value of the &lt;code&gt;key1&lt;/code&gt; field. The values are converted to strings.</source>
          <target state="translated">템플릿은 원자, 원자 목록, 튜플 및 문자열의 목록입니다. atom &lt;code&gt;level&lt;/code&gt; 또는 &lt;code&gt;msg&lt;/code&gt; 는 각각 심각도 레벨 및 로그 메시지에 대한 플레이스 홀더로 처리됩니다. 다른 원자 또는 원자 목록은 메타 데이터의 자리 표시 자로 해석되며 여기서 원자는 최상위 키와 일치해야하며 원자 목록은 메타 데이터가 중첩 된 맵일 때 하위 키에 대한 경로를 나타냅니다. 예를 들어 &lt;code&gt;[key1,key2]&lt;/code&gt; 목록 은 아래의 중첩 맵에서 &lt;code&gt;key2&lt;/code&gt; 필드 값으로 대체됩니다 . 원자 &lt;code&gt;key1&lt;/code&gt; 자체는의 전체 값으로 대체되는 &lt;code&gt;key1&lt;/code&gt; 필드. 값이 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="96e28f12366708f6b889216805c88be5b281bf16" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;define&lt;/code&gt; introduces a constant that is used to replace the name &lt;code&gt;Constant&lt;/code&gt; with &lt;code&gt;Value&lt;/code&gt;, wherever it is found in the test specification. This replacement occurs during an initial iteration through the test specification. Constants can be used anywhere in the test specification, for example, in any lists and tuples, and even in strings and inside the value part of other constant definitions. A constant can also be part of a node name, but that is the only place where a constant can be part of an atom.</source>
          <target state="translated">&lt;code&gt;define&lt;/code&gt; 이라는 용어 는 테스트 스펙에서 찾을 때마다 이름 &lt;code&gt;Constant&lt;/code&gt; 를 &lt;code&gt;Value&lt;/code&gt; 로 바꾸는 데 사용되는 상수를 소개합니다 . 이 대체는 테스트 사양을 통한 초기 반복 중에 발생합니다. 상수는 테스트 사양, 예를 들어 목록 및 튜플, 문자열 및 기타 상수 정의의 값 부분 내에서 사용할 수 있습니다. 상수는 노드 이름의 일부일 수도 있지만 상수가 원자의 일부일 수있는 유일한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="b33125cbeb164cf4f6a823b4bcb06baf40cb7cda" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;specs&lt;/code&gt; can be used to nest specifications, that is, have one specification include other specifications, which in turn include others, and so no</source>
          <target state="translated">&lt;code&gt;specs&lt;/code&gt; 이라는 용어는 스펙 을 중첩하는 데 사용될 수 있습니다. 즉, 하나의 스펙에 다른 스펙이 포함되며 다른 스펙도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="de1d039344650bb5818e83c555d5196b81ddbd6e" translate="yes" xml:space="preserve">
          <source>The term representing a collection of annotations. It is either a &lt;code&gt;location()&lt;/code&gt; or a list of key-value pairs.</source>
          <target state="translated">주석 모음을 나타내는 용어입니다. 그것은 하나 인 &lt;code&gt;location()&lt;/code&gt; 또는 키 - 값 쌍들의리스트.</target>
        </trans-unit>
        <trans-unit id="206bdfd6f6a1886654062cc692aecc040226c259" translate="yes" xml:space="preserve">
          <source>The terms &lt;code&gt;incl_dirs_r&lt;/code&gt; and &lt;code&gt;excl_dirs_r&lt;/code&gt; tell &lt;code&gt;Common Test&lt;/code&gt; to search the specified directories recursively and include or exclude any module found during the search. The terms &lt;code&gt;incl_dirs&lt;/code&gt; and &lt;code&gt;excl_dirs&lt;/code&gt; result in a non-recursive search for modules (that is, only modules found in the specified directories are included or excluded).</source>
          <target state="translated">&lt;code&gt;incl_dirs_r&lt;/code&gt; 및 &lt;code&gt;excl_dirs_r&lt;/code&gt; 이라는 용어 는 &lt;code&gt;Common Test&lt;/code&gt; 에게 지정된 디렉토리를 재귀 적으로 검색하고 검색 중에 찾은 모듈을 포함하거나 제외하도록 지시합니다. &lt;code&gt;incl_dirs&lt;/code&gt; 및 &lt;code&gt;excl_dirs&lt;/code&gt; 라는 용어는 모듈 을 비재 귀적으로 검색합니다 (즉, 지정된 디렉토리에서 찾은 모듈 만 포함 또는 제외).</target>
        </trans-unit>
        <trans-unit id="9ddcad5286af6cdd21c133d5d7ddb5de84e979bf" translate="yes" xml:space="preserve">
          <source>The test case can also be marked as failed without executing it by returning a tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; from &lt;code&gt;init_per_testcase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init_per_testcase&lt;/code&gt; 에서 튜플 &lt;code&gt;{fail,Reason}&lt;/code&gt; 을 반환하여 테스트 케이스를 실행하지 않고 실패로 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8af161d95302d88592feab6a61159ca646e5862" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="translated">테스트 케이스 함수 인수 &lt;code&gt;Config&lt;/code&gt; 는 구성 파일에서 검색 할 수있는 정보 ( &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt; 사용 ) 와 혼동하지 마십시오 . 테스트 케이스 인수 &lt;code&gt;Config&lt;/code&gt; 는 테스트 스위트 및 테스트 케이스의 런타임 구성에 사용되는 반면, 구성 파일에는 SUT와 관련된 데이터가 포함됩니다. 이 두 가지 유형의 구성 데이터는 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="22d7a935338112ce920c6d20731f07d69ad88ede" translate="yes" xml:space="preserve">
          <source>The test case function takes one argument, &lt;code&gt;Config&lt;/code&gt;, which contains configuration information such as &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt;. (For details about these, see section &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt;. The value of &lt;code&gt;Config&lt;/code&gt; at the time of the call, is the same as the return value from &lt;code&gt;init_per_testcase&lt;/code&gt;, mentioned earlier.</source>
          <target state="translated">테스트 케이스 함수는 &lt;code&gt;data_dir&lt;/code&gt; 및 &lt;code&gt;priv_dir&lt;/code&gt; 과 같은 구성 정보를 포함하는 &lt;code&gt;Config&lt;/code&gt; 인수를 사용 합니다. (자세한 내용은 &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 . 호출시 &lt;code&gt;Config&lt;/code&gt; 값은 앞에서 언급 한 &lt;code&gt;init_per_testcase&lt;/code&gt; 의 반환 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f3d78685ce4bc3a852ca4f95b85dea262a2dbfd5" translate="yes" xml:space="preserve">
          <source>The test case function.</source>
          <target state="translated">테스트 케이스 기능.</target>
        </trans-unit>
        <trans-unit id="772472b0e7495bb1b3ea5fe4354a4abec00b3983" translate="yes" xml:space="preserve">
          <source>The test case group information function, &lt;code&gt;group(GroupName)&lt;/code&gt;, serves the same purpose as the suite- and test case information functions previously described. However, the scope for the group information function, is all test cases and subgroups in the group in question (&lt;code&gt;GroupName&lt;/code&gt;).</source>
          <target state="translated">테스트 케이스 그룹 정보 함수 인 &lt;code&gt;group(GroupName)&lt;/code&gt; 은 앞에서 설명한 스위트 및 테스트 케이스 정보 함수와 동일한 목적으로 사용됩니다. 그러나 그룹 정보 기능의 범위는 해당 그룹의 모든 테스트 케이스 및 하위 그룹 ( &lt;code&gt;GroupName&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0d2f40a449aa01ec3c8d9cd4d1b80e618a045844" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스 그룹 정보 기능. 테스트 케이스 그룹 (즉, 테스트 케이스 및 서브 그룹)의 실행과 관련된 다양한 특성을 지정하는 태그가 지정된 튜플 목록을 리턴해야합니다. &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 로 설정된 특성은 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 에서 이전에 설정 한 것과 동일한 키로 특성을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="7fc2d22e0d7f34017553a5d0de008034c64289ba" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스 정보 기능. 이 특정 테스트 케이스의 실행과 관련된 다양한 속성을 지정하는 태그가 달린 튜플 목록을 반환해야합니다. &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; 에 의해 설정된 특성은 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 에 의해 테스트 케이스에 대해 이전에 설정된 특성보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="c528968b61f60ab84b8bb693468a7bbe033dbb46" translate="yes" xml:space="preserve">
          <source>The test case is implemented as follows:</source>
          <target state="translated">테스트 케이스는 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="561ea1ed4002a2f665fd14f2b18b980f0debbc51" translate="yes" xml:space="preserve">
          <source>The test case is skipped in the following two cases:</source>
          <target state="translated">다음 두 가지 경우에 테스트 사례를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="acb7aee40da2324bbced996f9d61c0d108e566ea" translate="yes" xml:space="preserve">
          <source>The test cases verify, by parsing a log file, that our SUT has performed a successful restart and that no unexpected errors are printed.</source>
          <target state="translated">테스트 사례는 로그 파일을 구문 분석하여 SUT가 성공적으로 다시 시작했으며 예기치 않은 오류가 인쇄되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="efc4c3530fced19d9cbc7b2225463ba3c8ff70fc" translate="yes" xml:space="preserve">
          <source>The test compares the following encoder/decoders:</source>
          <target state="translated">테스트는 다음 인코더 / 디코더를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8c3ccb28e1c0e973d6192fea8f8c8d2cd0b4ea0a" translate="yes" xml:space="preserve">
          <source>The test now fails with &lt;code&gt;{badmatch,24}&lt;/code&gt; because the atom &lt;code&gt;toy_table&lt;/code&gt; does not match the number returned for an unnamed table. So, the problem is found, the table is to be named, and the arguments supplied by the test program do not include &lt;code&gt;named_table&lt;/code&gt;. We rewrite the start function:</source>
          <target state="translated">atom &lt;code&gt;toy_table&lt;/code&gt; 이 이름이없는 테이블에 대해 리턴 된 숫자와 일치하지 않으므로 &lt;code&gt;{badmatch,24}&lt;/code&gt; 로 테스트가 실패 합니다. 따라서 문제점이 발견되고 테이블의 이름이 지정되며 테스트 프로그램에서 제공하는 인수에 &lt;code&gt;named_table&lt;/code&gt; 이 포함되지 않습니다 . 시작 기능을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3bf97f87b41a6f29d2b30317c0ec60daf7647ab1" translate="yes" xml:space="preserve">
          <source>The test program runs 10000 decodes on the value, resulting in an output with the elapsed time in microseconds for the total number of decodes.</source>
          <target state="translated">테스트 프로그램은 값에 대해 10000 디코드를 실행하여 총 디코드 수에 대해 경과 시간이 마이크로 초로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3633648c5d3cca8dc486b6dee36d903c368bcf6f" translate="yes" xml:space="preserve">
          <source>The test specification uses the same mechanism for specifying test case groups through names and paths, as explained in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt;, with the addition of element &lt;code&gt;GroupSpec&lt;/code&gt;.</source>
          <target state="translated">테스트 스펙은 &lt;code&gt;GroupSpec&lt;/code&gt; 요소를 추가하여 &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 이름과 경로를 통해 테스트 케이스 그룹을 지정하는 동일한 메커니즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="784058b40fd83e13e1f3df9bc88ef815cead679e" translate="yes" xml:space="preserve">
          <source>The test specifications used as input to &lt;code&gt;Common Test&lt;/code&gt; Master are fully compatible with the specifications used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The syntax is described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master에 대한 입력으로 사용 된 테스트 사양 은 일반 &lt;code&gt;Common Test&lt;/code&gt; 서버 에 대한 입력으로 사용 된 사양과 완전히 호환됩니다 . 구문은 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 및 테스트 실행 및 결과 분석 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="15500e2662eb6cf2096b1c33acff5c731c7b2d5b" translate="yes" xml:space="preserve">
          <source>The test suite information function. Returns a list of tagged tuples specifying various properties related to the execution of this test suite (common for all test cases in the suite).</source>
          <target state="translated">테스트 스위트 정보 기능. 이 테스트 스위트의 실행과 관련된 다양한 특성을 지정하는 태그가 지정된 튜플 목록을 리턴합니다 (스위트의 모든 테스트 케이스에 공통).</target>
        </trans-unit>
        <trans-unit id="ca4bd482d9cff3e45eb13e9917fb381a5f26152b" translate="yes" xml:space="preserve">
          <source>The test suite module must conform to a &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; specified by the &lt;code&gt;Common Test&lt;/code&gt; test server. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 스위트 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 테스트 서버 에서 지정한 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; 준수해야 합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd0f930877592ca670db8a085bb70953a2a40661" translate="yes" xml:space="preserve">
          <source>The test suites overview page includes a link to the Unexpected I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt;, as well as captured system error- and progress reports, which cannot be associated with particular test cases and therefore cannot be written to individual test case log files. This occurs, for example, if a log printout is made from an external process (not a test case process), &lt;strong&gt;or&lt;/strong&gt; if an error- or progress report comes in, during a short interval while &lt;code&gt;Common Test&lt;/code&gt; is not executing a test case or configuration function, &lt;strong&gt;or&lt;/strong&gt; while &lt;code&gt;Common Test&lt;/code&gt; is currently executing a parallel test case group.</source>
          <target state="translated">테스트 스위트 개요 페이지에는 예기치 않은 I / O 로그에 대한 링크가 포함되어 있습니다. 이 로그에서 &lt;code&gt;Common Test&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 로 작성된 인쇄물 과 캡처 된 시스템 오류 및 진행률 보고서를 저장합니다. 특정 테스트 케이스와 연관 될 수 없으므로 개별 테스트 케이스 로그 파일에 쓸 수 없습니다. 예를 들어, &lt;code&gt;Common Test&lt;/code&gt; 가 테스트 케이스 또는 구성을 실행하지 않는 동안 짧은 간격 동안 외부 프로세스 (테스트 케이스 프로세스가 아님)에서 로그 출력이 이루어 &lt;strong&gt;지거나&lt;/strong&gt; 오류 또는 진행 보고서가 나타나는 경우에 발생합니다. 기능 &lt;strong&gt;또는 &lt;/strong&gt; &lt;code&gt;Common Test&lt;/code&gt; 가 현재 병렬 테스트 케이스 그룹을 실행하는 동안 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8134f6c45a2f73ed264b68d4ba70993d25134c43" translate="yes" xml:space="preserve">
          <source>The tests can be read as documentation, typically showing both examples of correct and incorrect usage, along with the expected consequences.</source>
          <target state="translated">테스트는 문서로 읽을 수 있으며 일반적으로 올바른 결과와 잘못된 사용법의 예 및 예상 결과를 모두 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab59e3293af2eeab2e6a44396959211db748141a" translate="yes" xml:space="preserve">
          <source>The tests will be released into &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt;. After releasing the tests you have to install the tests on the build machine. You supply the same xcomp file as to &lt;code&gt;./otp_build&lt;/code&gt; in (9).</source>
          <target state="translated">테스트는 &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; 됩니다. 테스트를 해제 한 후 빌드 머신에 테스트를 설치해야합니다. (9)의 &lt;code&gt;./otp_build&lt;/code&gt; 와 동일한 xcomp 파일을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6461764795f9a7e6a1ca8fecef822585f15dd414" translate="yes" xml:space="preserve">
          <source>The text encoding config.</source>
          <target state="translated">텍스트 인코딩 구성</target>
        </trans-unit>
        <trans-unit id="0912732fbe8b51c591e00170193eac6690100280" translate="yes" xml:space="preserve">
          <source>The text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt;, which is part of the source code, contains information about all OTP versions from OTP 17.0 up to the current OTP version. Each line contains information about application versions that are part of a specific OTP version, and has the following format:</source>
          <target state="translated">소스 코드의 일부인 텍스트 파일 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt; 에는 OTP 17.0에서 현재 OTP 버전까지의 모든 OTP 버전에 대한 정보가 포함되어 있습니다. 각 줄에는 특정 OTP 버전의 일부인 응용 프로그램 버전에 대한 정보가 포함되며 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f468d3e883b219b9301214ec34fa66d1174c9bd6" translate="yes" xml:space="preserve">
          <source>The text given to a &lt;code&gt;?Q(Text)&lt;/code&gt; macro can be either a single string, or a list of strings. The latter is useful when you need to split a long expression over multiple lines, e.g.:</source>
          <target state="translated">&lt;code&gt;?Q(Text)&lt;/code&gt; 매크로에 제공된 텍스트 는 단일 문자열이거나 문자열 목록 일 수 있습니다. 후자는 여러 줄로 긴 표현식을 분할해야 할 때 유용합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="02aabeed8f889ebc3fe270b684693102faf40262" translate="yes" xml:space="preserve">
          <source>The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</source>
          <target state="translated">하위 표현식과 일치하는 텍스트 (정규 표현식에서 괄호로 표시)가 검색된 결과 목록에 삽입됩니다. 즉, 전체 정규 표현식이 단일 하위 표현식 인 분할 결과를 연결하면 (예 : 마지막 예와 같이) 항상 원래 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="7f15d959ef8fc520df7e2a55f83ecd2a324cb0e0" translate="yes" xml:space="preserve">
          <source>The third argument is &lt;code&gt;Vsn&lt;/code&gt; or &lt;code&gt;{down,Vsn}&lt;/code&gt;, as described for &lt;code&gt;gen_server:code_change/3&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_server:code_change/3&lt;/code&gt; 에 대해 설명한대로 세 번째 인수는 &lt;code&gt;Vsn&lt;/code&gt; 또는 &lt;code&gt;{down,Vsn}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98495365dd14291e5d0887711f1c5c3436964748" translate="yes" xml:space="preserve">
          <source>The third argument is an integer that is used to identify a particular instance of a C node.</source>
          <target state="translated">세 번째 인수는 C 노드의 특정 인스턴스를 식별하는 데 사용되는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b22885d6c6999fdcc81a99f8b75e55f5d786c841" translate="yes" xml:space="preserve">
          <source>The third argument is the full node name.</source>
          <target state="translated">세 번째 인수는 전체 노드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="365807a93bdba62a0a00761a03b6e541034bb449" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;Code&lt;/code&gt;, is a list of digits, which is the correct unlock code that is passed to callback function &lt;code&gt;init/1&lt;/code&gt;.</source>
          <target state="translated">세 번째 인수 인 &lt;code&gt;Code&lt;/code&gt; 는 콜백 함수 &lt;code&gt;init/1&lt;/code&gt; 에 전달되는 올바른 잠금 해제 코드 인 자릿수 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="5b4235e17037973516e425fe018a785d1dc11753" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">세 번째 인수 인 &lt;code&gt;[]&lt;/code&gt; 는 콜백 함수 &lt;code&gt;init&lt;/code&gt; 에 그대로 전달되는 용어입니다 . 여기서 &lt;code&gt;init&lt;/code&gt; 에는 데이터가 필요하지 않으며 인수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2a25200e085552c647a791d385625d025a3908db" translate="yes" xml:space="preserve">
          <source>The third component is a term providing additional information about the cause of the error.</source>
          <target state="translated">세 번째 구성 요소는 오류 원인에 대한 추가 정보를 제공하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="263e38347244b9c29c16011be163dc8c74039614" translate="yes" xml:space="preserve">
          <source>The third element of the &lt;code&gt;update&lt;/code&gt; instruction is a tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;, which says that the affected processes are to do a state transformation before loading the new version of the module. This is done by the processes calling the callback function &lt;code&gt;code_change&lt;/code&gt; (see the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in STDLIB). The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to the function:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령 의 세 번째 요소는 튜플 &lt;code&gt;{advanced,Extra}&lt;/code&gt; 이며, 영향을받는 프로세스는 새 버전의 모듈을로드하기 전에 상태 변환을 수행해야한다고 말합니다. 이는 콜백 함수 &lt;code&gt;code_change&lt;/code&gt; 를 호출하는 프로세스에 의해 수행됩니다 ( &lt;code&gt;gen_server(3)&lt;/code&gt; 의 gen_server (3) 매뉴얼 페이지 참조). 이 경우 &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;Extra&lt;/code&gt; ] 라는 용어 는 함수에 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ab1e993eaa153cf69b806d94010676be4ba79b9d" translate="yes" xml:space="preserve">
          <source>The third instruction, &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;, works as follows:</source>
          <target state="translated">세 번째 명령 인 &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c296204e008ff6b192a1e6549228a85ab543274" translate="yes" xml:space="preserve">
          <source>The third is the maximum value since the emulator was started.</source>
          <target state="translated">세 번째는 에뮬레이터가 시작된 이후의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="53980cbfc9a30778a14bd5b2052c49935bce4336" translate="yes" xml:space="preserve">
          <source>The threads and states are subject to change without any prior notice.</source>
          <target state="translated">스레드 및 상태는 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="110848e2d40c2615a11026b769bd376100abd56b" translate="yes" xml:space="preserve">
          <source>The threads for long running I/O work. See &lt;code&gt;erl +SDio&lt;/code&gt; for more details.</source>
          <target state="translated">장시간 실행되는 I / O 작업을위한 스레드 자세한 내용은 &lt;code&gt;erl +SDio&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86c3f72d097c7761a31ae09180cc6b2d4d48d019" translate="yes" xml:space="preserve">
          <source>The threads for long running cpu intensive work. See &lt;code&gt;erl +SDcpu&lt;/code&gt; for more details.</source>
          <target state="translated">장시간 실행되는 CPU 집약적 작업을위한 스레드입니다. 자세한 내용은 &lt;code&gt;erl +SDcpu&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aece34de50ec637e00271fb64aadf70ca0063d4f" translate="yes" xml:space="preserve">
          <source>The three Erlang (&lt;code&gt;.erl&lt;/code&gt;) files in the messenger example are individually compiled into object code file (&lt;code&gt;.beam&lt;/code&gt;). The Erlang system loads and links these files into the system when they are referred to during execution of the code. In this case, they are simply put in our current working directory (that is, the place you have done &quot;cd&quot; to). There are ways of putting the &lt;code&gt;.beam&lt;/code&gt; files in other directories.</source>
          <target state="translated">메신저 예제에서 3 개의 Erlang ( &lt;code&gt;.erl&lt;/code&gt; ) 파일은 개별적으로 객체 코드 파일 ( &lt;code&gt;.beam&lt;/code&gt; ) 로 컴파일됩니다 . Erlang 시스템은 코드 실행 중에 참조 될 때 이러한 파일을로드하여 시스템에 링크합니다. 이 경우 단순히 현재 작업 디렉토리 (즉, &quot;cd&quot;를 수행 한 위치)에 저장됩니다. &lt;code&gt;.beam&lt;/code&gt; 파일을 다른 디렉토리 에 넣는 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3179e67fe382f9002d115e1d41e6ed750c972cbf" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">해당 알람을 설정하기 전에 할당 할 수있는 시스템 메모리 양에 대한 임계 값 (시스템 메모리 백분율)입니다. 기본값은 0.80 (80 %)입니다.</target>
        </trans-unit>
        <trans-unit id="abb964e16a15aea3574dff337699e7babb0b88a4" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set. The default is 0.05 (5%).</source>
          <target state="translated">해당 알람이 설정되기 전에 하나의 Erlang 프로세스가 할당 할 수있는 시스템 메모리 양에 대한 시스템 메모리 백분율의 임계 값입니다. 기본값은 0.05 (5 %)입니다.</target>
        </trans-unit>
        <trans-unit id="e98007a7e215201117e788dbb3276465ac6d78e0" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of total disk space, for how much disk can be utilized before the &lt;code&gt;disk_almost_full&lt;/code&gt; alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">&lt;code&gt;disk_almost_full&lt;/code&gt; 경보가 설정 되기 전에 얼마나 많은 디스크를 사용할 수 있는지에 대한 전체 디스크 공간의 백분율로 표시되는 임계 값 입니다. 기본값은 0.80 (80 %)입니다.</target>
        </trans-unit>
        <trans-unit id="feab1aae2bdfc2e74927bee2d91bb36426d8246c" translate="yes" xml:space="preserve">
          <source>The time for calculating the length of a list is proportional to the length of the list, as opposed to &lt;code&gt;tuple_size/1&lt;/code&gt;, &lt;code&gt;byte_size/1&lt;/code&gt;, and &lt;code&gt;bit_size/1&lt;/code&gt;, which all execute in constant time.</source>
          <target state="translated">&lt;code&gt;tuple_size/1&lt;/code&gt; , &lt;code&gt;byte_size/1&lt;/code&gt; 및 &lt;code&gt;bit_size/1&lt;/code&gt; 과 달리리스트의 길이를 계산하는 시간은리스트의 길이에 비례 하며 모두 일정한 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd990e3b9e2b09e602b014e1bf744386f4c5083" translate="yes" xml:space="preserve">
          <source>The time for file operations in the linked in driver distributes itself as 1 % for open, 11 % for write and 87 % for close. All data is probably buffered in the operating system until the close.</source>
          <target state="translated">링크 된 드라이버에서 파일 작업 시간은 열기 1 %, 쓰기 11 %, 닫기 87 %로 자체 배포됩니다. 모든 데이터는 운영 체제에서 닫힐 때까지 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="9a190b1ab4466c628fefcec59c8cb2184c9a131f" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. The is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="translated">이 모듈에서 시간 함수 &lt;code&gt;local_time/0&lt;/code&gt; 및 &lt;code&gt;universal_time/0&lt;/code&gt; 은 날짜와 시간을 모두 반환합니다. 날짜와 시간에 대해 별도의 기능을 수행하면 날짜 / 시간 조합이 24 시간 동안 대체 될 수 있기 때문입니다. 함수 중 하나가 자정 전에 호출되고 다른 하나가 자정 후에 호출되는 경우에 발생합니다. 이 문제는 Erlang BIF &lt;code&gt;date/0&lt;/code&gt; 및 &lt;code&gt;time/0&lt;/code&gt; 에도 적용되며 신뢰할 수있는 날짜 / 시간 스탬프가 필요한 경우에는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69208e9c32fc9f7e1bfe894a2034c5bf8bcec375" translate="yes" xml:space="preserve">
          <source>The time in seconds the web server waits between each chunk of data from the script. If the CGI script does not deliver any data before the timeout, the connection to the client is closed. Default is &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">웹 서버가 스크립트의 각 데이터 청크 사이에서 대기하는 시간 (초)입니다. 시간 초과 전에 CGI 스크립트가 데이터를 전달하지 않으면 클라이언트에 대한 연결이 닫힙니다. 기본값은 &lt;code&gt;15&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83fde948bd1a784c99ccd55cd88c7ae69cfaa7fb" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic disk space check. The default is 30 minutes.</source>
          <target state="translated">주기적 디스크 공간 점검을위한 시간 간격 (분)입니다. 기본값은 30 분입니다.</target>
        </trans-unit>
        <trans-unit id="f648e7e2912e2b6d60327d6a0acc64bb170e218b" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic memory check. The default is one minute.</source>
          <target state="translated">주기적 메모리 점검을위한 시간 간격 (분). 기본값은 1 분입니다.</target>
        </trans-unit>
        <trans-unit id="6dc4a14921776a9a6e79ea069562a5ef16a83ecc" translate="yes" xml:space="preserve">
          <source>The time is specified as a fraction, in percent, of a full time-slice that a port is allowed to execute before it is to surrender the CPU to other runnable ports or processes. Valid range is &lt;code&gt;[1, 100]&lt;/code&gt;. The scheduling time-slice is not an exact entity, but can usually be approximated to about 1 millisecond.</source>
          <target state="translated">시간은 CPU를 다른 실행 가능한 포트 나 프로세스에 넘기기 전에 포트가 실행될 수있는 전체 시간 슬라이스의 비율 (%)로 지정됩니다. 유효한 범위는 &lt;code&gt;[1, 100]&lt;/code&gt; 입니다. 스케줄링 타임 슬라이스는 정확한 실체는 아니지만 일반적으로 약 1 밀리 초에 가깝다.</target>
        </trans-unit>
        <trans-unit id="68613cc82c2c14fbfd127a4e01a552399427b53f" translate="yes" xml:space="preserve">
          <source>The time of the least number of consecutive &lt;code&gt;MTTI&lt;/code&gt;s to cover &lt;code&gt;TransitionPeriod&lt;/code&gt; seconds following the call to &lt;code&gt;set_net_ticktime/2&lt;/code&gt; (that is, ((&lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; milliseconds).</source>
          <target state="translated">&lt;code&gt;set_net_ticktime/2&lt;/code&gt; (즉, (( &lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; 밀리 초)를 호출 한 후 &lt;code&gt;TransitionPeriod&lt;/code&gt; 초 를 처리하기 위한 최소 연속 &lt;code&gt;MTTI&lt;/code&gt; 수의 시간입니다 .</target>
        </trans-unit>
        <trans-unit id="6e174adfced39af8e0e284588941d85b0bfefb31" translate="yes" xml:space="preserve">
          <source>The time offset can change at any time without limitations. That is, Erlang system time can perform time warps both forwards and backwards at &lt;strong&gt;any&lt;/strong&gt; time. As we align Erlang system time with OS system time by changing the time offset, we can enable a time correction that tries to adjust the frequency of the Erlang monotonic clock to be as correct as possible. This makes time measurements using Erlang monotonic time more accurate and precise.</source>
          <target state="translated">시간 오프셋은 제한없이 언제든지 변경 될 수 있습니다. 즉, Erlang 시스템 시간은 &lt;strong&gt;언제든지&lt;/strong&gt; 앞뒤로 시간 왜곡을 수행 할 수 있습니다 . 시간 오프셋을 변경하여 Erlang 시스템 시간을 OS 시스템 시간에 맞추면 Erlang 모노 토닉 클록의 주파수를 가능한 한 정확하게 조정하려고하는 시간 수정을 활성화 할 수 있습니다. 따라서 Erlang 단조 시간을 사용하여 시간을보다 정확하고 정확하게 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d5aace605853ec8fe0539020e963801c0f8996" translate="yes" xml:space="preserve">
          <source>The time offset is determined at runtime system start and does not change later. This is the default behavior, but not because it is the best mode (which it is not). It is default &lt;strong&gt;only&lt;/strong&gt; because this is how the runtime system behaved until ERTS 7.0. Ensure that your Erlang code that can execute during a time warp is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; before enabling other modes.</source>
          <target state="translated">시간 오프셋은 런타임 시스템 시작시 결정되며 나중에 변경되지 않습니다. 이것이 기본 동작이지만 최상의 모드 (그렇지 않음)이기 때문이 아닙니다. 그것은 기본입니다 &lt;strong&gt;만&lt;/strong&gt; 이 런타임 시스템이 ERTS 7.0까지 행동하는 방법이기 때문이다. 다른 모드를 활성화하기 전에 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 중에 실행할 수있는 Erlang 코드가 타임 워프에 안전 해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a05290e0120252e64339359ca4738dbe7f2ecf8" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">시간 오프셋이 최종입니다. 때문에 두 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 사용하지 않는 시간 오프셋이 확정 되었기 때문에, 또는 때 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75246e26b9078dfc246576a8981834ffa66ca0f1" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 오프셋은 예비 단계이며 나중에 변경 및 마무리됩니다. 예비 시간 오프셋은 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 의 예비 단계 동안 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a542b4a11973e3e77034a41b121ba9735a608c2b" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">시간 오프셋은 일시적입니다. 즉, 언제든지 변경할 수 있습니다. &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 가 사용 되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="fe4b21df9a3383d5eec3e415625b8f307797fe41" translate="yes" xml:space="preserve">
          <source>The time offset may or may not change during operation depending on the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used.</source>
          <target state="translated">시간 오프셋은 사용 된 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; 에 따라 작동 중에 변경되거나 변경되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5747e4d4272d9517822c11117ba6680478fe811f" translate="yes" xml:space="preserve">
          <source>The time offset, either a string or an integer, to be used when formatting the timestamp.</source>
          <target state="translated">타임 스탬프를 형식화 할 때 사용되는 시간 오프셋 (문자열 또는 정수)입니다.</target>
        </trans-unit>
        <trans-unit id="01e05d873bba0338059375e3eba7a363e13a9238" translate="yes" xml:space="preserve">
          <source>The time to start the Erlang node, in seconds. Defaults to 3 seconds. If the node is not pingable within this time, the result &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">Erlang 노드를 시작하는 시간 (초)입니다. 기본값은 3 초입니다. 이 시간 내에 노드를 ping 할 수 없으면 결과 &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c2b0569acb74ea5c562c3c099098eac517911fa3" translate="yes" xml:space="preserve">
          <source>The time to wait for the node until it calls the internal callback function informing master about a successful startup. Defaults to 1 second. In case of a timed out message, the result &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">마스터가 성공적인 시작을 알리는 내부 콜백 함수를 호출 할 때까지 노드를 기다리는 시간입니다. 기본값은 1 초입니다. 시간 초과 메시지의 경우 결과 &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1ed69df7a8c67ce8c0a0d212b6e1372ea7bd21" translate="yes" xml:space="preserve">
          <source>The time to wait until the node stops to run &lt;code&gt;StartupFunctions&lt;/code&gt;. Defaults to 1 second. If this time-out occurs, the result &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">노드가 &lt;code&gt;StartupFunctions&lt;/code&gt; 실행을 중지 할 때까지 대기하는 시간 입니다. 기본값은 1 초입니다. 이 시간 종료가 발생하면 결과 &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9c4628387e5d0232143d2f5ae73813eebb7d09" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; 및 &lt;code&gt;ctime&lt;/code&gt; 으로 리턴 되는 시간 유형 은 다음과 같이 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 설정된 시간 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="025c3e1a1b5155e5b0e031d4135009cedb0e5183" translate="yes" xml:space="preserve">
          <source>The time type set in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; depends on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">의 시간 형식 설정 &lt;code&gt;atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; 에 , 그리고 &lt;code&gt;ctime&lt;/code&gt; 이는 의 시간 유형 설정에 따라 달라집니다 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="3e4f9d85f1388b8c9748c712e4d020e326e2e9ee" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt;os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="translated">시간 단위는 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 에서 반환 한 것과 동일 합니다. 따라서 밀리 초로 변환하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12219f11b7eb31ef4590154a3caff4c692e2fc9c" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second.</source>
          <target state="translated">의 시간 단위 &lt;code&gt;Time&lt;/code&gt; . 기본값은 &lt;code&gt;second&lt;/code&gt; 입니다. 다른 단위 ( &lt;code&gt;millisecond&lt;/code&gt; , &lt;code&gt;microsecond&lt;/code&gt; 또는 &lt;code&gt;nanosecond&lt;/code&gt; )가 제공되는 경우 형식화 된 문자열에 1 초의 분수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1430c59740c5ce36e77e21d493e646f47e818719" translate="yes" xml:space="preserve">
          <source>The time unit of the return value. The default is &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">반환 값의 시간 단위. 기본값은 &lt;code&gt;second&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6064d2834424e42c0c9064187c8cad80d5a77e73" translate="yes" xml:space="preserve">
          <source>The time warp made when finalizing the time offset can only be done forwards without encountering problems. This implies that the user must ensure that OS system time is set to a time earlier or equal to actual POSIX time before starting the Erlang runtime system.</source>
          <target state="translated">시간 오프셋을 완료 할 때 수행 된 시간 왜곡은 문제없이 진행될 수 있습니다. 이는 사용자가 Erlang 런타임 시스템을 시작하기 전에 OS 시스템 시간이 실제 POSIX 시간보다 빠르거나 같은 시간으로 설정되어 있어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d4fbb252f5f519e910d0858637bda3afb5fe08b3" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS.</source>
          <target state="translated">시간대 및 일광 절약 시간 수정은 기본 OS에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="46decb898c0ad74d50df552bed6180379c34d8f6" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</source>
          <target state="translated">시간대 및 일광 절약 시간 수정은 기본 OS에 따라 다릅니다. 예:</target>
        </trans-unit>
        <trans-unit id="c1ff4d23080563c54d4def9701098918387b1c59" translate="yes" xml:space="preserve">
          <source>The time-out (&lt;code&gt;after 5000&lt;/code&gt;) is started when &lt;code&gt;receive&lt;/code&gt; is entered. The time-out is canceled if &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is received. If &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is not received, the actions following the time-out are done after 5000 milliseconds. &lt;code&gt;after&lt;/code&gt; must be last in the &lt;code&gt;receive&lt;/code&gt;, that is, preceded by all other message reception specifications in the &lt;code&gt;receive&lt;/code&gt;. It is also possible to call a function that returned an integer for the time-out:</source>
          <target state="translated">&lt;code&gt;receive&lt;/code&gt; 이 입력 되면 시간 초과 ( &lt;code&gt;after 5000&lt;/code&gt; )가 시작됩니다 . &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; 가 수신 되면 시간 종료가 취소됩니다 . 경우 &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; 수신되지 않으면, 시간 제한을 다음과 같은 조치는 5000 밀리 초 후에 이루어집니다. &lt;code&gt;after&lt;/code&gt; (가)에 마지막으로해야 &lt;code&gt;receive&lt;/code&gt; (가)에, 즉, 다른 모든 메시지 수신 사양 앞에 &lt;code&gt;receive&lt;/code&gt; . 제한 시간 동안 정수를 리턴 한 함수를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74551537c5a43771b2d27e385232c7f56d26101" translate="yes" xml:space="preserve">
          <source>The time-out is set in:</source>
          <target state="translated">시간 초과는 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b43eb0e0eaef9c040d6d8272e488450d475f41d0" translate="yes" xml:space="preserve">
          <source>The time-out values that can be returned have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">리턴 될 수있는 시간 종료 값은 &lt;code&gt;gen_server&lt;/code&gt; 와 동일한 의미를 갖습니다 . 시간 초과가 발생하면 &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="23098336c20c6b0d05b70cb1a61cba6bfe7c35df" translate="yes" xml:space="preserve">
          <source>The time-outs are applied as follows:</source>
          <target state="translated">시간 초과는 다음과 같이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a92d7be64c5181c10f9b9787e69692d9bd980a7b" translate="yes" xml:space="preserve">
          <source>The time-outs are not exact, but are &lt;strong&gt;at least&lt;/strong&gt; as long as requested.</source>
          <target state="translated">시간 초과는 정확하지 않지만 요청 된 시간 &lt;strong&gt;이상&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5997cb057fe175060411534263631407871803d" translate="yes" xml:space="preserve">
          <source>The timeout time can have the values: &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">시간 종료 시간은 다음 값을 가질 수 있습니다. &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e975fa79f9358d6848c00dddda11ae68d145e5e9" translate="yes" xml:space="preserve">
          <source>The timeout time is in milliseconds. A value of 0 (zero) means that the proxy process will exit directly after the reply has been delivered.</source>
          <target state="translated">시간 종료 시간은 밀리 초입니다. 0 값은 응답이 전달 된 후 프록시 프로세스가 직접 종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6942299da0c7028fdc30f81f96ae8da61dd1bd71" translate="yes" xml:space="preserve">
          <source>The timeout value in a &lt;code&gt;receive..after&lt;/code&gt; expression is evaluated to something else than an integer or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;receive..after&lt;/code&gt; 표현식 의 시간 종료 값 은 integer 또는 &lt;code&gt;infinity&lt;/code&gt; 이외의 것으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="a58b363626052caadeef7377d180027acba06268" translate="yes" xml:space="preserve">
          <source>The timeout values that can be returned by the callback functions have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">콜백 함수가 리턴 할 수있는 시간 종료 값은 &lt;code&gt;gen_server&lt;/code&gt; 와 동일한 의미를 갖습니다 . 시간 초과가 발생하면 &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="746fc091a3bbb9211a083b1f5ae06872c6f4470d" translate="yes" xml:space="preserve">
          <source>The timer associated with &lt;code&gt;Timeout&lt;/code&gt; only supervises IP resolution of &lt;code&gt;Addr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 과 관련된 타이머 는 &lt;code&gt;Addr&lt;/code&gt; 의 IP 해상도 만 감독 합니다.</target>
        </trans-unit>
        <trans-unit id="09b399a5a75126e8cb452f47bf0a1a5174ce3ebb" translate="yes" xml:space="preserve">
          <source>The timer created using &lt;code&gt;dist_util:start_timer/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:start_timer/1&lt;/code&gt; 을 사용하여 만든 타이머입니다 .</target>
        </trans-unit>
        <trans-unit id="4e1cbb1460f78d41a3f7701791a14cffbd170fdb" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine changes states. You can restart a state time-out by setting it to a new time, which cancels the running timer and starts a new. This implies that you can cancel a state time-out by restarting it with time &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">상태 머신이 상태를 변경하면 상태 타임 아웃 타이머가 자동으로 취소됩니다. 상태 시간 초과를 새 시간으로 설정하여 상태 시간 초과를 다시 시작할 수 있습니다. 실행중인 타이머가 취소되고 새 시간이 시작됩니다. 이는 time &lt;code&gt;infinity&lt;/code&gt; 로 재시작하여 상태 시간 초과를 취소 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="64045eba1ed6044b87952089dc11046d257dec70" translate="yes" xml:space="preserve">
          <source>The timer is cancelled when a reply is received.</source>
          <target state="translated">응답이 수신되면 타이머가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="3e5d9243b241f9d1ac98de61c38151d7c0aed4f0" translate="yes" xml:space="preserve">
          <source>The timer is started with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;, so any trace patterns must be set up in advance. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; always sets up all patterns before invoking &lt;code&gt;ttb:p/2&lt;/code&gt;.</source>
          <target state="translated">타이머는 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 로 시작 되므로 추적 패턴을 미리 설정해야합니다. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ttb:p/2&lt;/code&gt; 를 호출하기 전에 항상 모든 패턴을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2045d1e31e58946973b89bfa19e30a90c88aef6e" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in a critical path, and can do other things while waiting for the result of this operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process is blocked until the operation has been performed.</source>
          <target state="translated">타이머를 관리하는 타이머 서비스는 호출 프로세스가 실행중인 스케줄러 이외의 다른 스케줄러와 함께 배치 될 수 있습니다. 그렇다면 타이머 서비스와의 통신이 로컬에있는 것보다 시간이 훨씬 오래 걸립니다. 호출 프로세스가 중요한 경로에 &lt;code&gt;{async, true}&lt;/code&gt; 작업의 결과를 기다리는 동안 다른 작업을 수행 할 수있는 경우 {async, true} 옵션을 사용하려고합니다 . &lt;code&gt;{async, false}&lt;/code&gt; 옵션을 사용하는 경우 작업이 수행 될 때까지 호출 프로세스가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="ea274128cf86d631de77306142f2359eec7a59d8" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in critical path, and can do other things while waiting for the result of this operation, or is not interested in the result of the operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process blocks until the operation has been performed.</source>
          <target state="translated">타이머를 관리하는 타이머 서비스는 호출 프로세스가 실행중인 스케줄러 이외의 다른 스케줄러와 함께 배치 될 수 있습니다. 그렇다면 타이머 서비스와의 통신이 로컬에있는 것보다 시간이 훨씬 오래 걸립니다. 호출 프로세스가 위험 경로에 있고이 조작의 결과를 기다리는 동안 다른 작업을 수행 할 수 있거나 조작 결과에 관심이없는 경우 &lt;code&gt;{async, true}&lt;/code&gt; 옵션을 사용하려고합니다 . &lt;code&gt;{async, false}&lt;/code&gt; 옵션을 사용하는 경우 호출 프로세스는 작업이 수행 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="01c4aedfbe422c954419af25bc2a44ca29efec29" translate="yes" xml:space="preserve">
          <source>The title bar shows the name of the currently loaded crashdump.</source>
          <target state="translated">제목 표시 줄에는 현재로드 된 크래시 덤프의 이름이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7219cf5f8f02500259c90d49cef81093f63f21" translate="yes" xml:space="preserve">
          <source>The token's text.</source>
          <target state="translated">토큰의 텍스트.</target>
        </trans-unit>
        <trans-unit id="6e8012793487b53f45a7c5a13441809363cbd8df" translate="yes" xml:space="preserve">
          <source>The tokenization succeeded.</source>
          <target state="translated">토큰 화에 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="e263b7ae6b2b75806ba8e04c9ad5e6232730c3db" translate="yes" xml:space="preserve">
          <source>The tokenizer &lt;code&gt;Function&lt;/code&gt; is either a fun or a tuple &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt;. The call &lt;code&gt;apply(Function, Args)&lt;/code&gt; or &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; is executed whenever a new token is needed. This, for example, makes it possible to parse from a file, token by token.</source>
          <target state="translated">토크 나이저 &lt;code&gt;Function&lt;/code&gt; 는 재미 있거나 튜플 &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt; 입니다. 새 토큰이 필요할 때마다 &lt;code&gt;apply(Function, Args)&lt;/code&gt; 또는 &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; 호출 이 실행됩니다. 예를 들어, 토큰별로 파일에서 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eecca73e115331e619af23f47c2166b9740b978b" translate="yes" xml:space="preserve">
          <source>The tokenizer used above has to be implemented so as to return one of the following:</source>
          <target state="translated">위에서 사용한 토크 나이 저는 다음 중 하나를 반환하도록 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9fe8d55f2a73cae0cc9b243cca2beb4f78cc27a7" translate="yes" xml:space="preserve">
          <source>The tool contain four things:</source>
          <target state="translated">이 도구에는 다음 네 가지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fdec03acdbb06629e6819b263973cb293a015233" translate="yes" xml:space="preserve">
          <source>The tool is a textual based tool that asks some questions and generates &lt;code&gt;sys.config&lt;/code&gt; and &lt;code&gt;*.conf&lt;/code&gt; files.</source>
          <target state="translated">이 도구는 몇 가지 질문을하고 &lt;code&gt;sys.config&lt;/code&gt; 및 &lt;code&gt;*.conf&lt;/code&gt; 파일을 생성하는 텍스트 기반 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="2cceab8c0f08bcd5eba3c48a52f4f32cc7451571" translate="yes" xml:space="preserve">
          <source>The tool makes it easy to dynamically extend an SNMP agent in run-time. MIBs can be loaded and unloaded at any time. It is also easy to change the implementation of an MIB in run-time, without having to recompile the MIB. The MIB implementation is clearly separated from the agent.</source>
          <target state="translated">이 도구를 사용하면 SNMP 에이전트를 런타임에 동적으로 쉽게 확장 할 수 있습니다. MIB는 언제든지로드 및 언로드 할 수 있습니다. MIB를 다시 컴파일하지 않고도 런타임에서 MIB 구현을 쉽게 변경할 수 있습니다. MIB 구현은 에이전트와 명확하게 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57eb5d97f3d1b93c6dc787ae451b8dff86780d1" translate="yes" xml:space="preserve">
          <source>The tool requires Erlang release 4.7 or later.</source>
          <target state="translated">이 도구에는 Erlang 릴리스 4.7 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4074bd4d79edc126504be2941fab21e73161d7fa" translate="yes" xml:space="preserve">
          <source>The tool uses an installed Erlang/OTP system as input. &lt;code&gt;root_dir&lt;/code&gt; is the root directory of the analysed system and it defaults to the system executing Reltool. Applications may also be located outside &lt;code&gt;root_dir&lt;/code&gt;. &lt;code&gt;lib_dirs&lt;/code&gt; defines library directories where additional applications may reside and it defaults to the directories listed by the operating system environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. See the module &lt;code&gt;code&lt;/code&gt; for more info.</source>
          <target state="translated">이 도구는 설치된 Erlang / OTP 시스템을 입력으로 사용합니다. &lt;code&gt;root_dir&lt;/code&gt; 은 분석 된 시스템의 루트 디렉토리이며 Reltool을 실행하는 시스템이 기본값입니다. 응용 프로그램은 &lt;code&gt;root_dir&lt;/code&gt; 외부에있을 수도 있습니다 . &lt;code&gt;lib_dirs&lt;/code&gt; 는 추가 응용 프로그램이 상주 할 수있는 라이브러리 디렉토리를 정의하며 운영 체제 환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; 로 나열된 디렉토리를 기본값으로 사용합니다 . 자세한 정보는 모듈 &lt;code&gt;code&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed25be45c8a83c834fb6f6c553fb74ad08b92fe" translate="yes" xml:space="preserve">
          <source>The tool(s) are located in the example/meas directory.</source>
          <target state="translated">도구는 example / meas 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="32614a53fcfaa9dead51313db65f2664ea439d19" translate="yes" xml:space="preserve">
          <source>The toolkit allows different kinds of sub-agents at the same time. Accordingly, different MIBs can have different &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt; mechanisms.</source>
          <target state="translated">툴킷은 동시에 여러 종류의 하위 에이전트를 허용합니다. 따라서, 상이한 MIB는 상이한 &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;get&lt;/code&gt; 메커니즘을 가질 수있다 .</target>
        </trans-unit>
        <trans-unit id="13a0a8edd61587bef6f837bb6b651cc3f7feb62a" translate="yes" xml:space="preserve">
          <source>The toolkit provides the following:</source>
          <target state="translated">툴킷은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="faaee45e85eb745fc476496ed2d34dbbfaf2f6f6" translate="yes" xml:space="preserve">
          <source>The toolkit supports the use of different types of sub-agents, but not the construction of sub-agents.</source>
          <target state="translated">툴킷은 다른 유형의 하위 에이전트 사용을 지원하지만 하위 에이전트 구성은 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eca4fd89becaf65e9a29ecebed7de54b42d7b29" translate="yes" xml:space="preserve">
          <source>The tools are further described in &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">도구는 더에 설명되어 있습니다 &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ae2ecc76d77c89a869d00df8f45f0ef79d0325" translate="yes" xml:space="preserve">
          <source>The top directories &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are treated differently from other files. All other files are by default copied to the target system. The &lt;code&gt;releases&lt;/code&gt; directory contains generated &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, and &lt;code&gt;boot&lt;/code&gt; files. The &lt;code&gt;lib&lt;/code&gt; directory contains the applications. Which applications are included and if they should be customized (archived, stripped from debug info etc.) is specified with various configuration parameters. The files in the &lt;code&gt;bin&lt;/code&gt; directory are copied from the &lt;code&gt;erts-vsn/bin&lt;/code&gt; directory, but only those files that were originally included in the &lt;code&gt;bin&lt;/code&gt; directory of the source system.</source>
          <target state="translated">최상위 디렉토리 &lt;code&gt;bin&lt;/code&gt; , &lt;code&gt;releases&lt;/code&gt; 및 &lt;code&gt;lib&lt;/code&gt; 는 다른 파일과 다르게 취급됩니다. 다른 모든 파일은 기본적으로 대상 시스템에 복사됩니다. &lt;code&gt;releases&lt;/code&gt; 디렉토리가 생성 포함 &lt;code&gt;rel&lt;/code&gt; , &lt;code&gt;script&lt;/code&gt; 및 &lt;code&gt;boot&lt;/code&gt; 파일을. &lt;code&gt;lib&lt;/code&gt; 디렉토리는 응용 프로그램이 포함되어 있습니다. 포함 된 응용 프로그램 및 사용자 지정해야하는 경우 (아카이브, 디버그 정보 등에서 제거) 다양한 구성 매개 변수로 지정됩니다. &lt;code&gt;bin&lt;/code&gt; 디렉토리 의 파일 은 &lt;code&gt;erts-vsn/bin&lt;/code&gt; 디렉토리 에서 복사 되지만 원래 &lt;code&gt;bin&lt;/code&gt; 에 포함 된 파일 만 복사됩니다. 소스 시스템의 디렉토리</target>
        </trans-unit>
        <trans-unit id="ccc5aad2efbe05e6d9003238cc37f069c3a6a12a" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SASL application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="translated">최상위 OTP MIB를 &lt;code&gt;OTP-REG&lt;/code&gt; 라고 하며 SASL 응용 프로그램에 포함되어 있습니다. 다른 모든 OTP MIB는이 MIB에서 일부 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="84531a2a9183b1d9855e02a467fa0f45db6199b5" translate="yes" xml:space="preserve">
          <source>The total amount of memory available to the Erlang emulator, allocated and free. May or may not be equal to the amount of memory configured in the system.</source>
          <target state="translated">Erlang 에뮬레이터에서 사용 가능하고 할당 된 총 메모리 양. 시스템에 구성된 메모리 양과 같거나 같지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21349daddbe9f78057ffe41633d03aeff5b4dfff" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for ETS tables. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">현재 ETS 테이블에 할당 된 총 메모리 양입니다. 이 메모리는 &lt;code&gt;system&lt;/code&gt; 메모리 로 제공되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="95625ce6b2bc15c6368f74e2c9f00e33024f644c" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for Erlang code. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">Erlang 코드에 현재 할당 된 총 메모리 양. 이 메모리는 &lt;code&gt;system&lt;/code&gt; 메모리 로 제공되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="92570f02d253003fe52d361898384d0a6cc00fde" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for atoms. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">현재 원자에 할당 된 총 메모리 양입니다. 이 메모리는 &lt;code&gt;system&lt;/code&gt; 메모리 로 제공되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="cc60a6cee6312a43f557d00bfccf3deeac83faed" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for binaries. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">이진에 현재 할당 된 총 메모리 양입니다. 이 메모리는 &lt;code&gt;system&lt;/code&gt; 메모리 로 제공되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="14e4c7529d5fddaff839bbeef6fdabaf59af1c55" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the Erlang processes.</source>
          <target state="translated">Erlang 프로세스에 현재 할당 된 총 메모리 양.</target>
        </trans-unit>
        <trans-unit id="a35fa37b02db12b38c932bf76bd09f88b68c5aa2" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="translated">Erlang 프로세스와 직접 관련되지 않은 에뮬레이터에 현재 할당 된 총 메모리 양입니다. &lt;code&gt;processes&lt;/code&gt; 로 제공된 메모리는 이 메모리에 포함되지 않습니다. &lt;code&gt;instrument(3)&lt;/code&gt; 은이 유형의 일부 메모리가 무엇인지에 대한 자세한 분석을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="215b071b6a42f1da89b3697d1f496f661d6aa206" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated. This is the same as the sum of the memory size for &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">현재 할당 된 총 메모리 양. 이것은 &lt;code&gt;processes&lt;/code&gt; 와 &lt;code&gt;system&lt;/code&gt; 의 메모리 크기의 합과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a938e56ba158faaa85844dc2539f443bb5a124d9" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used by the Erlang processes. This is part of the memory presented as &lt;code&gt;processes&lt;/code&gt; memory.</source>
          <target state="translated">Erlang 프로세스가 현재 사용하는 총 메모리 양. 이것은 &lt;code&gt;processes&lt;/code&gt; 메모리 로 표시되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="cdab624b2930e224876509f0c625e5e845b4ff1f" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used for atoms. This memory is part of the memory presented as &lt;code&gt;atom&lt;/code&gt; memory.</source>
          <target state="translated">현재 원자에 사용 된 총 메모리 양입니다. 이 메모리는 &lt;code&gt;atom&lt;/code&gt; 메모리 로 표시되는 메모리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a4493719e0d656453847edcf986d8ecdd8e5d76e" translate="yes" xml:space="preserve">
          <source>The total memory used by this process. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 프로세스에서 사용 된 총 메모리입니다. 여기에는 호출 스택, 힙 및 내부 구조가 포함됩니다. &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="87ecdfb27347e35b213d203586b4706d6725a207" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated, equivalent to &lt;code&gt;c:memory(total)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c:memory(total)&lt;/code&gt; 와 동일한 할당 된 총 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a4aacb9a69b73478d5cf380558cf1c9d0f0a175d" translate="yes" xml:space="preserve">
          <source>The total number of bytes, including field &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;Size&lt;/code&gt; 를 포함한 총 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="ade9bc9096e43152fdc50c7d93977a724953c2a8" translate="yes" xml:space="preserve">
          <source>The total number of items in all wrap log files.</source>
          <target state="translated">모든 랩 로그 파일의 총 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="e26f652c13c599e84a51a316ff52e72ae6c6a549" translate="yes" xml:space="preserve">
          <source>The total run-time of all threads in the system. This is what you get if you call &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt;</source>
          <target state="translated">시스템에있는 모든 스레드의 총 런타임 &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt; 를 호출하면 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a21c70804496cb28140caf8b69b9295c32be2b1" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</source>
          <target state="translated">가비지 수집을 수행하기 전에 프로세스에서 가상 힙에 허용되는 이진의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d53cdb49b3477b983e3f0debbb9d2b84b083cc6a" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</source>
          <target state="translated">가비지 콜렉션을 수행하기 전에 프로세스에서 가상 이전 힙에 허용 된 2 진의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ebb9f6115c8a24e5086416d9ee44573eb18624a0" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process heap.</source>
          <target state="translated">프로세스 힙에서 참조 된 고유 오프 힙 바이너리의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0b0eb863d44dbd5b8e589949207744e47251159f" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process old heap.</source>
          <target state="translated">프로세스 이전 힙에서 참조 된 고유 오프 힙 바이너리의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="32449a2d53f2b352b6abd6b8f47cee02d2cabee9" translate="yes" xml:space="preserve">
          <source>The total space required is the result calculated from the information above, plus 1 more byte for a version identifier.</source>
          <target state="translated">필요한 총 공간은 위 정보에서 계산 된 결과와 버전 식별자의 경우 1 바이트를 더한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd7a2f2d43f93a16c0153ab5248fa17162eed576" translate="yes" xml:space="preserve">
          <source>The total system memory reported under UNIX is the number of physical pages of memory times the page size, and the available memory is the number of available physical pages times the page size. This is a reasonable measure as swapping should be avoided anyway, but the task of defining total memory and available memory is difficult because of virtual memory and swapping.</source>
          <target state="translated">UNIX에서보고 된 총 시스템 메모리는 실제 페이지 수에 페이지 크기를 곱한 값이고 사용 가능한 메모리는 사용 가능한 실제 페이지 수에 페이지 크기를 곱한 값입니다. 어쨌든 스와핑을 피해야하기 때문에 합리적인 방법이지만 가상 메모리와 스와핑으로 인해 총 메모리와 사용 가능한 메모리를 정의하는 작업이 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="933816d7250e3513ec4007a083bc6d450febc23e" translate="yes" xml:space="preserve">
          <source>The trace &lt;code&gt;Events&lt;/code&gt; that are hosted by the &lt;code&gt;Collector&lt;/code&gt; may be stored to file and later be loaded by selecting &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; entries in the &lt;code&gt;Viewers&lt;/code&gt;&lt;code&gt;File&lt;/code&gt; menu or via the &lt;code&gt;et_collector&lt;/code&gt; API.</source>
          <target state="translated">추적 &lt;code&gt;Events&lt;/code&gt; 에 의해 호스팅되는 &lt;code&gt;Collector&lt;/code&gt; 파일에 저장 될 수 나중에 선택하여로드 할 수 &lt;code&gt;save&lt;/code&gt; 및 &lt;code&gt;load&lt;/code&gt; 항목 &lt;code&gt;Viewers&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 메뉴 나 통해 &lt;code&gt;et_collector&lt;/code&gt; 의 API.</target>
        </trans-unit>
        <trans-unit id="451f68a1cb2620369fda9754c56e9d6942f0eb42" translate="yes" xml:space="preserve">
          <source>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</source>
          <target state="translated">추적 제어 단어는 일반 추적 제어를위한 부호없는 32 비트 정수입니다. 추적 제어 단어는 추적 일치 스펙과 BIF 모두에서 테스트하고 설정할 수 있습니다. 이 호출은 추적 할 때만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3874cc2a63c677a77b05397368808af525c7352" translate="yes" xml:space="preserve">
          <source>The trace message is passed as the second argument (&lt;code&gt;Trace&lt;/code&gt;). The possible values of &lt;code&gt;Trace&lt;/code&gt; are the following:</source>
          <target state="translated">추적 메시지는 두 번째 인수 ( &lt;code&gt;Trace&lt;/code&gt; ) 로 전달됩니다 . 가능한 &lt;code&gt;Trace&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57fe6c1b5e0592fa7721c5593926798fe2d07b25" translate="yes" xml:space="preserve">
          <source>The trace token contains a component called &lt;code&gt;serial&lt;/code&gt;. It consists of two integers, &lt;code&gt;Previous&lt;/code&gt; and &lt;code&gt;Current&lt;/code&gt;. The purpose is to uniquely identify each traced event within a trace sequence, as well as to order the messages chronologically and in the different branches, if any.</source>
          <target state="translated">추적 토큰에는 &lt;code&gt;serial&lt;/code&gt; 이라는 구성 요소가 포함되어 있습니다 . &lt;code&gt;Previous&lt;/code&gt; 와 &lt;code&gt;Current&lt;/code&gt; 의 두 정수로 구성됩니다 . 목적은 추적 순서 내에서 각 추적 된 이벤트를 고유하게 식별하고 메시지를 시간순으로 다른 분기 (있는 경우)로 정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ff16088c10d9e1f1e816f51d73d899ab7bb112e4" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="translated">프로세스의 추적 토큰은 프로세스가 수신 된 메시지가 전달한 추적 토큰에 따라 수신 명령문의 메시지와 일치 할 때마다 비어 있는지 여부에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="252314f7c0c5e289f2fcfda50b4df8414eb39ecb" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the message.</source>
          <target state="translated">그런 다음 &lt;code&gt;tprev&lt;/code&gt; 및 &lt;code&gt;tcurr&lt;/code&gt; 가 있는 추적 토큰 이 메시지와 함께 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="04a1f28d66267b53ccd9a52f89433c7d9b1ac837" translate="yes" xml:space="preserve">
          <source>The tracing process receives the &lt;strong&gt;trace messages&lt;/strong&gt; described in the following list. &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the traced process in which the traced event has occurred. The third tuple element is the message tag.</source>
          <target state="translated">추적 프로세스는 다음 목록에 설명 된 &lt;strong&gt;추적 메시지를&lt;/strong&gt; 수신 합니다. &lt;code&gt;Pid&lt;/code&gt; 는 추적 된 이벤트가 발생한 추적 된 프로세스의 프로세스 식별자입니다. 세 번째 튜플 요소는 메시지 태그입니다.</target>
        </trans-unit>
        <trans-unit id="b59d7a5b365a7b486e7d3f659201ca1fdb7e58e1" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables.</source>
          <target state="translated">트랜잭션 처리기는 트랜잭션에 배치 된 Fun이 테이블에서 일련의 작업을 실행할 때 다른 트랜잭션에 포함 된 작업을 방해하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="70062fd2b1013f2420ee7dc801bcf2c7a5b9ebce" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node.</source>
          <target state="translated">트랜잭션 처리기는 트랜잭션의 모든 작업이 모든 노드에서 원자 적으로 성공적으로 수행되거나 노드에 영구적으로 영향을 미치지 않으면 서 트랜잭션이 실패하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b86538eb6924e406301e4e0cc389da5c07adc8a0" translate="yes" xml:space="preserve">
          <source>The transaction sender is a process (one per connection), which handle all transaction sending, if so configured (see &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">트랜잭션 발신자는 구성되어있는 경우 모든 트랜잭션 전송을 처리하는 프로세스 (연결 당 하나)입니다 ( &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="713f769ddf2bd92a6f2c46e6fb622ca19e8a8704" translate="yes" xml:space="preserve">
          <source>The transformation is done _after_ the actual decode has been done.</source>
          <target state="translated">실제 디코드가 완료된 후 _after_ 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ea5cd69dbba346421c19ed7295d3d9115fee3a0" translate="yes" xml:space="preserve">
          <source>The transformation module</source>
          <target state="translated">변환 모듈</target>
        </trans-unit>
        <trans-unit id="d3b5dbd701325ece1005f2efa209fdb4382b77de" translate="yes" xml:space="preserve">
          <source>The transient mode is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">감시 트리가 종료되면 이유는 &lt;code&gt;normal&lt;/code&gt; 아닌 &lt;code&gt;shutdown&lt;/code&gt; 로 설정되므로 일시적 모드는 거의 사용 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="279a8ee545cd6d6b2240b842b45553a898172100" translate="yes" xml:space="preserve">
          <source>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply is always very straightforward, but the translation from a v2 MIB to a v1 reply is somewhat more complicated. There is one data type in SMIv2, called &lt;code&gt;Counter64&lt;/code&gt;, that an SNMPv1 manager cannot decode correctly. Therefore, an agent may never send a &lt;code&gt;Counter64&lt;/code&gt; object to an SNMPv1 manager. The common practice in these situations is to simple ignore any &lt;code&gt;Counter64&lt;/code&gt; objects, when sending a reply or a trap to an SNMPv1 manager. For example, if an SNMPv1 manager tries to GET an object of type &lt;code&gt;Counter64&lt;/code&gt;, he will get a &lt;code&gt;noSuchName&lt;/code&gt; error, while an SNMPv2 manager would get a correct value.</source>
          <target state="translated">SMIv1 MIB에서 SNMPv2c 또는 SNMPv3 응답으로의 변환은 항상 매우 간단하지만 v2 MIB에서 v1 응답으로의 변환은 다소 복잡합니다. &lt;code&gt;Counter64&lt;/code&gt; 관리자가 올바르게 디코딩 할 수없는 Counter64 라는 SMIv2의 데이터 유형이 하나 있습니다. 따라서 에이전트는 &lt;code&gt;Counter64&lt;/code&gt; 관리자 에게 Counter64 개체를 보낼 수 없습니다 . 이러한 상황에서 일반적인 관행은 응답 또는 트랩을 SNMPv1 관리자에게 보낼 때 &lt;code&gt;Counter64&lt;/code&gt; 개체 를 간단히 무시하는 것 입니다. 예를 들어 SNMPv1 관리자가 &lt;code&gt;Counter64&lt;/code&gt; 유형의 개체를 가져 &lt;code&gt;noSuchName&lt;/code&gt; 하면 noSuchName 오류가 발생하지만 SNMPv2 관리자는 올바른 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d1002669f8eb3c39bdb5b7b84f078a3d57742186" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">funs에서 사양을 맞추기위한 변환은 두 개의 &quot;의사 함수&quot; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 을 통해 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="44fa72e8417ca847548609a0551ee3e367444c94" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions.</source>
          <target state="translated">fun에서 사양에 맞게 변환하는 것은 컴파일 타임에 수행되므로 이러한 의사 함수를 사용하면 런타임 성능에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cc78b834cad87c9de51c585d4cf589e52c474cd" translate="yes" xml:space="preserve">
          <source>The transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; allows the user to implement their own methods. Ready support is provided for TCP, TCP/TLS, and SCTP, but not DTLS/SCTP.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 문서화 된 전송 인터페이스를 통해 사용자는 자신의 메소드를 구현할 수 있습니다. TCP, TCP / TLS 및 SCTP는 지원되지만 DTLS / SCTP는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e689615a4328c7bb2be0d06728d745d0225ff3fd" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and only the superuser can read such addresses.</source>
          <target state="translated">하드웨어 주소는 역사적으로 링크 계층에 속하고 수퍼 유저 만 해당 주소를 읽을 수 있으므로 튜플 &lt;code&gt;{hwaddr,_}&lt;/code&gt; 은 Solaris에서 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="734c3a9accbed59c68b041ca30504d986c5e8330" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt; in &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">튜플 &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; 은 &lt;code&gt;nodedown&lt;/code&gt; 메시지의 &lt;code&gt;InfoList&lt;/code&gt; 에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f43f11b1eaa009f61e78aef8e72ca0bfe4ae132" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</source>
          <target state="translated">튜플 &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c413d0bf6ec66eace53dd4e7a39e8c1f75c0b563" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</source>
          <target state="translated">튜플 &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93c35c8a52aab9fd8efd803c8922b473482b1bda" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">튜플 형식은 이전 버전과의 호환성을 위해서만 유지됩니다. 지도가 선호됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2050463a23b37d880e27e3e31bb499a655c1dd4d" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">튜플 형식은 이전 버전과의 호환성을 위해서만 유지됩니다. 지도가 선호됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c70d1de1443033613ebef26319653a179cc6b15" translate="yes" xml:space="preserve">
          <source>The tuple returned from one &lt;code&gt;setelement/3&lt;/code&gt; call must only be used in the subsequent call to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">하나에서 반환 된 튜플 &lt;code&gt;setelement/3&lt;/code&gt; 호출 만에 후속 호출에 사용되어야 &lt;code&gt;setelement/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4ff128add1588c52d8394da93cf96f601027206" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,_}&lt;/code&gt;, and &lt;code&gt;{broadaddr,_}&lt;/code&gt; are repeated in the result list if the interface has multiple addresses. If you come across an interface with multiple &lt;code&gt;{flag,_}&lt;/code&gt; or &lt;code&gt;{hwaddr,_}&lt;/code&gt; tuples, you have a strange interface or possibly a bug in this function. The tuple &lt;code&gt;{flag,_}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="translated">인터페이스에 여러 주소가있는 경우 튜플 &lt;code&gt;{addr,Addr}&lt;/code&gt; , &lt;code&gt;{netmask,_}&lt;/code&gt; 및 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 이 결과 목록에서 반복됩니다. 여러 개의 &lt;code&gt;{flag,_}&lt;/code&gt; 또는 &lt;code&gt;{hwaddr,_}&lt;/code&gt; 튜플이있는 인터페이스를 만나면 이상한 인터페이스가 있거나이 함수에 버그가있을 수 있습니다. 튜플 &lt;code&gt;{flag,_}&lt;/code&gt; 은 필수이며 나머지는 모두 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c792192eae5af5df8655eee98e78f1050f5569af" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="translated">두 개의 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 는 가능한 모든 이벤트와 상태 조합을 처리하는 하나의 공통 목표와 함께 다양한 가능성과 제한을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0298b22c480eceedcea59bf7361f3f9da67e49ce" translate="yes" xml:space="preserve">
          <source>The two flag values can be combined with bitwise OR. The resource type name is local to the calling module. Argument &lt;code&gt;module_str&lt;/code&gt; is not (yet) used and must be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;dtor&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if no destructor is needed.</source>
          <target state="translated">두 플래그 값은 비트 단위 OR과 결합 될 수 있습니다. 자원 유형 이름은 호출 모듈에 로컬입니다. 인수 &lt;code&gt;module_str&lt;/code&gt; 은 (아직) 사용되지 않으며 &lt;code&gt;NULL&lt;/code&gt; 이어야 합니다 . 소멸자가 필요없는 경우 &lt;code&gt;dtor&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d12cd5775794850530c69243a0b35a79255f52a0" translate="yes" xml:space="preserve">
          <source>The two following &lt;code&gt;setelement/3&lt;/code&gt; calls modify the tuple in place.</source>
          <target state="translated">다음 두 &lt;code&gt;setelement/3&lt;/code&gt; 호출은 튜플을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="65274f8639b74e1c1addc358f6c4f02af0256408" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;until_newline/3&lt;/code&gt; and &lt;code&gt;until_enough/3&lt;/code&gt; are helpers used together with function &lt;code&gt;get_until/5&lt;/code&gt; to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; (inefficiently):</source>
          <target state="translated">&lt;code&gt;until_newline/3&lt;/code&gt; 및 &lt;code&gt;until_enough/3&lt;/code&gt; 의 두 함수 는 &lt;code&gt;get_chars&lt;/code&gt; 및 &lt;code&gt;get_line&lt;/code&gt; 을 효율적 으로 구현하기 위해 &lt;code&gt;get_until/5&lt;/code&gt; 함수와 함께 사용되는 헬퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="66b4872540376e34796f1ec9e420e0053c6366ad" translate="yes" xml:space="preserve">
          <source>The two functions for reloading drivers are to be used together with corresponding load functions to support the two different behaviors concerning open ports:</source>
          <target state="translated">드라이버를 다시로드하기위한 두 가지 기능은 해당로드 기능과 함께 사용되어 열린 포트와 관련된 두 가지 동작을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c0c4d47161e2b26102273194fa251a585e05de6" translate="yes" xml:space="preserve">
          <source>The two index search functions described here are automatically started when searching tables with &lt;code&gt;qlc&lt;/code&gt; list comprehensions and also when using the low-level &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; functions.</source>
          <target state="translated">여기에 설명 된 두 개의 인덱스 검색 기능은 &lt;code&gt;qlc&lt;/code&gt; 목록 이해가있는 테이블을 검색 할 때와 낮은 수준의 &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; 사용할 때 자동으로 시작됩니다 : [dirty_] match_object 함수.</target>
        </trans-unit>
        <trans-unit id="246d94548a4e439a2a10c8f1eb4458a0f48f069d" translate="yes" xml:space="preserve">
          <source>The two main interfaces for running tests with &lt;code&gt;Common Test&lt;/code&gt; are an executable program named &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; and the Erlang module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_run&lt;/code&gt; is compiled for the underlying operating system (for example, Unix/Linux or Windows) during the build of the Erlang/OTP system, and is installed automatically with other executable programs in the top level &lt;code&gt;bin&lt;/code&gt; directory of Erlang/OTP. The &lt;code&gt;ct&lt;/code&gt; interface functions can be called from the Erlang shell, or from any Erlang function, on any supported platform.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 로 테스트를 실행하기위한 두 가지 주요 인터페이스는 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 이라는 실행 프로그램 과 Erlang 모듈 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;ct_run&lt;/code&gt; 은 Erlang / OTP 시스템을 빌드하는 동안 기본 운영 체제 (예 : Unix / Linux 또는 Windows) 용으로 컴파일되며 Erlang / OTP의 최상위 &lt;code&gt;bin&lt;/code&gt; 디렉토리 에있는 다른 실행 프로그램과 함께 자동으로 설치됩니다 . &lt;code&gt;ct&lt;/code&gt; 인터페이스 기능은 얼랑 쉘에서 호출, 또는 얼랑 기능에서 지원되는 모든 플랫폼에서 할 수있다.</target>
        </trans-unit>
        <trans-unit id="1eed66d650bf2a2472423671355f16a5f1ae975a" translate="yes" xml:space="preserve">
          <source>The two major components of the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; tool is a graphical sequence chart viewer (&lt;code&gt;et_viewer&lt;/code&gt;) and its backing storage (&lt;code&gt;et_collector&lt;/code&gt;). One &lt;code&gt;Collector&lt;/code&gt; may be used as backing storage for several simultaneous &lt;code&gt;Viewers&lt;/code&gt; where each one may display a different view of the same trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 도구 의 두 가지 주요 구성 요소 는 그래픽 시퀀스 차트 뷰어 ( &lt;code&gt;et_viewer&lt;/code&gt; ) 및 해당 백업 저장소 ( &lt;code&gt;et_collector&lt;/code&gt; )입니다. 하나의 &lt;code&gt;Collector&lt;/code&gt; 는 여러 동시 &lt;code&gt;Viewers&lt;/code&gt; 백업 저장소로 사용될 수 있으며 각 뷰어 는 동일한 추적 데이터의 다른보기를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b98c5ee144a7e629e6a186d5b34f7dc5bb41d7" translate="yes" xml:space="preserve">
          <source>The two occurrences of &lt;code&gt;N&lt;/code&gt; are not related. The compiler will complain that the &lt;code&gt;N&lt;/code&gt; in the size field is unbound.</source>
          <target state="translated">두 번의 &lt;code&gt;N&lt;/code&gt; 발생은 관련이 없습니다. 컴파일러는 크기 필드 의 &lt;code&gt;N&lt;/code&gt; 이 바인딩되지 않았다고 불평합니다 .</target>
        </trans-unit>
        <trans-unit id="8c1e49fb3411cc8e5831e0be0f58277a39603aae" translate="yes" xml:space="preserve">
          <source>The two parts of the &lt;code&gt;convert&lt;/code&gt; function are called its clauses. As shown, &lt;code&gt;miles&lt;/code&gt; is not part of either of the clauses. The Erlang system cannot &lt;strong&gt;match&lt;/strong&gt; either of the clauses so an error message &lt;code&gt;function_clause&lt;/code&gt; is returned. The shell formats the error message nicely, but the error tuple is saved in the shell's history list and can be output by the shell command &lt;code&gt;v/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 함수 의 두 부분을 절이라고합니다. 표시된 것처럼 &lt;code&gt;miles&lt;/code&gt; 은 두 조항 중 일부가 아닙니다. Erlang 시스템은 어느 한 절 &lt;strong&gt;과도 일치&lt;/strong&gt; 할 수 없으므로 오류 메시지 &lt;code&gt;function_clause&lt;/code&gt; 가 리턴됩니다. 쉘은 오류 메시지를 멋지게 형식화하지만 오류 튜플은 쉘의 히스토리 목록에 저장되며 쉘 명령 &lt;code&gt;v/1&lt;/code&gt; 에 의해 출력 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef209651a9fdf27bee622b273ceb5f16c1a1ba01" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;BIT STRING&lt;/code&gt; can be used to model information that is made up of arbitrary length series of bits. It is intended to be used for selection of flags, not for binary files.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 유형 은 임의의 길이의 일련의 비트로 구성된 정보를 모델링하는 데 사용할 수 있습니다. 바이너리 파일이 아닌 플래그 선택에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae16e6086ff80fdbd8c4ef671e6092d385270bd3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;CHOICE&lt;/code&gt; is a space saver and is similar to the concept of a 'union' in C.</source>
          <target state="translated">&lt;code&gt;CHOICE&lt;/code&gt; 유형 은 공간 절약형이며 C의 '연합'개념과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="965f2c85137cbf54f06adf43202eea3af0164d29" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;ENUMERATED&lt;/code&gt; can be used when the value you want to describe can only take one of a set of predefined values. Example:</source>
          <target state="translated">설명하려는 값이 사전 정의 된 값 세트 중 하나만 사용할 수있는 경우 &lt;code&gt;ENUMERATED&lt;/code&gt; 유형을 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c0ca634710fd8cc8e3767efb8dc71dc3f784baaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;EXTERNAL&lt;/code&gt; had a slightly different associated type before 1994. X.691 states that encoding must follow the older associated type. So, generated encode/decode functions convert values of the newer format to the older format before encoding. This implies that it is allowed to use &lt;code&gt;EXTERNAL&lt;/code&gt; type values of either format for encoding. Decoded values are always returned in the newer format.</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; 유형 은 1994 년 이전에 연관된 유형이 약간 다릅니다. X.691은 인코딩이 이전의 연관된 유형을 따라야한다고 명시합니다. 따라서 생성 된 인코딩 / 디코딩 함수는 인코딩 전에 최신 형식의 값을 이전 형식으로 변환합니다. 이는 인코딩에 두 형식의 &lt;code&gt;EXTERNAL&lt;/code&gt; 유형 값 을 사용할 수 있음을 의미합니다 . 디코딩 된 값은 항상 최신 형식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b96d9ad7628789a455a00e354d8f85bc83f8dcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;MACRO&lt;/code&gt; is not supported. It is no longer part of the ASN.1 standard.</source>
          <target state="translated">&lt;code&gt;MACRO&lt;/code&gt; 유형 이 지원되지 않습니다. 더 이상 ASN.1 표준의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="aa57b7a761159ee02439dd9f7a7248614deec258" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;NULL&lt;/code&gt; is suitable where supply and recognition of a value is important but the actual value is not.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 유형 은 값의 공급 및 인식이 중요하지만 실제 값이 아닌 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8f171db85c218b70d6addcc8e6fc151a7cbbadd9" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is used whenever a unique identity is required. An ASN.1 module, a transfer syntax, and so on, is identified with an &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. Assume the following example:</source>
          <target state="translated">&lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 유형 은 고유 한 ID가 필요할 때마다 사용됩니다. ASN.1 모듈, 전송 구문 등은 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 로 식별 됩니다. 다음 예제를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9360300fbf341e9ae2dadc1fc262f79e78fb2fc1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TimeOut&lt;/code&gt; has the default value &lt;code&gt;infinity&lt;/code&gt;, so for instance:</source>
          <target state="translated">&lt;code&gt;TimeOut&lt;/code&gt; 유형 의 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25b9026ac150bd3535441298ee5fe811ce22b776" translate="yes" xml:space="preserve">
          <source>The type a port has when it is opened, but not bound to any file descriptor.</source>
          <target state="translated">포트가 열렸을 때 파일 형식에 바인딩되지 않은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="92d522e36d256191ae801d58140abe1b10a81a7f" translate="yes" xml:space="preserve">
          <source>The type checking in the SEQUENCE construct is non-strict (i.e. subtypes may be specified). The reason for this is that some standard MIBs use this.</source>
          <target state="translated">SEQUENCE 구문의 유형 검사는 엄격하지 않습니다 (즉, 하위 유형을 지정할 수 있음). 그 이유는 일부 표준 MIB가이를 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1be2df477daeda02d0883ed07f5157d20b6857d8" translate="yes" xml:space="preserve">
          <source>The type definition for a child specification is as follows:</source>
          <target state="translated">하위 스펙의 유형 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a191726a17db26ad276e59c3d2dbd9a5d58a79fa" translate="yes" xml:space="preserve">
          <source>The type definition of a child specification is as follows:</source>
          <target state="translated">하위 스펙의 유형 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6def97965eb0171fce707fed1d80f680f68afe44" translate="yes" xml:space="preserve">
          <source>The type name is the atom &lt;code&gt;my_struct_type&lt;/code&gt;, followed by parentheses. &lt;code&gt;Type&lt;/code&gt; is a type as defined in the previous section. A current restriction is that &lt;code&gt;Type&lt;/code&gt; can contain only predefined types, or user-defined types which are either of the following:</source>
          <target state="translated">유형 이름은 원자 &lt;code&gt;my_struct_type&lt;/code&gt; 이며 괄호가 뒤에옵니다. &lt;code&gt;Type&lt;/code&gt; 은 이전 섹션에서 정의 된 유형 입니다. 현재 제한 사항은 &lt;code&gt;Type&lt;/code&gt; 에는 다음 중 하나 인 미리 정의 된 형식 또는 사용자 정의 형식 만 포함 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="309c924e1cd088d894f3ed5124531ce4037037e9" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 의 유형은 &lt;code&gt;Item&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="55a401f10752570792b382f21d74eedbc9c46cc7" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">유형 &lt;code&gt;Val&lt;/code&gt; 의 값에 따라 &lt;code&gt;Tag&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; 더 많은 정보를 원하시면.</target>
        </trans-unit>
        <trans-unit id="88149033eb0717d0b52143637014a89740d11a73" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">유형 &lt;code&gt;Val&lt;/code&gt; 의 값에 따라 &lt;code&gt;Tag&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; 더 많은 정보를 원하시면.</target>
        </trans-unit>
        <trans-unit id="5e5d162e866719ba45f57bb291d7dab0d1fc5d64" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">유형 &lt;code&gt;Val&lt;/code&gt; 의 값에 따라 &lt;code&gt;Tag&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; 더 많은 정보를 원하시면.</target>
        </trans-unit>
        <trans-unit id="329ae914482ca32cea66526a39a0dbcd107a797e" translate="yes" xml:space="preserve">
          <source>The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are &lt;code&gt;undefined&lt;/code&gt; and the Diameter types: &lt;code&gt;OctetString&lt;/code&gt;, &lt;code&gt;Integer32&lt;/code&gt;, &lt;code&gt;Integer64&lt;/code&gt;, &lt;code&gt;Unsigned32&lt;/code&gt;, &lt;code&gt;Unsigned64&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, &lt;code&gt;Float64&lt;/code&gt;, &lt;code&gt;Grouped&lt;/code&gt;, &lt;code&gt;Enumerated&lt;/code&gt;, &lt;code&gt;Address&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;UTF8String&lt;/code&gt;, &lt;code&gt;DiameterIdentity&lt;/code&gt;, &lt;code&gt;DiameterURI&lt;/code&gt;, &lt;code&gt;IPFilterRule&lt;/code&gt; and &lt;code&gt;QoSFilterRule&lt;/code&gt;.</source>
          <target state="translated">해당 사전 파일에 지정된 AVP의 유형 (또는 상속 된 파일) 가능한 유형이있다 &lt;code&gt;undefined&lt;/code&gt; 및 직경 유형 : &lt;code&gt;OctetString&lt;/code&gt; , &lt;code&gt;Integer32&lt;/code&gt; , &lt;code&gt;Integer64&lt;/code&gt; , &lt;code&gt;Unsigned32&lt;/code&gt; , &lt;code&gt;Unsigned64&lt;/code&gt; , &lt;code&gt;Float32&lt;/code&gt; , &lt;code&gt;Float64&lt;/code&gt; , &lt;code&gt;Grouped&lt;/code&gt; , &lt;code&gt;Enumerated&lt;/code&gt; , &lt;code&gt;Address&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;UTF8String&lt;/code&gt; 에 , &lt;code&gt;DiameterIdentity&lt;/code&gt; , &lt;code&gt;DiameterURI&lt;/code&gt; , &lt;code&gt;IPFilterRule&lt;/code&gt; 및 &lt;code&gt;QoSFilterRule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">파일의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4a0aaded2e1891fac9206e8409a5f01261f2d116" translate="yes" xml:space="preserve">
          <source>The type tag of a syntax tree node may also be used as a primary tag by the &lt;code&gt;erl_parse&lt;/code&gt; representation; in that case, the selector functions for that node type &lt;strong&gt;must&lt;/strong&gt; handle both the abstract syntax tree and the &lt;code&gt;erl_parse&lt;/code&gt; form. The function &lt;code&gt;type(T)&lt;/code&gt; should return the correct type tag regardless of the representation of &lt;code&gt;T&lt;/code&gt;, so that the user sees no difference between &lt;code&gt;erl_syntax&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt; nodes.</source>
          <target state="translated">구문 트리 노드의 타입 태그는 또한 &lt;code&gt;erl_parse&lt;/code&gt; 표현에 의해 1 차 태그로서 사용될 수있다 ; 이 경우 해당 노드 유형에 대한 선택기 함수 는 추상 구문 트리와 &lt;code&gt;erl_parse&lt;/code&gt; 형식을 모두 처리 &lt;strong&gt;해야합니다&lt;/strong&gt; . 사용자는 &lt;code&gt;erl_syntax&lt;/code&gt; 와 &lt;code&gt;erl_parse&lt;/code&gt; 노드 사이에 차이가 없도록 &lt;code&gt;T&lt;/code&gt; 의 표시에 관계없이 함수 &lt;code&gt;type(T)&lt;/code&gt; 은 올바른 유형 태그를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3202d206f4f93d7d4689f53e891b3fc4e897bc" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt; have been removed from the standard since 1994. It is recommended not to use these types any more. They can, however, exist in some old ASN.1 modules. The idea with this type was to leave a &quot;hole&quot; in a definition where it was possible to put unspecified data of any kind, even non-ASN.1 data.</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; 및 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 유형 은 1994 년 이후 표준에서 제거되었습니다.이 유형을 더 이상 사용하지 않는 것이 좋습니다. 그러나 일부 오래된 ASN.1 모듈에는 존재할 수 있습니다. 이 유형의 아이디어는 정의되지 않은 데이터, 심지어 비 ASN.1 데이터를 넣을 수있는 정의에 &quot;구멍&quot;을 남기는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="7d97ad7fc3d758f8f7503253b112a82e8b959c1f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;EXTERNAL&lt;/code&gt;, &lt;code&gt;EMBEDDED PDV&lt;/code&gt;, and &lt;code&gt;CHARACTER STRING&lt;/code&gt; are used in presentation layer negotiation. They are encoded according to their associated type, see X.680.</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; , &lt;code&gt;EMBEDDED PDV&lt;/code&gt; 및 &lt;code&gt;CHARACTER STRING&lt;/code&gt; 유형 은 프리젠 테이션 계층 협상에 사용됩니다. 관련 형식에 따라 인코딩됩니다 (X.680 참조).</target>
        </trans-unit>
        <trans-unit id="31206f08c9e0b285f83486faa623acb15de23275" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt; correspond to the concept of an array in several programming languages. The Erlang syntax for both types is straightforward, for example:</source>
          <target state="translated">&lt;code&gt;SET OF&lt;/code&gt; 및 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 유형 은 여러 프로그래밍 언어의 배열 개념에 해당합니다. 두 유형의 Erlang 구문은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b29412cfed4840e6735cd1786ded80d86e51e8fe" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; specifies encoding/decoding of the &lt;strong&gt;Unicode Transformation Format&lt;/strong&gt;s UTF-8, UTF-16, and UTF-32, respectively.</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형 은 각각 &lt;strong&gt;유니 코드 변환 형식&lt;/strong&gt; UTF-8, UTF-16 및 UTF-32의 인코딩 / 디코딩을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="397ab02499d0458aff045535e75d83bc31f4cbeb" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="translated">유형은 세트가 충족해야하는 다양한 조건을 구현하는 데 사용됩니다. 예를 들어, 두 세트 R과 S의 상대 곱을 고려하고 R이 Y에 대한 이진 관계이고 S가 Y의 이진 관계인 경우 R과 S의 상대 곱이 정의되어 있음을 상기하십시오. 제품, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt; 는 인수가 첫 번째 인수의 유형 (Arg1 say)과 [{C, D}]를 두 번째 인수의 유형 (Arg2 say)과 일치시켜 인수가 이진 관계를 나타내는 지 확인합니다. [{A, B}]가 Arg1의 유형과 일치한다는 사실은 X에서 Y 로의 이진 관계를 나타내는 Arg1로 해석됩니다. 여기서 X는 일부 요소 x에 대한 모든 세트로 Set (x)로 정의됩니다. Arg2는 W에서 Z 로의 이진 관계를 나타내는 것으로 해석됩니다. 마지막으로 B가 C와 일치하는지 확인하여 W가 Y와 같은지 확인하기에 충분합니다. 집합은 별도로 처리됩니다. 형식 [ '_']은 정렬되지 않은 집합의 형식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="92a2f2f4039eb9cab39f41c392f86d30d282c1cf" translate="yes" xml:space="preserve">
          <source>The types of errors that may occur can be divide into the following categories.</source>
          <target state="translated">발생할 수있는 오류 유형은 다음 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc80a70996f3fb5f7ac83b02a6f6f55b6b8c98c" translate="yes" xml:space="preserve">
          <source>The types of record fields can be specified in the declaration of the record. The syntax for this is as follows:</source>
          <target state="translated">레코드 필드의 유형은 레코드 선언에서 지정할 수 있습니다. 이에 대한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015a6a68261fd2baee3f181670e406ef25582853" translate="yes" xml:space="preserve">
          <source>The typical round-trip of a message can be viewed as follows. Firstly we view the call flow on the originating side:</source>
          <target state="translated">메시지의 일반적인 왕복은 다음과 같이 볼 수 있습니다. 먼저 발신 측에서 통화 흐름을 봅니다.</target>
        </trans-unit>
        <trans-unit id="a092e2bd3b4745048655568b0b490cb79d98d82c" translate="yes" xml:space="preserve">
          <source>The unit of measurement is memory words. There exists both a 32-bit and a 64-bit implementation. A word is therefore 4 bytes or 8 bytes, respectively.</source>
          <target state="translated">측정 단위는 메모리 워드입니다. 32 비트 및 64 비트 구현이 모두 있습니다. 따라서 단어는 각각 4 바이트 또는 8 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d78579febd40e018de674b923ab2dd8480cc6d1a" translate="yes" xml:space="preserve">
          <source>The unit size is given as &lt;code&gt;unit:IntegerLiteral&lt;/code&gt;. The allowed range is 1-256. It is multiplied by the &lt;code&gt;Size&lt;/code&gt; specifier to give the effective size of the segment. The unit size specifies the alignment for binary segments without size.</source>
          <target state="translated">단위 크기는 &lt;code&gt;unit:IntegerLiteral&lt;/code&gt; 로 제공됩니다 . 허용되는 범위는 1-256입니다. 세그먼트의 유효 크기를 제공하기 위해 &lt;code&gt;Size&lt;/code&gt; 지정자를 곱 합니다. 단위 크기는 크기가없는 이진 세그먼트의 정렬을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5ee4d7b5711971b4db427f1d7dcb1848a313bcc2" translate="yes" xml:space="preserve">
          <source>The unload request is registered, but other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still hold the driver. Notice that the term &lt;code&gt;pending_process&lt;/code&gt; can refer to the running process; there can be more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; in the same process.</source>
          <target state="translated">언로드 요청이 등록되었지만 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 여전히 드라이버를 보유합니다. &lt;code&gt;pending_process&lt;/code&gt; 라는 용어 는 실행중인 프로세스를 나타낼 수 있습니다. 동일한 프로세스에 둘 이상의 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a92c5b2b8040b8ecbc28851e51c3e75943648293" translate="yes" xml:space="preserve">
          <source>The unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver in question while in progress.</source>
          <target state="translated">언로드 / 로딩은 하나의 원 자성 작업으로 수행되어 시스템의 모든 프로세스가 진행중인 동안 해당 드라이버를 사용하지 못하도록 차단합니다.</target>
        </trans-unit>
        <trans-unit id="b2bb7ad491dec5db9c49126bb51367d385e40bcc" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt64&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt64&lt;/code&gt; are always 64 bits wide. They were introduced in ERTS 5.7.4.</source>
          <target state="translated">부호없는 정수 데이터 형식 &lt;code&gt;ErlDrvUInt64&lt;/code&gt; 및 부호있는 정수 데이터 형식 &lt;code&gt;ErlDrvSInt64&lt;/code&gt; 는 항상 64 비트입니다. 그것들은 ERTS 5.7.4에서 소개되었습니다.</target>
        </trans-unit>
        <trans-unit id="06cd090adf77b790656c62fa3caa0f561db0b42b" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt&lt;/code&gt; are 64 bits wide on a 64-bit runtime system and 32 bits wide on a 32-bit runtime system. They were introduced in ERTS 5.6 and replaced some of the &lt;code&gt;int&lt;/code&gt; arguments in the list above.</source>
          <target state="translated">부호없는 정수 데이터 유형 &lt;code&gt;ErlDrvUInt&lt;/code&gt; 및 부호있는 정수 데이터 유형 &lt;code&gt;ErlDrvSInt&lt;/code&gt; 는 64 비트 런타임 시스템에서 64 비트, 32 비트 런타임 시스템에서 32 비트입니다. 그것들은 ERTS 5.6에서 소개되었으며 위의 목록에서 &lt;code&gt;int&lt;/code&gt; 인수 중 일부를 대체했습니다 .</target>
        </trans-unit>
        <trans-unit id="d4dbe8cb85a6484b8db2e5ddc4f7e81602e6c250" translate="yes" xml:space="preserve">
          <source>The unsigned integer value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">부호없는 정수 값 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634b3eb0cccf55ffe20b68558982833221c90d25" translate="yes" xml:space="preserve">
          <source>The unsleeping reader may notice that the ACC times for &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; and &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; is not equal between the paragraphs above, even though it is easy to believe that &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is just a passthrough function.</source>
          <target state="translated">&lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 않는 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 는 prim_file : drv_command / 2 가 단지 passthrough 함수 라고 믿기는 쉽지만 prim_file : drv_command / 2 및 &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 의 ACC 시간이 위의 단락들 사이에서 동일하지 않다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c140ed888506c0fa3ce30e4732a3ab8d9bef72" translate="yes" xml:space="preserve">
          <source>The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if the request is acknowledged, the upgrade to tls is performed.</source>
          <target state="translated">업그레이드는 두 단계로 수행됩니다. 먼저 서버에 업그레이드 권한을 요청합니다. 둘째, 요청이 승인되면 tls 로의 업그레이드가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f1abe4219b1176145faaf51a5d5248cfe9c5cdbb" translate="yes" xml:space="preserve">
          <source>The upgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;upgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 업그레이드 스크립트를 평가할 수 있습니다 . 대신 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋지만이 기능 ( &lt;code&gt;upgrade_script&lt;/code&gt; )은 스크립트의 내용을 검사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="66b6bbe8cee241bbe5ef7774f674afa0a63f5765" translate="yes" xml:space="preserve">
          <source>The upgrade was refused by the LDAP server. The &lt;code&gt;ResponseFromServer&lt;/code&gt; is an atom delivered byt the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is still un-encrypted.</source>
          <target state="translated">LDAP 서버에서 업그레이드를 거부했습니다. &lt;code&gt;ResponseFromServer&lt;/code&gt; 는 여전히 암호화되지 않은 그래서, LDAP 서버 BYT 전달 원자는 RFC 2830의 연결 2.3은 영향을받지 않습니다 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="24e4c40c9265bed4ba5b9b42f433f1e4b84ab6f0" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the allocated block size histograms. Defaults to 128.</source>
          <target state="translated">할당 된 블록 크기 히스토그램에서 첫 번째 간격의 상한입니다. 기본값은 128입니다.</target>
        </trans-unit>
        <trans-unit id="cbc1809e93754ae11d777adddcabee5582e3ea4f" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the free block size histograms. Defaults to 512.</source>
          <target state="translated">사용 가능한 블록 크기 히스토그램에서 첫 번째 간격의 상한입니다. 기본값은 512입니다.</target>
        </trans-unit>
        <trans-unit id="49138c2017ae769df1dbe3fdeaaab6a9e2775cc2" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval is provided by the function that returned the histogram, and the last interval has no upper bound.</source>
          <target state="translated">첫 번째 간격의 상한은 히스토그램을 반환 한 함수에 의해 제공되며 마지막 간격에는 상한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dc8cf3ce6b3c8880a720af10de4f0e69e030978" translate="yes" xml:space="preserve">
          <source>The uppercase escapes match the inverse sets of characters. Notice that \d matches only decimal digits, while \w matches any Unicode digit, any Unicode letter, and underscore. Notice also that &lt;code&gt;ucp&lt;/code&gt; affects \b and \B, as they are defined in terms of \w and \W. Matching these sequences is noticeably slower when &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">대문자 이스케이프는 역의 문자 집합과 일치합니다. \ d는 십진수 만 일치하고 \ w는 모든 유니 코드 숫자, 유니 코드 문자 및 밑줄과 일치합니다. 또한 &lt;code&gt;ucp&lt;/code&gt; 는 \ w 및 \ W로 정의되므로 \ b 및 \ B에 영향을줍니다. &lt;code&gt;ucp&lt;/code&gt; 가 설정 되면 이러한 순서를 일치시키는 것이 눈에 띄게 느려집니다 .</target>
        </trans-unit>
        <trans-unit id="b043a2c5698c1e7d1fd873979502125e49e702d8" translate="yes" xml:space="preserve">
          <source>The use and effect of the actions are as follows:</source>
          <target state="translated">조치의 사용 및 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea64d7717e78cf5f593ec4e6046b9c45fcf5ca9f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="translated">리소스 객체를 사용하면 NIF에서 네이티브 데이터 구조에 대한 포인터를 안전하게 반환 할 수 있습니다. 자원 객체는 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 로 할당 된 메모리 블록 일뿐 입니다. 그런 다음 &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 를 사용하여이 메모리 블록에 대한 핸들 ( &quot;안전 포인터&quot;)을 Erlang으로 리턴 할 수 있습니다 . &lt;code&gt;enif_make_resource&lt;/code&gt; 에 의해 리턴되는 용어는 사실상 불투명합니다. 프로세스간에 저장하여 전달할 수 있지만 실제 최종 용도는 NIF에 인수로 전달하는 것뿐입니다. 그런 다음 NIF는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 를 호출 하고 메모리 블록에 대한 포인터를 다시 가져올 수 있으며 여전히 유효합니다. 마지막 핸들 용어가 VM에 의해 가비지 수집되고 자원이 해제 될 때까지 자원 오브젝트가 할당 해제되지 않습니다. &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (순서대로는 아님).</target>
        </trans-unit>
        <trans-unit id="abd42e11d00d705e28195f82bd49864a0d14541e" translate="yes" xml:space="preserve">
          <source>The use of the match operator is particularly useful for pulling apart Erlang terms and creating new ones.</source>
          <target state="translated">일치 연산자를 사용하면 Erlang 용어를 분리하고 새 용어를 만들 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9361a4a5f036e16a92bbb4fe0af3e2c751d37ab7" translate="yes" xml:space="preserve">
          <source>The use of this option has always been discouraged. As from R14A, it is an error to use it.</source>
          <target state="translated">이 옵션은 항상 사용하지 않는 것이 좋습니다. R14A에서와 같이 사용하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7051fa8cce86b7e9e63652f268c7db87c6180ee0" translate="yes" xml:space="preserve">
          <source>The used memory for all ETS tables.</source>
          <target state="translated">모든 ETS 테이블에 사용 된 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="8f9be74fa1ece2bebb8a5ba0433d42158ebba618" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;otptest&lt;/code&gt;, which has bash as default shell, uses the &lt;code&gt;ssh:shell/1&lt;/code&gt; client to connect to the &lt;strong&gt;openssh&lt;/strong&gt; daemon running on a host called &lt;strong&gt;tarlop&lt;/strong&gt;:</source>
          <target state="translated">bash를 기본 쉘로 사용하는 &lt;code&gt;otptest&lt;/code&gt; 사용자 는 &lt;code&gt;ssh:shell/1&lt;/code&gt; 클라이언트를 사용하여 &lt;strong&gt;tarlop&lt;/strong&gt; 이라는 호스트에서 실행 되는 &lt;strong&gt;openssh&lt;/strong&gt; 데몬 에 연결합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d301c340a5de16be3a33995e9e04d1a25c73f970" translate="yes" xml:space="preserve">
          <source>The user can include this AVP as required.</source>
          <target state="translated">사용자는 필요에 따라이 AVP를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b476a06d8305252521da860471bca0c708d1246d" translate="yes" xml:space="preserve">
          <source>The user can provide a test specification including (for &lt;code&gt;Common Test&lt;/code&gt;) unrecognizable terms. If this is desired, use flag &lt;code&gt;-allow_user_terms&lt;/code&gt; when starting tests with &lt;code&gt;ct_run&lt;/code&gt;. This forces &lt;code&gt;Common Test&lt;/code&gt; to ignore unrecognizable terms. In this mode, &lt;code&gt;Common Test&lt;/code&gt; is not able to check the specification for errors as efficiently as if the scanner runs in default mode. If &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; is used for starting the tests, the relaxed scanner mode is enabled by tuple &lt;code&gt;{allow_user_terms,true}&lt;/code&gt;.</source>
          <target state="translated">사용자는 ( &lt;code&gt;Common Test&lt;/code&gt; ) 인식 할 수없는 용어 를 포함한 테스트 사양을 제공 할 수 있습니다 . 이것이 필요한 경우, &lt;code&gt;-allow_user_terms&lt;/code&gt; 테스트를 시작할 때 플래그 -allow_user_terms를 사용 &lt;code&gt;ct_run&lt;/code&gt; . 이로 인해 &lt;code&gt;Common Test&lt;/code&gt; 는 인식 할 수없는 용어를 무시합니다. 이 모드에서 &lt;code&gt;Common Test&lt;/code&gt; 는 스캐너가 기본 모드에서 실행되는 것처럼 효율적으로 사양에서 오류를 확인할 수 없습니다. 경우 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 테스트를 시작하는 데 사용됩니다, 완화 된 스캐너 모드는 튜플으로 활성화되어 &lt;code&gt;{allow_user_terms,true}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aec8dfaf1d2231e245fe0cd75a270293f3d428b2" translate="yes" xml:space="preserve">
          <source>The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; when starting Erlang.</source>
          <target state="translated">사용자는 쉘 및 형식 지정 기능에 의해 문자열을 발견 적 발견 할 때 인쇄 가능한 것으로 간주되는 문자 범위를 요청할 수 있습니다. 이는 공급함으로써 행해진 &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; 얼랑 시작할 때.</target>
        </trans-unit>
        <trans-unit id="5ae2400e1fce55a0b4d9b7318948b8627b3d6a40" translate="yes" xml:space="preserve">
          <source>The user can specify a specific group path with parameter &lt;code&gt;group_names_or_paths&lt;/code&gt;. With this type of specification execution of unwanted groups (in otherwise matching paths), and/or the execution of subgroups can be avoided. The command line syntax of the group path is a list of group names in the path, for example:</source>
          <target state="translated">사용자는 &lt;code&gt;group_names_or_paths&lt;/code&gt; 매개 변수를 사용하여 특정 그룹 경로를 지정할 수 있습니다 . 이러한 유형의 사양을 사용하면 원하지 않는 그룹의 실행 (또는 일치하는 경로에서) 및 / 또는 하위 그룹의 실행을 피할 수 있습니다. 그룹 경로의 명령 줄 구문은 경로의 그룹 이름 목록입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="0130ad65a7625b17e035e835fe6eaf0679e0f246" translate="yes" xml:space="preserve">
          <source>The user can specify configuration data on a different format than key-value tuples in a text file, as described so far. The data can, for example, be read from any files, fetched from the web over HTTP, or requested from a user-specific process. To support this, &lt;code&gt;Common Test&lt;/code&gt; provides a callback module plugin mechanism to handle configuration data.</source>
          <target state="translated">사용자는 지금까지 설명한대로 텍스트 파일에서 키-값 튜플과 다른 형식으로 구성 데이터를 지정할 수 있습니다. 예를 들어, 데이터는 모든 파일에서 읽거나 HTTP를 통해 웹에서 가져 오거나 사용자 별 프로세스에서 요청할 수 있습니다. 이를 지원하기 위해 &lt;code&gt;Common Test&lt;/code&gt; 는 구성 데이터를 처리하기위한 콜백 모듈 플러그인 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="660461224293f1991c368482cebc005aee961e52" translate="yes" xml:space="preserve">
          <source>The user configures diameter with the identifiers to send at capabilities exchange, along with corresponding dictionaries defining the messages of the applications.</source>
          <target state="translated">사용자는 응용 프로그램의 메시지를 정의하는 해당 사전과 함께 기능 교환시 전송할 식별자로 직경을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b475ffe342e790093cd964ba6cc829f6bd45785f" translate="yes" xml:space="preserve">
          <source>The user constructs application-specific messages, but diameter provides failed AVPs in message callbacks. Failed component AVPs are grouped within the relevant Grouped AVPs.</source>
          <target state="translated">사용자는 응용 프로그램 별 메시지를 구성하지만 Diameter는 메시지 콜백에서 실패한 AVP를 제공합니다. 실패한 구성 요소 AVP는 관련 그룹화 된 AVP 내에 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="3591203b72caf861e6110120cbe93c01af2b88a2" translate="yes" xml:space="preserve">
          <source>The user decides whether or not to process a request locally in the request callback from diameter.</source>
          <target state="translated">사용자는 직경으로부터의 요청 콜백에서 로컬로 요청을 처리할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3464961bd356a69bfcff6ac160a461e76a93d25f" translate="yes" xml:space="preserve">
          <source>The user has explicitly cancelled the wait (megaco:cancel/2).</source>
          <target state="translated">사용자가 대기를 명시 적으로 취소했습니다 (megaco : cancel / 2).</target>
        </trans-unit>
        <trans-unit id="d18a93e929b37cd21f4c79e7536ff6532ff0f893" translate="yes" xml:space="preserve">
          <source>The user has logged off (the &quot;logoff&quot; message is removed).</source>
          <target state="translated">사용자가 로그 오프했습니다 ( &quot;로그 오프&quot;메시지가 제거됨).</target>
        </trans-unit>
        <trans-unit id="66d08744fcbef8850f22e132fcee2b95959ddf93" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 사용자 키 디렉토리를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf02e29035334a18d18c5e1b94c79095367bd56" translate="yes" xml:space="preserve">
          <source>The user may (for special purposes) create additional nodes with other type tags, using the &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">사용자는 (특별한 목적으로) &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 다른 유형 태그로 추가 노드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee238ea123b1d44a60398d5285952819fc3ede9" translate="yes" xml:space="preserve">
          <source>The user should implement a scanner that segments the input text, and turns it into one or more lists of tokens. Each token should be a tuple containing information about syntactic category, position in the text (e.g. line number), and the actual terminal symbol found in the text: &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt;.</source>
          <target state="translated">사용자는 입력 텍스트를 분할하여 하나 이상의 토큰 목록으로 바꾸는 스캐너를 구현해야합니다. 각 토큰은 구문 범주, 텍스트에서의 위치 (예 : 행 번호) 및 텍스트에서 찾은 실제 터미널 기호 &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt; 대한 정보를 포함하는 튜플이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d9c7796fd10aeef2e76370d88ff426dec7a02695" translate="yes" xml:space="preserve">
          <source>The user tag is provided to the user probes triggered by calls top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; as well as probes in the efile_driver. In the future, user tags might be added to more probes.</source>
          <target state="translated">사용자 태그는 &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; 프로브뿐만 아니라 top dyntrace : p / {1,2,3,4,5,6,7,8} 호출에 의해 트리거되는 사용자 프로브에 제공됩니다 . 앞으로 사용자 태그가 더 많은 프로브에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="935cfbe6393df2b605ae54a72dfb24e180f2b45e" translate="yes" xml:space="preserve">
          <source>The user timetrap function can be used for two things as follows:</source>
          <target state="translated">사용자 타임 트랩 기능은 다음과 같이 두 가지 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2130a51941a7dd2f7d9af37266ecb1c20f0d79" translate="yes" xml:space="preserve">
          <source>The user timetrap function can return a time value after a delay. The effective timetrap time is then the delay time &lt;strong&gt;plus&lt;/strong&gt; the returned time.</source>
          <target state="translated">사용자 타임 트랩 함수는 지연 후 시간 값을 반환 할 수 있습니다. 유효 타임 트랩 시간은 지연 시간 &lt;strong&gt;+&lt;/strong&gt; 반환 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b5ee7bda12decc24125202f276f6922f07234b3a" translate="yes" xml:space="preserve">
          <source>The user(s) register their agents.</source>
          <target state="translated">사용자는 자신의 에이전트를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="1d94abedc5a45d3a00396f6b9115ee0199e9b2d1" translate="yes" xml:space="preserve">
          <source>The user-defined CPU topology can also be set by passing command-line argument &lt;code&gt;+sct&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">명령 줄 인수 &lt;code&gt;+sct&lt;/code&gt; 를 &lt;code&gt;erl(1)&lt;/code&gt; 에 전달하여 사용자 정의 CPU 토폴로지를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3eac153a48412697b04bd3f7c3679f6e2cb43d77" translate="yes" xml:space="preserve">
          <source>The user-specific handler can be written to handle special configuration file formats. The parameter can be either file names or configuration strings (the empty list is valid).</source>
          <target state="translated">특수 구성 파일 형식을 처리하기 위해 사용자 별 핸들러를 작성할 수 있습니다. 매개 변수는 파일 이름 또는 구성 문자열 일 수 있습니다 (빈 목록이 유효 함).</target>
        </trans-unit>
        <trans-unit id="070ed6c048e93f78c36ea8f0ccfec711d97f3991" translate="yes" xml:space="preserve">
          <source>The user/operator can specify the order at will, and maybe a different execution order is sometimes more relevant or efficient.</source>
          <target state="translated">사용자 / 운영자는 마음대로 순서를 지정할 수 있으며, 때로는 다른 실행 순서가 더 관련성 있거나 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816667b752baf90b5891d2f5483693ef98e188ca" translate="yes" xml:space="preserve">
          <source>The username used for authentication.</source>
          <target state="translated">인증에 사용되는 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="32f031cef47e0932c6309630147b6b75921f94b2" translate="yes" xml:space="preserve">
          <source>The utilities are also suitable to use in system testing on large systems, where other tools have too much impact on the system performance. Some primitive support for sequential tracing is also included, see the &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">이 유틸리티는 다른 도구가 시스템 성능에 너무 많은 영향을 미치는 대규모 시스템의 시스템 테스트에 사용하기에 적합합니다. 순차 추적에 대한 일부 기본 지원도 포함되어 &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; ( 고급 주제 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="1b998cc802660cc78a04365f6fb84a62e62e8e56" translate="yes" xml:space="preserve">
          <source>The utility &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">유틸리티 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 은 대체 컴파일 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88c9fe090556e5d2d20b460fae9afd89cea9e45c" translate="yes" xml:space="preserve">
          <source>The utility function &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; can be used to easily transform a string of text into a &lt;code&gt;par&lt;/code&gt; representation by splitting it into words.</source>
          <target state="translated">유틸리티 함수 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 를 사용하면 텍스트 문자열 을 단어로 분할 하여 텍스트 표현 을 쉽게 &lt;code&gt;par&lt;/code&gt; 표현 으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd02acb46e123ade0af1cb132c81a7c98e6cbd55" translate="yes" xml:space="preserve">
          <source>The utility module &lt;code&gt;msacc(3)&lt;/code&gt; can be used to more easily analyse these statistics.</source>
          <target state="translated">유틸리티 모듈 &lt;code&gt;msacc(3)&lt;/code&gt; 를 사용하여 이러한 통계를보다 쉽게 ​​분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86003c423491838636e87b46780a42310a82d73b" translate="yes" xml:space="preserve">
          <source>The valid configuration parameters are as follows:</source>
          <target state="translated">유효한 구성 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb94796638387a4f1cb0c6ac15343b38548969a" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. See the &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; function for more info on the &lt;code&gt;Validate&lt;/code&gt; fun.</source>
          <target state="translated">유효성 검사 기능인 &lt;code&gt;Validate&lt;/code&gt; 는 &lt;code&gt;DateAndTime&lt;/code&gt; 인수 에 대해보다 &quot;유연한&quot;유효성 검사를 허용합니다 . 데이터가 RFC2579를 따르지 않는 것으로 판명 될 때마다, 더 &quot;완벽한&quot;검증을 허용하는 재미가 요구됩니다. &lt;code&gt;Validate&lt;/code&gt; 재미 에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60c703f2c6b10b3e79aabc8eaf2dfdc52607c370" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. The input to the validation fun looks like this:</source>
          <target state="translated">유효성 검사 기능인 &lt;code&gt;Validate&lt;/code&gt; 는 &lt;code&gt;DateAndTime&lt;/code&gt; 인수 에 대해보다 &quot;유연한&quot;유효성 검사를 허용합니다 . 데이터가 RFC2579를 따르지 않는 것으로 판명 될 때마다, 더 &quot;완벽한&quot;검증을 허용하는 재미가 요구됩니다. 유효성 검사 재미에 대한 입력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58a5e20ed6c2d29e3e861f7702b4763df798e9a1" translate="yes" xml:space="preserve">
          <source>The validity of the options is &lt;strong&gt;not&lt;/strong&gt; checked by the HTTP client they are assumed to be correct and passed on to ssl application and inet driver, which may reject them if they are not correct.</source>
          <target state="translated">옵션의 유효성이되어 &lt;strong&gt;있지&lt;/strong&gt; 가 정확하지 않은 경우이를 거부 할 수가 정확하고 SSL 응용 프로그램과 INET 드라이버에 전달로 간주하는 HTTP 클라이언트에 의해 확인.</target>
        </trans-unit>
        <trans-unit id="247d880cbbfe17329068c2a487e83b52be0b8fd0" translate="yes" xml:space="preserve">
          <source>The validity period of the certificate.</source>
          <target state="translated">인증서의 유효 기간</target>
        </trans-unit>
        <trans-unit id="de095b0c0154458957667b823417f32d9c762772" translate="yes" xml:space="preserve">
          <source>The value (in seconds) must be in the range 10 &amp;lt; X &amp;lt;= 65535.</source>
          <target state="translated">값 (초)은 10 &amp;lt;X &amp;lt;= 65535 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c7d9f4f2d7422b47b5c88e4d58854e12adae49bd" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;-1&lt;/code&gt; in any field means &quot;unknown&quot;, and in most cases it means that the dump was truncated somewhere around this field.</source>
          <target state="translated">모든 필드 의 값 &lt;code&gt;-1&lt;/code&gt; 은 &quot;알 수 없음&quot;을 의미하며 대부분의 경우이 필드 주위에서 덤프가 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="ebb9639bd59b81ac3f0302e2ea6264dd43e978a9" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;random&lt;/code&gt; will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version.</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 값 은 각 연결 시도에서 임의의 문자열을 작성합니다. 이것은 악의적 인 피어가 ssh 소프트웨어 브랜드와 버전을 찾는 것을 좀 더 어렵게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59cae5c48ebf4d4c60edc8af8c6900b2f10cdd93" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; will make a random string with at least &lt;code&gt;Nmin&lt;/code&gt; characters and at most &lt;code&gt;Nmax&lt;/code&gt; characters.</source>
          <target state="translated">값 &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; 적어도와 임의의 문자열 것 &lt;code&gt;Nmin&lt;/code&gt; 을의 문자와 최대 &lt;code&gt;Nmax&lt;/code&gt; 가의 문자.</target>
        </trans-unit>
        <trans-unit id="cc2e81fd931d300e3783349335314abc90033f4a" translate="yes" xml:space="preserve">
          <source>The value associated with key &lt;code&gt;alpha&lt;/code&gt; is fetched for both arguments using the &lt;code&gt;:=&lt;/code&gt; operator. The other keys in the map are ignored, only the key &lt;code&gt;alpha&lt;/code&gt; is required and checked for.</source>
          <target state="translated">키 &lt;code&gt;alpha&lt;/code&gt; 와 관련된 값 은 &lt;code&gt;:=&lt;/code&gt; 연산자를 사용하여 두 인수 모두에 대해 페치됩니다 . 맵의 다른 키는 무시되며 키 &lt;code&gt;alpha&lt;/code&gt; 만 필요하며 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="86b0b34c5895cd8049a0c1760924204afc238fc1" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">이 키와 연관된 값은 특정 기능 영역과 같은 로그 이벤트를 그룹화하기 위해 필터에서 사용합니다. 이 필드를 사용하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a9b31d1fc7f3b413bcae938dfe03589bb5285a5" translate="yes" xml:space="preserve">
          <source>The value defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73cc3165471e18765106ff9988f4618f4de5f7c9" translate="yes" xml:space="preserve">
          <source>The value defined here can be used in several ways. It can, for example, be used as the value in some &lt;code&gt;DEFAULT&lt;/code&gt; component:</source>
          <target state="translated">여기에 정의 된 값은 여러 가지 방법으로 사용될 수 있습니다. 예를 들어 일부 &lt;code&gt;DEFAULT&lt;/code&gt; 구성 요소 의 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00cedad00d133d50963e34c659f0ef80545f6ee4" translate="yes" xml:space="preserve">
          <source>The value denotes a regular expression (see module &lt;code&gt;re&lt;/code&gt;). Tidying will only be applied to those regular files whose names match this pattern. The default value is &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt;, which matches normal Erlang source file names.</source>
          <target state="translated">값은 정규식을 나타냅니다 (모듈 &lt;code&gt;re&lt;/code&gt; 참조 ). 정리는 이름이이 패턴과 일치하는 일반 파일에만 적용됩니다. 기본값은 &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt; 이며 이는 일반적인 Erlang 소스 파일 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a7fc7c904bc65fe1f04425c2c4301dd4dfba43f3" translate="yes" xml:space="preserve">
          <source>The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.</source>
          <target state="translated">값은 RFC 6733의 섹션 8.8에 필요한 형식을 갖습니다. 식별자는 반환 된 값이 포함 된 메시지가 전송 될 피어의 Origin-Host 여야합니다.</target>
        </trans-unit>
        <trans-unit id="565bd9ff9980988d34e45f60f24a9df4493a532c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">프로세스에 대해 통화 저장이 활성화되지 않은 경우 값은 &lt;code&gt;false&lt;/code&gt; 입니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt; 참조 ). 통화 저장이 활성화되면 마지막 요소가 가장 최근에 호출 된 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fca5756bcf0742c5fb8a83c510ae9ce36b623343" translate="yes" xml:space="preserve">
          <source>The value is a &lt;code&gt;boolean()&lt;/code&gt;. The value &lt;code&gt;true&lt;/code&gt; will make the client accept any unknown Host Key without any user interaction. The value &lt;code&gt;false&lt;/code&gt; preserves the default behaviour of asking the user on stdio.</source>
          <target state="translated">값은 &lt;code&gt;boolean()&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 값 은 클라이언트가 사용자 개입없이 알 수없는 호스트 키를 수락하도록합니다. &lt;code&gt;false&lt;/code&gt; 값 은 stdio에서 사용자에게 묻는 기본 동작을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4b03c47ccab46f2579d8f24abc755f87cc416f2a" translate="yes" xml:space="preserve">
          <source>The value is a list of pairs, associating tuples &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; with tuples &lt;code&gt;{NewModule, NewName}&lt;/code&gt;, specifying renamings of calls to remote functions. By default, the value is the empty list.</source>
          <target state="translated">값은 튜플 &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; 을 튜플 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; 과 연관 시켜 원격 함수 호출의 이름 바꾸기를 지정하는 쌍 목록입니다 . 기본적으로 값은 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1df1db1ba1c8748b25a7c5b626dd8804fd835229" translate="yes" xml:space="preserve">
          <source>The value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; section 9.1.</source>
          <target state="translated">이 값은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; 섹션 9.1에 정의 된 프로토콜 수준 응답의 sftp 오류 코드에서 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd41f86d28c143add491ec9132e29dfc8b19621e" translate="yes" xml:space="preserve">
          <source>The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use &lt;code&gt;atom()&lt;/code&gt;s or &lt;code&gt;string()&lt;/code&gt;s to specify the subpatterns to be returned. For example, consider the regular expression:</source>
          <target state="translated">값 목록은 하위 패턴이 리턴 할 색인 목록입니다. 여기서 색인 0은 모든 패턴에 대한 것이고 1은 정규 표현식의 첫 번째 명시 적 캡처 하위 패턴 등입니다. 정규 표현식에서 명명 된 캡처 된 하위 패턴 (아래 참조)을 사용하는 경우 &lt;code&gt;atom()&lt;/code&gt; 또는 &lt;code&gt;string()&lt;/code&gt; 을 사용하여 반환 할 하위 패턴을 지정할 수 있습니다. 예를 들어 정규 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c81f48007ff0ed091ec4764a41dbf0e172a8f0bb" translate="yes" xml:space="preserve">
          <source>The value must be a function with arity 1, returning &lt;code&gt;{Format,Args}&lt;/code&gt;, and it will be called with a report as only argument.</source>
          <target state="translated">값은 arity 1을 가진 함수 여야하며 &lt;code&gt;{Format,Args}&lt;/code&gt; 를 리턴 하며 보고서와 함께 인수로만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e234819107a6b5dcfa3fe173976c85b1ea1b28f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값과 같습니다 . 그렇지 않으면 런타임 시스템이 드라이버로드를 거부했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="116150239ed1360f1b36349687371da72b694bcd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 값과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78be37cd91f4cf995f8b06a4daace135c812602c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0b2195f8068d2a10ede4ea4cc9fcbf6ff4d98d21" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b118746e3fc7bb9edb78696fb5442fd44cb5a3e1" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Misc&lt;/code&gt; varies for different types of processes, for example:</source>
          <target state="translated">&lt;code&gt;Misc&lt;/code&gt; 의 가치는 다음 과 같은 프로세스 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8dae040f4f2546c55f00cef77a0cb74993dea2c6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 와 단위를 곱한 값은 비트 수를 나타냅니다. &lt;code&gt;binary&lt;/code&gt; 유형의 세그먼트는 8로 균등하게 나눌 수있는 크기를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="780ca2b28783a99a4c631093f06c672e54bdfc8a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; specifies the size of the segment in units (see below). The default value depends on the type (see below):</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 값은 세그먼트의 크기를 단위로 지정합니다 (아래 참조). 기본값은 유형에 따라 다릅니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="b1854e31941d7fbfcb3749a7e6c4457829e3447d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;State&lt;/code&gt; varies for different types of processes, as follows:</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 의 값은 다음과 같이 프로세스 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67326e380fdef2e7ca1cffaffc1a499d8945109f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;engine_id&lt;/code&gt; is a string, which should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;engine_id&lt;/code&gt; 의 값은 문자열이며 매우 구체적인 구조를 가져야합니다. 자세한 내용은 RFC 2271/2571을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67a488abfbc3355615ef1fdf9842c10e39f374ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;file&lt;/code&gt; overrides the value of &lt;code&gt;file&lt;/code&gt; as defined in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">의 값 &lt;code&gt;file&lt;/code&gt; 의 값에 우선 &lt;code&gt;file&lt;/code&gt; 에 정의로 &lt;code&gt;.app&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="ce398bd65bb25721ffa1a8a7e0185e8682912540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;intAgentTransports&lt;/code&gt; is a list of &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuples, where &lt;code&gt;Domain&lt;/code&gt; is either &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is the address in the domain. &lt;code&gt;Addr&lt;/code&gt; can be specified either as an &lt;code&gt;IpAddr&lt;/code&gt; or as an &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; tuple. &lt;code&gt;IpAddr&lt;/code&gt; is either a regular Erlang/OTP &lt;code&gt;ip_address()&lt;/code&gt; or a traditional SNMP integer list and &lt;code&gt;IpPort&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;intAgentTransports&lt;/code&gt; 값은 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 튜플 의 목록입니다 . 여기서 &lt;code&gt;Domain&lt;/code&gt; 은 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 이고 &lt;code&gt;Addr&lt;/code&gt; 은 도메인의 주소입니다. &lt;code&gt;Addr&lt;/code&gt; 은 &lt;code&gt;IpAddr&lt;/code&gt; 또는 &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; 튜플 로 지정할 수 있습니다 . &lt;code&gt;IpAddr&lt;/code&gt; 은 일반 Erlang / OTP &lt;code&gt;ip_address()&lt;/code&gt; 또는 기존 SNMP 정수 목록이며 &lt;code&gt;IpPort&lt;/code&gt; 는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="fa552c79540af3ff0c608c82bebe09aa87d449b9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;parent_value&lt;/code&gt; is the value returned by &lt;code&gt;ParentFun&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if there is no &lt;code&gt;ParentFun&lt;/code&gt;. &lt;code&gt;ParentFun&lt;/code&gt; is called once just before the call of &lt;code&gt;PreFun&lt;/code&gt; in the context of the process calling &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;parent_value&lt;/code&gt; 는 값으로 반환된다 &lt;code&gt;ParentFun&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 전혀 존재하지 않는 경우 &lt;code&gt;ParentFun&lt;/code&gt; . &lt;code&gt;ParentFun&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하는 프로세스와 관련하여 &lt;code&gt;PreFun&lt;/code&gt; 호출 직전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="403588e32c3c599137f65e61edac93c0adc811e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;snmpEngineID&lt;/code&gt; is a string, which for a deployed agent should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;snmpEngineID&lt;/code&gt; 의 값은 문자열이며, 배치 된 에이전트의 경우 매우 구체적인 구조를 가져야합니다. 자세한 내용은 RFC 2271/2571을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39576763fb2878e58995adcb19edf7b1f8b5b52e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;stop_fun&lt;/code&gt; is a nullary fun that deletes the cursor if called from the parent, or &lt;code&gt;undefined&lt;/code&gt; if there is no cursor.</source>
          <target state="translated">&lt;code&gt;stop_fun&lt;/code&gt; 의 값은 상위에서 호출 된 경우 커서를 삭제하거나 커서 가없는 경우 &lt;code&gt;undefined&lt;/code&gt; 널 재미입니다 .</target>
        </trans-unit>
        <trans-unit id="bbda166cbb0a64342130a713cafa3ff8a579278c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;tc_group_properties&lt;/code&gt; is a list of status tuples, each with the key &lt;code&gt;ok&lt;/code&gt;, &lt;code&gt;skipped&lt;/code&gt;, and &lt;code&gt;failed&lt;/code&gt;. The value of a status tuple is a list with names of test cases that have been executed with the corresponding status as result.</source>
          <target state="translated">&lt;code&gt;tc_group_properties&lt;/code&gt; 값은 각각 &lt;code&gt;ok&lt;/code&gt; , &lt;code&gt;skipped&lt;/code&gt; 및 &lt;code&gt;failed&lt;/code&gt; 키가있는 상태 튜플 목록입니다 . 상태 튜플의 값은 결과로 해당 상태로 실행 된 테스트 케이스 이름이있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c90e20096422723556a7637012d02aa52ba6cd06" translate="yes" xml:space="preserve">
          <source>The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수의 값은 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 를 호출하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e674f5f0ae9761a28b0e34a6e1578f6940f7307" translate="yes" xml:space="preserve">
          <source>The value of a field in a record can be an instance of a record. Retrieval of nested data can be done stepwise, or in a single step, as shown in the following example:</source>
          <target state="translated">레코드의 필드 값은 레코드의 인스턴스 일 수 있습니다. 다음 예제와 같이 중첩 된 데이터 검색은 단계별 또는 단일 단계로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090fd2fb5e0fd0eb93688d1bfcea8e341fe24db7" translate="yes" xml:space="preserve">
          <source>The value of option &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; is to be &lt;code&gt;'=:='&lt;/code&gt; if the table considers two keys equal if they match, and to be &lt;code&gt;'=='&lt;/code&gt; if two keys are equal if they compare equal. Defaults to &lt;code&gt;'=:='&lt;/code&gt;.</source>
          <target state="translated">옵션의 값 &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; 이 될 것입니다 &lt;code&gt;'=:='&lt;/code&gt; 테이블에 두 개의 키가 일치하는 경우와 동일하고,로 간주하는 경우 &lt;code&gt;'=='&lt;/code&gt; 가 동일한 비교하면 두 개의 키가 동일한 경우. 기본값은 &lt;code&gt;'=:='&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b5f4463cd58d2c1d9f4f3e85881555f2a7d602d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;Parserfile&lt;/code&gt; option stripped of the &lt;code&gt;.erl&lt;/code&gt; extension is used by Yecc as the module name of the generated parser file.</source>
          <target state="translated">&lt;code&gt;.erl&lt;/code&gt; 확장자가 제거 된 &lt;code&gt;Parserfile&lt;/code&gt; 옵션 의 값은 Yecc 에서 생성 된 구문 분석기 파일의 모듈 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c64d7956fe51b588938aacaa6f88fb7a9310598" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;closure&lt;/code&gt; operator (the &lt;code&gt;digraph&lt;/code&gt; representation) is represented by the atom &lt;code&gt;'closure()'&lt;/code&gt;.</source>
          <target state="translated">의 값 &lt;code&gt;closure&lt;/code&gt; 조작합니다 ( &lt;code&gt;digraph&lt;/code&gt; 표현) 원자에 의해 표현되는 &lt;code&gt;'closure()'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22be0277bd691cf393301070a38cd39e17abb844" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;mod&lt;/code&gt; key of the including application must be set to &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; as usual is the application callback module. &lt;code&gt;StartArgs&lt;/code&gt; is a term provided as argument to the callback function &lt;code&gt;Module:start/2&lt;/code&gt;:</source>
          <target state="translated">포함 애플리케이션 의 &lt;code&gt;mod&lt;/code&gt; 키 값은 &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt; 로 설정해야합니다 . 여기서 &lt;code&gt;Module&lt;/code&gt; 은 일반적으로 애플리케이션 콜백 모듈입니다. &lt;code&gt;StartArgs&lt;/code&gt; 는 콜백 함수 &lt;code&gt;Module:start/2&lt;/code&gt; 에 인수로 제공되는 용어입니다 .</target>
        </trans-unit>
        <trans-unit id="e1d24fa6cc650f3b91539b4d964f2dd68411a599" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">의 값 &lt;code&gt;native&lt;/code&gt; 시간 단위는 다소 시간 값의 품질에 대한 정보를 당신에게 제공하지 않습니다. &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 와 시간 값 의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 에 대한 제한을 설정 하지만 시간 값의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 에 대한 정보는 제공하지 않습니다 . 해상도의 &lt;code&gt;native&lt;/code&gt; 시간 단위와 시간 값의 해상도는 크게 다를 수있다.</target>
        </trans-unit>
        <trans-unit id="75115f0cbc11f2e0c976711bd383faef47f72f73" translate="yes" xml:space="preserve">
          <source>The value of the Kernel configuration parameter &lt;code&gt;logger&lt;/code&gt; is a list of tuples. It is possible to write the term on the command line when starting an erlang node, but as the term grows, a better approach is to use the system configuration file. See the &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; manual page for more information about this file.</source>
          <target state="translated">커널 구성 매개 변수 &lt;code&gt;logger&lt;/code&gt; 의 값은 튜플 목록입니다. erlang 노드를 시작할 때 명령 행에 용어를 쓸 수 있지만 용어가 커질수록 시스템 구성 파일을 사용하는 것이 더 좋습니다. 참고 항목 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; 이 파일에 대한 자세한 내용은 설명서 페이지를.</target>
        </trans-unit>
        <trans-unit id="4ed44d3d955ffacf489b8abf33f5d265d4032122" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 에 대한 &lt;code&gt;offset&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c25e0afe475bdf7bd456a401767e588d0dff287" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 에 대한 &lt;code&gt;time_designator&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcf4c591c4a3e4e565b4ce6c5bc397552958d5be" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on application level.</source>
          <target state="translated">이 매개 변수의 값은 응용 프로그램 레벨에서 동일한 이름을 가진 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5f26c290284005b85aff4a14161e0e2b51659761" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on system level.</source>
          <target state="translated">이 매개 변수의 값은 시스템 레벨에서 동일한 이름을 가진 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="afeb557b1f15dc186755d5f00deaf5e3432d37f3" translate="yes" xml:space="preserve">
          <source>The value range stated at the top of this function description is technically correct, but &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically.</source>
          <target state="translated">이 함수 설명 상단에 명시된 값 범위는 기술적으로 정확하지만 &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; 은 생성 된 숫자의 통계 분포에 대한 더 나은 설명입니다. 정확히 0.0이 반환되지 않는 한 통계적으로는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de293b0684a913e1bf7ebfb80ee4f6ab7675b8bf" translate="yes" xml:space="preserve">
          <source>The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, at the time the diameter application was started.</source>
          <target state="translated">리턴 된 값은 19680120T031408Z &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 지름 애플리케이션이 시작된 시점에서 지름 시간 () 으로 인코딩 될 수있는 첫 번째 값) 이후의 초 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a55ba7f90cd067fd29a372ba9492df0943f53a10" translate="yes" xml:space="preserve">
          <source>The value specifies a list of source files to be merged with the file being compiled; cf. &lt;code&gt;merge_files/4&lt;/code&gt;.</source>
          <target state="translated">값은 컴파일 할 파일과 병합 할 소스 파일 목록을 지정합니다. cf. &lt;code&gt;merge_files/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f03a18e612b75547971d666854d8f1114a5bb61" translate="yes" xml:space="preserve">
          <source>The values encoded in the fields of generated records depends on the type and number of times the AVP can occur. In particular, an AVP which is specified as occurring exactly once is encoded as a value of the AVP's type while an AVP with any other specification is encoded as a list of values of the AVP's type. The AVP's type is as specified in the AVP definition, the RFC 6733 types being described below.</source>
          <target state="translated">생성 된 레코드의 필드에 인코딩 된 값은 AVP가 발생할 수있는 유형 및 횟수에 따라 다릅니다. 특히 정확히 한 번만 발생하는 것으로 지정된 AVP는 AVP 유형의 값으로 인코딩되고 다른 사양의 AVP는 AVP 유형의 값 목록으로 인코딩됩니다. AVP의 유형은 AVP 정의에 지정된대로 RFC 6733 유형은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="28cbef0507c54b3b51d13679291493de8c4ec6f1" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file and the values in a system configuration file can be overridden directly from the command line:</source>
          <target state="translated">의 값 &lt;code&gt;.app&lt;/code&gt; 시스템 구성 파일의 파일과 값은 명령 줄에서 직접 대체 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="25131865afbeb61db1691607b17034d98faf548c" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file can be overridden by values in a &lt;strong&gt;system configuration file&lt;/strong&gt;. This is a file that contains configuration parameters for relevant applications:</source>
          <target state="translated">의 값 &lt;code&gt;.app&lt;/code&gt; 파일은의 값에 의해 대체 될 수 있습니다 &lt;strong&gt;시스템 구성 파일&lt;/strong&gt; . 이것은 관련 응용 프로그램에 대한 구성 매개 변수가 포함 된 파일입니다.</target>
        </trans-unit>
        <trans-unit id="626a57e5be3f05ed3f7f8f360fb873aeecee8e88" translate="yes" xml:space="preserve">
          <source>The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is &lt;code&gt;index&lt;/code&gt;, the tuple &lt;code&gt;{-1,0}&lt;/code&gt; is returned for values with no corresponding subpattern in the regular expression, but for the other types (&lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;), the values are the empty binary or list, respectively.</source>
          <target state="translated">값 목록은 정규식에없는 색인 또는 이름을 지정할 수 있으며,이 경우 반환 값은 유형에 따라 다릅니다. type이 &lt;code&gt;index&lt;/code&gt; 인 경우 정규식에서 해당하는 서브 패턴이없는 값에 대해 튜플 &lt;code&gt;{-1,0}&lt;/code&gt; 이 리턴되지만 다른 유형 ( &lt;code&gt;binary&lt;/code&gt; 및 &lt;code&gt;list&lt;/code&gt; )의 경우 값은 각각 빈 2 진 또는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="863d5cefc2b644473a83e6d5a4a11ff192199273" translate="yes" xml:space="preserve">
          <source>The values of each ASN.1 type have their own representation in Erlang, as described in the following sections. Users must provide these values for encoding according to the representation, as shown in the following example:</source>
          <target state="translated">각 ASN.1 유형의 값은 다음 섹션에 설명 된대로 Erlang에서 고유 한 표현을 갖습니다. 사용자는 다음 예제와 같이 표현에 따라 인코딩에 이러한 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cda52f885cae0f363921f91bfa5571c49510a4d" translate="yes" xml:space="preserve">
          <source>The values of the largest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">가장 큰 &lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt; 블록 캐리어 크기 ( lmbcs )의 값</target>
        </trans-unit>
        <trans-unit id="dcd3ad0ab905a987c601beb85b07dfe07ff7ed75" translate="yes" xml:space="preserve">
          <source>The values of the previously listed thresholds can be specified by the user. This way, a handler can be configured to, for example, not drop or flush messages unless the message queue length of the handler process grows extremely large. Notice that large amounts of memory can be required for the node under such circumstances. Another example of user configuration is when, for performance reasons, the client processes must never be blocked by synchronous log requests. It is possible, perhaps, that dropping or flushing events is still acceptable, since it does not affect the performance of the client processes sending the log events.</source>
          <target state="translated">이전에 나열된 임계 값은 사용자가 지정할 수 있습니다. 이런 식으로 처리기는 처리기 프로세스의 메시지 큐 길이가 너무 커지지 않는 한 메시지를 삭제하거나 플러시하지 않도록 구성 할 수 있습니다. 이러한 상황에서는 노드에 많은 양의 메모리가 필요할 수 있습니다. 사용자 구성의 또 다른 예는 성능상의 이유로 클라이언트 프로세스가 동기식 로그 요청으로 차단되어서는 안되는 경우입니다. 로그 이벤트를 보내는 클라이언트 프로세스의 성능에 영향을 미치지 않으므로 이벤트 삭제 또는 플러시가 여전히 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d445c310ac867e11827b280d08f4096d3c3c12" translate="yes" xml:space="preserve">
          <source>The values stored when &lt;code&gt;put&lt;/code&gt; is evaluated within the scope of a &lt;code&gt;catch&lt;/code&gt; are not retracted if a &lt;code&gt;throw&lt;/code&gt; is evaluated, or if an error occurs.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 평가하거나 오류가 발생하면 &lt;code&gt;catch&lt;/code&gt; 범위 내에서 &lt;code&gt;put&lt;/code&gt; 을 평가할 때 저장된 값 이 취소되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0e48d6dd38ad6c9102722d33252c5ae65615ba8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;$ERL_TOP&lt;/code&gt; will be mentioned a lot of times. It refers to the top directory in the source tree. More information about &lt;code&gt;$ERL_TOP&lt;/code&gt; can be found in the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; section below. If you are building in git you probably want to take a look at the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section below before proceeding.</source>
          <target state="translated">&lt;code&gt;$ERL_TOP&lt;/code&gt; 변수 는 여러 번 언급됩니다. 소스 트리의 최상위 디렉토리를 나타냅니다. &lt;code&gt;$ERL_TOP&lt;/code&gt; 에 대한 자세한 내용은 아래 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; 섹션 에서 확인할 수 있습니다 . git로 빌드하는 경우 계속하기 전에 아래의 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 섹션을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="b71a4a47f8b57681eb67d0f149cf4d7c4811e3e6" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$$'&lt;/code&gt; expands to a list of the values of all bound variables in order (that is, &lt;code&gt;['$1','$2', ...]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'$$'&lt;/code&gt; 변수 는 모든 바인딩 된 변수의 값 목록 (즉, &lt;code&gt;['$1','$2', ...]&lt;/code&gt; )으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9e92c9812c408c5ff3803c9050d025112ca40670" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$_'&lt;/code&gt; expands to the whole &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; term.</source>
          <target state="translated">&lt;code&gt;'$_'&lt;/code&gt; 변수 는 전체 &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; 용어로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="223547b0ee006d68fdeafe7dbabcdb4195ccc06b" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;Bin&lt;/code&gt; must contain a whole number of bytes, because the &lt;code&gt;binary&lt;/code&gt; type defaults to &lt;code&gt;unit:8&lt;/code&gt;. A &lt;code&gt;badarg&lt;/code&gt; exception is generated if &lt;code&gt;Bin&lt;/code&gt; consist of, for example, 17 bits.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 유형의 기본값은 &lt;code&gt;unit:8&lt;/code&gt; 이므로 변수 &lt;code&gt;Bin&lt;/code&gt; 에는 전체 바이트 수가 포함되어야합니다 . &lt;code&gt;badarg&lt;/code&gt; 의 경우, 예외가 발생 &lt;code&gt;Bin&lt;/code&gt; 예를 들면, 17 비트로 구성.</target>
        </trans-unit>
        <trans-unit id="b327cd3ab139aaaeb5479b3a8cd2e03a44cba9d4" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the bit string comprehensions.</source>
          <target state="translated">생성기 패턴의 변수, 함수 문자열의 그림자 변수, 비트 문자열 이해를 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="ba7b76fc37dd4760f96fd86e277ce66335f21492" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the list comprehensions.</source>
          <target state="translated">생성기 패턴의 변수, 함수 절의 그림자 변수, 목록 이해를 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="c3cbd2f6779e41d23e6821f5cc806aa75af8d5cf" translate="yes" xml:space="preserve">
          <source>The variables in the specified test system configuration files are imported for the test.</source>
          <target state="translated">지정된 테스트 시스템 구성 파일의 변수를 테스트 용으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="16b31340c6df5777f901eec1b8dd72202ecc99a3" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;iodata()&lt;/code&gt; that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</source>
          <target state="translated">현재 구현으로 데이터를 최소한으로 복사하는 &lt;code&gt;iodata()&lt;/code&gt; 의 변형 (종종 이진이지만 의존하지는 않음)</target>
        </trans-unit>
        <trans-unit id="7db0c9c9f81aaee69d11da93235542d480ff9436" translate="yes" xml:space="preserve">
          <source>The variants &lt;code&gt;http_bin&lt;/code&gt; and &lt;code&gt;httph_bin&lt;/code&gt; return strings (&lt;code&gt;HttpString&lt;/code&gt;) as binaries instead of lists.</source>
          <target state="translated">변형 &lt;code&gt;http_bin&lt;/code&gt; 및 &lt;code&gt;httph_bin&lt;/code&gt; 은 문자열 ( &lt;code&gt;HttpString&lt;/code&gt; )을 목록 대신 이진으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="386d7a023ddb83a55d49c04d2e00b77bbc947fdc" translate="yes" xml:space="preserve">
          <source>The verb name comes from the observation that it can be used for a pattern-based if-then-else block:</source>
          <target state="translated">동사 이름은 패턴 기반 if-then-else 블록에 사용될 수 있다는 관찰에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="e53a018823f7d0826b490411f9a345448e7e805f" translate="yes" xml:space="preserve">
          <source>The verbs described above provide four different &quot;strengths&quot; of control when subsequent matching fails:</source>
          <target state="translated">위에 설명 된 동사는 후속 일치에 실패 할 때 네 가지 제어 &quot;강도&quot;를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f2b992bf8000e459ed5b0cdc131fc96ec8dcdccf" translate="yes" xml:space="preserve">
          <source>The verification fun is called during the X509-path validation when an error or an extension unknown to the SSL application is encountered. It is also called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. It differentiates between the peer certificate and the CA certificates by using &lt;code&gt;valid_peer&lt;/code&gt; or &lt;code&gt;valid&lt;/code&gt; as second argument to the verification fun. See the &lt;code&gt;public_key User's Guide&lt;/code&gt; for definition of &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; and &lt;code&gt;#'Extension'{}&lt;/code&gt;.</source>
          <target state="translated">SSL 애플리케이션에 알려지지 않은 오류 또는 확장이 발생하면 X509 경로 유효성 검증 중에 검증 기능이 호출됩니다. 사용자 응용 프로그램 경로의 각 인증서에 대한 액세스를 허용하기 위해 경로 유효성 검사에 의해 인증서가 유효한 것으로 간주 될 때도 호출됩니다. &lt;code&gt;valid_peer&lt;/code&gt; 두 번째 인수로 valid_peer 또는 &lt;code&gt;valid&lt;/code&gt; 를 사용하여 피어 인증서와 CA 인증서를 구별합니다 . &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; 및 &lt;code&gt;#'Extension'{}&lt;/code&gt; 의 정의에 대해서는 &lt;code&gt;public_key User's Guide&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1de90c0b2842f11f7973bd5edddedba51c5c85c5" translate="yes" xml:space="preserve">
          <source>The verification fun is to be defined as follows:</source>
          <target state="translated">검증 재미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a7587f36555080700643b0019cdfdef45f4827cd" translate="yes" xml:space="preserve">
          <source>The version is defined by the module attribute &lt;code&gt;vsn&lt;/code&gt;, if any. There is no such attribute in &lt;code&gt;ch3&lt;/code&gt;, so in this case the version is the checksum (a huge integer) of the beam file, an uninteresting value, which is ignored.</source>
          <target state="translated">버전은 &lt;code&gt;vsn&lt;/code&gt; 모듈 속성으로 정의됩니다 (있는 경우). &lt;code&gt;ch3&lt;/code&gt; 에는 이러한 속성이 없으므로이 경우 버전은 빔 파일의 체크섬 (거대한 정수)이며 무관심 값으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6440cebe392d666b5024e49f82c9929c9694517" translate="yes" xml:space="preserve">
          <source>The version numbers differ in your system. Whenever one of the applications included in the script is upgraded, change the script.</source>
          <target state="translated">시스템에서 버전 번호가 다릅니다. 스크립트에 포함 된 응용 프로그램 중 하나가 업그레이드 될 때마다 스크립트를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="81ee8706973e7d65b914ed727a2144141d282b58" translate="yes" xml:space="preserve">
          <source>The version of an application specified in the &lt;code&gt;.rel&lt;/code&gt; file is to be the same as the version specified in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 파일에 지정된 응용 프로그램 의 버전은 &lt;code&gt;.app&lt;/code&gt; 파일에 지정된 버전과 동일해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d2168251640676c1f75844920669340f83623b6f" translate="yes" xml:space="preserve">
          <source>The version of net-if provided by this application makes no use of this data, with one exception: Any tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; may be used by the agent and is therefor &lt;strong&gt;reserved&lt;/strong&gt;.</source>
          <target state="translated">이 응용 프로그램에서 제공하는 net-if 버전은 한 가지 예외를 제외하고이 데이터를 사용하지 않습니다. 원자 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 를 포함하는 모든 튜플 은 에이전트가 사용할 수 있으며 &lt;strong&gt;예약되어&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ae167373b6abecea965d3976c2d1e8cb0f8001" translate="yes" xml:space="preserve">
          <source>The version of the application. In an installed system there may exist several versions of an application. The &lt;code&gt;vsn&lt;/code&gt; parameter controls which version of the application will be chosen.</source>
          <target state="translated">응용 프로그램의 버전입니다. 설치된 시스템에는 여러 버전의 응용 프로그램이있을 수 있습니다. &lt;code&gt;vsn&lt;/code&gt; 애플리케이션의 버전을 선택한다 파라미터 조절기.</target>
        </trans-unit>
        <trans-unit id="0f6691af69660ac2dbeef6458e54f6b092b02a7f" translate="yes" xml:space="preserve">
          <source>The version scheme was changed as of OTP 17.0. This implies that application versions used prior to OTP 17.0 do not adhere to this version scheme. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; is included at the end of this section</source>
          <target state="translated">버전 체계는 OTP 17.0부터 변경되었습니다. 이는 OTP 17.0 이전에 사용 된 응용 프로그램 버전이이 버전 체계를 따르지 않음을 의미합니다. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; 은이 섹션의 끝에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="71667a4b4c466db83cfa8dccda4dd2b33a602563" translate="yes" xml:space="preserve">
          <source>The versions are defined in following RFCs</source>
          <target state="translated">버전은 다음 RFC에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4892e73c1831bf8a3d6b46b7aa415cf267e8507" translate="yes" xml:space="preserve">
          <source>The viewed trace data is normally collected from Erlang trace ports or files.</source>
          <target state="translated">조회 된 추적 데이터는 일반적으로 Erlang 추적 포트 또는 파일에서 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8e60b869b23fc7c125b17fff74830d66f135c3" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_NET_RAW&lt;/code&gt;.</source>
          <target state="translated">가상 머신에는 또한 수퍼 유저 또는 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능이있는 (Linux의 경우) 상승 된 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cc464fdb800c73159385639322d0fc6141087504" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; according to the documentation for &lt;code&gt;setns(2)&lt;/code&gt;. However, during testing also &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; and &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; have proven to be necessary.</source>
          <target state="translated">또한 가상 머신에는 &lt;code&gt;setns(2)&lt;/code&gt; 설명서에 따라 수퍼 유저로 실행하거나 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 기능이있는 (Linux의 경우) 상승 된 권한이 필요합니다 . 그러나 테스트 중에 &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; 및 &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; 도 필요한 것으로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="006ddc155b00e369e7d44f1b15919a8110bdd467" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows and MacOS X.</source>
          <target state="translated">가상 머신은 파일 이름이 UTF-8 (또는 다른 시스템 고유의 유니 코드 인코딩)을 사용하여 인코딩 된 것처럼 파일 이름과 함께 작동합니다. 이것이 유니 코드 인코딩을 적용하는 운영 체제, 즉 Windows 및 MacOS X의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c517daaf8ca72cb9652e4e1b82ea25a6ea34e353" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using the ISO Latin-1 encoding, disallowing Unicode characters with code points &amp;gt; 255.</source>
          <target state="translated">가상 머신은 ISO Latin-1 인코딩을 사용하여 인코딩 된 것처럼 파일 이름을 사용하여 코드 포인트가 255보다 큰 유니 코드 문자를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13ed31f912a0c3756dff51206169f32f13717017" translate="yes" xml:space="preserve">
          <source>The wanted string encoding is specified by &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt;. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from &lt;code&gt;*was&lt;/code&gt;. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from &lt;code&gt;*result&lt;/code&gt;. Both &lt;code&gt;was&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;*result&lt;/code&gt; can differ from &lt;code&gt;want&lt;/code&gt; if &lt;code&gt;want&lt;/code&gt; is a bitwise OR'd combination like &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; or if &lt;code&gt;*result&lt;/code&gt; turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</source>
          <target state="translated">원하는 문자열 인코딩은 &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt; 로 지정됩니다 . 이진 형식 (Latin-1 또는 UTF-8)에 사용 된 원래 인코딩은 &lt;code&gt;*was&lt;/code&gt; 에서 얻을 수 있습니다 . 결과 문자열 (7 비트 ASCII, 라틴 -1 또는 UTF-8)의 인코딩은 &lt;code&gt;*result&lt;/code&gt; 에서 얻을 수 있습니다 . 모두 &lt;code&gt;was&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 될 수 &lt;code&gt;NULL&lt;/code&gt; . &lt;code&gt;*result&lt;/code&gt; 다를 수 있습니다 &lt;code&gt;want&lt;/code&gt; 하면 &lt;code&gt;want&lt;/code&gt; 같은 비트 논리합 조합 &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; 경우 또는 &lt;code&gt;*result&lt;/code&gt; 순수한 7 비트 ASCII로 밝혀 (와 호환 모두 라틴어-1과 UTF-8).</target>
        </trans-unit>
        <trans-unit id="018d5b3762ed16f8137ce9fdaea1d65522f0b4e2" translate="yes" xml:space="preserve">
          <source>The warning for the first clause says that the creation of a sub binary cannot be delayed, because it will be returned. The warning for the second clause says that a sub binary will not be created (yet).</source>
          <target state="translated">첫 번째 절에 대한 경고는 하위 바이너리의 생성이 반환 될 수 있기 때문에 지연 될 수 없음을 나타냅니다. 두 번째 절에 대한 경고는 하위 바이너리가 아직 생성되지 않는다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="5ce61e8b18d0497bc2e9762acc6fdf3697ac3b7b" translate="yes" xml:space="preserve">
          <source>The warning is given if the number of shift/reduce conflicts differs from 2, or if there are reduce/reduce conflicts.</source>
          <target state="translated">이동 / 감소 충돌 수가 2와 다르거 나 감소 / 감소 충돌이있는 경우 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eac3dbbed6bc0bb402c42ed8978c9b0740688aad" translate="yes" xml:space="preserve">
          <source>The warning message will look like this:</source>
          <target state="translated">경고 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ff587868921130f6eb1c6a720b2933f27272e9" translate="yes" xml:space="preserve">
          <source>The warnings detected include:</source>
          <target state="translated">감지 된 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57441a0a1920375468fcb3cda7b741895e7ab716" translate="yes" xml:space="preserve">
          <source>The warnings look as follows:</source>
          <target state="translated">경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bcce3258cf3577717dad6c74c35c711e27cd4cd" translate="yes" xml:space="preserve">
          <source>The way EUnit represents tests and test sets as data is flexible, powerful, and concise. This section describes the representation in detail.</source>
          <target state="translated">데이터가 유연하고 강력하며 간결하기 때문에 EUnit이 테스트 및 테스트 세트를 나타내는 방식입니다. 이 섹션에서는 표현에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="965b7339512f62c1c68183166bad964a056729e8" translate="yes" xml:space="preserve">
          <source>The web-based GUI, Virtual Test Server (VTS), is started with the &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program. From the GUI, you can load configuration files and select directories, suites, and cases to run. You can also state the configuration files, directories, suites, and cases on the command line when starting the web-based GUI.</source>
          <target state="translated">웹 기반 GUI 인 VTS (Virtual Test Server)는 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 프로그램으로 시작됩니다 . GUI에서 구성 파일을로드하고 실행할 디렉토리, 스위트 및 케이스를 선택할 수 있습니다. 웹 기반 GUI를 시작할 때 명령 줄에 구성 파일, 디렉토리, 스위트 및 케이스를 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6550d3349d235f242c72f62c04f437d2ce48c34b" translate="yes" xml:space="preserve">
          <source>The well-known quick sort routine can be written as follows:</source>
          <target state="translated">잘 알려진 빠른 정렬 루틴은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1daf9c055686d26205a86325249ab61a258c6aa6" translate="yes" xml:space="preserve">
          <source>The whole list comprehension must be given to the function &lt;code&gt;qlc:q/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;qlc:q/1&lt;/code&gt; 함수에 전체 목록 이해가 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a700c9c164740d8193a70ef5191bc6f87818b7c6" translate="yes" xml:space="preserve">
          <source>The whole original data chunk attempted to be sent.</source>
          <target state="translated">원본 데이터 청크 전체를 보내려고했습니다.</target>
        </trans-unit>
        <trans-unit id="3f50dc8a9a7232f081e9d82f5c58d1d5ab88774d" translate="yes" xml:space="preserve">
          <source>The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">와일드 카드 문자열은 다음과 같은 &quot;와일드 카드 문자&quot;가 특별한 방식으로 해석된다는 점을 제외하면 일반적인 파일 이름처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="445ca2425df9850fe9ecf76a693661ab20880f20" translate="yes" xml:space="preserve">
          <source>The window is divided into the following five parts:</source>
          <target state="translated">창은 다음 다섯 부분으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="3c5d5fc6a6c1a668ddf6252dfa60f0a768f4fd44" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;LINE&lt;/code&gt; in this section represents an integer, and denotes the number of the line in the source file where the construction occurred. Several instances of &lt;code&gt;LINE&lt;/code&gt; in the same construction can denote different lines.</source>
          <target state="translated">이 섹션에서 &lt;code&gt;LINE&lt;/code&gt; 이라는 단어 는 정수를 나타내며 구성이 발생한 소스 파일의 줄 수를 나타냅니다. 동일한 구성에서 &lt;code&gt;LINE&lt;/code&gt; 의 여러 인스턴스 는 다른 선을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eade7caf0a719386f3ed9bf0405c428ad15ea3eb" translate="yes" xml:space="preserve">
          <source>The workflow is as follows:</source>
          <target state="translated">워크 플로우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9930007b7ab7effc4f3827d9e45f7224f2de6c3" translate="yes" xml:space="preserve">
          <source>The working directory for the Erlang emulator. Must be on a local drive (no network drives are mounted when a service starts). Default working directory for services is &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt;. Debug log files will be placed in this directory.</source>
          <target state="translated">Erlang 에뮬레이터의 작업 디렉토리. 로컬 드라이브에 있어야합니다 (서비스가 시작될 때 네트워크 드라이브가 마운트되지 않음). 서비스의 기본 작업 디렉토리는 &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt; 입니다. 디버그 로그 파일이이 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="256bb673e1707d94ab2537efadaa95bffde4c53b" translate="yes" xml:space="preserve">
          <source>The written string is always &lt;code&gt;NULL&lt;/code&gt;-terminated, unless buffer &lt;code&gt;size&lt;/code&gt; is &amp;lt; &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">버퍼 &lt;code&gt;size&lt;/code&gt; 가 &amp;lt; &lt;code&gt;1&lt;/code&gt; 이 아니면 기록 된 문자열은 항상 &lt;code&gt;NULL&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f7a1436c802ad678039fa82fd904d4269922bbb" translate="yes" xml:space="preserve">
          <source>The wxWidgets-3.1 version should also work if 2.8 compatibility is enabled, add &lt;code&gt;--enable-compat28&lt;/code&gt; to configure commands below.</source>
          <target state="translated">2.8 호환성이 활성화 된 경우 wxWidgets-3.1 버전도 작동해야합니다. &lt;code&gt;--enable-compat28&lt;/code&gt; 을 추가 하여 아래 명령을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8a53a91ff254f2bc93279dc81109c603e90d0d26" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec.</source>
          <target state="translated">xmerl_xpath 모듈은 전체 XPath 1.0 사양을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="119bf8dc786018631b7988a88beda339c2ba800b" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec. XPath expressions typically occur in XML attributes and are used to address parts of an XML document. The grammar is defined in &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt;. The core functions are defined in &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt;.</source>
          <target state="translated">xmerl_xpath 모듈은 전체 XPath 1.0 사양을 처리합니다. XPath 표현식은 일반적으로 XML 속성에서 발생하며 XML 문서의 일부를 처리하는 데 사용됩니다. 문법은 &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt; 에 정의되어 있습니다 . 핵심 기능은 &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0a5d4ec5e9af18ded993eb6992af6fcaadb42e4" translate="yes" xml:space="preserve">
          <source>The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported.</source>
          <target state="translated">zip 모듈은 최대 6.1의 zip 아카이브 버전을 지원합니다. 그러나 비밀번호 보호 및 Zip64는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f89ec6f488689cc3f3700cb5183e203d59254205" translate="yes" xml:space="preserve">
          <source>The | operator can also be used to add a head to a list:</source>
          <target state="translated">| 연산자를 사용하여 목록에 헤드를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40fe3907425ba07df22ef0d6959c2d137d54e469" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;m1&lt;/code&gt; is cover compiled in test run &lt;code&gt;s2&lt;/code&gt;, but not shown in the coverage log. Instead, if &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; is called after both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; test runs are completed, the accumulated result for &lt;code&gt;m1&lt;/code&gt; is available in the cross cover log for test run &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;m1&lt;/code&gt; 은 테스트 실행 &lt;code&gt;s2&lt;/code&gt; 에서 커버 컴파일 되지만 커버리지 로그에는 표시되지 않습니다. 대신 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 테스트 실행이 완료된 후 &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; 가 호출 되면 &lt;code&gt;m1&lt;/code&gt; 에 대한 누적 결과 는 테스트 실행 &lt;code&gt;s1&lt;/code&gt; 의 교차 커버 로그에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a8047a09730147dedb7e9d78a5e192ccf03ab6c4" translate="yes" xml:space="preserve">
          <source>Then go to the cross host system and setup the erlang installed in (4) or (5) to be in your &lt;code&gt;$PATH&lt;/code&gt;. Then go to what previously was &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; and issue the following command.</source>
          <target state="translated">그런 다음 교차 호스트 시스템으로 이동하여 (4) 또는 (5)에 설치된 erlang을 &lt;code&gt;$PATH&lt;/code&gt; 에 설정하십시오 . 그런 다음 이전에 &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; 하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8c63d4c24a80d8a897066cde6b4458486a7ca80" translate="yes" xml:space="preserve">
          <source>Then one column per state is printed with a the percentage of time this thread spent in the state out of it's own real-time. After the thread specific time, the accumulated time for each type of thread is printed in a similar format.</source>
          <target state="translated">그런 다음 상태 당 하나의 열이이 스레드가 자체적으로 실시간 상태에서 소비 한 시간의 백분율로 인쇄됩니다. 스레드 특정 시간이 지나면 각 스레드 유형에 대한 누적 시간이 유사한 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="58043576d5fe13fa1a246436e2e8c6ef745d143f" translate="yes" xml:space="preserve">
          <source>Then proceed as follows:</source>
          <target state="translated">그런 다음 다음과 같이 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="7d9412fbd0462825f974f875c15e384433c2ca1a" translate="yes" xml:space="preserve">
          <source>Then read the trace file and create the raw profile data with &lt;code&gt;fprof:profile()&lt;/code&gt;, or perhaps &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; for non-default filename.</source>
          <target state="translated">그런 다음 추적 파일을 읽고 기본 파일 이름이 아닌 경우 &lt;code&gt;fprof:profile()&lt;/code&gt; 또는 &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; 를 사용하여 원시 프로파일 데이터를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5663aeb9e710685d724afdba3fc67379b487af35" translate="yes" xml:space="preserve">
          <source>Then the compact text version without indentation and with short keywords:</source>
          <target state="translated">그런 다음 들여 쓰기가없고 간단한 키워드가 포함 된 간결한 텍스트 버전 :</target>
        </trans-unit>
        <trans-unit id="139ac9c79449e95e5f9e070852b997046b48832a" translate="yes" xml:space="preserve">
          <source>Then the compact version without indentation and with short keywords:</source>
          <target state="translated">그런 다음 들여 쓰기가없고 키워드가 짧은 컴팩트 버전 :</target>
        </trans-unit>
        <trans-unit id="641d01dad066a8551404d7310477baa1cb6f8772" translate="yes" xml:space="preserve">
          <source>Then the new event handler &lt;code&gt;Handler2&lt;/code&gt; is added and initiated by calling &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Module2&lt;/code&gt; is the callback module of &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module1:terminate/2&lt;/code&gt;. This makes it possible to transfer information from &lt;code&gt;Handler1&lt;/code&gt; to &lt;code&gt;Handler2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 을 호출 하여 새 이벤트 핸들러 &lt;code&gt;Handler2&lt;/code&gt; 를 추가하고 시작합니다 . 여기서 &lt;code&gt;Module2&lt;/code&gt; 는 &lt;code&gt;Handler2&lt;/code&gt; 의 콜백 모듈 이고 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 의 리턴 값입니다 . 이로써에서 정보를 전송 할 수 &lt;code&gt;Handler1&lt;/code&gt; 에 &lt;code&gt;Handler2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c562a001db2c4ae28ac1742e8925ddf8af7163" translate="yes" xml:space="preserve">
          <source>Then the sublists are sorted and the results are combined.</source>
          <target state="translated">그런 다음 하위 목록이 정렬되고 결과가 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="73b24c998d871947414c80ba0ded68c358316e6c" translate="yes" xml:space="preserve">
          <source>Then we continue with the call flow on the destination side:</source>
          <target state="translated">그런 다음 대상 측의 통화 흐름을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="b5acd2104208de4c3faf2546e133d8d457c2a417" translate="yes" xml:space="preserve">
          <source>Then you can add your favorite application my_app to the new PLT:</source>
          <target state="translated">그런 다음 좋아하는 응용 프로그램 my_app를 새 PLT에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31669bbfe7c81803e33f753695ac857feb8b190" translate="yes" xml:space="preserve">
          <source>Then you can proceed as follows:</source>
          <target state="translated">그런 다음 다음과 같이 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78475e203a352f84ea57f7b84f34d9e978f720ec" translate="yes" xml:space="preserve">
          <source>Then you can run it through the export_simple/2 function:</source>
          <target state="translated">그런 다음 export_simple / 2 함수를 통해 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9e10c047b34e0b14a433931956d6784d8af0a2" translate="yes" xml:space="preserve">
          <source>Then you send events to the &lt;code&gt;Collector&lt;/code&gt; with the function &lt;code&gt;et_collector:report_event/6&lt;/code&gt; like this:</source>
          <target state="translated">그런 다음 &lt;code&gt;et_collector:report_event/6&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;Collector&lt;/code&gt; 이벤트를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="32ec0c3065e7c7e83edd0f5ba55760ca9ae6826d" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and specify type &lt;code&gt;{file,File}&lt;/code&gt;.:</source>
          <target state="translated">그런 다음 파일로 인쇄하는 새 핸들러를 추가하십시오. 핸들러 모듈 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 를 사용하고 &lt;code&gt;{file,File}&lt;/code&gt; 유형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff57f64121d7cfa622102225ba9e153cee5fdd8" translate="yes" xml:space="preserve">
          <source>Then, all loaded modules are listed. The following fields exist:</source>
          <target state="translated">그런 다음로드 된 모든 모듈이 나열됩니다. 다음과 같은 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37285406a539aba18b235f1780c7ea66141aed2d" translate="yes" xml:space="preserve">
          <source>Then, an &lt;strong&gt;application specification&lt;/strong&gt; is needed, which is put in an &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt;. Among other things, this file specifies which modules the application consists of and the name of the callback module.</source>
          <target state="translated">그런 다음 &lt;strong&gt;응용 프로그램 스펙&lt;/strong&gt; 이 필요하며 이는 &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt; 있습니다. 무엇보다도이 파일은 애플리케이션이 구성하는 모듈과 콜백 모듈의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6b038b9a866b08fa7aa12d5de74309b996761d25" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;strong&gt;system event&lt;/strong&gt; to be logged or traced, the following function is to be called.</source>
          <target state="translated">그런 다음 각 &lt;strong&gt;시스템 이벤트&lt;/strong&gt; 가 기록되거나 추적 될 때마다 다음 기능이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b2b275200d1a22a2d00f625e244ca1c19bb04f51" translate="yes" xml:space="preserve">
          <source>Then, for the primary application and each included application in top-down, left-to-right order, the application master calls &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; for each phase defined for the primary application, in that order. If a phase is not defined for an included application, the function is not called for this phase and application.</source>
          <target state="translated">그런 다음 기본 애플리케이션과 포함 된 각 애플리케이션을 위에서 아래로, 왼쪽에서 오른쪽 순서로 애플리케이션 마스터 는 기본 애플리케이션에 대해 정의 된 각 단계에 대해 &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; 를 해당 순서대로 호출합니다 . 포함 된 애플리케이션에 대해 단계가 정의되지 않은 경우이 단계 및 애플리케이션에 대해 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bce82c8d0395aa60449fa59c5a8cfb50a252f9b" translate="yes" xml:space="preserve">
          <source>Then, you can use the &lt;code&gt;?Q(Text)&lt;/code&gt; macros in your code to create ASTs or match on existing ASTs. For example:</source>
          <target state="translated">그런 다음 코드에서 &lt;code&gt;?Q(Text)&lt;/code&gt; 매크로를 사용하여 AST를 만들거나 기존 AST에서 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="54025678c0a48ad36d078ae7c486444ea8302d6e" translate="yes" xml:space="preserve">
          <source>There are 146097 days in a 400 year period.</source>
          <target state="translated">400 년 동안 146097 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4922e83fd8840f5a8507bbf756cb975adb85c4c4" translate="yes" xml:space="preserve">
          <source>There are 1461 days in a 4 year period.</source>
          <target state="translated">4 년 동안 1461 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a006b5eea15a1aff01c844f4450c0802ffc7c5a3" translate="yes" xml:space="preserve">
          <source>There are 3 categories of events: &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;internal&lt;/code&gt;.</source>
          <target state="translated">이벤트 범주에는 &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 세 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2631fe7788bb799ec0d53ee0b2da8319a05517e4" translate="yes" xml:space="preserve">
          <source>There are 3 types of timeout events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">상태 머신이 해당 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 사용하여 자체적으로 생성 할 수있는 3 가지 유형의 시간 초과 이벤트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32e2588a4d8a20d2c12320bd314f5979f4fc80b1" translate="yes" xml:space="preserve">
          <source>There are 365 days in an ordinary year.</source>
          <target state="translated">보통 연중 365 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d970b2470b79eb6a87c891f0b7f5a8f224ef200c" translate="yes" xml:space="preserve">
          <source>There are 36524 days in a 100 year period.</source>
          <target state="translated">100 년 동안 36524 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3485b6c23bf0750711aa938792fc3cb9795cf2" translate="yes" xml:space="preserve">
          <source>There are 366 days in a leap year.</source>
          <target state="translated">윤년에는 366 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fe64c83f46614adbd1fbe2801f7f2ef313c16d" translate="yes" xml:space="preserve">
          <source>There are 719528 days between Jan 1, 0 and Jan 1, 1970.</source>
          <target state="translated">1970 년 1 월 1 일과 1 월 1 일 사이에는 719528 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35333b685e5533111f684a33ff4796d2d156cad" translate="yes" xml:space="preserve">
          <source>There are 86400 seconds in a day.</source>
          <target state="translated">하루에 86400 초가 있습니다.</target>
        </trans-unit>
        <trans-unit id="180512e757bce690ec3e5179e5aff8954ea8a216" translate="yes" xml:space="preserve">
          <source>There are a few other shells available, but in all examples below we assume that you use bash.</source>
          <target state="translated">사용 가능한 다른 쉘이 몇 가지 있지만 아래의 모든 예제에서 bash를 사용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1edf8f04e2a157900339e6be967c14131457929f" translate="yes" xml:space="preserve">
          <source>There are a number of BIFs for type conversions.</source>
          <target state="translated">유형 변환을위한 여러 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="242b6cdf7d5bf2f5010f113ba9575096eca5ab25" translate="yes" xml:space="preserve">
          <source>There are a number of configuration parameter's that control the operation of the transaction sender. In principle, a message with everything stored (ack's and request's) is sent from the process when:</source>
          <target state="translated">트랜잭션 송신자의 조작을 제어하는 ​​여러 구성 매개 변수가 있습니다. 원칙적으로 다음과 같은 경우에 저장된 모든 내용 (ack 및 요청)이 포함 된 메시지가 프로세스에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="14ebd1b2612f7ab9a04862c2c58993cbe8294ef0" translate="yes" xml:space="preserve">
          <source>There are also Erlang plugins for other code editors &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt; Atom &lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; and &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">다른 코드 편집기 &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt;Atom&lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; 및 &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 용 Erlang 플러그인도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ab85aacb25c2dac1de9193bd4c1c96c59434beb" translate="yes" xml:space="preserve">
          <source>There are also buttons to clear the contents of each window.</source>
          <target state="translated">각 창의 내용을 지우는 버튼도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e9837f18730715ec49993436d5ae3ed6b58962" translate="yes" xml:space="preserve">
          <source>There are also corresponding trace client types that can read the Erlang trace data format from such files or ports. The &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; function makes use of these Erlang trace clients and redirects the trace data to the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">해당 파일 또는 포트에서 Erlang 추적 데이터 형식을 읽을 수있는 해당 추적 클라이언트 유형도 있습니다. &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; 기능이 얼랑 추적 클라이언트를 사용한다과에 추적 데이터 리디렉션 &lt;code&gt;Collector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c99ca7c6f5a9145961cb429767668ca00d8aa464" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x&lt;/code&gt; use a dynamic buffer.</source>
          <target state="translated">동적 버퍼를 사용하는 인코딩 함수도 있습니다. 이것들을 사용하여 데이터를 인코딩하는 것이 더 편리합니다. 모든 인코딩 기능은 두 가지 버전으로 제공됩니다. &lt;code&gt;ei_x&lt;/code&gt; 로 시작 하는 것은 동적 버퍼를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7c973e8a6ad46963c3452623094e6dbd1de252e5" translate="yes" xml:space="preserve">
          <source>There are also existing functions in the API that reads from various sources and calls &lt;code&gt;et_collector:report/2&lt;/code&gt;:</source>
          <target state="translated">API에는 다양한 소스에서 읽고 &lt;code&gt;et_collector:report/2&lt;/code&gt; 를 호출하는 기존 함수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b0b6ca2d317b12bcab295cfefa25fba1f494f42" translate="yes" xml:space="preserve">
          <source>There are also several open source tools outside of Erlang/OTP that can be used to help profiling. Some of them are:</source>
          <target state="translated">Erlang / OTP 외부에는 프로파일 링을 돕는 데 사용할 수있는 몇 가지 오픈 소스 도구가 있습니다. 그들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="142cde2c5e7c063e8b6e633dcb4d8f992d4a63a0" translate="yes" xml:space="preserve">
          <source>There are also some tools that can be used to get a view of the whole system with more or less overhead.</source>
          <target state="translated">오버 헤드가 더 많거나 적은 전체 시스템을 볼 수있는 도구도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d345e5c9462888e4d0e72da3171fd099f28666f6" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt; 모듈에는 SNMP 메시지의 인코딩 및 디코딩에 유용한 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c12c548107750b36f7254260f1588ab2784f00" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmp_pdus&lt;/code&gt; 모듈에는 SNMP 메시지의 인코딩 및 디코딩에 유용한 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4b5b08a6ea2fb2b0f10fe9a664d0767cb557d8" translate="yes" xml:space="preserve">
          <source>There are also two optional functions that may be exported:</source>
          <target state="translated">내보낼 수있는 두 가지 선택적 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02924d8e6964e4587d120c6a611e73172eec6d8f" translate="yes" xml:space="preserve">
          <source>There are also unary set operators:</source>
          <target state="translated">단항 집합 연산자도 있습니다.</target>
        </trans-unit>
        <trans-unit id="18a4256a63577ca8fbaba2b8f665cf1ca462e6b4" translate="yes" xml:space="preserve">
          <source>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</source>
          <target state="translated">기본적으로 둘 이상의 테이블 복제본을 사용하는 이유는 내결함성과 속도입니다. 테이블 복제는이 두 시스템 요구 사항 모두에 대한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="efcb011fbe2418732f8e84878ff0611edcbe6375" translate="yes" xml:space="preserve">
          <source>There are basically two ways to avoid copying a binary that is sent to a driver:</source>
          <target state="translated">드라이버로 전송되는 바이너리를 복사하지 않으려면 기본적으로 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="427d1b12162110ab82e9ecb95a1e779c90521928" translate="yes" xml:space="preserve">
          <source>There are different ways to run the mstone1 tool, e.g. with or without the use of drivers, with &lt;strong&gt;only&lt;/strong&gt; flex-empowered configs.</source>
          <target state="translated">flex- powerpowered 구성 &lt;strong&gt;만으로&lt;/strong&gt; 드라이버를 사용하거나 사용하지 않고 mstone1 도구를 실행하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83886161e156439b88f864a15f0682e914bef032" translate="yes" xml:space="preserve">
          <source>There are errors in the module.</source>
          <target state="translated">모듈에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2059c62b05489c060b2ff7738b1e0f09fb659b" translate="yes" xml:space="preserve">
          <source>There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern, as described in the previous section.)</source>
          <target state="translated">5 개의 캡처 하위 문자열이 있지만 일치 후에는 하나만 설정됩니다. (이 문제를 해결하는 다른 방법은 이전 섹션에서 설명한대로 &quot;분기 재설정&quot;하위 패턴을 사용하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="33595bb67b93a0d4d29156619db2bde17172f1a9" translate="yes" xml:space="preserve">
          <source>There are five kinds of atomic literals, which are represented in the same way in patterns, expressions, and guards:</source>
          <target state="translated">5 가지 종류의 원자 리터럴이 있으며, 패턴, 표현 및 가드로 같은 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="51d0a41716062d2a82d15d8d350dc23a6b9ec6b3" translate="yes" xml:space="preserve">
          <source>There are five lists exchanged in the connection setup. Three of them are also divided in two directions, to and from the server.</source>
          <target state="translated">연결 설정에서 교환 된 5 개의 목록이 있습니다. 이들 중 3 개는 서버와의 양방향으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="cf8e92c428bfd92f9fbf9d5334e7e6eb53e744e5" translate="yes" xml:space="preserve">
          <source>There are five other standard MIBs, which also may be loaded into the agent. These MIBs are:</source>
          <target state="translated">에이전트에로드 될 수있는 5 개의 다른 표준 MIB가 있습니다. 이러한 MIB는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="152329e6587feacf4160245f8023f9e4b43d1b9a" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the &lt;code&gt;Application dependencies&lt;/code&gt; page. If the application is used by other applications, these are listed under &lt;code&gt;Used by&lt;/code&gt;. If the application requires other applications be started before it can be started, these are listed under &lt;code&gt;Required&lt;/code&gt;. These applications are listed in the &lt;code&gt;applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application includes other applications, these are listed under &lt;code&gt;Included&lt;/code&gt;. These applications are listed in the &lt;code&gt;included_applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application uses other applications, these are listed under &lt;code&gt;Uses&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Application dependencies&lt;/code&gt; 페이지 에는 네 가지 범주의 응용 프로그램이 있습니다 . 다른 응용 프로그램에서 응용 프로그램을 사용하는 경우 다음에 의해 &lt;code&gt;Used by&lt;/code&gt; 아래에 나열 됩니다 . 응용 프로그램을 시작하기 전에 다른 응용 프로그램을 시작해야하는 경우 &lt;code&gt;Required&lt;/code&gt; 아래에 나열됩니다 . 이러한 응용 프로그램은 &lt;code&gt;applications&lt;/code&gt; &lt;code&gt;app&lt;/code&gt; 파일 의 응용 프로그램 부분에 나열되어 있습니다. 응용 프로그램에 다른 응용 프로그램이 포함 된 경우 해당 응용 프로그램이 &lt;code&gt;Included&lt;/code&gt; 아래에 나열됩니다 . 이러한 응용 프로그램은 응용 &lt;code&gt;app&lt;/code&gt; 파일 의 &lt;code&gt;included_applications&lt;/code&gt; 부분에 나열되어 있습니다. 응용 프로그램이 다른 응용 프로그램을 사용하는 경우, 다음은 아래에 나열됩니다 &lt;code&gt;Uses&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d82c54f7bd20fbaa9331c2a4418fb92d7a4c19" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the applications page. &lt;code&gt;Included&lt;/code&gt; contains applications that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains applications that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains applications that either are used directly by explicitly included applications or by other derived applications. &lt;code&gt;Available&lt;/code&gt; contains the remaining applications.</source>
          <target state="translated">응용 프로그램 페이지에는 4 가지 범주의 응용 프로그램이 있습니다. &lt;code&gt;Included&lt;/code&gt; 에는 명시 적으로 포함 된 응용 프로그램이 포함됩니다. &lt;code&gt;Excluded&lt;/code&gt; 에는 명시 적으로 제외 된 응용 프로그램이 포함되어 있습니다. &lt;code&gt;Derived&lt;/code&gt; 에는 명시 적으로 포함 된 응용 프로그램이나 다른 파생 된 응용 프로그램에서 직접 사용하는 응용 프로그램이 포함됩니다. &lt;code&gt;Available&lt;/code&gt; 나머지 응용 프로그램이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68efc29dbc075cb27e8313dd48ca56abcbcbd47" translate="yes" xml:space="preserve">
          <source>There are four categories of modules on the modules page. &lt;code&gt;Included&lt;/code&gt; contains modules that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains modules that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains modules that either are used directly by explicitly included modules or by other derived modules. &lt;code&gt;Available&lt;/code&gt; contains the remaining modules.</source>
          <target state="translated">모듈 페이지에는 네 가지 범주의 모듈이 있습니다. &lt;code&gt;Included&lt;/code&gt; 에는 명시 적으로 포함 된 모듈이 포함됩니다. &lt;code&gt;Excluded&lt;/code&gt; 에는 명시 적으로 제외 된 모듈이 포함되어 있습니다. &lt;code&gt;Derived&lt;/code&gt; 에는 명시 적으로 포함 된 모듈이나 다른 파생 모듈에서 직접 사용되는 모듈이 포함됩니다. &lt;code&gt;Available&lt;/code&gt; 나머지 모듈이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b0337aead7f70c27290d4535794d260d389da6" translate="yes" xml:space="preserve">
          <source>There are four different encodings present during the handling of URIs:</source>
          <target state="translated">URI를 처리하는 동안 다음과 같은 네 가지 인코딩이 있습니다.</target>
        </trans-unit>
        <trans-unit id="413ab333b189c985048445074e9603bae2ba9723" translate="yes" xml:space="preserve">
          <source>There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions.</source>
          <target state="translated">하위 패턴에 대한 참조, 재귀에 대한 참조, DEFINE이라는 의사 조건 및 어설 션의 네 가지 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afecc58bc3779a5734aaac232e18d7916a22144d" translate="yes" xml:space="preserve">
          <source>There are function clauses, if clauses, case clauses, and catch clauses.</source>
          <target state="translated">함수 절, if 절, case 절 및 catch 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72251a5ed304e5df93ccf96c6a4cfa369e458578" translate="yes" xml:space="preserve">
          <source>There are however attacks that are not detected by those checks. Suppose a bad guy has succeded with a DNS infection. Then the client could belive it is connecting to one host but ends up at another but evil one. Though it is evil, it could have a perfectly legal certificate! The certificate has a valid signature, it is not revoked, the certificate chain is not faked and has a trusted root and so on.</source>
          <target state="translated">그러나 해당 검사에서 탐지되지 않은 공격이 있습니다. 나쁜 사람이 DNS 감염에 성공했다고 가정 해 봅시다. 그러면 클라이언트는 한 호스트에 연결되어 있지만 다른 호스트에 연결되지만 악의적 인 호스트가 될 수 있습니다. 사악하지만 완벽하게 법적인 증명서를 가질 수 있습니다! 인증서에 유효한 서명이 있고 해지되지 않았으며 인증서 체인이 위조되지 않았으며 신뢰할 수있는 루트 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3713f84d148979b203b3befe641b4b77769eb559" translate="yes" xml:space="preserve">
          <source>There are limitations to when you can execute time warp unsafe code using this mode. If it is possible to use time warp safe code only, it is &lt;strong&gt;much&lt;/strong&gt; better to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 모드를 사용하여 안전하지 않은 타임 워프 코드를 실행할 수있는 시점에는 제한이 있습니다. 그것은 단지 시간 워프 안전 코드를 사용할 수 있습니다 경우는 &lt;strong&gt;많이&lt;/strong&gt; 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="cd4bd83b271a665a5b58936e70ef38dadf1155ad" translate="yes" xml:space="preserve">
          <source>There are limitations with this transaction mechanism. If complex dependencies exist between variables, for example between &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;day&lt;/code&gt;, another mechanism is needed. Setting the date to 'Feb 31' can be avoided by a somewhat more generic transaction mechanism. You can continue and find more and more complex situations and construct an N-phase set-mechanism. This toolkit only contains a trivial mechanism.</source>
          <target state="translated">이 트랜잭션 메커니즘에는 제한이 있습니다. 변수간에 복잡한 종속성이 존재하는 경우 (예 : &lt;code&gt;month&lt;/code&gt; 와 &lt;code&gt;day&lt;/code&gt; 사이에 ) 다른 메커니즘이 필요합니다. 좀 더 일반적인 트랜잭션 메커니즘으로 날짜를 '2 월 31 일'로 설정하지 않아도됩니다. 점점 더 복잡한 상황을 계속 찾아서 N- 상 설정 메커니즘을 구성 할 수 있습니다. 이 툴킷에는 간단한 메커니즘 만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="439879eaa90ceaba58052efe3928a2c96e71eaa0" translate="yes" xml:space="preserve">
          <source>There are many different ways of writing back references to named subpatterns. The .NET syntax &lt;code&gt;\k{name}&lt;/code&gt; and the Perl syntax &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt; are supported, as is the Python syntax &lt;code&gt;(?P=name)&lt;/code&gt;. The unified back reference syntax in Perl 5.10, in which \g can be used for both numeric and named references, is also supported. The previous example can be rewritten in the following ways:</source>
          <target state="translated">명명 된 하위 패턴에 대한 참조를 다시 쓰는 방법에는 여러 가지가 있습니다. Python 구문 &lt;code&gt;(?P=name)&lt;/code&gt; 과 같이 .NET 구문 &lt;code&gt;\k{name}&lt;/code&gt; 및 Perl 구문 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 이 지원됩니다 . 숫자 및 명명 된 참조 모두에 \ g를 사용할 수있는 Perl 5.10의 통합 된 역 참조 구문도 지원됩니다. 이전 예제는 다음과 같은 방식으로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed05625b139b4d644de6d7f67ce1fa7c2638ef57" translate="yes" xml:space="preserve">
          <source>There are many kinds of test suites. Some concentrate on calling every function or command (in the documented way) in a certain interface. Some others do the same, but use all kinds of illegal parameters, and verify that the server stays alive and rejects the requests with reasonable error codes. Some test suites simulate an application (typically consisting of a few modules of an application), some try to do tricky requests in general, and some test suites even test internal functions with help of special Load Modules on target.</source>
          <target state="translated">많은 종류의 테스트 스위트가 있습니다. 어떤 사람들은 특정 인터페이스에서 모든 기능이나 명령을 (문서화 된 방식으로) 호출하는데 집중합니다. 다른 일부는 동일하지만 모든 종류의 잘못된 매개 변수를 사용하고 서버가 활성 상태를 유지하고 합리적인 오류 코드로 요청을 거부하는지 확인합니다. 일부 테스트 스위트는 애플리케이션 (일반적으로 애플리케이션의 일부 모듈로 구성됨)을 시뮬레이션하고, 일부는 일반적으로 까다로운 요청을 시도하며, 일부 테스트 스위트는 대상의 특수로드 모듈을 사용하여 내부 기능을 테스트하기까지합니다.</target>
        </trans-unit>
        <trans-unit id="7c87c0f774843afd2689dfb3a9a1edad461eb107" translate="yes" xml:space="preserve">
          <source>There are many other BIFs such as &lt;code&gt;trunc&lt;/code&gt;. Only a few BIFs can be used in guards, and you cannot use functions you have defined yourself in guards. (see &lt;code&gt;Guard Sequences&lt;/code&gt;) (For advanced readers: This is to ensure that guards do not have side effects.) Let us play with a few of these functions in the shell:</source>
          <target state="translated">&lt;code&gt;trunc&lt;/code&gt; 와 같은 다른 많은 BIF가 있습니다 . 가드에는 소수의 BIF 만 사용할 수 있으며 가드에서 자신이 정의한 기능은 사용할 수 없습니다. ( &lt;code&gt;Guard Sequences&lt;/code&gt; 참조 ) (고급 독자의 경우 : 가드에 부작용이 없도록하기위한 것입니다.) 쉘에서 다음 기능 중 몇 가지를 가지고 놀도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7ad50dd0c2f864512dffbc3444e8c2dbdeaa7fbe" translate="yes" xml:space="preserve">
          <source>There are many very useful functions in the &lt;code&gt;lists&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;lists&lt;/code&gt; 모듈 에는 매우 유용한 기능이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebf4e0ad405ef3fed32697182bdabfe322f69cbb" translate="yes" xml:space="preserve">
          <source>There are more efficient ways to create tables manually, i.e. to use the module &lt;code&gt;snmp_index&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmp_index&lt;/code&gt; 모듈을 사용하여 테이블을 수동으로 작성하는보다 효율적인 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd92c71af502e8043671a8043ed8709a47495a40" translate="yes" xml:space="preserve">
          <source>There are more specific state-transition actions that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt;return value&lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible state transition actions:</source>
          <target state="translated">콜백 함수가 콜백 함수가 리턴 된 후 &lt;code&gt;gen_statem&lt;/code&gt; 엔진에 명령 할 수있는보다 구체적인 상태 전이 조치가 있습니다 . 이러한 목록을 반환하여 명령하는 &lt;code&gt;actions&lt;/code&gt; 의 &lt;code&gt;return value&lt;/code&gt; 로부터 &lt;code&gt;callback function&lt;/code&gt; . 가능한 상태 전이 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b36a2cfd042d4aa3ef25491b61074f01870dd914" translate="yes" xml:space="preserve">
          <source>There are no errors in the module.</source>
          <target state="translated">모듈에 오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf5c5dc136c77b62a5f73ee583f29675f0867a0a" translate="yes" xml:space="preserve">
          <source>There are no good and explicit ways to declare dependencies, so it can be difficult to see and understand these in test suite code and in test logs.</source>
          <target state="translated">의존성을 선언하는 좋고 명확한 방법은 없으므로 테스트 스위트 코드와 테스트 로그에서이를 이해하고 이해하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79dc22722039d0f06f11ce0ecbb4a728b9b8c1f7" translate="yes" xml:space="preserve">
          <source>There are no restrictions on the number of bits in the tail.</source>
          <target state="translated">테일의 비트 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e0f9557377e4510903384f151fd0ecbad27b195" translate="yes" xml:space="preserve">
          <source>There are obvious dependencies between the listed functions. The server cannot be configured if it has not first been started, a client connot be connectd until the server is properly configured, and so on. If we want to have one test case for each function, we might be tempted to try to always run the test cases in the stated order and carry possible data (identities, handles, and so on) between the cases and therefore introduce dependencies between them.</source>
          <target state="translated">나열된 기능간에 명확한 종속성이 있습니다. 서버가 처음 시작되지 않은 경우 서버를 구성 할 수 없으며 서버가 올바르게 구성 될 때까지 클라이언트가 연결되지 않습니다. 각 기능에 대해 하나의 테스트 케이스를 원한다면, 명시된 순서대로 테스트 케이스를 항상 실행하고 케이스 사이에 가능한 데이터 (ID, 핸들 등)를 전달하여 이들 사이의 종속성을 유발하려는 유혹을받을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="8523e884f51973cbccd87b9cb2dffcddaeb778e9" translate="yes" xml:space="preserve">
          <source>There are often sufficient means to work around the need for test case dependencies. Generally, the problem is related to the state of the System Under Test (SUT). The action of one test case can change the system state. For some other test case to run properly, this new state must be known.</source>
          <target state="translated">테스트 케이스 종속성의 필요성을 해결하기위한 충분한 수단이 종종 있습니다. 일반적으로이 문제는 테스트 대상 시스템 (SUT)의 상태와 관련이 있습니다. 한 테스트 사례의 작업으로 시스템 상태가 변경 될 수 있습니다. 다른 테스트 사례가 제대로 실행 되려면이 새로운 상태를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="e108f06d2e6b2fe834e0d25027b8927df7aa555e" translate="yes" xml:space="preserve">
          <source>There are other types of runtime systems that can be built as well using the similar steps just described.</source>
          <target state="translated">방금 설명한 유사한 단계를 사용하여 빌드 할 수있는 다른 유형의 런타임 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e163c970efe377af5c8f879ce7a54392863fd666" translate="yes" xml:space="preserve">
          <source>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</source>
          <target state="translated">조각난 테이블의 레코드를 노드 풀에 균등하게 분배하는 몇 가지 알고리즘이 있습니다. 아무도 최선이 아니며 응용 프로그램 요구에 달려 있습니다. 다음과 같은 상황의 예에는주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3da498f3aa13476c3eb92930717e01466d88d04f" translate="yes" xml:space="preserve">
          <source>There are several error cases which may prevent an answer from being received and passed to a &lt;code&gt;handle_answer/4&lt;/code&gt; callback:</source>
          <target state="translated">응답이 수신되지 않고 &lt;code&gt;handle_answer/4&lt;/code&gt; 콜백으로 전달되지 못하게하는 몇 가지 오류 사례가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5e18c76899cc79f203e980d3f385f0b37cfdefe" translate="yes" xml:space="preserve">
          <source>There are several implementations provided with the agent: &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt;, &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; and &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt;.</source>
          <target state="translated">에이전트와 함께 제공되는 구현은 &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt; , &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; 및 &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3ff816ccd8ec855be66bcf7ca689d7727faafd3" translate="yes" xml:space="preserve">
          <source>There are several occasions when &lt;code&gt;Mnesia&lt;/code&gt; can detect that the network has been partitioned because of a communication failure, for example:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 통신 실패로 인해 네트워크가 분할되었음을 감지 할 수있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c57bfac8bb05da0f5a10e7726d24981a1293333" translate="yes" xml:space="preserve">
          <source>There are several other process flags, see &lt;code&gt;erlang(3)&lt;/code&gt;. Changing the default behaviour of a process in this way is usually not done in standard user programs, but is left to the supervisory programs in OTP. However, the ping pong program is modified to illustrate exit trapping.</source>
          <target state="translated">다른 프로세스 플래그가 몇 개 있습니다 &lt;code&gt;erlang(3)&lt;/code&gt; 참조 ) . 이런 방식으로 프로세스의 기본 동작 변경은 일반적으로 표준 사용자 프로그램에서는 수행되지 않지만 OTP의 감독 프로그램에는 맡겨집니다. 그러나 핑퐁 프로그램은 출구 트래핑을 설명하기 위해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e75da42e192bf5430b68298e12cdc636289e3c2" translate="yes" xml:space="preserve">
          <source>There are several ways to send a binary created with &lt;code&gt;driver_alloc_binary()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;driver_alloc_binary()&lt;/code&gt; 생성 된 바이너리를 보내는 몇 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="75f05fa20e3e2427a955f3a2446bd3c23ed22b34" translate="yes" xml:space="preserve">
          <source>There are several ways to write a metavariable in your quoted code:</source>
          <target state="translated">인용 코드로 메타 변수를 작성하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82aa827e8118fb053e3d4c4658ad116b8c399af" translate="yes" xml:space="preserve">
          <source>There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows:</source>
          <target state="translated">Windows 레지스트리에는 최상위 키인 6 개의 진입 점이 있습니다. 이 모듈에서는 다음과 같이 약어로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70680607de60b05f98568bdca23a84c98a7353e4" translate="yes" xml:space="preserve">
          <source>There are some new data types in SNMPv2 that are useful in SNMPv1 as well. In the STANDARD-MIB, three data types are defined, &lt;code&gt;RowStatus&lt;/code&gt;, &lt;code&gt;TruthValue&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. These data types are originally defined as textual conventions in SNMPv2-TC (RFC1903).</source>
          <target state="translated">SNMPv2에는 SNMPv1에도 유용한 일부 새로운 데이터 유형이 있습니다. STANDARD-MIB에서는 &lt;code&gt;RowStatus&lt;/code&gt; , &lt;code&gt;TruthValue&lt;/code&gt; 및 &lt;code&gt;DateAndTime&lt;/code&gt; 의 세 가지 데이터 유형이 정의됩니다 . 이러한 데이터 유형은 원래 SNMPv2-TC (RFC1903)에서 텍스트 규칙으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7f436b6808fb57326aab28c43cc3d495d3886b" translate="yes" xml:space="preserve">
          <source>There are three built-in trace patterns: &lt;code&gt;exception_trace&lt;/code&gt;, &lt;code&gt;caller_trace&lt;/code&gt; and &lt;code&gt;caller_exception_trace&lt;/code&gt; (or &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;cx&lt;/code&gt; respectively). Exception trace sets a trace which will show function names, parameters, return values and exceptions thrown from functions. Caller traces display function names, parameters and information about which function called it. An example using a built-in alias:</source>
          <target state="translated">내장 된 추적 패턴에는 &lt;code&gt;exception_trace&lt;/code&gt; , &lt;code&gt;caller_trace&lt;/code&gt; 및 &lt;code&gt;caller_exception_trace&lt;/code&gt; (또는 각각 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;cx&lt;/code&gt; )의 세 가지가 있습니다. 예외 추적은 함수에서 발생한 함수 이름, 매개 변수, 반환 값 및 예외를 표시하는 추적을 설정합니다. 호출자 추적은 함수 이름, 매개 변수 및 호출 한 함수에 대한 정보를 표시합니다. 내장 별명을 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="ce6e977a031f0f78d9783247027132e2871000ad" translate="yes" xml:space="preserve">
          <source>There are three entities: department, employee, and project.</source>
          <target state="translated">부서, 직원 및 프로젝트의 세 가지 엔티티가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95942457dca44926353518936009aaa1a127415" translate="yes" xml:space="preserve">
          <source>There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; is subpattern index 1, &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; is subpattern index 2, and &lt;code&gt;(..d)&lt;/code&gt; is subpattern index 3. When matched against the following string:</source>
          <target state="translated">세 개의 명시 적으로 캡처하는 서브 패턴이 있는데, 여는 괄호 위치가 결과의 순서를 결정하므로 &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; 는 서브 패턴 인덱스 1이고 &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; 는 서브 패턴입니다 인덱스 2 및 &lt;code&gt;(..d)&lt;/code&gt; 는 하위 패턴 인덱스 3입니다. 다음 문자열과 일치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="b9d8071a7cab5fe6bb06cfbf16feb00bf5b9bf05" translate="yes" xml:space="preserve">
          <source>There are three kinds of configuration:</source>
          <target state="translated">구성에는 세 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f596c95045c35d0f6872618b7a800aff23b78f1" translate="yes" xml:space="preserve">
          <source>There are three main reasons for using this mapping:</source>
          <target state="translated">이 매핑을 사용하는 세 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21dcf13609dda19f86b7a0c362b1f37accd05aea" translate="yes" xml:space="preserve">
          <source>There are three relationships between these entities:</source>
          <target state="translated">이 엔티티들 사이에는 세 가지 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6f8a9d2ff844ea14957c3bca79e832dabec9620" translate="yes" xml:space="preserve">
          <source>There are to be no circular dependencies among the applications.</source>
          <target state="translated">응용 프로그램간에 순환 종속성이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a76c3a9ace292c2e0f4031bfd80c3c9f908baded" translate="yes" xml:space="preserve">
          <source>There are to be no duplicated modules, that is, modules with the same name but belonging to different applications.</source>
          <target state="translated">중복 된 모듈, 즉 이름은 같지만 다른 응용 프로그램에 속하는 모듈은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="b018774fca4517707ee8766e662ecc9fb5f61fbf" translate="yes" xml:space="preserve">
          <source>There are to be no undefined applications, that is, dependencies to applications that are not included in the release. (Key &lt;code&gt;applications&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file).</source>
          <target state="translated">정의되지 않은 응용 프로그램, 즉 릴리스에 포함되지 않은 응용 프로그램에 대한 종속성이 없어야합니다. (키 &lt;code&gt;applications&lt;/code&gt; 에서 &lt;code&gt;.app&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="8657af51c1708a2f767083749fec728b2f15dd21" translate="yes" xml:space="preserve">
          <source>There are two Elisp modules included in this tool package for Emacs. There is erlang.el that defines the actual erlang mode and there is erlang-start.el that makes some nice initializations.</source>
          <target state="translated">이맥스 용 툴 패키지에는 2 개의 Elisp 모듈이 포함되어 있습니다. 실제 erlang 모드를 정의하는 erlang.el과 멋진 초기화를 수행하는 erlang-start.el이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4650ca14e027a543e950b128c780c1aff1d2ced2" translate="yes" xml:space="preserve">
          <source>There are two alternatives for &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 에는 두 가지 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8bf9361085b975630319d83556ce12329f9229c" translate="yes" xml:space="preserve">
          <source>There are two basic ways to use the binary encodings: With package related name and termination id transformation (the 'native' encoding config) or without. This transformation converts package related names and termination id's to a more convenient internal form (equivalent with the decoded text message).</source>
          <target state="translated">바이너리 인코딩을 사용하는 두 가지 기본 방법이 있습니다 : 패키지 관련 이름 및 종료 ID 변환 ( '네이티브'인코딩 구성) 또는없는. 이 변환은 패키지 관련 이름과 종료 ID를보다 편리한 내부 형식 (디코딩 된 문자 메시지와 동일)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="dd1db3d75a354d15737e7ae7563e82290092028f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dependencies&lt;/code&gt; 페이지 에는 두 가지 범주의 모듈이 있습니다 . 모듈은 다른 모듈에 의해 사용되는 경우, 이들은 아래에 나열되어 &lt;code&gt;Modules using this&lt;/code&gt; . 모듈이 다른 모듈을 사용하는 경우 &lt;code&gt;Used modules&lt;/code&gt; 아래에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="887d7e8bf421025bcb8d521eeed1d2552d08027f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Module dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module dependencies&lt;/code&gt; 페이지 에는 두 가지 범주의 모듈이 있습니다 . 모듈은 다른 모듈에 의해 사용되는 경우, 이들은 아래에 나열되어 &lt;code&gt;Modules using this&lt;/code&gt; . 모듈이 다른 모듈을 사용하는 경우 &lt;code&gt;Used modules&lt;/code&gt; 아래에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="599878b5a82e164996281429b80e489ea9c477d5" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">C 측에서 Erl_Interface 를 사용할 때 일반 포트만 사용 하는 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 의 예제와 비교하여 두 가지 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23c004d4c8512a14978a320110e39b1a0ff94575" translate="yes" xml:space="preserve">
          <source>There are two different measurement tools:</source>
          <target state="translated">두 가지 측정 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a94aa96b73c7ee440863f41a5aef58bc994511af" translate="yes" xml:space="preserve">
          <source>There are two implementations available:</source>
          <target state="translated">사용 가능한 두 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b217d8aaa3bcdc7db2e259b15d48c394ea4df29" translate="yes" xml:space="preserve">
          <source>There are two kinds of variables: predefined variables and user variables.  &lt;strong id=&quot;predefined_variable&quot;&gt;Predefined variables&lt;/strong&gt; hold set up module data, and cannot be assigned to but only used in queries.  &lt;strong id=&quot;user_variable&quot;&gt;User variables&lt;/strong&gt; on the other hand can be assigned to, and are typically used for temporary results while evaluating a query, and for keeping results of queries for use in subsequent queries. The predefined variables are (variables marked with (*) are available in &lt;code&gt;functions&lt;/code&gt; mode only):</source>
          <target state="translated">사전 정의 된 변수와 사용자 변수의 두 가지 변수가 있습니다. &lt;strong id=&quot;predefined_variable&quot;&gt;사전 정의 된 변수&lt;/strong&gt; 는 설정 모듈 데이터를 보유하며 쿼리에는 할당 할 수 없지만 쿼리에만 사용됩니다. 반면에 &lt;strong id=&quot;user_variable&quot;&gt;사용자 변수&lt;/strong&gt; 는 할당 할 수 있으며 일반적으로 쿼리를 평가하는 동안 임시 결과 및 후속 쿼리에 사용하기 위해 쿼리 결과를 유지하는 데 사용됩니다. 사전 정의 된 변수는 다음과 같습니다 ((*)로 표시된 변수는 &lt;code&gt;functions&lt;/code&gt; 모드에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="51e96249f31fef90280598a64efcee667d150bd9" translate="yes" xml:space="preserve">
          <source>There are two known shortcomings in xmerl:</source>
          <target state="translated">xmerl에는 두 가지 알려진 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0e3ffc28ca1f923c575a2ec112ffd273f7f33c" translate="yes" xml:space="preserve">
          <source>There are two options for handling syntax errors (that is when an unexpected event is received when the digit map evaluator is expecting some other event). The unexpected events may either be ignored or rejected. The latter means that the evaluation is aborted and an error is returned.</source>
          <target state="translated">구문 오류를 처리하기위한 두 가지 옵션이 있습니다 (즉, 숫자 맵 평가자가 다른 이벤트를 예상 할 때 예기치 않은 이벤트가 수신 될 때). 예기치 않은 이벤트는 무시되거나 거부 될 수 있습니다. 후자는 평가가 중단되고 오류가 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e7ea701d75f10ddf239c1c9acff7a8b7f85969f9" translate="yes" xml:space="preserve">
          <source>There are two reasons why &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; are not to be used: they are not efficient, and they prevent the use of key &lt;code&gt;'$end_of_table'&lt;/code&gt;, as this atom is used to indicate the end of the table. If possible, use functions &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; for traversing tables.</source>
          <target state="translated">&lt;code&gt;first/1&lt;/code&gt; 과 &lt;code&gt;next/2&lt;/code&gt; 가 사용되지 않는 데는 두 가지 이유 가 있습니다. 효율적 &lt;code&gt;'$end_of_table'&lt;/code&gt; 원자가 테이블의 끝을 나타내는 데 사용 되므로 '$ end_of_table' 키를 사용하지 못하게 합니다. 가능하면 사용 기능은 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt; 를 , 그리고 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 이송 테이블.</target>
        </trans-unit>
        <trans-unit id="80545dc051cca46852b43329d06d54cf9d266b54" translate="yes" xml:space="preserve">
          <source>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</source>
          <target state="translated">레코드를 읽고, 산술을 수행하고, 레코드를 쓰는 대신이 함수를 사용할 때 두 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad1bd4e1026419dc7de0c5664baefca6532877" translate="yes" xml:space="preserve">
          <source>There are two special cases for the timeout value &lt;code&gt;ExprT&lt;/code&gt;:</source>
          <target state="translated">시간 종료 값 &lt;code&gt;ExprT&lt;/code&gt; 에는 두 가지 특수한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c56d561a526dd7ff6bad858caa6d005781753b5c" translate="yes" xml:space="preserve">
          <source>There are two types of numeric literals, &lt;strong&gt;integers&lt;/strong&gt; and &lt;strong&gt;floats&lt;/strong&gt;. Besides the conventional notation, there are two Erlang-specific notations:</source>
          <target state="translated">숫자 리터럴에는 &lt;strong&gt;integers&lt;/strong&gt; 및 &lt;strong&gt;floats&lt;/strong&gt; 의 두 가지 유형이 있습니다 . 일반적인 표기법 외에 두 가지 Erlang 관련 표기법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c927021e9667cac0b76e4d583b237c1b874a0a" translate="yes" xml:space="preserve">
          <source>There are two types of unique integers both created using the &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF:</source>
          <target state="translated">&lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF를 사용하여 생성 된 두 가지 유형의 고유 정수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adcec4978d9685360563b69cc57cc9c6d0c475d9" translate="yes" xml:space="preserve">
          <source>There are two versions of the &lt;code&gt;server_transfer&lt;/code&gt; function: one with four arguments (&lt;code&gt;server_transfer/4&lt;/code&gt;) and one with five (&lt;code&gt;server_transfer/5&lt;/code&gt;). These are regarded by Erlang as two separate functions.</source>
          <target state="translated">&lt;code&gt;server_transfer&lt;/code&gt; 함수 에는 두 가지 버전이 있습니다. 하나는 인수가 네 &lt;code&gt;server_transfer/4&lt;/code&gt; ( server_transfer / 4 ) 하나는 다섯 개가 있습니다 ( &lt;code&gt;server_transfer/5&lt;/code&gt; ). 이것들은 Erlang에 의해 두 개의 개별 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1b723932d3f965d03f997c2929d90177ac53f1a0" translate="yes" xml:space="preserve">
          <source>There are two ways of shutting down an &lt;code&gt;ssh&lt;/code&gt; daemon, see &lt;strong&gt;Step 5a&lt;/strong&gt; and &lt;strong&gt;Step 5b&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 데몬 을 종료하는 두 가지 방법이 있습니다 ( &lt;strong&gt;5a &lt;/strong&gt;&lt;strong&gt;단계&lt;/strong&gt; 및 &lt;strong&gt;5b 단계&lt;/strong&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="67a5f230cec8e69ad074e79327cb344b91c01c42" translate="yes" xml:space="preserve">
          <source>There are two ways to handle the different megaco encoding versions. Either using &lt;strong&gt;dynamic version detection&lt;/strong&gt; (only valid for for incoming messages) or by &lt;strong&gt;explicit version&lt;/strong&gt; setting in the connection info.</source>
          <target state="translated">다른 megaco 인코딩 버전을 처리하는 두 가지 방법이 있습니다. 어느 사용하여 &lt;strong&gt;동적 버전 감지&lt;/strong&gt; (들어오는 메시지에 대한 유효) 또는에 의해 &lt;strong&gt;명시 적 버전&lt;/strong&gt; 연결 정보에서 설정을.</target>
        </trans-unit>
        <trans-unit id="d9e65fcf80d23dd2690fb225a26bd4c0425947c3" translate="yes" xml:space="preserve">
          <source>There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching.</source>
          <target state="translated">PCRE에서 처리되는 패턴에 주석을 포함시키는 두 가지 방법이 있습니다. 두 경우 모두, 주석의 시작은 문자 클래스 또는 (? : 또는 하위 패턴 이름 또는 번호와 같은 다른 관련 문자 시퀀스의 중간에 있어서는 안됩니다. 주석을 구성하는 문자는 아무런 역할을하지 않습니다. 패턴 일치.</target>
        </trans-unit>
        <trans-unit id="d20c200558da5edbf4cd1004014da1b7247909e5" translate="yes" xml:space="preserve">
          <source>There are two ways to set a timeout for the underlying ssh connection:</source>
          <target state="translated">기본 ssh 연결에 대한 시간 초과를 설정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f355209178288a170c04f2c9a20a04655a8e5d7d" translate="yes" xml:space="preserve">
          <source>There are two ways to start a restricted shell session:</source>
          <target state="translated">제한된 쉘 세션을 시작하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5c659495ea0b68ab11f6dd415042864496550c" translate="yes" xml:space="preserve">
          <source>There are various reasons for using multi-file compilation:</source>
          <target state="translated">다중 파일 컴파일을 사용하는 데는 여러 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bd267d265d01937064d3e1fb0e66e780b2cf5c" translate="yes" xml:space="preserve">
          <source>There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;:</source>
          <target state="translated">동일한 서브 패턴에 대한 역 참조가 둘 이상있을 수 있습니다. 하위 패턴이 특정 일치 항목에서 사용되지 않은 경우 하위 패턴에 대한 역 참조는 항상 실패합니다. 예를 들어, 다음 패턴이 &quot;bc&quot;가 아닌 &quot;a&quot;와 일치하기 시작하면 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="23ffd59215d348fa8988a623fd249aee7018b927" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first parameter has to be an integer() and the last a string().</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 첫 번째 매개 변수는 integer ()이고 마지막은 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1112d47dc0a89deb75a8a7d00a4b483aae845be6" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first three parameters has to be integer()'s and the last three string()'s.</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 처음 세 매개 변수는 integer () 및 마지막 세 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="abdb1ae11dc35da6f7877497944147afcc093ef4" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first two parameters has to be integer()'s and the last two string()'s.</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 처음 두 매개 변수는 integer () 및 마지막 두 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9363b97aec7cf5ddf082ad0d169c592d9050f71" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary pattern. A binary pattern can occur wherever patterns are allowed, including inside other patterns. Binary patterns cannot be nested. The pattern &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; matches a zero length binary.</source>
          <target state="translated">이진 패턴에는 0 개 이상의 세그먼트가있을 수 있습니다. 이진 패턴은 다른 패턴 내부를 포함하여 패턴이 허용되는 모든 곳에서 발생할 수 있습니다. 이진 패턴은 중첩 될 수 없습니다. &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 패턴 은 길이가 0 인 이진과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e406e24fdab0c44cf1156b1456ae80afb50bb754" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary to be constructed. The expression &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; constructs a zero length binary.</source>
          <target state="translated">바이너리에 생성 할 세그먼트가 0 개 이상있을 수 있습니다. &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 표현식 은 길이가 0 인 2 진을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="92428ad0a4bfb32617492b37faa92496b8ccd220" translate="yes" xml:space="preserve">
          <source>There exist a number of other &lt;code&gt;spawn&lt;/code&gt; BIFs, for example, &lt;code&gt;spawn/4&lt;/code&gt; for spawning a process at another node.</source>
          <target state="translated">다른 노드에서 프로세스를 &lt;code&gt;spawn/4&lt;/code&gt; 하기위한 다른 &lt;code&gt;spawn&lt;/code&gt; BIF (예 : spawn / 4) 가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf1452fa6d696c476949e9f9eb92d75ee28307f" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate maps.</source>
          <target state="translated">맵을 조작하기위한 많은 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a19838f7ca93f30ce58e7113784f915faaff575" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate tuples.</source>
          <target state="translated">튜플을 조작하기위한 많은 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71ba36f320e1a48ef1d206a22dd1cb9d13cc9ef" translate="yes" xml:space="preserve">
          <source>There is &lt;strong&gt;no&lt;/strong&gt; automatic mechanism for avoiding priority inversion, such as priority inheritance or priority ceilings. When using priorities, take this into account and handle such scenarios by yourself.</source>
          <target state="translated">우선 순위 상속 또는 우선 순위 상한과 같은 우선 순위 반전을 피하기위한 자동 메커니즘 은 &lt;strong&gt;없습니다&lt;/strong&gt; . 우선 순위를 사용할 때이를 고려하여 직접 이러한 시나리오를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="ea2c52d8c1115defbbd414994b65799bf1261e4f" translate="yes" xml:space="preserve">
          <source>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community string to a &lt;code&gt;contextEngineID&lt;/code&gt; and &lt;code&gt;contextName&lt;/code&gt;. Thus, each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always uniquely identifies a context.</source>
          <target state="translated">커뮤니티 문자열을 &lt;code&gt;contextEngineID&lt;/code&gt; 및 &lt;code&gt;contextName&lt;/code&gt; 에 맵핑하는 MIB, SNMP-COMMUNITY-MIB가 있습니다 . 따라서 SNMPv1, SNMPv2c 또는 SNMPv3 메시지와 같은 각 메시지는 항상 컨텍스트를 고유하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="9ade9e507a62a79d9f797b73458450166ab26545" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 정의 된 기본 호스트 이름 일치 절차 와 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 정의 된 프로토콜 종속 변형이 있습니다. 기본 절차는 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 에 구현되어 있습니다. 옵션 목록을 사용하여 클라이언트가 수정 된 규칙을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57b5d67847213c70927a42448b10614ec369aea" translate="yes" xml:space="preserve">
          <source>There is a scaling problem with this database.</source>
          <target state="translated">이 데이터베이스에 스케일링 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2622c0a39c247fb494769606e0e52cccfb438701" translate="yes" xml:space="preserve">
          <source>There is a set of standard MIBs, which are used to control and configure an SNMP agent. All of these MIBs, with the exception of the optional SNMP-PROXY-MIB (which is only used for proxy agents), are implemented in this agent. Further, it is configurable which of these MIBs are actually loaded, and thus made visible to SNMP managers. For example, in a non-secure environment, it might be a good idea to not make MIBs that define access control visible. Note, the data the MIBs define is used internally in the agent, even if the MIBs not are loaded. This chapter describes these standard MIBs, and some aspects of their implementation.</source>
          <target state="translated">SNMP 에이전트를 제어하고 구성하는 데 사용되는 표준 MIB 세트가 있습니다. 선택적인 SNMP-PROXY-MIB (프록시 에이전트에만 사용됨)를 제외한 모든 MIB는이 에이전트에서 구현됩니다. 또한 이러한 MIB 중 어떤 것이 실제로로드되는지 구성 할 수 있으므로 SNMP 관리자가 볼 수 있습니다. 예를 들어, 비보안 환경에서는 액세스 제어를 정의하는 MIB를 표시하지 않는 것이 좋습니다. MIB가 정의되지 않은 데이터는 MIB가로드되지 않은 경우에도 에이전트에서 내부적으로 사용됩니다. 이 장에서는 이러한 표준 MIB와 그 구현의 일부 측면에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="245adc1cc09d9e8cf3fbaea30fefe11a104de911" translate="yes" xml:space="preserve">
          <source>There is a severe performance penalty in using &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; after any modifying operation is done on that table in the same transaction. That is, avoid using &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;mnesia:select&lt;/code&gt; in the same transaction.</source>
          <target state="translated">동일한 트랜잭션에서 해당 테이블에 대해 수정 작업을 수행 한 후 &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; 를 사용 하면 성능이 저하 됩니다. 즉 , 동일한 트랜잭션에서 &lt;code&gt;mnesia:select&lt;/code&gt; 전에 mnesia : &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; 을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3e3a6368bd3434309374ec5b9d503fef73c80480" translate="yes" xml:space="preserve">
          <source>There is a special case for this field. When the &lt;code&gt;max_retries&lt;/code&gt; has the value &lt;code&gt;infinity_restartable&lt;/code&gt;, it means that the timer is restartable as long as some external event occurs (e.g. receipt of a pending message for instance). But the timer will never be restarted &quot;by itself&quot;, i.e. when the timer expires (whatever the timeout time), so does the timer. Whenever the timer is restarted, the timeout time will be calculated in the usual way! Also, as mentioned above, beware the consequences of setting the value to &lt;code&gt;infinity&lt;/code&gt; if &lt;strong&gt;incr&lt;/strong&gt; has been set to an negative value.</source>
          <target state="translated">이 분야에는 특별한 경우가 있습니다. 때 &lt;code&gt;max_retries&lt;/code&gt; 값 갖는다 &lt;code&gt;infinity_restartable&lt;/code&gt; 를 , 상기 타이머가 긴 일부 외부 이벤트 (예를 들어 계류중인 메시지의 수신 등)를 발생으로 재시작 것을 의미한다. 그러나 타이머는 &quot;자체로&quot;다시 시작되지 않습니다. 즉, 타이머가 만료 될 때 (시간 초과 시간에 관계없이) 타이머도 다시 시작됩니다. 타이머가 다시 시작될 때마다 시간 초과 시간이 일반적인 방식으로 계산됩니다! 또한, 위에서 언급 한 것처럼 &lt;strong&gt;incr&lt;/strong&gt; 이 음수 값으로 설정된 경우 값을 &lt;code&gt;infinity&lt;/code&gt; 로 설정 한 결과에 유의하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="447c2e61ea99ad24abf33df5c7d87ca6d434b459" translate="yes" xml:space="preserve">
          <source>There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom &lt;code&gt;default&lt;/code&gt; instead of the name.</source>
          <target state="translated">&quot;default&quot;값도 있는데,이 문자열은 이름으로 비어 있습니다. 이름 대신 원자 &lt;code&gt;default&lt;/code&gt; 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="2f4ba43d3ad9541719761e12f97fd9eb701de696" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory (e.g. VxWorks). The output on other systems is however still valid, although sparse.</source>
          <target state="translated">시스템 종속 메모리 데이터 인 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 대한 인터페이스도 있습니다 . 결과는 기본 운영 체제에 따라 크게 달라지며 인터페이스는 주로 가상 메모리가없는 시스템 (예 : VxWorks)을 대상으로합니다. 그러나 다른 시스템의 출력은 희소하지만 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7c9bc41f259857156ea8f5d5261fcd25f2b407e3" translate="yes" xml:space="preserve">
          <source>There is also a module &lt;code&gt;make&lt;/code&gt;, which provides a set of functions similar to the UNIX type Make functions, see the &lt;code&gt;make(3)&lt;/code&gt; manual page in Tools.</source>
          <target state="translated">UNIX 유형 Make 기능과 유사한 기능 세트를 제공 하는 모듈 &lt;code&gt;make&lt;/code&gt; 도 있습니다 &lt;code&gt;make(3)&lt;/code&gt; 도구 의 make (3) 매뉴얼 페이지 참조 ) .</target>
        </trans-unit>
        <trans-unit id="0dad695a19ca238ba2a763d955fb786b98d2dc49" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 에 대한 서버 시작 옵션 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; 이 있어 서버를 자동으로 최대 절전 모드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24b3a3437fd8a632ab4bcd78a41f42013e20b72" translate="yes" xml:space="preserve">
          <source>There is also a type test BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt;.</source>
          <target state="translated">형식 테스트 BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa23f797927415980ee4810932d3c90b6953794" translate="yes" xml:space="preserve">
          <source>There is also an API to block or unblock users manually. This API can also list blocked users or users who have been authenticated within a configurable amount of time.</source>
          <target state="translated">사용자를 수동으로 차단하거나 차단 해제하는 API도 있습니다. 이 API는 차단 가능한 사용자 또는 구성 가능한 시간 내에 인증 된 사용자를 나열 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7110ad7a4f42b784159bbbf21bed3303346edd8d" translate="yes" xml:space="preserve">
          <source>There is also function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels.</source>
          <target state="translated">&lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 함수도 배포 채널을 통해 데이터를 엄격하게 정렬해야하는 기능에 해당하는 모든 플래그를 비트 단위 또는 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fa8c8dbb4f5b93ed951ec7e3ddcfaace3c9a8bb" translate="yes" xml:space="preserve">
          <source>There is also the single sequence \N, which matches a non-newline character. This is the same as the &quot;.&quot; metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set. Perl also uses \N to match characters by name, but PCRE does not support this.</source>
          <target state="translated">줄 바꾸기가 아닌 문자와 일치하는 단일 시퀀스 \ N도 있습니다. 이것은 &quot;.&quot;와 동일합니다. &lt;code&gt;dotall&lt;/code&gt; 이 설정되지 않은 경우 메타 문자 . Perl은 \ N을 사용하여 이름별로 문자를 일치 시키지만 PCRE는이를 지원하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
