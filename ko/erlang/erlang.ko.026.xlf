<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="1d1e8ed0c63bea5501f0e18a8588004e6a97f424" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into two lists according to &lt;code&gt;Pred&lt;/code&gt;. &lt;code&gt;splitwith/2&lt;/code&gt; behaves as if it is defined as follows:</source>
          <target state="translated">&lt;code&gt;Pred&lt;/code&gt; 에 따라 파티션 &lt;code&gt;List&lt;/code&gt; 을 두 목록 으로 나눕니다 . &lt;code&gt;splitwith/2&lt;/code&gt; 는 다음과 같이 정의 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="7a0f34af55f62b96f8e7863f5d8947f87bbe0f4d" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into two lists, where the first list contains all elements for which &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, and the second list contains all elements for which &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">파티션 &lt;code&gt;List&lt;/code&gt; 을 두 목록 으로 분할 합니다. 첫 번째 목록에는 &lt;code&gt;Pred(Elem)&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 요소가 포함되고 두 번째 목록에는 &lt;code&gt;Pred(Elem)&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 모든 요소가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="be77f796fd8548373af529ca7332cc6d13c15156" translate="yes" xml:space="preserve">
          <source>Parts of certificates can be decoded with &lt;code&gt;public_key:der_decode/2&lt;/code&gt;, using the ASN.1 type of that part. However, an application-specific certificate extension requires application-specific ASN.1 decode/encode-functions. In the recent example, the first value of &lt;code&gt;rdnSequence&lt;/code&gt; is of ASN.1 type &lt;code&gt;'X520CommonName'. ({2,5,4,3} = ?id-at-commonName)&lt;/code&gt;:</source>
          <target state="translated">인증서 부분은 해당 부분의 ASN.1 유형을 사용하여 &lt;code&gt;public_key:der_decode/2&lt;/code&gt; 로 디코딩 할 수 있습니다 . 그러나 응용 프로그램 별 인증서 확장에는 응용 프로그램 별 ASN.1 디코딩 / 인코딩 기능이 필요합니다. 최근 예에서 &lt;code&gt;rdnSequence&lt;/code&gt; 의 첫 번째 값 은 ASN.1 유형 &lt;code&gt;'X520CommonName'. ({2,5,4,3} = ?id-at-commonName)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39f1ccafc930086a1e2f26b171bee188745affe2" translate="yes" xml:space="preserve">
          <source>Pass extra chunks to be stored in the &lt;code&gt;.beam&lt;/code&gt; file. The extra chunks must be a list of tuples with a four byte binary as chunk name followed by a binary with the chunk contents. See &lt;code&gt;beam_lib&lt;/code&gt; for more information.</source>
          <target state="translated">추가 청크를 전달하여 &lt;code&gt;.beam&lt;/code&gt; 파일에 저장 하십시오. 추가 청크는 청크 이름으로 4 바이트 2 진이 있고 청크 내용이있는 2 진이있는 튜플 목록이어야합니다. 자세한 내용은 &lt;code&gt;beam_lib&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0d014bb56599fcece5464b8d5372d0e641b8c1b" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;+Mea config&lt;/code&gt; command-line flag to the Erlang runtime system you are going to use for creation of the allocator configuration. It will disable features that prevent &lt;code&gt;erts_alloc_config&lt;/code&gt; from doing its job. Note, you should &lt;strong&gt;not&lt;/strong&gt; use this flag when using the created configuration. Also note that it is important that you use the same &lt;code&gt;amount of schedulers&lt;/code&gt; when creating the configuration as you are going the use on the system using the configuration.</source>
          <target state="translated">패스 &lt;code&gt;+Mea config&lt;/code&gt; 하면 할당 구성의 생성을 위해 사용하려고하는 얼랑 런타임 시스템에 명령 줄 플래그. &lt;code&gt;erts_alloc_config&lt;/code&gt; 가 작업을 수행 하지 못하게하는 기능을 비활성화합니다 . 작성된 구성을 사용할 때이 플래그를 사용 &lt;strong&gt;하지&lt;/strong&gt; 않아야 합니다. 또한 구성을 사용하여 시스템에서 사용할 때 구성을 작성할 때 동일한 &lt;code&gt;amount of schedulers&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="52a8e49b5b4f355426b2d1b0e4d23c4d22798cb7" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;megaco_receive_handle&lt;/code&gt; to the transport module.</source>
          <target state="translated">패스 &lt;code&gt;megaco_receive_handle&lt;/code&gt; 전송 모듈을.</target>
        </trans-unit>
        <trans-unit id="a12c368fddb9450ed1c838dd29236b5bedef5580" translate="yes" xml:space="preserve">
          <source>Pass the cross compilation variables as command line arguments to &lt;code&gt;configure&lt;/code&gt; using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax.</source>
          <target state="translated">크로스 컴파일 변수를 명령 행 인수로 전달 하여 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 구문을 사용하여 &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15b216add241be5dbff40c5c961c72de3bf72091" translate="yes" xml:space="preserve">
          <source>Passed &quot;as-is&quot; from the &lt;code&gt;{advanced,Extra}&lt;/code&gt; part of the update instruction.</source>
          <target state="translated">업데이트 명령 의 &lt;code&gt;{advanced,Extra}&lt;/code&gt; 부분 에서 &quot;있는 그대로&quot;전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="48905dff7e74ddb13af1cf1fa9519a564cdab569" translate="yes" xml:space="preserve">
          <source>Passed as the first argument to all NIFs. All function arguments passed to a NIF belong to that environment. The return value from a NIF must also be a term belonging to the same environment.</source>
          <target state="translated">모든 NIF에 대한 첫 번째 인수로 전달되었습니다. NIF에 전달 된 모든 함수 인수는 해당 환경에 속합니다. NIF의 리턴 값도 동일한 환경에 속하는 용어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2a480eadd0d94fe624912e0c9231b5b28630f2a3" translate="yes" xml:space="preserve">
          <source>Passes &lt;code&gt;ListIn&lt;/code&gt; through a sequence of substitution/expansion stages. For an &lt;code&gt;aliases&lt;/code&gt; operation, function &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt;substitute_aliases/2&lt;/a&gt;&lt;/code&gt; is applied using the specified list of aliases:</source>
          <target state="translated">패스 &lt;code&gt;ListIn&lt;/code&gt; 를 교체 / 신장 단계의 시퀀스를 통해. 들어 &lt;code&gt;aliases&lt;/code&gt; 동작 기능 &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt;substitute_aliases/2&lt;/a&gt;&lt;/code&gt; 는 별칭 지정된 목록을 사용하여 적용된다 :</target>
        </trans-unit>
        <trans-unit id="e5bad30c3f82a8b6ce3c2d80f62cb2189d29b412" translate="yes" xml:space="preserve">
          <source>Passes extra arguments to the emulator startup program &lt;code&gt;erl.exe&lt;/code&gt; (or &lt;code&gt;start_erl.exe&lt;/code&gt;). Arguments that cannot be specified here are &lt;code&gt;-noinput&lt;/code&gt; (&lt;code&gt;StopActions&lt;/code&gt; would not work), &lt;code&gt;-name&lt;/code&gt;, and &lt;code&gt;-sname&lt;/code&gt; (they are specified in any way). The most common use is for specifying cookies and flags to be passed to &lt;code&gt;init:boot()&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;).</source>
          <target state="translated">에뮬레이터 시작 프로그램 &lt;code&gt;erl.exe&lt;/code&gt; (또는 &lt;code&gt;start_erl.exe&lt;/code&gt; )에 추가 인수를 전달합니다 . 여기에 지정할 수없는 인수는 &lt;code&gt;-noinput&lt;/code&gt; ( &lt;code&gt;StopActions&lt;/code&gt; 가 작동하지 않음), &lt;code&gt;-name&lt;/code&gt; 및 &lt;code&gt;-sname&lt;/code&gt; 입니다 ( 어쨌든 지정됨 ). 가장 일반적인 용도는 쿠키와 플래그를 &lt;code&gt;init:boot()&lt;/code&gt; ( &lt;code&gt;-s&lt;/code&gt; ) 로 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="17423ed9634ebf487daeddd08024ea098b0dfac8" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;msg_env&lt;/code&gt; as &lt;code&gt;NULL&lt;/code&gt; is only supported as from ERTS 8.0 (Erlang/OTP 19).</source>
          <target state="translated">&lt;code&gt;msg_env&lt;/code&gt; 를 &lt;code&gt;NULL&lt;/code&gt; 로 전달하는 것은 ERTS 8.0 (Erlang / OTP 19)에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="05b52936612a6b19fd4936a6190ec91e1270fc3f" translate="yes" xml:space="preserve">
          <source>Passing the others on to an enclosing &lt;code&gt;try&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt;, or to default error handling.</source>
          <target state="translated">다른 것들을 둘러싼 &lt;code&gt;try&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 또는 기본 오류 처리로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c3441c01856bc44f16f44713579f9eb0b9cab8a3" translate="yes" xml:space="preserve">
          <source>Password-protected and encrypted archives are not supported.</source>
          <target state="translated">비밀번호로 보호되고 암호화 된 아카이브는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3606fd7f334a9c3d48f5825a16e88b15b8c73b" translate="yes" xml:space="preserve">
          <source>Pasted text is inserted at the current prompt position and is interpreted by Erlang as usual keyboard input.</source>
          <target state="translated">붙여 넣은 텍스트는 현재 프롬프트 위치에 삽입되며 Erlang은 일반적인 키보드 입력으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="bae50870edf6016cbfd2f917e452b9a16dcd7599" translate="yes" xml:space="preserve">
          <source>Patches are either released as maintenance patch packages or emergency patch packages. The only difference is that maintenance patch packages are planned and usually contain more changes than emergency patch packages. Emergency patch packages are released to solve one or more specific issues when such are discovered.</source>
          <target state="translated">패치는 유지 보수 패치 패키지 또는 응급 패치 패키지로 릴리스됩니다. 유일한 차이점은 유지 관리 패치 패키지가 계획되어 있으며 일반적으로 응급 패치 패키지보다 더 많은 변경 사항이 포함되어 있다는 것입니다. 응급 패치 패키지는 발견 될 때 하나 이상의 특정 문제를 해결하기 위해 릴리스됩니다.</target>
        </trans-unit>
        <trans-unit id="8160b1ab2039239aefde8cb0e11cb5ebe2e0ad8b" translate="yes" xml:space="preserve">
          <source>Patching applications is a one-way process. Create a backup of your OTP installation directory before proceeding.</source>
          <target state="translated">패치 응용 프로그램은 단방향 프로세스입니다. 계속하기 전에 OTP 설치 디렉토리의 백업을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="55c14b77f9d8f42c4e27a07e774f4f8fb65cbb79" translate="yes" xml:space="preserve">
          <source>Path P is &lt;strong id=&quot;simple_path&quot;&gt;simple&lt;/strong&gt; if all vertices are distinct, except that the first and the last vertices can be the same.</source>
          <target state="translated">첫 번째와 마지막 정점이 동일 할 수 있다는 점을 제외하고 모든 정점이 구별되는 경우 경로 P는 &lt;strong id=&quot;simple_path&quot;&gt;간단&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e97f14f2f6a2a22960aaaf716fd64dd488ed83" translate="yes" xml:space="preserve">
          <source>Path P is a &lt;strong id=&quot;cycle&quot;&gt;cycle&lt;/strong&gt; if the length of P is not zero and v[1] = v[k].</source>
          <target state="translated">P 의 길이가 0이 아니고 v [1] = v [k] 인 경우 경로 P는 &lt;strong id=&quot;cycle&quot;&gt;주기&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec4b3c7aff6a8f5ca4aa618fd7283506da7262b5" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded CA certificates. The CA certificates are used during server authentication and when building the client certificate chain.</source>
          <target state="translated">PEM으로 인코딩 된 CA 인증서가 포함 된 파일의 경로입니다. CA 인증서는 서버 인증 및 클라이언트 인증서 체인을 구축 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e90e566c06157343897915883777d52efdf4c086" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded CA certificates. The CA certificates are used to build the server certificate chain and for client authentication. The CAs are also used in the list of acceptable client CAs passed to the client when a certificate is requested. Can be omitted if there is no need to verify the client and if there are no intermediate CAs for the server certificate.</source>
          <target state="translated">PEM으로 인코딩 된 CA 인증서가 포함 된 파일의 경로입니다. CA 인증서는 서버 인증서 체인을 구축하고 클라이언트 인증을 위해 사용됩니다. CA는 인증서가 요청 될 때 클라이언트에 전달 된 허용 가능한 클라이언트 CA 목록에도 사용됩니다. 클라이언트를 확인할 필요가없고 서버 인증서에 대한 중간 CA가없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a605e96cddb300d711887a44f810e2c399109734" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded Diffie Hellman parameters to be used by the server if a cipher suite using Diffie Hellman key exchange is negotiated. If not specified, default parameters are used.</source>
          <target state="translated">Diffie Hellman 키 교환을 사용하는 암호 스위트가 협상 된 경우 서버에서 사용할 PEM 인코딩 Diffie Hellman 매개 변수가 포함 된 파일의 경로입니다. 지정하지 않으면 기본 매개 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eac8a20a2d9480ebb53700b4e9bedee92d37f637" translate="yes" xml:space="preserve">
          <source>Path to a file containing the user certificate.</source>
          <target state="translated">사용자 인증서가 포함 된 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="1e962d8338f96f1e74e511aa7a15c1b3d987bd58" translate="yes" xml:space="preserve">
          <source>Path to the file containing the user's private PEM-encoded key. As PEM-files can contain several entries, this option defaults to the same file as given by option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">사용자의 개인 PEM 인코딩 키가 포함 된 파일의 경로입니다. PEM 파일에는 여러 항목이 포함될 수 &lt;code&gt;certfile&lt;/code&gt; 옵션의 기본값은 certfile 옵션에서 제공 한 것과 동일한 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="8fcabcda1f4e1160624d33fb2f5784f5c63030cc" translate="yes" xml:space="preserve">
          <source>PathList is a list of directories to search when fetching files. If the file in question is not in the fetch_path, the URI will be used as a file name.</source>
          <target state="translated">PathList는 파일을 가져올 때 검색 할 디렉토리 목록입니다. 문제의 파일이 fetch_path에 없으면 URI가 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47482e00ecdde046c872e760861acd107da31305" translate="yes" xml:space="preserve">
          <source>Paths to keys are left to right, with subkeys to the right and backslash between keys. (Remember that backslashes must be doubled in Erlang strings.) Case is preserved but not significant.</source>
          <target state="translated">키에 대한 경로는 왼쪽에서 오른쪽으로, 하위 키는 오른쪽으로, 키 사이에는 백 슬래시가 있습니다. Erlang 문자열에서는 백 슬래시를 두 배로 늘려야합니다. 대소 문자는 유지되지만 중요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">패턴 매칭</target>
        </trans-unit>
        <trans-unit id="07df831a704cd0fc47532246baa7f29146388369" translate="yes" xml:space="preserve">
          <source>Pattern matching in function head as well as in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt; clauses are optimized by the compiler. With a few exceptions, there is nothing to gain by rearranging clauses.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt; 절 뿐만 아니라 함수 헤드에서도 패턴 일치가 컴파일러에 의해 최적화됩니다. 몇 가지 예외가 있지만 조항을 재정렬하여 얻을 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e33f96bb1810cf2a758f0574bbb8ca910eec1915" translate="yes" xml:space="preserve">
          <source>Pattern matching with records is very similar to creating records. For example, inside a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt;:</source>
          <target state="translated">레코드와 패턴 일치는 레코드 작성과 매우 유사합니다. 예를 들어, &lt;code&gt;case&lt;/code&gt; 내부 또는 &lt;code&gt;receive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b4cf89b5b26547550456e5e4f643ae53f5d29be" translate="yes" xml:space="preserve">
          <source>Pattern variables &lt;code&gt;'$N'&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt;=0,1,...</source>
          <target state="translated">패턴 변수 &lt;code&gt;'$N'&lt;/code&gt; , 여기서 &lt;code&gt;N&lt;/code&gt; = 0,1, ...</target>
        </trans-unit>
        <trans-unit id="98d00def036dd2fd6e93404dff53fcc8b8b39938" translate="yes" xml:space="preserve">
          <source>Patterns are allowed in clause heads, &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt; expressions, and match expressions.</source>
          <target state="translated">절 머리글, &lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt; 표현식 에서 패턴을 사용할 수 있으며 표현식을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6af09a32bdb3adae271bf8a9bea0cb4b9c66dda2" translate="yes" xml:space="preserve">
          <source>Pau_Cin_Hau</source>
          <target state="translated">Pau_Cin_Hau</target>
        </trans-unit>
        <trans-unit id="49ed482e870cd614e256519cffa6b9161630c632" translate="yes" xml:space="preserve">
          <source>Pause call count tracing for all functions in all modules and stop it for all functions in modules to be loaded. This is the same as &lt;code&gt;(pause({'_','_','_'})+stop({on_load}))&lt;/code&gt;.</source>
          <target state="translated">모든 모듈의 모든 기능에 대해 호출 수 추적을 일시 중지하고 모듈의 모든 기능이로드되도록 중지하십시오. 이것은 &lt;code&gt;(pause({'_','_','_'})+stop({on_load}))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2db0d11168e0cf244f7875ac1346e7b6c97f62cc" translate="yes" xml:space="preserve">
          <source>Pause call counters for matching functions in matching modules. The &lt;code&gt;FS&lt;/code&gt; argument can be used to specify the first argument to &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;. See erlang(3).</source>
          <target state="translated">일치하는 모듈에서 일치하는 기능을 위해 콜 카운터를 일시 중지합니다. &lt;code&gt;FS&lt;/code&gt; 의 인수에 대한 첫 번째 인수를 지정하는 데 사용할 수 있습니다 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; . erlang (3)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="391d516918ec3156c32ea3be943e04f2e2a433a7" translate="yes" xml:space="preserve">
          <source>Pauses the call counters for specified functions. This minimises the impact of code running in the background or in the shell that disturbs the profiling. Call counters are automatically paused when they &quot;hit the ceiling&quot; of the host machine word size. For a 32 bit host the maximum counter value is 2147483647.</source>
          <target state="translated">지정된 기능에 대한 콜 카운터를 일시 중지합니다. 이것은 프로파일 링을 방해하는 백그라운드 또는 쉘에서 실행되는 코드의 영향을 최소화합니다. 콜 카운터는 호스트 기계 단어 크기의 &quot;최고 한도&quot;에 도달하면 자동으로 일시 중지됩니다. 32 비트 호스트의 경우 최대 카운터 값은 2147483647입니다.</target>
        </trans-unit>
        <trans-unit id="cf9afa37f2e5869dc6ad902115a35d4f0c5f630f" translate="yes" xml:space="preserve">
          <source>Peer Connections</source>
          <target state="translated">피어 연결</target>
        </trans-unit>
        <trans-unit id="59488fa72b53c2103f34565feb175db9fb2c4131" translate="yes" xml:space="preserve">
          <source>Peer State Machine</source>
          <target state="translated">피어 스테이트 머신</target>
        </trans-unit>
        <trans-unit id="98ae8b5da563501389aa05d3f2695db094619a3c" translate="yes" xml:space="preserve">
          <source>Peer Table</source>
          <target state="translated">피어 테이블</target>
        </trans-unit>
        <trans-unit id="1bee610f8ffa13f60ce754210a4e3cbf3ffbe983" translate="yes" xml:space="preserve">
          <source>Peer to which the request in question can be sent, preempting the selection of peers having advertised support for the Diameter application in question. Multiple options can be specified, and their order is respected in the candidate lists passed to a subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback.</source>
          <target state="translated">해당 요청을 전송할 수있는 피어로서, 해당 직경 애플리케이션에 대한 광고를 지원하는 피어를 선점합니다. 여러 옵션을 지정할 수 있으며 순서는 후속 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 전달 된 후보 목록에서 고려 됩니다.</target>
        </trans-unit>
        <trans-unit id="84b84620029f6985cb04948713a4f88534fba4df" translate="yes" xml:space="preserve">
          <source>Peer-to-Peer Considerations</source>
          <target state="translated">피어 투 피어 고려 사항</target>
        </trans-unit>
        <trans-unit id="fcd5fc2500f0a1816c7d774f52e29f9431495a7a" translate="yes" xml:space="preserve">
          <source>Peers are only shared with services of the same name for the purpose of sending outgoing requests. Since the value of the &lt;code&gt;&lt;a href=&quot;#application_opt&quot;&gt;application_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;alias&lt;/code&gt;, passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, is the handle for identifying a peer as a suitable candidate, services that share peers must use the same aliases to identify their supported applications. They should typically also configure identical &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt;, since by sharing peer connections they are distributing the implementation of a single Diameter node across multiple Erlang nodes.</source>
          <target state="translated">동료는 발신 요청을 보내기 위해 동일한 이름의 서비스와 만 공유됩니다. &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 에 전달 된 &lt;code&gt;&lt;a href=&quot;#application_opt&quot;&gt;application_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;alias&lt;/code&gt; 값은 피어를 적합한 후보로 식별하는 핸들이므로 피어를 공유하는 서비스는 지원되는 애플리케이션을 식별하기 위해 동일한 별명을 사용해야합니다. 피어 연결을 공유함으로써 여러 Erlang 노드에 단일 직경 노드 구현을 분배하기 때문에 일반적으로 동일한 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83040eadd1e47ac6af77c8ee2d41f0ec18c15f6e" translate="yes" xml:space="preserve">
          <source>Per module to caller</source>
          <target state="translated">발신자에게 모듈 당</target>
        </trans-unit>
        <trans-unit id="2cad7f79a8783eead4b37e0cf84881231114b250" translate="yes" xml:space="preserve">
          <source>Per process to screen/file</source>
          <target state="translated">화면 / 파일로 프로세스 당</target>
        </trans-unit>
        <trans-unit id="15141e26e03178e5d1d620e527c846aa1c625c2d" translate="yes" xml:space="preserve">
          <source>Per process/function to screen/file</source>
          <target state="translated">화면 / 파일에 대한 프로세스 / 기능별</target>
        </trans-unit>
        <trans-unit id="6128679797da16a04d84c728a524e6710fc16bbe" translate="yes" xml:space="preserve">
          <source>Percentage of accumulated waiting time of wall clock time. This percentage can be higher than 100% since accumulated time is from all threads.</source>
          <target state="translated">벽시계 시간의 누적 대기 시간 백분율. 누적 시간이 모든 스레드에서 오기 때문에이 백분율은 100 %보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900a5b77b467253970a850573dc79a89db1e52f1" translate="yes" xml:space="preserve">
          <source>Perform CRL (Certificate Revocation List) verification &lt;code&gt;(public_key:pkix_crls_validate/3)&lt;/code&gt; on all the certificates during the path validation &lt;code&gt;(public_key:pkix_path_validation/3)&lt;/code&gt; of the certificate chain. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인증서 체인 의 경로 유효성 검사 &lt;code&gt;(public_key:pkix_path_validation/3)&lt;/code&gt; 중에 모든 인증서에 대해 CRL (인증서 해지 목록) 확인 &lt;code&gt;(public_key:pkix_crls_validate/3)&lt;/code&gt; 을 수행하십시오 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dfd0566897f67f4a88a10a9ccab4a835f714346" translate="yes" xml:space="preserve">
          <source>Perform a backup of the mib-server data.</source>
          <target state="translated">mib 서버 데이터의 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f5297ab6e77bd5a8f87b119bc54aebb086ae8bf2" translate="yes" xml:space="preserve">
          <source>Perform a backup of the mib-storage table.</source>
          <target state="translated">mib-storage 테이블의 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3df0035ca80e21666d0fd6cd422cbcccdf7b1a" translate="yes" xml:space="preserve">
          <source>Perform a code-change (upgrade or downgrade).</source>
          <target state="translated">코드 변경 (업그레이드 또는 다운 그레이드)을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dcafc54e1058ab12e1726559ee25482e972eb9fa" translate="yes" xml:space="preserve">
          <source>Perform a minimal decode of a megaco message.</source>
          <target state="translated">megaco 메시지의 최소 디코딩을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="794622c63bd34b165ba99166f899c7db08151e43" translate="yes" xml:space="preserve">
          <source>Perform mib server cache gc.</source>
          <target state="translated">mib 서버 캐시 gc를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ffce32cc050ae65e8a2071012a2914617cc171d0" translate="yes" xml:space="preserve">
          <source>Performance suffers when modified timing is enabled. This flag is &lt;strong&gt;only&lt;/strong&gt; intended for testing and debugging.</source>
          <target state="translated">수정 된 타이밍이 활성화되면 성능이 저하됩니다. 이 플래그는 테스트 및 디버깅 &lt;strong&gt;전용&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d4cef1e85e0d8796653ef41a51578e4b550d221" translate="yes" xml:space="preserve">
          <source>Performance tuning. Defaults to &lt;code&gt;false&lt;/code&gt;, in which case an operation that mutates (writes to) the table obtains exclusive access, blocking any concurrent access of the same table until finished. If set to &lt;code&gt;true&lt;/code&gt;, the table is optimized to concurrent write access. Different objects of the same table can be mutated (and read) by concurrent processes. This is achieved to some degree at the expense of memory consumption and the performance of sequential access and concurrent reading.</source>
          <target state="translated">성능 조정 기본값은 &lt;code&gt;false&lt;/code&gt; 이며,이 경우 테이블을 변경 (쓰기)하는 작업은 단독 액세스를 가져 와서 완료 될 때까지 동일한 테이블의 동시 액세스를 차단합니다. &lt;code&gt;true&lt;/code&gt; 로 설정 하면 테이블이 동시 쓰기 액세스에 최적화됩니다. 동일한 테이블의 다른 개체는 동시 프로세스에 의해 변경 (및 읽기) 될 수 있습니다. 이는 메모리 소비와 순차적 액세스 및 동시 읽기 성능을 희생하여 어느 정도 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="4ab94c7cedeb2cfec74773af353f3d78c22eb541" translate="yes" xml:space="preserve">
          <source>Performance tuning. Defaults to &lt;code&gt;false&lt;/code&gt;. When set to &lt;code&gt;true&lt;/code&gt;, the table is optimized for concurrent read operations. When this option is enabled on a runtime system with SMP support, read operations become much cheaper; especially on systems with multiple physical processors. However, switching between read and write operations becomes more expensive.</source>
          <target state="translated">성능 조정 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 로 설정 하면 테이블이 동시 읽기 작업에 최적화됩니다. SMP를 지원하는 런타임 시스템에서이 옵션을 사용하면 읽기 작업이 훨씬 저렴 해집니다. 특히 여러 개의 물리적 프로세서가있는 시스템에서. 그러나 읽기와 쓰기 작업 간 전환이 더 비싸집니다.</target>
        </trans-unit>
        <trans-unit id="24461109bfb38c1846415956b344d29b6573204f" translate="yes" xml:space="preserve">
          <source>Performing the handshakes/cookie verification</source>
          <target state="translated">핸드 셰이크 / 쿠키 확인 수행</target>
        </trans-unit>
        <trans-unit id="4f5f75852079a024445eb45615d781f09840d582" translate="yes" xml:space="preserve">
          <source>Performs CRL validation. It is intended to be called from the verify fun of &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt;pkix_path_validation/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CRL 유효성 검사를 수행합니다. &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt;pkix_path_validation/3&lt;/a&gt;&lt;/code&gt; 의 검증 기능에서 호출하도록되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55946f4b90e3f6fd8ef1498f50ddd3c5f07b68a6" translate="yes" xml:space="preserve">
          <source>Performs a GET operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</source>
          <target state="translated">에이전트에서 GET 조작을 수행합니다. 이 작업에서는로드 된 모든 MIB 객체를 볼 수 있습니다. 에이전트는 마치 관리자로부터 오는 GET 요청 인 것처럼 해당 계측 기능을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="98e445605a9fc3e5f98515d8ffa3a57e6ffd8436" translate="yes" xml:space="preserve">
          <source>Performs a GET-NEXT operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</source>
          <target state="translated">에이전트에서 GET-NEXT 작업을 수행합니다. 이 작업에서는로드 된 모든 MIB 객체를 볼 수 있습니다. 에이전트는 마치 관리자로부터 오는 GET 요청 인 것처럼 해당 계측 기능을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fbfe9d2053799030c3effc383609b21073247735" translate="yes" xml:space="preserve">
          <source>Performs a basic path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; However, CRL validation is done separately by &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3&lt;/a&gt;&lt;/code&gt; and is to be called from the supplied &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; 에 따라 기본 경로 유효성 검증을 수행합니다. 그러나 CRL 유효성 검증은 &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3&lt;/a&gt;&lt;/code&gt; 에 의해 별도로 수행되며 제공된 &lt;code&gt;verify_fun&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9816bd4572d4da2d5254081f508d19359bc0475d" translate="yes" xml:space="preserve">
          <source>Performs a sanity check on the system. If no issues were found, &lt;code&gt;ok&lt;/code&gt; is returned. If issues were found, &lt;code&gt;{failed, Failures}&lt;/code&gt; is returned. All failures found will be part of the &lt;code&gt;Failures&lt;/code&gt; list. Currently defined &lt;code&gt;Failure&lt;/code&gt; elements in the &lt;code&gt;Failures&lt;/code&gt; list:</source>
          <target state="translated">시스템에서 상태 점검을 수행합니다. 문제가 발견되지 않으면 &lt;code&gt;ok&lt;/code&gt; 가 반환됩니다. 문제가 발견되면 &lt;code&gt;{failed, Failures}&lt;/code&gt; 가 반환됩니다. 발견 된 모든 실패는 &lt;code&gt;Failures&lt;/code&gt; 목록의 일부입니다 . &lt;code&gt;Failures&lt;/code&gt; 목록 에서 현재 정의 된 &lt;code&gt;Failure&lt;/code&gt; 요소 :</target>
        </trans-unit>
        <trans-unit id="1be49612d446742e1eb3514b871f56b8a3ce8433" translate="yes" xml:space="preserve">
          <source>Performs a sequence of &lt;code&gt;pread/3&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. Returns &lt;code&gt;{ok, [Data, ...]}&lt;/code&gt; or &lt;code&gt;{error, Reason}&lt;/code&gt;, where each &lt;code&gt;Data&lt;/code&gt;, the result of the corresponding &lt;code&gt;pread&lt;/code&gt;, is either a list or a binary depending on the mode of the file, or &lt;code&gt;eof&lt;/code&gt; if the requested position is beyond end of file.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 효율적인 &lt;code&gt;pread/3&lt;/code&gt; 시퀀스를 한 번의 작업으로 수행합니다 . &lt;code&gt;{ok, [Data, ...]}&lt;/code&gt; 또는 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환합니다 . 여기서 해당 &lt;code&gt;pread&lt;/code&gt; 의 결과 인 각 &lt;code&gt;Data&lt;/code&gt; 는 파일 모드에 따라 목록 또는 이진이거나 요청 된 경우 &lt;code&gt;eof&lt;/code&gt; 입니다 위치가 파일 끝을 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="22bb771fd651389aaadce513456ba74d3fd0ed89" translate="yes" xml:space="preserve">
          <source>Performs a sequence of &lt;code&gt;pwrite/3&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. Returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, {N, Reason}}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of successful writes done before the failure.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 효율적인 &lt;code&gt;pwrite/3&lt;/code&gt; 시퀀스를 한 번의 작업으로 수행합니다 . &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, {N, Reason}}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 실패 전에 완료된 쓰기 수입니다.</target>
        </trans-unit>
        <trans-unit id="280190b61c0c88706d5eded9a13af6f093ee900b" translate="yes" xml:space="preserve">
          <source>Performs a synchronous call to a port. The meaning of &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; depends on the port, that is, on the port driver. Not all port drivers support this feature.</source>
          <target state="translated">포트에 대한 동기 호출을 수행합니다. &lt;code&gt;Operation&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 의 의미는 포트, 즉 포트 드라이버에 따라 다릅니다. 모든 포트 드라이버가이 기능을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="40fc6748b5fbb2d35ce953467a85ef32b1d82a24" translate="yes" xml:space="preserve">
          <source>Performs a synchronous control operation on a port. The meaning of &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; depends on the port, that is, on the port driver. Not all port drivers support this control feature.</source>
          <target state="translated">포트에서 동기 제어 작업을 수행합니다. &lt;code&gt;Operation&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 의 의미는 포트, 즉 포트 드라이버에 따라 다릅니다. 모든 포트 드라이버가이 제어 기능을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="13d765f074145e069c27186fead40fb3ae13c752" translate="yes" xml:space="preserve">
          <source>Performs a syntactic and semantic check of the script file. Warnings and errors (if any) are written to the standard output, but the script will not be run. The exit status is &lt;code&gt;0&lt;/code&gt; if any errors are found, otherwise &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">스크립트 파일의 구문 및 의미 검사를 수행합니다. 경고 및 오류 (있는 경우)는 표준 출력에 기록되지만 스크립트는 실행되지 않습니다. 오류가 발견되면 종료 상태는 &lt;code&gt;0&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;127&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51b00069a7d5cb93226f893911ac7caf2f55b4b0" translate="yes" xml:space="preserve">
          <source>Performs a test of encode and decode of types in &lt;code&gt;Module&lt;/code&gt;. The generated functions are called by this function. This function is useful during test to secure that the generated encode and decode functions as well as the general runtime support work as expected.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 에서 형식의 인코딩 및 디코딩 테스트를 수행합니다 . 생성 된 함수는이 함수에 의해 호출됩니다. 이 기능은 테스트 중에 생성 된 인코딩 및 디코딩 기능과 일반 런타임 지원이 예상대로 작동하는지 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d3b4972ee35b6d2ed6932472f96493c8c99e99ae" translate="yes" xml:space="preserve">
          <source>Performs a user-initiated dump of the local log file. This is usually not necessary, as Mnesia by default manages this automatically. See configuration parameters &lt;code&gt;&lt;a href=&quot;#dump_log_time_threshold&quot;&gt;dump_log_time_threshold&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#dump_log_write_threshold&quot;&gt;dump_log_write_threshold&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 로그 파일의 사용자 시작 덤프를 수행합니다. Mnesia는 기본적으로 이것을 자동으로 관리하므로 일반적으로 필요하지 않습니다. 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#dump_log_time_threshold&quot;&gt;dump_log_time_threshold&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#dump_log_write_threshold&quot;&gt;dump_log_write_threshold&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbce4fd8e8c273fb3d0d070a4bf63febe024097d" translate="yes" xml:space="preserve">
          <source>Performs an asynchronous call. The function &lt;code&gt;async_invoke&lt;/code&gt; is invoked in a thread separate from the emulator thread. This enables the driver to perform time-consuming, blocking operations without blocking the emulator.</source>
          <target state="translated">비동기 호출을 수행합니다. &lt;code&gt;async_invoke&lt;/code&gt; 함수 는 에뮬레이터 스레드와 별도의 스레드에서 호출됩니다. 이를 통해 드라이버는 에뮬레이터를 차단하지 않고 시간이 많이 걸리는 차단 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8e1e45db305e4c65eb358872501f86f5ca41b3" translate="yes" xml:space="preserve">
          <source>Performs an ets/dets matching on the table. See Stdlib documentation, module ets, for a description of &lt;code&gt;Pattern&lt;/code&gt; and the return values.</source>
          <target state="translated">테이블에서 일치하는 ets / dets를 수행합니다. &lt;code&gt;Pattern&lt;/code&gt; 및 리턴 값 에 대한 설명은 Stdlib 문서, 모듈 세트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80ddf1ab4c5a4ace67d0fceb7152a9233f49eec4" translate="yes" xml:space="preserve">
          <source>Performs an identity transformation on Erlang forms, as an example.</source>
          <target state="translated">예를 들어 Erlang 양식에서 ID 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e96ceee5ca669b69ceed3f28a9e634eb2729259c" translate="yes" xml:space="preserve">
          <source>Performs analysis of one or more Cover compiled modules, as specified by &lt;code&gt;Analysis&lt;/code&gt; and &lt;code&gt;Level&lt;/code&gt; (see above), by examining the contents of the internal database.</source>
          <target state="translated">내부 데이터베이스의 내용을 검사하여 &lt;code&gt;Analysis&lt;/code&gt; 및 &lt;code&gt;Level&lt;/code&gt; (위 참조)에 지정된대로 하나 이상의 Cover 컴파일 된 모듈을 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="ef62ac9b7159f229d46fa80ce221a721a030144b" translate="yes" xml:space="preserve">
          <source>Performs bit-wise XOR (exclusive or) on the data supplied.</source>
          <target state="translated">제공된 데이터에 대해 비트 단위 XOR (독점 또는)을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1e4270aba1ba7205d6177c0c6c52d4aee26d94d9" translate="yes" xml:space="preserve">
          <source>Performs command &lt;code&gt;listenv&lt;/code&gt; on the specified Telnet connection and returns the result as a list of key-value pairs.</source>
          <target state="translated">지정된 Telnet 연결에서 명령 &lt;code&gt;listenv&lt;/code&gt; 를 수행 하고 결과를 키-값 쌍의 목록으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1e742f72d48ea0d869f73c425bd3bb42130fb756" translate="yes" xml:space="preserve">
          <source>Performs login of &lt;code&gt;User&lt;/code&gt; with &lt;code&gt;Password&lt;/code&gt; to the account specified by &lt;code&gt;Account&lt;/code&gt;.</source>
          <target state="translated">수행이의 로그인 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Password&lt;/code&gt; 에 의해 지정된 계정에 &lt;code&gt;Account&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61aff80f20917a90cadf86008c298098cf718490" translate="yes" xml:space="preserve">
          <source>Performs login of &lt;code&gt;User&lt;/code&gt; with &lt;code&gt;Password&lt;/code&gt;.</source>
          <target state="translated">수행이의 로그인 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Password&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a3c66dde8a5c3d5e1d69b450f3fb1194e697017" translate="yes" xml:space="preserve">
          <source>Performs possible initializations of the cache and returns a reference to it that is used as parameter to the other API functions. Is called by the cache handling processes &lt;code&gt;init&lt;/code&gt; function, hence putting the same requirements on it as a normal process &lt;code&gt;init&lt;/code&gt; function. This function is called twice when starting the SSL application, once with the role client and once with the role server, as the SSL application must be prepared to take on both roles.</source>
          <target state="translated">캐시의 가능한 초기화를 수행하고 다른 API 함수에 매개 변수로 사용되는 참조를 리턴합니다. 캐시 처리 프로세스 &lt;code&gt;init&lt;/code&gt; 함수에 의해 호출 되므로 일반 프로세스 &lt;code&gt;init&lt;/code&gt; 함수 와 동일한 요구 사항이 적용됩니다 . SSL 응용 프로그램이 두 역할을 모두 수행 할 수 있도록 준비되어야하므로이 기능은 SSL 응용 프로그램을 시작할 때 역할 클라이언트에서 한 번, 역할 서버에서 한 번 두 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e21c5aaeabe015b0a346ede9fe7603c40e3285" translate="yes" xml:space="preserve">
          <source>Performs some checks on the package, for example, checks that all mandatory files are present, and extracts its contents.</source>
          <target state="translated">예를 들어, 모든 필수 파일이 있는지 확인하고 내용을 추출하는 등 패키지에 대한 일부 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d7e17286dfe95065d8a22e3569662aef2ec0170e" translate="yes" xml:space="preserve">
          <source>Performs the SSL/TLS/DTLS server-side handshake.</source>
          <target state="translated">SSL / TLS / DTLS 서버 측 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="de30caaee38c0ba213430dd42690a090335a596f" translate="yes" xml:space="preserve">
          <source>Perhaps you want to do something more arranged for human reading. Suppose that you want to list all different brands in the beginning with links to each group of motorcycles. You also want all motorcycles sorted by brand, then some flashy colors on top of it. Thus you rearrange the order of the elements and put in arbitrary HTML tags. This is possible to do by means of the &lt;code&gt;&lt;a href=&quot;http://www.w3.org/Style/XSL/&quot;&gt;XSL Transformation (XSLT)&lt;/a&gt;&lt;/code&gt; like functionality in xmerl.</source>
          <target state="translated">아마도 당신은 인간의 독서를 위해 더 마련된 것을하고 싶을 것입니다. 처음에 각기 다른 오토바이 그룹에 대한 링크와 함께 모든 다른 브랜드를 나열한다고 가정하십시오. 또한 모든 오토바이를 브랜드별로 정렬 한 다음 화려한 색상을 원합니다. 따라서 요소의 순서를 재정렬하고 임의의 HTML 태그를 넣습니다. 이는 xmerl의 기능과 같은 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/Style/XSL/&quot;&gt;XSL Transformation (XSLT)&lt;/a&gt;&lt;/code&gt; 를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc72f276fa3f20586692a9e869fb89bcfcd032e0" translate="yes" xml:space="preserve">
          <source>Periodically checks the disks. For each disk or partition which uses more than a certain amount of the available space, the alarm &lt;code&gt;{{disk_almost_full, MountedOn}, []}&lt;/code&gt; is set.</source>
          <target state="translated">정기적으로 디스크를 점검하십시오. 사용 가능한 공간을 일정량 이상 사용하는 각 디스크 또는 파티션에 대해 &lt;code&gt;{{disk_almost_full, MountedOn}, []}&lt;/code&gt; 알람 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae86c831bcfb2749ff7edc7ec83510fdd2c53cda" translate="yes" xml:space="preserve">
          <source>Periodically flushes all file trace port clients (see &lt;code&gt;dbg:flush_trace_port/1&lt;/code&gt;). When enabled, the buffers are freed each &lt;code&gt;MSec&lt;/code&gt; millisecond. This option is not allowed with &lt;code&gt;{file, {local, File}}&lt;/code&gt; tracing.</source>
          <target state="translated">모든 파일 추적 포트 클라이언트를 주기적으로 플러시합니다 ( &lt;code&gt;dbg:flush_trace_port/1&lt;/code&gt; 참조 ). 활성화되면 버퍼는 매 &lt;code&gt;MSec&lt;/code&gt; 밀리 초 마다 해제됩니다 . &lt;code&gt;{file, {local, File}}&lt;/code&gt; 추적 에서는 이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c59c25186e0bd17e60b87557f8d70871e9a6d4de" translate="yes" xml:space="preserve">
          <source>Periodically performs a memory check:</source>
          <target state="translated">주기적으로 메모리 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ec9bd9a3791c02544b4da2b4e584f9e54f09f137" translate="yes" xml:space="preserve">
          <source>Peripheral, trace, and debug functionality is at greater risk of being changed in an incompatible way than functionality in the language itself and core libraries used during operation.</source>
          <target state="translated">주변 장치, 추적 및 디버그 기능은 언어 자체의 기능 및 운영 중에 사용되는 핵심 라이브러리보다 호환되지 않는 방식으로 변경 될 위험이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="7d00286c1df2e01196a79a4eb5cbf70766e74af5" translate="yes" xml:space="preserve">
          <source>Peripheral, trace, and debug functionality is at greater risk of removal than functionality in the language itself and core libraries used during operation.</source>
          <target state="translated">주변 장치, 추적 및 디버그 기능은 언어 자체의 기능 및 작동 중에 사용되는 핵심 라이브러리보다 제거 위험이 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="4cdcf1198efb4c7cd76975e49ce37ac8c50b1461" translate="yes" xml:space="preserve">
          <source>Perl 5</source>
          <target state="translated">펄 5</target>
        </trans-unit>
        <trans-unit id="f883526d06ac7dbd60d3aeb0d4a51ea2f54f7ccb" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a feature where each alternative in a subpattern uses the same numbers for its capturing parentheses. Such a subpattern starts with &lt;code&gt;(?|&lt;/code&gt; and is itself a non-capturing subpattern. For example, consider the following pattern:</source>
          <target state="translated">Perl 5.10에서는 하위 패턴의 각 대안이 캡처 괄호에 동일한 숫자를 사용하는 기능을 도입했습니다. 이러한 하위 패턴은 &lt;code&gt;(?|&lt;/code&gt; 시작하며 자체가 캡처되지 않는 하위 패턴입니다. 예를 들어 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b82c2b36892e4b847da5ec02ae07fa7e941783f0" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced some &quot;Special Backtracking Control Verbs&quot;, which are still described in the Perl documentation as &quot;experimental and subject to change or removal in a future version of Perl&quot;. It goes on to say: &quot;Their usage in production code should be noted to avoid problems during upgrades.&quot; The same remarks apply to the PCRE features described in this section.</source>
          <target state="translated">Perl 5.10은 &quot;Special Backtracking Control Verbs&quot;를 도입했으며, Perl 문서에는 여전히 &quot;Perl의 향후 버전에서 실험적이며 변경 또는 제거 될 수 있습니다&quot;라고 설명되어 있습니다. &quot;업그레이드 중 문제를 피하기 위해 프로덕션 코드에서의 사용법에 주목해야합니다.&quot; 이 섹션에 설명 된 PCRE 기능에도 동일한 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e78f523b81d69e2ce697283a6d30d972833c9add" translate="yes" xml:space="preserve">
          <source>Perl and POSIX space are now the same. Perl added VT to its space character set at release 5.18 and PCRE changed at release 8.34.</source>
          <target state="translated">펄과 POSIX 공간은 이제 동일합니다. Perl은 릴리스 5.18에서 공백 문자 세트에 VT를 추가하고 릴리스 8.34에서 PCRE가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="2de73d4e781601af4c1bbb6f2148001448b0732c" translate="yes" xml:space="preserve">
          <source>Perl documents that the use of \K within assertions is &quot;not well defined&quot;. In PCRE, \K is acted upon when it occurs inside positive assertions, but is ignored in negative assertions. Note that when a pattern such as (?=ab\K) matches, the reported start of the match can be greater than the end of the match.</source>
          <target state="translated">펄은 어설 션 내에서 \ K의 사용이 &quot;잘 정의되어 있지 않다&quot;고 문서화했다. PCRE에서 \ K는 포지티브 어설 션 내부에서 발생할 때 작동하지만 네거티브 어설 션에서는 무시됩니다. (? = ab \ K)와 같은 패턴이 일치하면보고 된 일치 시작이 일치 끝보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f68ced8ff5ff018b572b360c5b59d5cb10a9ec8" translate="yes" xml:space="preserve">
          <source>Perl has no direct equivalent of &lt;code&gt;notempty&lt;/code&gt; or &lt;code&gt;notempty_atstart&lt;/code&gt;, but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier &lt;code&gt;/g&lt;/code&gt;. The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with &lt;code&gt;notempty_atstart&lt;/code&gt; and &lt;code&gt;anchored&lt;/code&gt;, and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again.</source>
          <target state="translated">Perl은 &lt;code&gt;notempty&lt;/code&gt; 또는 &lt;code&gt;notempty_atstart&lt;/code&gt; 와 직접적으로 동일 하지는 않지만 split () 함수 내에서 및 modifier &lt;code&gt;/g&lt;/code&gt; 를 사용할 때 빈 문자열의 패턴 일치에 대한 특별한 경우를 만듭니다 . &lt;code&gt;notempty_atstart&lt;/code&gt; 및 &lt;code&gt;anchored&lt;/code&gt; 와 동일한 오프셋에서 일치를 다시 시도한 다음 시작 오프셋을 높이고 (아래 참조) 일반 일치를 다시 시도하여 null 문자열을 일치시킨 후 Perl 동작을 에뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe8e00e55de2ba8dd6ec7b50c079a9f787696c02" translate="yes" xml:space="preserve">
          <source>Perl supports the Posix notation for character classes. This uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports this notation. For example, the following matches &quot;0&quot;, &quot;1&quot;, any alphabetic character, or &quot;%&quot;:</source>
          <target state="translated">Perl은 문자 클래스에 대한 Posix 표기법을 지원합니다. 이것은 대괄호 안에 [:와 :]로 묶인 이름을 사용합니다. PCRE는이 표기법도 지원합니다. 예를 들어, 다음은 &quot;0&quot;, &quot;1&quot;, 알파벳 문자 또는 &quot;%&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="765fb2057a7d0f34aecd0daea653b99ec1e8d5fd" translate="yes" xml:space="preserve">
          <source>Perl uses the syntax (?(&amp;lt;name&amp;gt;)...) or (?('name')...) to test for a used subpattern by name. For compatibility with earlier versions of PCRE, which had this facility before Perl, the syntax (?(name)...) is also recognized.</source>
          <target state="translated">Perl은 구문 (? (&amp;lt;name&amp;gt;) ...) 또는 (? ( 'name') ...)을 사용하여 이름으로 사용 된 하위 패턴을 테스트합니다. Perl 이전에이 기능을 가진 이전 버전의 PCRE와의 호환성을 위해 구문 (? (name) ...)도 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae8f7a8fad341ccb38028f9d0cbbf740e954e88" translate="yes" xml:space="preserve">
          <source>Perl-like regular expressions for Erlang.</source>
          <target state="translated">Erlang에 대한 Perl과 같은 정규식.</target>
        </trans-unit>
        <trans-unit id="863d66a8ea986e9d2766a9fb1020b6a98f7a40ae" translate="yes" xml:space="preserve">
          <source>Permanent Failures</source>
          <target state="translated">영구적 인 실패</target>
        </trans-unit>
        <trans-unit id="5e842f59f65d2bb9be9ae185301ffb374b609927" translate="yes" xml:space="preserve">
          <source>Permanently deletes all replicas of table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Tab&lt;/code&gt; 의 모든 복제본을 영구적으로 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="9d10bab6320387e35667d7efc31ca008974ef6de" translate="yes" xml:space="preserve">
          <source>Permits access to the specified set of nodes.</source>
          <target state="translated">지정된 노드 세트에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cbcc14cf66794a811615925669093ae6f0483b21" translate="yes" xml:space="preserve">
          <source>Persistence. Tables can be coherently kept on disc and in the main memory.</source>
          <target state="translated">고집. 테이블은 디스크와 주 메모리에 일관성있게 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f92e7deab74e37ba55baaec014f2b2842033b9fb" translate="yes" xml:space="preserve">
          <source>Persistent connections are not supported when setting the &lt;code&gt;socket_opts&lt;/code&gt; option. When &lt;code&gt;socket_opts&lt;/code&gt; is not set the current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">&lt;code&gt;socket_opts&lt;/code&gt; 옵션을 설정할 때 지속적인 연결이 지원되지 않습니다 . 때 &lt;code&gt;socket_opts&lt;/code&gt; 는 현재 구현은 동일한 호스트에 요청을 가정 설정되지 않은 포트 조합은 동일한 소켓 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2bee04fabd8ac0fac36ed62f88c0b1f7fc8cfa48" translate="yes" xml:space="preserve">
          <source>Peter's client receives the message in the &lt;code&gt;await_result&lt;/code&gt; function.</source>
          <target state="translated">Peter의 클라이언트는 &lt;code&gt;await_result&lt;/code&gt; 함수 에서 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="a1fbe41a1fd16bc593d390402b8a1d609687aad4" translate="yes" xml:space="preserve">
          <source>Phags_Pa</source>
          <target state="translated">Phags_Pa</target>
        </trans-unit>
        <trans-unit id="6908ab9bda0e225ecfd064a3d987f42cfc69e74c" translate="yes" xml:space="preserve">
          <source>Phoenician</source>
          <target state="translated">Phoenician</target>
        </trans-unit>
        <trans-unit id="816184994301f53e2f7c60336684c53229d3fc02" translate="yes" xml:space="preserve">
          <source>Pick just a few suites</source>
          <target state="translated">스위트 몇 개 선택</target>
        </trans-unit>
        <trans-unit id="f298de9cea75ea5230dda5d9d28b4989aaf746f4" translate="yes" xml:space="preserve">
          <source>Pid</source>
          <target state="translated">Pid</target>
        </trans-unit>
        <trans-unit id="39e4ade84d7c390c8d53a5ae6be8e034ac54f0ea" translate="yes" xml:space="preserve">
          <source>Pid is the pid returned from &lt;code&gt;inets:start/[2,3]&lt;/code&gt;. Can also be retrieved form &lt;code&gt;inets:services/0&lt;/code&gt; and &lt;code&gt;inets:services_info/0&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pid는 &lt;code&gt;inets:start/[2,3]&lt;/code&gt; 에서 반환 된 pid 입니다. &lt;code&gt;inets:services/0&lt;/code&gt; 및 &lt;code&gt;inets:services_info/0&lt;/code&gt; 에서 검색 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="e5a12aecdd3b6ac3a81192c0d891abe00ae128dc" translate="yes" xml:space="preserve">
          <source>Pipelining is only used if the pipeline time-out is set, otherwise persistent connections without pipelining are used. That is, the client always waits for the previous response before sending the next request.</source>
          <target state="translated">파이프 라인 시간 초과가 설정된 경우에만 파이프 라이닝이 사용되며 그렇지 않으면 파이프 라이닝이없는 영구 연결이 사용됩니다. 즉, 클라이언트는 다음 요청을 보내기 전에 항상 이전 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="299afcf56421dc47a2f48e2448670fa6fa1de131" translate="yes" xml:space="preserve">
          <source>Plain arguments are not interpreted in any way. They are also stored by the &lt;code&gt;init&lt;/code&gt; process and can be retrieved by calling &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt;. Plain arguments can occur before the first flag, or after a &lt;code&gt;--&lt;/code&gt; flag. Also, the &lt;code&gt;-extra&lt;/code&gt; flag causes everything that follows to become plain arguments.</source>
          <target state="translated">일반적인 주장은 어떤 식으로도 해석되지 않습니다. 또한 &lt;code&gt;init&lt;/code&gt; 프로세스 에 의해 저장되며 &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 . 일반 인수는 첫 번째 플래그 앞이나 &lt;code&gt;--&lt;/code&gt; 플래그 뒤에 발생할 수 있습니다 . 또한 &lt;code&gt;-extra&lt;/code&gt; 플래그는 뒤에 오는 모든 항목이 일반 인수가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="021e228d28e31a2dac01ca348b598716a2be960a" translate="yes" xml:space="preserve">
          <source>Plain system messages. These are received as &lt;code&gt;{system, From, Msg}&lt;/code&gt;. The content and meaning of this message are not interpreted by the receiving process module. When a system message is received, function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; is called to handle the request.</source>
          <target state="translated">일반 시스템 메시지. 이들은 &lt;code&gt;{system, From, Msg}&lt;/code&gt; 로 수신됩니다 . 이 메시지의 내용과 의미는 수신 프로세스 모듈에 의해 해석되지 않습니다. 시스템 메시지가 수신되면 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수 가 호출되어 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="67b04c48713ae02b17574be1c7c9e6c47d938551" translate="yes" xml:space="preserve">
          <source>Please note that by historical reasons both the &lt;code&gt;HostAddress&lt;/code&gt; argument and the &lt;code&gt;gen_tcp connect_option(){ip,Address}&lt;/code&gt; set the listening address. This is a source of possible inconsistent settings.</source>
          <target state="translated">역사적으로 &lt;code&gt;HostAddress&lt;/code&gt; 인수와 &lt;code&gt;gen_tcp connect_option(){ip,Address}&lt;/code&gt; 는 모두 수신 주소를 설정합니다. 이는 일관되지 않은 설정의 원인입니다.</target>
        </trans-unit>
        <trans-unit id="32abe057fa82c9bf0495c06f768e39e26b9f11f2" translate="yes" xml:space="preserve">
          <source>Please note that design is something, that not necessarily will, but might change in future releases. While the semantics of the API will not change as it is independent of the implementation.</source>
          <target state="translated">디자인은 반드시 필요한 것은 아니지만 향후 릴리스에서 변경 될 수 있습니다. API의 의미는 구현과 무관하므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="597358d6204ed2d5f3fed145f855762b0d748a69" translate="yes" xml:space="preserve">
          <source>Please see the GNU Emacs Manual and the etags man page for more info.</source>
          <target state="translated">자세한 내용은 GNU Emacs 매뉴얼 및 etags 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c436ed1231dc5771eef264b43827bd13f0e6d7b" translate="yes" xml:space="preserve">
          <source>Please submit any patches for cross compiling in a way consistent with this system. All input is welcome as we have a very limited set of cross compiling environments to test with. If a new configuration variable is needed, add it to &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt;, and use it in &lt;code&gt;configure.in&lt;/code&gt;. Other files that might need to be updated are:</source>
          <target state="translated">이 시스템과 일관된 방식으로 크로스 컴파일을위한 패치를 제출하십시오. 테스트 할 크로스 컴파일 환경이 매우 제한되어 있으므로 모든 입력을 환영합니다. 새 구성 변수가 필요한 경우 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; 에 추가하고 &lt;code&gt;configure.in&lt;/code&gt; 에서 사용하십시오 . 업데이트해야 할 다른 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4140a0c59f9aa45b8631c3e0f8a874473a22c621" translate="yes" xml:space="preserve">
          <source>Please take a look at the reference of &lt;code&gt;sanity_check()&lt;/code&gt; for more information.</source>
          <target state="translated">자세한 내용 은 &lt;code&gt;sanity_check()&lt;/code&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de27f66a37035340860ce9e599a1a2f161cf94be" translate="yes" xml:space="preserve">
          <source>Please, observe that these performance figures are related to our implementation in Erlang/OTP. Measurements of other implementations using other tools and techniques may of course result in other figures.</source>
          <target state="translated">이러한 성능 수치는 Erlang / OTP에서의 구현과 관련이 있습니다. 다른 툴 및 기술을 사용한 다른 구현의 측정은 물론 다른 도면을 초래할 수있다.</target>
        </trans-unit>
        <trans-unit id="d9963c2e5095bb9cc0241cd748d7939bdbfdd2d6" translate="yes" xml:space="preserve">
          <source>Pointer to next structure in a linked list of all port structures. This list is used when accepting connections and when the driver is unloaded.</source>
          <target state="translated">모든 포트 구조의 링크 된 목록에서 다음 구조를 가리키는 포인터. 이 목록은 연결을 수락 할 때와 드라이버를 언로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f19f028244073bea25c8d31a9519278211c9e77e" translate="yes" xml:space="preserve">
          <source>Pointer to the array of reference numbers in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 의 참조 번호 배열을 가리키는 포인터 .</target>
        </trans-unit>
        <trans-unit id="1604bd8010fd538d08c7b5045fd397612cd1e659" translate="yes" xml:space="preserve">
          <source>Points out a file containing a decryption key for &lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt; 의 암호 해독 키가 포함 된 파일을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="7afa60ee7ef4769f7cc3c7f050d9db637653fed0" translate="yes" xml:space="preserve">
          <source>Points out a user HTML style sheet (described later).</source>
          <target state="translated">사용자 HTML 스타일 시트를 가리 킵니다 (나중에 설명 함).</target>
        </trans-unit>
        <trans-unit id="5a35981ceab91897e91ab04e8e2d42162dbd7728" translate="yes" xml:space="preserve">
          <source>Policy for the selection of the temporary port that is used by the server/client during the file transfer. Default is &lt;code&gt;random&lt;/code&gt;, which is the standardized policy. With this policy a randomized free port is used. A single port or a range of ports can be useful if the protocol passes through a firewall.</source>
          <target state="translated">파일 전송 중 서버 / 클라이언트가 사용하는 임시 포트 선택 정책. 기본값은 &lt;code&gt;random&lt;/code&gt; 이며 이는 표준화 된 정책입니다. 이 정책에서는 무작위로 사용 가능한 포트가 사용됩니다. 프로토콜이 방화벽을 통과하는 경우 단일 포트 또는 포트 범위가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="465d89dc629419a077edf90091affa9697b2e338" translate="yes" xml:space="preserve">
          <source>Polling interval (sleep time between polls) = 1 second</source>
          <target state="translated">폴링 간격 (폴링 사이의 휴면 시간) = 1 초</target>
        </trans-unit>
        <trans-unit id="f8b9e6faf5ca12ec30a6ab11e637a8f904a10ff8" translate="yes" xml:space="preserve">
          <source>Polling limit (max number of times to poll to get a remaining string terminated) = 0</source>
          <target state="translated">폴링 제한 (남은 문자열을 종료하기 위해 폴링 할 최대 횟수) = 0</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="799fa570fa6f42daa22b2994cc3725a643fc7be8" translate="yes" xml:space="preserve">
          <source>Port :: &lt;code&gt;inet:port_number()&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">포트 :: &lt;code&gt;inet:port_number()&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ea62c46246b1ea7a1efd0181063c1442570f3e77" translate="yes" xml:space="preserve">
          <source>Port :: &lt;code&gt;inet:port_number()&lt;/code&gt;,</source>
          <target state="translated">포트 :: &lt;code&gt;inet:port_number()&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3db9bac190e277a6139a6817df535ad965dd6629" translate="yes" xml:space="preserve">
          <source>Port = &lt;code&gt;integer() &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">포트 = &lt;code&gt;integer() &amp;gt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59426fd42c4bd1ecdac5914a8115399d46411358" translate="yes" xml:space="preserve">
          <source>Port handle of the executing port.</source>
          <target state="translated">실행 포트의 포트 핸들</target>
        </trans-unit>
        <trans-unit id="bda81d4c1d517232b2d8149167cc3dc467ef84ea" translate="yes" xml:space="preserve">
          <source>Port queries, that is, on which port the node with a specified name listens</source>
          <target state="translated">포트 쿼리, 즉 지정된 이름의 노드가 수신하는 포트</target>
        </trans-unit>
        <trans-unit id="909ce0bd80b59fe5319fb9028cc0d212219399d1" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 4.9.1.1). The function returns a hash value for &lt;code&gt;Term&lt;/code&gt; within the range &lt;code&gt;1..Range&lt;/code&gt;. The maximum value for &lt;code&gt;Range&lt;/code&gt; is 2^32.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 함수 (BIF는 ERTS 4.9.1.1에서 도입 됨). 이 함수는 &lt;code&gt;1..Range&lt;/code&gt; 범위 내의 &lt;code&gt;Term&lt;/code&gt; 해시 값을 반환합니다 . &lt;code&gt;Range&lt;/code&gt; 의 최대 값 은 2 ^ 32입니다.</target>
        </trans-unit>
        <trans-unit id="054b8319dfcb3d23d08071f8f07f5156fb5d7c54" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 5.2). The function returns a hash value for &lt;code&gt;Term&lt;/code&gt; within the range &lt;code&gt;0..Range-1&lt;/code&gt;. The maximum value for &lt;code&gt;Range&lt;/code&gt; is 2^32. When without argument &lt;code&gt;Range&lt;/code&gt;, a value in the range 0..2^27-1 is returned.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 함수 (BIF는 ERTS 5.2에서 도입 됨). 이 함수는 &lt;code&gt;0..Range-1&lt;/code&gt; 범위 내의 &lt;code&gt;Term&lt;/code&gt; 해시 값을 반환합니다 . &lt;code&gt;Range&lt;/code&gt; 의 최대 값 은 2 ^ 32입니다. 인수 &lt;code&gt;Range&lt;/code&gt; 가 없으면 0..2 ^ 27-1 범위의 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1154c86e0447265172bd06d0ffc96a0fbd31265c" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 기능</target>
        </trans-unit>
        <trans-unit id="c97a4b3879c8d95d45f28ff453955a6b9bfa5cfb" translate="yes" xml:space="preserve">
          <source>Ports are always byte-oriented, so before sending data that you are not sure is bytewise-encoded to a port, ensure to encode it in a proper Unicode encoding. Sometimes this means that only part of the data must be encoded as, for example, UTF-8. Some parts can be binary data (like a length indicator) or something else that must not undergo character encoding, so no automatic translation is present.</source>
          <target state="translated">포트는 항상 바이트 지향이므로 확실하지 않은 데이터를 포트로 바이트 단위로 인코딩하기 전에 적절한 유니 코드 인코딩으로 인코딩해야합니다. 때때로 이것은 데이터의 일부만 예를 들어 UTF-8로 인코딩되어야 함을 의미합니다. 일부 부분은 길이 표시기와 같은 이진 데이터이거나 문자 인코딩을 수행해서는 안되는 다른 부분 일 수 있으므로 자동 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4193cfa2c1ff713d813bfaa0d36b429c920defb" translate="yes" xml:space="preserve">
          <source>Ports are configured by the user: diameter places no restrictions.</source>
          <target state="translated">포트는 사용자가 구성합니다. 직경은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb46560c81a3989fb4e829762625b62e66c95636" translate="yes" xml:space="preserve">
          <source>Ports provide the basic mechanism for communication with the external world, from Erlang's point of view. The ports provide a byte-oriented interface to an external program. When a port is created, Erlang can communicate with it by sending and receiving lists of bytes (not Erlang terms). This means that the programmer might have to invent a suitable encoding and decoding scheme.</source>
          <target state="translated">포트는 Erlang의 관점에서 외부 세계와의 통신을위한 기본 메커니즘을 제공합니다. 포트는 외부 프로그램에 바이트 지향 인터페이스를 제공합니다. 포트가 작성되면 Erlang은 바이트 목록 (Erlang 용어가 아님)을 송수신하여 통신 할 수 있습니다. 이것은 프로그래머가 적절한 인코딩 및 디코딩 체계를 발명해야 할 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e5dca5bbd887da11b920c85a6859b7dc5d6446ce" translate="yes" xml:space="preserve">
          <source>Posix character class (only if followed by Posix syntax)</source>
          <target state="translated">Posix 문자 클래스 (Posix 구문이 뒤에 오는 경우에만)</target>
        </trans-unit>
        <trans-unit id="cf44c2ab63d2bfdbd90509d6ab05ee59689772ed" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers are always greedy; the setting of option &lt;code&gt;ungreedy&lt;/code&gt; is ignored. They are a convenient notation for the simpler forms of an atomic group. However, there is no difference in the meaning of a possessive quantifier and the equivalent atomic group, but there can be a performance difference; possessive quantifiers are probably slightly faster.</source>
          <target state="translated">소유 수량자는 항상 탐욕스러워합니다. 옵션 &lt;code&gt;ungreedy&lt;/code&gt; 설정 은 무시됩니다. 원자 그룹의 단순한 형태에 대한 편리한 표기법입니다. 그러나 소유 수량 화기와 동등한 원자 그룹의 의미에는 차이가 없지만 성능 차이가있을 수 있습니다. 소유 수량자는 아마도 약간 빠를 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b6f1087ff5e67d140eb09f11b3dad81741a1747" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers can be used with lookbehind assertions to specify efficient matching of fixed-length strings at the end of subject strings. Consider the following simple pattern when applied to a long string that does not match:</source>
          <target state="translated">Posessive 한정자는 lookbehind 어설 션과 함께 사용되어 주제 문자열의 끝에 고정 길이 문자열의 효율적인 일치를 지정합니다. 일치하지 않는 긴 문자열에 적용될 때는 다음과 같은 간단한 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1dfe8268667e0c66e3daa6ac9b57143d77624130" translate="yes" xml:space="preserve">
          <source>Possible Erlang 'EXIT' messages is to be handled by this function and all channels are to handle the following message.</source>
          <target state="translated">가능한 Erlang 'EXIT'메시지는이 기능으로 처리되며 모든 채널은 다음 메시지를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="149bf3ac15f9f4fc58f0fe306b8c56c8c16051d0" translate="yes" xml:space="preserve">
          <source>Possible SCTP events:</source>
          <target state="translated">가능한 SCTP 이벤트 :</target>
        </trans-unit>
        <trans-unit id="b91d93860e0e7dc1f57e9b3c4cd2dfcbc0c4795b" translate="yes" xml:space="preserve">
          <source>Possible actions: ignore as in drop the event (maybe log it) or deal with the event in some other state as in postpone it.</source>
          <target state="translated">가능한 조치 : 이벤트를 제거 할 때 무시하거나 (로그 기록 가능) 연기 된 것처럼 다른 상태에서 이벤트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="986d4a1466fd9cd5e38ecaec22d116bf1c515c81" translate="yes" xml:space="preserve">
          <source>Possible configuration variables include:</source>
          <target state="translated">가능한 구성 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34001dfcb817c4c0ae5c87f2102d6fe4615ff7e1" translate="yes" xml:space="preserve">
          <source>Possible options and values vary depending on the I/O device. For a list of supported options and their current values on a specific I/O device, use function &lt;code&gt;&lt;a href=&quot;#getopts-1&quot;&gt;getopts/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 옵션과 값은 I / O 장치에 따라 다릅니다. 특정 I / O 장치에서 지원되는 옵션 및 현재 값 목록을 보려면 &lt;code&gt;&lt;a href=&quot;#getopts-1&quot;&gt;getopts/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="878f3530033a9b08ada15887a53634015460882c" translate="yes" xml:space="preserve">
          <source>Possible options are :</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60e11e810786d4e1c3e27a2df214cc536e9941c7" translate="yes" xml:space="preserve">
          <source>Possible options are:</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2005d62e46c5a3d6f217477137da0006cd82c5a1" translate="yes" xml:space="preserve">
          <source>Possible reasons for a bad certificate:</source>
          <target state="translated">잘못된 인증서의 가능한 이유 :</target>
        </trans-unit>
        <trans-unit id="1473fc3a07d611c813c39a776d207edb467c5e8f" translate="yes" xml:space="preserve">
          <source>Possibly the most important feature of an editor designed for programmers is the ability to indent a line of code in accordance with the structure of the programming language. The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language. The mode also provides things as syntax highlighting, electric commands, module name verification, comment support including paragraph filling, skeletons, tags support etc.</source>
          <target state="translated">프로그래머를 위해 설계된 편집기의 가장 중요한 기능은 프로그래밍 언어의 구조에 따라 코드 줄을 들여 쓰는 기능 일 것입니다. Erlang 모드는 물론이 기능을 제공합니다. 사용 된 레이아웃은 일반적인 언어 사용을 기반으로합니다. 이 모드는 구문 강조, 전기 명령, 모듈 이름 확인, 단락 채우기를 포함한 주석 지원, 골격, 태그 지원 등을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c84b501894f8e4082c349aaca37c8c128c099d19" translate="yes" xml:space="preserve">
          <source>Postponing is ordered by the state transition &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt;.</source>
          <target state="translated">연기는 상태 전이 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 의해 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e2fa43d974da83b84f8b7a0198aa7c4a5f02ff1" translate="yes" xml:space="preserve">
          <source>PowerPC: All 32-bit 6xx/7xx(G3)/74xx(G4) processors should work. 32-bit mode on 970 (G5) and POWER5 processors should work.</source>
          <target state="translated">PowerPC : 모든 32 비트 6xx / 7xx (G3) / 74xx (G4) 프로세서가 작동해야합니다. 970 (G5) 및 POWER5 프로세서의 32 비트 모드가 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfd617494e5919519b64ca7cf73d988ce7314f09" translate="yes" xml:space="preserve">
          <source>PowerPC: Linux, Mac OSX</source>
          <target state="translated">PowerPC : Linux, Mac OSX</target>
        </trans-unit>
        <trans-unit id="8756ea35ca147cf4eb388864ebf89dce85216cce" translate="yes" xml:space="preserve">
          <source>Pre-built Source Release</source>
          <target state="translated">사전 빌드 소스 릴리스</target>
        </trans-unit>
        <trans-unit id="e9533f120fc37f02251d4dcf3459051b82c4e403" translate="yes" xml:space="preserve">
          <source>Pre-defined module attributes is to be placed before any function declaration.</source>
          <target state="translated">사전 정의 된 모듈 속성은 함수 선언 전에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="926f83f2a7c83bde06ce094d99185e3842a8a8f9" translate="yes" xml:space="preserve">
          <source>Pre-formatted &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_21.0.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_21.0.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; can be downloaded from</source>
          <target state="translated">사전 형식화 된 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_21.0.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_21.0.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="ff56d95f5ae87da89cf746ab41ce4e6a479c1f0d" translate="yes" xml:space="preserve">
          <source>Predictive Loop Avoidance</source>
          <target state="translated">예측 루프 회피</target>
        </trans-unit>
        <trans-unit id="1fa566d2725a0b203f5437a8f646bcbb04681b10" translate="yes" xml:space="preserve">
          <source>Preferably, you would check the machine type, the operating system, and the Kernel version before executing anything similar to this code.</source>
          <target state="translated">이 코드와 비슷한 것을 실행하기 전에 머신 유형, 운영 체제 및 커널 버전을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="84c0062ba00a989bbfa87f065cc839159da1421f" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on TD-33</source>
          <target state="translated">TD-33 기반 예비 버전 3</target>
        </trans-unit>
        <trans-unit id="da668ceef4aad0b079d2fa1313967654991563d7" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on TD-33, but text encoding updated with the final solution for priority in &lt;code&gt;contextProperty&lt;/code&gt; (which is backward compatible with v2).</source>
          <target state="translated">TD-33을 기반으로하는 예비 버전 3이지만 텍스트 인코딩은 &lt;code&gt;contextProperty&lt;/code&gt; 의 우선 순위에 대한 최종 솔루션으로 업데이트되었습니다 (v2와 역 호환 가능).</target>
        </trans-unit>
        <trans-unit id="8ce9d534fd06e5e0f995497a19bceaa290fe794b" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on the final version of the v3-standard, but &lt;strong&gt;excluding&lt;/strong&gt; segments!</source>
          <target state="translated">v3 표준의 최종 버전을 기반으로하는 예비 버전 3 ( 세그먼트 &lt;strong&gt;제외)&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="635a0b9ab635f6550fdf7e8b53c541a528049aa3" translate="yes" xml:space="preserve">
          <source>Preloaded modules are always reported as &lt;code&gt;loaded&lt;/code&gt;, without inspecting the contents on disk. Cover compiled modules will always be reported as &lt;code&gt;modified&lt;/code&gt; if an object file exists, or as &lt;code&gt;removed&lt;/code&gt; otherwise. Modules whose load path is an empty string (which is the convention for auto-generated code) will only be reported as &lt;code&gt;loaded&lt;/code&gt; or &lt;code&gt;not_loaded&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;loaded&lt;/code&gt; 모듈은 디스크의 내용을 검사하지 않고 항상 loaded 로보고됩니다 . Cover 컴파일 된 모듈은 항상 오브젝트 파일이 존재하는 경우 &lt;code&gt;modified&lt;/code&gt; 것으로보고 되거나 그렇지 않으면 &lt;code&gt;removed&lt;/code&gt; 된 것으로보고됩니다 . 로드 경로가 빈 문자열 (자동 생성 코드의 규칙) 인 모듈은 &lt;code&gt;loaded&lt;/code&gt; 또는 &lt;code&gt;not_loaded&lt;/code&gt; 로만보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ccb4a6b47e69ccdef1feeb0cb6c0bbd699daa33" translate="yes" xml:space="preserve">
          <source>Prepares to load the modules in the list &lt;code&gt;Modules&lt;/code&gt;. Finish the loading by calling &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading(Prepared)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 목록에 &lt;code&gt;Modules&lt;/code&gt; 을로드 할 준비를합니다 . &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading(Prepared)&lt;/a&gt;&lt;/code&gt; 을 호출하여로드를 완료하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af0e9a7676ad5c34d0982329c5f5caab38b02df" translate="yes" xml:space="preserve">
          <source>Prepares to open a file on the client side.</source>
          <target state="translated">클라이언트 측에서 파일을 열 준비를합니다.</target>
        </trans-unit>
        <trans-unit id="1af579a4819f628301944085e091406a4beaf50a" translate="yes" xml:space="preserve">
          <source>Prepend the specified directory to the code path. Use to point at beam files compiled from inherited dictionaries, &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; in a dictionary file creating a beam dependency, not an erl/hrl dependency.</source>
          <target state="translated">지정된 디렉토리를 코드 경로 앞에 추가하십시오. 빔 상속 사전에서 컴파일 된 파일에서 포인트 사용 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 빔 의존성을 만드는 사전 파일이 아닌 ERL / HRL 의존성.</target>
        </trans-unit>
        <trans-unit id="a20fa72c3402e6bde9460d87001f7ae629c23c73" translate="yes" xml:space="preserve">
          <source>Preprocesses and parses an Erlang source file. Notice that tuple &lt;code&gt;{eof, Line}&lt;/code&gt; returned at the end of the file is included as a &quot;form&quot;.</source>
          <target state="translated">Erlang 소스 파일을 사전 처리하고 구문 분석합니다. 파일 끝에서 반환 된 튜플 &lt;code&gt;{eof, Line}&lt;/code&gt; 은 &quot;양식&quot;으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2691f43bd7041517e5cd137cba084147892ae0d0" translate="yes" xml:space="preserve">
          <source>Presented IDs</source>
          <target state="translated">제시된 ID</target>
        </trans-unit>
        <trans-unit id="0c6c64c4381af2076f81188f61e3735af23c9c67" translate="yes" xml:space="preserve">
          <source>Presented Identifier</source>
          <target state="translated">제시된 식별자</target>
        </trans-unit>
        <trans-unit id="1d8162ec721e521c8cbbcf0236344390db358601" translate="yes" xml:space="preserve">
          <source>Presents the error returned by an SSL function as a printable string.</source>
          <target state="translated">SSL 함수가 리턴 할 수있는 오류를 인쇄 가능한 문자열로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04f8808cdf1dcc1ebc30cfb13086e1464c6e225f" translate="yes" xml:space="preserve">
          <source>Press Control-C to shut down the Erlang system and the Erlang shell.</source>
          <target state="translated">Control-C를 눌러 Erlang 시스템과 Erlang 쉘을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f85da72e94aea2381a2f0b0888b6cb0b938cff09" translate="yes" xml:space="preserve">
          <source>Pretty printing of abstract Erlang syntax trees.</source>
          <target state="translated">추상 Erlang 구문 트리의 예쁜 인쇄.</target>
        </trans-unit>
        <trans-unit id="dc508f11298d514f277642f83dadf29968dd9d46" translate="yes" xml:space="preserve">
          <source>Pretty prints a &lt;code&gt;Form&lt;/code&gt;, which is an abstract form of a type that is returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt;erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pretty는 &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt;erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 형식의 추상 형식 인 &lt;code&gt;Form&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d63df205ad942f1c830ebd4e4bc701ca8b9e816f" translate="yes" xml:space="preserve">
          <source>Pretty-print a syntax tree or template to the standard output. This is a utility function for development and debugging.</source>
          <target state="translated">구문 트리 또는 템플릿을 표준 출력으로 출력하십시오. 개발 및 디버깅을위한 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ac772a8e8177c0183620391b61e4e90f72e8fe2f" translate="yes" xml:space="preserve">
          <source>Prettyprint-formats an abstract Erlang syntax tree as text. For example, if you have a &lt;code&gt;.beam&lt;/code&gt; file that has been compiled with &lt;code&gt;debug_info&lt;/code&gt;, the following should print the source code for the module (as it looks in the debug info representation):</source>
          <target state="translated">Pretty Erlang 구문 트리를 텍스트로 Prettyprint 형식으로 지정합니다. 당신이있는 경우 예를 들어, &lt;code&gt;.beam&lt;/code&gt; 의 컴파일 된 파일 &lt;code&gt;debug_info&lt;/code&gt; 을 (가 디버그 정보 표현에 보이는대로), 다음은 모듈의 소스 코드를 인쇄해야합니다 :</target>
        </trans-unit>
        <trans-unit id="bf3e85268675b1375b86ffb5b4b5e86258ba6284" translate="yes" xml:space="preserve">
          <source>Prevents loading information about source filenames and line numbers. This saves some memory, but exceptions do not contain information about the filenames and line numbers.</source>
          <target state="translated">소스 파일 이름 및 줄 번호에 대한 정보를로드하지 못하게합니다. 이렇게하면 일부 메모리가 절약되지만 파일 이름 및 줄 번호에 대한 정보는 예외에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d09eeaa3bc8ced4fe796ecbcf1dd05c62de1e4cd" translate="yes" xml:space="preserve">
          <source>Prevents the Server Name Indication extension from being sent and disables the hostname verification check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;</source>
          <target state="translated">서버 이름 표시 확장이 전송되지 않도록하고 호스트 이름 확인 검사 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="13c464652aa4866a035cb6021e96dd21a453187f" translate="yes" xml:space="preserve">
          <source>Previous implementation used to allow all characters as long as they were integer values greater than or equal to zero. This sometimes lead to unwanted results since null characters (integer value zero) often are interpreted as string termination. The current implementation rejects these.</source>
          <target state="translated">이전 구현에서는 모든 문자가 0 이상의 정수 값인 한 모든 문자를 허용했습니다. 널 문자 (정수 값 0)가 종종 문자열 종료로 해석되기 때문에 원하지 않는 결과가 발생할 수 있습니다. 현재 구현에서는이를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="7569c52a61d993390fecf54a831ac17622da8694" translate="yes" xml:space="preserve">
          <source>Previously &lt;code&gt;erlang:now/0&lt;/code&gt; was the only option for doing many things. This section deals with some things that &lt;code&gt;erlang:now/0&lt;/code&gt; can be used for, and how you use the new API.</source>
          <target state="translated">이전에는 &lt;code&gt;erlang:now/0&lt;/code&gt; 이 많은 작업을 수행하는 유일한 옵션이었습니다. 이 섹션에서는 &lt;code&gt;erlang:now/0&lt;/code&gt; 을 사용할 수있는 몇 가지 사항 과 새로운 API를 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0ceee1e4ba51d6772fb4907373f07ae18936fe7" translate="yes" xml:space="preserve">
          <source>Previously, in the runtime system without SMP support, specific driver callbacks were always called from the same thread. This is &lt;strong&gt;not&lt;/strong&gt; the case in the runtime system with SMP support. Regardless of locking scheme used, calls to driver callbacks can be made from different threads. For example, two consecutive calls to exactly the same callback for exactly the same port can be made from two different threads. This is for &lt;strong&gt;most&lt;/strong&gt; drivers not a problem, but it can be. Drivers that depend on all callbacks that are called in the same thread, &lt;strong&gt;must&lt;/strong&gt; be rewritten before they are used in the runtime system with SMP support.</source>
          <target state="translated">이전에는 SMP를 지원하지 않는 런타임 시스템에서 특정 드라이버 콜백이 항상 동일한 스레드에서 호출되었습니다. 입니다 &lt;strong&gt;하지&lt;/strong&gt; SMP를 지원하는 런타임 시스템의 경우. 사용 된 잠금 체계에 관계없이 드라이버 콜백에 대한 호출은 다른 스레드에서 수행 될 수 있습니다. 예를 들어, 정확히 동일한 포트에 대해 정확히 동일한 콜백에 대한 두 번의 연속 호출은 두 개의 다른 스레드에서 이루어질 수 있습니다. 이것은 &lt;strong&gt;대부분의&lt;/strong&gt; 드라이버에게 문제가되지 않지만 문제가 될 수 있습니다. 동일한 스레드에서 호출 된 모든 콜백에 의존하는 드라이버는 SMP를 지원하는 런타임 시스템에서 사용되기 전에 다시 작성 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="41e95726528ea52023e106b0ac0c22d8fda4f9a9" translate="yes" xml:space="preserve">
          <source>Primary configuration data for Logger. The following default values apply:</source>
          <target state="translated">로거의 기본 구성 데이터. 다음과 같은 기본값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4247f20e948bccce17d13768ac3cbeade11f898" translate="yes" xml:space="preserve">
          <source>Primary filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;. They can also be added at system start via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 필터는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 로 추가 되고 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 제거됩니다 . 시스템 시작시 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 를 통해 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c017c83ba101ed388ebd807c4962577b9c15b383" translate="yes" xml:space="preserve">
          <source>Print information about the progress of execution (analysis phases, time spent in each, and size of the relative input).</source>
          <target state="translated">실행 진행 상황 (분석 단계, 각각에 소요 된 시간 및 상대 입력 크기)에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="840da8e13285304b6387e89b722d638fe4321fb7" translate="yes" xml:space="preserve">
          <source>Print percentage of time spent in each state out of system time as well as thread time. Default: false.</source>
          <target state="translated">스레드 시간뿐만 아니라 시스템 시간이 아닌 각 상태에서 소요 된 시간의 백분율을 인쇄합니다. 기본값 : false</target>
        </trans-unit>
        <trans-unit id="07be91632e8eb7326b61e92e0be9119ccf72f9d9" translate="yes" xml:space="preserve">
          <source>Print the Dialyzer version and some more information and exit.</source>
          <target state="translated">투석기 버전 및 추가 정보를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="4ad3462bebc7bf990bf0f02e7785a28379a6206b" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to standard out. With many states this can be quite verbose. See the top of this reference manual for a brief description of what the fields mean.</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 표준 출력으로 인쇄합니다. 많은 주에서 이것은 매우 장황 할 수 있습니다. 필드의 의미에 대한 간략한 설명은이 참조 매뉴얼 상단을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c29cb731638369d14c3a95c6a29333f3020a9db2" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to stdout. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(DataOrStats,#{}).&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 stdout에 인쇄하십시오. &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(DataOrStats,#{}).&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d7eaf72064647bad389abb4f1d3dfdc027f8b39d" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to the given file or device. The other arguments behave the same way as for &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 주어진 파일 또는 장치에 인쇄하십시오. 다른 인수는 &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="34634055c6f69316398bf0d40b7161096698a0c0" translate="yes" xml:space="preserve">
          <source>Print the statistics by source file and line numbers.</source>
          <target state="translated">소스 파일 및 행 번호별로 통계를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="6346a375113351396db6189bbd3e28045635ee9a" translate="yes" xml:space="preserve">
          <source>Print the structure of a syntax tree or template to the standard output. This is a utility function for development and debugging.</source>
          <target state="translated">구문 트리 또는 템플릿의 구조를 표준 출력으로 인쇄하십시오. 개발 및 디버깅을위한 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b0de2ead24e5961c777ca83b34e36a96963308e8" translate="yes" xml:space="preserve">
          <source>Print this message and exit.</source>
          <target state="translated">이 메시지를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="67d04a8c259ba2c520817ac42065457527ed5559" translate="yes" xml:space="preserve">
          <source>Printing characters, excluding letters, digits, and space</source>
          <target state="translated">문자, 숫자 및 공백을 제외한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="dd479d5b24caa5cc7f6fcec5ba84f65bfd052c0e" translate="yes" xml:space="preserve">
          <source>Printing characters, excluding space</source>
          <target state="translated">공백을 제외한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="1ceeb223cd6849a3604ba83fadcbca0256451f47" translate="yes" xml:space="preserve">
          <source>Printing characters, including space</source>
          <target state="translated">공백을 포함한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="5d921c48d9c8fb8f05637fa271ea8672b6ca0cee" translate="yes" xml:space="preserve">
          <source>Printing options:</source>
          <target state="translated">인쇄 옵션 :</target>
        </trans-unit>
        <trans-unit id="d6045c26dcc40b8b0b1a862cc5369f2a960dd880" translate="yes" xml:space="preserve">
          <source>Prints &lt;code&gt;Text&lt;/code&gt; and the wall clock time for evaluation of &lt;code&gt;Expr&lt;/code&gt;. The result is always the value of &lt;code&gt;Expr&lt;/code&gt;, so this macro can be wrapped around any expression to show its run time when the code is compiled with debugging enabled. For example, &lt;code&gt;List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))&lt;/code&gt; might show as &quot;&lt;code&gt;sorting: 0.015 s&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 평가를 위해 &lt;code&gt;Text&lt;/code&gt; 및 벽시계 시간을 인쇄 합니다. 결과는 항상 &lt;code&gt;Expr&lt;/code&gt; 의 값 이므로,이 매크로는 코드가 디버깅이 활성화 된 상태에서 컴파일 될 때 런타임을 보여주기 위해 모든 표현식을 감쌀 수 있습니다. 예를 들어 &lt;code&gt;List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))&lt;/code&gt; 는 &quot; &lt;code&gt;sorting: 0.015 s&lt;/code&gt; &quot; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249624d6cefc4a2b88e5bd0c9d8e84ed3f1f76d0" translate="yes" xml:space="preserve">
          <source>Prints a list of internal lock counters by source code locations.</source>
          <target state="translated">소스 코드 위치별로 내부 잠금 카운터 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5b46759cd364af5f12c0d8bc8dd37e3821f4b179" translate="yes" xml:space="preserve">
          <source>Prints a list of internal lock counters for a specific lock.</source>
          <target state="translated">특정 잠금에 대한 내부 잠금 카운터 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f780c7159f6f13c37c7d77cfd6cc4335b5ecf7a3" translate="yes" xml:space="preserve">
          <source>Prints a list of internal locks and its statistics.</source>
          <target state="translated">내부 잠금 목록 및 해당 통계를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="34938f37f4431fc15190b179d6c88b3314bbc2c3" translate="yes" xml:space="preserve">
          <source>Prints a term using the record definitions known to the shell. All of &lt;code&gt;Term&lt;/code&gt; is printed; the depth is not limited as is the case when a return value is printed.</source>
          <target state="translated">쉘에 알려진 레코드 정의를 사용하여 용어를 인쇄합니다. 모든 &lt;code&gt;Term&lt;/code&gt; 가 인쇄됩니다. 반환 값이 인쇄 될 때와 같이 깊이는 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af0bf4827e6f6c31d2c88fd072f546d7d79231d8" translate="yes" xml:space="preserve">
          <source>Prints a term, in clear text, to the file specified by &lt;code&gt;fp&lt;/code&gt;, or the buffer pointed to by &lt;code&gt;s&lt;/code&gt;. It tries to resemble the term printing in the Erlang shell.</source>
          <target state="translated">&lt;code&gt;fp&lt;/code&gt; 로 지정된 파일 또는 &lt;code&gt;s&lt;/code&gt; 로 지정된 버퍼 에 일반 텍스트로 용어를 인쇄합니다 . Erlang 쉘의 인쇄 용어와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="dbb3d816fd9f97adbc552b5513c5a135cb6248eb" translate="yes" xml:space="preserve">
          <source>Prints a text representation of &lt;code&gt;Term&lt;/code&gt; on the standard output.</source>
          <target state="translated">표준 출력 에 &lt;code&gt;Term&lt;/code&gt; 의 텍스트 표현을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f131bd4ae3bf99f6a37fd4eaaff33b16a3ddd00d" translate="yes" xml:space="preserve">
          <source>Prints all existing breakpoints in &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 모든 기존 중단 점을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8350e6665f2a056f33d55252db1621c39e138f" translate="yes" xml:space="preserve">
          <source>Prints all existing breakpoints.</source>
          <target state="translated">기존의 모든 중단 점을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a09e12adb74f08869231e9cda96a7ab997d865d7" translate="yes" xml:space="preserve">
          <source>Prints all filenames in the zip archive &lt;code&gt;Archive&lt;/code&gt; to the Erlang shell. (Similar to &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt;.)</source>
          <target state="translated">Zip 아카이브 &lt;code&gt;Archive&lt;/code&gt; 의 모든 파일 이름을 Erlang 쉘 에 인쇄합니다 . &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt; 와 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="18e7b8e58c0e38665fb68377f1d2376f33278d8b" translate="yes" xml:space="preserve">
          <source>Prints all record definitions.</source>
          <target state="translated">모든 레코드 정의를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="66a41d50c3e8acabd70db40b3336aae5ee4b67bb" translate="yes" xml:space="preserve">
          <source>Prints all system events on &lt;code&gt;standard_io&lt;/code&gt;. The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 의 모든 시스템 이벤트를 인쇄합니다 . 이벤트는 이벤트를 생성 한 프로세스에 의해 정의 된 함수 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt; 에 대한 호출)로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a70ee13c7e68963279aefe5da5f06258c94682e" translate="yes" xml:space="preserve">
          <source>Prints an informational message about each added file.</source>
          <target state="translated">추가 된 각 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b783bcbadb2cc653a08641efe74f849f29f9e618" translate="yes" xml:space="preserve">
          <source>Prints an informational message about the added file.</source>
          <target state="translated">추가 된 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="789b189bdffe8e48a506f0e50b3eae0173a1b17d" translate="yes" xml:space="preserve">
          <source>Prints an informational message for each extracted file.</source>
          <target state="translated">추출 된 각 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b42f15b17183c3dbb48cf5820eb8a855896d590a" translate="yes" xml:space="preserve">
          <source>Prints and logs from a test case.</source>
          <target state="translated">테스트 사례에서 인쇄 및 기록합니다.</target>
        </trans-unit>
        <trans-unit id="0cf9dc25b9f3af6da971b72a11d06f3ed2521439" translate="yes" xml:space="preserve">
          <source>Prints both the source code for &lt;code&gt;Expr&lt;/code&gt; and its current value. E.g., &lt;code&gt;?debugVal(f(X))&lt;/code&gt; might be displayed as &quot;&lt;code&gt;f(X) = 42&lt;/code&gt;&quot;. (Large terms are truncated to the depth given by the macro &lt;code&gt;EUNIT_DEBUG_VAL_DEPTH&lt;/code&gt;, which defaults to 15 but can be overridden by the user.) The result is always the value of &lt;code&gt;Expr&lt;/code&gt;, so this macro can be wrapped around any expression to display its value when the code is compiled with debugging enabled.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 의 소스 코드 와 현재 값 을 모두 인쇄합니다 . 예를 들어, &lt;code&gt;?debugVal(f(X))&lt;/code&gt; 는 &quot; &lt;code&gt;f(X) = 42&lt;/code&gt; &quot; 로 표시 될 수 있습니다 . (큰 용어는 &lt;code&gt;EUNIT_DEBUG_VAL_DEPTH&lt;/code&gt; 매크로가 제공하는 깊이로 잘 리며 기본값은 15이지만 사용자가 재정의 할 수 있습니다.) 결과는 항상 &lt;code&gt;Expr&lt;/code&gt; 값 이므로이 매크로는 모든 표현식을 감싸서 값을 표시 할 수 있습니다. 코드는 디버깅이 활성화 된 상태로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cba2a56bd54f58298d76b707819499e391db4251" translate="yes" xml:space="preserve">
          <source>Prints call statistics for each process in the analysis. This is the default.</source>
          <target state="translated">분석의 각 프로세스에 대한 통화 통계를 인쇄합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e1be7a76157fe86cb7376f259794a335da8ea625" translate="yes" xml:space="preserve">
          <source>Prints callers and called information in the analysis. This is the default.</source>
          <target state="translated">분석에서 발신자와 호출 된 정보를 인쇄합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c909f68d3cdf1b4678031168fcbd218d91fd2a8e" translate="yes" xml:space="preserve">
          <source>Prints filenames and information about all files in the zip archive &lt;code&gt;Archive&lt;/code&gt; to the Erlang shell. (Similar to &lt;code&gt;tar tv&lt;/code&gt;.)</source>
          <target state="translated">Zip 아카이브 &lt;code&gt;Archive&lt;/code&gt; 의 모든 파일에 대한 파일 이름 및 정보를 Erlang 쉘에 인쇄합니다. ( &lt;code&gt;tar tv&lt;/code&gt; 와 유사합니다 .)</target>
        </trans-unit>
        <trans-unit id="3d37aa2c01035d21e560d11bd3a6a17de70550c3" translate="yes" xml:space="preserve">
          <source>Prints from a test case to the console.</source>
          <target state="translated">테스트 케이스에서 콘솔로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f28c890f7ca27b31a21a647f349c289e1195b699" translate="yes" xml:space="preserve">
          <source>Prints from a test case to the log file.</source>
          <target state="translated">테스트 케이스에서 로그 파일로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="367bedb7c3ebf6d1df93886702fa7c7177182d00" translate="yes" xml:space="preserve">
          <source>Prints help text.</source>
          <target state="translated">도움말 텍스트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4842182b0113366c688f6ed8532b18cf4974ced6" translate="yes" xml:space="preserve">
          <source>Prints information about all table definitions on the terminal.</source>
          <target state="translated">터미널의 모든 테이블 정의에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c9b99b5c7266c995bbf989e773efe1fa4d05005d" translate="yes" xml:space="preserve">
          <source>Prints information about one table definition on the terminal.</source>
          <target state="translated">터미널에서 하나의 테이블 정의에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a832165573cfbb962be90caea9e1e9a84652de7" translate="yes" xml:space="preserve">
          <source>Prints lcnt server state and generic information about collected lock statistics.</source>
          <target state="translated">수집 된 잠금 통계에 대한 lcnt 서버 상태 및 일반 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="96fd634328bfac39da0d4ad325d6f383ea04727b" translate="yes" xml:space="preserve">
          <source>Prints names and information about all files in the tar file &lt;code&gt;Name&lt;/code&gt; to the Erlang shell (similar to &quot;&lt;code&gt;tar&amp;nbsp;tv&lt;/code&gt;&quot;).</source>
          <target state="translated">인쇄 이름과 타르 파일에있는 모든 파일에 대한 정보는 &lt;code&gt;Name&lt;/code&gt; ( &quot;비슷한 얼랑 쉘 &lt;code&gt;tar&amp;nbsp;tv&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="0b7c144db0f81aaecb54453231a97d3656fc6209" translate="yes" xml:space="preserve">
          <source>Prints one expression. It is useful for implementing hooks (see section &lt;code&gt;&lt;a href=&quot;#knownlimitations&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">하나의 표현식을 인쇄합니다. 후크 구현에 유용합니다 (섹션 &lt;code&gt;&lt;a href=&quot;#knownlimitations&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0d811790ffe033d437439353029d5c5f60196585" translate="yes" xml:space="preserve">
          <source>Prints selected record definitions. &lt;code&gt;RecordNames&lt;/code&gt; is a record name or a list of record names.</source>
          <target state="translated">선택된 레코드 정의를 인쇄합니다. &lt;code&gt;RecordNames&lt;/code&gt; 는 레코드 이름 또는 레코드 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3337334a9f65d4805b4e67126869967487e4a45a" translate="yes" xml:space="preserve">
          <source>Prints system information on the terminal. This function can be used even if Mnesia is not started. However, more information is displayed if Mnesia is started.</source>
          <target state="translated">터미널에 시스템 정보를 인쇄합니다. Mnesia가 시작되지 않은 경우에도이 기능을 사용할 수 있습니다. 그러나 Mnesia가 시작되면 자세한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7fe00a6e4282e0ab0f331a54683530177db63d" translate="yes" xml:space="preserve">
          <source>Prints the argument with the string syntax. The argument is, if no Unicode translation modifier is present, an &lt;code&gt;iolist()&lt;/code&gt;, a &lt;code&gt;binary()&lt;/code&gt;, or an &lt;code&gt;atom()&lt;/code&gt;. If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the argument is &lt;code&gt;unicode:chardata()&lt;/code&gt;, meaning that binaries are in UTF-8. The characters are printed without quotes. The string is first truncated by the specified precision and then padded and justified to the specified field width. The default precision is the field width.</source>
          <target state="translated">문자열 구문으로 인수를 인쇄합니다. 유니 코드 변환 수정자가없는 경우 &lt;code&gt;iolist()&lt;/code&gt; , &lt;code&gt;binary()&lt;/code&gt; 또는 &lt;code&gt;atom()&lt;/code&gt; 입니다. 유니 코드 변환 수정 자 ( &lt;code&gt;t&lt;/code&gt; )가 유효한 경우 인수는 &lt;code&gt;unicode:chardata()&lt;/code&gt; 이며 이진은 UTF-8로되어 있습니다. 문자는 따옴표없이 인쇄됩니다. 문자열은 먼저 지정된 정밀도로 잘린 다음 지정된 필드 너비에 맞게 채워지고 정렬됩니다. 기본 정밀도는 필드 너비입니다.</target>
        </trans-unit>
        <trans-unit id="bd5cd1b05b1d6e3d16e8bf612aeeaa8d48e96e04" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) tables and variables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 테이블 및 변수의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="90637c82b5d5250fe221618f94be01dea7995ed8" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) tables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 테이블의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4bf87b55c70954b59410622021acfda18b4d862a" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) variables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 변수의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5b79c2bcb86c7797ba5fa06effcf5832d223d36a" translate="yes" xml:space="preserve">
          <source>Prints the contents of the database on screen. This is useful for debugging since the &lt;code&gt;STANDARD-MIB&lt;/code&gt; and &lt;code&gt;OTP-SNMPEA-MIB&lt;/code&gt; (and maybe your own MIBs) are stored in &lt;code&gt;snmpa_local_db&lt;/code&gt;.</source>
          <target state="translated">데이터베이스의 내용을 화면에 인쇄합니다. 이것은 이후 디버깅에 유용 &lt;code&gt;STANDARD-MIB&lt;/code&gt; 및 &lt;code&gt;OTP-SNMPEA-MIB&lt;/code&gt; 에 저장됩니다 (어쩌면 자신의 MIB를하고) &lt;code&gt;snmpa_local_db&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d48e71ba53b9a774ace4b3048a7d6147bac49e2" translate="yes" xml:space="preserve">
          <source>Prints the current microstate accounting to standard out. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(msacc:stats(),#{}).&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">현재 마이크로 스테이트 회계를 표준 출력으로 인쇄합니다. 동일 &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(msacc:stats(),#{}).&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f573f7b3b8befc12d22fd5e016d5affba5ec7e7" translate="yes" xml:space="preserve">
          <source>Prints the current status of all interpreted processes.</source>
          <target state="translated">해석 된 모든 프로세스의 현재 상태를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b7de039db4515d2480ed1087648907d99e3cce17" translate="yes" xml:space="preserve">
          <source>Prints the current variable bindings.</source>
          <target state="translated">현재 변수 바인딩을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="38356e23d298a145e0dd7db9a9c3d8f5137f87bd" translate="yes" xml:space="preserve">
          <source>Prints the formatted string in the comment field in the table on the test suite result page.</source>
          <target state="translated">테스트 스위트 결과 페이지의 테이블에있는 주석 필드에 형식화 된 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a338446495bbc76dc9e6e72c05e03dc5573b368" translate="yes" xml:space="preserve">
          <source>Prints the history list.</source>
          <target state="translated">히스토리 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1587f809009dffca5babc79d912a7baf0c2c4678" translate="yes" xml:space="preserve">
          <source>Prints the logged system events in the debug structure, using &lt;code&gt;FormFunc&lt;/code&gt; as defined when the event was generated by a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt; 호출로 이벤트가 생성 될 때 정의 된대로 &lt;code&gt;FormFunc&lt;/code&gt; 를 사용하여 디버그 구조에서 로그 된 시스템 이벤트를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="c697f405132de684f29b1c85650f6166f19d3f38" translate="yes" xml:space="preserve">
          <source>Prints the name of the working directory.</source>
          <target state="translated">작업 디렉토리의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2b0a0e8caa63b361ad3055b9a938bd9ee0847140" translate="yes" xml:space="preserve">
          <source>Prints the names of all files in the tar file &lt;code&gt;Name&lt;/code&gt; to the Erlang shell (similar to &quot;&lt;code&gt;tar&amp;nbsp;t&lt;/code&gt;&quot;).</source>
          <target state="translated">tar 파일에있는 모든 파일의 &lt;code&gt;Name&lt;/code&gt; 을 Erlang 쉘에 인쇄합니다 ( &quot; &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt; &quot; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="df056a5b36536b5f6f05efef7d94a9025dcb4881" translate="yes" xml:space="preserve">
          <source>Prints the node uptime (as specified by &lt;code&gt;erlang:statistics(wall_clock)&lt;/code&gt;) in human-readable form.</source>
          <target state="translated">&lt;code&gt;erlang:statistics(wall_clock)&lt;/code&gt; 지정된 노드 가동 시간 을 사람이 읽을 수있는 형식으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="236e4648c9dfa6dccb2557b594716eafdf865791" translate="yes" xml:space="preserve">
          <source>Prints the specified &lt;code&gt;Comment&lt;/code&gt; in the comment field in the table on the test suite result page.</source>
          <target state="translated">테스트 스위트 결과 페이지의 테이블에있는 주석 필드에 지정된 &lt;code&gt;Comment&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="86341a0cf794500a0ef3c32c1e84cb1e5b1a1ea2" translate="yes" xml:space="preserve">
          <source>Prints the specified Erlang term to the specified output stream.</source>
          <target state="translated">지정된 Erlang 용어를 지정된 출력 스트림으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="01d810dcc882a2671bb99ec2a3f4b52034e71105" translate="yes" xml:space="preserve">
          <source>Prior to Erlang/OTP 21.0, supervisor, crash, and progress reports were only logged when the SASL application was running. This behaviour can, for backwards compatibility, be enabled by setting the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">Erlang / OTP 21.0 이전에는 수퍼바이저, 충돌 및 진행 보고서가 SASL 응용 프로그램이 실행 중일 때만 기록되었습니다. 커널 구성 매개 변수 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이전 버전과의 호환성을 위해이 동작을 사용할 수 있습니다 . 자세한 내용 은 SASL 사용 설명서의 &lt;code&gt;SASL Error Logging&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c5c3d6724263056f8e5809f4ae6b20baea9b0f8" translate="yes" xml:space="preserve">
          <source>Prior to Erlang/OTP 21.0, these reports were only logged when the SASL application was running, and they were printed trough SASL's own event handlers &lt;code&gt;sasl_report_tty_h&lt;/code&gt; and &lt;code&gt;sasl_report_file_h&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP 21.0 이전에는 이러한 보고서가 SASL 응용 프로그램이 실행 중일 때만 기록되었으며 SASL 자체 이벤트 핸들러 &lt;code&gt;sasl_report_tty_h&lt;/code&gt; 및 &lt;code&gt;sasl_report_file_h&lt;/code&gt; 를 통해 인쇄 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="06bdb66fe24b1bd0f13724edf2132df5e7b44cc6" translate="yes" xml:space="preserve">
          <source>Priority level &lt;code&gt;max&lt;/code&gt; is reserved for internal use in the Erlang runtime system, and is &lt;strong&gt;not&lt;/strong&gt; to be used by others.</source>
          <target state="translated">우선 순위 레벨 &lt;code&gt;max&lt;/code&gt; 는 Erlang 런타임 시스템에서 내부 용으로 예약 되어 있으며 다른 사람이 사용 &lt;strong&gt;해서는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="891a5ba970623a36963c697cb5e2983045ef4bf5" translate="yes" xml:space="preserve">
          <source>Private directory for a test suite. This directory is to be used when the test suite needs to write to files.</source>
          <target state="translated">테스트 스위트의 개인 디렉토리. 이 디렉토리는 테스트 스위트가 파일에 써야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1560d5e03a4510a6c6ad469d0a62cd63315c3854" translate="yes" xml:space="preserve">
          <source>Private key of the host matching the &lt;code&gt;Algorithm&lt;/code&gt;. It may be a reference to a 'ssh-rsa', rsa-sha2-* or 'ssh-dss' (NOT ecdsa) key stored in a loaded Engine.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 과 일치하는 호스트의 개인 키 . 로드 된 엔진에 저장된 'ssh-rsa', rsa-sha2- * 또는 'ssh-dss'(NOT ecdsa) 키에 대한 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="603f6c7b83b91ba3b66637cb17d80977c31db448" translate="yes" xml:space="preserve">
          <source>Private key of the user matching the &lt;code&gt;Algorithm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 과 일치하는 사용자의 개인 키 .</target>
        </trans-unit>
        <trans-unit id="74ad72304fcac0b5a69a08a6f5ec35c07a46f71f" translate="yes" xml:space="preserve">
          <source>Private use</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="b79a8e30c6fdcdcf9dd5d5409cd8498f3ab57c1c" translate="yes" xml:space="preserve">
          <source>Probe specifications can be found in &lt;code&gt;erts/emulator/beam/erlang_dtrace.d&lt;/code&gt;, and a few example scripts can be found under &lt;code&gt;lib/runtime_tools/examples/&lt;/code&gt;.</source>
          <target state="translated">프로브 사양은 &lt;code&gt;erts/emulator/beam/erlang_dtrace.d&lt;/code&gt; 에서 찾을 수 있으며 &lt;code&gt;lib/runtime_tools/examples/&lt;/code&gt; 에서 몇 가지 예제 스크립트를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f85f3223fd42f20ff0f4013198f3a0482c317dc6" translate="yes" xml:space="preserve">
          <source>Probes in the dtrace.so NIF library like this:</source>
          <target state="translated">dtrace.so NIF 라이브러리의 프로브는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4180fe17ea663764396b9e7a7c467588a0d635b1" translate="yes" xml:space="preserve">
          <source>Problems were found during the analysis.</source>
          <target state="translated">분석 중에 문제가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcd7a97391d07066e93a31ea99c263af50266780" translate="yes" xml:space="preserve">
          <source>Problems when extracting from a tar file, &lt;code&gt;erl_tar:extract/2&lt;/code&gt; returned &lt;code&gt;{error, {Name, Reason}}&lt;/code&gt;.</source>
          <target state="translated">tar 파일에서 추출 할 때 &lt;code&gt;erl_tar:extract/2&lt;/code&gt; 에서 &lt;code&gt;{error, {Name, Reason}}&lt;/code&gt; 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e976a26adbbfd7012fe545033a0a8839af4e4c58" translate="yes" xml:space="preserve">
          <source>Process IDs of processes linked to this one. Can also contain ports. If process monitoring is used, this field also tells in which direction the monitoring is in effect. That is, a link &quot;to&quot; a process tells you that the &quot;current&quot; process was monitoring the other, and a link &quot;from&quot; a process tells you that the other process was monitoring the current one.</source>
          <target state="translated">이 프로세스에 연결된 프로세스의 프로세스 ID 포트를 포함 할 수도 있습니다. 프로세스 모니터링이 사용되는 경우이 필드는 모니터링이 적용되는 방향을 알려줍니다. 즉, 프로세스에 대한 &quot;연결&quot;링크는 &quot;현재&quot;프로세스가 다른 프로세스를 모니터링하고 있음을 나타내며 프로세스 &quot;연결&quot;은 프로세스가 다른 프로세스가 현재 프로세스를 모니터링하고 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d7a28bb3334285a1e0ac0387ca14af38afa1bb3b" translate="yes" xml:space="preserve">
          <source>Process a received message</source>
          <target state="translated">수신 된 메시지 처리</target>
        </trans-unit>
        <trans-unit id="6ed08f16461a6d037cb208e9913ab037737a77bd" translate="yes" xml:space="preserve">
          <source>Process identifier of the &lt;code&gt;Kernel&lt;/code&gt; process. That is, the process that called either &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Kernel&lt;/code&gt; 프로세스 의 프로세스 식별자 . 즉, &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 를 호출 한 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="5350a81bb4d7a6e885720414c324c78fdac18460" translate="yes" xml:space="preserve">
          <source>Process identifier of the process created by the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; 콜백에 의해 생성 된 프로세스의 프로세스 식별자 .</target>
        </trans-unit>
        <trans-unit id="ec8568d5958f46e915bd83080ff98e0e79a75222" translate="yes" xml:space="preserve">
          <source>Process is monitored by pid.</source>
          <target state="translated">프로세스는 pid에 의해 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="beca56c90caa14898b2c241f5874170cc90c2a9c" translate="yes" xml:space="preserve">
          <source>Process metadata is set and updated with &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt;logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt;logger:update_process metadata/1&lt;/a&gt;&lt;/code&gt;, respectively. This metadata applies to the process on which these calls are made, and Logger adds the metadata to all log events issued on that process.</source>
          <target state="translated">프로세스 메타 데이터는 각각 &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt;logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt;logger:update_process metadata/1&lt;/a&gt;&lt;/code&gt; 로 설정 및 업데이트됩니다 . 이 메타 데이터는 이러한 호출이 수행되는 프로세스에 적용되며 로거는 해당 프로세스에서 발행 된 모든 로그 이벤트에 메타 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="67e5f2d87d665dc7e3929e88907eef304eb59bc0" translate="yes" xml:space="preserve">
          <source>Process the action requests and either return an error_descr() indicating some fatal error or a list of action replies (wildcarded or not).</source>
          <target state="translated">조치 요청을 처리하고 일부 치명적 오류를 나타내는 error_descr () 또는 조치 응답 목록 (와일드 카드 표시 여부)을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="6055fe67fe73591ecd6add960eb22a68e35be849" translate="yes" xml:space="preserve">
          <source>Processes an incoming message. Performs authentication and decryption as necessary. The return values should be passed the manager server.</source>
          <target state="translated">수신 메시지를 처리합니다. 필요에 따라 인증 및 암호 해독을 수행합니다. 리턴 값은 관리자 서버로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="288b10741351f050abd56115edaeab3cbc0b134b" translate="yes" xml:space="preserve">
          <source>Processes an incoming packet. Performs authentication and decryption as necessary. The return values should be passed to the agent.</source>
          <target state="translated">들어오는 패킷을 처리합니다. 필요에 따라 인증 및 암호 해독을 수행합니다. 리턴 값은 에이전트에 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed98243f088a1f790e5261686fb35da9e9e2e36b" translate="yes" xml:space="preserve">
          <source>Processes and ports added by process/port identifiers add the nodes these processes/ports reside on in the node list. More nodes can be added by clicking button &lt;strong&gt;Add Nodes&lt;/strong&gt;, or by right-clicking in the &lt;strong&gt;Nodes&lt;/strong&gt; list and select &lt;strong&gt;Add Nodes&lt;/strong&gt;. To remove nodes, select them, then right-click and choose &lt;strong&gt;Remove nodes&lt;/strong&gt;.</source>
          <target state="translated">프로세스 / 포트 식별자로 추가 된 프로세스 및 포트는 이러한 프로세스 / 포트가있는 노드를 노드 목록에 추가합니다. &lt;strong&gt;Add Nodes&lt;/strong&gt; 버튼을 클릭 하거나 &lt;strong&gt;Nodes&lt;/strong&gt; 목록 에서 마우스 오른쪽 버튼을 클릭하고 &lt;strong&gt;Add Nodes를&lt;/strong&gt; 선택 하여 더 많은 노드를 추가 할 수 있습니다 . 노드를 제거하려면 해당 노드를 선택한 다음 마우스 오른쪽 단추를 클릭하고 &lt;strong&gt;노드 제거를&lt;/strong&gt; 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf438e45a34ce6e54b5666dee9827f7d9908c9aa" translate="yes" xml:space="preserve">
          <source>Processes are added from the &lt;strong&gt;Applications&lt;/strong&gt; or &lt;strong&gt;Processes&lt;/strong&gt; tabs. Ports are added from the &lt;strong&gt;Ports&lt;/strong&gt; tab. A special &lt;strong&gt;new&lt;/strong&gt; identifier, meaning all processes, or ports, started after trace start, can be added with buttons &lt;strong&gt;Add 'new' Processes&lt;/strong&gt; and &lt;strong&gt;Add 'new' Ports&lt;/strong&gt;, respecively.</source>
          <target state="translated">프로세스는 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 또는 &lt;strong&gt;프로세스&lt;/strong&gt; 탭 에서 추가됩니다 . 포트는 &lt;strong&gt;포트&lt;/strong&gt; 탭 에서 추가됩니다 . 추적 시작 후 시작된 모든 프로세스 또는 포트를 의미 하는 특수한 &lt;strong&gt;새&lt;/strong&gt; 식별자는 &lt;strong&gt;'새'프로세스 &lt;/strong&gt;&lt;strong&gt;추가&lt;/strong&gt; 및 &lt;strong&gt;'새'포트 추가&lt;/strong&gt; 단추로 각각 &lt;strong&gt;추가&lt;/strong&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be549e5919a2d84debbcdab9c71aa73639ddafc7" translate="yes" xml:space="preserve">
          <source>Processes can be specified as registered names, globally registered names, or process identifiers. Ports can be specified as registered names or port identifiers. If a registered name is specified, the flags are set on processes/ports with this name on all active nodes.</source>
          <target state="translated">프로세스는 등록 된 이름, 전체적으로 등록 된 이름 또는 프로세스 식별자로 지정할 수 있습니다. 포트는 등록 된 이름 또는 포트 식별자로 지정할 수 있습니다. 등록 된 이름이 지정되면 플래그는 모든 활성 노드에서이 이름으로 프로세스 / 포트에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c93cc0cb1c7c1cf0a914f4b84e40d8422afe1f41" translate="yes" xml:space="preserve">
          <source>Processes can monitor other processes and detect process terminations, see &lt;code&gt;&lt;a href=&quot;processes#errors&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 프로세스를 모니터링하고 프로세스 종단을 검출 할 수있는 프로세스는, 참조 &lt;code&gt;&lt;a href=&quot;processes#errors&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="630a26a9de10b21d483dfee70c4d12d378a250c0" translate="yes" xml:space="preserve">
          <source>Processes communicate by sending and receiving messages. Messages are sent by using the &lt;code&gt;&lt;a href=&quot;expressions#send&quot;&gt;send operator !&lt;/a&gt;&lt;/code&gt; and received by calling &lt;code&gt;&lt;a href=&quot;expressions#receive&quot;&gt;receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스는 메시지를 송수신하여 통신합니다. &lt;code&gt;&lt;a href=&quot;expressions#send&quot;&gt;send operator !&lt;/a&gt;&lt;/code&gt; 를 사용하여 메시지를 보냅니다 ! &lt;code&gt;&lt;a href=&quot;expressions#receive&quot;&gt;receive&lt;/a&gt;&lt;/code&gt; 를 호출하여 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="d178bde37cb4db43efd1bc3bc63a9067eff3bf67" translate="yes" xml:space="preserve">
          <source>Processes in &lt;code&gt;ch_app&lt;/code&gt; for which code have not been updated, for example, the supervisor, are still evaluating code from &lt;code&gt;ch_app-1&lt;/code&gt;.</source>
          <target state="translated">코드가 업데이트되지 않은 &lt;code&gt;ch_app&lt;/code&gt; 의 프로세스 ( 예 : 감독자)는 여전히 &lt;code&gt;ch_app-1&lt;/code&gt; 의 코드를 평가하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="033f59a44cf3d7e0ad2fb2a6c9d6d37906dc4f55" translate="yes" xml:space="preserve">
          <source>Processes sending command data to the port are suspended if either the port is busy or if the port message queue is busy. Suspended processes are resumed when neither the port or the port message queue is busy.</source>
          <target state="translated">포트가 사용 중이거나 포트 메시지 큐가 사용 중이면 명령 데이터를 포트로 전송하는 프로세스가 일시 중단됩니다. 포트 또는 포트 메시지 큐가 사용 중이 아니면 일시 중단 된 프로세스가 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="7813ce8e07b59a64bbf71e0e1c1f12985cd75cf4" translate="yes" xml:space="preserve">
          <source>Processes sending command data to the port are suspended if either the port or the port message queue is busy. Suspended processes are resumed when neither the port or the port message queue is busy. Command data is in this context data passed to the port using either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="translated">포트 또는 포트 메시지 큐가 사용 중이면 명령 데이터를 포트로 보내는 프로세스가 일시 중단됩니다. 포트 또는 포트 메시지 큐가 사용 중이 아니면 일시 중단 된 프로세스가 재개됩니다. 명령 데이터는이 컨텍스트에서 &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; 또는 &lt;code&gt;port_command/[2,3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a29be095a2ff95859b3cad24b61604a71c86c0b" translate="yes" xml:space="preserve">
          <source>Processes started with functions &lt;code&gt;proc_lib:spawn&lt;/code&gt; or &lt;code&gt;proc_lib:spawn_link&lt;/code&gt; are wrapped within a &lt;code&gt;catch&lt;/code&gt;. A crash report is issued when such a process terminates with an unexpected reason, which is any reason other than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;. Processes using behaviors &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt; or &lt;code&gt;gen_statem&lt;/code&gt; are examples of such processes. A crash report contains the following items:</source>
          <target state="translated">&lt;code&gt;proc_lib:spawn&lt;/code&gt; 또는 &lt;code&gt;proc_lib:spawn_link&lt;/code&gt; 함수로 시작된 프로세스 는 &lt;code&gt;catch&lt;/code&gt; 내에 래핑됩니다 . 이러한 프로세스가 예기치 않은 이유로 종료 될 경우 충돌 보고서가 발행되는데, 이는 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유 입니다. &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_fsm&lt;/code&gt; 또는 &lt;code&gt;gen_statem&lt;/code&gt; 동작을 사용하는 프로세스 가 이러한 프로세스의 예입니다. 충돌 보고서에는 다음 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a39a6bcdcfd7777bfaedcdb0b7cb9d27d3872a4" translate="yes" xml:space="preserve">
          <source>Processes that are not implemented as one of the standard behaviors must still understand system messages. The following three messages must be understood:</source>
          <target state="translated">표준 동작 중 하나로 구현되지 않은 프로세스는 여전히 시스템 메시지를 이해해야합니다. 다음 세 가지 메시지를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="58c7efb2fc2ee91313efcb0b51ba3d6222f1b4e4" translate="yes" xml:space="preserve">
          <source>Processes, ports and ets tables can then be inspecting using their respective info functions, i.e. &lt;code&gt;erlang:process_info/2&lt;/code&gt;, &lt;code&gt;erlang:port_info/2&lt;/code&gt; and &lt;code&gt;ets:info/1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 프로세스, 포트 및 ets 테이블은 각각의 정보 기능 (예 : &lt;code&gt;erlang:process_info/2&lt;/code&gt; , &lt;code&gt;erlang:port_info/2&lt;/code&gt; 및 &lt;code&gt;ets:info/1&lt;/code&gt; )을 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6017176610426ad0695826f94e970fac5ae785f" translate="yes" xml:space="preserve">
          <source>Processing Local Requests</source>
          <target state="translated">로컬 요청 처리</target>
        </trans-unit>
        <trans-unit id="2f93aa73375c48e5ac1052bbdea13b31c4c62dea" translate="yes" xml:space="preserve">
          <source>Processing Received Answers</source>
          <target state="translated">받은 답변 처리</target>
        </trans-unit>
        <trans-unit id="47c0c8f7f7c694d8170efc2ece7ee9a4d20e521e" translate="yes" xml:space="preserve">
          <source>Processing options such as case-independence are fixed when a subpattern is defined, so if it is used as a subroutine, such options cannot be changed for different calls. For example, the following pattern matches &quot;abcabc&quot; but not &quot;abcABC&quot;, as the change of processing option does not affect the called subpattern:</source>
          <target state="translated">서브 패턴이 정의되면 대소 문자 독립성과 같은 처리 옵션이 고정되므로 서브 루틴으로 사용되는 경우 다른 호출에 대해 이러한 옵션을 변경할 수 없습니다. 예를 들어, 처리 옵션 변경이 호출 된 서브 패턴에 영향을주지 않으므로 다음 패턴은 &quot;abcabc&quot;와 일치하지만 &quot;abcABC&quot;와는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eab01ffe9a07f631f008bdf0c75bf332d75ff92" translate="yes" xml:space="preserve">
          <source>Produces a Makefile rule to track header dependencies. The rule is sent to &lt;code&gt;stdout&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">헤더 종속성을 추적하는 Makefile 규칙을 생성합니다. 규칙은 &lt;code&gt;stdout&lt;/code&gt; 으로 전송됩니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0b65fd07934b92a1f3f3b16fdae0415377d8f3" translate="yes" xml:space="preserve">
          <source>Produces a Makefile rule to track headers dependencies. No object file is produced.</source>
          <target state="translated">헤더 종속성을 추적하는 Makefile 규칙을 생성합니다. 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="522655e258c4e569c30e0510cdca6d0699bc8809" translate="yes" xml:space="preserve">
          <source>Produces a list of miscellaneous information. Intended for debugging. If no profile is specified, the default profile is used.</source>
          <target state="translated">기타 정보 목록을 생성합니다. 디버깅을위한 것입니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17b15b2832a09a04ae3469c8eba4b0f7717aeed3" translate="yes" xml:space="preserve">
          <source>Produces a list of the entire cookie database. Intended for debugging/testing purposes. If no profile is specified, the default profile is used.</source>
          <target state="translated">전체 쿠키 데이터베이스의 목록을 생성합니다. 디버깅 / 테스트 목적으로 사용됩니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4a70cdd8befb25aae49184a69129ba10dc3026" translate="yes" xml:space="preserve">
          <source>Produces a listing of the assembler code in the file &lt;code&gt;&amp;lt;File&amp;gt;.S&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;File&amp;gt;.S&lt;/code&gt; 파일에 어셈블러 코드 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14a6e3657dbd240095b72afb45cd733b01f3e525" translate="yes" xml:space="preserve">
          <source>Produces a listing of the code, after all source code transformations have been performed, in the file &lt;code&gt;&amp;lt;File&amp;gt;.E&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;File&amp;gt;.E&lt;/code&gt; 파일에서 모든 소스 코드 변환이 수행 된 후 코드 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e05890546d0a6ddd75cdab592794da9dd67dbc" translate="yes" xml:space="preserve">
          <source>Produces a listing of the parsed code, after preprocessing and parse transforms, in the file &lt;code&gt;&amp;lt;File&amp;gt;.P&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">사전 처리 및 구문 분석 변환 후 &lt;code&gt;&amp;lt;File&amp;gt;.P&lt;/code&gt; 파일에서 구문 분석 된 코드의 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b42942b44b3250eb3b2271073a1658bcb5331121" translate="yes" xml:space="preserve">
          <source>Produces a new map &lt;code&gt;Map&lt;/code&gt; by calling function &lt;code&gt;fun F(K, V1)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V1&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/2&lt;/code&gt; must return value &lt;code&gt;V2&lt;/code&gt; to be associated with key &lt;code&gt;K&lt;/code&gt; for the new map &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">매 &lt;code&gt;K&lt;/code&gt; 마다 함수 &lt;code&gt;fun F(K, V1)&lt;/code&gt; 를 호출 하여 &lt;code&gt;MapOrIter&lt;/code&gt; 의 &lt;code&gt;V1&lt;/code&gt; 연관 을 어떤 순서 로든 호출 하여 새 맵 &lt;code&gt;Map&lt;/code&gt; 을 생성합니다 . 함수 &lt;code&gt;fun F/2&lt;/code&gt; 는 새 맵 &lt;code&gt;Map&lt;/code&gt; 의 키 &lt;code&gt;K&lt;/code&gt; 와 연관되도록 값 &lt;code&gt;V2&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="734f2970d4a5791f19c5ec99de733cebe7c5db24" translate="yes" xml:space="preserve">
          <source>Produces a slightly processed dump of the session database. It is intended for debugging. If no profile is specified, the default profile is used.</source>
          <target state="translated">약간 처리 된 세션 데이터베이스 덤프를 생성합니다. 디버깅을위한 것입니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e2b5bef8d3aea29dc3d87dc03c8bd706ff3c63" translate="yes" xml:space="preserve">
          <source>Produces an Erlang binary object from a buffer containing a sequence of bytes.</source>
          <target state="translated">바이트 시퀀스를 포함하는 버퍼에서 Erlang 이진 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28dc5d49200b0d0db7991c1bd65981ee7a79b5b9" translate="yes" xml:space="preserve">
          <source>Product identification, or similar.</source>
          <target state="translated">제품 식별 또는 유사</target>
        </trans-unit>
        <trans-unit id="47c4b8b7bf496f53b2cc4542ca4954138de2040e" translate="yes" xml:space="preserve">
          <source>Product-Name AVP</source>
          <target state="translated">제품 이름 AVP</target>
        </trans-unit>
        <trans-unit id="17df105acacb67dbb629858e9cd9d8d447c45b58" translate="yes" xml:space="preserve">
          <source>Profile :: atom()) -&amp;gt;</source>
          <target state="translated">프로필 :: atom ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0026a969a9cb473a3dd25bc732d4ff9709ac80a8" translate="yes" xml:space="preserve">
          <source>Profile :: term()) -&amp;gt;</source>
          <target state="translated">프로필 :: term ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="57c6e422edb8ce7e828dbfdc0ca3e7e40b6fc1e1" translate="yes" xml:space="preserve">
          <source>Profile process locks, equal to adding &lt;code&gt;process&lt;/code&gt; to the lock category mask; see &lt;code&gt;lcnt:rt_mask/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; 를 잠금 카테고리 마스크 에 추가하는 것과 동일한 프로세스 잠금 ; 참조 &lt;code&gt;lcnt:rt_mask/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f72795f752c26fa8b5758727320096204ecec91e" translate="yes" xml:space="preserve">
          <source>Profiling is done in the following steps:</source>
          <target state="translated">프로파일 링은 다음 단계에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="630e9fa5225f76b674631196640d8884476f77f0" translate="yes" xml:space="preserve">
          <source>Profiling is essentially done in 3 steps:</source>
          <target state="translated">프로파일 링은 기본적으로 3 단계로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="129873d7917621f62579cca8da507adfd58f5037" translate="yes" xml:space="preserve">
          <source>Profiling; the trace file is read and raw profile data is collected into an internal RAM storage on the node. During this step the trace data may be dumped in text format to file or console.</source>
          <target state="translated">프로파일 링; 추적 파일을 읽고 원시 프로파일 데이터가 노드의 내부 RAM 스토리지에 수집됩니다. 이 단계에서 추적 데이터는 텍스트 형식으로 파일 또는 콘솔에 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="864662422fc6799b55caf37fed8419aea855ecf3" translate="yes" xml:space="preserve">
          <source>Profiling; the trace file is read, the execution call stack is simulated, and raw profile data is calculated from the simulated call stack and the trace timestamps. The profile data is stored in the &lt;code&gt;fprof&lt;/code&gt; server state. During this step the trace data may be dumped in text format to file or console.</source>
          <target state="translated">프로파일 링; 추적 파일을 읽고, 실행 호출 스택을 시뮬레이션하고, 원시 프로파일 데이터가 시뮬레이션 된 호출 스택 및 추적 타임 스탬프에서 계산됩니다. 프로필 데이터는 &lt;code&gt;fprof&lt;/code&gt; 서버 상태로 저장됩니다 . 이 단계에서 추적 데이터는 텍스트 형식으로 파일 또는 콘솔에 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be14140f572829d13e013899b88b1a29c94a894b" translate="yes" xml:space="preserve">
          <source>Program used for starting Common Test from the OS command line.</source>
          <target state="translated">OS 명령 행에서 공통 테스트를 시작하는 데 사용되는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="04fc4ca4a8116882232b1856689a04eb18a1fd86" translate="yes" xml:space="preserve">
          <source>Programmers are strongly advised not to engage in parse transformations. No support is offered for problems encountered.</source>
          <target state="translated">프로그래머는 구문 분석 변환에 관여하지 않는 것이 좋습니다. 발생한 문제에 대한 지원은 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd20cc773cac79796c578e4d9775b5144b70f227" translate="yes" xml:space="preserve">
          <source>Programming Erlang: Software for a Concurrent World (2007), Pragmatic Bookshelf, ISBN13: 9781934356005.</source>
          <target state="translated">Erlang 프로그래밍 : 동시 세계를위한 소프트웨어 (2007), Pragmatic Bookshelf, ISBN13 : 9781934356005.</target>
        </trans-unit>
        <trans-unit id="04bef1b7e7ac277d38fb7b2086faa2a0ce21e478" translate="yes" xml:space="preserve">
          <source>Programming Erlang: Software for a Concurrent World by Joe Armstrong; ISBN: 978-1-93435-600-5</source>
          <target state="translated">프로그래밍 Erlang : Joe Armstrong의 동시 세계 용 소프트웨어; ISBN : 978-1-93435-600-5</target>
        </trans-unit>
        <trans-unit id="4fff5c0832402c080338f74960f55c82c6dba845" translate="yes" xml:space="preserve">
          <source>Programming concurrent Erlang systems is the subject of a separate book. However, it is worthwhile to draw attention to the following features, which permit concurrent processes to exist in a &lt;code&gt;Mnesia&lt;/code&gt; system:</source>
          <target state="translated">동시 Erlang 시스템 프로그래밍은 별도의 책의 주제입니다. 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에 동시 프로세스가 존재할 수 있도록 다음 기능에주의를 기울여야 합니다.</target>
        </trans-unit>
        <trans-unit id="f766991f1e78a66d69e7e9b58e7feee18bce8c08" translate="yes" xml:space="preserve">
          <source>Programs should always operate on a normalized form and compare canonical-equivalent Unicode characters as equal. All characters should thus be normalized to one form once on the system borders. One of the following functions can convert characters to their normalized forms &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt;characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt;characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt;. For general text &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; is preferred, and for identifiers one of the compatibility normalization functions, such as &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt;characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt;, is preferred for security reasons. The normalization functions where introduced in OTP 20. Additional information on normalization can be found in the &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로그램은 항상 정규화 된 형식으로 작동해야하며 동등한 동등한 유니 코드 문자를 비교해야합니다. 따라서 모든 문자는 시스템 경계에서 한 형태로 한 번만 정규화되어야합니다. 다음 함수 중 하나는 문자를 정규화 된 양식 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt;characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt;characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt; 로 변환 할 수 있습니다 . 일반 텍스트 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; 이 선호되며 식별자의 경우 &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt;characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt; 과 같은 호환성 정규화 함수 중 하나입니다.보안상의 이유로 선호됩니다. 정규화 기능은 OTP 20에 도입 된 기능입니다. 정규화에 대한 추가 정보는 &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc562a9bcac4fb874aa74077af2a891fe251b3ed" translate="yes" xml:space="preserve">
          <source>Programs that process plain text or binary data files.</source>
          <target state="translated">일반 텍스트 또는 이진 데이터 파일을 처리하는 프로그램.</target>
        </trans-unit>
        <trans-unit id="7c71281f9dbe691f92bb15faa53cb0c49a91d43a" translate="yes" xml:space="preserve">
          <source>Progress = &lt;code&gt;ignore | {CBModule, CBFunction, InitProgress}&lt;/code&gt;</source>
          <target state="translated">진행 = &lt;code&gt;ignore | {CBModule, CBFunction, InitProgress}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="519ffd1265424ff9151c74fa5631e9848160fa7a" translate="yes" xml:space="preserve">
          <source>Progress report</source>
          <target state="translated">진행 보고서</target>
        </trans-unit>
        <trans-unit id="a3f10a152d854770b6ab1de6f50d8a4da946dbb4" translate="yes" xml:space="preserve">
          <source>Progress reports are issued as &lt;code&gt;info&lt;/code&gt; level log events, and since the default primary log level is &lt;code&gt;notice&lt;/code&gt;, these are not logged by default. To enable printing of progress reports, set the &lt;code&gt;&lt;a href=&quot;#primary_level&quot;&gt;primary log level&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;info&lt;/code&gt;.</source>
          <target state="translated">진행률 보고서는 &lt;code&gt;info&lt;/code&gt; 레벨 로그 이벤트 로 발행되며 기본 1 차 로그 레벨이 &lt;code&gt;notice&lt;/code&gt; 이므로 기본적으로 로그 되지 않습니다. 진행률 보고서를 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#primary_level&quot;&gt;primary log level&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;info&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2feeef99e0f2d9657de9874ba0e75f9b066346ff" translate="yes" xml:space="preserve">
          <source>Propagate the same error signal to the links of the killed process.</source>
          <target state="translated">종료 된 프로세스의 링크에 동일한 오류 신호를 전파하십시오.</target>
        </trans-unit>
        <trans-unit id="5eb34826139e0a6c504423934bde097d38a8e5ac" translate="yes" xml:space="preserve">
          <source>Properties are not inherited from top-level groups to nested subgroups. For instance, in the previous example, the test cases in &lt;code&gt;group2&lt;/code&gt; are not executed in random order (which is the property of &lt;code&gt;group1&lt;/code&gt;).</source>
          <target state="translated">최상위 그룹에서 중첩 하위 그룹으로 속성이 상속되지 않습니다. 예를 들어, 이전 예제에서 &lt;code&gt;group2&lt;/code&gt; 의 테스트 케이스 는 무작위 순서 ( &lt;code&gt;group1&lt;/code&gt; 의 특성)로 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cf72435a6a8dfe264c2d8cbb64919ecfbaeba5bb" translate="yes" xml:space="preserve">
          <source>Property lists are ordinary lists containing entries in the form of either tuples, whose first elements are keys used for lookup and insertion, or atoms, which work as shorthand for tuples &lt;code&gt;{Atom, true}&lt;/code&gt;. (Other terms are allowed in the lists, but are ignored by this module.) If there is more than one entry in a list for a certain key, the first occurrence normally overrides any later (irrespective of the arity of the tuples).</source>
          <target state="translated">속성 목록은 첫 번째 요소가 조회 및 삽입에 사용되는 키인 튜플 또는 튜플 &lt;code&gt;{Atom, true}&lt;/code&gt; 속기 역할을하는 원자 형식의 항목을 포함하는 일반 목록 입니다. (다른 용어는 목록에서 허용되지만이 모듈에서는 무시됩니다.) 특정 키에 대한 목록에 둘 이상의 항목이있는 경우 첫 번째 항목은 일반적으로 이후에 우선합니다 (튜플의 특성에 관계없이).</target>
        </trans-unit>
        <trans-unit id="8f3a63f6f6853f3776df6fd40f512c3bc2423c62" translate="yes" xml:space="preserve">
          <source>Property lists are useful for representing inherited properties, such as options passed to a function where a user can specify options overriding the default settings, object properties, annotations, and so on.</source>
          <target state="translated">속성 목록은 사용자가 기본 설정, 객체 속성, 주석 등을 재정의하는 옵션을 지정할 수있는 함수에 전달 된 옵션과 같은 상속 된 속성을 나타내는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69ef40d1cd2975594eba3c5b03a443daf8151c13" translate="yes" xml:space="preserve">
          <source>Protocol Errors</source>
          <target state="translated">프로토콜 오류</target>
        </trans-unit>
        <trans-unit id="1b0a81e8f360216134418545602ccf414662dde9" translate="yes" xml:space="preserve">
          <source>Protocol Messages</source>
          <target state="translated">프로토콜 메시지</target>
        </trans-unit>
        <trans-unit id="2e1b345b4778495a0a85f0806404f2ef32e5c47c" translate="yes" xml:space="preserve">
          <source>Protocol Overview</source>
          <target state="translated">프로토콜 개요</target>
        </trans-unit>
        <trans-unit id="c07efc54af15e46ede9045b5a09cbf868ae19105" translate="yes" xml:space="preserve">
          <source>Prototypes for the driver callback routines can be found in the &lt;code&gt;erl_driver.h&lt;/code&gt; header file.</source>
          <target state="translated">드라이버 콜백 루틴의 프로토 타입은 &lt;code&gt;erl_driver.h&lt;/code&gt; 헤더 파일 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f653b51c616d14c355967d6de899534adb195231" translate="yes" xml:space="preserve">
          <source>Prototyping</source>
          <target state="translated">Prototyping</target>
        </trans-unit>
        <trans-unit id="1f374df4d309c019bc6178248783e9390656a10a" translate="yes" xml:space="preserve">
          <source>Provide a fun to implement your own logging of the SSH message SSH_MSG_DEBUG. The last three parameters are from the message, see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4253#section-11.3&quot;&gt;RFC 4253, section 11.3&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#type-connection_ref&quot;&gt;connection_ref()&lt;/a&gt;&lt;/code&gt; is the reference to the connection on which the message arrived. The return value from the fun is not checked.</source>
          <target state="translated">SSH 메시지 SSH_MSG_DEBUG에 대한 자체 로깅을 구현하는 재미를 제공하십시오. 마지막 3 개의 매개 변수는 메시지에서 온 것입니다 ( &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4253#section-11.3&quot;&gt;RFC 4253, section 11.3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#type-connection_ref&quot;&gt;connection_ref()&lt;/a&gt;&lt;/code&gt; 메시지가 도착한 연결에 대한 참조이다. 재미의 반환 값은 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08a2504f6114a9c36ec403b96c7c302a482e126f" translate="yes" xml:space="preserve">
          <source>Provide default headers for the HTTP servers responses. Note that this option may override built-in defaults.</source>
          <target state="translated">HTTP 서버 응답에 대한 기본 헤더를 제공하십시오. 이 옵션은 내장 기본값을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bca3403285a45fca5f582216c20e2b31fefe923" translate="yes" xml:space="preserve">
          <source>Provide some simple support for sequential tracing.</source>
          <target state="translated">순차 추적에 대한 간단한 지원을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="410239829c19fb6bb8f95e6437ab94a49a5db9bc" translate="yes" xml:space="preserve">
          <source>Provides a decryption key for &lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt; 대한 암호 해독 키를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="903b44886dfe622745223d5547c0cc9c2859f2f6" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging or other action when an unexpected message arrives. If the fun returns &lt;code&gt;report&lt;/code&gt; the usual info report is issued but if &lt;code&gt;skip&lt;/code&gt; is returned no report is generated.</source>
          <target state="translated">예기치 않은 메시지가 도착했을 때 자신의 로깅 또는 기타 작업을 구현할 수있는 재미를 제공합니다. 재미가 &lt;code&gt;report&lt;/code&gt; 반환 하면 일반적인 정보 보고서가 발행되지만 &lt;code&gt;skip&lt;/code&gt; 가 반환 되면 보고서가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8122202de6a4acb088d775f3973da908d4fecce" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when a user authenticates to the server.</source>
          <target state="translated">사용자가 서버에 인증 할 때 고유 한 로깅을 구현할 수있는 재미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ae014fb7ce0d00946111ea1f6afbd515ba680d3" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when a user fails to authenticate.</source>
          <target state="translated">사용자가 인증에 실패하면 자신의 로깅을 구현할 수있는 재미있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="693b50c9238225aebe1905f9a4bbeddbe802666a" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when the peer disconnects.</source>
          <target state="translated">피어 연결이 끊어졌을 때 사용자 고유의 로깅을 구현하는 재미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2622540d75e1ce825909c4c27dcf1a5e81b022b9" translate="yes" xml:space="preserve">
          <source>Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values.</source>
          <target state="translated">비밀번호 유효성 검사 기능을 제공합니다. 이것은 외부 시스템을 호출하거나 해시 값으로 저장된 암호를 처리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02519300dbb28165f9b31d399e480b06aff4a3e" translate="yes" xml:space="preserve">
          <source>Provides a function for password validation. This function is called with user and password as strings, and returns:</source>
          <target state="translated">비밀번호 유효성 검사 기능을 제공합니다. 이 함수는 사용자 및 비밀번호를 문자열로 사용하여 호출되며 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6aa5ff7905134531fc9760a2816fc0228545f5bd" translate="yes" xml:space="preserve">
          <source>Provides a function for tab-completion (expansion) like the Erlang shell. This function is called when the user presses the &lt;strong&gt;Tab&lt;/strong&gt; key. The expansion is active when calling line-reading functions, such as &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘과 같은 탭 완성 (확장) 기능을 제공합니다. 이 기능은 사용자가 &lt;strong&gt;Tab&lt;/strong&gt; 키를 누를 때 호출됩니다 . &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 와 같은 행 읽기 기능을 호출 할 때 확장이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0126483ea757d9c456fac59884fa78b1895b0c1d" translate="yes" xml:space="preserve">
          <source>Provides a global password that authenticates any user.</source>
          <target state="translated">모든 사용자를 인증하는 글로벌 비밀번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bcf2a440040f1adc832c9af437538a1274c09fbb" translate="yes" xml:space="preserve">
          <source>Provides a list of the scheme and their default port numbers supported (by default) by this utility.</source>
          <target state="translated">이 유틸리티가 지원하는 체계 및 기본 포트 번호 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="882538ba1337b4bc7c8a6a34a8a92a54495af42b" translate="yes" xml:space="preserve">
          <source>Provides a name for the NIF that is scheduled for execution. If it cannot be converted to an atom, &lt;code&gt;enif_schedule_nif&lt;/code&gt; returns a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">실행이 예정된 NIF의 이름을 제공합니다. 원자로 변환 할 수 없으면 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 는 &lt;code&gt;badarg&lt;/code&gt; 예외를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9a7fa191207bdbdcf1355b3abd90f2d61475ca15" translate="yes" xml:space="preserve">
          <source>Provides a password for password authentication. If this option is not given, the user is asked for a password, if the password authentication method is attempted.</source>
          <target state="translated">비밀번호 인증을위한 비밀번호를 제공합니다. 이 옵션을 지정하지 않으면 비밀번호 인증 방법을 시도 할 경우 사용자에게 비밀번호를 묻습니다.</target>
        </trans-unit>
        <trans-unit id="2e6245a80cc81adaed06ea9939826c09d6c8984a" translate="yes" xml:space="preserve">
          <source>Provides a way of filtering log events based on a &lt;code&gt;domain&lt;/code&gt; field in &lt;code&gt;Metadata&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Metadata&lt;/code&gt; 의 &lt;code&gt;domain&lt;/code&gt; 필드를 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="955f63ea342c9ccdf55e0b9ef1640dd09419b809" translate="yes" xml:space="preserve">
          <source>Provides a way of filtering log events based on the log level.</source>
          <target state="translated">로그 수준을 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="917a3a6ad732d2f5671eafaeed7176e9ef18f549" translate="yes" xml:space="preserve">
          <source>Provides access to the registry on Windows.</source>
          <target state="translated">Windows에서 레지스트리에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05ac5290f4045fe43f63e391afe9724d565253dd" translate="yes" xml:space="preserve">
          <source>Provides an Erlang interface to communicate with relational SQL-databases. It is built on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to the database that you want to connect to. The Erlang ODBC application is designed using the version 3.0 of the ODBC-standard, however using the option &lt;code&gt;{scrollable_cursors, off}&lt;/code&gt; for a connection has been known to make it work for at least some 2.X drivers.</source>
          <target state="translated">관계형 SQL 데이터베이스와 통신하기위한 Erlang 인터페이스를 제공합니다. Microsoft의 ODBC 인터페이스 위에 구축되므로 연결할 데이터베이스에 대한 ODBC 드라이버가 있어야합니다. Erlang ODBC 응용 프로그램은 ODBC 표준 버전 3.0을 사용하여 설계되었지만 연결에 대해 &lt;code&gt;{scrollable_cursors, off}&lt;/code&gt; 옵션을 사용하면 최소한 2.X 드라이버에서 작동하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79e1bbf3ee82741dfe60b12a6243392fa5cd563" translate="yes" xml:space="preserve">
          <source>Provides base64 encode and decode, see &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base64 인코딩 및 디코딩을 제공합니다 ( &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4e9af3af74f64719e08406feffc5d04267f3391b" translate="yes" xml:space="preserve">
          <source>Provides base64 encode and decode, see RFC 2045.</source>
          <target state="translated">base64 인코딩 및 디코딩을 제공합니다 (RFC 2045 참조).</target>
        </trans-unit>
        <trans-unit id="0767fcb9cf2d27bebf009a5c390e3880f87527f9" translate="yes" xml:space="preserve">
          <source>Provides extended diagnostics, use &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">확장 된 진단 기능을 제공합니다 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1.&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e583caf4df904713adcce17bae909ffac9b6bbf8" translate="yes" xml:space="preserve">
          <source>Provides functions to handle public-key infrastructure, for details see &lt;code&gt;public_key(6)&lt;/code&gt;.</source>
          <target state="translated">공개 키 인프라를 처리하는 기능을 제공합니다. 자세한 내용은 &lt;code&gt;public_key(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b490ba126a125b5dbe6b1345ee3fd68b833fe2f" translate="yes" xml:space="preserve">
          <source>Provides information about the FIPS operating status of crypto and the underlying OpenSSL library. If crypto was built with FIPS support this can be either &lt;code&gt;enabled&lt;/code&gt; (when running in FIPS mode) or &lt;code&gt;not_enabled&lt;/code&gt;. For other builds this value is always &lt;code&gt;not_supported&lt;/code&gt;.</source>
          <target state="translated">암호화 및 기본 OpenSSL 라이브러리의 FIPS 작동 상태에 대한 정보를 제공합니다. 암호화가 FIPS 지원으로 빌드 된 경우이를 &lt;code&gt;enabled&lt;/code&gt; (FIPS 모드에서 실행할 때)하거나 &lt;code&gt;not_enabled&lt;/code&gt; 할 수 있습니다 . 다른 빌드의 경우이 값은 항상 &lt;code&gt;not_supported&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e528ef223145dad4b73216f63054349090dcd33" translate="yes" xml:space="preserve">
          <source>Provides more control than the &lt;code&gt;load/2&lt;/code&gt;/&lt;code&gt;reload/2&lt;/code&gt; and &lt;code&gt;load_driver/2&lt;/code&gt;/&lt;code&gt;reload_driver/2&lt;/code&gt; interfaces. It never waits for completion of other operations related to the driver, but immediately returns the status of the driver as one of the following:</source>
          <target state="translated">&lt;code&gt;load/2&lt;/code&gt; / &lt;code&gt;reload/2&lt;/code&gt; 및 &lt;code&gt;load_driver/2&lt;/code&gt; / &lt;code&gt;reload_driver/2&lt;/code&gt; 인터페이스 보다 더 많은 제어 기능을 제공합니다 . 드라이버와 관련된 다른 작업이 완료 될 때까지 기다리지 않지만 다음 중 하나로 드라이버의 상태를 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15c9038fc5b1524a7c052b7a20860ee70d660228" translate="yes" xml:space="preserve">
          <source>Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords.</source>
          <target state="translated">비밀번호 인증을위한 비밀번호를 제공합니다. 암호는 누군가 서버에 연결하려고 시도하고 공개 키 사용자 인증에 실패한 경우에 사용됩니다. 이 옵션은 유효한 사용자 이름 및 해당 비밀번호 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b074a4910398fb49d04cfd408836de827bf0e394" translate="yes" xml:space="preserve">
          <source>Provides the flag &lt;code&gt;-boot&lt;/code&gt; specifying the boot file of the release version found (&lt;code&gt;&quot;releases/FIRST/start.boot&quot;&lt;/code&gt;).</source>
          <target state="translated">찾은 릴리스 버전의 부팅 파일 ( &lt;code&gt;&quot;releases/FIRST/start.boot&quot;&lt;/code&gt; )을 지정 하여 플래그 &lt;code&gt;-boot&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a72441e1164e80082373bf66638549573dc043ff" translate="yes" xml:space="preserve">
          <source>Provides the name and version of the libraries used by crypto.</source>
          <target state="translated">암호화에 사용되는 라이브러리의 이름과 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77276a6c8bb030519317824295c69e75a13fdde9" translate="yes" xml:space="preserve">
          <source>Provides the username. If this option is not given, &lt;code&gt;ssh&lt;/code&gt; reads from the environment (&lt;code&gt;LOGNAME&lt;/code&gt; or &lt;code&gt;USER&lt;/code&gt; on UNIX, &lt;code&gt;USERNAME&lt;/code&gt; on Windows).</source>
          <target state="translated">사용자 이름을 제공합니다. 이 옵션을 지정하지 않으면 &lt;code&gt;ssh&lt;/code&gt; 가 환경에서 읽습니다 ( UNIX의 경우 &lt;code&gt;LOGNAME&lt;/code&gt; 또는 &lt;code&gt;USER&lt;/code&gt; , Windows의 경우 &lt;code&gt;USERNAME&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b09826e2df02ed043b8710bf898e2179004a2680" translate="yes" xml:space="preserve">
          <source>Provides your own CLI implementation in a daemon.</source>
          <target state="translated">데몬에서 고유 한 CLI 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6337706f6e77732d06ad836d88d60b82dd945341" translate="yes" xml:space="preserve">
          <source>Proxy Agents</source>
          <target state="translated">프록시 에이전트</target>
        </trans-unit>
        <trans-unit id="a7d3fe08253cdc3ad07d2f5dabfe674d1aa52bd9" translate="yes" xml:space="preserve">
          <source>Proxy-Host AVP</source>
          <target state="translated">프록시 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="aaa9a1afcf35a6a510bb9543bf0d6f52952fb297" translate="yes" xml:space="preserve">
          <source>Proxy-Info AVP</source>
          <target state="translated">프록시 정보 AVP</target>
        </trans-unit>
        <trans-unit id="64812682c3ee84678a9b41d9cc2b26f19b76cc5c" translate="yes" xml:space="preserve">
          <source>Proxy-State AVP</source>
          <target state="translated">프록시 상태 AVP</target>
        </trans-unit>
        <trans-unit id="40db0b3883f06edc9792ae47fe2fd8fc1148af25" translate="yes" xml:space="preserve">
          <source>Psalter_Pahlavi</source>
          <target state="translated">Psalter_Pahlavi</target>
        </trans-unit>
        <trans-unit id="d0fdfc27d15a90f7600623009abb8fe006b3ef96" translate="yes" xml:space="preserve">
          <source>Pseudo function that by a &lt;code&gt;parse_transform&lt;/code&gt; translates &lt;code&gt;LiteralFun&lt;/code&gt; typed as parameter in the function call to a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. With &quot;literal&quot; is meant that the fun must textually be written as the parameter of the function, it cannot be held in a variable that in turn is passed to the function.</source>
          <target state="translated">a로한다는 의사 기능 &lt;code&gt;parse_transform&lt;/code&gt; 가 번역 &lt;code&gt;LiteralFun&lt;/code&gt; 는 A와 함수 호출에서 매개 변수로 입력 한 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; . &quot;리터럴&quot;이란 재미는 문자 적으로 함수의 매개 변수로 텍스트로 작성되어야 함을 의미하며, 함수에 전달되는 변수에 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b76821618a6e81543a9111bbe440dd93c8037696" translate="yes" xml:space="preserve">
          <source>Pseudo function that by means of a &lt;code&gt;parse_transform&lt;/code&gt; translates the &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;fun()&lt;/code&gt; typed as parameter in the function call to a match specification as described in the &lt;code&gt;match_spec&lt;/code&gt; manual of ERTS users guide. (with literal I mean that the &lt;code&gt;fun()&lt;/code&gt; needs to textually be written as the parameter of the function, it cannot be held in a variable which in turn is passed to the function).</source>
          <target state="translated">&lt;code&gt;parse_transform&lt;/code&gt; 을 통해 함수 호출에서 매개 변수로 입력 된 &lt;strong&gt;리터럴 &lt;/strong&gt; &lt;code&gt;fun()&lt;/code&gt; 을 ERTS 사용자 안내서 의 &lt;code&gt;match_spec&lt;/code&gt; 매뉴얼에 설명 된대로 일치 스펙으로 변환하는 의사 함수 . (리터럴을 사용하면 &lt;code&gt;fun()&lt;/code&gt; 이 텍스트로 함수의 매개 변수로 텍스트로 작성되어야하며 함수에 전달되는 변수에 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad66a675910e9dc1b80a46c98524572b8db0801a" translate="yes" xml:space="preserve">
          <source>Pseudo random number generation.</source>
          <target state="translated">의사 난수 생성.</target>
        </trans-unit>
        <trans-unit id="3d62ca4c64f68f59f57794d1a577fae252d0de3d" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generation.</source>
          <target state="translated">의사 난수 생성.</target>
        </trans-unit>
        <trans-unit id="c98572a8cdc44f29acd6d9bafcc787680c0311e9" translate="yes" xml:space="preserve">
          <source>Public-key data (keys, certificates, and so on) can be stored in Privacy Enhanced Mail (PEM) format. The PEM files have the following structure:</source>
          <target state="translated">공개 키 데이터 (키, 인증서 등)는 PEM (Privacy Enhanced Mail) 형식으로 저장할 수 있습니다. PEM 파일의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af9d874c62240cf5f3756c1a09f53a1acbbe30fb" translate="yes" xml:space="preserve">
          <source>Public-key decryption using the private key. See also &lt;code&gt;crypto:private_decrypt/4&lt;/code&gt;</source>
          <target state="translated">개인 키를 사용한 공개 키 암호 해독 &lt;code&gt;crypto:private_decrypt/4&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="0d0b4eff2289312e196864ad9ede672c54ac16fd" translate="yes" xml:space="preserve">
          <source>Public-key decryption using the public key. See also &lt;code&gt;crypto:public_decrypt/4&lt;/code&gt;</source>
          <target state="translated">공개 키를 사용한 공개 키 암호 해독 &lt;code&gt;crypto:public_decrypt/4&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="1c9a6fa031fc4d41c5bb997e94e3205b5bde379c" translate="yes" xml:space="preserve">
          <source>Public-key encryption using the private key. See also &lt;code&gt;crypto:private_encrypt/4&lt;/code&gt;.</source>
          <target state="translated">개인 키를 사용하는 공개 키 암호화 &lt;code&gt;crypto:private_encrypt/4&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b474ab2cacf9c0bf60c2569f1a89c4cf597b125c" translate="yes" xml:space="preserve">
          <source>Public-key encryption using the public key. See also &lt;code&gt;crypto:public_encrypt/4&lt;/code&gt;.</source>
          <target state="translated">공개 키를 사용한 공개 키 암호화 &lt;code&gt;crypto:public_encrypt/4&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68fc7bd4bc44e3818645b5f17ee1089ffb95b680" translate="yes" xml:space="preserve">
          <source>Punctuation</source>
          <target state="translated">Punctuation</target>
        </trans-unit>
        <trans-unit id="9a2f2d19b27f34b47025e9233d9cd866b4bd3b4e" translate="yes" xml:space="preserve">
          <source>Punctuation character</source>
          <target state="translated">문장 부호 문자</target>
        </trans-unit>
        <trans-unit id="82792519d207c87b83fb05059a79c1df3520b2eb" translate="yes" xml:space="preserve">
          <source>Punctuation characters</source>
          <target state="translated">문장 부호 문자</target>
        </trans-unit>
        <trans-unit id="0438651b1551394f1e2bbfd8ad53fbbf577875d4" translate="yes" xml:space="preserve">
          <source>Punctuation space</source>
          <target state="translated">문장 부호 공간</target>
        </trans-unit>
        <trans-unit id="f4845e6e07d3e7c50eaf916600cc5ee92c07d965" translate="yes" xml:space="preserve">
          <source>Purges and loads, or reloads, a module by calling &lt;code&gt;code:purge(Module)&lt;/code&gt; followed by &lt;code&gt;code:load_file(Module)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;code:purge(Module)&lt;/code&gt; 다음에 &lt;code&gt;code:load_file(Module)&lt;/code&gt; 을 호출하여 모듈을 제거 및로드하거나 다시로드 합니다.</target>
        </trans-unit>
        <trans-unit id="2a530eeffee5c0860d74ab29d23d89f4632d5774" translate="yes" xml:space="preserve">
          <source>Purges each module &lt;code&gt;Mod&lt;/code&gt;, that is, removes the old code. Notice that any process executing purged code is killed.</source>
          <target state="translated">각 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 제거합니다. 즉, 이전 코드를 제거합니다. 제거 된 코드를 실행하는 모든 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdb75c711668c4160644fd3a6e8e5aebaaf8245" translate="yes" xml:space="preserve">
          <source>Purges the code for &lt;code&gt;Module&lt;/code&gt;, that is, removes code marked as old, but only if no processes linger in it.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 코드를 제거합니다 . 즉, 이전으로 표시된 코드를 제거하지만 프로세스가 남아 있지 않은 경우에만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3d8198c900f27b7b2a03e448756c517424e92bed" translate="yes" xml:space="preserve">
          <source>Purges the code for &lt;code&gt;Module&lt;/code&gt;, that is, removes code marked as old. If some processes still linger in the old code, these processes are killed before the code is removed.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 코드를 제거합니다 . 즉, 이전으로 표시된 코드를 제거합니다. 일부 프로세스가 여전히 이전 코드에 남아 있으면 코드를 제거하기 전에 이러한 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdaf8c1d6cdda09ba5cdf41daf294b6c9ed7786" translate="yes" xml:space="preserve">
          <source>Purists may argue that this should be modelled with a separate state machine that sends pre-processed events to the main state machine, but to decrease overhead the small pre-processing state machine can be implemented in the common state event handling of the main state machine using a few state data variables that then sends the pre-processed events as internal events to the main state machine. Using internal events also can make it easier to synchronize the state machines.</source>
          <target state="translated">순수 주의자들은 이것이 전처리 된 이벤트를 주 상태 머신으로 보내는 별도의 상태 머신으로 모델링되어야한다고 주장 할 수 있지만, 오버 헤드를 줄이기 위해 소형 전처리 상태 머신은 메인 상태 머신의 공통 상태 이벤트 처리에서 구현 될 수 있습니다 몇 가지 상태 데이터 변수를 사용하여 사전 처리 된 이벤트를 내부 이벤트로 기본 상태 머신에 보냅니다. 내부 이벤트를 사용하면 상태 시스템을보다 쉽게 ​​동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c01ec6868afc102597a3ed42373e9470221d26" translate="yes" xml:space="preserve">
          <source>Pushing back characters gives you unexpected possibilities to cause the scanner to loop!</source>
          <target state="translated">문자를 뒤로 밀면 스캐너가 루프 될 수있는 예상치 못한 가능성이 있습니다!</target>
        </trans-unit>
        <trans-unit id="4fe937319833d21c895af7373098e512f06998b1" translate="yes" xml:space="preserve">
          <source>Put the marker on a function name and double click to go to the definition of the function. If the function is defined in another module, that module will be loaded and added to the page list.</source>
          <target state="translated">함수 이름에 마커를 놓고 두 번 클릭하여 함수 정의로 이동하십시오. 함수가 다른 모듈에 정의되어 있으면 해당 모듈이로드되어 페이지 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5c334594f2e0d971a5e8ed41a49b4ac58e9cff76" translate="yes" xml:space="preserve">
          <source>Put their names in the association file.</source>
          <target state="translated">이름을 연관 파일에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="267984807457cef8b61168f668ee488edeae227f" translate="yes" xml:space="preserve">
          <source>Puts data at the head of the driver queue. The data in &lt;code&gt;buf&lt;/code&gt; is copied (&lt;code&gt;len&lt;/code&gt; bytes) and placed at the beginning of the queue.</source>
          <target state="translated">드라이버 큐의 헤드에 데이터를 넣습니다. &lt;code&gt;buf&lt;/code&gt; 의 데이터 가 복사되고 ( &lt;code&gt;len&lt;/code&gt; 바이트) 큐의 시작 부분에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="9e27e158ac5c5a01e234c267f7eda9d6f033aceb" translate="yes" xml:space="preserve">
          <source>Puts data in the binary &lt;code&gt;bin&lt;/code&gt;, at &lt;code&gt;offset&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; at the head of the driver queue. It is most often faster than &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">이진 데이터에두고 &lt;code&gt;bin&lt;/code&gt; 에서 &lt;code&gt;offset&lt;/code&gt; 길이 &lt;code&gt;len&lt;/code&gt; 드라이버 큐의 헤드. 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="35a65ec39446238a0a0eac9475e71d6cef8cf751" translate="yes" xml:space="preserve">
          <source>Puts the Erlang term &lt;code&gt;TraceInfo&lt;/code&gt; into the sequential trace output if the calling process currently is executing within a sequential trace and the &lt;code&gt;print&lt;/code&gt; flag of the trace token is set.</source>
          <target state="translated">호출 프로세스가 현재 순차 추적 내에서 실행 중이고 추적 토큰 의 &lt;code&gt;print&lt;/code&gt; 플래그가 설정된 경우 Erlang 용어 &lt;code&gt;TraceInfo&lt;/code&gt; 를 순차 추적 출력에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="042a67e13942247a8e41ae9098af6d0aa9580018" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible. This is useful if the process does not expect to receive any messages soon.</source>
          <target state="translated">호출 프로세스를 메모리 할당이 가능한 한 감소 된 대기 상태로 만듭니다. 프로세스가 메시지를 곧받을 것으로 예상되지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d013f0295b6c01c558d00c5ba53aca86377c9dd9" translate="yes" xml:space="preserve">
          <source>Puts the data in &lt;code&gt;ev&lt;/code&gt;, skipping the first &lt;code&gt;skip&lt;/code&gt; bytes of it, at the head of the driver queue. It is faster than &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">드라이버 큐의 헤드에서 데이터 의 첫 번째 &lt;code&gt;skip&lt;/code&gt; 바이트를 건너 뛰고 &lt;code&gt;ev&lt;/code&gt; 에 데이터 를 넣습니다. 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="0e3da342d32b71066e0ff7598d5155af43136f49" translate="yes" xml:space="preserve">
          <source>Pythagorean triplets are sets of integers &lt;code&gt;{A,B,C}&lt;/code&gt; such that &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt;.</source>
          <target state="translated">피타고라스 수는 정수의 집합 인 &lt;code&gt;{A,B,C}&lt;/code&gt; 되도록 &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdad7e832388f477b308e785e461d43f185fd4b" translate="yes" xml:space="preserve">
          <source>Q: Can I build something that looks exactly as the commercial release?</source>
          <target state="translated">Q : 상용 릴리스와 똑같이 보이는 것을 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9c33e934c4ed63e98eb95622daa029fee8f2aee2" translate="yes" xml:space="preserve">
          <source>Q: Can you help me setup X in Cygwin/MSYS/MSYS2?</source>
          <target state="translated">Q : Cygwin / MSYS / MSYS2에서 X 설정을 도와 줄 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2a92f9f3084b89244941d6f295251370a4ed363a" translate="yes" xml:space="preserve">
          <source>Q: Can/will I build a Cygwin binary with the procedure you describe?</source>
          <target state="translated">Q : 설명하는 절차에 따라 Cygwin 바이너리를 구축 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8fdbaf479bc8188c169196a96796d9e462c3fb1f" translate="yes" xml:space="preserve">
          <source>Q: Hah, I saw you, you used GCC even though you said you didn't!</source>
          <target state="translated">Q : Hah, 나는 당신을 보았습니다, 당신은 당신이하지 않았다고 말했지만 GCC를 사용했습니다!</target>
        </trans-unit>
        <trans-unit id="4d33d2562fd29f6e1c9fc76d264215b3d5aeeca3" translate="yes" xml:space="preserve">
          <source>Q: OK, you need VC++, but now you've started to demand a quite recent (and expensive) version of Visual Studio. Why?</source>
          <target state="translated">Q : 좋습니다. VC ++가 필요하지만 이제는 최신 (그리고 비싼) 버전의 Visual Studio를 요구하기 시작했습니다. 왜?</target>
        </trans-unit>
        <trans-unit id="5fa7db24f83822063f97229323a06aa3a0877f5d" translate="yes" xml:space="preserve">
          <source>Q: So how does it all work then?</source>
          <target state="translated">Q : 그렇다면 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="4848dd0945c44e751b1591373d20f6801c1998a4" translate="yes" xml:space="preserve">
          <source>Q: So now there's a MS VC++ project file somewhere and I can build OTP using the nifty VC++ GUI?</source>
          <target state="translated">Q : 이제 어딘가에 MS VC ++ 프로젝트 파일이 있는데 멋진 VC ++ GUI를 사용하여 OTP를 빌드 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="7beb25dc53e0563d452b76025a13d007739f049b" translate="yes" xml:space="preserve">
          <source>Q: So, now I can build Erlang using GCC on Windows?</source>
          <target state="translated">Q : 이제 Windows에서 GCC를 사용하여 Erlang을 빌드 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1f93ee200a556071dcfd3098474bd38969c35084" translate="yes" xml:space="preserve">
          <source>Q: Which version of Cygwin/MSYS/MSYS2 and other tools do you use then?</source>
          <target state="translated">Q : 어떤 버전의 Cygwin / MSYS / MSYS2 및 기타 도구를 사용하십니까?</target>
        </trans-unit>
        <trans-unit id="3824ecc6208efe4bfe24a674a751c9d0ca079f07" translate="yes" xml:space="preserve">
          <source>Q: Why haven't you got rid of VC++ then, you ******?</source>
          <target state="translated">Q : 왜 VC ++를 없애지 않았습니까, ******?</target>
        </trans-unit>
        <trans-unit id="cb20cfbdc096ea44ab338185d58c6e58b37996ba" translate="yes" xml:space="preserve">
          <source>Q: You use and need Cygwin, but then you haven't taken the time to port Erlang to the Cygwin environment but instead focus on your commercial release, is that really ethical?</source>
          <target state="translated">Q : Cygwin을 사용하고 필요하지만 Erlang을 Cygwin 환경으로 포팅하는 데 시간이 걸리지 않고 대신 상용 릴리스에 집중하는 것이 정말 윤리적인가?</target>
        </trans-unit>
        <trans-unit id="ab248038951d6f5bbf2e6b69cbcd23902b8c49b9" translate="yes" xml:space="preserve">
          <source>QLC</source>
          <target state="translated">QLC</target>
        </trans-unit>
        <trans-unit id="44b991a394914f0303f96d96a457d83497af8f65" translate="yes" xml:space="preserve">
          <source>QLC can be used as a database programming language for Mnesia. It includes a notation called &quot;list comprehensions&quot; and can be used to make complex database queries over a set of tables.</source>
          <target state="translated">QLC는 Mnesia의 데이터베이스 프로그래밍 언어로 사용될 수 있습니다. 여기에는 &quot;목록 이해&quot;라는 표기법이 포함되며 일련의 테이블에 대해 복잡한 데이터베이스 쿼리를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b344639b609596306bc487c87eb37bfda190216" translate="yes" xml:space="preserve">
          <source>QLC can optimize the query compiler for the Mnesia DBMS, essentially making the DBMS more efficient.</source>
          <target state="translated">QLC는 Mnesia DBMS에 대한 쿼리 컴파일러를 최적화하여 기본적으로 DBMS를보다 효율적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5d2d92876611f40bde581d69101f8fddd8c14363" translate="yes" xml:space="preserve">
          <source>QLC queries can also be used to search &lt;code&gt;Mnesia&lt;/code&gt; tables. By using the function &lt;code&gt;&lt;a href=&quot;mnesia#table-1&quot;&gt;mnesia:table/[1|2]&lt;/a&gt;&lt;/code&gt; as the generator inside a QLC query, you let the query operate on a &lt;code&gt;Mnesia&lt;/code&gt; table. &lt;code&gt;Mnesia&lt;/code&gt;-specific options to &lt;code&gt;mnesia:table/2&lt;/code&gt; are &lt;code&gt;{lock, Lock}&lt;/code&gt;, &lt;code&gt;{n_objects,Integer}&lt;/code&gt;, and &lt;code&gt;{traverse, SelMethod}&lt;/code&gt;:</source>
          <target state="translated">QLC 쿼리를 사용하여 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 검색 할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;mnesia#table-1&quot;&gt;mnesia:table/[1|2]&lt;/a&gt;&lt;/code&gt; 함수를 QLC 쿼리 내부의 생성기로 사용하면 쿼리가 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에서 작동하게 할 수 있습니다 . &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;mnesia:table/2&lt;/code&gt; 대한 Mnesia 관련 옵션 은 &lt;code&gt;{lock, Lock}&lt;/code&gt; , &lt;code&gt;{n_objects,Integer}&lt;/code&gt; 및 &lt;code&gt;{traverse, SelMethod}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2442c21b812ded9c8602b0eb848411eef6d3f41" translate="yes" xml:space="preserve">
          <source>QLC queries can be performed in all these activity contexts (&lt;code&gt;transaction&lt;/code&gt;, &lt;code&gt;sync_transaction&lt;/code&gt;, &lt;code&gt;async_dirty&lt;/code&gt;, &lt;code&gt;sync_dirty&lt;/code&gt;, and &lt;code&gt;ets&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; activity only works if the table has no indexes.</source>
          <target state="translated">QLC 쿼리는 이러한 모든 활동 컨텍스트 ( &lt;code&gt;transaction&lt;/code&gt; , &lt;code&gt;sync_transaction&lt;/code&gt; , &lt;code&gt;async_dirty&lt;/code&gt; , &lt;code&gt;sync_dirty&lt;/code&gt; 및 &lt;code&gt;ets&lt;/code&gt; ) 에서 수행 될 수 있습니다 . &lt;code&gt;ets&lt;/code&gt; 테이블에는 인덱스가없는 경우 활동에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6fdde551c1ae8e6fe45e078d55ddb3f31ce7e09a" translate="yes" xml:space="preserve">
          <source>QLCs are convenient for stating constraints on data from two or more tables. The following example does a natural join on two query handles on position 2:</source>
          <target state="translated">QLC는 둘 이상의 테이블의 데이터에 대한 제한 조건을 설명하는 데 편리합니다. 다음 예제는 위치 2의 두 쿼리 핸들에서 자연 결합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="28177dc15b26c0a74159857924b18e3df0638648" translate="yes" xml:space="preserve">
          <source>Queries can be sent to the master to determine which node will have the least load.</source>
          <target state="translated">쿼리를 마스터로 보내서로드가 가장 적은 노드를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594265df0f504d11dc7e03fde007c6624ca2cfba" translate="yes" xml:space="preserve">
          <source>Queries the database to find out the ODBC data types of the columns of the table &lt;code&gt;Table&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 테이블을 조회하여 &lt;code&gt;Table&lt;/code&gt; 테이블 열의 ODBC 데이터 유형을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2412c764d41ab6b9791a2250b7102a18362506f7" translate="yes" xml:space="preserve">
          <source>Query ::= Statement&lt;code&gt;,&lt;/code&gt; ...</source>
          <target state="translated">쿼리 :: = 문 &lt;code&gt;,&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="c162938e377e38115dc3cedfcf24cb92df1d737c" translate="yes" xml:space="preserve">
          <source>Query List Comprehension (QLC) can be used with Mnesia to produce specialized functions that enhance the operational ability of Mnesia. QLC has its own documentation as part of the OTP documentation set. The main features of QLC when used with Mnesia are as follows:</source>
          <target state="translated">QLC (Query List Comprehension)는 Mnesia와 함께 사용하여 Mnesia의 작동 능력을 향상시키는 특수 기능을 생성 할 수 있습니다. QLC에는 OTP 문서 세트의 일부로 자체 문서가 있습니다. Mnesia와 함께 사용되는 QLC의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d6e12fb5478de8f3fa8e6c09b0ca1974dd2631e" translate="yes" xml:space="preserve">
          <source>Query interface</source>
          <target state="translated">쿼리 인터페이스</target>
        </trans-unit>
        <trans-unit id="c1792a32d0b77c434cdc1e30d03076a0c0097b22" translate="yes" xml:space="preserve">
          <source>Query interface to Mnesia, ETS, Dets, and so on.</source>
          <target state="translated">Mnesia, ETS, Dets 등에 대한 쿼리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="966933c9d4fe3603343d28156ae1dd639fce4546" translate="yes" xml:space="preserve">
          <source>Queues are double-ended. The mental picture of a queue is a line of people (items) waiting for their turn. The queue front is the end with the item that has waited the longest. The queue rear is the end an item enters when it starts to wait. If instead using the mental picture of a list, the front is called head and the rear is called tail.</source>
          <target state="translated">대기열이 두 번 끝났습니다. 줄의 정신 그림은 사람들의 차례를 기다리는 사람들 (항목)입니다. 대기열 앞쪽은 가장 오래 기다린 항목의 끝입니다. 대기열 뒷면은 항목이 대기하기 시작할 때 입력되는 끝입니다. 대신 목록의 정신 그림을 사용하는 경우 앞면을 머리라고하고 뒷면을 꼬리라고합니다.</target>
        </trans-unit>
        <trans-unit id="a20596c790f832b98307345d7e29739a19f1b37f" translate="yes" xml:space="preserve">
          <source>Quits Erlang. Notice that this option is disabled if Erlang is started with the ignore break, &lt;code&gt;+Bi&lt;/code&gt;, system flag (which can be useful, for example when running a restricted shell, see the next section).</source>
          <target state="translated">Erlang을 종료합니다. Erlang이 시스템 브레이크 플래그 인 ignore break &lt;code&gt;+Bi&lt;/code&gt; 로 시작되면이 옵션이 비활성화됩니다 (예 : 제한된 쉘을 실행할 때 유용 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9e0e35667c233db47de30256c67c29187c2127da" translate="yes" xml:space="preserve">
          <source>RAM memory of 96 MB is recommended to run OTP on Windows NT. A system with less than 64 MB of RAM is not recommended.</source>
          <target state="translated">Windows NT에서 OTP를 실행하려면 96MB의 RAM 메모리가 권장됩니다. RAM이 64MB 미만인 시스템은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="e243ff0db6962f2860f9daeb7b76706585f6a228" translate="yes" xml:space="preserve">
          <source>RFC 1350, The TFTP Protocol (revision 2)</source>
          <target state="translated">RFC 1350, TFTP 프로토콜 (개정 2)</target>
        </trans-unit>
        <trans-unit id="1dce0d83a131f276794188635a3dd2c84e8c7eb2" translate="yes" xml:space="preserve">
          <source>RFC 2347, TFTP Option Extension</source>
          <target state="translated">RFC 2347, TFTP 옵션 확장</target>
        </trans-unit>
        <trans-unit id="bbc82bb105613050636fa25569250ca1eee846e0" translate="yes" xml:space="preserve">
          <source>RFC 2348, TFTP Blocksize Option</source>
          <target state="translated">RFC 2348, TFTP 블록 크기 옵션</target>
        </trans-unit>
        <trans-unit id="58b78666477f6c30faf4308df7d8a596afe3e335" translate="yes" xml:space="preserve">
          <source>RFC 2349, TFTP Timeout Interval and Transfer Size Options</source>
          <target state="translated">RFC 2349, TFTP 시간 초과 간격 및 전송 크기 옵션</target>
        </trans-unit>
        <trans-unit id="59a4f7837e70ac5999135a8d3596c58b849ab6fc" translate="yes" xml:space="preserve">
          <source>RFC 2830</source>
          <target state="translated">RFC 2830</target>
        </trans-unit>
        <trans-unit id="4b90d6cab31b63063971c3605ede011c0f69a6ae" translate="yes" xml:space="preserve">
          <source>RFC 4510 - RFC 4519</source>
          <target state="translated">RFC 4510-RFC 4519</target>
        </trans-unit>
        <trans-unit id="d99facf0134d096b722a33331e4fe8b6452b7572" translate="yes" xml:space="preserve">
          <source>RFC 4716 SSH files looks confusingly like PEM files, but there are some differences:</source>
          <target state="translated">RFC 4716 SSH 파일은 PEM 파일과 혼동 될 수 있지만 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1da6885bf9a20f8d0085f4bb97f71554cbe07e08" translate="yes" xml:space="preserve">
          <source>RFC 6733 is unclear about the semantics of the M-bit. One the one hand, the CCF specification in section 3.2 documents AVP in a command grammar as meaning &lt;strong&gt;any&lt;/strong&gt; arbitrary AVP; on the other hand, 1.3.4 states that AVPs setting the M-bit cannot be added to an existing command: the modified command must instead be placed in a new Diameter application.</source>
          <target state="translated">RFC 6733은 M- 비트의 의미에 대해 명확하지 않습니다. 하나 한편, 3.2 문서를 의미하는 것으로 명령 문법 AVP 섹션의 CCF 사양 &lt;strong&gt;어떤&lt;/strong&gt; 임의 AVP 단계; 반면, 1.3.4에서는 M- 비트를 설정하는 AVP를 기존 명령에 추가 할 수 없다고 설명합니다. 대신 수정 된 명령을 새 직경 응용 프로그램에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a00bbd3345e1dc4481f48b2eb823bd6a52b39bc" translate="yes" xml:space="preserve">
          <source>RFC1155, 1157, 1212 and 1215 (SNMPv1)</source>
          <target state="translated">RFC1155, 1157, 1212 및 1215 (SNMPv1)</target>
        </trans-unit>
        <trans-unit id="776412993c8f2099a41ff3173b993a46e8d2ffc2" translate="yes" xml:space="preserve">
          <source>RFC1157, RFC1905 and/or RFC2272 should be studied carefully before using this module, &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">이 모듈 &lt;code&gt;snmp_pdus&lt;/code&gt; 를 사용하기 전에 RFC1157, RFC1905 및 / 또는 RFC2272를주의해서 연구해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1168b5a47f86b0c1ab1cefa353e2e20f382b649a" translate="yes" xml:space="preserve">
          <source>RFC1901-1907 (SNMPv2c)</source>
          <target state="translated">RFC1901-1907 (SNMPv2c)</target>
        </trans-unit>
        <trans-unit id="8f47f36a71eeb2e19619fed1c9a260fe790b894f" translate="yes" xml:space="preserve">
          <source>RFC1908, 2089 (coexistence between SNMPv1 and SNMPv2)</source>
          <target state="translated">RFC1908, 2089 (SNMPv1과 SNMPv2의 공존)</target>
        </trans-unit>
        <trans-unit id="b65e8c8967997cf54ae07d33911cd338bcfd5fea" translate="yes" xml:space="preserve">
          <source>RFC2271, RFC2273 (SNMP std MIBs)</source>
          <target state="translated">RFC2271, RFC2273 (SNMP 표준 MIB)</target>
        </trans-unit>
        <trans-unit id="f8914ca9f86bbe9f10be1026bac810afc6078c5e" translate="yes" xml:space="preserve">
          <source>RSA key generation is only available if the runtime was built with dirty scheduler support. Otherwise, attempting to generate an RSA key will throw exception &lt;code&gt;error:notsup&lt;/code&gt;.</source>
          <target state="translated">RSA 키 생성은 런타임이 더티 스케줄러 지원으로 빌드 된 경우에만 사용 가능합니다. 그렇지 않으면 RSA 키를 생성하려고 시도하면 예외 &lt;code&gt;error:notsup&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="05d92fe0db12744e04d5c42042cf1cefb4d02e52" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;undef&lt;/code&gt; exception with a stacktrace, indicating that &lt;code&gt;Module:Function/N&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;Module:Function/N&lt;/code&gt; 이 정의되지 않았 음을 나타내는 스택 추적으로 &lt;code&gt;undef&lt;/code&gt; 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="459599ff17e3d64ffa950ad44a266ffa3f086014" translate="yes" xml:space="preserve">
          <source>Range = 1..2^32, Hash = 1..Range</source>
          <target state="translated">범위 = 1..2 ^ 32, 해시 = 1 .. 범위</target>
        </trans-unit>
        <trans-unit id="a7f829a993da34443f81cc1e6ec49f9944aa415e" translate="yes" xml:space="preserve">
          <source>Ranges of taken salt (if any) and returned value depend on the hash type.</source>
          <target state="translated">소금의 범위 (있는 경우)와 반환 값의 범위는 해시 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4739ff05fa329071f045d72b76e29a97728b5a87" translate="yes" xml:space="preserve">
          <source>Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example, [\000-\037]. Ranges can include any characters that are valid for the current mode.</source>
          <target state="translated">범위는 문자 값의 조합 순서로 작동합니다. 숫자로 지정된 문자 (예 : [\ 000- \ 037])에도 사용할 수 있습니다. 범위에는 현재 모드에 유효한 모든 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b944ab1d190ffab8bdf5f92747b67f829f474fa" translate="yes" xml:space="preserve">
          <source>Rarely used. Determines the ACK time (specified by &lt;code&gt;assoc_value&lt;/code&gt;, in milliseconds) for the specified association or the whole endpoint if &lt;code&gt;assoc_value = 0&lt;/code&gt; (default).</source>
          <target state="translated">드물게 사용되는. &lt;code&gt;assoc_value = 0&lt;/code&gt; (기본값) 인 경우 지정된 연관 또는 전체 엔드 포인트에 대한 ACK 시간 ( &lt;code&gt;assoc_value&lt;/code&gt; 로 지정됨 ( 밀리 초)을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="acb7267dc157944fbc4f68b9244986a8dd01d029" translate="yes" xml:space="preserve">
          <source>Rather than reading the &lt;code&gt;Emakefile&lt;/code&gt; specify configuration explicitly.</source>
          <target state="translated">&lt;code&gt;Emakefile&lt;/code&gt; 을 읽는 대신 구성을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="47883c793c16264c0bf3a9f6e7125312a6498763" translate="yes" xml:space="preserve">
          <source>Raw filenames were introduced together with Unicode filename support in ERTS 5.8.2 (Erlang/OTP R14B01). The reason &quot;raw filenames&quot; were introduced in the system was to be able to represent filenames, specified in different encodings on the same system, consistently. It can seem practical to have the VM automatically translate a filename that is not in UTF-8 to a list of Unicode characters, but this would open up for both duplicate filenames and other inconsistent behavior.</source>
          <target state="translated">원시 파일 이름은 ERTS 5.8.2 (Erlang / OTP R14B01)에서 유니 코드 파일 이름 지원과 함께 도입되었습니다. &quot;원시 파일 이름&quot;이 시스템에 도입 된 이유는 동일한 시스템에서 다른 인코딩으로 지정된 파일 이름을 일관되게 나타낼 수 있기 때문입니다. VM에서 UTF-8이 아닌 파일 이름을 유니 코드 문자 목록으로 자동 변환하는 것이 실용적으로 보일 수 있지만 중복 된 파일 이름과 다른 일관되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795061f45c0310d22fcc247f07c3b4e23fa83463" translate="yes" xml:space="preserve">
          <source>Raw files use the file system of the host machine of the node. For normal files (non-raw), the file server is used to find the files, and if the node is running its file server as slave to the file server of another node, and the other node runs on some other host machine, they can have different file systems. However, this is seldom a problem.</source>
          <target state="translated">원시 파일은 노드 호스트 시스템의 파일 시스템을 사용합니다. 일반 파일 (비원시)의 경우 파일 서버는 파일을 찾는 데 사용되며 노드가 다른 노드의 파일 서버에 대한 슬레이브로 파일 서버를 실행하고 다른 노드는 다른 호스트 시스템에서 실행되는 경우 다른 파일 시스템을 가질 수 있습니다. 그러나 이것은 거의 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c84575df9844c415b455e79411320007894aa74" translate="yes" xml:space="preserve">
          <source>Raw socket options, such as &lt;code&gt;packet&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; must not be specified on the command line.</source>
          <target state="translated">&lt;code&gt;packet&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 와 같은 원시 소켓 옵션 은 명령 행에 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1a1608e0a1ead364bb6ddf1ef14e4576861c85e2" translate="yes" xml:space="preserve">
          <source>Re-Auth-Answer</source>
          <target state="translated">Re-Auth-Answer</target>
        </trans-unit>
        <trans-unit id="cea1207d9889c12a36609f11fca3aa3647d57966" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request</source>
          <target state="translated">Re-Auth-Request</target>
        </trans-unit>
        <trans-unit id="16429bb7f0689c5c487b46f0ec26c0177f1ef94a" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request-Type AVP</source>
          <target state="translated">재 인증 요청 유형 AVP</target>
        </trans-unit>
        <trans-unit id="7bc3f1950022396c1453ed6991b28afe5cc3b167" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request-Type AVP Values</source>
          <target state="translated">재 인증 요청 유형 AVP 값</target>
        </trans-unit>
        <trans-unit id="77e1d4c89a77db083b40468156c72a44aaeb8a27" translate="yes" xml:space="preserve">
          <source>Re-defining the match operation</source>
          <target state="translated">일치 작업 재정의</target>
        </trans-unit>
        <trans-unit id="19c1fde66df90cd89fae9d3e8cfddd3b6967eaae" translate="yes" xml:space="preserve">
          <source>Re-send a megaco message.</source>
          <target state="translated">megaco 메시지를 다시 보내십시오.</target>
        </trans-unit>
        <trans-unit id="8f461656f4f97af8310e6bbba806a6dfac4836a2" translate="yes" xml:space="preserve">
          <source>Re-send of messages, handling pending transactions, acknowledgements etc. is handled automatically by the Megaco application but the user is free to override the default behaviour by the various configuration possibilities. See megaco:update_user_info/2 and megaco:update_conn_info/2 about the possibilities.</source>
          <target state="translated">메시지 재전송, 보류중인 트랜잭션 처리, 승인 등은 Megaco 응용 프로그램에서 자동으로 처리하지만 사용자는 다양한 구성 가능성에 따라 기본 동작을 자유롭게 무시할 수 있습니다. 가능성에 대해서는 megaco : update_user_info / 2 및 megaco : update_conn_info / 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc298594d701205369ec5adc40340226d9806b5c" translate="yes" xml:space="preserve">
          <source>Read a compiled mib.</source>
          <target state="translated">컴파일 된 mib를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="2d219c0f4eafc3f8960679e044824d76e3076ea1" translate="yes" xml:space="preserve">
          <source>Read a file dump produced by &lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt;to_file(Filename)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt;to_file(Filename)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 파일 덤프를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="094a01892ae368406b5fc03359c07f6767d0465e" translate="yes" xml:space="preserve">
          <source>Read a record from the mib-storage table.</source>
          <target state="translated">mib-storage 테이블에서 레코드를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fae42d0f132843e9c05600efe03222c799da3c90" translate="yes" xml:space="preserve">
          <source>Read back a stored value:</source>
          <target state="translated">저장된 값을 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8d5d990ecf5aa325dd10c8954d8f4a8821e157b8" translate="yes" xml:space="preserve">
          <source>Read locks an rwlock. The calling thread is blocked until the rwlock has been read locked. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; lock the same rwlock again.</source>
          <target state="translated">읽기는 rwlock을 잠급니다. rwlock이 읽혀질 때까지 호출 스레드가 차단됩니다. 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠글 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="76ccfbe9ca99e346c048962da6d197423a7cbd46" translate="yes" xml:space="preserve">
          <source>Read locks can be shared. This means that if one transaction manages to acquire a read lock on an item, other transactions can also acquire a read lock on the same item. However, if someone has a read lock, no one can acquire a write lock at the same item. If someone has a write lock, no one can acquire either a read lock or a write lock at the same item.</source>
          <target state="translated">읽기 잠금을 공유 할 수 있습니다. 즉, 한 트랜잭션이 항목에 대한 읽기 잠금을 획득하면 다른 트랜잭션도 동일한 항목에 대한 읽기 잠금을 획득 할 수 있습니다. 그러나 누군가에게 읽기 잠금이 있으면 아무도 같은 항목에서 쓰기 잠금을 얻을 수 없습니다. 누군가 쓰기 잠금이있는 경우 아무도 같은 항목에서 읽기 잠금 또는 쓰기 잠금을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab3b8c2401387cd20afc043cfe4cdb6d7fad5178" translate="yes" xml:space="preserve">
          <source>Read more about behaviours and callback modules in &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OTP Design Principles&lt;/code&gt; 에서 동작 및 콜백 모듈에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="07143977457b982ffd87794e7909594ac2808846" translate="yes" xml:space="preserve">
          <source>Read more about funs in &lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt;Fun Expressions&lt;/a&gt;&lt;/code&gt;. For more examples, see &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt;Fun Expressions&lt;/a&gt;&lt;/code&gt; 의 재미 에 대해 자세히 알아보십시오 . 자세한 예는 &lt;code&gt;Programming Examples&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1be27ef0d2a3f64890f259db44beefa37af2c5b" translate="yes" xml:space="preserve">
          <source>Read more about maps in &lt;code&gt;&lt;a href=&quot;expressions#map_expressions&quot;&gt;Map Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expressions#map_expressions&quot;&gt;Map Expressions&lt;/a&gt;&lt;/code&gt; 에서 지도 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="9a94884a1eeb79bbde0f80da164882bdecb46069" translate="yes" xml:space="preserve">
          <source>Read more about ports in &lt;code&gt;&lt;a href=&quot;ports&quot;&gt;Ports and Port Drivers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ports&quot;&gt;Ports and Port Drivers&lt;/a&gt;&lt;/code&gt; 포트에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="554282f3efb20a0099d5f18b19f7a754b826fd3a" translate="yes" xml:space="preserve">
          <source>Read more about processes in &lt;code&gt;&lt;a href=&quot;processes&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 과정에 대해 더 자세히 &lt;code&gt;&lt;a href=&quot;processes&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bf0c0fc48b6429df321b465a4fd9dd18e68f80" translate="yes" xml:space="preserve">
          <source>Read more about records in &lt;code&gt;&lt;a href=&quot;records&quot;&gt;Records&lt;/a&gt;&lt;/code&gt;. More examples can be found in &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">레코드에 대해 더 자세히 &lt;code&gt;&lt;a href=&quot;records&quot;&gt;Records&lt;/a&gt;&lt;/code&gt; . 더 많은 예제는 &lt;code&gt;Programming Examples&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88c12fc1054e6dee5889bd067bef3dd784174d05" translate="yes" xml:space="preserve">
          <source>Read more about the &lt;code&gt;&lt;a href=&quot;../system_principles/versions&quot;&gt;version handling&lt;/a&gt;&lt;/code&gt; introduced in Erlang/OTP release 17, which also describes how to determine if an installation includes one or more patched applications.</source>
          <target state="translated">설치에 하나 이상의 패치 응용 프로그램이 포함되어 있는지 판별하는 방법을 설명하는 Erlang / OTP 릴리스 17에 도입 된 &lt;code&gt;&lt;a href=&quot;../system_principles/versions&quot;&gt;version handling&lt;/a&gt;&lt;/code&gt; 에 대해 자세히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f5acd88bebed6795b6d43dc94e4d954048ae135b" translate="yes" xml:space="preserve">
          <source>Read more in &lt;code&gt;&lt;a href=&quot;macros&quot;&gt;Preprocessor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전 &lt;code&gt;&lt;a href=&quot;macros&quot;&gt;Preprocessor&lt;/a&gt;&lt;/code&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="25902641bc735ddad3dc3752e9e7cdf871e33269" translate="yes" xml:space="preserve">
          <source>Read more in &lt;code&gt;&lt;a href=&quot;typespec&quot;&gt;Types and Function specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;typespec&quot;&gt;Types and Function specifications&lt;/a&gt;&lt;/code&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="f648b4cd550b1fadddeedd092b40e39b527f7289" translate="yes" xml:space="preserve">
          <source>Read operations must be fast and performed in RAM.</source>
          <target state="translated">RAM에서 빠르게 읽기 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcc1f12b3d10e63c14a1f8d7961be76cc365a4c2" translate="yes" xml:space="preserve">
          <source>Read operations on the file return binaries rather than lists.</source>
          <target state="translated">리스트가 아닌 파일 리턴 바이너리에 대한 읽기 조작.</target>
        </trans-unit>
        <trans-unit id="a2e1d0549799772810864d99ca395221ead7f179" translate="yes" xml:space="preserve">
          <source>Read permission: group</source>
          <target state="translated">읽기 권한 : 그룹</target>
        </trans-unit>
        <trans-unit id="907dbe453adbd7fa6e280b4f6613faf3d07802de" translate="yes" xml:space="preserve">
          <source>Read permission: other</source>
          <target state="translated">읽기 권한 : 기타</target>
        </trans-unit>
        <trans-unit id="e07884b49a0e21ab3dba84b49e8cf1e33e98b370" translate="yes" xml:space="preserve">
          <source>Read permission: owner</source>
          <target state="translated">읽기 권한 : owner</target>
        </trans-unit>
        <trans-unit id="a9a2a9ac46cb0c7c5000cf0d6d9e745656ad5010" translate="yes" xml:space="preserve">
          <source>Read the &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; from a binary. Returns the read encoding, or &lt;code&gt;none&lt;/code&gt; if no valid encoding is found.</source>
          <target state="translated">바이너리 에서 &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; 을 읽습니다 . 읽기 인코딩을 반환하거나 유효한 인코딩이 없으면 &lt;code&gt;none&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b9bff9acfee5a49ed23833e2b2e81ce0eafcf087" translate="yes" xml:space="preserve">
          <source>Read the &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; from a file. Returns the read encoding, or &lt;code&gt;none&lt;/code&gt; if no valid encoding is found.</source>
          <target state="translated">파일 에서 &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; 을 읽습니다 . 읽기 인코딩을 반환하거나 유효한 인코딩이 없으면 &lt;code&gt;none&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="03addc218b3ecbd8505da6cd353ed8258e946c82" translate="yes" xml:space="preserve">
          <source>Read the current agent community config file.</source>
          <target state="translated">현재 에이전트 커뮤니티 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="02b971b894024a807e610f7f5b2b637f8dd97000" translate="yes" xml:space="preserve">
          <source>Read the current agent config file.</source>
          <target state="translated">현재 에이전트 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="342a88f5b0ef188a6710923ae2c68b182e32efef" translate="yes" xml:space="preserve">
          <source>Read the current agent context config file.</source>
          <target state="translated">현재 에이전트 컨텍스트 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="b6fc36e2d6043726f29d5d8f1c08f9f88ee70c74" translate="yes" xml:space="preserve">
          <source>Read the current agent notify config file.</source>
          <target state="translated">현재 에이전트 알림 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="3eb932c8851f4e2dc54a684ed2c99b02f3242cba" translate="yes" xml:space="preserve">
          <source>Read the current agent standard config file.</source>
          <target state="translated">현재 에이전트 표준 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="35433f92aa6ddf91ab8a32ad2893c1416b06ab17" translate="yes" xml:space="preserve">
          <source>Read the current agent target_addr config file.</source>
          <target state="translated">현재 에이전트 target_addr 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="78a4a501636d7de7588fd4069fcaa0ba16c5b911" translate="yes" xml:space="preserve">
          <source>Read the current agent target_params config file.</source>
          <target state="translated">현재 에이전트 target_params 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="fc9c3b2ea448e1950b438a66a1ac53da2c5c848c" translate="yes" xml:space="preserve">
          <source>Read the current agent usm config file.</source>
          <target state="translated">현재 에이전트 usm 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="a884a170d9e1573ebe82ea228079e20c5eb624ee" translate="yes" xml:space="preserve">
          <source>Read the current agent vacm config file.</source>
          <target state="translated">현재 에이전트 vacm 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="1cccddc3b38e21d434122b66beec2e249ff466f7" translate="yes" xml:space="preserve">
          <source>Read the current manager agents config file.</source>
          <target state="translated">현재 관리자 에이전트 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="5ea1df47d9a8182ee88ccdea1f6d44fd125d1e2e" translate="yes" xml:space="preserve">
          <source>Read the current manager config file.</source>
          <target state="translated">현재 관리자 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="bf1020e0b4f41cf2c22e11431cbaedc662a19f79" translate="yes" xml:space="preserve">
          <source>Read the current manager users config file.</source>
          <target state="translated">현재 관리자 사용자 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="59e482ad7bf583e0ad9e54f15735c13cf785f39c" translate="yes" xml:space="preserve">
          <source>Read the current manager usm config file.</source>
          <target state="translated">현재 manager usm 구성 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="be2ba72b989b324a88b19ff039a27eab2a805aaf" translate="yes" xml:space="preserve">
          <source>Read the whole manual page if it is the first time you are using the transformations.</source>
          <target state="translated">변환을 처음 사용하는 경우 전체 매뉴얼 페이지를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="0a736cf2a92b3cd68f6984820f5b1301a5650942" translate="yes" xml:space="preserve">
          <source>Read unlocks an rwlock. The rwlock currently must be read locked by the calling thread.</source>
          <target state="translated">읽기는 rwlock을 잠금 해제합니다. rwlock은 현재 호출 스레드에 의해 읽혀 져야합니다.</target>
        </trans-unit>
        <trans-unit id="ce3d31d0d015c1d0a226f6e114ecb8215a61f763" translate="yes" xml:space="preserve">
          <source>Read/write lock. Used to allow multiple threads to read shared data while only allowing one thread to write the same data. Multiple threads can read lock an rwlock at the same time, while only one thread can read/write lock an rwlock at a time.</source>
          <target state="translated">읽기 / 쓰기 잠금 하나의 스레드 만 동일한 데이터를 쓰도록 허용하면서 여러 스레드가 공유 데이터를 읽을 수 있도록하는 데 사용됩니다. 여러 스레드가 동시에 rwlock을 읽을 수있는 반면 한 스레드 만 한 번에 rwlock을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a088a96620af47c2bef0d4a01c4765cd4908ac8e" translate="yes" xml:space="preserve">
          <source>Read/write locks an rwlock. The calling thread is blocked until the rwlock has been read/write locked. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; lock the same rwlock again.</source>
          <target state="translated">읽기 / 쓰기는 rwlock을 잠급니다. rwlock이 읽기 / 쓰기로 잠길 때까지 호출 스레드가 차단됩니다. 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠글 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="88f7eef8181951ff1f841f14cc7c3dfc0d58e28f" translate="yes" xml:space="preserve">
          <source>Read/write unlocks an rwlock. The rwlock currently must be read/write locked by the calling thread.</source>
          <target state="translated">읽기 / 쓰기는 rwlock을 잠금 해제합니다. rwlock은 현재 호출 스레드에 의해 읽기 / 쓰기 잠금 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="db3a2609cebf7e16af76fe0013217765a0dfa76f" translate="yes" xml:space="preserve">
          <source>Readability and maintainability suffer when test cases become too large and extensive. It is not certain that the resulting log files reflect very well the number of tests performed.</source>
          <target state="translated">테스트 사례가 너무 커지고 광범위 해지면 가독성과 유지 관리 성이 떨어집니다. 결과 로그 파일이 수행 된 테스트 수를 잘 반영하고 있는지는 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9aec65966a9a00d068d698cfbc5cbf74dcf30e9b" translate="yes" xml:space="preserve">
          <source>Reading and writing of files with Unicode data is, however, not best done with the &lt;code&gt;file&lt;/code&gt; module, as its interface is byte-oriented. A file opened with a Unicode encoding (like UTF-8) is best read or written using the &lt;code&gt;io&lt;/code&gt; module.</source>
          <target state="translated">그러나 유니 코드 데이터로 파일을 읽고 쓰는 것은 인터페이스가 바이트 지향적이므로 &lt;code&gt;file&lt;/code&gt; 모듈을 사용하는 것이 가장 좋습니다 . UTF-8과 같은 유니 코드 인코딩으로 열린 파일은 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 가장 잘 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c222fd852ba1812493153ccc2dcc4014ebaf8c" translate="yes" xml:space="preserve">
          <source>Reading man pages. Make sure that &lt;code&gt;erl&lt;/code&gt; is referring to the installed version. For example &lt;code&gt;/usr/local/bin/erl&lt;/code&gt;. Try viewing at the man page for Mnesia</source>
          <target state="translated">매뉴얼 페이지를 읽는 중입니다. &lt;code&gt;erl&lt;/code&gt; 이 설치된 버전을 참조하고 있는지 확인하십시오 . 예를 들어 &lt;code&gt;/usr/local/bin/erl&lt;/code&gt; 입니다. Mnesia의 맨 페이지에서보십시오</target>
        </trans-unit>
        <trans-unit id="252f4b5e75f178405e6c8d8917b5a5ddac65f605" translate="yes" xml:space="preserve">
          <source>Reads &lt;code&gt;Count&lt;/code&gt; characters from standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 &lt;code&gt;Count&lt;/code&gt; 문자를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다.</target>
        </trans-unit>
        <trans-unit id="f6c0eac8f5e6c09bd6f995de56f2885b56f262d1" translate="yes" xml:space="preserve">
          <source>Reads &lt;code&gt;Len&lt;/code&gt; bytes from the file referenced by &lt;code&gt;Handle&lt;/code&gt;. Returns &lt;code&gt;{ok, Data}&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt;, or &lt;code&gt;{error, reason()}&lt;/code&gt;. If the file is opened with &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;Data&lt;/code&gt; is a binary, otherwise it is a string.</source>
          <target state="translated">&lt;code&gt;Handle&lt;/code&gt; 에서 참조하는 파일에서 &lt;code&gt;Len&lt;/code&gt; 바이트를 읽습니다 . &lt;code&gt;{ok, Data}&lt;/code&gt; , &lt;code&gt;eof&lt;/code&gt; 또는 &lt;code&gt;{error, reason()}&lt;/code&gt; 리턴 합니다. 파일이 열립니다 경우 &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;Data&lt;/code&gt; , 그렇지 않으면 문자열입니다, 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="daa50c7790746978f3529a39e628aa17d94fcef6" translate="yes" xml:space="preserve">
          <source>Reads &lt;code&gt;Number&lt;/code&gt; bytes/characters from the file referenced by &lt;code&gt;IoDevice&lt;/code&gt;. The functions &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#pread-3&quot;&gt;pread/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt; are the only ways to read from a file opened in &lt;code&gt;raw&lt;/code&gt; mode (although they work for normally opened files, too).</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 가 참조하는 파일에서 &lt;code&gt;Number&lt;/code&gt; 바이트 / 문자를 읽 습니다 . &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#pread-3&quot;&gt;pread/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;raw&lt;/code&gt; 모드 에서 열린 파일에서 읽는 유일한 방법 입니다 (일반적으로 열린 파일에서도 작동하지만).</target>
        </trans-unit>
        <trans-unit id="f70ae81f047ca6b4913a5ff1eb01e17721a1df8e" translate="yes" xml:space="preserve">
          <source>Reads Erlang terms, separated by '.', from &lt;code&gt;Filename&lt;/code&gt;. Returns one of the following:</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 에서 '.'으로 구분 된 Erlang 용어를 읽습니다 . 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be3d677dc62d08604840b02570c3e7442cfa5893" translate="yes" xml:space="preserve">
          <source>Reads a (virtual) file &lt;code&gt;RemoteFilename&lt;/code&gt; from a TFTP server.</source>
          <target state="translated">TFTP 서버에서 (가상) 파일 &lt;code&gt;RemoteFilename&lt;/code&gt; 을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="475ab7b68b4f86a328c596114c612ba9ab111e93" translate="yes" xml:space="preserve">
          <source>Reads a chunk from the file.</source>
          <target state="translated">파일에서 청크를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bcf09f51900c4beb18f4a5c9714ec92cbd388e75" translate="yes" xml:space="preserve">
          <source>Reads a file from the server, and returns the data in a binary.</source>
          <target state="translated">서버에서 파일을 읽고 이진으로 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d10f6f7263be88bc8003790c8726391f4e9dbdf" translate="yes" xml:space="preserve">
          <source>Reads a file produced by &lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; and creates the corresponding table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 파일을 읽고 해당 테이블 &lt;code&gt;Tab&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dc54f5017946e86d78cdba6d809d92457be885be" translate="yes" xml:space="preserve">
          <source>Reads a line from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 라인을 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다.</target>
        </trans-unit>
        <trans-unit id="36b17ad13f0b033f6df4a993a7b171c360fa8c45" translate="yes" xml:space="preserve">
          <source>Reads a line of bytes/characters from the file referenced by &lt;code&gt;IoDevice&lt;/code&gt;. Lines are defined to be delimited by the linefeed (LF, &lt;code&gt;\n&lt;/code&gt;) character, but any carriage return (CR, &lt;code&gt;\r&lt;/code&gt;) followed by a newline is also treated as a single LF character (the carriage return is silently ignored). The line is returned &lt;strong&gt;including&lt;/strong&gt; the LF, but excluding any CR immediately followed by an LF. This behaviour is consistent with the behaviour of &lt;code&gt;io:get_line/2&lt;/code&gt;. If end of file is reached without any LF ending the last line, a line with no trailing LF is returned.</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 가 참조하는 파일에서 바이트 / 문자 행을 읽 습니다 . 줄은 줄 바꿈 (LF, &lt;code&gt;\n&lt;/code&gt; ) 문자 로 구분되도록 정의 되지만 줄 바꿈 뒤에 오는 캐리지 리턴 (CR, &lt;code&gt;\r&lt;/code&gt; )은 단일 LF 문자로 취급됩니다 (캐리지 리턴은 자동으로 무시됩니다). LF를 &lt;strong&gt;포함&lt;/strong&gt; 하여 행이 리턴 되지만 CR 뒤에 바로 LF가 있으면 제외됩니다. 이 동작은 &lt;code&gt;io:get_line/2&lt;/code&gt; 동작과 일치합니다 . LF가 마지막 행을 종료하지 않고 파일 끝에 도달하면 후행 LF가없는 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="aae52d304fd52a828dbf2eedbff2f04b0029c986" translate="yes" xml:space="preserve">
          <source>Reads a row by its SNMP index. This index is specified as an SNMP Object Identifier, a list of integers.</source>
          <target state="translated">SNMP 색인으로 행을 읽습니다. 이 색인은 정수 목록 인 SNMP 객체 식별자로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="842ce7e26143e68269e6af73ca149569ed32c0c5" translate="yes" xml:space="preserve">
          <source>Reads a term &lt;code&gt;Term&lt;/code&gt; from &lt;code&gt;IoDevice&lt;/code&gt;, prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Reading starts at location &lt;code&gt;StartLocation&lt;/code&gt;. Argument &lt;code&gt;Options&lt;/code&gt; is passed on as argument &lt;code&gt;Options&lt;/code&gt; of function &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 에서 &lt;code&gt;Term&lt;/code&gt; 이라는 용어 를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 와 함께 프롬프트 합니다. &lt;code&gt;StartLocation&lt;/code&gt; 위치에서 읽기가 시작됩니다 . 인수 &lt;code&gt;Options&lt;/code&gt; 인수로 전달됩니다 &lt;code&gt;Options&lt;/code&gt; 기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d4db0c3277853bee5baecd76ea077556e6a19fa" translate="yes" xml:space="preserve">
          <source>Reads a term &lt;code&gt;Term&lt;/code&gt; from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 용어 &lt;code&gt;Term&lt;/code&gt; 을 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다.</target>
        </trans-unit>
        <trans-unit id="ac643941e9886622de2937798fd5270edc0fabf5" translate="yes" xml:space="preserve">
          <source>Reads a time stamp into the memory pointed to by parameter &lt;code&gt;now&lt;/code&gt;. For information about specific fields, see &lt;code&gt;&lt;a href=&quot;#ErlDrvNowData&quot;&gt;ErlDrvNowData&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;now&lt;/code&gt; 매개 변수가 가리키는 메모리에 타임 스탬프를 읽습니다 . 특정 필드에 대한 정보는 &lt;code&gt;&lt;a href=&quot;#ErlDrvNowData&quot;&gt;ErlDrvNowData&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c19818e3b583cae64bcc594ab0744745d21d8def" translate="yes" xml:space="preserve">
          <source>Reads all records from table &lt;code&gt;Tab&lt;/code&gt; with key &lt;code&gt;Key&lt;/code&gt;. This function has the same semantics regardless of the location of &lt;code&gt;Tab&lt;/code&gt;. If the table is of type &lt;code&gt;bag&lt;/code&gt;, the function &lt;code&gt;mnesia:read(Tab, Key)&lt;/code&gt; can return an arbitrarily long list. If the table is of type &lt;code&gt;set&lt;/code&gt;, the list is either of length 1, or &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">키 &lt;code&gt;Key&lt;/code&gt; 를 사용 하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 에서 모든 레코드를 읽습니다 . 이 함수는 &lt;code&gt;Tab&lt;/code&gt; 위치에 관계없이 동일한 의미를 갖습니다 . 테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 &lt;code&gt;mnesia:read(Tab, Key)&lt;/code&gt; 함수 는 임의로 긴 목록을 리턴 할 수 있습니다. 테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되면 목록의 길이는 1 또는 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5c89de20ea0caf916aed94b0b16edcd0fa5a8208" translate="yes" xml:space="preserve">
          <source>Reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression) from &lt;code&gt;Filename&lt;/code&gt;. The result of the evaluation is not returned; any expression sequence in the file must be there for its side effect. Returns one of the following:</source>
          <target state="translated">'.'으로 구분 된 Erlang 표현식을 읽고 평가합니다. &lt;code&gt;Filename&lt;/code&gt; 에서 (또는 ',', 일련의 표현식도 표현식입니다 .) 평가 결과는 반환되지 않습니다. 파일의 모든 표현식 순서는 부작용이 있어야합니다. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4538536a6029a3eaaa364e5024ba9396498603a" translate="yes" xml:space="preserve">
          <source>Reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from the file.</source>
          <target state="translated">'.'으로 구분 된 Erlang 표현식을 읽고 평가합니다. (또는 ',', 일련의 표현식은 표현식이기도합니다).</target>
        </trans-unit>
        <trans-unit id="f86a65da862e66ea58fe0b1e1894f4ad5ab8707c" translate="yes" xml:space="preserve">
          <source>Reads and parses a file. If successful, &lt;code&gt;{ok, Forms}&lt;/code&gt; is returned, where &lt;code&gt;Forms&lt;/code&gt; is a list of abstract syntax trees representing the &quot;program forms&quot; of the file (cf. &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt;). Otherwise, &lt;code&gt;{error, errorinfo()}&lt;/code&gt; is returned, typically if the file could not be opened. Note that parse errors show up as error markers in the returned list of forms; they do not cause this function to fail or return &lt;code&gt;{error, errorinfo()}&lt;/code&gt;.</source>
          <target state="translated">파일을 읽고 구문 분석합니다. 성공하면 &lt;code&gt;{ok, Forms}&lt;/code&gt; 가 리턴됩니다. 여기서 &lt;code&gt;Forms&lt;/code&gt; 는 파일의 &quot;프로그램 형식&quot;을 나타내는 추상 구문 트리 목록입니다 (예 : &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt; ). 그렇지 않으면 일반적으로 파일을 열 수없는 경우 &lt;code&gt;{error, errorinfo()}&lt;/code&gt; 가 리턴됩니다. 구문 분석 오류는 반환 된 양식 목록에 오류 표시 자로 나타납니다. 이 함수는 실패하거나 &lt;code&gt;{error, errorinfo()}&lt;/code&gt; 리턴하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2920dcddbbb429fc599c5c461913301f70aa81e6" translate="yes" xml:space="preserve">
          <source>Reads and parses a single program form from an I/O stream. Characters are read from &lt;code&gt;IODevice&lt;/code&gt; until an end-of-form marker is found (a period character followed by whitespace), or until end-of-file; apart from this, the behaviour is similar to that of &lt;code&gt;parse/3&lt;/code&gt;, except that the return values also contain the final line number given that &lt;code&gt;StartLine&lt;/code&gt; is the initial line number, and that &lt;code&gt;{eof, LineNo}&lt;/code&gt; may be returned.</source>
          <target state="translated">I / O 스트림에서 단일 프로그램 양식을 읽고 구문 분석합니다. 양식 끝 마커가 발견 될 때까지 (마침표 문자 다음에 공백) 또는 파일 끝까지 문자 를 &lt;code&gt;IODevice&lt;/code&gt; 에서 읽습니다 . 이와는 별도로 &lt;code&gt;StartLine&lt;/code&gt; 이 초기 행 번호이고 &lt;code&gt;{eof, LineNo}&lt;/code&gt; 가 리턴 될 경우 리턴 값에도 최종 행 번호가 포함된다는 점을 제외 하면 동작은 &lt;code&gt;parse/3&lt;/code&gt; 의 동작과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a5c3bcde53de74966bb137b9992cbcf8bea8b82b" translate="yes" xml:space="preserve">
          <source>Reads and parses program text from an I/O stream. Characters are read from &lt;code&gt;IODevice&lt;/code&gt; until end-of-file; apart from this, the behaviour is the same as for &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;StartLine&lt;/code&gt; is the initial line number, which should be a positive integer.</source>
          <target state="translated">I / O 스트림에서 프로그램 텍스트를 읽고 구문 분석합니다. 파일 끝까지 &lt;code&gt;IODevice&lt;/code&gt; 에서 문자를 읽습니다 . 이 외에도 동작은 &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. &lt;code&gt;StartLine&lt;/code&gt; 은 초기 행 번호이며 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="575313b04f7b2d9ade2c2ac804470bebb4ac3f46" translate="yes" xml:space="preserve">
          <source>Reads characters from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Interprets the characters in accordance with &lt;code&gt;Format&lt;/code&gt;. &lt;code&gt;Format&lt;/code&gt; contains control sequences that directs the interpretation of the input.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 문자를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다. &lt;code&gt;Format&lt;/code&gt; 에 따라 문자를 해석합니다 . &lt;code&gt;Format&lt;/code&gt; 은 입력의 해석을 지시하는 제어 순서를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="936b3c9cc90592c88890f5bba0974bbcc4534300" translate="yes" xml:space="preserve">
          <source>Reads chunk data for all chunks.</source>
          <target state="translated">모든 청크에 대한 청크 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5478616d388c3efd3ce75d4d04ed80f7b653d5be" translate="yes" xml:space="preserve">
          <source>Reads chunk data for selected chunks references. The order of the returned list of chunk data is determined by the order of the list of chunks references.</source>
          <target state="translated">선택된 청크 참조에 대한 청크 데이터를 읽습니다. 반환 된 청크 데이터 목록의 순서는 청크 참조 목록의 순서에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b313c71e885968a16f290931cc4dc9de8929bf2d" translate="yes" xml:space="preserve">
          <source>Reads configuration data values.</source>
          <target state="translated">구성 데이터 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9149fffa2a35130db955805683d3e726e8bc00d9" translate="yes" xml:space="preserve">
          <source>Reads data from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Reading starts at location &lt;code&gt;StartLocation&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). Argument &lt;code&gt;Options&lt;/code&gt; is passed on as argument &lt;code&gt;Options&lt;/code&gt; of function &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt;. The data is tokenized as if it were a sequence of Erlang expressions until a final dot (&lt;code&gt;.&lt;/code&gt;) is reached. This token is also returned.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 데이터를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다. 위치 &lt;code&gt;StartLocation&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 에서 읽기가 시작됩니다 . 인수 &lt;code&gt;Options&lt;/code&gt; 인수로 전달됩니다 &lt;code&gt;Options&lt;/code&gt; 기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt; . 데이터는 최종 점 ( &lt;code&gt;.&lt;/code&gt; )에 도달 할 때까지 일련의 Erlang 표현식 인 것처럼 토큰 화됩니다 . 이 토큰도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="374c9ef16799b9abb4e9d26f5fa912264a6e1657" translate="yes" xml:space="preserve">
          <source>Reads data from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Starts reading at location &lt;code&gt;StartLocation&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). Argument &lt;code&gt;Options&lt;/code&gt; is passed on as argument &lt;code&gt;Options&lt;/code&gt; of function &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt;. The data is tokenized and parsed as if it was a sequence of Erlang expressions until a final dot (&lt;code&gt;.&lt;/code&gt;) is reached.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 데이터를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다. 위치 &lt;code&gt;StartLocation&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 에서 읽기를 시작합니다 . 인수 &lt;code&gt;Options&lt;/code&gt; 인수로 전달됩니다 &lt;code&gt;Options&lt;/code&gt; 기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt; . 데이터는 최종 점 ( &lt;code&gt;.&lt;/code&gt; )에 도달 할 때까지 일련의 Erlang 표현식 인 것처럼 토큰 화되고 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1cad2965b9c36b880989ab004d941243e0ccdf7" translate="yes" xml:space="preserve">
          <source>Reads data from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Starts reading at location &lt;code&gt;StartLocation&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). Argument &lt;code&gt;Options&lt;/code&gt; is passed on as argument &lt;code&gt;Options&lt;/code&gt; of function &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt;. The data is tokenized and parsed as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot (&lt;code&gt;.&lt;/code&gt;) is reached.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 데이터를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다. 위치 &lt;code&gt;StartLocation&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 에서 읽기를 시작합니다 . 인수 &lt;code&gt;Options&lt;/code&gt; 인수로 전달됩니다 &lt;code&gt;Options&lt;/code&gt; 기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt; . 데이터는 최종 점 ( &lt;code&gt;.&lt;/code&gt; )에 도달 할 때까지 Erlang 양식 (Erlang 소스 파일의 유효한 Erlang 표현식 중 하나) 인 것처럼 토큰 화되고 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="595f61201ea85ff9dc6c8defa70b03e0e2371abf" translate="yes" xml:space="preserve">
          <source>Reads data from the standard input (&lt;code&gt;IoDevice&lt;/code&gt;), prompting it with &lt;code&gt;Prompt&lt;/code&gt;. Starts reading at location &lt;code&gt;StartLocation&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). Argument &lt;code&gt;Options&lt;/code&gt; is passed on as argument &lt;code&gt;Options&lt;/code&gt; of function &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt;. The data is tokenized as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot (&lt;code&gt;.&lt;/code&gt;) is reached. This last token is also returned.</source>
          <target state="translated">표준 입력 ( &lt;code&gt;IoDevice&lt;/code&gt; ) 에서 데이터를 읽고 &lt;code&gt;Prompt&lt;/code&gt; 로 프롬프트 합니다. 위치 &lt;code&gt;StartLocation&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 에서 읽기를 시작합니다 . 인수 &lt;code&gt;Options&lt;/code&gt; 인수로 전달됩니다 &lt;code&gt;Options&lt;/code&gt; 기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#tokens-4&quot;&gt;erl_scan:tokens/4&lt;/a&gt;&lt;/code&gt; . 데이터는 최종 점 ( &lt;code&gt;.&lt;/code&gt; )에 도달 할 때까지 Erlang 양식 (Erlang 소스 파일의 유효한 Erlang 표현식 중 하나) 인 것처럼 토큰 화됩니다 . 이 마지막 토큰도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="adade152b720618374d89b5e6eb7f3a1c8be4d9d" translate="yes" xml:space="preserve">
          <source>Reads data in parts from the file. This is intended for memory-limited machines that, for example, builds a tar file on a remote machine over SFTP, see &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt;.</source>
          <target state="translated">파일에서 부분적으로 데이터를 읽습니다. 예를 들어 SFTP를 통해 원격 시스템에 tar 파일을 작성하는 메모리 제한 시스템을위한 것입니다 ( &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b2dd7f9783c71e871e5a5536f61fe7d2f34a7b79" translate="yes" xml:space="preserve">
          <source>Reads each &lt;code&gt;Mod&lt;/code&gt; from directory &lt;code&gt;App-Vsn/ebin&lt;/code&gt; as a binary. It does not load the modules. The instruction is to be placed first in the script to read all new code from the file to make the suspend-load-resume cycle less time-consuming.</source>
          <target state="translated">&lt;code&gt;App-Vsn/ebin&lt;/code&gt; 디렉토리에서 각 &lt;code&gt;Mod&lt;/code&gt; 를 바이너리로 읽습니다 . 모듈을로드하지 않습니다. 명령은 스크립트에서 첫 번째로 배치되어 파일에서 모든 새 코드를 읽고 일시 중단-로드-재개주기를 줄 이도록합니다.</target>
        </trans-unit>
        <trans-unit id="5f9e8132777eeeea0b0b9630390bdccb83499a2f" translate="yes" xml:space="preserve">
          <source>Reads file &lt;code&gt;.hosts.erlang&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt;. Returns the hosts in this file as a list. Returns &lt;code&gt;{error, Reason}&lt;/code&gt; if the file cannot be read or the Erlang terms on the file cannot be interpreted.</source>
          <target state="translated">파일 읽어 &lt;code&gt;.hosts.erlang&lt;/code&gt; 을 , 섹션 참조 &lt;code&gt;&lt;a href=&quot;#files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; . 이 파일의 호스트를리스트로 돌려줍니다. 파일을 읽을 수 없거나 파일의 Erlang 용어를 해석 할 수없는 경우 &lt;code&gt;{error, Reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="acd0eef8d72bba8b5179acfa61549202aee45b07" translate="yes" xml:space="preserve">
          <source>Reads from an open file, without waiting for the result. If the handle is valid, the function returns &lt;code&gt;{async, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is a term guaranteed to be unique between calls of &lt;code&gt;aread&lt;/code&gt;. The actual data is sent as a message to the calling process. This message has the form &lt;code&gt;{async_reply, N, Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is the result from the read, either &lt;code&gt;{ok, Data}&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt;, or &lt;code&gt;{error, reason()}&lt;/code&gt;.</source>
          <target state="translated">결과를 기다리지 않고 열린 파일에서 읽습니다. 핸들이 유효하면이 함수는 &lt;code&gt;{async, N}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;aread&lt;/code&gt; 호출 사이에서 고유함을 보장하는 용어 입니다. 실제 데이터는 호출 프로세스에 메시지로 전송됩니다. 이 메시지의 형식은 &lt;code&gt;{async_reply, N, Result}&lt;/code&gt; . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 &lt;code&gt;{ok, Data}&lt;/code&gt; , &lt;code&gt;eof&lt;/code&gt; 또는 &lt;code&gt;{error, reason()}&lt;/code&gt; 읽기 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="473a3f49d1f005cdbfb18d83b547219146f6b620" translate="yes" xml:space="preserve">
          <source>Reads information about the timetrap set for the current test case. &lt;code&gt;Scaling&lt;/code&gt; indicates if &lt;code&gt;Common Test&lt;/code&gt; will attempt to compensate timetraps automatically for runtime delays introduced by, for example, tools like cover. &lt;code&gt;ScaleVal&lt;/code&gt; is the value of the current scaling multipler (always 1 if scaling is disabled). Note the &lt;code&gt;Time&lt;/code&gt; is not the scaled result.</source>
          <target state="translated">현재 테스트 케이스에 설정된 타임 트랩에 대한 정보를 읽습니다. &lt;code&gt;Scaling&lt;/code&gt; 은 &lt;code&gt;Common Test&lt;/code&gt; 가 예를 들어 cover와 같은 도구에 의해 도입 된 런타임 지연에 대해 자동으로 타임 트랩을 보상하려고 시도 하는지 여부를 나타냅니다 . &lt;code&gt;ScaleVal&lt;/code&gt; 은 현재 스케일링 멀티플렉서의 값입니다 (스케일링이 비활성화 된 경우 항상 1). 메모 &lt;code&gt;Time&lt;/code&gt; 스케일링 된 결과가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5cb0a0e95145733613cfe1c4d5d32a786e548cb7" translate="yes" xml:space="preserve">
          <source>Reads one or more terms from the test specification used to configure and run this test. &lt;code&gt;Tag&lt;/code&gt; is any valid test specification tag, for example, &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;config&lt;/code&gt;, or &lt;code&gt;logdir&lt;/code&gt;. User-specific terms are also available to read if option &lt;code&gt;allow_user_terms&lt;/code&gt; is set.</source>
          <target state="translated">이 테스트를 구성하고 실행하는 데 사용 된 테스트 사양에서 하나 이상의 용어를 읽습니다. &lt;code&gt;Tag&lt;/code&gt; 는 유효한 테스트 사양 태그입니다 (예 : &lt;code&gt;label&lt;/code&gt; , &lt;code&gt;config&lt;/code&gt; 또는 &lt;code&gt;logdir&lt;/code&gt; ) . &lt;code&gt;allow_user_terms&lt;/code&gt; 옵션 이 설정된 경우 사용자 별 용어를 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9678f45370812f85bf721cb4a46a673223c64b44" translate="yes" xml:space="preserve">
          <source>Reads record definitions from a module's BEAM file. If there are no record definitions in the BEAM file, the source file is located and read instead. Returns the names of the record definitions read. &lt;code&gt;Module&lt;/code&gt; is an atom.</source>
          <target state="translated">모듈의 BEAM 파일에서 레코드 정의를 읽습니다. BEAM 파일에 레코드 정의가 없으면 소스 파일을 찾아서 대신 읽습니다. 읽은 레코드 정의의 이름을 리턴합니다. &lt;code&gt;Module&lt;/code&gt; 은 원자입니다.</target>
        </trans-unit>
        <trans-unit id="df8cc01b9c5d974fd88821805f092bbf2d9438ba" translate="yes" xml:space="preserve">
          <source>Reads record definitions from files but discards record names not mentioned in &lt;code&gt;RecordNames&lt;/code&gt; (a record name or a list of record names).</source>
          <target state="translated">파일에서 레코드 정의를 &lt;code&gt;RecordNames&lt;/code&gt; 언급되지 않은 레코드 이름 (레코드 이름 또는 레코드 이름 목록)은 버립니다 .</target>
        </trans-unit>
        <trans-unit id="c7a29df53eefec6311892690ec9b68fab17c6c71" translate="yes" xml:space="preserve">
          <source>Reads record definitions from files. Existing definitions of any of the record names read are replaced. &lt;code&gt;Wildcard&lt;/code&gt; is a wildcard string as defined in &lt;code&gt;&lt;a href=&quot;filelib&quot;&gt;filelib(3)&lt;/a&gt;&lt;/code&gt;, but not an atom.</source>
          <target state="translated">파일에서 레코드 정의를 읽습니다. 읽은 레코드 이름의 기존 정의가 바뀝니다. &lt;code&gt;Wildcard&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;filelib&quot;&gt;filelib(3)&lt;/a&gt;&lt;/code&gt; 정의 된 와일드 카드 문자열 이지만 원자는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1d4affa78ab45ecbfb3d3d5e0421aca7b1d8b2a0" translate="yes" xml:space="preserve">
          <source>Reads record definitions from files. The compiler options &lt;code&gt;{i,&amp;nbsp;Dir}&lt;/code&gt;, &lt;code&gt;{d,&amp;nbsp;Macro}&lt;/code&gt;, and &lt;code&gt;{d,&amp;nbsp;Macro,&amp;nbsp;Value}&lt;/code&gt; are recognized and used for setting up the include path and macro definitions. To read all record definitions, use &lt;code&gt;'_'&lt;/code&gt; as value of &lt;code&gt;RecordNames&lt;/code&gt;.</source>
          <target state="translated">파일에서 레코드 정의를 읽습니다. 컴파일러 옵션 &lt;code&gt;{i,&amp;nbsp;Dir}&lt;/code&gt; , &lt;code&gt;{d,&amp;nbsp;Macro}&lt;/code&gt; 및 &lt;code&gt;{d,&amp;nbsp;Macro,&amp;nbsp;Value}&lt;/code&gt; 는 포함 경로 및 매크로 정의를 설정하는 데 인식 및 사용됩니다. 모든 레코드 정의를 읽으려면 &lt;code&gt;RecordNames&lt;/code&gt; 값으로 &lt;code&gt;'_'&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a97a11fc0cb6ea77a20ef2c272dd9b0c766b3e97" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by &lt;code&gt;File&lt;/code&gt; is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; specified by &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">I / O 장치에서 &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; 을 읽고 그에 따라 장치의 인코딩을 설정합니다. &lt;code&gt;File&lt;/code&gt; 이 참조하는 I / O 장치의 위치는 영향을받지 않습니다. I / O 장치에서 유효한 인코딩을 읽을 수없는 경우 I / O 장치의 인코딩은 &lt;code&gt;Default&lt;/code&gt; 로 지정된 &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; 으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f93ddca5006ccdbb3f7596d1f8a8390df9f011d" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by &lt;code&gt;File&lt;/code&gt; is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the default encoding.</source>
          <target state="translated">I / O 장치에서 &lt;code&gt;&lt;a href=&quot;#encoding&quot;&gt;encoding&lt;/a&gt;&lt;/code&gt; 을 읽고 그에 따라 장치의 인코딩을 설정합니다. &lt;code&gt;File&lt;/code&gt; 이 참조하는 I / O 장치의 위치는 영향을받지 않습니다. I / O 장치에서 유효한 인코딩을 읽을 수 없으면 I / O 장치의 인코딩이 기본 인코딩으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c87f7c3cd992fe79a2c1b8d950c1deaacc9012" translate="yes" xml:space="preserve">
          <source>Reads the application configuration parameter &lt;code&gt;logger&lt;/code&gt; and calls &lt;code&gt;add_handlers/1&lt;/code&gt; with its contents.</source>
          <target state="translated">응용 프로그램 구성 매개 변수 &lt;code&gt;logger&lt;/code&gt; 읽고 내용으로 &lt;code&gt;add_handlers/1&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0978dc894d2a71b1cf1cfdef66ccd9de4a864810" translate="yes" xml:space="preserve">
          <source>Reads the current time of a timer, and places the result in &lt;code&gt;time_left&lt;/code&gt;. This is the time in milliseconds, before the time-out occurs.</source>
          <target state="translated">타이머의 현재 시간을 읽고 &lt;code&gt;time_left&lt;/code&gt; 에 결과를 배치 합니다. 시간이 초과되기 전의 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="ef330399fd66929e3d50b54bbdd55115fbd0d652" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;Filename&lt;/code&gt; and creates raw profile data that is stored in RAM by the &lt;code&gt;fprof&lt;/code&gt; server. If the option &lt;code&gt;file&lt;/code&gt; is given, or none of these options are given, the file &lt;code&gt;&quot;fprof.trace&quot;&lt;/code&gt; is read. The call will return when the whole trace has been read with the return value &lt;code&gt;ok&lt;/code&gt; if successful. This option is not allowed with the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 파일을 읽고 &lt;code&gt;fprof&lt;/code&gt; 서버 가 RAM에 저장 한 원시 프로파일 데이터를 작성 합니다. 옵션 &lt;code&gt;file&lt;/code&gt; 이 제공되거나 이러한 옵션이 제공되지 &lt;code&gt;&quot;fprof.trace&quot;&lt;/code&gt; 파일을 읽습니다. 성공 하면 반환 값이 &lt;code&gt;ok&lt;/code&gt; 인 전체 트레이스를 읽었을 때 호출이 반환됩니다 . 이 옵션은 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;stop&lt;/code&gt; 옵션 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="49742bfb294b102cbe18de7cfaaa6d790db477e2" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;mysystem.rel&lt;/code&gt; and creates a new file &lt;code&gt;plain.rel&lt;/code&gt; that is identical to the former, except that it only lists the Kernel and STDLIB applications.</source>
          <target state="translated">&lt;code&gt;mysystem.rel&lt;/code&gt; 파일을 읽고 이전 파일 과 동일한 새 파일 &lt;code&gt;plain.rel&lt;/code&gt; 을 작성 합니다 (단, 커널 및 STDLIB 애플리케이션 만 나열 함).</target>
        </trans-unit>
        <trans-unit id="f903b588a4d361175c96f10e6de158fead02c148" translate="yes" xml:space="preserve">
          <source>Reads the link target from the symbolic link specified by &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 으로 지정된 심볼릭 링크에서 링크 대상을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e21a2e27c60061a5209d8bcd0b5afd002f70ac3e" translate="yes" xml:space="preserve">
          <source>Reads the next chunk of uncompressed data, initialized by &lt;code&gt;&lt;a href=&quot;#inflateChunk-2&quot;&gt;inflateChunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#inflateChunk-2&quot;&gt;inflateChunk/2&lt;/a&gt;&lt;/code&gt; 로 초기화 된 비 압축 데이터의 다음 청크를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="a4416420a93781bcc0dc5f8a20da753372346242" translate="yes" xml:space="preserve">
          <source>Reads the referenced XML schema and checks that it is valid. Returns the &lt;code&gt;global_state()&lt;/code&gt; with schema info or an error reason. The error reason may be a list of several errors or a single error encountered during the processing.</source>
          <target state="translated">참조 된 XML 스키마를 읽고 유효한지 확인하십시오. 스키마 정보 또는 오류 이유가 있는 &lt;code&gt;global_state()&lt;/code&gt; 를 리턴합니다 . 오류 이유는 여러 오류 목록 또는 처리 중에 발생한 단일 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd38efe5a280152c0ed35ee9c7f2ad0f403268c" translate="yes" xml:space="preserve">
          <source>Reads the referenced XML schemas and controls they are valid. Returns the &lt;code&gt;global_state()&lt;/code&gt; with schema info or an error reason. The error reason may be a list of several errors or a single error encountered during the processing.</source>
          <target state="translated">참조 된 XML 스키마를 읽고 유효한 스키마를 제어하십시오. 스키마 정보 또는 오류 이유가 있는 &lt;code&gt;global_state()&lt;/code&gt; 를 리턴합니다 . 오류 이유는 여러 오류 목록 또는 처리 중에 발생한 단일 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9173077db3e9017296abe012415cae4350f279ec" translate="yes" xml:space="preserve">
          <source>Reads the runtime system version (&lt;code&gt;&quot;5.10.4&quot;&lt;/code&gt;) and release version (&lt;code&gt;&quot;FIRST&quot;&lt;/code&gt;) from the file &lt;code&gt;start_erl.data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start_erl.data&lt;/code&gt; 파일에서 런타임 시스템 버전 ( &lt;code&gt;&quot;5.10.4&quot;&lt;/code&gt; ) 및 릴리스 버전 ( &lt;code&gt;&quot;FIRST&quot;&lt;/code&gt; )을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="839d040990703f858648a5ce1365721721986faf" translate="yes" xml:space="preserve">
          <source>Reads the schema state with all information of the processed schema from a file created with &lt;code&gt;state2file/[1,2]&lt;/code&gt;. The format of this file is internal. The state can then be used validating an XML document.</source>
          <target state="translated">&lt;code&gt;state2file/[1,2]&lt;/code&gt; 로 작성된 파일에서 처리 된 스키마의 모든 정보가있는 스키마 상태를 읽습니다 . 이 파일의 형식은 내부입니다. 그런 다음 상태를 사용하여 XML 문서를 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce1e5c45b80097e6f2841595672e121dabebb10" translate="yes" xml:space="preserve">
          <source>Reads the specified binary trace log(s). The logs are processed in the order of their time stamps as long as option &lt;code&gt;disable_sort&lt;/code&gt; is not specified.</source>
          <target state="translated">지정된 이진 추적 로그를 읽습니다. &lt;code&gt;disable_sort&lt;/code&gt; 옵션을 지정하지 않으면 로그는 타임 스탬프 순서대로 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="148a9f2e73482a200b8b553fede2788e553b25f1" translate="yes" xml:space="preserve">
          <source>Reads the state of a timer that has been created by either &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;TimerRef&lt;/code&gt; identifies the timer, and was returned by the BIF that created the timer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt; 에 의해 작성된 타이머의 상태를 읽습니다 . &lt;code&gt;TimerRef&lt;/code&gt; 는 타이머를 식별하며 타이머를 만든 BIF에 의해 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce5cad4e11c1c94a9f2dab2d00983fc0cb846b46" translate="yes" xml:space="preserve">
          <source>Reads the state of a timer. The same as calling &lt;code&gt;&lt;a href=&quot;#read_timer-2&quot;&gt;erlang:read_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타이머 상태를 읽습니다. &lt;code&gt;&lt;a href=&quot;#read_timer-2&quot;&gt;erlang:read_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="9aa5c569849cf218527f93f7dee3cdc648481493" translate="yes" xml:space="preserve">
          <source>Reads using &lt;code&gt;UserPrivate&lt;/code&gt; but only &lt;code&gt;Size&lt;/code&gt; bytes. Notice that there is only an arity-2 read function, not an arity-1 function.</source>
          <target state="translated">&lt;code&gt;UserPrivate&lt;/code&gt; 를 사용 하지만 &lt;code&gt;Size&lt;/code&gt; 바이트 만 사용하여 읽습니다 . arity-1 함수가 아니라 arity-2 읽기 기능 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d4f658eb0b3d94a3c309c489e7d4e9bdbc4f01" translate="yes" xml:space="preserve">
          <source>Realloc always moves. When enabled, reallocate operations are more or less translated into an allocate, copy, free sequence. This often reduces memory fragmentation, but costs performance.</source>
          <target state="translated">Realloc은 항상 움직입니다. 사용 가능한 경우 재 할당 조작은 할당, 복사, 사용 가능 시퀀스로 다소 변환됩니다. 이로 인해 메모리 조각화가 줄어들지 만 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9c4c1a235d7360d6343d538e931ae913df1102" translate="yes" xml:space="preserve">
          <source>Reallocates memory allocated by &lt;code&gt;&lt;a href=&quot;#enif_alloc&quot;&gt;enif_alloc&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc&quot;&gt;enif_alloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당 된 메모리 를 &lt;code&gt;size&lt;/code&gt; 바이트로 재 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="db92aea9f5fbc58fe0efec58ed9588b7d88ee22c" translate="yes" xml:space="preserve">
          <source>Reason :: term(),</source>
          <target state="translated">이유 :: term (),</target>
        </trans-unit>
        <trans-unit id="6891013bdffc70486bc0bdf2c393714c46955deb" translate="yes" xml:space="preserve">
          <source>Rebalances &lt;code&gt;Tree1&lt;/code&gt;. Notice that this is rarely necessary, but can be motivated when many nodes have been deleted from the tree without further insertions. Rebalancing can then be forced to minimize lookup times, as deletion does not rebalance the tree.</source>
          <target state="translated">&lt;code&gt;Tree1&lt;/code&gt; 재조정 . 이것은 거의 필요하지 않지만 추가 삽입없이 트리에서 많은 노드가 삭제 된 경우 동기를 부여 할 수 있습니다. 삭제로 인해 트리의 균형이 재조정되지 않으므로 재조정을 통해 조회 시간을 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="562c2b623630d3b42ab3e60d86c0debcf41c1ff3" translate="yes" xml:space="preserve">
          <source>Rebalances the tree representation of &lt;code&gt;Set1&lt;/code&gt;. Notice that this is rarely necessary, but can be motivated when a large number of elements have been deleted from the tree without further insertions. Rebalancing can then be forced to minimise lookup times, as deletion does not rebalance the tree.</source>
          <target state="translated">&lt;code&gt;Set1&lt;/code&gt; 의 트리 표현을 재조정합니다 . 이것은 거의 필요하지 않지만 추가 삽입없이 트리에서 많은 수의 요소가 삭제 된 경우 동기 부여가 가능합니다. 삭제로 인해 트리의 균형이 재조정되지 않으므로 재조정을 통해 조회 시간을 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65975122721ed3cffdcd5af89ade5a30eb41911c" translate="yes" xml:space="preserve">
          <source>Reboots the system by making the old release permanent, and calls &lt;code&gt;init:reboot()&lt;/code&gt; directly. The release must have status &lt;code&gt;old&lt;/code&gt;.</source>
          <target state="translated">이전 릴리스를 영구적으로 만들어 시스템을 재부팅하고 &lt;code&gt;init:reboot()&lt;/code&gt; 직접 호출 합니다 . 릴리스 상태는 &lt;code&gt;old&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c151c49267645ae0a3f97285a4421925221ab63e" translate="yes" xml:space="preserve">
          <source>Recall that a call is a pair (From, To). &lt;code&gt;domain&lt;/code&gt; applied to a set of calls is interpreted as the set of all vertices From, and &lt;code&gt;range&lt;/code&gt; as the set of all vertices To. The interpretation of the &lt;code&gt;strict&lt;/code&gt; operator is the operand with all calls on the form (A, A) removed.</source>
          <target state="translated">통화는 한 쌍 (발신인, 도착 인)임을 상기하십시오. 일련의 호출에 적용된 &lt;code&gt;domain&lt;/code&gt; 은 모든 정점의 시작으로 해석되고 &lt;code&gt;range&lt;/code&gt; 는 모든 정점의 설정으로 해석됩니다 . &lt;code&gt;strict&lt;/code&gt; 연산자 의 해석은 (A, A) 형식의 모든 호출이 제거 된 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="fbe39f3322855d03ba354f72c527385f73d95360" translate="yes" xml:space="preserve">
          <source>Receive buffer size.</source>
          <target state="translated">수신 버퍼 크기.</target>
        </trans-unit>
        <trans-unit id="4ae1a5ec8aa92d4958acd89043f891f02e540bf3" translate="yes" xml:space="preserve">
          <source>Receive notification of a notation declaration event.</source>
          <target state="translated">표기법 선언 이벤트의 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="5544b22e095d4110eb969347412c5f0ad7a7eb1f" translate="yes" xml:space="preserve">
          <source>Receive notification of a processing instruction. The Parser will send this event once for each processing instruction found: note that processing instructions may occur before or after the main document element.</source>
          <target state="translated">처리 명령의 알림을받습니다. 파서는 발견 된 각 처리 명령에 대해이 이벤트를 한 번 전송합니다. 처리 명령은 기본 문서 요소 전후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbbc3c20409ab8df6511a3a9d041b81bc1f03484" translate="yes" xml:space="preserve">
          <source>Receive notification of an unparsed entity declaration event.</source>
          <target state="translated">구문 분석되지 않은 엔티티 선언 이벤트에 대한 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="b0f707ac12424cf8350e1640b548139d4dcbc752" translate="yes" xml:space="preserve">
          <source>Receive notification of character data.</source>
          <target state="translated">캐릭터 데이터의 통지를받습니다.</target>
        </trans-unit>
        <trans-unit id="e1ed75deeb63816becb327823827f361dc002ace" translate="yes" xml:space="preserve">
          <source>Receive notification of ignorable whitespace in element content.</source>
          <target state="translated">요소 내용에서 무시할 수있는 공백에 대한 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="7ad2df2530dcae85b22b6938c6f4a1d9b0af6c9a" translate="yes" xml:space="preserve">
          <source>Receive notification of the beginning of a document. The SAX parser will send this event only once before any other event callbacks.</source>
          <target state="translated">문서 시작 알림을받습니다. SAX 파서는이 이벤트를 다른 이벤트 콜백 전에 한 번만 보냅니다.</target>
        </trans-unit>
        <trans-unit id="877d2315fff28722da3564b35f709435f38d644a" translate="yes" xml:space="preserve">
          <source>Receive notification of the beginning of an element. The Parser will send this event at the beginning of every element in the XML document; there will be a corresponding endElement event for every startElement event (even when the element is empty). All of the element's content will be reported, in order, before the corresponding endElement event.</source>
          <target state="translated">요소의 시작에 대한 알림을받습니다. 파서는 XML 문서의 모든 요소가 시작될 때이 이벤트를 보냅니다. 모든 startElement 이벤트에 대해 해당 endElement 이벤트가 있습니다 (요소가 비어있는 경우에도). 해당 endElement 이벤트 전에 요소의 모든 내용이 순서대로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8643851b60b52ba3b3a806063fe1eea7f4aff427" translate="yes" xml:space="preserve">
          <source>Receive notification of the end of a document. The SAX parser will send this event only once, and it will be the last event during the parse.</source>
          <target state="translated">문서 끝의 알림을받습니다. SAX 구문 분석기는이 이벤트를 한 번만 전송하며 구문 분석 중 마지막 이벤트가됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb259e3df1d0efa19aa9bec712acc5ac84cbaf8" translate="yes" xml:space="preserve">
          <source>Receive notification of the end of an element. The SAX parser will send this event at the end of every element in the XML document; there will be a corresponding startElement event for every endElement event (even when the element is empty).</source>
          <target state="translated">요소의 끝의 통지를받습니다. SAX 파서는이 이벤트를 XML 문서 내의 모든 요소의 말미에 송신합니다. 모든 endElement 이벤트에 해당하는 startElement 이벤트가 있습니다 (요소가 비어있는 경우에도).</target>
        </trans-unit>
        <trans-unit id="8797c16612fdf5d27b7de210d50ba2cccb65cc70" translate="yes" xml:space="preserve">
          <source>Receive pending limit (see the MGOriginatedPendingLimit and the MGCOriginatedPendingLimit of the megaco root package). This parameter specifies how many pending messages that can be received (for a sent transaction request). When the limit is exceeded, the transaction is considered lost, and an error returned to the user (through the call-back function &lt;strong&gt;handle_trans_reply&lt;/strong&gt;).</source>
          <target state="translated">보류 제한을받습니다 (megaco 루트 패키지의 MGOriginatedPendingLimit 및 MGCOriginatedPendingLimit 참조). 이 매개 변수는 (전송 된 트랜잭션 요청에 대해) 수신 할 수있는 보류중인 메시지 수를 지정합니다. 한도를 초과하면 트랜잭션이 손실 된 것으로 간주되고 콜백 함수 &lt;strong&gt;handle_trans_reply를&lt;/strong&gt; 통해 사용자에게 오류가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d5ecbcb08d0f4d6115bb32ff52731dfbd7a7c13" translate="yes" xml:space="preserve">
          <source>Received &lt;code&gt;Packet&lt;/code&gt; is delivered as a binary.</source>
          <target state="translated">수신 &lt;code&gt;Packet&lt;/code&gt; 은 바이너리로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fc2c4f32aaa7580a805013b8ff075ec71d5b9a" translate="yes" xml:space="preserve">
          <source>Received &lt;code&gt;Packet&lt;/code&gt; is delivered as a list.</source>
          <target state="translated">수신 된 &lt;code&gt;Packet&lt;/code&gt; 이 목록으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="095439cd3a95f819e845e63f1a8b1cf9a8ac21eb" translate="yes" xml:space="preserve">
          <source>Received &lt;code&gt;Packet&lt;/code&gt; is delivered as defined by &lt;code&gt;Mode&lt;/code&gt;.</source>
          <target state="translated">수신 &lt;code&gt;Packet&lt;/code&gt; 은 &lt;code&gt;Mode&lt;/code&gt; 에서 정의한대로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="11bdd920d9bb9ec7f1744e588b3249a3eb42f4bc" translate="yes" xml:space="preserve">
          <source>Receives a chunk of the remote file (&lt;code&gt;RemoteFile&lt;/code&gt; of &lt;code&gt;recv_chunk_start&lt;/code&gt;). The return values have the following meaning:</source>
          <target state="translated">원격 파일 청크를 수신합니다 ( &lt;code&gt;RemoteFile&lt;/code&gt; of &lt;code&gt;recv_chunk_start&lt;/code&gt; ). 반환 값의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de7f79d5297387bcfc0d13974523a5f34bf53062" translate="yes" xml:space="preserve">
          <source>Receives a message consisting of a sequence of bytes in the Erlang external format.</source>
          <target state="translated">Erlang 외부 형식의 일련의 바이트로 구성된 메시지를받습니다.</target>
        </trans-unit>
        <trans-unit id="79120148644e55cd552daccc123d05a76cb9f13a" translate="yes" xml:space="preserve">
          <source>Receives a message to the buffer in &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;ei_xreceive_msg&lt;/code&gt; allows the buffer in &lt;code&gt;x&lt;/code&gt; to grow, but &lt;code&gt;ei_receive_msg&lt;/code&gt; fails if the message is larger than the pre-allocated buffer in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 버퍼에 메시지를받습니다 . &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 버퍼가 커지도록 허용 하지만 메시지가 &lt;code&gt;x&lt;/code&gt; 의 사전 할당 된 버퍼보다 ​​큰 경우 &lt;code&gt;ei_receive_msg&lt;/code&gt; 는 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="88ade3e878d068456efb014fd72f2989e409bb39" translate="yes" xml:space="preserve">
          <source>Receives a packet from a socket in passive mode. A closed socket is indicated by return value &lt;code&gt;{error, closed}&lt;/code&gt;.</source>
          <target state="translated">수동 모드의 소켓에서 패킷을 수신합니다. 닫힌 소켓은 리턴 값 &lt;code&gt;{error, closed}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7ccc2574bf778a71ae7a9543f1b346cd8d49c7" translate="yes" xml:space="preserve">
          <source>Receives a packet from a socket in passive mode. Optional parameter &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">수동 모드의 소켓에서 패킷을 수신합니다. 선택적 매개 변수 &lt;code&gt;Timeout&lt;/code&gt; 은 시간 초과를 밀리 초로 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef7ad247f4d592c4f5c9dd57f0200426e983df3e" translate="yes" xml:space="preserve">
          <source>Receives expected data from server on the specified session channel.</source>
          <target state="translated">지정된 세션 채널의 서버에서 예상 데이터를받습니다.</target>
        </trans-unit>
        <trans-unit id="cec7dde1707a867ec3ac180b1d8faf20bd5a279e" translate="yes" xml:space="preserve">
          <source>Receives messages sent to the process using the send operator (!). The patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the first message in time order in the mailbox, then the second, and so on. If a match succeeds and the optional guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;Body&lt;/code&gt; is evaluated. The matching message is consumed, that is, removed from the mailbox, while any other messages in the mailbox remain unchanged.</source>
          <target state="translated">send 연산자 (!)를 사용하여 프로세스로 전송 된 메시지를받습니다. 패턴 &lt;code&gt;Pattern&lt;/code&gt; 은 메일 함의 시간 순서대로 첫 번째 메시지와 차례로 차례로 일치 한 다음 두 번째 메시지와 비교됩니다. 성공적으로 일치하고 선택적인 가드 시퀀스 &lt;code&gt;GuardSeq&lt;/code&gt; 가 true이면 해당 &lt;code&gt;Body&lt;/code&gt; 이 평가됩니다. 일치하는 메시지가 사용됩니다 (즉, 사서함에서 제거됨). 사서함의 다른 메시지는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cc1284ee604f9633073521a2db79d9f71aff293" translate="yes" xml:space="preserve">
          <source>Receives one packet of data.</source>
          <target state="translated">하나의 데이터 패킷을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="43e2b0fdb2b90c2ae0d79559c9136a0b0fbf1061" translate="yes" xml:space="preserve">
          <source>Receives the &lt;code&gt;Data&lt;/code&gt; message from any association of the socket. If the receive times out, &lt;code&gt;{error,timeout}&lt;/code&gt; is returned. The default time-out is &lt;code&gt;infinity&lt;/code&gt;. &lt;code&gt;FromIP&lt;/code&gt; and &lt;code&gt;FromPort&lt;/code&gt; indicate the address of the sender.</source>
          <target state="translated">소켓의 연관으로부터 &lt;code&gt;Data&lt;/code&gt; 메시지를 받습니다 . 수신 시간이 초과되면 &lt;code&gt;{error,timeout}&lt;/code&gt; 이 반환됩니다. 기본 시간 제한은 &lt;code&gt;infinity&lt;/code&gt; 입니다. &lt;code&gt;FromIP&lt;/code&gt; 및 &lt;code&gt;FromPort&lt;/code&gt; 는 발신자의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="31c3f1b8ef20a940b9e8eca2f6ff181ad7a8d16d" translate="yes" xml:space="preserve">
          <source>Receives the message into the specified buffer and decodes into &lt;code&gt;(ErlMessage *) emsg&lt;/code&gt;.</source>
          <target state="translated">지정된 버퍼에 메시지를 수신하고 &lt;code&gt;(ErlMessage *) emsg&lt;/code&gt; 로 디코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="6e89cb081d99ed724d5931544bc83550c03a78c4" translate="yes" xml:space="preserve">
          <source>Receiving Requests</source>
          <target state="translated">요청 받기</target>
        </trans-unit>
        <trans-unit id="077d735aed11e2e48a44668a13373797ed93e95f" translate="yes" xml:space="preserve">
          <source>Receiving process/port and message term</source>
          <target state="translated">수신 프로세스 / 포트 및 메시지 용어</target>
        </trans-unit>
        <trans-unit id="1019a13cb6e4b083bd8b40b2d7fb5371dc84bfe2" translate="yes" xml:space="preserve">
          <source>Receiving segmented messages:</source>
          <target state="translated">세그먼트 화 된 메시지 수신 :</target>
        </trans-unit>
        <trans-unit id="5754a8bb83120ef7d69ead91ce581426fad83335" translate="yes" xml:space="preserve">
          <source>Recognized request methods and header fields are returned as atoms. Others are returned as strings. Strings of unrecognized header fields are formatted with only capital letters first and after hyphen characters, for example, &lt;code&gt;&quot;Sec-Websocket-Key&quot;&lt;/code&gt;.</source>
          <target state="translated">인식 된 요청 메소드 및 헤더 필드는 원자로 리턴됩니다. 다른 것은 문자열로 반환됩니다. 인식 할 수없는 헤더 필드의 문자열은 대문자와 하이픈 문자 (예 : &lt;code&gt;&quot;Sec-Websocket-Key&quot;&lt;/code&gt; ) 뒤에 대문자로만 서식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="06210493d8afafd3fbe9c98e7aefe7e12c50cb5e" translate="yes" xml:space="preserve">
          <source>Recommendations:</source>
          <target state="translated">Recommendations:</target>
        </trans-unit>
        <trans-unit id="4e0d0a34940fd710c8e8528aed83c032f4775bdb" translate="yes" xml:space="preserve">
          <source>Recomposing a map of URI components into a URI string</source>
          <target state="translated">URI 구성 요소의 맵을 URI 문자열로 재구성</target>
        </trans-unit>
        <trans-unit id="ce83d6ed524fb80981aa317a9b2ad1f780cc5c35" translate="yes" xml:space="preserve">
          <source>Reconnection interval (time to wait in between reconnection attempts) = 5 seconds</source>
          <target state="translated">재 연결 간격 (재 연결 시도 사이에 대기 시간) = 5 초</target>
        </trans-unit>
        <trans-unit id="1fdeec60896b5fb2de70c54c0789290dbd55f5e0" translate="yes" xml:space="preserve">
          <source>Reconstitute a parsed dictionary, as returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt;, without using &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. That is, construct an equivalent dictionary in which all AVP's are definined in the dictionary itself. The return value is also a parsed dictionary.</source>
          <target state="translated">재구성을 파싱 사전 의해 반환 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 를 사용하지 않고, &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 를 . 즉, 모든 AVP가 사전 자체에서 정의되는 동등한 사전을 구성하십시오. 반환 값은 파싱 된 사전이기도합니다.</target>
        </trans-unit>
        <trans-unit id="1d4ca640183de7618d71ecdb2e23d9ce63837fd1" translate="yes" xml:space="preserve">
          <source>Record definitions are allowed anywhere in a module, also among the function declarations. Read more in &lt;code&gt;&lt;a href=&quot;records&quot;&gt;Records&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">레코드 정의는 함수 선언 중 모듈의 어느 곳에서나 허용됩니다. &lt;code&gt;&lt;a href=&quot;records&quot;&gt;Records&lt;/a&gt;&lt;/code&gt; 에서 더 많은 것을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="016cb45280daecda9b7b119fc9dace58154435ea" translate="yes" xml:space="preserve">
          <source>Record definitions for this module can be found using:</source>
          <target state="translated">이 모듈에 대한 레코드 정의는 다음을 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd9a03d9ebf3a3c8f7631f0aa5a3cf6db8bbced" translate="yes" xml:space="preserve">
          <source>Record expressions are translated to tuple expressions during compilation. A record defined as:</source>
          <target state="translated">레코드 표현식은 컴파일 중에 튜플 표현식으로 변환됩니다. 다음과 같이 정의 된 레코드 :</target>
        </trans-unit>
        <trans-unit id="7cb719be81341614e030a4a2e403c5ea98aca76f" translate="yes" xml:space="preserve">
          <source>Record names versus table names</source>
          <target state="translated">레코드 이름과 테이블 이름</target>
        </trans-unit>
        <trans-unit id="144612104dcd31483365025648e162a5188453ca" translate="yes" xml:space="preserve">
          <source>Records allow references to the fields by name, instead of by position. In the following example, a record instead of a tuple is used to store the data:</source>
          <target state="translated">레코드를 사용하면 위치 대신 이름으로 필드를 참조 할 수 있습니다. 다음 예제에서는 튜플 대신 레코드가 데이터를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="613bf96af83ed6c9b691f468cc1cafc02874076f" translate="yes" xml:space="preserve">
          <source>Records are extended to possibly contain type information. This is described in &lt;code&gt;&lt;a href=&quot;#typeinrecords&quot;&gt;Type Information in Record Declarations&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형 정보를 포함하도록 레코드가 확장되었습니다. 이에 대해서는 &lt;code&gt;&lt;a href=&quot;#typeinrecords&quot;&gt;Type Information in Record Declarations&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf99ef8454e1e901403d3747fabb549275497b0b" translate="yes" xml:space="preserve">
          <source>Records have possibly been deleted. &lt;code&gt;What&lt;/code&gt; is either &lt;code&gt;{Table, Key}&lt;/code&gt; or a record &lt;code&gt;{RecordName, Key, ...}&lt;/code&gt; that was deleted. Notice that the new content depends on the table type.</source>
          <target state="translated">레코드가 삭제되었을 수 있습니다. &lt;code&gt;What&lt;/code&gt; 입니다 중 &lt;code&gt;{Table, Key}&lt;/code&gt; 또는 기록 &lt;code&gt;{RecordName, Key, ...}&lt;/code&gt; 삭제되었습니다. 새 내용은 테이블 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9f89198d9e262f6073124ec6efc26bc57f43b091" translate="yes" xml:space="preserve">
          <source>Records in &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;bag&lt;/code&gt; tables are not ordered. However, there is an ordering of the records that is unknown to the user. A table can therefore be traversed by this function with the function &lt;code&gt;mnesia:next/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;bag&lt;/code&gt; 테이블의 레코드는 주문되지 않습니다. 그러나 사용자에게 알려지지 않은 레코드 순서가 있습니다. 따라서이 함수는 &lt;code&gt;mnesia:next/2&lt;/code&gt; 함수를 사용하여 테이블을 순회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59700296e24a1cf9794576dac5b155d8b10dbdb1" translate="yes" xml:space="preserve">
          <source>Records in &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;bag&lt;/code&gt; tables are not ordered. However, there is an ordering of the records that is unknown to the user. Therefore, a table can be traversed by this function with the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;bag&lt;/code&gt; 테이블의 레코드는 주문되지 않습니다. 그러나 사용자에게 알려지지 않은 레코드 순서가 있습니다. 따라서이 함수는 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 함수를 사용하여 테이블을 순회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d7ddf3a47ed2b29eb25eb18cb6fa66a868c9de" translate="yes" xml:space="preserve">
          <source>Records in &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;bag&lt;/code&gt; tables are not sorted. However, there is a record order that is unknown to the user. This means that a table can be traversed by this function with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;bag&lt;/code&gt; 테이블의 레코드는 정렬되지 않습니다. 그러나 사용자에게 알려지지 않은 레코드 순서가 있습니다. 이는이 함수가 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 테이블을 순회 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bb519de4fc078d24d538560c361925ce544f5dec" translate="yes" xml:space="preserve">
          <source>Recovery from communication failure</source>
          <target state="translated">통신 장애 복구</target>
        </trans-unit>
        <trans-unit id="c857be3a0573cdabebb7a961ed6d631e3f3733de" translate="yes" xml:space="preserve">
          <source>Recovery of transactions</source>
          <target state="translated">거래 복구</target>
        </trans-unit>
        <trans-unit id="b82d4c7650ef2416c470136be1d0e55fc283f2db" translate="yes" xml:space="preserve">
          <source>Recreates the file &lt;code&gt;mysystem.tar.gz&lt;/code&gt; from the directories in the directory &lt;code&gt;tmp&lt;/code&gt; and removes &lt;code&gt;tmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tmp&lt;/code&gt; 디렉토리의 디렉토리에서 &lt;code&gt;mysystem.tar.gz&lt;/code&gt; 파일을 다시 작성하고 tmp 를 제거 &lt;code&gt;tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0c24b60848ddc6e8e54f77a11b281c810436a9a" translate="yes" xml:space="preserve">
          <source>Recursion processing in PCRE differs from Perl in two important ways. In PCRE (like Python, but unlike Perl), a recursive subpattern call is always treated as an atomic group. That is, once it has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. This can be illustrated by the following pattern, which means to match a palindromic string containing an odd number of characters (for example, &quot;a&quot;, &quot;aba&quot;, &quot;abcba&quot;, &quot;abcdcba&quot;):</source>
          <target state="translated">PCRE의 재귀 처리는 두 가지 중요한 점에서 Perl과 다릅니다. PCRE (Python과 같지만 Perl과는 달리)에서 재귀 하위 패턴 호출은 항상 원자 그룹으로 처리됩니다. 즉, 일단 주제 문자열의 일부와 일치하면 시도되지 않은 대안이 포함되고 후속 일치 실패가 있어도 다시 입력되지 않습니다. 이는 홀수 개의 문자를 포함하는 회문 문자열 (예 : &quot;a&quot;, &quot;aba&quot;, &quot;abcba&quot;, &quot;abcdcba&quot;)을 일치시키는 다음 패턴으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c36f3bbb51240a32d3b51ef263546135b56e0d" translate="yes" xml:space="preserve">
          <source>Redefined and undefined functions</source>
          <target state="translated">재정의 및 정의되지 않은 함수</target>
        </trans-unit>
        <trans-unit id="9821e8e3eb5f0b3550eb425437d414bd5f509995" translate="yes" xml:space="preserve">
          <source>Redirect Agents</source>
          <target state="translated">리디렉트 에이전트</target>
        </trans-unit>
        <trans-unit id="cb2b5a6cb4c9d318ad4e5065d9f3485f316f8814" translate="yes" xml:space="preserve">
          <source>Redirect Erlang input and output streams on Unix systems.</source>
          <target state="translated">Unix 시스템에서 Erlang 입력 및 출력 스트림을 리디렉션하십시오.</target>
        </trans-unit>
        <trans-unit id="c502d3c9c5fc88582d123f9cda4001ffbea9a9f6" translate="yes" xml:space="preserve">
          <source>Redirect-Host AVP</source>
          <target state="translated">리디렉션 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="1e581fb68f4db03f158c73399e1aef520dcfaf98" translate="yes" xml:space="preserve">
          <source>Redirect-Host-Usage AVP</source>
          <target state="translated">리디렉션 호스트 사용 AVP</target>
        </trans-unit>
        <trans-unit id="a1446afc50214ae3e357fb0a71f59e2404d18c81" translate="yes" xml:space="preserve">
          <source>Redirect-Host-Usage AVP Values</source>
          <target state="translated">리디렉션 호스트 사용 AVP 값</target>
        </trans-unit>
        <trans-unit id="cd193b05a97a631073ccb483d47d26ea1dafe644" translate="yes" xml:space="preserve">
          <source>Redirect-Max-Cache-Time AVP</source>
          <target state="translated">리디렉션 최대 캐시 시간 AVP</target>
        </trans-unit>
        <trans-unit id="7dc43d4ac811f4906c7b139115075f47a12d9c79" translate="yes" xml:space="preserve">
          <source>Redirecting Requests</source>
          <target state="translated">요청 리디렉션</target>
        </trans-unit>
        <trans-unit id="98d90033419f07be437a04bf22d4b03540b1022d" translate="yes" xml:space="preserve">
          <source>Redirects all report output from the RB tool to the specified file, registered name, or &lt;code&gt;io_device&lt;/code&gt;.</source>
          <target state="translated">RB 도구의 모든 보고서 출력을 지정된 파일, 등록 된 이름 또는 &lt;code&gt;io_device&lt;/code&gt; 로 리디렉션 합니다.</target>
        </trans-unit>
        <trans-unit id="d20e63f8c7e8894f58f191215bb077b8a93d30c2" translate="yes" xml:space="preserve">
          <source>Redraw line</source>
          <target state="translated">라인 다시 그리기</target>
        </trans-unit>
        <trans-unit id="e6d86c37ebe8a894ce36d13e14a286c242f0c262" translate="yes" xml:space="preserve">
          <source>Redundant directory separators are removed.</source>
          <target state="translated">중복 디렉토리 구분 기호가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="e227dfcf432b828dab887b3933a18c3b63d3ed41" translate="yes" xml:space="preserve">
          <source>Ref is the value that was returned from the call to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; that has lead to starting of a transport process.</source>
          <target state="translated">Ref는 전송 프로세스를 시작하게하는 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 대한 호출에서 리턴 된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1c0d648927926fa5ea5d04766e8a678e8fc58490" translate="yes" xml:space="preserve">
          <source>Refc binaries consist of two parts:</source>
          <target state="translated">Refc 바이너리는 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d231e7267d9cb6cb23fcfa03c8ac87df69935c7e" translate="yes" xml:space="preserve">
          <source>Refer also to the chapter(s) &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Definition of Agent Configuration Files&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files&quot;&gt;Definition of Manager Configuration Files&lt;/a&gt;&lt;/code&gt; which contains more detailed information about the agent and manager configuration files.</source>
          <target state="translated">장 (들)를 참조하여주십시오 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Definition of Agent Configuration Files&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files&quot;&gt;Definition of Manager Configuration Files&lt;/a&gt;&lt;/code&gt; 에이전트와 관리 프로그램 구성 파일에 대한 자세한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2222f6b50ec8d89285956cc68d86c2224b726ef7" translate="yes" xml:space="preserve">
          <source>Refer to &lt;code&gt;rt_mask/2&lt;/code&gt; for a list of valid categories. All categories are enabled by default.</source>
          <target state="translated">유효한 카테고리 목록은 &lt;code&gt;rt_mask/2&lt;/code&gt; 를 참조하십시오 . 모든 카테고리는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ffdd2bd542a285efd2de4779f5b373c9466faf0" translate="yes" xml:space="preserve">
          <source>Refer to the Mnesia User's Guide for information on how to declare a Mnesia table as an SNMP table.</source>
          <target state="translated">Mnesia 테이블을 SNMP 테이블로 선언하는 방법에 대한 정보는 Mnesia 사용자 안내서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f0e653ef4f1da220b6cd05bc836f3690e633c668" translate="yes" xml:space="preserve">
          <source>Refer to the chapter &lt;code&gt;&lt;a href=&quot;snmp_advanced_agent&quot;&gt;Advanced Agent Topics&lt;/a&gt;&lt;/code&gt; in this User's Guide for more information about these topics.</source>
          <target state="translated">이러한 주제에 대한 자세한 정보는이 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;snmp_advanced_agent&quot;&gt;Advanced Agent Topics&lt;/a&gt;&lt;/code&gt; 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e379ff749b13f33a9df504f29d8f8b458d827d7" translate="yes" xml:space="preserve">
          <source>Refer to the following documentation for more information about &lt;code&gt;Event Tracer (ET)&lt;/code&gt; and about the Erlang/OTP development system:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 및 Erlang / OTP 개발 시스템에 대한 자세한 정보는 다음 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f539ecbb66f8ec24d2e6f1646377a431c040604d" translate="yes" xml:space="preserve">
          <source>Refer to the following documentation for more information about Megaco/H.248 and about the Erlang/OTP development system:</source>
          <target state="translated">Megaco / H.248 및 Erlang / OTP 개발 시스템에 대한 자세한 내용은 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e44a86d89e003984ea5ef73cfad4e5d309a9ade7" translate="yes" xml:space="preserve">
          <source>Refer to the following documentation for more information about Reltool and about the Erlang/OTP development system:</source>
          <target state="translated">Reltool 및 Erlang / OTP 개발 시스템에 대한 자세한 내용은 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ebdb38c8d53695f9ea0d66e56f5fddcaa30ef1c" translate="yes" xml:space="preserve">
          <source>Refer to the following documentation for more information about SNMP and about the Erlang/OTP development system:</source>
          <target state="translated">SNMP 및 Erlang / OTP 개발 시스템에 대한 자세한 내용은 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="e0dc153ae2bdd0fe9582cae3b3c29c7ba9a0ae63" translate="yes" xml:space="preserve">
          <source>Reference IDs</source>
          <target state="translated">참조 ID</target>
        </trans-unit>
        <trans-unit id="27c7472e340ed21263acad4148dc337d9d6c12a1" translate="yes" xml:space="preserve">
          <source>Reference Identifier</source>
          <target state="translated">참조 식별자</target>
        </trans-unit>
        <trans-unit id="713c0142116eaba09081a317268f9ee98220982c" translate="yes" xml:space="preserve">
          <source>Reference returned by &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; that identifies the configuration.</source>
          <target state="translated">구성을 식별하는 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 참조</target>
        </trans-unit>
        <trans-unit id="9c5d563f657af29bb1ef8ba94dfb428a73fff530" translate="yes" xml:space="preserve">
          <source>Reference to the &lt;code&gt;ssh&lt;/code&gt; connection as returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">받는 사람 기준 &lt;code&gt;ssh&lt;/code&gt; 에 의해 반환 연결 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21c316b9ea2c08e8a30d1111d9a15dea4523351d" translate="yes" xml:space="preserve">
          <source>Referenced modules are now parsed when the compiler finds an entity that is imported. No code is generated for the referenced module. However, the compiled modules rely on that the referenced modules are also compiled.</source>
          <target state="translated">컴파일러가 가져온 엔티티를 찾으면 참조 된 모듈이 구문 분석됩니다. 참조 된 모듈에 대한 코드가 생성되지 않습니다. 그러나 컴파일 된 모듈은 참조 된 모듈도 컴파일되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="5dfbb32d4eeb2b41a35cac6863870075ee04f983" translate="yes" xml:space="preserve">
          <source>References.</source>
          <target state="translated">References.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="7a7812481d7d8a559db48b96be55b5b061c0f69c" translate="yes" xml:space="preserve">
          <source>Refers to the atom with &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 를 사용하여 아톰을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="36717b8ae4c9e2f35cbb35a6b8557e62f3195790" translate="yes" xml:space="preserve">
          <source>Refreshes the top-level HTML index files.</source>
          <target state="translated">최상위 HTML 색인 파일을 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="94ce43532e416f84ee6391e5a1ef349f36f00a42" translate="yes" xml:space="preserve">
          <source>RegArity ::= RegString | Number | &lt;code&gt;_&lt;/code&gt; | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">RegArity :: = RegString | 번호 | &lt;code&gt;_&lt;/code&gt; | &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3acf35ba403cbdbfa0631a0b0f04b366e0b454d8" translate="yes" xml:space="preserve">
          <source>RegAtom ::= RegString | Atom | &lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">RegAtom :: = RegString | 원자 | &lt;code&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41639ede4e105dbe6f8a9955f29465cf6b7d6c32" translate="yes" xml:space="preserve">
          <source>RegExpr ::= RegString &lt;code&gt;:&lt;/code&gt; Type | RegFunc | RegFunc &lt;code&gt;:&lt;/code&gt; Type</source>
          <target state="translated">RegExpr :: = RegString &lt;code&gt;:&lt;/code&gt; 유형 | RegFunc | RegFunc &lt;code&gt;:&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="930b67b59794ec947de2a9f2994493cadd99fca4" translate="yes" xml:space="preserve">
          <source>RegFunc ::= RegModule &lt;code&gt;:&lt;/code&gt; RegFunction &lt;code&gt;/&lt;/code&gt; RegArity</source>
          <target state="translated">RegFunc :: = RegModule &lt;code&gt;:&lt;/code&gt; RegFunction &lt;code&gt;/&lt;/code&gt; RegArity</target>
        </trans-unit>
        <trans-unit id="134c93f0cffad65e559068d0d1b231a309a6fdfe" translate="yes" xml:space="preserve">
          <source>RegFunction ::= RegAtom</source>
          <target state="translated">RegFunction :: = RegAtom</target>
        </trans-unit>
        <trans-unit id="7def8fd36ca99187f55e24c50241ef969bcc1d09" translate="yes" xml:space="preserve">
          <source>RegModule ::= RegAtom</source>
          <target state="translated">RegModule :: = RegAtom</target>
        </trans-unit>
        <trans-unit id="5ea313547c0f2b26b1f18ea46a73a7c74fcbe229" translate="yes" xml:space="preserve">
          <source>RegString ::= - a regular expression, as described in the &lt;code&gt;re&lt;/code&gt; module, enclosed in double quotes -</source>
          <target state="translated">RegString :: =- 큰 따옴표로 묶인 &lt;code&gt;re&lt;/code&gt; 모듈에 설명 된 정규식 -</target>
        </trans-unit>
        <trans-unit id="0469fbf0d49c6eb360a825665c9fd2a213e391df" translate="yes" xml:space="preserve">
          <source>Regarding filename encoding, the Erlang VM can operate in two modes. The current mode can be queried using function &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding/0&lt;/a&gt;&lt;/code&gt;. It returns &lt;code&gt;latin1&lt;/code&gt; or &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">파일 이름 인코딩과 관련하여 Erlang VM은 두 가지 모드로 작동 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding/0&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 현재 모드를 쿼리 할 수 ​​있습니다 . &lt;code&gt;latin1&lt;/code&gt; 또는 &lt;code&gt;utf8&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fa909bfc847f3f2dab8d9422d9641563e62929f7" translate="yes" xml:space="preserve">
          <source>Regardless of locking scheme used, calls to driver callbacks can be made from different threads.</source>
          <target state="translated">사용 된 잠금 체계에 관계없이 드라이버 콜백에 대한 호출은 다른 스레드에서 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fda3f1d7a876f76d3fabdf3fae0856aadda52fb" translate="yes" xml:space="preserve">
          <source>Register an alternate input handler process for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt;. Once this function has been called, &lt;code&gt;InputHandler&lt;/code&gt; is the only process allowed to call &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_put_data-2&quot;&gt;erlang:dist_ctrl_put_data(DHandle, Data)&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;DHandle&lt;/code&gt; identifing this distribution channel.</source>
          <target state="translated">&lt;code&gt;DHandle&lt;/code&gt; 로 식별 된 분배 채널에 대한 대체 입력 핸들러 프로세스를 등록 하십시오 . 이 함수가 호출되면 &lt;code&gt;InputHandler&lt;/code&gt; 는 이 분배 채널을 식별 하는 &lt;code&gt;DHandle&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_put_data-2&quot;&gt;erlang:dist_ctrl_put_data(DHandle, Data)&lt;/a&gt;&lt;/code&gt; 를 호출 할 수있는 유일한 프로세스 입니다.</target>
        </trans-unit>
        <trans-unit id="612e70bc80f39d67fe2e63fcdd740554f873caa3" translate="yes" xml:space="preserve">
          <source>Register the given node name with the registrar.</source>
          <target state="translated">지정된 노드 이름을 레지스트라에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="ccd3f2e94ffa6a327eccda4637f3834b6ee954d5" translate="yes" xml:space="preserve">
          <source>Register the manager entity (=user) responsible for specific agent(s).</source>
          <target state="translated">특정 에이전트를 담당하는 관리자 엔티티 (= 사용자)를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="6cc246aaee03583a1b67072b099abeb8fb79e782" translate="yes" xml:space="preserve">
          <source>Register the monitored manager entity (=user) responsible for specific agent(s).</source>
          <target state="translated">특정 에이전트를 담당하는 모니터링되는 관리자 엔티티 (= 사용자)를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="9061d41e371d4fedc0115d522b3c3789e7d55102" translate="yes" xml:space="preserve">
          <source>Register the subagent, process, handling part of the mib-tree.</source>
          <target state="translated">밉 트리의 일부를 처리하는 서브 에이전트, 프로세스를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="cfb9ebfdaecff168ceeaf8ecaef604259474208a" translate="yes" xml:space="preserve">
          <source>Register the user(s).</source>
          <target state="translated">사용자를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="1845a68e796020a1048d95263bf795b90fc9c9e6" translate="yes" xml:space="preserve">
          <source>Registers a name in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 에 이름을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="34b7a3701f7f578b66d40dc493d201623ead9205" translate="yes" xml:space="preserve">
          <source>Registers a notification filter.</source>
          <target state="translated">알림 필터를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="067b57c37c89870a838e4c3a029c8848eae5cb13" translate="yes" xml:space="preserve">
          <source>Registers a sub-agent under a sub-tree of another agent.</source>
          <target state="translated">다른 에이전트의 하위 트리 아래에 하위 에이전트를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="2179f43e0837bc4378d035e264feccd782f007ff" translate="yes" xml:space="preserve">
          <source>Registers an unary fun that is called if &lt;code&gt;beam_lib&lt;/code&gt; must read an &lt;code&gt;debug_info&lt;/code&gt; chunk that has been encrypted. The fun is held in a process that is started by the function.</source>
          <target state="translated">경우 호출되는 단항 재미 등록 &lt;code&gt;beam_lib&lt;/code&gt; 가 읽을 수 있어야합니다 &lt;code&gt;debug_info&lt;/code&gt; 의 암호화 된 덩어리를. 재미는 기능에 의해 시작되는 프로세스에서 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0dcd7f686b516b64b10f7fd221bfb77639b2541f" translate="yes" xml:space="preserve">
          <source>Registers the manager entity (=user) responsible for specific agent(s). Corresponds to making an entry in &lt;code&gt;users.conf&lt;/code&gt;.</source>
          <target state="translated">특정 에이전트를 담당하는 관리자 엔티티 (= 사용자)를 등록합니다. &lt;code&gt;users.conf&lt;/code&gt; 에 항목을 작성하는 것에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="282f350423b62ae0006f17688a3e8604714b46e5" translate="yes" xml:space="preserve">
          <source>Registers the node with &lt;code&gt;epmd&lt;/code&gt; and tells epmd what port will be used for the current node. It returns a creation number. This number is incremented on each register to help with identifying if a node is reconnecting to epmd.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 에 노드를 등록하고 epmd 에게 현재 노드에 사용될 포트를 알려줍니다. 생성 번호를 반환합니다. 이 번호는 각 레지스터에서 증가하여 노드가 epmd에 다시 연결되는지 식별하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="74789ff4511238a502c97e8e4e6d4952c88a95ba" translate="yes" xml:space="preserve">
          <source>Registration of a callback module. When a file is to be transferred, its local filename is matched to the regular expressions of the registered callbacks. The first matching callback is used during the transfer. See &lt;code&gt;&lt;a href=&quot;#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈 등록 파일이 전송 될 때 로컬 파일 이름은 등록 된 콜백의 정규식과 일치합니다. 첫 번째 일치하는 콜백이 전송 중에 사용됩니다. &lt;code&gt;&lt;a href=&quot;#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="731691a0705f5aaf0542053dc6a66d67a7a10393" translate="yes" xml:space="preserve">
          <source>Registration of global names</source>
          <target state="translated">글로벌 이름 등록</target>
        </trans-unit>
        <trans-unit id="314870021208b673ff11034ad2c9468f72e2c31d" translate="yes" xml:space="preserve">
          <source>Regular expression matching all possible prompts for a specific target type. &lt;code&gt;regexp&lt;/code&gt; must not have any groups, that is, when matching, &lt;code&gt;re:run/3&lt;/code&gt; (in STDLIB) must return a list with one single element.</source>
          <target state="translated">특정 대상 유형에 대해 가능한 모든 프롬프트와 일치하는 정규식. &lt;code&gt;regexp&lt;/code&gt; 에는 그룹이 없어야합니다. 즉, 일치시 &lt;code&gt;re:run/3&lt;/code&gt; (STDLIB에서)는 하나의 단일 요소가있는 목록을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="47a56ab232ae123975ea9710e5fcf7b1f558f1c1" translate="yes" xml:space="preserve">
          <source>Regular expression matching functions for strings and binaries</source>
          <target state="translated">문자열 및 이진에 대한 정규식 일치 함수</target>
        </trans-unit>
        <trans-unit id="203fb6152721f63268ed61bd1c4ea54b026fd773" translate="yes" xml:space="preserve">
          <source>Regular startup options are described in section &lt;code&gt;&lt;a href=&quot;#daemon_flags&quot;&gt;Regular Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 시작 옵션은 &lt;code&gt;&lt;a href=&quot;#daemon_flags&quot;&gt;Regular Options&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f62c81988a0243c7eee0e36486de9a38c2c37387" translate="yes" xml:space="preserve">
          <source>Regulates how many &lt;code&gt;disc_copies&lt;/code&gt; replicas that each fragment is to have. This property can explicitly be set at table creation. Default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">각 조각에 포함 할 &lt;code&gt;disc_copies&lt;/code&gt; 복제본 수를 조정합니다 . 이 특성은 테이블 작성시 명시 적으로 설정할 수 있습니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30a8ba0420e7bdf4559176393019bd04c0fbe5e4" translate="yes" xml:space="preserve">
          <source>Regulates how many &lt;code&gt;disc_only_copies&lt;/code&gt; replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">각 조각에 포함 할 &lt;code&gt;disc_only_copies&lt;/code&gt; 복제본 수를 조정합니다 . 이 특성은 테이블 작성시 명시 적으로 설정할 수 있습니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5ace031434130fcf1ca2044f6c738d84c99c499" translate="yes" xml:space="preserve">
          <source>Regulates how many &lt;code&gt;ram_copies&lt;/code&gt; replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is &lt;code&gt;0&lt;/code&gt;, but if &lt;code&gt;n_disc_copies&lt;/code&gt; and &lt;code&gt;n_disc_only_copies&lt;/code&gt; also are &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;n_ram_copies&lt;/code&gt; defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">각 조각에 보유 할 &lt;code&gt;ram_copies&lt;/code&gt; 복제본 수를 조정합니다 . 이 특성은 테이블 작성시 명시 적으로 설정할 수 있습니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 이지만 &lt;code&gt;n_disc_copies&lt;/code&gt; 및 &lt;code&gt;n_disc_only_copies&lt;/code&gt; 도 &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;n_ram_copies&lt;/code&gt; 의 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13bed85e379f26741bf756020202c97a912d20f5" translate="yes" xml:space="preserve">
          <source>Rejang</source>
          <target state="translated">Rejang</target>
        </trans-unit>
        <trans-unit id="caa53feb7f3da187483d6f1241ee4328c1297f25" translate="yes" xml:space="preserve">
          <source>Related Documents</source>
          <target state="translated">관련된 문서</target>
        </trans-unit>
        <trans-unit id="a534f1b763c40f42ca56d5b3ac62f8426b11f10e" translate="yes" xml:space="preserve">
          <source>Relational operators: &amp;gt;, &amp;gt;=, &amp;lt;, =&amp;lt;, =:=, ==, =/=, /=</source>
          <target state="translated">관계 연산자 :&amp;gt;,&amp;gt; =, &amp;lt;, = &amp;lt;, = : =, ==, = / =, / =</target>
        </trans-unit>
        <trans-unit id="b4d1ac06f9ff5455701be2b5477a539436883381" translate="yes" xml:space="preserve">
          <source>Relations as defined above (as sets of ordered pairs) are from now on referred to as &lt;strong id=&quot;binary_relation&quot;&gt;binary relations&lt;/strong&gt;.</source>
          <target state="translated">위에서 정의 된 관계 (순서 쌍으로)는 이제부터 &lt;strong id=&quot;binary_relation&quot;&gt;이진 관계&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="84d2940af626b029fa2ef82659d4a2d4cd5ce382" translate="yes" xml:space="preserve">
          <source>Relative maximum cache bad fit (in percent). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than relative maximum cache bad fit percent of the requested size. Defaults to &lt;code&gt;20&lt;/code&gt;.</source>
          <target state="translated">상대적 최대 캐시 불량 (%) 메모리 세그먼트 캐시의 세그먼트는 크기가 요청 된 크기의 상대적 최대 캐시 불량 적합 백분율을 초과하여 요청 된 크기를 초과하면 재사용되지 않습니다. 기본값은 &lt;code&gt;20&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c153cc101fda20f14f84dfde0781fcad6804b45" translate="yes" xml:space="preserve">
          <source>Relative multiblock carrier move threshold (in percent). When a block located in a multiblock carrier is shrunk, the block is moved if the ratio of the size of the returned memory compared to the previous size is more than this threshold, otherwise the block is shrunk at the current location.</source>
          <target state="translated">상대 멀티 블록 캐리어 이동 임계 값 (백분율). 멀티 블록 캐리어에 위치한 블록이 축소 될 때, 이전 크기와 비교하여 반환 된 메모리의 크기의 비율이이 임계 값보다 크면 블록이 이동되고, 그렇지 않으면 현재 위치에서 블록이 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="79bd0bd84b449b2094f3b7b77828c840f0397c79" translate="yes" xml:space="preserve">
          <source>Relative singleblock carrier move threshold (in percent). When a block located in a singleblock carrier is shrunk to a size smaller than the value of parameter &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;, the block is left unchanged in the singleblock carrier if the ratio of unused memory is less than this threshold, otherwise it is moved into a multiblock carrier.</source>
          <target state="translated">상대 단일 블록 캐리어 이동 임계 값 (백분율). 단일 블록 캐리어에 위치한 블록이 매개 변수 &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; 값보다 작은 크기로 축소 되면 사용되지 않은 메모리의 비율이이 임계 값보다 작 으면 블록이 단일 블록 캐리어에서 변경되지 않은 채로 남아 있습니다. 그렇지 않으면 멀티 블록 캐리어로 이동됩니다 .</target>
        </trans-unit>
        <trans-unit id="71e2887d05759469568d7ab87cf6c068541efe99" translate="yes" xml:space="preserve">
          <source>Relative singleblock carrier shrink threshold (in percent). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the ratio of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_asbcst&quot;&gt;asbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상대 단일 블록 캐리어 축소 임계 값 (백분율). &lt;code&gt;mseg_alloc&lt;/code&gt; 단일 블록 캐리어 에 위치한 블록 이 축소 될 때, 사용되지 않은 메모리의 비율이이 임계 값보다 작 으면 캐리어는 변경되지 않은 채로 유지되고, 그렇지 않으면 캐리어가 축소됩니다. &lt;code&gt;&lt;a href=&quot;#M_asbcst&quot;&gt;asbcst&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a923017f941086cdc19675bb6e7e66bf98f618" translate="yes" xml:space="preserve">
          <source>Relaxed command checking can also be enabled by setting environment variable &lt;code&gt;ERL_EPMD_RELAXED_COMMAND_CHECK&lt;/code&gt; before starting &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">편안한 명령 검사는 설정 환경 변수로 사용할 수 있습니다 &lt;code&gt;ERL_EPMD_RELAXED_COMMAND_CHECK&lt;/code&gt; 시작하기 전에 &lt;code&gt;epmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f808de3af1211921e144126704f0ebe1a620f6" translate="yes" xml:space="preserve">
          <source>Relay Agents</source>
          <target state="translated">릴레이 에이전트</target>
        </trans-unit>
        <trans-unit id="2434cb2c3792d5ccccc15c76f01d0a9de58fc0fe" translate="yes" xml:space="preserve">
          <source>Relaying and Proxying Answers</source>
          <target state="translated">릴레이 및 프록시 답변</target>
        </trans-unit>
        <trans-unit id="e4472f3c80aefb8e7db82dc13af52546d928899f" translate="yes" xml:space="preserve">
          <source>Relaying and Proxying Requests</source>
          <target state="translated">릴레이 및 프록시 요청</target>
        </trans-unit>
        <trans-unit id="b25d7bda466685a6a4e753a794a4ba838c55e906" translate="yes" xml:space="preserve">
          <source>Release ::= Atom</source>
          <target state="translated">출시 :: = 원자</target>
        </trans-unit>
        <trans-unit id="d7bf8b26bb971b25e39e96502911b730591e9714" translate="yes" xml:space="preserve">
          <source>Release Edges. All release calls.</source>
          <target state="translated">릴리스 엣지. 모든 릴리스 통화.</target>
        </trans-unit>
        <trans-unit id="12b5679ebc6469749dadfd2078344f69e5ead4b1" translate="yes" xml:space="preserve">
          <source>Release candidates have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix. The suffix &lt;code&gt;-rc0&lt;/code&gt; is used during development up to the first release candidate.</source>
          <target state="translated">릴리스 후보에는 &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; 접미사가 있습니다. 접미사 &lt;code&gt;-rc0&lt;/code&gt; 은 개발 중에 첫 번째 릴리스 후보까지 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d77b5c204252acaaec43d623048d2075abad904a" translate="yes" xml:space="preserve">
          <source>Release handling</source>
          <target state="translated">릴리스 처리</target>
        </trans-unit>
        <trans-unit id="076bab209366a52c80009dd116377b92396f787e" translate="yes" xml:space="preserve">
          <source>Release handling relies on this assumption. When installing a new release version, the new &lt;code&gt;sys.config&lt;/code&gt; is read and used to update the application configurations.</source>
          <target state="translated">릴리스 처리는이 가정에 의존합니다. 새 릴리스 버전을 설치할 때 새 &lt;code&gt;sys.config&lt;/code&gt; 를 읽고 응용 프로그램 구성을 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7949ab7905efd94b32946cabca1a8a77f563a091" translate="yes" xml:space="preserve">
          <source>Release name.</source>
          <target state="translated">출시 이름.</target>
        </trans-unit>
        <trans-unit id="3ccc1e080be82cc836d31609c3948421780b08c1" translate="yes" xml:space="preserve">
          <source>Release resource file</source>
          <target state="translated">자원 파일 해제</target>
        </trans-unit>
        <trans-unit id="d34f3018803f4c680fc3638d635bd0def6f5ab72" translate="yes" xml:space="preserve">
          <source>Release specific configuration. Each release maps to a &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt; and &lt;code&gt;boot&lt;/code&gt; file. See the module &lt;code&gt;systools&lt;/code&gt; for more info about the details. Each release has a name, a version and a set of applications with a few release specific parameters such as type and included applications.</source>
          <target state="translated">특정 구성을 해제하십시오. 각 릴리스는 &lt;code&gt;rel&lt;/code&gt; , &lt;code&gt;script&lt;/code&gt; 및 &lt;code&gt;boot&lt;/code&gt; 파일에 매핑 됩니다. 세부 사항에 대한 자세한 정보는 &lt;code&gt;systools&lt;/code&gt; 모듈을 참조 하십시오. 각 릴리스에는 유형 및 포함 된 응용 프로그램과 같은 릴리스 특정 매개 변수가있는 이름, 버전 및 응용 프로그램 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c97862a62c2fa6a793cf11c297f8d6b788b549" translate="yes" xml:space="preserve">
          <source>Release upgrade file</source>
          <target state="translated">릴리스 업그레이드 파일</target>
        </trans-unit>
        <trans-unit id="0fe65a88b4e14f014e0b3c78603bddcf72898de3" translate="yes" xml:space="preserve">
          <source>Release upgrade instructions are interpreted by the release handler when an upgrade or downgrade is made. For more information about release handling, see &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">릴리스 업그레이드 지침은 업그레이드 또는 다운 그레이드가 수행 될 때 릴리스 핸들러에서 해석됩니다. 릴리스 처리에 대한 자세한 내용은 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;OTP Design Principles&lt;/code&gt; 을 참조하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369560c15d5e85e475c6b562995f9fcd49fd567b" translate="yes" xml:space="preserve">
          <source>Release version.</source>
          <target state="translated">출시 버전.</target>
        </trans-unit>
        <trans-unit id="8fa41d59c259d95cfaded10953d5a2f8e0b38bb4" translate="yes" xml:space="preserve">
          <source>Releases</source>
          <target state="translated">Releases</target>
        </trans-unit>
        <trans-unit id="dfeb990703a2c588b44af2cd26546ad311c6ab1a" translate="yes" xml:space="preserve">
          <source>Releases a binary obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 에서 얻은 바이너리를 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="4e281e0f826facd98ecceebe9523eb2ae766b4f8" translate="yes" xml:space="preserve">
          <source>Releases up to and including Erlang/OTP R10 did not check if the process was already registered. The global name table could therefore become inconsistent. The old (buggy) behavior can be chosen by giving the Kernel application variable &lt;code&gt;global_multi_name_action&lt;/code&gt; the value &lt;code&gt;allow&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP R10까지의 릴리스는 프로세스가 이미 등록되어 있는지 확인하지 않았습니다. 따라서 전역 이름 테이블이 일치하지 않을 수 있습니다. 커널 응용 프로그램 변수 &lt;code&gt;global_multi_name_action&lt;/code&gt; 에 &lt;code&gt;allow&lt;/code&gt; 값을 지정 하여 이전 (버기) 동작을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c581dab1907a3bfee043dac2fd31f1599d1e2e43" translate="yes" xml:space="preserve">
          <source>Releases.</source>
          <target state="translated">Releases.</target>
        </trans-unit>
        <trans-unit id="3e5adc00a3e13272f013a6c83b211713760aa4e1" translate="yes" xml:space="preserve">
          <source>Relevant manual pages are the following:</source>
          <target state="translated">관련 매뉴얼 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df0b3f17846bac2fbdbfa13c6c4f8a9a09ca29d" translate="yes" xml:space="preserve">
          <source>Reload the configuration without restarting the server:</source>
          <target state="translated">서버를 다시 시작하지 않고 구성을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="892b893ae67558c733d183c0cf9bfa2f667f6b56" translate="yes" xml:space="preserve">
          <source>Reloads all currently loaded modules that have changed on disk (see &lt;code&gt;mm()&lt;/code&gt;). Returns the list of results from calling &lt;code&gt;l(M)&lt;/code&gt; for each such &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">디스크에서 변경된 모든 현재로드 된 모듈을 다시로드합니다 ( &lt;code&gt;mm()&lt;/code&gt; 참조 ). 그러한 각 &lt;code&gt;M&lt;/code&gt; 에 대해 &lt;code&gt;l(M)&lt;/code&gt; 을 호출 한 결과 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a88146e081b7ea26a305d5560641eb3b9b496437" translate="yes" xml:space="preserve">
          <source>Reloads configuration file containing specified configuration key.</source>
          <target state="translated">지정된 구성 키가 포함 된 구성 파일을 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="5d2d1ade4f750a24b8183ab33233fd81e8d4a1d7" translate="yes" xml:space="preserve">
          <source>Reloads the HTTP server configuration without restarting the server. Incoming requests are answered with a temporary down message during the reload time.</source>
          <target state="translated">서버를 다시 시작하지 않고 HTTP 서버 구성을 다시로드합니다. 다시로드하는 동안 들어오는 요청에 임시 다운 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c84319814d8e6fe83a0c1b622bebb2f8ee15395e" translate="yes" xml:space="preserve">
          <source>Reloads the driver named &lt;code&gt;Name&lt;/code&gt; from a possibly different &lt;code&gt;Path&lt;/code&gt; than previously used. This function is used in the code change &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; described in the introduction.</source>
          <target state="translated">이전에 사용한 것과 다른 &lt;code&gt;Path&lt;/code&gt; 에서 &lt;code&gt;Name&lt;/code&gt; 이라는 이름 의 드라이버를 다시로드합니다 . 이 기능은 소개에서 설명한 코드 변경 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="784e31d4f3c0cba2e7db35d731e55aca1c1fad9d" translate="yes" xml:space="preserve">
          <source>Reltool is a release management tool. It analyses a given Erlang/OTP installation and determines various dependencies between applications. The &lt;code&gt;graphical&lt;/code&gt; frontend depicts the dependencies and enables interactive customization of a target system. The backend provides a &lt;code&gt;batch&lt;/code&gt; interface for generation of customized target systems.</source>
          <target state="translated">Reltool은 릴리스 관리 도구입니다. 지정된 Erlang / OTP 설치를 분석하고 응용 프로그램 간의 다양한 종속성을 판별합니다. &lt;code&gt;graphical&lt;/code&gt; 프론트 엔드는 종속성을 묘사하고 대상 시스템의 상호 작용하는 사용자 정의 할 수 있습니다. 백엔드는 사용자 정의 된 대상 시스템 생성을위한 &lt;code&gt;batch&lt;/code&gt; 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="7f2e3fa39fb833cfad927a914aaf178d914c55ed" translate="yes" xml:space="preserve">
          <source>Remaining options are any accepted by &lt;code&gt;gen_sctp:open/1&lt;/code&gt;, with the exception of options &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sctp_events&lt;/code&gt;. Note that options &lt;code&gt;ip&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; specify the local address and port respectively.</source>
          <target state="translated">옵션 &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;active&lt;/code&gt; 및 &lt;code&gt;sctp_events&lt;/code&gt; 를 제외한 나머지 옵션은 &lt;code&gt;gen_sctp:open/1&lt;/code&gt; 에서 허용됩니다 . &lt;code&gt;ip&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 옵션 은 각각 로컬 주소와 포트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="815293be363db289b37d927caa1f5d8eea88f49b" translate="yes" xml:space="preserve">
          <source>Remaining options are any accepted by &lt;code&gt;ssl:connect/3&lt;/code&gt; or &lt;code&gt;gen_tcp:connect/3&lt;/code&gt; for a connecting transport, or &lt;code&gt;ssl:listen/2&lt;/code&gt; or &lt;code&gt;gen_tcp:listen/2&lt;/code&gt; for a listening transport, depending on whether or not &lt;code&gt;{ssl_options, true}&lt;/code&gt; has been specified. Options &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;packet&lt;/code&gt; and &lt;code&gt;active&lt;/code&gt; cannot be specified. Also, option &lt;code&gt;port&lt;/code&gt; can be specified for a listening transport to specify the local listening port, the default being the standardized 3868. Note that the option &lt;code&gt;ip&lt;/code&gt; specifies the local address.</source>
          <target state="translated">나머지 옵션은 허용됩니다 &lt;code&gt;ssl:connect/3&lt;/code&gt; 또는 &lt;code&gt;gen_tcp:connect/3&lt;/code&gt; 연결 전송을 위해, 또는 &lt;code&gt;ssl:listen/2&lt;/code&gt; 또는 &lt;code&gt;gen_tcp:listen/2&lt;/code&gt; 여부에 따라 청취 전송을 위해 &lt;code&gt;{ssl_options, true}&lt;/code&gt; 이 지정되었습니다. &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;packet&lt;/code&gt; 및 &lt;code&gt;active&lt;/code&gt; 옵션을 지정할 수 없습니다. 또한 수신 전송에 옵션 &lt;code&gt;port&lt;/code&gt; 를 지정하여 로컬 수신 포트를 지정할 수 있습니다. 기본값은 표준 3868입니다. &lt;code&gt;ip&lt;/code&gt; 옵션 은 로컬 주소를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="66cf83c455fd1bd0a82aed4f3cb5675602a3ab47" translate="yes" xml:space="preserve">
          <source>Remember that file trace ports buffer the data by default. If the node crashes, trace messages are not flushed to the binary log. If the risk of failure is high, it can be a good idea to flush the buffers every now and then automatically. Passing &lt;code&gt;{flush, MSec}&lt;/code&gt; as an option of &lt;code&gt;ttb:tracer/2&lt;/code&gt; flushes all buffers every &lt;code&gt;MSec&lt;/code&gt; millisecond.</source>
          <target state="translated">파일 추적 포트는 기본적으로 데이터를 버퍼링합니다. 노드가 충돌하면 추적 메시지가 2 진 로그로 플러시되지 않습니다. 실패의 위험이 높으면 매번 버퍼를 플러시하고 자동으로 플러시하는 것이 좋습니다. &lt;code&gt;ttb:tracer/2&lt;/code&gt; 의 옵션으로 &lt;code&gt;{flush, MSec}&lt;/code&gt; 를 전달하면 매 &lt;code&gt;MSec&lt;/code&gt; 밀리 초 마다 모든 버퍼가 플러시됩니다 .</target>
        </trans-unit>
        <trans-unit id="26dfb878780f2523c83b1d853967893e8ff04168" translate="yes" xml:space="preserve">
          <source>Remember that the | operator can be used to get the head of a list:</source>
          <target state="translated">기억하십시오 | 연산자를 사용하여 목록의 헤드를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="389b0b7962fe40649a28790b524a030d6d8fe385" translate="yes" xml:space="preserve">
          <source>Remember that:</source>
          <target state="translated">기억:</target>
        </trans-unit>
        <trans-unit id="78a5feb713d2557dfe3eacd16a70807ff5ae0bd3" translate="yes" xml:space="preserve">
          <source>Remember to free &lt;code&gt;pid&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;erl_malloc#erl_free_term&quot;&gt;erl_malloc:erl_free_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나중에 &lt;code&gt;&lt;a href=&quot;erl_malloc#erl_free_term&quot;&gt;erl_malloc:erl_free_term&lt;/a&gt;&lt;/code&gt; 으로 &lt;code&gt;pid&lt;/code&gt; 를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eca0d691ee9c6774e0eb8b51cbe73481e15cdf17" translate="yes" xml:space="preserve">
          <source>Remote Procedure Call services.</source>
          <target state="translated">원격 프로 시저 호출 서비스.</target>
        </trans-unit>
        <trans-unit id="98ef7c5ca9880fe05d2a7209c1987cab4b52873f" translate="yes" xml:space="preserve">
          <source>Remote hostname.</source>
          <target state="translated">원격 호스트 이름</target>
        </trans-unit>
        <trans-unit id="bcfceb272c786094ee4dfb353770550b1fbd9c5f" translate="yes" xml:space="preserve">
          <source>Remote procedure calls</source>
          <target state="translated">원격 프로 시저 호출</target>
        </trans-unit>
        <trans-unit id="6c62ad2fef650defef629666029a983bdea55bce" translate="yes" xml:space="preserve">
          <source>Remote type, that is, type defined in, and exported by, other modules; more about this soon.</source>
          <target state="translated">원격 유형, 즉 다른 모듈에 정의되어 내보내는 유형. 이것에 대해 더 빨리.</target>
        </trans-unit>
        <trans-unit id="f3d2fdb2a1bafef3bfef448975f7ee50436cc38f" translate="yes" xml:space="preserve">
          <source>Remote.</source>
          <target state="translated">Remote.</target>
        </trans-unit>
        <trans-unit id="3a07d5691e90ca1626bc3af406339c26bbc92230" translate="yes" xml:space="preserve">
          <source>Remove (rm) one or more algorithms from &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 에서 하나 이상의 알고리즘을 제거하십시오 (rm) .</target>
        </trans-unit>
        <trans-unit id="a1b19b04489ffa84280a335fd561b33e3df1e32b" translate="yes" xml:space="preserve">
          <source>Remove all edges of &lt;code&gt;G&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#emanate&quot;&gt;emanating&lt;/a&gt;&lt;/code&gt; from v[i] and &lt;code&gt;&lt;a href=&quot;#incident&quot;&gt;incident&lt;/a&gt;&lt;/code&gt; to v[i+1] for 1 &amp;lt;= i &amp;lt; k (including multiple edges).</source>
          <target state="translated">v [i]에서 &lt;code&gt;&lt;a href=&quot;#emanate&quot;&gt;emanating&lt;/a&gt;&lt;/code&gt; &lt;code&gt;G&lt;/code&gt; 의 모든 모서리를 제거하고 1 &amp;lt;= i &amp;lt;k (여러 모서리 포함) 동안 v [i + 1]에 &lt;code&gt;&lt;a href=&quot;#incident&quot;&gt;incident&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="aa1bc0e635cc0c09da1d0e321cb9f66931a8a682" translate="yes" xml:space="preserve">
          <source>Remove call count breakpoints from the matching functions that has call count breakpoints.</source>
          <target state="translated">호출 횟수 중단 점이있는 일치하는 함수에서 호출 횟수 중단 점을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1c94e4f466ef58b151007050c8d81df3b4baf221" translate="yes" xml:space="preserve">
          <source>Remove module specific log settings. After this, the primary log level is used for all modules.</source>
          <target state="translated">모듈 별 로그 설정을 제거하십시오. 그런 다음 기본 로그 수준이 모든 모듈에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1752d32ef2409c2c524b1db337059b374545e2f1" translate="yes" xml:space="preserve">
          <source>Remove module specific log settings. After this, the primary log level is used for the specified modules.</source>
          <target state="translated">모듈 별 로그 설정을 제거하십시오. 그런 다음 기본 로그 수준이 지정된 모듈에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2de54fa41d973e8645ea65252a458390fa9b8e13" translate="yes" xml:space="preserve">
          <source>Remove previously added transports.</source>
          <target state="translated">이전에 추가 한 전송을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="de2212deaf408786494f5a6437f6c7dfb1de7a09" translate="yes" xml:space="preserve">
          <source>Remove the &lt;code&gt;'silent'&lt;/code&gt; trace flag when the first argument is &lt;code&gt;'verbose'&lt;/code&gt;, and add it when it is &lt;code&gt;'silent':&lt;/code&gt;</source>
          <target state="translated">첫 번째 인수가 &lt;code&gt;'verbose'&lt;/code&gt; 일 때 &lt;code&gt;'silent'&lt;/code&gt; 추적 플래그를 제거하고 'silent' 일 때 추가하십시오 &lt;code&gt;'silent':&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c1a0c637d49a4d7569668331ee1b3088eb73750" translate="yes" xml:space="preserve">
          <source>Remove the filter identified by &lt;code&gt;FilterId&lt;/code&gt; from the handler identified by &lt;code&gt;HandlerId&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HandlerId&lt;/code&gt; 로 식별 된 핸들러에서 &lt;code&gt;FilterId&lt;/code&gt; 로 식별 된 필터를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e2a9bd7f431a82ca58a25b840ca86d577fc69f6" translate="yes" xml:space="preserve">
          <source>Remove the handler identified by &lt;code&gt;HandlerId&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HandlerId&lt;/code&gt; 로 식별 된 핸들러를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="270d63a2d4e284cb38a67b35a61f4d1b10185100" translate="yes" xml:space="preserve">
          <source>Remove the old version.</source>
          <target state="translated">이전 버전을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bc432335254977c2eff9f225b9bfe4b9346eb9" translate="yes" xml:space="preserve">
          <source>Remove the primary filter identified by &lt;code&gt;FilterId&lt;/code&gt; from Logger.</source>
          <target state="translated">Logger에서 &lt;code&gt;FilterId&lt;/code&gt; 로 식별 된 기본 필터를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ab44531e296112b4f85de0885693c0cd1e921a5" translate="yes" xml:space="preserve">
          <source>Removes (one) &lt;code&gt;{_, MonitorRef, _, _, _}&lt;/code&gt; message, if there is one, from the caller message queue after monitoring has been stopped.</source>
          <target state="translated">&lt;code&gt;{_, MonitorRef, _, _, _}&lt;/code&gt; 메시지가있을 경우 모니터링이 중지 된 후 발신자 메시지 큐에서 메시지를 제거합니다 (하나) .</target>
        </trans-unit>
        <trans-unit id="2af136900a1f59bad5aae8293e0b480336d75d7b" translate="yes" xml:space="preserve">
          <source>Removes &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; from an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 제거 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9c0f67a25257aba96321b301fce1c1d0e01aea" translate="yes" xml:space="preserve">
          <source>Removes a driver entry &lt;code&gt;de&lt;/code&gt; previously added with &lt;code&gt;&lt;a href=&quot;#add_driver_entry&quot;&gt;add_driver_entry&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버 항목을 제거 &lt;code&gt;de&lt;/code&gt; 이전에 추가 &lt;code&gt;&lt;a href=&quot;#add_driver_entry&quot;&gt;add_driver_entry&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ef910fd5c7a07e6df5e2bcac95688a112adbf8b2" translate="yes" xml:space="preserve">
          <source>Removes a driver monitor in much the same way as &lt;code&gt;erlang:demonitor/1&lt;/code&gt; in ERTS does with process monitors. For details about how to create driver monitors, see &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS의 &lt;code&gt;erlang:demonitor/1&lt;/code&gt; 이 프로세스 모니터와 동일한 방식으로 드라이버 모니터를 제거합니다 . 드라이버 모니터를 작성하는 방법에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="469ccfe46e68680d711e0478f9486ba9db3e26c4" translate="yes" xml:space="preserve">
          <source>Removes a filename extension. &lt;code&gt;rootname/2&lt;/code&gt; works as &lt;code&gt;rootname/1&lt;/code&gt;, except that the extension is removed only if it is &lt;code&gt;Ext&lt;/code&gt;.</source>
          <target state="translated">파일 이름 확장자를 제거합니다. &lt;code&gt;rootname/2&lt;/code&gt; 는 확장자가 &lt;code&gt;Ext&lt;/code&gt; 인 경우에만 제거된다는 점을 제외하고 &lt;code&gt;rootname/1&lt;/code&gt; 로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cfdbbaeba26ada922495e3b365aa4160395c9fe4" translate="yes" xml:space="preserve">
          <source>Removes a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. The resource object is destructed when the last reference is removed. Each call to &lt;code&gt;enif_release_resource&lt;/code&gt; must correspond to a previous call to &lt;code&gt;enif_alloc_resource&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enif_keep_resource&quot;&gt;enif_keep_resource&lt;/a&gt;&lt;/code&gt;. References made by &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; can only be removed by the garbage collector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 에서 확보 한 자원 오브젝트 &lt;code&gt;obj&lt;/code&gt; 에 대한 참조를 제거합니다 . 마지막 참조가 제거되면 자원 객체가 소멸됩니다. &lt;code&gt;enif_release_resource&lt;/code&gt; 에 대한 각 호출은 &lt;code&gt;enif_alloc_resource&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enif_keep_resource&quot;&gt;enif_keep_resource&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출에 해당해야합니다 . &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 로 작성된 참조는 가비지 콜렉터에서만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f93eec43121b96bc7a270f3d88692f108331e875" translate="yes" xml:space="preserve">
          <source>Removes a release and its files from the system. The release must not be the permanent release. Removes only the files and directories not in use by another release.</source>
          <target state="translated">시스템에서 릴리스 및 해당 파일을 제거합니다. 릴리스는 영구 릴리스가 아니어야합니다. 다른 릴리스에서 사용하지 않는 파일 및 디렉토리 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="69722c4296c8491884f2e4d612c28fd292392777" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints.</source>
          <target state="translated">모든 중단 점을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ebf28b81a76f27b32b9e5da02e466fe49e99b342" translate="yes" xml:space="preserve">
          <source>Removes all chunks except those needed by the loader from BEAM files. In particular, the debug information (chunk &lt;code&gt;debug_info&lt;/code&gt; and &lt;code&gt;abstract_code&lt;/code&gt;) is removed. The returned list contains one element for each specified filename, in the same order as in &lt;code&gt;Files&lt;/code&gt;.</source>
          <target state="translated">BEAM 파일에서 로더에 필요한 것을 제외한 모든 청크를 제거합니다. 특히 디버그 정보 (chunk &lt;code&gt;debug_info&lt;/code&gt; 및 &lt;code&gt;abstract_code&lt;/code&gt; )가 제거됩니다. 반환 된리스트에는 &lt;code&gt;Files&lt;/code&gt; 와 같은 순서로 지정된 각 파일 이름에 대해 하나의 요소가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="69c09d3f76b01192e3e0cb5339b531159c96fb89" translate="yes" xml:space="preserve">
          <source>Removes all chunks except those needed by the loader from the BEAM files of a release. &lt;code&gt;Dir&lt;/code&gt; is to be the installation root directory. For example, the current OTP release can be stripped with the call &lt;code&gt;beam_lib:strip_release(code:root_dir())&lt;/code&gt;.</source>
          <target state="translated">릴리스의 BEAM 파일에서 로더에 필요한 것을 제외한 모든 청크를 제거합니다. &lt;code&gt;Dir&lt;/code&gt; 은 설치 루트 디렉토리입니다. 예를 들어, 현재 OTP 릴리스는 &lt;code&gt;beam_lib:strip_release(code:root_dir())&lt;/code&gt; 호출로 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b653de0025fa2e1c9e18ccdf6499bb91a5318e88" translate="yes" xml:space="preserve">
          <source>Removes all chunks from a BEAM file except those needed by the loader. In particular, the debug information (chunk &lt;code&gt;debug_info&lt;/code&gt; and &lt;code&gt;abstract_code&lt;/code&gt;) is removed.</source>
          <target state="translated">로더가 필요로하는 것을 제외한 BEAM 파일에서 모든 청크를 제거합니다. 특히 디버그 정보 (chunk &lt;code&gt;debug_info&lt;/code&gt; 및 &lt;code&gt;abstract_code&lt;/code&gt; )가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8e06a52291161535a71ec3cf6b4b53521525128d" translate="yes" xml:space="preserve">
          <source>Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</source>
          <target state="translated">구문 트리의 모든 노드에서 모든 주석을 제거합니다. 위치 정보와 같은 다른 모든 속성은 변경되지 않습니다. 양식 목록의 독립형 주석이 제거됩니다. 다른 독립형 주석은 텍스트가없고 들여 쓰기가없는 null 주석으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="2ba013b61f6c343926311bc6cb40098be1f76e8e" translate="yes" xml:space="preserve">
          <source>Removes all empty parts of the result.</source>
          <target state="translated">결과의 빈 부분을 모두 제거합니다.</target>
        </trans-unit>
        <trans-unit id="423a342bd4a5da772f2ac8a4ddc5c196849871b4" translate="yes" xml:space="preserve">
          <source>Removes all items from a disk log. If argument &lt;code&gt;Head&lt;/code&gt; or &lt;code&gt;BHead&lt;/code&gt; is specified, this item is written first in the newly truncated log, otherwise the header given to &lt;code&gt;open/1&lt;/code&gt; is used. The header argument is used only once. Next time a wrap log file is opened, the header given to &lt;code&gt;open/1&lt;/code&gt; is used.</source>
          <target state="translated">디스크 로그에서 모든 항목을 제거합니다. &lt;code&gt;Head&lt;/code&gt; 또는 &lt;code&gt;BHead&lt;/code&gt; 인수 가 지정되면이 항목은 새로 잘린 로그에 먼저 기록되고, 그렇지 않으면 &lt;code&gt;open/1&lt;/code&gt; 에 제공된 헤더 가 사용됩니다. 헤더 인수는 한 번만 사용됩니다. 다음에 랩 로그 파일을 &lt;code&gt;open/1&lt;/code&gt; 지정된 헤더 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9124834eeba59cb5d4394905a7f8431b79dc8304" translate="yes" xml:space="preserve">
          <source>Removes all objects marked for deletion. When objects are deleted with &lt;code&gt;ei_reg_delete()&lt;/code&gt; they are not removed from the registry, only marked for later removal. On a later backup to &lt;code&gt;Mnesia&lt;/code&gt;, the objects can also be removed from the &lt;code&gt;Mnesia&lt;/code&gt; table. If you are not backing up to &lt;code&gt;Mnesia&lt;/code&gt;, you may wish to remove the objects manually with this function.</source>
          <target state="translated">삭제 표시된 모든 개체를 제거합니다. &lt;code&gt;ei_reg_delete()&lt;/code&gt; 객체를 삭제 하면 레지스트리에서 제거되지 않고 나중에 제거 할 수 있도록 표시됩니다. 나중에 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 할 때 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에서 객체를 제거 할 수도 있습니다 . &lt;code&gt;Mnesia&lt;/code&gt; 에 백업하지 않는 경우이 기능을 사용하여 수동으로 개체를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="006c0542f30160a6d1b184407353efd9e067c6df" translate="yes" xml:space="preserve">
          <source>Removes all record definitions, then reads record definitions from the modules &lt;code&gt;shell_default&lt;/code&gt; and &lt;code&gt;user_default&lt;/code&gt; (if loaded). Returns the names of the records defined.</source>
          <target state="translated">모든 레코드 정의를 제거한 다음 &lt;code&gt;shell_default&lt;/code&gt; 및 &lt;code&gt;user_default&lt;/code&gt; (로드 된 경우) 모듈에서 레코드 정의를 읽습니다 . 정의 된 레코드의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c21f9615f09252f2d8d49897680a589dc928737" translate="yes" xml:space="preserve">
          <source>Removes all variable bindings.</source>
          <target state="translated">모든 변수 바인딩을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0a4c4b594d16c7a2ef5704cbf29a757883867569" translate="yes" xml:space="preserve">
          <source>Removes an installed debug function from the process. &lt;code&gt;Func&lt;/code&gt; or &lt;code&gt;FuncId&lt;/code&gt; must be the same as previously installed.</source>
          <target state="translated">프로세스에서 설치된 디버그 기능을 제거합니다. &lt;code&gt;Func&lt;/code&gt; 또는 &lt;code&gt;FuncId&lt;/code&gt; 는 이전에 설치된 것과 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="2df2ad072e68f52d7ebb2bd3a6411521ff839dae" translate="yes" xml:space="preserve">
          <source>Removes anything before &lt;code&gt;SearchPattern&lt;/code&gt; in &lt;code&gt;String&lt;/code&gt; and returns the remainder of the string or &lt;code&gt;nomatch&lt;/code&gt; if &lt;code&gt;SearchPattern&lt;/code&gt; is not found. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt; or &lt;code&gt;trailing&lt;/code&gt;, indicates from which direction characters are to be searched.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 에서 &lt;code&gt;SearchPattern&lt;/code&gt; 이전의 항목을 제거 하고 &lt;code&gt;SearchPattern&lt;/code&gt; 을 찾을 수없는 경우 나머지 문자열 또는 &lt;code&gt;nomatch&lt;/code&gt; 하지 않는 부분을 ​​반환합니다 . &lt;code&gt;leading&lt;/code&gt; 또는 &lt;code&gt;trailing&lt;/code&gt; 일 수있는 &lt;code&gt;Dir&lt;/code&gt; 은 검색 할 방향 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c0c5aecc0b610cae928d0362a36410e9e33385d9" translate="yes" xml:space="preserve">
          <source>Removes applications and their modules and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; from an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 에서 응용 프로그램 및 해당 모듈 및 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 제거 합니다 .</target>
        </trans-unit>
        <trans-unit id="d58329662a1a0da29049c8ec4fb23031b2a385a8" translate="yes" xml:space="preserve">
          <source>Removes cipher suites if any of the filter functions returns false for any part of the cipher suite. This function also calls default filter functions to make sure the cipher suites are supported by crypto. If no filter function is supplied for some part the default behaviour is fun(Algorithm) -&amp;gt; true.</source>
          <target state="translated">필터 스위트 중 하나가 암호화 스위트의 일부에 대해 false를 리턴하면 암호화 스위트를 제거합니다. 이 함수는 또한 기본 필터 기능을 호출하여 암호 제품군이 암호화에서 지원되는지 확인합니다. 일부에 대해 필터 기능이 제공되지 않으면 기본 동작은 fun (Algorithm)-&amp;gt; true입니다.</target>
        </trans-unit>
        <trans-unit id="6e0849ded45459bb75fc962a53bf83df2a5b5ba0" translate="yes" xml:space="preserve">
          <source>Removes configuration variables (together wih their aliases) that were loaded with specified callback module and configuration string.</source>
          <target state="translated">지정된 콜백 모듈 및 구성 문자열과 함께로드 된 구성 변수 (별명과 함께)를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="19a1a1f167a8dd46ef5ea9470ec88dd1d515a514" translate="yes" xml:space="preserve">
          <source>Removes directory &lt;code&gt;Dir&lt;/code&gt; at the remote server.</source>
          <target state="translated">원격 서버에서 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="02924e99f1092efed94b21cddc4567c00ed0797b" translate="yes" xml:space="preserve">
          <source>Removes nodes from the current cover test.</source>
          <target state="translated">현재 커버 테스트에서 노드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="cf8e7542d98d969ab5b6a2bc0c3d6d5e50905b7d" translate="yes" xml:space="preserve">
          <source>Removes old code for &lt;code&gt;Module&lt;/code&gt;. Before this BIF is used, &lt;code&gt;&lt;a href=&quot;#check_process_code-2&quot;&gt;check_process_code/2&lt;/a&gt;&lt;/code&gt;is to be called to check that no processes execute old code in the module.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 오래된 코드를 제거합니다 . 이 BIF를 사용하기 전에 모듈에서 오래된 코드를 실행하는 프로세스가 없는지 확인하기 위해 &lt;code&gt;&lt;a href=&quot;#check_process_code-2&quot;&gt;check_process_code/2&lt;/a&gt;&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="281c5754c557f40c25fc049eb32abf747c439426" translate="yes" xml:space="preserve">
          <source>Removes releases and their applications, modules and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; from an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 에서 릴리스 및 해당 응용 프로그램, 모듈 및 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 제거 합니다 .</target>
        </trans-unit>
        <trans-unit id="1494c23d99ae7a074da0f5767968b97ada72e430" translate="yes" xml:space="preserve">
          <source>Removes selected record definitions. &lt;code&gt;RecordNames&lt;/code&gt; is a record name or a list of record names. To remove all record definitions, use &lt;code&gt;'_'&lt;/code&gt;.</source>
          <target state="translated">선택된 레코드 정의를 제거합니다. &lt;code&gt;RecordNames&lt;/code&gt; 는 레코드 이름 또는 레코드 이름 목록입니다. 모든 레코드 정의를 제거하려면 &lt;code&gt;'_'&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="08aa69eb4dff9986ba433e51ea964d15b903f2db" translate="yes" xml:space="preserve">
          <source>Removes the &lt;code&gt;Key&lt;/code&gt;, if it exists, and its associated value from &lt;code&gt;Map1&lt;/code&gt; and returns a new map &lt;code&gt;Map2&lt;/code&gt; without key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">삭제 &lt;code&gt;Key&lt;/code&gt; 존재하는 경우,과에서 관련 값 &lt;code&gt;Map1&lt;/code&gt; 과 새로운 맵 반환 &lt;code&gt;Map2&lt;/code&gt; 에를 키없이 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93557a3a60b8e22b6a793259a6b192bb29de371b" translate="yes" xml:space="preserve">
          <source>Removes the binding of &lt;code&gt;Name&lt;/code&gt; in &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">&lt;code&gt;BindingStruct&lt;/code&gt; 에서 &lt;code&gt;Name&lt;/code&gt; 바인딩을 제거합니다 . 업데이트 된 바인딩 구조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="537e2f9fa77de9edf6444f921d6e10ab6626425c" translate="yes" xml:space="preserve">
          <source>Removes the binding of variable &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;X&lt;/code&gt; 의 바인딩을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2a70e4c1ab0cf5300dd607b66a1471f48013af8c" translate="yes" xml:space="preserve">
          <source>Removes the configuration parameter &lt;code&gt;Par&lt;/code&gt; and its value for &lt;code&gt;Application&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;Par&lt;/code&gt; 및 &lt;code&gt;Application&lt;/code&gt; 값을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2a7b9f71cdf502a6cbced36e46c5564bce6c50e1" translate="yes" xml:space="preserve">
          <source>Removes the current code for &lt;code&gt;Module&lt;/code&gt;, that is, the current code for &lt;code&gt;Module&lt;/code&gt; is made old. This means that processes can continue to execute the code in the module, but no external function calls can be made to it.</source>
          <target state="translated">현재 코드 제거 &lt;code&gt;Module&lt;/code&gt; , 현재 코드, &lt;code&gt;Module&lt;/code&gt; 오래된 구성되어 있습니다. 이는 프로세스가 모듈에서 코드를 계속 실행할 수 있지만 외부 함수 호출은 수행 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1f61ca04390382aeff5d670ab45ee550c4297632" translate="yes" xml:space="preserve">
          <source>Removes the globally registered name &lt;code&gt;Name&lt;/code&gt; from the network of Erlang nodes.</source>
          <target state="translated">Erlang 노드의 네트워크에서 전체적으로 등록 된 이름 &lt;code&gt;Name&lt;/code&gt; 을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="81e55227c7de5aa8064bff12851856ba47f63444" translate="yes" xml:space="preserve">
          <source>Removes the item at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns tuple &lt;code&gt;{{value, Item}, Q2}&lt;/code&gt;, where &lt;code&gt;Item&lt;/code&gt; is the item removed and &lt;code&gt;Q2&lt;/code&gt; is the resulting queue. If &lt;code&gt;Q1&lt;/code&gt; is empty, tuple &lt;code&gt;{empty, Q1}&lt;/code&gt; is returned.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 앞의 항목을 제거합니다 . 튜플 &lt;code&gt;{{value, Item}, Q2}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;Item&lt;/code&gt; 은 제거 된 항목이고 &lt;code&gt;Q2&lt;/code&gt; 는 결과 대기열입니다. 경우 &lt;code&gt;Q1&lt;/code&gt; 이 비어 튜플 &lt;code&gt;{empty, Q1}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8847d0032fa945206d3bb9ae3e11a876f1dfecc7" translate="yes" xml:space="preserve">
          <source>Removes the item at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns tuple &lt;code&gt;{{value, Item}, Q2}&lt;/code&gt;, where &lt;code&gt;Item&lt;/code&gt; is the item removed and &lt;code&gt;Q2&lt;/code&gt; is the new queue. If &lt;code&gt;Q1&lt;/code&gt; is empty, tuple &lt;code&gt;{empty, Q1}&lt;/code&gt; is returned.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 뒷면에있는 항목을 제거합니다 . 튜플 &lt;code&gt;{{value, Item}, Q2}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Item&lt;/code&gt; 은 제거 된 항목이고 &lt;code&gt;Q2&lt;/code&gt; 는 새 큐입니다. 경우 &lt;code&gt;Q1&lt;/code&gt; 이 비어 튜플 &lt;code&gt;{empty, Q1}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="571beed8fa2a0a28fac65d7bf77305b45836b63c" translate="yes" xml:space="preserve">
          <source>Removes the link, if there is one, between the calling process and the process or port referred to by &lt;code&gt;Id&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스와 &lt;code&gt;Id&lt;/code&gt; 가 참조하는 프로세스 또는 포트 사이에 링크가 있으면 링크를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="504de2ff2d5c71d2f018e6c02a78b16a7a10f573" translate="yes" xml:space="preserve">
          <source>Removes the node with key &lt;code&gt;Key&lt;/code&gt; from &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree, crashes otherwise.</source>
          <target state="translated">&lt;code&gt;Tree1&lt;/code&gt; 에서 &lt;code&gt;Key&lt;/code&gt; 키가있는 노드를 제거하고 새 트리를 반환합니다. 키가 트리에 있다고 가정하고 그렇지 않으면 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="70950e4f3c8e2c52528b10b76a754de546dbfc5e" translate="yes" xml:space="preserve">
          <source>Removes the node with key &lt;code&gt;Key&lt;/code&gt; from &lt;code&gt;Tree1&lt;/code&gt; if the key is present in the tree, otherwise does nothing. Returns the new tree.</source>
          <target state="translated">키를 사용하여 노드 제거 &lt;code&gt;Key&lt;/code&gt; 에서 &lt;code&gt;Tree1&lt;/code&gt; , 그렇지 않으면 아무것도하지 않는다, 키가 트리에있는 경우입니다. 새로운 트리를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="971ac232183d0065bf0bdfc8b8573c390073318f" translate="yes" xml:space="preserve">
          <source>Removes the possibility for SNMP to manipulate the table.</source>
          <target state="translated">SNMP가 테이블을 조작 할 가능성을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f6583a0dab178a2fb992ad59fefd4d81f7931c54" translate="yes" xml:space="preserve">
          <source>Removes the registered name &lt;code&gt;RegName&lt;/code&gt; associated with a process identifier or a port identifier, for example:</source>
          <target state="translated">프로세스 식별자 또는 포트 식별자와 관련된 등록 이름 &lt;code&gt;RegName&lt;/code&gt; 을 제거합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbc47bf2382d0f415e3aa194df6dfa16f631c639" translate="yes" xml:space="preserve">
          <source>Removes the service completely with all its registered options. It is stopped before it is removed.</source>
          <target state="translated">등록 된 모든 옵션으로 서비스를 완전히 제거합니다. 제거되기 전에 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="acc9c9c020f9d887226a9272cf21c3405519decf" translate="yes" xml:space="preserve">
          <source>Removes the subscription on events of type &lt;code&gt;Event-Category&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Event-Category&lt;/code&gt; 유형의 이벤트 에 대한 구독을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="cb76eef89426250953e573fa86236fe52b0f4297" translate="yes" xml:space="preserve">
          <source>Removes the validation callback call before heartbeats.</source>
          <target state="translated">하트 비트 전에 유효성 검사 콜백 호출을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1d9765a2dae7a6da7b34b4a4b327bad4140b2d58" translate="yes" xml:space="preserve">
          <source>Removes trailing empty parts of the result (as does &lt;code&gt;trim&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;re#split-3&quot;&gt;re:split/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;re#split-3&quot;&gt;re:split/3&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;trim&lt;/code&gt; 하는 것처럼 결과의 후행 빈 부분을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="dc704ae3bc04ac3e06137d6e6058582a4d180738" translate="yes" xml:space="preserve">
          <source>Removing a transport causes the corresponding transport processes to be terminated. Whether or not a DPR message is sent to a peer is controlled by value of &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; configured on the transport.</source>
          <target state="translated">전송을 제거하면 해당 전송 프로세스가 종료됩니다. DPR 메시지가 피어로 전송되는지 여부는 전송에 구성된 &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; 값으로 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="23711c5d370f461cdeb8d7a28cd3a7168c48b70d" translate="yes" xml:space="preserve">
          <source>Removing an application means that the application is stopped, the modules are unloaded using &lt;code&gt;delete_module&lt;/code&gt;, and then the application specification is unloaded from the application controller.</source>
          <target state="translated">응용 프로그램을 제거하면 응용 프로그램이 중지되고 &lt;code&gt;delete_module&lt;/code&gt; 을 사용하여 모듈이 언로드 된 다음 응용 프로그램 컨트롤러에서 응용 프로그램 사양이 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="2a257b8e79bb4eac48b669f49bbde3fc82db52ad" translate="yes" xml:space="preserve">
          <source>Removing an application means that the application is stopped, the modules are unloaded using a number of &lt;code&gt;delete_module&lt;/code&gt; instructions, and then the application specification is unloaded from the application controller.</source>
          <target state="translated">응용 프로그램을 제거하면 응용 프로그램이 중지되고 여러 &lt;code&gt;delete_module&lt;/code&gt; 명령어를 사용하여 모듈이 언로드 된 다음 응용 프로그램 컨트롤러에서 응용 프로그램 사양이 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="21ecfe29f13ab8d3591c9f7ede9bc7422e8e8b32" translate="yes" xml:space="preserve">
          <source>Removing the &lt;code&gt;timer&lt;/code&gt; key from the map when we change to state &lt;code&gt;locked&lt;/code&gt; is not strictly necessary since we can only get into state &lt;code&gt;open&lt;/code&gt; with an updated &lt;code&gt;timer&lt;/code&gt; map value. But it can be nice to not have outdated values in the state &lt;code&gt;Data&lt;/code&gt;!</source>
          <target state="translated">업데이트 된 &lt;code&gt;timer&lt;/code&gt; 맵 값 으로 상태를 &lt;code&gt;open&lt;/code&gt; 수 있기 때문에 상태 &lt;code&gt;locked&lt;/code&gt; 상태로 변경할 때 맵에서 &lt;code&gt;timer&lt;/code&gt; 키를 제거 할 필요는 없습니다 . 그러나 상태 &lt;code&gt;Data&lt;/code&gt; 에서 오래된 값을 가지지 않는 것이 좋습니다 !</target>
        </trans-unit>
        <trans-unit id="0cfa720136cd04bacd2eac92ab7474295652cf42" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;Old&lt;/code&gt; to &lt;code&gt;New&lt;/code&gt; at the remote server.</source>
          <target state="translated">원격 서버에서 &lt;code&gt;Old&lt;/code&gt; 를 &lt;code&gt;New&lt;/code&gt; 로 이름을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="6d0f47bb19f5b5facec144970690eb3792cd2ef5" translate="yes" xml:space="preserve">
          <source>Renames a file named &lt;code&gt;OldName&lt;/code&gt; and gives it the name &lt;code&gt;NewName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OldName&lt;/code&gt; 이라는 파일 이름을 바꾸고 이름을 &lt;code&gt;NewName&lt;/code&gt; 으로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="08c6204fdae6705e22c2f29ad8fc6ee2ce0504b5" translate="yes" xml:space="preserve">
          <source>Renames a set of possibly interdependent source code modules. &lt;code&gt;Files&lt;/code&gt; is a list of file names of source modules to be processed. &lt;code&gt;Renamings&lt;/code&gt; is a list of pairs of &lt;strong&gt;module names&lt;/strong&gt;, representing a mapping from old names to new. The returned value is the list of output file names.</source>
          <target state="translated">상호 의존 가능한 소스 코드 모듈 세트를 이름을 바꿉니다. &lt;code&gt;Files&lt;/code&gt; 은 처리 할 소스 모듈의 파일 이름 목록입니다. &lt;code&gt;Renamings&lt;/code&gt; 는 이전 이름에서 새 이름으로의 맵핑을 나타내는 &lt;strong&gt;모듈 이름&lt;/strong&gt; 쌍의 목록입니다 . 리턴 된 값은 출력 파일 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fd85297b6c1591a7f5105a46107e2cb8283239d7" translate="yes" xml:space="preserve">
          <source>Renames the log file to &lt;code&gt;File&lt;/code&gt; and then recreates a new log file. If a wrap log exists, &lt;code&gt;File&lt;/code&gt; is used as the base name of the renamed files. By default the header given to &lt;code&gt;open/1&lt;/code&gt; is written first in the newly opened log file, but if argument &lt;code&gt;Head&lt;/code&gt; or &lt;code&gt;BHead&lt;/code&gt; is specified, this item is used instead. The header argument is used only once. Next time a wrap log file is opened, the header given to &lt;code&gt;open/1&lt;/code&gt; is used.</source>
          <target state="translated">로그 파일 이름을 &lt;code&gt;File&lt;/code&gt; 로 바꾼 다음 새 로그 파일을 다시 만듭니다. 랩 로그가 존재하면 &lt;code&gt;File&lt;/code&gt; 은 이름이 바뀐 파일의 기본 이름으로 사용됩니다. 기본적으로 &lt;code&gt;open/1&lt;/code&gt; 에 지정된 헤더 가 새로 열린 로그 파일에서 먼저 기록되지만 &lt;code&gt;Head&lt;/code&gt; 또는 &lt;code&gt;BHead&lt;/code&gt; 인수 가 지정된 경우이 항목이 대신 사용됩니다. 헤더 인수는 한 번만 사용됩니다. 다음에 랩 로그 파일을 &lt;code&gt;open/1&lt;/code&gt; 지정된 헤더 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54af7ac61590d862405adf0734930d6cae2cb066" translate="yes" xml:space="preserve">
          <source>Renames the named table &lt;code&gt;Tab&lt;/code&gt; to the new name &lt;code&gt;Name&lt;/code&gt;. Afterwards, the old name cannot be used to access the table. Renaming an unnamed table has no effect.</source>
          <target state="translated">명명 된 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 이름 을 새 이름 &lt;code&gt;Name&lt;/code&gt; 으로 바꿉니다 . 그 후에는 이전 이름을 사용하여 테이블에 액세스 할 수 없습니다. 명명되지 않은 테이블의 이름을 바꾸더라도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff5eaf0e51b9b10a59f079047c36ed274ea953d1" translate="yes" xml:space="preserve">
          <source>Renaming of open files is not allowed on most platforms (see &lt;code&gt;eacces&lt;/code&gt; below).</source>
          <target state="translated">열려있는 파일의 이름을 바꾸는 것은 대부분의 플랫폼에서 허용되지 않습니다 (아래 &lt;code&gt;eacces&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="7fad444613612977458b8b88430a31438343ac58" translate="yes" xml:space="preserve">
          <source>Repeat the modification step with the tail of &lt;code&gt;modify_algs_list()&lt;/code&gt; and the resulting &lt;code&gt;A'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modify_algs_list()&lt;/code&gt; 의 꼬리 와 결과 &lt;code&gt;A'&lt;/code&gt; 수정 단계를 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac3f3cc198e4d81a7905803f774173fbcea00b2" translate="yes" xml:space="preserve">
          <source>Repeat until there is no path between &lt;code&gt;V1&lt;/code&gt; and &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V1&lt;/code&gt; 과 &lt;code&gt;V2&lt;/code&gt; 사이에 경로가 없을 때까지 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="882850f9efe1aecf6bc3eb3238cdb7ef37fa9c9b" translate="yes" xml:space="preserve">
          <source>Repeats command &lt;code&gt;N&lt;/code&gt;, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the &lt;code&gt;N&lt;/code&gt;th previous command is repeated (that is, &lt;code&gt;e(-1)&lt;/code&gt; repeats the previous command).</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 이 양수 이면 명령 &lt;code&gt;N&lt;/code&gt; 을 반복합니다 . 음수이면 &lt;code&gt;N&lt;/code&gt; 번째 이전 명령이 반복됩니다 (즉, &lt;code&gt;e(-1)&lt;/code&gt; 이 이전 명령을 반복 함).</target>
        </trans-unit>
        <trans-unit id="f80a175e58465cf2c27bbc9fe26e988c97a71cc0" translate="yes" xml:space="preserve">
          <source>Repeats the split until &lt;code&gt;Subject&lt;/code&gt; is exhausted. Conceptually option &lt;code&gt;global&lt;/code&gt; makes split work on the positions returned by &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, while it normally works on the position returned by &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 가 다 될 때까지 분할을 반복합니다 . 개념적으로 &lt;code&gt;global&lt;/code&gt; 옵션 은 &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 위치에서 split 작업을 수행 하지만, 보통 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 위치에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a172a0f5c387a5e46c31a43f2cefffb22c95831f" translate="yes" xml:space="preserve">
          <source>Repetition is specified by quantifiers, which can follow any of the following items:</source>
          <target state="translated">반복은 수량 자에 의해 지정되며 다음 항목 중 하나를 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="146808ca12c9af96348c2ab80e60f75d56da8935" translate="yes" xml:space="preserve">
          <source>Replace the kex algorithms list with the single algorithm &lt;code&gt;'diffie-hellman-group14-sha256'&lt;/code&gt;:</source>
          <target state="translated">kex 알고리즘 목록을 단일 알고리즘 &lt;code&gt;'diffie-hellman-group14-sha256'&lt;/code&gt; 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="56d42d2b692a0d6476978d84d1a8114ac3464d87" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed module&lt;/a&gt;&lt;/code&gt; with data read from a BEAM file. Application membership of the module is retained, and so is the value of the &lt;code&gt;builtins&lt;/code&gt; option of the module. An error is returned if the name of the read module differs from the given module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed module&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 BEAM 파일에서 읽은 데이터 로 바꿉니다 . 모듈의 응용 프로그램 멤버 자격이 유지되며 모듈의 &lt;code&gt;builtins&lt;/code&gt; 옵션 값도 유지 됩니다. 읽기 모듈 이름이 지정된 모듈과 다른 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9750cc1b6985af6ed569e4fe99331e1df8b510" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;SearchPattern&lt;/code&gt; in &lt;code&gt;String&lt;/code&gt; with &lt;code&gt;Replacement&lt;/code&gt;. &lt;code&gt;Where&lt;/code&gt;, default &lt;code&gt;leading&lt;/code&gt;, indicates whether the &lt;code&gt;leading&lt;/code&gt;, the &lt;code&gt;trailing&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt; encounters of &lt;code&gt;SearchPattern&lt;/code&gt; are to be replaced.</source>
          <target state="translated">바꿉니다 &lt;code&gt;SearchPattern&lt;/code&gt; 에서 &lt;code&gt;String&lt;/code&gt; 로 &lt;code&gt;Replacement&lt;/code&gt; . &lt;code&gt;Where&lt;/code&gt; 기본 &lt;code&gt;leading&lt;/code&gt; 은 &lt;code&gt;SearchPattern&lt;/code&gt; 의 &lt;code&gt;leading&lt;/code&gt; , &lt;code&gt;trailing&lt;/code&gt; 또는 &lt;code&gt;all&lt;/code&gt; 만남을 바꿀지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a561fe60c3d9ba1409232278ffca46e8f6e25489" translate="yes" xml:space="preserve">
          <source>Replaces an event handler in event manager &lt;code&gt;EventMgrRef&lt;/code&gt; in the same way as &lt;code&gt;swap_handler/3&lt;/code&gt;, but also supervises the connection between &lt;code&gt;Handler2&lt;/code&gt; and the calling process.</source>
          <target state="translated">&lt;code&gt;swap_handler/3&lt;/code&gt; 와 같은 방식으로 이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 의 이벤트 핸들러를 대체 하지만 &lt;code&gt;Handler2&lt;/code&gt; 와 호출 프로세스 간의 연결을 감독합니다 .</target>
        </trans-unit>
        <trans-unit id="419481a738590ffe74f074cd3f66660d64a0e60c" translate="yes" xml:space="preserve">
          <source>Replaces an old event handler with a new event handler in event manager &lt;code&gt;EventMgrRef&lt;/code&gt;.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에서 이전 이벤트 핸들러를 새 이벤트 핸들러로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="9eed3a84ce22771b5808dd7e1463a515114573df" translate="yes" xml:space="preserve">
          <source>Replaces an old occurrence of a directory named &lt;code&gt;.../Name[-Vsn][/ebin]&lt;/code&gt; in the code path, with &lt;code&gt;Dir&lt;/code&gt;. If &lt;code&gt;Name&lt;/code&gt; does not exist, it adds the new directory &lt;code&gt;Dir&lt;/code&gt; last in the code path. The new directory must also be named &lt;code&gt;.../Name[-Vsn][/ebin]&lt;/code&gt;. This function is to be used if a new version of the directory (library) is added to a running system.</source>
          <target state="translated">코드 경로에서 &lt;code&gt;.../Name[-Vsn][/ebin]&lt;/code&gt; 디렉토리의 이전 항목을 &lt;code&gt;Dir&lt;/code&gt; 로 바꿉니다 . 경우 &lt;code&gt;Name&lt;/code&gt; 존재하지 않는, 그것은 새 디렉토리에 추가 &lt;code&gt;Dir&lt;/code&gt; 코드 경로에서 마지막. 새 디렉토리의 이름도 &lt;code&gt;.../Name[-Vsn][/ebin]&lt;/code&gt; 합니다. 이 기능은 새 버전의 디렉토리 (라이브러리)가 실행중인 시스템에 추가 된 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e95e156f5a3b21e55b9e9d7df8ac40e83028b042" translate="yes" xml:space="preserve">
          <source>Replaces the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of all &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt; the BEAM files of which have been modified since last read by an &lt;code&gt;add&lt;/code&gt; function or &lt;code&gt;update&lt;/code&gt;. Application membership of the modules is retained, and so is the value of the &lt;code&gt;builtins&lt;/code&gt; option. Returns a sorted list of the names of the replaced modules.</source>
          <target state="translated">BEAM 파일이 &lt;code&gt;add&lt;/code&gt; 함수 또는 &lt;code&gt;update&lt;/code&gt; 에 의해 마지막으로 읽은 이후 수정 된 모든 &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 대체합니다 . 모듈의 응용 프로그램 멤버 자격이 유지되며 &lt;code&gt;builtins&lt;/code&gt; 옵션 의 값도 유지 됩니다. 교체 된 모듈 이름의 정렬 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e162acc877cce3efc4c4645eed631739ea69f0f7" translate="yes" xml:space="preserve">
          <source>Replaces the existing objects of table &lt;code&gt;Name&lt;/code&gt; with objects created by calling the input function &lt;code&gt;InitFun&lt;/code&gt;, see below. The reason for using this function rather than calling &lt;code&gt;insert/2&lt;/code&gt; is that of efficiency. Notice that the input functions are called by the process that handles requests to the Dets table, not by the calling process.</source>
          <target state="translated">입력 함수 &lt;code&gt;InitFun&lt;/code&gt; 을 호출하여 작성된 테이블 &lt;code&gt;Name&lt;/code&gt; 의 기존 오브젝트를 오브젝트로 바꿉니다 ( 아래 참조). &lt;code&gt;insert/2&lt;/code&gt; 를 호출하는 대신이 기능을 사용하는 이유 는 효율성 때문입니다. 입력 함수는 호출 프로세스가 아닌 Dets 테이블에 대한 요청을 처리하는 프로세스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e2db8771ec60e84f4f89a23c30a3ab11bf1890" translate="yes" xml:space="preserve">
          <source>Replaces the existing objects of table &lt;code&gt;Tab&lt;/code&gt; with objects created by calling the input function &lt;code&gt;InitFun&lt;/code&gt;, see below. This function is provided for compatibility with the &lt;code&gt;dets&lt;/code&gt; module, it is not more efficient than filling a table by using &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Tab&lt;/code&gt; 의 기존 객체를 입력 함수 &lt;code&gt;InitFun&lt;/code&gt; 을 호출하여 만든 객체로 바꿉니다 ( 아래 참조). 이 기능은 &lt;code&gt;dets&lt;/code&gt; 모듈 과의 호환성을 위해 제공되며 &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블을 채우는 것보다 효율적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6628e9df362f62f633a5d7e6425eed79b6dbe778" translate="yes" xml:space="preserve">
          <source>Replaces the matched part of the &lt;code&gt;Subject&lt;/code&gt; string with the contents of &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 문자열 에서 일치하는 부분 을 &lt;code&gt;Replacement&lt;/code&gt; 의 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="12f3f7bbddec5d3195ba4a36bdd58ba53790386e" translate="yes" xml:space="preserve">
          <source>Replaces the modules of an application with other modules read from an application directory. Release membership of the application is retained. Note that the name of the application is kept; the name of the given directory is not used.</source>
          <target state="translated">응용 프로그램의 모듈을 응용 프로그램 디렉토리에서 읽은 다른 모듈로 바꿉니다. 응용 프로그램의 릴리스 멤버 자격이 유지됩니다. 응용 프로그램 이름이 유지됩니다. 주어진 디렉토리의 이름이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8d1a9d58a5e5ca14250cdab073b72fea337a464" translate="yes" xml:space="preserve">
          <source>Replaces the path specified in the boot script; see &lt;code&gt;script(4)&lt;/code&gt;.</source>
          <target state="translated">부팅 스크립트에 지정된 경로를 바꿉니다. &lt;code&gt;script(4)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047f0df8a3018b8551685d31f76e6d44444474fc" translate="yes" xml:space="preserve">
          <source>Replaces the state of the process, and returns the new state.</source>
          <target state="translated">프로세스 상태를 바꾸고 새 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9184d9c39282b5754d576935dbc39e77f9d02e83" translate="yes" xml:space="preserve">
          <source>Replicas of type &lt;code&gt;disc_only_copies&lt;/code&gt; are only affected by this parameter during the initial dump of the log file at startup. When designing applications with &lt;strong&gt;very&lt;/strong&gt; high requirements, it can be appropriate not to use &lt;code&gt;disc_only_copies&lt;/code&gt; tables at all. The reason for this is the random access nature of normal operating system files. If a node goes down for a reason such as a power failure, these files can be corrupted because they are not properly closed. The &lt;code&gt;DAT&lt;/code&gt; files for &lt;code&gt;disc_only_copies&lt;/code&gt; are updated on a per transaction basis.</source>
          <target state="translated">&lt;code&gt;disc_only_copies&lt;/code&gt; 유형의 복제본은 시작시 로그 파일의 초기 덤프 중이 매개 변수의 영향을받습니다. 요구 사항 이 &lt;strong&gt;매우&lt;/strong&gt; 높은 응용 프로그램을 디자인 할 때는 &lt;code&gt;disc_only_copies&lt;/code&gt; 테이블을 전혀 사용하지 않는 것이 좋습니다 . 그 이유는 일반 운영 체제 파일의 무작위 액세스 특성 때문입니다. 정전과 같은 이유로 노드가 중단되면 이러한 파일이 제대로 닫히지 않아 손상 될 수 있습니다. &lt;code&gt;disc_only_copies&lt;/code&gt; 의 &lt;code&gt;DAT&lt;/code&gt; 파일 은 트랜잭션별로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6ac8596fa89edfabdcf6fecf958d16a005ece982" translate="yes" xml:space="preserve">
          <source>Replicated tables have the same content on all nodes where they are replicated. However, it is sometimes advantageous to have tables, but different content on different nodes.</source>
          <target state="translated">복제 된 테이블은 복제되는 모든 노드에서 동일한 내용을 갖습니다. 그러나 테이블이 있지만 노드마다 내용이 다른 것이 유리한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9e9afe1a552da9f13fde90fd0f5258e6b4db3e" translate="yes" xml:space="preserve">
          <source>Replicated tables that reside locally as well as somewhere else are either initiated from disc or by copying the entire table from the other node, depending on which of the different replicas are the most recent. &lt;code&gt;Mnesia&lt;/code&gt; determines which of the tables are the most recent.</source>
          <target state="translated">다른 곳뿐만 아니라 로컬에 상주하는 복제 된 테이블은 가장 최근의 다른 복제본에 따라 디스크에서 시작하거나 다른 노드에서 전체 테이블을 복사하여 시작됩니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 가장 최근의 테이블을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5ebc556c3a47de1e105808f80a573351d288796c" translate="yes" xml:space="preserve">
          <source>Replication. Tables can be replicated at several nodes.</source>
          <target state="translated">복제. 여러 노드에서 테이블을 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7fb706c746d6c42069331ec3f48fc3bf37dbe5a" translate="yes" xml:space="preserve">
          <source>Replies arriving after the timer has expired, will be delivered using the &lt;code&gt;&lt;a href=&quot;megaco_user#unexpected_trans&quot;&gt;handle_unexpected_trans/3,4&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="translated">타이머가 만료 된 후에 도착한 응답은 &lt;code&gt;&lt;a href=&quot;megaco_user#unexpected_trans&quot;&gt;handle_unexpected_trans/3,4&lt;/a&gt;&lt;/code&gt; 콜백 함수를 사용하여 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="126cf04b40e9dfa6af76d4b4da1a8ce9285a1fa9" translate="yes" xml:space="preserve">
          <source>Reply :: term()</source>
          <target state="translated">답글 :: term ()</target>
        </trans-unit>
        <trans-unit id="58cf87f6dac57b28d02194486fcb6f8dd6ecc261" translate="yes" xml:space="preserve">
          <source>Reply from other state than the request, &lt;code&gt;sys&lt;/code&gt; traceable</source>
          <target state="translated">요청 이외의 다른 상태에서 응답, &lt;code&gt;sys&lt;/code&gt; 추적 가능</target>
        </trans-unit>
        <trans-unit id="7a00bbb5f99bc04dd63e793a0e32145c7dc90c48" translate="yes" xml:space="preserve">
          <source>Reply to &lt;code&gt;Port ! {Pid,close}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Port ! {Pid,close}&lt;/code&gt; 회신하십시오 ! {Pid, close} .</target>
        </trans-unit>
        <trans-unit id="8694767ec4c7b52fb9e3f8d2f15cf11c06894a41" translate="yes" xml:space="preserve">
          <source>Reply to &lt;code&gt;Port ! {Pid,{connect,NewPid}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Port ! {Pid,{connect,NewPid}}&lt;/code&gt; 회신하십시오 ! {PID를, {}, NewPid를 연결} .</target>
        </trans-unit>
        <trans-unit id="4b96dfeb12fd8a4e4012eab404a286bb6ae1f178" translate="yes" xml:space="preserve">
          <source>Reply to a caller, mentioned at the end of section &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 섹션 끝에 언급 된 발신자에게 회신</target>
        </trans-unit>
        <trans-unit id="72df4b4bc039d9b2e5bdd4ac208ec2c87607d70b" translate="yes" xml:space="preserve">
          <source>Reply | {error, Reason}</source>
          <target state="translated">답장 | {오류, 이유}</target>
        </trans-unit>
        <trans-unit id="d41fb2069eb0e10f46e258ab0b1229e85d9491d5" translate="yes" xml:space="preserve">
          <source>Report a parsed external entity declaration.</source>
          <target state="translated">구문 분석 된 외부 엔티티 선언을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="ea5741dec57b6d216da5d5c515fc46fa697f27c6" translate="yes" xml:space="preserve">
          <source>Report an XML comment anywhere in the document (both inside and outside of the document element).</source>
          <target state="translated">문서의 내부 및 외부에서 문서의 어느 위치 에나 XML 주석을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="5b4904e061e57bddfab52b6cfd2d3ea1d06c349e" translate="yes" xml:space="preserve">
          <source>Report an attribute type declaration.</source>
          <target state="translated">속성 유형 선언을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="e3db9c3fab04d85ea232a7fcf942fbfd1b004b09" translate="yes" xml:space="preserve">
          <source>Report an element type declaration. The content model will consist of the string &quot;EMPTY&quot;, the string &quot;ANY&quot;, or a parenthesised group, optionally followed by an occurrence indicator. The model will be normalized so that all parameter entities are fully resolved and all whitespace is removed,and will include the enclosing parentheses. Other normalization (such as removing redundant parentheses or simplifying occurrence indicators) is at the discretion of the parser.</source>
          <target state="translated">요소 유형 선언을보고하십시오. 컨텐츠 모델은 문자열 &quot;EMPTY&quot;, 문자열 &quot;ANY&quot;또는 괄호로 묶은 그룹으로 구성되며 선택적으로 발생 표시기가 뒤 따릅니다. 모든 매개 변수 엔터티가 완전히 확인되고 모든 공백이 제거되고 둘러싸는 괄호가 포함되도록 모델이 정규화됩니다. 다른 정규화 (예 : 중복 괄호 제거 또는 발생 표시 단순화)는 구문 분석기의 재량에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bf5d2d664010dcb10710bdf2302a984224d32fd1" translate="yes" xml:space="preserve">
          <source>Report an event to the collector.</source>
          <target state="translated">수집기에게 이벤트를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="0726ec060dd61caf7a44399784154bba339be6e5" translate="yes" xml:space="preserve">
          <source>Report an internal entity declaration.</source>
          <target state="translated">내부 실체 신고를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="b903e37625cb00383193345807e6f2cd70182b4f" translate="yes" xml:space="preserve">
          <source>Report browsing</source>
          <target state="translated">보고서 탐색</target>
        </trans-unit>
        <trans-unit id="b4e0e2fdd9a9b427f43e27d5c7689fab83f4954f" translate="yes" xml:space="preserve">
          <source>Report the beginning of some internal and external XML entities. ???</source>
          <target state="translated">내부 및 외부 XML 엔터티의 시작을보고합니다. ???</target>
        </trans-unit>
        <trans-unit id="1537db331987c73e42ec79886424725e7ced0ca8" translate="yes" xml:space="preserve">
          <source>Report the end of DTD declarations, it's reporting the end of the DOCTYPE declaration.</source>
          <target state="translated">DTD 선언의 끝을보고하고 DOCTYPE 선언의 끝을보고합니다.</target>
        </trans-unit>
        <trans-unit id="45b1374aafa256e46789d17cd746069ce811a778" translate="yes" xml:space="preserve">
          <source>Report the end of a CDATA section.</source>
          <target state="translated">CDATA 섹션의 끝을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="4e77cabadac053249b29d05bd9d1d234e2cc1e97" translate="yes" xml:space="preserve">
          <source>Report the end of an entity. ???</source>
          <target state="translated">엔터티의 끝을보고하십시오. ???</target>
        </trans-unit>
        <trans-unit id="c09ed9bee7f1262daef582c404162b533ffaa466" translate="yes" xml:space="preserve">
          <source>Report the start of DTD declarations, it's reporting the start of the DOCTYPE declaration. If the document has no DOCTYPE declaration, this event will not be sent.</source>
          <target state="translated">DTD 선언의 시작을보고하고 DOCTYPE 선언의 시작을보고합니다. 문서에 DOCTYPE 선언이 없으면이 이벤트가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b91bc27e6fa6a320a4ff9f88df2653241bb852b" translate="yes" xml:space="preserve">
          <source>Report the start of a CDATA section. The contents of the CDATA section will be reported through the regular characters event.</source>
          <target state="translated">CDATA 섹션의 시작을보고하십시오. CDATA 섹션의 내용은 일반 문자 이벤트를 통해보고됩니다.</target>
        </trans-unit>
        <trans-unit id="93fd5ff4921baf203ff8b603c22461be039d636b" translate="yes" xml:space="preserve">
          <source>Reports term allocation statistics.</source>
          <target state="translated">용어 할당 통계를보고합니다.</target>
        </trans-unit>
        <trans-unit id="99f5b324157a74f4ba599f70ce8661cfdaad5091" translate="yes" xml:space="preserve">
          <source>Reports the service as stopped to the service manager whenever it fails; it must be manually restarted.</source>
          <target state="translated">실패 할 때마다 서비스를 서비스 관리자에게 중지 된 것으로보고합니다. 수동으로 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="e58aecb98ff170f7c11b8160942cbfb76f351aa2" translate="yes" xml:space="preserve">
          <source>Represents a file path or directory path</source>
          <target state="translated">파일 경로 또는 디렉토리 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="22e7792d22c5ac3675d98858db71f22cbdabe7a5" translate="yes" xml:space="preserve">
          <source>Represents a file path.</source>
          <target state="translated">파일 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f7ed31f709b30e7c94bd6f94122425a637cb46a" translate="yes" xml:space="preserve">
          <source>Request :: term(),</source>
          <target state="translated">요청 :: term (),</target>
        </trans-unit>
        <trans-unit id="507b55ef67a3793e186e31503844b20cdf44035d" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;get_geometry&lt;/code&gt; has no meaning for this I/O server, so the reply is &lt;code&gt;{error, enotsup}&lt;/code&gt;. The only option we handle is &lt;code&gt;binary&lt;/code&gt;/&lt;code&gt;list&lt;/code&gt;, which is done in separate functions.</source>
          <target state="translated">&lt;code&gt;get_geometry&lt;/code&gt; 요청 은이 I / O 서버에 의미가 없으므로 응답은 &lt;code&gt;{error, enotsup}&lt;/code&gt; 입니다. 우리가 처리하는 유일한 옵션은 &lt;code&gt;binary&lt;/code&gt; / &lt;code&gt;list&lt;/code&gt; 이며 별도의 기능으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="24e691247dfe3630fd35fda8c0e139ee4284bed3" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;getopts&lt;/code&gt; is to return a list of &lt;code&gt;{Option, Value}&lt;/code&gt; tuples. This has the twofold function of providing both the current values and the available options of this I/O server. We have only one option, and hence return that.</source>
          <target state="translated">&lt;code&gt;getopts&lt;/code&gt; 요청 은 &lt;code&gt;{Option, Value}&lt;/code&gt; 튜플 목록을 반환하는 것 입니다. 여기에는 현재 값과이 I / O 서버의 사용 가능한 옵션을 모두 제공하는 두 가지 기능이 있습니다. 우리는 단 하나의 옵션을 가지고 있으므로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e0c378c7ccfe92728a6bfeeedc02369a4d75150" translate="yes" xml:space="preserve">
          <source>Request Forwarding</source>
          <target state="translated">요청 전달</target>
        </trans-unit>
        <trans-unit id="370aa763d24c7c6a889f8bc1f6473021ef74ab40" translate="yes" xml:space="preserve">
          <source>Request Routing</source>
          <target state="translated">요청 라우팅</target>
        </trans-unit>
        <trans-unit id="e22d3290b587090a383ad7e805ef81704f3e3f28" translate="yes" xml:space="preserve">
          <source>Request URI</source>
          <target state="translated">요청 URI</target>
        </trans-unit>
        <trans-unit id="0f51f8766bdb5268b3f7a7fb925d40cf0ac64489" translate="yes" xml:space="preserve">
          <source>Request a notification (message) when the SNMP manager has started.</source>
          <target state="translated">SNMP 관리자가 시작되면 알림 (메시지)을 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="b54284e63f3207a9fed531cafce78b6ab997861b" translate="yes" xml:space="preserve">
          <source>Request notification when more data is available to fetch using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_get_data-1&quot;&gt;erlang:dist_ctrl_get_data(DHandle)&lt;/a&gt;&lt;/code&gt; for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt;. When more data is present, the caller will be sent the message &lt;code&gt;dist_data&lt;/code&gt;. Once a &lt;code&gt;dist_data&lt;/code&gt; messages has been sent, no more &lt;code&gt;dist_data&lt;/code&gt; messages will be sent until the &lt;code&gt;dist_ctrl_get_data_notification/1&lt;/code&gt; function has been called again.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_get_data-1&quot;&gt;erlang:dist_ctrl_get_data(DHandle)&lt;/a&gt;&lt;/code&gt; 식별되는 분배 채널에 대해 erlang : dist_ctrl_get_data (DHandle) 을 사용하여 더 많은 데이터를 페치 할 수있는 경우 알림을 요청 &lt;code&gt;DHandle&lt;/code&gt; . 더 많은 데이터가 있으면 호출자에게 &lt;code&gt;dist_data&lt;/code&gt; 메시지가 전송됩니다 . 한 번 &lt;code&gt;dist_data&lt;/code&gt; 메시지가 전송되어, 더 이상 &lt;code&gt;dist_data&lt;/code&gt; 메시지가 될 때까지 전송되지 않습니다 &lt;code&gt;dist_ctrl_get_data_notification/1&lt;/code&gt; 함수가 다시 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a5f2a76edb63ef16353fc42ce9a4bc1b8d49591" translate="yes" xml:space="preserve">
          <source>Request the network interface process (&lt;code&gt;Pid&lt;/code&gt;) to send this pdu (&lt;code&gt;Pdu&lt;/code&gt;).</source>
          <target state="translated">이 pdu ( &lt;code&gt;Pdu&lt;/code&gt; ) 를 보내 려면 네트워크 인터페이스 프로세스 ( &lt;code&gt;Pid&lt;/code&gt; )를 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="f13633a66bddd5919d4452b83066b5c9306c3699" translate="yes" xml:space="preserve">
          <source>Requests &lt;code&gt;getopts&lt;/code&gt; and &lt;code&gt;setopts&lt;/code&gt; are also simple to handle. We only change or read the state record:</source>
          <target state="translated">요청 &lt;code&gt;getopts&lt;/code&gt; 및 &lt;code&gt;setopts&lt;/code&gt; 도 처리하기 쉽습니다 . 상태 기록 만 변경하거나 읽습니다.</target>
        </trans-unit>
        <trans-unit id="64e6fe8df794535a6e7f8e3381fa29ec4cd2b3fe" translate="yes" xml:space="preserve">
          <source>Requests all available options and their current values for a specific I/O device, for example:</source>
          <target state="translated">특정 I / O 장치에 대해 사용 가능한 모든 옵션과 현재 값을 요청합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="44b5e144b529d1d34d542fbdbbb37113f0041e10" translate="yes" xml:space="preserve">
          <source>Requests are constructed by the user; diameter sets header fields as defined in the relevant dictionary.</source>
          <target state="translated">요청은 사용자가 구성합니다. 직경은 관련 사전에 정의 된대로 헤더 필드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ddc39c20a1e625e364b51db01eb9285198684651" translate="yes" xml:space="preserve">
          <source>Requests can be issued in two different ways. Synchronous (see &lt;code&gt;&lt;a href=&quot;snmpm#sync_set&quot;&gt;sync_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#sync_get&quot;&gt;sync_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#sync_get_next&quot;&gt;sync_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#sync_get_bulk&quot;&gt;sync_get_bulk&lt;/a&gt;&lt;/code&gt;) and asynchronous (see &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_get_bulk&quot;&gt;async_get_bulk&lt;/a&gt;&lt;/code&gt;). With synchronous the snmp reply is returned by the function. With asynchronous, the reply will instead be delivered through a call to one of the &lt;code&gt;handle_pdu&lt;/code&gt; callback function defined by the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_pdu&quot;&gt;handle_pdu&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">요청은 두 가지 방법으로 발행 될 수 있습니다. 동기식 ( &lt;code&gt;&lt;a href=&quot;snmpm#sync_set&quot;&gt;sync_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#sync_get&quot;&gt;sync_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#sync_get_next&quot;&gt;sync_get_next&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpm#sync_get_bulk&quot;&gt;sync_get_bulk&lt;/a&gt;&lt;/code&gt; 참조) 및 비동기식 ( &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpm#async_get_bulk&quot;&gt;async_get_bulk&lt;/a&gt;&lt;/code&gt; 참조 ) 동기식으로 snmp 응답이 함수에 의해 리턴됩니다. 비동기식으로 응답은 &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_pdu&quot;&gt;handle_pdu&lt;/a&gt;&lt;/code&gt; 동작에 의해 정의 된 &lt;code&gt;handle_pdu&lt;/code&gt; 콜백 함수 중 하나에 대한 호출을 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2414a5adfd102a338c55197c870a5e8ed30f956e" translate="yes" xml:space="preserve">
          <source>Requests graceful termination of the session associated with the client.</source>
          <target state="translated">클라이언트와 관련된 세션의 정상적인 종료를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="d655475b16d4a6739afa13e1af4b35470f41df5a" translate="yes" xml:space="preserve">
          <source>Requests information about the &lt;code&gt;Result&lt;/code&gt; of the cancellation. &lt;code&gt;Info&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;, which means the &lt;code&gt;Result&lt;/code&gt; is given. When &lt;code&gt;Info&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, no information about the result of the cancellation is given.</source>
          <target state="translated">취소 &lt;code&gt;Result&lt;/code&gt; 에 대한 정보를 요청합니다 . &lt;code&gt;Info&lt;/code&gt; 기본값은 &lt;code&gt;true&lt;/code&gt; 이며 &lt;code&gt;Result&lt;/code&gt; 가 제공됨 을 의미합니다 . &lt;code&gt;Info&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 취소 결과에 대한 정보가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ff6c0ce1dee907fd5d7c3ad8ae69cf89227f676" translate="yes" xml:space="preserve">
          <source>Requests server to perform &lt;code&gt;Command&lt;/code&gt;. A previously opened session channel is used for the request. &lt;code&gt;Data&lt;/code&gt; is received from the server as a result of the command.</source>
          <target state="translated">서버에게 &lt;code&gt;Command&lt;/code&gt; 을 수행하도록 요청합니다 . 이전에 열린 세션 채널이 요청에 사용됩니다. 명령의 결과로 서버에서 &lt;code&gt;Data&lt;/code&gt; 가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="6f2f2abc3ea9b54a33e41c7792741fcd63ec00c4" translate="yes" xml:space="preserve">
          <source>Requests server to perform &lt;code&gt;Command&lt;/code&gt;. A session channel is opened automatically for the request. &lt;code&gt;Data&lt;/code&gt; is received from the server as a result of the command.</source>
          <target state="translated">서버에게 &lt;code&gt;Command&lt;/code&gt; 을 수행하도록 요청합니다 . 요청을 위해 세션 채널이 자동으로 열립니다. 명령의 결과로 서버에서 &lt;code&gt;Data&lt;/code&gt; 가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7ab29539f909d1d965db364abb306b9d8c23af" translate="yes" xml:space="preserve">
          <source>Requests that the user default shell (typically defined in &lt;code&gt;/etc/passwd&lt;/code&gt; in Unix systems) is executed at the server end.</source>
          <target state="translated">사용자 기본 쉘 (일반적으로 Unix 시스템의 &lt;code&gt;/etc/passwd&lt;/code&gt; 에 정의 됨 )이 서버 쪽에서 실행되도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e5d06105dd7bae848be23c489d1e425eef14e5ec" translate="yes" xml:space="preserve">
          <source>Requests the distribution port for the given node of an EPMD instance. Together with the port it returns a distribution protocol version which has been 5 since Erlang/OTP R6.</source>
          <target state="translated">EPMD 인스턴스의 지정된 노드에 대한 배포 포트를 요청합니다. 포트와 함께 Erlang / OTP R6 이후 5의 배포 프로토콜 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c627743aae6292d1edfab3fd611cfbaa35f44835" translate="yes" xml:space="preserve">
          <source>Require one node with a Telnet connection and an FTP connection. Name the node &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Telnet 연결 및 FTP 연결이있는 하나의 노드가 필요합니다. 노드 이름을 &lt;code&gt;a&lt;/code&gt; 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="932dc49cb33ce805a923ee58428b5676a3722687" translate="yes" xml:space="preserve">
          <source>Require these &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; to be used. The connection will be aborted during the handshake if the other end does not use them.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다. 다른 쪽 끝에서 사용하지 않으면 핸드 셰이크 중에 연결이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="56063266c28627d12fee18669ead149368f5bd42" translate="yes" xml:space="preserve">
          <source>Requires that &lt;code&gt;&lt;a href=&quot;#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; has been run first.</source>
          <target state="translated">그 필요 &lt;code&gt;&lt;a href=&quot;#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; 먼저 실행되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2e070334a18ace55475d2c7ef7214f9f493188c" translate="yes" xml:space="preserve">
          <source>Requires that the connection is activated. See megaco:conn_info/2 about which items and values that are valid.</source>
          <target state="translated">연결이 활성화되어 있어야합니다. 유효한 항목과 값은 megaco : conn_info / 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f30287faf99098f6763e46a8603c005c19362cee" translate="yes" xml:space="preserve">
          <source>Requires that the connection is active.</source>
          <target state="translated">연결이 활성화되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c17e71f20f663cc9f1189e3ef11360a81ecbc8ce" translate="yes" xml:space="preserve">
          <source>Requires that the user does not have any active connection.</source>
          <target state="translated">사용자에게 활성 연결이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3da804007a27f313a5e70a7489a52d0032c97df" translate="yes" xml:space="preserve">
          <source>Requires that the user is started. See megaco:user_info/2 about which items and values that are valid.</source>
          <target state="translated">사용자가 시작해야합니다. 유효한 항목과 값은 megaco : user_info / 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="481a1c0d4b2c5ff0b5f30e85bd6e692df575764b" translate="yes" xml:space="preserve">
          <source>Requires the megaco application to be started. A user is either a Media Gateway (MG) or a Media Gateway Controller (MGC). One Erlang node may host many users.</source>
          <target state="translated">megaco 응용 프로그램을 시작해야합니다. 사용자는 미디어 게이트웨이 (MG) 또는 미디어 게이트웨이 컨트롤러 (MGC)입니다. 하나의 Erlang 노드가 많은 사용자를 호스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd1dec24c9ebfc2c604cc35df6701d77561b1e0" translate="yes" xml:space="preserve">
          <source>Res | {badrpc, Reason}</source>
          <target state="translated">입술 | {badrpc, 이유}</target>
        </trans-unit>
        <trans-unit id="f4d9a08bacabf1ee192cf2da13ea58302dc18f45" translate="yes" xml:space="preserve">
          <source>Rescans the report directory. &lt;code&gt;Options&lt;/code&gt; is the same as for function &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보고서 디렉토리를 다시 스캔하십시오. &lt;code&gt;Options&lt;/code&gt; 은 기능 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="01982cececb98074d29349a0c9e9557b0c782077" translate="yes" xml:space="preserve">
          <source>Reserved for future use. Do &lt;strong&gt;not&lt;/strong&gt; use this flag.</source>
          <target state="translated">나중에 사용하기 위해 예약되어 있습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 이 플래그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="094891da7eec692d61182c9206f122cd46f36e84" translate="yes" xml:space="preserve">
          <source>Reset all TCP related (SNMP) statistics counters.</source>
          <target state="translated">모든 TCP 관련 (SNMP) 통계 카운터를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="68db580cd0bf93363aa59a948b05562996e8a597" translate="yes" xml:space="preserve">
          <source>Reset all related (SNMP) statistics counters.</source>
          <target state="translated">모든 관련 (SNMP) 통계 카운터를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea2af705ba687b7e03e81fd53a43ecd4950468a4" translate="yes" xml:space="preserve">
          <source>Reset microstate accounting counters. Returns whether is was enabled or disabled.</source>
          <target state="translated">마이크로 스테이트 회계 카운터를 재설정합니다. 활성화 또는 비활성화 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1629825928942be4143ae7ec741fae164c32209f" translate="yes" xml:space="preserve">
          <source>Resets (clears) the cookie database for the specified &lt;code&gt;Profile&lt;/code&gt;. If no profile is specified the default profile is used.</source>
          <target state="translated">지정된 &lt;code&gt;Profile&lt;/code&gt; 의 쿠키 데이터베이스를 재설정 (클리어)합니다 . 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42f663110bd6b64d84eaef947ff89445b867c379" translate="yes" xml:space="preserve">
          <source>Resets all &lt;code&gt;snmp&lt;/code&gt; counters to 0.</source>
          <target state="translated">모든 &lt;code&gt;snmp&lt;/code&gt; 카운터를 0으로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d94724b4ac055ae7ff4431386f7dd90b475d3b80" translate="yes" xml:space="preserve">
          <source>Resets all counters and then starts microstate accounting for the given milliseconds.</source>
          <target state="translated">모든 카운터를 재설정 한 다음 주어진 밀리 초 동안 마이크로 스테이트 계산을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c35fd9595bfbabab4d1c990efe590d85aad9a81e" translate="yes" xml:space="preserve">
          <source>Resets all coverage data for a Cover compiled module &lt;code&gt;Module&lt;/code&gt; in the Cover database on all nodes. If the argument is omitted, the coverage data will be reset for all modules known by Cover.</source>
          <target state="translated">모든 노드의 Cover 데이터베이스에서 Cover 컴파일 된 모듈 &lt;code&gt;Module&lt;/code&gt; 에 대한 모든 Coverage 데이터를 재설정합니다 . 인수가 생략되면 Coverage로 알려진 모든 모듈에 대해 Coverage 데이터가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f827ea2106527d66b22496ff17d161262d1e35ba" translate="yes" xml:space="preserve">
          <source>Resets entry &lt;code&gt;I&lt;/code&gt; to the default value for the array. If the value of entry &lt;code&gt;I&lt;/code&gt; is the default value, the array is returned unchanged. Reset never changes the array size. Shrinking can be done explicitly by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">항목 &lt;code&gt;I&lt;/code&gt; 을 배열의 기본값으로 재설정 합니다. 항목 &lt;code&gt;I&lt;/code&gt; 의 값이 기본값이면 배열이 변경되지 않은 상태로 반환됩니다. Reset은 어레이 크기를 변경하지 않습니다. &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 축소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de1d66243efd40011f5354f807bf4316d6d884bd" translate="yes" xml:space="preserve">
          <source>Resizes a driver binary, while keeping the data.</source>
          <target state="translated">데이터를 유지하면서 드라이버 바이너리의 크기를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="afe06ccb43798e203443a661c67985d4683b2235" translate="yes" xml:space="preserve">
          <source>Resizes a memory block, either in place, or by allocating a new block, copying the data, and freeing the old block. A pointer is returned to the reallocated memory. On failure (out of memory), &lt;code&gt;NULL&lt;/code&gt; is returned. (This is most often a wrapper for &lt;code&gt;realloc&lt;/code&gt;.)</source>
          <target state="translated">메모리 블록의 크기를 조정하거나 새 블록을 할당하고 데이터를 복사하고 이전 블록을 해제합니다. 재 할당 된 메모리로 포인터가 리턴됩니다. 실패시 (메모리 부족) &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. (이것은 대부분 &lt;code&gt;realloc&lt;/code&gt; 래퍼입니다 .)</target>
        </trans-unit>
        <trans-unit id="09d1f73c9252da1107937d4d534d408ca7760aa6" translate="yes" xml:space="preserve">
          <source>Resolves a DNS record of the specified type and class for the specified name.</source>
          <target state="translated">지정된 이름과 지정된 유형에 대한 DNS 레코드의 레코드를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="eba5a7224f57500ffaa0dd3342225d7f10381f82" translate="yes" xml:space="preserve">
          <source>Resolves a DNS record of the specified type and class for the specified name. The returned &lt;code&gt;dns_msg()&lt;/code&gt; can be examined using access functions in &lt;code&gt;inet_db&lt;/code&gt;, as described in section in &lt;code&gt;&lt;a href=&quot;#dns_types&quot;&gt;DNS Types&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 이름과 지정된 유형에 대한 DNS 레코드의 레코드를 확인합니다. 반환 된 &lt;code&gt;dns_msg()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#dns_types&quot;&gt;DNS Types&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 &lt;code&gt;inet_db&lt;/code&gt; 의 액세스 함수를 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e276400129592150e484867e483da18ebb865dd" translate="yes" xml:space="preserve">
          <source>Resolves a DNS record of the specified type for the specified host, of class &lt;code&gt;in&lt;/code&gt;. Returns, on success, a &lt;code&gt;hostent()&lt;/code&gt; record with &lt;code&gt;dns_data()&lt;/code&gt; elements in the address list field.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 의 지정된 호스트에 대해 지정된 유형의 DNS 레코드를 확인합니다 . 성공 하면 주소 목록 필드에 &lt;code&gt;dns_data()&lt;/code&gt; 요소가 있는 &lt;code&gt;hostent()&lt;/code&gt; 레코드를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e255f15dc3b35ddba127b05f853b1bc2a4f1b219" translate="yes" xml:space="preserve">
          <source>Resolves the DNS data for the record of the specified type and class for the specified name. On success, filters out the answer records with the correct &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;, and returns a list of their data fields. So, a lookup for type &lt;code&gt;any&lt;/code&gt; gives an empty answer, as the answer records have specific types that are not &lt;code&gt;any&lt;/code&gt;. An empty answer or a failed lookup returns an empty list.</source>
          <target state="translated">지정된 유형의 레코드 및 지정된 이름의 클래스에 대한 DNS 데이터를 확인합니다. 성공하면 올바른 &lt;code&gt;Class&lt;/code&gt; 및 &lt;code&gt;Type&lt;/code&gt; 으로 응답 레코드를 필터링하고 해당 데이터 필드 목록을 리턴합니다. 그래서, 유형에 대한 조회는 &lt;code&gt;any&lt;/code&gt; 응답 기록이없는 특정 유형의이 같은 빈 대답을 제공합니다 &lt;code&gt;any&lt;/code&gt; . 빈 답변 또는 실패한 조회는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e7209e804399190d5b8e9245f8d82fb88f8ff0c" translate="yes" xml:space="preserve">
          <source>Resource types support upgrade in runtime by allowing a loaded NIF library to take over an already existing resource type and by that &quot;inherit&quot; all existing objects of that type. The destructor of the new library is thereafter called for the inherited objects and the library with the old destructor function can be safely unloaded. Existing resource objects, of a module that is upgraded, must either be deleted or taken over by the new NIF library. The unloading of a library is postponed as long as there exist resource objects with a destructor function in the library.</source>
          <target state="translated">리소스 유형은로드 된 NIF 라이브러리가 이미 존재하는 리소스 유형을 대신하여 해당 유형의 모든 기존 객체를 &quot;상속&quot;함으로써 런타임에서의 업그레이드를 지원합니다. 그 후, 새로운 라이브러리의 소멸자가 상속 된 객체를 요구하고, 이전 소멸자 기능을 가진 라이브러리는 안전하게 언로드 될 수 있습니다. 업그레이드 된 모듈의 기존 자원 객체는 새로운 NIF 라이브러리에 의해 삭제되거나 대체되어야합니다. 라이브러리에 소멸자 함수가있는 자원 객체가있는 한 라이브러리 언로드가 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="0ef0d0d978a116bde33e50341c9e6394cb2893fc" translate="yes" xml:space="preserve">
          <source>Restart call counters for the matching functions in matching modules that are call count traced. The &lt;code&gt;FS&lt;/code&gt; argument can be used to specify the first argument to &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;. See erlang(3).</source>
          <target state="translated">호출 횟수가 추적되는 일치 모듈에서 일치하는 기능에 대한 호출 카운터를 다시 시작하십시오. &lt;code&gt;FS&lt;/code&gt; 의 인수에 대한 첫 번째 인수를 지정하는 데 사용할 수 있습니다 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; . erlang (3)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61c90f456eca86b51d3200d77a1d7f2617f0ddb0" translate="yes" xml:space="preserve">
          <source>Restart the set worker process of a multi-threaded agent.</source>
          <target state="translated">다중 스레드 에이전트의 작업자 설정 프로세스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7e74f2cc20537e216a01ecee1923f294af034529" translate="yes" xml:space="preserve">
          <source>Restart the worker process of a multi-threaded agent.</source>
          <target state="translated">다중 스레드 에이전트의 작업자 프로세스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="dc214e0416b7a580a7af166989fb4bbe4276bbd4" translate="yes" xml:space="preserve">
          <source>Restarting an application is useful when a change is too complicated to be made without restarting the processes, for example, if the supervisor hierarchy has been restructured.</source>
          <target state="translated">예를 들어 감독자 계층 구조가 재구성 된 경우와 같이 프로세스를 다시 시작하지 않고 변경이 너무 복잡 할 경우 응용 프로그램을 다시 시작하면 유용합니다.</target>
        </trans-unit>
        <trans-unit id="78facde3d4d8b32988e630ea196e0d52f90f256d" translate="yes" xml:space="preserve">
          <source>Restarting an application means that the application is stopped and then started again similar to using the instructions &lt;code&gt;remove_application&lt;/code&gt; and &lt;code&gt;add_application&lt;/code&gt; in sequence.</source>
          <target state="translated">응용 프로그램을 다시 시작한다는 것은 &lt;code&gt;remove_application&lt;/code&gt; 및 &lt;code&gt;add_application&lt;/code&gt; 명령 을 순서대로 사용하는 것과 유사하게 응용 프로그램이 중지되었다가 다시 시작됨 을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="98a98cfd0a822c62415063db7432a74158f00a07" translate="yes" xml:space="preserve">
          <source>Restarting an application means that the application is stopped and then started again, similar to using the instructions &lt;code&gt;remove_application&lt;/code&gt; and &lt;code&gt;add_application&lt;/code&gt; in sequence. Note that, even if the application has been started before the release upgrade is performed, &lt;code&gt;restart_application&lt;/code&gt; may only &lt;code&gt;load&lt;/code&gt; it rather than &lt;code&gt;start&lt;/code&gt; it, depending on the application's &lt;code&gt;start type&lt;/code&gt;: If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded. If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">응용 프로그램을 다시 시작한다는 것은 &lt;code&gt;remove_application&lt;/code&gt; 및 &lt;code&gt;add_application&lt;/code&gt; 명령 을 순서대로 사용하는 것과 유사하게 응용 프로그램이 중지되었다가 다시 시작됨 을 의미합니다. 릴리스 업그레이드가 수행되기 전에 응용 프로그램이 시작된 경우에도 &lt;code&gt;restart_application&lt;/code&gt; 은 응용 프로그램의 &lt;code&gt;start type&lt;/code&gt; 에 따라 &lt;code&gt;start&lt;/code&gt; 하지 않고 &lt;code&gt;load&lt;/code&gt; 만 할 수 있습니다 . &lt;code&gt;Type = load&lt;/code&gt; 인 경우 응용 프로그램 만로드됩니다. &lt;code&gt;Type = none&lt;/code&gt; 인 경우 해당 모듈의 코드가로드되었지만 응용 프로그램이로드되지 않고 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2de62cc3a4bd25c5d36ad0d8cc488270e5a0abd1" translate="yes" xml:space="preserve">
          <source>Restarts the call counters from zero for specified functions. Can be used to collect a new set of counters without having to stop and start call count profiling.</source>
          <target state="translated">지정된 기능에 대해 콜 카운터를 0에서 다시 시작합니다. 통화 카운트 프로파일 링을 중지하고 시작하지 않고도 새로운 카운터 세트를 수집하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b939c958cae308cd1ce8394371dead14ecaa1d6" translate="yes" xml:space="preserve">
          <source>Restore previous configuration by maintaining a history buffer and handling configuration files.</source>
          <target state="translated">히스토리 버퍼를 유지하고 구성 파일을 처리하여 이전 구성을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="3733a2a68fd7503fd11786ec56d8016b0a108fe2" translate="yes" xml:space="preserve">
          <source>Restores an opaque continuation returned by &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; if the continuation has passed through external term format (been sent between nodes or stored on disk).</source>
          <target state="translated">연속이 외부 용어 형식 (노드간에 전송되거나 디스크에 저장 됨)을 통과 한 경우 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 불투명 연속을 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="4f3f20018aa0040e4c23d84e3c7950b3527b5bdd" translate="yes" xml:space="preserve">
          <source>Restores previously saved data to the server.</source>
          <target state="translated">이전에 저장된 데이터를 서버로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="9fd2af0db43c49aa55ce334c12e957767a3ccb8b" translate="yes" xml:space="preserve">
          <source>Restores the previous state of user tags and their spreading as it was before a call to &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt;. Note that the restoring is not limited to the same process, one can utilize this to turn off spreding in one process and restore it in a newly created, the one that actually is going to send messages:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt; 호출하기 전의 상태와 사용자 태그의 이전 상태를 복원합니다 . 복원은 동일한 프로세스로 제한되지 않으며,이를 사용하여 한 프로세스에서 스프 레딩을 끄고 실제로 메시지를 보낼 새로 생성 된 프로세스에서 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fac283093b6a2a509402c8c0582786b4a2bfd78" translate="yes" xml:space="preserve">
          <source>RestrOp ::= &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">RestrOp :: = &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7dd86ea16702f2798d2509aeac3e281b6a70f1b" translate="yes" xml:space="preserve">
          <source>RestrOp ::= &lt;code&gt;||&lt;/code&gt;</source>
          <target state="translated">RestrOp :: = &lt;code&gt;||&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc7c10d01aae72be16a86c0f638ea9cf021214b5" translate="yes" xml:space="preserve">
          <source>RestrOp ::= &lt;code&gt;|||&lt;/code&gt;</source>
          <target state="translated">RestrOp :: = &lt;code&gt;|||&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfa4191a9eae6ca9165e4fa4ff48bbaff74e299e" translate="yes" xml:space="preserve">
          <source>Restricts the socket to use only IPv6, prohibiting any IPv4 connections. This is only applicable for IPv6 sockets (option &lt;code&gt;inet6&lt;/code&gt;).</source>
          <target state="translated">소켓이 IPv6 만 사용하도록 제한하여 IPv4 연결을 금지합니다. 이것은 IPv6 소켓에만 적용됩니다 (옵션 &lt;code&gt;inet6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="fad7e8f89b3044f680980534cc7f38eb45d77455" translate="yes" xml:space="preserve">
          <source>Result = 0 -&amp;gt; ok, result &amp;gt; 0 -&amp;gt; error.</source>
          <target state="translated">결과 = 0-&amp;gt; 확인, 결과&amp;gt; 0-&amp;gt; 오류.</target>
        </trans-unit>
        <trans-unit id="72c3908300e570c710533b083bcfd239361ca5b4" translate="yes" xml:space="preserve">
          <source>Result code 4003 is sent in CEA if there is an existing connection to the peer in question and configuration does not allow more than one.</source>
          <target state="translated">해당 피어에 대한 기존 연결이 있고 구성에서 둘 이상을 허용하지 않는 경우 결과 코드 4003이 CEA로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b1380f2ff1e7ff28281bc2b3937da790713a4a29" translate="yes" xml:space="preserve">
          <source>Result codes 3001, 3002, 3005, and 3007 can be sent in answers formulated by diameter, if configured to do so.</source>
          <target state="translated">결과 코드 3001, 3002, 3005 및 3007은 구성된 경우 직경별로 공식화 된 답변으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdb45e9d6b5679ea0ed96f1d5bfeae12bb8e898" translate="yes" xml:space="preserve">
          <source>Result-Code AVP</source>
          <target state="translated">결과 코드 AVP</target>
        </trans-unit>
        <trans-unit id="da7c61f4348e14cf89c824561d092db5c3023fcb" translate="yes" xml:space="preserve">
          <source>Result-Code AVP Values</source>
          <target state="translated">결과 코드 AVP 값</target>
        </trans-unit>
        <trans-unit id="0a0db2d8653e2bdb24b4ddd06733b9ef033724a6" translate="yes" xml:space="preserve">
          <source>Results are written to file (excel compatible text files) and on stdout.</source>
          <target state="translated">결과는 파일 (Excel 호환 텍스트 파일) 및 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1e28cf400ace7a0cf6a58fff614aab265e55e1" translate="yes" xml:space="preserve">
          <source>Results in a OS call to:</source>
          <target state="translated">다음에 대한 OS 호출 결과 :</target>
        </trans-unit>
        <trans-unit id="92266fcdf49cd88ae3cb55b7500e16b861e0f8f8" translate="yes" xml:space="preserve">
          <source>Resume the processes.</source>
          <target state="translated">프로세스를 재개하십시오.</target>
        </trans-unit>
        <trans-unit id="e18f16b3b88e1efaab280687e97a380ca884e44f" translate="yes" xml:space="preserve">
          <source>Resumes a suspended process.</source>
          <target state="translated">일시 중단 된 프로세스를 재개합니다.</target>
        </trans-unit>
        <trans-unit id="f14bdb1234c7ed01c49eaf26a7e322a0b85afcbe" translate="yes" xml:space="preserve">
          <source>Resumes all suspended processes using a module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;Mod&lt;/code&gt; 를 사용하여 일시 중단 된 모든 프로세스를 재개합니다 .</target>
        </trans-unit>
        <trans-unit id="17c7293f799309379456316dabcac2397077e454" translate="yes" xml:space="preserve">
          <source>Resumes process execution for &lt;code&gt;Pid&lt;/code&gt; or &lt;code&gt;c:pid(X,Y,Z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 또는 &lt;code&gt;c:pid(X,Y,Z)&lt;/code&gt; 대한 프로세스 실행을 재개합니다 .</target>
        </trans-unit>
        <trans-unit id="baa6efb2f790bdb132e3741e6aa4b131129c8c15" translate="yes" xml:space="preserve">
          <source>Retains the statistics of destroyed locks.</source>
          <target state="translated">파괴 된 잠금 통계를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="5cc03bdcfe4904c6966e4b5da63b22275bcbe022" translate="yes" xml:space="preserve">
          <source>Retreive all the sdp records of type &lt;code&gt;Type&lt;/code&gt; from the property group &lt;code&gt;PG&lt;/code&gt;.</source>
          <target state="translated">특성 그룹 &lt;code&gt;PG&lt;/code&gt; 에서 유형 &lt;code&gt;Type&lt;/code&gt; 의 모든 sdp 레코드 를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="02febca237ef746057d21ace8518a1c006a9c4b9" translate="yes" xml:space="preserve">
          <source>Retreive the (SNMP) statistic counters maintained by the megaco application. The global counters handle events that cannot be attributed to a single connection (e.g. protocol errors that occur before the connection has been properly setup).</source>
          <target state="translated">megaco 응용 프로그램에서 유지 관리하는 (SNMP) 통계 카운터를 검색하십시오. 글로벌 카운터는 단일 연결로 인해 발생할 수없는 이벤트 (예 : 연결이 올바르게 설정되기 전에 발생하는 프로토콜 오류)를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fa70701bc77c29039a4b681cd1ced4c75c07e003" translate="yes" xml:space="preserve">
          <source>Retreive the TCP related (SNMP) statistics counters.</source>
          <target state="translated">TCP 관련 (SNMP) 통계 카운터를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="8d7ef75f058aa1cf6b07567ad7ff04b3417d35fb" translate="yes" xml:space="preserve">
          <source>Retreive the UDP related (SNMP) statistics counters.</source>
          <target state="translated">UDP 관련 (SNMP) 통계 카운터를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="7151989dd8e6c94f234c2f32661137cfebef0084" translate="yes" xml:space="preserve">
          <source>Retreive the size of the mib server cache.</source>
          <target state="translated">mib 서버 캐시의 크기를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="4b31fb756dce544f130f19b8dad2c90736d11a83" translate="yes" xml:space="preserve">
          <source>Retreive the type (asn1 bertype) of an oid.</source>
          <target state="translated">OID의 유형 (asn1 bertype)을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="a066518d0b87d9a981cc76dfb930b0b065ce9302" translate="yes" xml:space="preserve">
          <source>Retrieve Erlang System Time</source>
          <target state="translated">Erlang 시스템 시간 검색</target>
        </trans-unit>
        <trans-unit id="9d19fa4433634e8f7f0044b8f7171e217dfed550" translate="yes" xml:space="preserve">
          <source>Retrieve agent config.</source>
          <target state="translated">에이전트 구성을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3acc64305dc86f6d79205ab898062e15ca0a37ff" translate="yes" xml:space="preserve">
          <source>Retrieve all alias-names known to the agent.</source>
          <target state="translated">에이전트에 알려진 모든 별명을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="2134b573a854d0e886332caabf7da925b7e53ab2" translate="yes" xml:space="preserve">
          <source>Retrieve all loaded mib-files.</source>
          <target state="translated">로드 된 모든 mib 파일을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="1147438c0e44be971748704321067492f033f625" translate="yes" xml:space="preserve">
          <source>Retrieve all notifications (and traps) known to the agent.</source>
          <target state="translated">에이전트에 알려진 모든 알림 (및 트랩)을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="fadeb4e61b2e973528a9b28b3ff09f86b61edc47" translate="yes" xml:space="preserve">
          <source>Retrieve all tables known to the agent.</source>
          <target state="translated">에이전트에 알려진 모든 테이블을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="fce5ac6430e5aaacbba5d6b3b19663ec99641f54" translate="yes" xml:space="preserve">
          <source>Retrieve all variables known to the agent.</source>
          <target state="translated">에이전트에 알려진 모든 변수를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="1bdc580cb2514729314f5603353f80c0bbf0c5c6" translate="yes" xml:space="preserve">
          <source>Retrieve data set with &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt; 로 데이터 세트를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d69480abf5e824d94bacf05e6e59333596eae5f" translate="yes" xml:space="preserve">
          <source>Retrieve implementation dependent mib-storage table information.</source>
          <target state="translated">구현 종속 밉 스토리지 테이블 정보를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="c4acb468e368837beb0ba41c4f9baf884236d501" translate="yes" xml:space="preserve">
          <source>Retrieve misc info for the mib data.</source>
          <target state="translated">mib 데이터에 대한 기타 정보를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="95b30a24349787eb347b2a0cdc30747002d1ce85" translate="yes" xml:space="preserve">
          <source>Retrieve the encoding-config and when initiating the &lt;code&gt;megaco_receive_handle&lt;/code&gt;, set the field &lt;code&gt;encoding_config&lt;/code&gt; accordingly.</source>
          <target state="translated">encoding-config를 검색하고 &lt;code&gt;megaco_receive_handle&lt;/code&gt; 을 시작할 때 &lt;code&gt;encoding_config&lt;/code&gt; 필드를 적절하게 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f599f26a74119290164e57387a0798ea103824b0" translate="yes" xml:space="preserve">
          <source>Retrieve the encoding-config using the &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; function (with &lt;code&gt;Item = text_config&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;Item = text_config&lt;/code&gt; )를 사용하여 encoding-config를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e5761ee307c8026ca4f761f940f2b961da0dd03" translate="yes" xml:space="preserve">
          <source>Retrieve the list of all the mibs loaded into this agent. Default is the master agent.</source>
          <target state="translated">이 에이전트에로드 된 모든 밉 목록을 검색하십시오. 기본은 마스터 에이전트입니다.</target>
        </trans-unit>
        <trans-unit id="8fb723c2fa9c15cbf7e40bed085d2e51be38564e" translate="yes" xml:space="preserve">
          <source>Retrieve the mib file for the mib.</source>
          <target state="translated">mib의 mib 파일을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3c2eaccb5619264e34509fb47435f523adc8579d" translate="yes" xml:space="preserve">
          <source>Retrieve the mib-file to which an given &lt;code&gt;oid()&lt;/code&gt; belongs.</source>
          <target state="translated">주어진 &lt;code&gt;oid()&lt;/code&gt; 속하는 mib 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce97c7b119f622a84d3bd15681ec77eab484e0f" translate="yes" xml:space="preserve">
          <source>Retrieve usm user config.</source>
          <target state="translated">usm 사용자 구성을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="f971d95474a7aaf7ba0a3a08e8e1bb54f6e0db8d" translate="yes" xml:space="preserve">
          <source>Retrieves a list of all known global names.</source>
          <target state="translated">알려진 모든 전역 이름의 목록을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="77f059fe18a8998fe23607cd9d9f051918562790" translate="yes" xml:space="preserve">
          <source>Retrieves a list of all values on the current key. The values have types corresponding to the registry types, see &lt;code&gt;&lt;a href=&quot;#value-2&quot;&gt;value/2&lt;/a&gt;&lt;/code&gt;. Calls the Win32 API function &lt;code&gt;EnumRegValuesEx()&lt;/code&gt;.</source>
          <target state="translated">현재 키의 모든 값 목록을 검색합니다. 값은 레지스트리 유형에 해당하는 유형을 갖습니다 ( &lt;code&gt;&lt;a href=&quot;#value-2&quot;&gt;value/2&lt;/a&gt;&lt;/code&gt; 참조) . Win32 API 함수 &lt;code&gt;EnumRegValuesEx()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2be5bbae4bd62f61c8d1df623c4813ba30080529" translate="yes" xml:space="preserve">
          <source>Retrieves configuration stored with &lt;code&gt;write_config(Data)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write_config(Data)&lt;/code&gt; 저장된 구성을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="b59675caaf402ed44ac06666148753ec422a80b1" translate="yes" xml:space="preserve">
          <source>Retrieves information about a connection. The list &lt;code&gt;Keys&lt;/code&gt; defines which information that is returned.</source>
          <target state="translated">연결에 대한 정보를 검색합니다. 목록 &lt;code&gt;Keys&lt;/code&gt; 는 반환되는 정보를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c62fd3c8db94f2ecb5d2fae829a42891b9817f97" translate="yes" xml:space="preserve">
          <source>Retrieves information about a file. Returns &lt;code&gt;{ok, FileInfo}&lt;/code&gt; if successful, otherwise &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;FileInfo&lt;/code&gt; is a record &lt;code&gt;file_info&lt;/code&gt;, defined in the Kernel include file &lt;code&gt;file.hrl&lt;/code&gt;. Include the following directive in the module from which the function is called:</source>
          <target state="translated">파일에 대한 정보를 검색합니다. 반환 &lt;code&gt;{ok, FileInfo}&lt;/code&gt; 성공하면, 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; . &lt;code&gt;FileInfo&lt;/code&gt; 기록이다 &lt;code&gt;file_info&lt;/code&gt; 커널에 정의는, 파일 포함 &lt;code&gt;file.hrl&lt;/code&gt; 을 . 함수가 호출되는 모듈에 다음 지시문을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="fe76411933e9e2e81fdcf0338d7957f7bda42a01" translate="yes" xml:space="preserve">
          <source>Retrieves information about a file. Returns &lt;code&gt;{ok, FileInfo}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;FileInfo&lt;/code&gt; is a record &lt;code&gt;file_info&lt;/code&gt;, defined in the Kernel include file &lt;code&gt;file.hrl&lt;/code&gt;. Include the following directive in the module from which the function is called:</source>
          <target state="translated">파일에 대한 정보를 검색합니다. 성공하면 &lt;code&gt;{ok, FileInfo}&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 리턴 합니다. &lt;code&gt;FileInfo&lt;/code&gt; 기록이다 &lt;code&gt;file_info&lt;/code&gt; 커널에 정의는, 파일 포함 &lt;code&gt;file.hrl&lt;/code&gt; 을 . 함수가 호출되는 모듈에 다음 지시문을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="d2276be2f2c3029568caafee6e887d81c617a51b" translate="yes" xml:space="preserve">
          <source>Retrieves information about the C-node. These values are initially set with &lt;code&gt;erl_connect_init()&lt;/code&gt; or &lt;code&gt;erl_connect_xinit()&lt;/code&gt;.</source>
          <target state="translated">C 노드에 대한 정보를 검색합니다. 이 값은 초기에 &lt;code&gt;erl_connect_init()&lt;/code&gt; 또는 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec85b06183feb13e2594732aca3a501dd9750a6" translate="yes" xml:space="preserve">
          <source>Retrieves the binding of &lt;code&gt;Var&lt;/code&gt;. This function is intended to be used by the conditional function of a breakpoint.</source>
          <target state="translated">&lt;code&gt;Var&lt;/code&gt; 바인딩을 검색합니다 . 이 기능은 중단 점의 조건부 기능에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="952c5ae51d3a297be343234997d87d013a82d0b3" translate="yes" xml:space="preserve">
          <source>Retrieves the driver queue as a pointer to an array of &lt;code&gt;SysIOVec&lt;/code&gt;s. It also returns the number of elements in &lt;code&gt;vlen&lt;/code&gt;. This is one of two ways to get data out of the queue.</source>
          <target state="translated">&lt;code&gt;SysIOVec&lt;/code&gt; 배열에 대한 포인터로 드라이버 큐를 검색합니다 . 또한 &lt;code&gt;vlen&lt;/code&gt; 의 요소 수를 반환합니다 . 이것은 큐에서 데이터를 가져 오는 두 가지 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="c07292a4b963b263d1b6cc1646b4c6d5902c86d7" translate="yes" xml:space="preserve">
          <source>Retrieves the driver queue into a supplied &lt;code&gt;ErlIOVec&lt;/code&gt;&lt;code&gt;ev&lt;/code&gt;. It also returns the queue size. This is one of two ways to get data out of the queue.</source>
          <target state="translated">제공된 &lt;code&gt;ErlIOVec&lt;/code&gt; &lt;code&gt;ev&lt;/code&gt; 로 드라이버 큐를 검색합니다 . 또한 대기열 크기를 반환합니다. 이것은 큐에서 데이터를 가져 오는 두 가지 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="a894c3ff79393666e5c7b22a004ebacc352e97d6" translate="yes" xml:space="preserve">
          <source>Retrieves the named value (or default) on the current key. Registry values of type &lt;code&gt;REG_SZ&lt;/code&gt; are returned as strings. Type &lt;code&gt;REG_DWORD&lt;/code&gt; values are returned as integers. All other types are returned as binaries.</source>
          <target state="translated">현재 키에서 이름이 지정된 값 (또는 기본값)을 검색합니다. &lt;code&gt;REG_SZ&lt;/code&gt; 유형의 레지스트리 값은 문자열로 반환됩니다. 유형 &lt;code&gt;REG_DWORD&lt;/code&gt; 값은 정수로 반환됩니다. 다른 모든 유형은 이진으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="245670a16c43ecee47979e6d1e5f4fdfc89b0df2" translate="yes" xml:space="preserve">
          <source>Retrieves the names of all files in the tar file &lt;code&gt;Name&lt;/code&gt;.</source>
          <target state="translated">tar 파일 &lt;code&gt;Name&lt;/code&gt; 의 모든 파일 이름을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="d564b671e170b3431e838ae67d5ab7768b72f2e4" translate="yes" xml:space="preserve">
          <source>Retrieves the number of columns of the &lt;code&gt;IoDevice&lt;/code&gt; (that is, the width of a terminal). The function succeeds for terminal devices and returns &lt;code&gt;{error, enotsup}&lt;/code&gt; for all other I/O devices.</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 의 열 수 (즉, 터미널 너비)를 검색합니다. 이 기능은 터미널 장치에 성공 하고 다른 모든 I / O 장치에 대해 &lt;code&gt;{error, enotsup}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e778e49b2d71c140dcdf03681dbceb1ae0cc20b4" translate="yes" xml:space="preserve">
          <source>Retrieves the number of rows of &lt;code&gt;IoDevice&lt;/code&gt; (that is, the height of a terminal). The function only succeeds for terminal devices, for all other I/O devices the function returns &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IoDevice&lt;/code&gt; 의 행 수 (즉, 터미널의 높이)를 검색합니다. 이 기능은 터미널 장치, 다른 모든 I / O 장치의 &lt;code&gt;{error, enotsup}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0bb6456edb698b942587d5fb778ec0a6722ce718" translate="yes" xml:space="preserve">
          <source>Retrieves the options currently used by the client.</source>
          <target state="translated">클라이언트가 현재 사용하는 옵션을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="76466246f8a47a437b9e1621604ae79ee0d8b373" translate="yes" xml:space="preserve">
          <source>Retrieves the pid of the C-node. Every C-node has a (pseudo) pid used in &lt;code&gt;ei_send_reg&lt;/code&gt;, &lt;code&gt;ei_rpc&lt;/code&gt;, and others. This is contained in a field in the &lt;code&gt;ec&lt;/code&gt; structure. It will be safe for a long time to fetch this field directly from the &lt;code&gt;ei_cnode&lt;/code&gt; structure.</source>
          <target state="translated">C 노드의 pid를 검색합니다. 모든 C 노드에는 &lt;code&gt;ei_send_reg&lt;/code&gt; , &lt;code&gt;ei_rpc&lt;/code&gt; 등에서 사용되는 (의사) pid가 있습니다. 이것은 &lt;code&gt;ec&lt;/code&gt; 구조 의 필드에 포함됩니다 . &lt;code&gt;ei_cnode&lt;/code&gt; 구조 에서이 필드를 직접 가져 오는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="aabdb36347cbaff97e37db5db212dc599e8b84b1" translate="yes" xml:space="preserve">
          <source>Retrieves the value of an environment variable.</source>
          <target state="translated">환경 변수의 값을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5a702c3a25b2ca721ccd72b7aec2133da01de553" translate="yes" xml:space="preserve">
          <source>Retrieves the value stored with &lt;code&gt;Key&lt;/code&gt; in &lt;code&gt;Tree&lt;/code&gt;. Assumes that the key is present in the tree, crashes otherwise.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; in &lt;code&gt;Tree&lt;/code&gt; 로 저장된 값을 검색합니다 . 키가 트리에 있다고 가정하고 그렇지 않으면 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="59fedfa91c0565ade05984a3af8146c0a81048c8" translate="yes" xml:space="preserve">
          <source>Retrieving data from DBMS is usually to be done with the functions &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#read-2&quot;&gt;mnesia:read/1&lt;/a&gt;&lt;/code&gt;. The following function raises the salary:</source>
          <target state="translated">DBMS에서 데이터 검색은 일반적으로 &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#read-2&quot;&gt;mnesia:read/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 수행됩니다 . 다음 함수는 급여를 올립니다.</target>
        </trans-unit>
        <trans-unit id="d886a95270a0b97b770f611dbef1f5da0d79dcec" translate="yes" xml:space="preserve">
          <source>Retrieving/generating the response.</source>
          <target state="translated">응답 검색 / 생성</target>
        </trans-unit>
        <trans-unit id="cc15ba53eed9cac3cb103f31237c1c8cb9da235a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;Token&lt;/code&gt; and is last token in a tokens call.</source>
          <target state="translated">리턴 &lt;code&gt;Token&lt;/code&gt; 이며 토큰 호출에서 마지막 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="96fed125f9b4a3ff4eafa9dc4ab9f431753358e2" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;Token&lt;/code&gt; to the caller.</source>
          <target state="translated">발신자에게 &lt;code&gt;Token&lt;/code&gt; 을 반환 하십시오.</target>
        </trans-unit>
        <trans-unit id="1a1c978f872f3e9d4cbb152e995b6529af78529a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the host name part of the &lt;code&gt;NodeName&lt;/code&gt; is valid for use with this protocol; otherwise, &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NodeName&lt;/code&gt; 의 호스트 이름 부분 이이 프로토콜에 사용하기에 유효한 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 하십시오 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c835ade1ee058ea2528895c15193d9d02d86145e" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the module has native compiled code. Return &lt;code&gt;false&lt;/code&gt; otherwise. In a system compiled without HiPE support, the result is always &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">모듈에 네이티브 컴파일 코드가있는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 하십시오. 돌아 &lt;code&gt;false&lt;/code&gt; 이 없습니다. HiPE 지원없이 컴파일 된 시스템에서 결과는 항상 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13532ab427d3f5c254e071d7934ca748721f8b88" translate="yes" xml:space="preserve">
          <source>Return a &lt;code&gt;{{Counter, Ref}, non_neg_integer()}&lt;/code&gt; list of counter values. &lt;code&gt;Ref&lt;/code&gt; can be either a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or a &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt;. Entries for the latter are folded into corresponding entries for the former as peer connections go down. Entries for both are removed at &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;. The Diameter-level statistics returned by &lt;code&gt;transport&lt;/code&gt; and &lt;code&gt;connections&lt;/code&gt; info are based upon these entries.</source>
          <target state="translated">카운터 값 의 &lt;code&gt;{{Counter, Ref}, non_neg_integer()}&lt;/code&gt; 목록을 반환 합니다. &lt;code&gt;Ref&lt;/code&gt; 는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; 있습니다. 피어 연결이 끊어지면 후자의 항목이 전자의 해당 항목으로 접 힙니다. 두 항목 모두 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 에서 제거됩니다 . &lt;code&gt;transport&lt;/code&gt; 및 &lt;code&gt;connections&lt;/code&gt; 정보가 반환 한 직경 수준 통계는 이러한 항목을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="1bb16078b0f2378184a73700819de4ceef71e2e5" translate="yes" xml:space="preserve">
          <source>Return a capability value as configured with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 구성된 기능 값을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="9536f6bbba6fdc1b7d0b454be9dde8f6750a2209" translate="yes" xml:space="preserve">
          <source>Return a list containing one entry for each of the service's transport as configured with &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. Each entry is a tagged list containing both configuration and information about established peer connections. An example return value with for a client service with Origin-Host &quot;client.example.com&quot; configured with a single transport connected to &quot;server.example.com&quot; might look as follows.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 로 구성된 각 서비스 전송에 대해 하나의 항목이 포함 된 목록을 리턴하십시오 . 각 항목은 설정된 피어 연결에 대한 구성 및 정보가 모두 포함 된 태그가 지정된 목록입니다. &quot;server.example.com&quot;에 연결된 단일 전송으로 구성된 Origin-Host &quot;client.example.com&quot;이있는 클라이언트 서비스에 대한 반환 값 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3714b9f4dba0aac8c1334a0e9085f3405a08f7a" translate="yes" xml:space="preserve">
          <source>Return a list containing one entry for every established transport connection whose watchdog state machine is not in the &lt;code&gt;down&lt;/code&gt; state. This is a flat view of &lt;code&gt;transport&lt;/code&gt; info which lists only active connections and for which Diameter-level statistics are accumulated only for the lifetime of the transport connection. A return value for the server above might look as follows.</source>
          <target state="translated">워치 독 상태 머신이 &lt;code&gt;down&lt;/code&gt; 상태 가 아닌 모든 확립 된 전송 연결에 대해 하나의 항목을 포함하는 목록을 리턴하십시오 . 이것은 활성 연결 만 나열하고 &lt;code&gt;transport&lt;/code&gt; 수준의 수명 동안 만 지름 수준 통계가 누적되는 전송 정보 의 평면보기입니다 . 위의 서버에 대한 반환 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db261cceb040f1c9828fe3d4c6c1a35462982fe0" translate="yes" xml:space="preserve">
          <source>Return a reasonable value for use as Origin-State-Id in outgoing messages.</source>
          <target state="translated">발신 메시지에서 Origin-State-Id로 ​​사용할 적절한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b57b27e4df9b1ae0072d43165d38c155eb66de4" translate="yes" xml:space="preserve">
          <source>Return a scheduler utilization sample for all schedulers, including dirty-io schedulers.</source>
          <target state="translated">dirty-io 스케줄러를 포함한 모든 스케줄러에 대한 스케줄러 사용 샘플을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="e48ca14d3d26b2f077fe65868bb3fe756cfe0117" translate="yes" xml:space="preserve">
          <source>Return a scheduler utilization sample for normal and dirty-cpu schedulers.</source>
          <target state="translated">정상 및 더티 CPU 스케줄러에 대한 스케줄러 사용 샘플을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="189e6f742d0287bea7092b8b595dda21405a8676" translate="yes" xml:space="preserve">
          <source>Return a specification of the target system. The actual target system can be created with &lt;code&gt;reltool:eval_target_spec/3&lt;/code&gt;.</source>
          <target state="translated">대상 시스템의 사양을 돌려줍니다. 실제 대상 시스템은 &lt;code&gt;reltool:eval_target_spec/3&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2aa7025ff201afee814f6c2a93ae1bcb0ae4ca05" translate="yes" xml:space="preserve">
          <source>Return a table handle.</source>
          <target state="translated">테이블 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f2413dd20c0e576107037d6e42aeba92e71c7df" translate="yes" xml:space="preserve">
          <source>Return a tagged list of all capabilities values as configured with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 구성된 모든 기능 값의 태그가 지정된 목록을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8294e0b56eeb80e5eba4768dcc17c3d64870430" translate="yes" xml:space="preserve">
          <source>Return a the identity of the globally registered collector if there is any.</source>
          <target state="translated">글로벌 등록 콜렉터의 ID가있는 경우이를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9f6b885db67cca106a9b569ccd725228af91846d" translate="yes" xml:space="preserve">
          <source>Return a value for a Session-Id AVP.</source>
          <target state="translated">Session-Id AVP의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba6a05dfc89724422c5b71e06eeac07f56af24ec" translate="yes" xml:space="preserve">
          <source>Return all records in the mib-storage table in the form of a list.</source>
          <target state="translated">mib-storage 테이블의 모든 레코드를 목록 형식으로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="c8a7afda668c35cdafcb1e64da708b8cf8d41b06" translate="yes" xml:space="preserve">
          <source>Return an ordered list of the metavariables in the template.</source>
          <target state="translated">템플릿에서 순서화 된 메타 변수 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f4c3667b1add8d5e02e30fe75d8033f0bfc2e96" translate="yes" xml:space="preserve">
          <source>Return comment tokens.</source>
          <target state="translated">댓글 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="785922d0c7990e6a6337740a8132f1efba76556b" translate="yes" xml:space="preserve">
          <source>Return compiler options given via the environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt;. If the value is a list, it is returned as is. If it is not a list, it is put into a list.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 를 통해 제공된 컴파일러 옵션을 리턴 하십시오 . 값이 목록이면 그대로 반환됩니다. 목록이 아닌 경우 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4afe5c3542f3f32911baf31fbf610eaf8e8a9d8d" translate="yes" xml:space="preserve">
          <source>Return information about a started service. Requesting info for an unknown service causes &lt;code&gt;undefined&lt;/code&gt; to be returned. Requesting a list of items causes a tagged list to be returned.</source>
          <target state="translated">시작된 서비스에 대한 정보를 반환합니다. 알 수없는 서비스에 대한 정보를 요청하면 &lt;code&gt;undefined&lt;/code&gt; 가 반환됩니다. 항목 목록을 요청하면 태그가 지정된 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd34f9aa0dee036d0db04e93eacf17e6bece459" translate="yes" xml:space="preserve">
          <source>Return node names held by the registrar for the given host.</source>
          <target state="translated">주어진 호스트에 대한 등록자가 보유한 노드 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="996ea5173163b123ed6a043649459919ca914183" translate="yes" xml:space="preserve">
          <source>Return only &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; integer corresponding to creation time.</source>
          <target state="translated">생성 시간에 해당하는 &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 정수만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="73fec507617851a521471bf50b4848c38830e262" translate="yes" xml:space="preserve">
          <source>Return only positive integers.</source>
          <target state="translated">양의 정수만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c2362dda30d47eb99dd0cab5c2b8fa38f869f8c" translate="yes" xml:space="preserve">
          <source>Return results in a &lt;code&gt;{ok, [Out]}&lt;/code&gt; tuple instead of writing to file and returning &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">파일에 쓰고 &lt;code&gt;ok&lt;/code&gt; 를 반환하는 대신 &lt;code&gt;{ok, [Out]}&lt;/code&gt; 튜플에 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6d34509ab6610cf83be325f59f6c39943cfea5" translate="yes" xml:space="preserve">
          <source>Return the address of the given node. If not implemented, &lt;code&gt;inet:gethostbyname/1&lt;/code&gt; will be used instead</source>
          <target state="translated">주어진 노드의 주소를 반환합니다. 구현되지 않은 경우 &lt;code&gt;inet:gethostbyname/1&lt;/code&gt; 이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="292859966a655edc4054e4f1076d2fed6b650843" translate="yes" xml:space="preserve">
          <source>Return the defining parameters of a elliptic curve.</source>
          <target state="translated">타원 곡선의 정의 매개 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08d6beff9271fb403fee80042fc6e6442d0f5864" translate="yes" xml:space="preserve">
          <source>Return the distribution port used by the given node.</source>
          <target state="translated">주어진 노드가 사용하는 배포 포트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="026ca738a4e24775b52601dc015e85dbf9838772" translate="yes" xml:space="preserve">
          <source>Return the list of applications as configured with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 구성된 애플리케이션 목록을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="8760f4dfa12986348ea3b742e129cc7f36b461e8" translate="yes" xml:space="preserve">
          <source>Return the list of body subtrees of a &lt;code&gt;clause&lt;/code&gt; node.</source>
          <target state="translated">&lt;code&gt;clause&lt;/code&gt; 노드 의 본문 하위 트리 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="415e4cccd2b2511ca9972eccc4412def66ed17df" translate="yes" xml:space="preserve">
          <source>Return the list of started services.</source>
          <target state="translated">시작된 서비스 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="869a332a11dcce537fc74b533f9961fb120feb39" translate="yes" xml:space="preserve">
          <source>Return the number of matching functions that can have call count breakpoints, the same as &lt;code&gt;start/0..3&lt;/code&gt; with the same arguments would have returned.</source>
          <target state="translated">콜백 중단 점을 가질 수있는 일치 함수의 수를 리턴하십시오. 동일한 인수를 가진 &lt;code&gt;start/0..3&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="545eef5a0d17878bc6d57549235644bab28f7ff8" translate="yes" xml:space="preserve">
          <source>Return the number of matching functions that has got call count breakpoints.</source>
          <target state="translated">호출 횟수 중단 점을 가진 일치하는 함수 수를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6ecb156241944c24df7a613253421fdcbcc3e0d5" translate="yes" xml:space="preserve">
          <source>Return the process identifier of the server process.</source>
          <target state="translated">서버 프로세스의 프로세스 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="596033205682a5c5f39f8c045be421baf09bdbad" translate="yes" xml:space="preserve">
          <source>Return transport configuration associated with a single peer, as passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. The returned list is empty if the peer is unknown. Otherwise it contains the &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; tuples as in &lt;code&gt;transport&lt;/code&gt; and &lt;code&gt;connections&lt;/code&gt; info above. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 에 전달 된 단일 피어와 연관된 전송 구성을 리턴하십시오 . 피어를 알 수 없으면 리턴 된 목록이 비어 있습니다. 그렇지 않으면 위의 &lt;code&gt;transport&lt;/code&gt; 및 &lt;code&gt;connections&lt;/code&gt; 정보 와 같이 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 튜플이 포함됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b25b7bff97770cbd71aa2bcb0ba6cc19819e76b" translate="yes" xml:space="preserve">
          <source>Return true if &lt;code&gt;term&lt;/code&gt; is an exception.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 가 예외 인 경우 true를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="18d44aa00d4d2f1a0de4ecac8687cabb586ac03d" translate="yes" xml:space="preserve">
          <source>Return value from an &lt;code&gt;ssh_sftp&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ssh_sftp&lt;/code&gt; 함수 에서 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3163d3a67f9c0a3df18a0b32a1848d46a7cae484" translate="yes" xml:space="preserve">
          <source>Return value from the start functions, for example, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작 함수에서 반환 값, 예를 들어, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d184302be65b0501c434c989ce960b469d8ab2e9" translate="yes" xml:space="preserve">
          <source>Return value is &lt;code&gt;0&lt;/code&gt;, unless the &lt;code&gt;timeout&lt;/code&gt; driver function is &lt;code&gt;NULL&lt;/code&gt;, in which case it is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 드라이버 함수가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 리턴 값은 &lt;code&gt;0&lt;/code&gt; 이며, 이 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff216a94df439e2821ca3664b457f212cf962310" translate="yes" xml:space="preserve">
          <source>Return white space tokens. By convention, a newline character, if present, is always the first character of the text (there cannot be more than one newline in a white space token).</source>
          <target state="translated">공백 토큰을 반환합니다. 일반적으로 줄 바꿈 문자는있는 경우 항상 텍스트의 첫 번째 문자입니다 (공백 토큰에는 둘 이상의 줄 바꿈 문자가있을 수 없음).</target>
        </trans-unit>
        <trans-unit id="0a0f9ea4537c829f189c17c1388dd83d2074333e" translate="yes" xml:space="preserve">
          <source>ReturnFormat) -&amp;gt;</source>
          <target state="translated">ReturnFormat)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e8872950120a8fda0116e4eeb516842552c69925" translate="yes" xml:space="preserve">
          <source>Returned by &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0b4bbed1147880ab3fa88ace211606ff099dbee" translate="yes" xml:space="preserve">
          <source>Returned by the functions &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;connect/2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-2&quot;&gt;ssh_sftp:start_channel/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;connect/2,3,4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-2&quot;&gt;ssh_sftp:start_channel/2,3&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="80d9f2993c240cb5395538eac32a770dc645b1f7" translate="yes" xml:space="preserve">
          <source>Returned by the functions &lt;code&gt;&lt;a href=&quot;ssh#daemon-1&quot;&gt;daemon/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#daemon-1&quot;&gt;daemon/1,2,3&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2b499cd87149b2c8112ff4703aabf6b14742dd7" translate="yes" xml:space="preserve">
          <source>Returned by the functions &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="7600c8cb62b3f6c0670cf2d28c10c2d70f454cac" translate="yes" xml:space="preserve">
          <source>Returned if &lt;code&gt;Number&amp;gt;0&lt;/code&gt; and end of file was reached before anything at all could be read.</source>
          <target state="translated">&lt;code&gt;Number&amp;gt;0&lt;/code&gt; 이고 파일 끝에 도달하기 전에 파일 끝에 도달 하면 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebd6a9b6057141637a7f687d405ddc6223fd3a4d" translate="yes" xml:space="preserve">
          <source>Returned if end of file was reached before anything at all could be read.</source>
          <target state="translated">무엇이든 읽을 수 있기 전에 파일 끝에 도달하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78f92740b63dec59bb4c6e7e6eaba8a507fff69f" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{skip,Reason}&lt;/code&gt; from function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{skip,Reason}&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="79fbf73ac7c1fd87f1058ecd2cd1bb43d786dfe6" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{skip,Reason}&lt;/code&gt; from the execution clause of the test case. The execution clause is called, so the author must ensure that the test case does not run.</source>
          <target state="translated">테스트 케이스의 실행 절에서 &lt;code&gt;{skip,Reason}&lt;/code&gt; 을 리턴 합니다. 실행 절이 호출되므로 작성자는 테스트 케이스가 실행되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="78efdce4503fc5152a50adf6376b612d02e50c2c" translate="yes" xml:space="preserve">
          <source>Returning any other value or generating an exception causes the new code to be unloaded. If the return value is not an atom, a warning error report is sent to the error logger.</source>
          <target state="translated">다른 값을 반환하거나 예외를 생성하면 새 코드가 언로드됩니다. 리턴 값이 원자가 아닌 경우, 오류 로거에 경고 오류 보고서가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5bafc7cb30a4a28d5f1849e1ed82229cd36e7a85" translate="yes" xml:space="preserve">
          <source>Returning anything but &lt;code&gt;ok&lt;/code&gt; or a 2xxx series result code causes the transport connection to be broken. Multiple &lt;code&gt;&lt;a href=&quot;#capabilities_cb&quot;&gt;capabilities_cb&lt;/a&gt;&lt;/code&gt; options can be specified, in which case the corresponding callbacks are applied until either all return &lt;code&gt;ok&lt;/code&gt; or one does not.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 또는 2xxx 시리즈 결과 코드 이외의 것을 반환 하면 전송 연결이 끊어집니다. 여러 &lt;code&gt;&lt;a href=&quot;#capabilities_cb&quot;&gt;capabilities_cb&lt;/a&gt;&lt;/code&gt; 의 옵션은 모든 반환 할 때까지이 경우 해당 콜백이 적용 지정할 수 있습니다 &lt;code&gt;ok&lt;/code&gt; 또는 하나하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13619914603e5198752b243417d1cec7b1cbae13" translate="yes" xml:space="preserve">
          <source>Returns 0 if &lt;code&gt;cpu_sup&lt;/code&gt; is not available.</source>
          <target state="translated">&lt;code&gt;cpu_sup&lt;/code&gt; 을 사용할 수없는 경우 0을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="2fe7ef4689924328d121fc13015c7e449fbb3af4" translate="yes" xml:space="preserve">
          <source>Returns 0 on success, non-zero on failure.</source>
          <target state="translated">성공하면 0을, 실패하면 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2fbeaf650327f2e3c58e1b893cae4fb1a66501a9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code id=&quot;read_link_all&quot;&gt;{ok, Filename}&lt;/code&gt; if &lt;code&gt;Name&lt;/code&gt; refers to a symbolic link that is not a raw filename, or &lt;code&gt;{error, Reason}&lt;/code&gt; otherwise. On platforms that do not support symbolic links, the return value is &lt;code&gt;{error,enotsup}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 원시 파일 이름이 아닌 기호 링크를 참조 하면 &lt;code id=&quot;read_link_all&quot;&gt;{ok, Filename}&lt;/code&gt; &lt;code&gt;{error, Reason}&lt;/code&gt; 그렇지 않으면 {error, Reason}을 리턴 합니다. 기호 링크를 지원하지 않는 플랫폼에서 리턴 값은 &lt;code&gt;{error,enotsup}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c8a13c6c0607ec9a0e9c3c4823a02858da20b803" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is not a proper list.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 가 올바른 목록이 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="488069c3cb5902ddad05d14f6565535c0efbbfa1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;-1&lt;/code&gt; if the floating point number is not finite.</source>
          <target state="translated">부동 소수점 숫자가 유한하지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6e8da0a8ae5c1d6ebbf2999c231c02b4ccea25da" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; and initializes &lt;code&gt;obuf&lt;/code&gt; on success, otherwise &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 반환 하고 &lt;code&gt;obuf&lt;/code&gt; 를 초기화하고 , 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="072a398ea7b2dc0fc0a565fe904090ff6d623dd0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;monitor1&lt;/code&gt; and &lt;code&gt;monitor2&lt;/code&gt; are equal, &amp;lt; &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;monitor1&lt;/code&gt; &amp;lt; &lt;code&gt;monitor2&lt;/code&gt;, and &amp;gt; &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;monitor1&lt;/code&gt; &amp;gt; &lt;code&gt;monitor2&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 만약 &lt;code&gt;monitor1&lt;/code&gt; 과 &lt;code&gt;monitor2&lt;/code&gt; , 동일 &amp;lt; &lt;code&gt;0&lt;/code&gt; 의 경우 &lt;code&gt;monitor1&lt;/code&gt; &amp;lt; &lt;code&gt;monitor2&lt;/code&gt; 및&amp;gt; &lt;code&gt;0&lt;/code&gt; 의 경우 &lt;code&gt;monitor1&lt;/code&gt; &amp;gt; &lt;code&gt;monitor2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f42b6d3dd05f623e6c9a461536fab61de5146090" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if a monitor was removed and &amp;gt; 0 if the monitor no longer exists.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 모니터가 제거 된 경우와&amp;gt; 0 모니터가 더 이상 존재하지 않으면.</target>
        </trans-unit>
        <trans-unit id="fbcc999b8ba8bb8fb081510096a443737b55216e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if successful, otherwise &lt;code&gt;-1&lt;/code&gt;. In the latter case it sets &lt;code&gt;erl_errno&lt;/code&gt; to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 , 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 . 후자의 경우에는 &lt;code&gt;erl_errno&lt;/code&gt; 를 &lt;code&gt;EIO&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dd74052a4956a0a756749720fbbf26847c93e18f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if the monitor was successfully identified and removed. Returns a non-zero value if the monitor could not be identified, which means it was either</source>
          <target state="translated">모니터가 성공적으로 식별되고 제거 된 경우 &lt;code&gt;0&lt;/code&gt; 을 리턴 합니다. 모니터를 식별 할 수없는 경우 0이 아닌 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a1cd3df7b26605f1b8a43bc02fca546fec8ce909" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if the terms are equal, &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;term1&lt;/code&gt; &amp;lt; &lt;code&gt;term2&lt;/code&gt;, or &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;term2&lt;/code&gt; &amp;lt; &lt;code&gt;term1&lt;/code&gt;.</source>
          <target state="translated">항이 같으면 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;term1&lt;/code&gt; &amp;lt; &lt;code&gt;term2&lt;/code&gt; 인 경우 &lt;code&gt;-1&lt;/code&gt; 또는 &lt;code&gt;term2&lt;/code&gt; &amp;lt; &lt;code&gt;term1&lt;/code&gt; 인 경우 &lt;code&gt;1&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="52ee1791e89438cfbb09fe85370e4be0c4174cff" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; if the type cannot be determined or one of:</source>
          <target state="translated">유형을 결정할 수 없거나 다음 중 하나 인 경우 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="50e51ec9b602d8e52f5b56e7dd86a98c570d1875" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; it they are not equal, and a value not equal to &lt;code&gt;0&lt;/code&gt; if they are equal.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 그것은 그들이 동일하지 않고, 값이 없습니다 동일한 &lt;code&gt;0&lt;/code&gt; 가 동일한 경우.</target>
        </trans-unit>
        <trans-unit id="1495d2dcd77d2c277ca09871795adbea294a06a5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, &amp;lt; 0 if no &lt;code&gt;down&lt;/code&gt; callback is provided, and &amp;gt; 0 if the process is no longer alive.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을, &lt;code&gt;down&lt;/code&gt; 콜백이 제공 되지 않으면 &amp;lt;0을 , 프로세스가 더 이상 존재하지 않으면&amp;gt; 0을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="147dfcedb6130dcb3e344debc4b54ca54f8b8a66" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, &amp;lt; 0 if no callback is provided, and &amp;gt; 0 if the process is no longer alive.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 성공, &amp;lt;콜백이 제공되지 않을 경우 0, 및&amp;gt; 0 프로세스가 더 이상 살아합니다.</target>
        </trans-unit>
        <trans-unit id="2c492d5222c271880cc6dab0353ce6f5682b5289" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을, 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="99b406373dc8fe6db0449d813a5f79501cb33531" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise &lt;code&gt;EBUSY&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을, 그렇지 않으면 &lt;code&gt;EBUSY&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c69f20dec618478f3663e41c43a1c6b626d3205" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise &lt;code&gt;EBUSY&lt;/code&gt;. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same rwlock again.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을, 그렇지 않으면 &lt;code&gt;EBUSY&lt;/code&gt; 를 반환합니다 . 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠그려고 시도 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="06b21577fae8bbe6572f27c24fcac58fd4e88891" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise a value &lt;code&gt;!= 0&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을, 그렇지 않으면 값 &lt;code&gt;!= 0&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="7f67995b09d8c03447773e8b6d645bf327b96995" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise an &lt;code&gt;errno&lt;/code&gt; value is returned to indicate the error.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 반환 하고, 그렇지 않으면 오류를 나타내는 &lt;code&gt;errno&lt;/code&gt; 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17e727f0f7e44e0124cf8250aaf77abcb4d94e4e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise an &lt;code&gt;errno&lt;/code&gt; value is returned to indicate the error. The driver creating the key is responsible for destroying it before the driver is unloaded.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 반환 하고, 그렇지 않으면 오류를 나타내는 &lt;code&gt;errno&lt;/code&gt; 값을 반환합니다. 키를 생성하는 드라이버는 드라이버를 언로드하기 전에 키를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="26800ea3c35a48f48e98accc6b96cb83bd10b328" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success, otherwise an &lt;code&gt;errno&lt;/code&gt; value is returned to indicate the error. The newly created thread begins executing in the function pointed to by &lt;code&gt;func&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; is passed &lt;code&gt;arg&lt;/code&gt; as argument. When &lt;code&gt;erl_drv_thread_create&lt;/code&gt; returns, the thread identifier of the newly created thread is available in &lt;code&gt;*tid&lt;/code&gt;. &lt;code&gt;opts&lt;/code&gt; can be either a &lt;code&gt;NULL&lt;/code&gt; pointer, or a pointer to an &lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; structure. If &lt;code&gt;opts&lt;/code&gt; is a &lt;code&gt;NULL&lt;/code&gt; pointer, default options are used, otherwise the passed options are used.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 반환 하고, 그렇지 않으면 오류를 나타내는 &lt;code&gt;errno&lt;/code&gt; 값을 반환합니다. 새로 생성 된 스레드가 가리키는 함수의 실행이 시작 &lt;code&gt;func&lt;/code&gt; 및 &lt;code&gt;func&lt;/code&gt; 전달 &lt;code&gt;arg&lt;/code&gt; 인수한다. 때 &lt;code&gt;erl_drv_thread_create&lt;/code&gt; 반환, 새로 생성 된 스레드의 스레드 식별자에서 사용할 수 있습니다 &lt;code&gt;*tid&lt;/code&gt; . &lt;code&gt;opts&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 포인터이거나 &lt;code&gt;&lt;a href=&quot;#ErlDrvThreadOpts&quot;&gt;ErlDrvThreadOpts&lt;/a&gt;&lt;/code&gt; 구조 에 대한 포인터 일 수 있습니다 . 경우 &lt;code&gt;opts&lt;/code&gt; A는 &lt;code&gt;NULL&lt;/code&gt; 포인터, 기본 옵션, 그렇지 않으면 전달 된 옵션을 사용, 사용된다.</target>
        </trans-unit>
        <trans-unit id="e72c8d8be7beff4d9ddb37560e1a80573817b4bd" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; on success. If the call fails, a non-zero value is returned, and the reason for the error can be obtained with the appropriate platform-dependent call.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 . 호출이 실패하면 0이 아닌 값이 리턴되고 적절한 플랫폼 종속 호출로 오류 이유를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3086d983f407d141773c522d0f5defee16a27022" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f11efa5004a5978c0569c8d60ebccedb9d05a28f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;1&lt;/code&gt; if the timeslice is exhausted, otherwise &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;1&lt;/code&gt; is returned, the NIF is to return as soon as possible in order for the process to yield.</source>
          <target state="translated">반환 &lt;code&gt;1&lt;/code&gt; 타임 슬라이스 달리, 소진 된 경우 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;code&gt;1&lt;/code&gt; 이 반환되면, NIF는 수율 공정의 순서를 가능한 한 빨리 복귀하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a05934f68d914848552efcba4c6a4de46ed6c2d6" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;1&lt;/code&gt; on success, otherwise &lt;code&gt;0&lt;/code&gt;. In the latter case &lt;code&gt;erl_errno&lt;/code&gt; is set to one of:</source>
          <target state="translated">성공하면 &lt;code&gt;1&lt;/code&gt; 을, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 . 후자의 경우 &lt;code&gt;erl_errno&lt;/code&gt; 는 다음 중 하나로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bbce47d721ecf0ed15007cbf5bc4ae1c1f24fa2f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;&lt;code&gt;Family&lt;/code&gt; such that the index set is equal to the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of the binary relation &lt;code&gt;BinRel&lt;/code&gt;, and &lt;code&gt;Family&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of the set of i under &lt;code&gt;BinRel&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; &lt;code&gt;Family&lt;/code&gt; 인덱스 세트는 상기와 동일하도록 &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; 이진 관계 &lt;code&gt;BinRel&lt;/code&gt; 및 &lt;code&gt;Family&lt;/code&gt; [I]는 인 &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; 아래 난 세트의 &lt;code&gt;BinRel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c70c55ba98a792957a1ed746bcd3599e74b06f8c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;&lt;code&gt;Family&lt;/code&gt; where the indexed set is a &lt;code&gt;&lt;a href=&quot;#partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; such that two elements are considered equal if the results of applying &lt;code&gt;SetFun&lt;/code&gt; are the same value i. This i is the index that &lt;code&gt;Family&lt;/code&gt; maps onto the &lt;code&gt;&lt;a href=&quot;#equivalence_class&quot;&gt;equivalence class&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SetFun&lt;/code&gt; 적용 결과가 동일한 값 i 인 경우 두 요소가 동일한 것으로 간주 되도록 색인화 된 세트가 &lt;code&gt;Set&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; &lt;code&gt;Family&lt;/code&gt; 리턴 합니다. 이것은 &lt;code&gt;Family&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#equivalence_class&quot;&gt;equivalence class&lt;/a&gt;&lt;/code&gt; 매핑 하는 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="1e039b7fedb94135b8bf441f4e52eb683044770e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;. Notice that negative values are not uncommon.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 반환 합니다 . 음수 값은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9c959f6d83500aa2c72c79ef3eff1a14895716ac" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; integers corresponding to creation time. That is, the integer returned is always larger than previously returned integers on the current runtime system instance.</source>
          <target state="translated">생성 시간에 해당하는 &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 정수를 반환 합니다. 즉, 리턴 된 정수는 항상 현재 런타임 시스템 인스턴스에서 이전에 리턴 된 정수보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="640ef747ead04008a85649e4332a8d5379261b2b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;CpuTopology&lt;/code&gt; used by the emulator. For more information, see argument &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology&quot;&gt;cpu_topology&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터에서 사용하는 &lt;code&gt;CpuTopology&lt;/code&gt; 를 반환 합니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology&quot;&gt;cpu_topology&lt;/a&gt;&lt;/code&gt; 인수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72f02ca8ebdf85d353fec758b111da577d03f183" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;ERL_DRV_TIME_ERROR&lt;/code&gt; if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</source>
          <target state="translated">유효하지 않은 시간 단위 인수로 호출되거나 스케줄러 스레드가 아닌 스레드에서 호출 된 경우 &lt;code&gt;ERL_DRV_TIME_ERROR&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a844d69586de15e9bd1cfc35b03711b171962f8c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;ERL_DRV_TIME_ERROR&lt;/code&gt; if called with an invalid time unit argument.</source>
          <target state="translated">유효하지 않은 시간 단위 인수로 호출 된 경우 &lt;code&gt;ERL_DRV_TIME_ERROR&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fbb08c81705b11d4c70e818d320627a5178b1fac" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; if called with an invalid time unit argument or if called from a thread that is not a scheduler thread.</source>
          <target state="translated">유효하지 않은 시간 단위 인수로 호출되거나 스케줄러 스레드가 아닌 스레드에서 호출 된 경우 &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d9785e5a0bee0c018d5494695cfb88ba9e8b07fb" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</source>
          <target state="translated">유효하지 않은 시간 단위 인수로 호출되거나 스케줄러 스레드가 아닌 스레드에서 호출 된 경우 &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bc80a13223e5723498400925f90cdc9b85a31063" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; if called with an invalid time unit argument.</source>
          <target state="translated">유효하지 않은 시간 단위 인수로 호출 된 경우 &lt;code&gt;ERL_NIF_TIME_ERROR&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8c25a7c06a297494f90b2e3a36638938a9b1aac4" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;Input&lt;/code&gt;, which is the total number of bytes received through ports, and &lt;code&gt;Output&lt;/code&gt;, which is the total number of bytes output to ports.</source>
          <target state="translated">포트를 통해 수신 된 총 바이트 수인 &lt;code&gt;Input&lt;/code&gt; 과 포트로 &lt;code&gt;Output&lt;/code&gt; 되는 총 바이트 수인 Output을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="2873dd80c13cadf65349a58c98c0a4c2b0396052" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q&lt;/code&gt; 앞에있는 &lt;code&gt;Item&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="879d7819f21618972cba5f60307c902040474ba8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q&lt;/code&gt; 의 뒷면에있는 &lt;code&gt;Item&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce4cb1f794dd5a9fb9ff2644b8f5c049da553f9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;Item&lt;/code&gt; from the head of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q&lt;/code&gt; 의 헤드에서 &lt;code&gt;Item&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
