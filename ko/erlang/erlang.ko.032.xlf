<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="c745a240a8b09464690a74b0ded828b443277620" translate="yes" xml:space="preserve">
          <source>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</source>
          <target state="translated">드라이버 이름은 역사적 이유로 원자 목록이 아닌 문자열 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8c90e4dc558838312154093ae7e4d33a042314e8" translate="yes" xml:space="preserve">
          <source>The driver options for a specified driver name need always to be consistent, &lt;strong&gt;even when the driver is reloaded&lt;/strong&gt;, meaning that they are as much a part of the driver as the name.</source>
          <target state="translated">&lt;strong&gt;드라이버를 다시로드 할 때에도&lt;/strong&gt; 지정된 드라이버 이름에 대한 드라이버 옵션은 항상 일관성이 있어야합니다. 즉, 드라이버 이름 &lt;strong&gt;이 드라이버&lt;/strong&gt; 의 일부인 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec7187710cb97de822c20a1794719f5b691ec563" translate="yes" xml:space="preserve">
          <source>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal Erlang message queues). This can be useful if the driver must wait for slow devices, and so on, and wants to yield back to the emulator. The driver queue is implemented as an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">드라이버 큐는 에뮬레이터에서 드라이버로 출력을 큐에 넣을 수 있습니다 (드라이버에서 에뮬레이터로의 데이터는 일반 Erlang 메시지 큐에서 에뮬레이터에 의해 큐에 대기됩니다). 드라이버가 느린 장치 등을 기다려야하고 에뮬레이터로 되돌려 보내려는 경우에 유용 할 수 있습니다. 드라이버 큐는 &lt;code&gt;ErlIOVec&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="267e1ade55aca0a7989f62dc5c3745421b17592a" translate="yes" xml:space="preserve">
          <source>The driver structure contains the driver name and some 15 function pointers, which are called at different times by the emulator.</source>
          <target state="translated">드라이버 구조에는 드라이버 이름과 약 15 개의 함수 포인터가 포함되어 있으며 에뮬레이터에서 다른 시간에 호출합니다.</target>
        </trans-unit>
        <trans-unit id="777fa5f89808e7871ea95ba4af70a119a6124215" translate="yes" xml:space="preserve">
          <source>The driver structure is filled with the driver name and function pointers. It is returned from the special entry point, declared with the macro &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">드라이버 구조는 드라이버 이름과 함수 포인터로 채워져 있습니다. 매크로 &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt; 선언 된 특수 진입 점에서 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca38a39e87b4ab492f8fbeb01d018493a1577466" translate="yes" xml:space="preserve">
          <source>The driver structure is similar for statically linked-in drivers and dynamically loaded. However, some of the fields are to be left empty (that is, initialized to NULL) in the different types of drivers. The first field (the &lt;code&gt;init&lt;/code&gt; function pointer) is always left blank in a dynamically loaded driver, see line 26. &lt;code&gt;NULL&lt;/code&gt; on line 37 is always to be there, the field is no longer used and is retained for backward compatibility. No timers are used in this driver, why no callback for timers is needed. The &lt;code&gt;outputv&lt;/code&gt; field (line 40) can be used to implement an interface similar to Unix &lt;code&gt;writev&lt;/code&gt; for output. The Erlang runtime system could previously not use &lt;code&gt;outputv&lt;/code&gt; for the distribution, but it can as from ERTS 5.7.2. As this driver was written before ERTS 5.7.2 it does not use the &lt;code&gt;outputv&lt;/code&gt; callback. Using the &lt;code&gt;outputv&lt;/code&gt; callback is preferred, as it reduces copying of data. (We will however use scatter/gather I/O internally in the driver.)</source>
          <target state="translated">드라이버 구조는 정적으로 링크 된 드라이버와 유사하며 동적으로로드됩니다. 그러나 일부 필드는 다른 유형의 드라이버에서 비워 두어야합니다 (즉, NULL로 초기화 됨). 첫 번째 필드 ( &lt;code&gt;init&lt;/code&gt; 함수 포인터)는 동적으로로드 된 드라이버에서 항상 비워 둡니다 . 26 행을 참조하십시오. 37 행의 &lt;code&gt;NULL&lt;/code&gt; 은 항상 존재하며 필드는 더 이상 사용되지 않으며 이전 버전과의 호환성을 위해 유지됩니다. 이 드라이버에는 타이머가 사용되지 않으므로 타이머에 대한 콜백이 필요하지 않은 이유는 무엇입니까? &lt;code&gt;outputv&lt;/code&gt; 의 필드 (라인 40)은 유닉스와 유사한 인터페이스를 구현하는데 사용될 수 &lt;code&gt;writev&lt;/code&gt; 는 출력한다. Erlang 런타임 시스템은 이전에 &lt;code&gt;outputv&lt;/code&gt; 를 사용할 수 없었습니다.배포에 대해서는 ERTS 5.7.2에서와 같이 가능합니다. 이 드라이버는 ERTS 5.7.2 이전에 작성 &lt;code&gt;outputv&lt;/code&gt; 콜백을 사용하지 않습니다 . &lt;code&gt;outputv&lt;/code&gt; 콜백을 사용하는 것이 좋습니다. 데이터 복사가 줄어 듭니다. (하지만 내부적으로 분산 / 수집 I / O를 드라이버에서 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="13e83e61fa641454caf4f4f17446cac682b522d1" translate="yes" xml:space="preserve">
          <source>The driver used for Erlang distribution is to implement a reliable, order maintaining, variable length packet-oriented protocol. All error correction, resending and such need to be implemented in the driver or by the underlying communications protocol. If the protocol is stream-oriented (as is the case with both TCP/IP and our streamed Unix domain sockets), some mechanism for packaging is needed. We will use the simple method of having a header of four bytes containing the length of the package in a big-endian 32-bit integer. As Unix domain sockets only can be used between processes on the same machine, we do not need to code the integer in some special endianess, but we will do it anyway because in most situation you need to do it. Unix domain sockets are reliable and order maintaining, so we do not need to implement resends and such in the driver.</source>
          <target state="translated">Erlang 배포에 사용되는 드라이버는 안정적인 순서 유지 가변 길이 패킷 지향 프로토콜을 구현하는 것입니다. 모든 오류 수정, 재전송 등은 드라이버 또는 기본 통신 프로토콜로 구현해야합니다. 프로토콜이 스트림 지향 인 경우 (TCP / IP 및 스트리밍 된 Unix 도메인 소켓의 경우와 같이) 패키징을위한 일부 메커니즘이 필요합니다. 우리는 빅 엔디안 32 비트 정수로 패키지의 길이를 포함하는 4 바이트의 헤더를 갖는 간단한 방법을 사용할 것입니다. 유닉스 도메인 소켓은 동일한 머신의 프로세스간에 만 사용할 수 있기 때문에 특별한 엔디안으로 정수를 코딩 할 필요는 없지만 대부분의 상황에서 수행해야하기 때문에 어쨌든 수행합니다. 유닉스 도메인 소켓은 신뢰할 수 있고 순서를 유지하며따라서 드라이버에서 재전송 등을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="885a9c9f85b39e7698683efce0ff5bba88451a67" translate="yes" xml:space="preserve">
          <source>The driver was already loaded by another process or is in use by a living port, or both. The load by you is registered and a corresponding &lt;code&gt;try_unload&lt;/code&gt; is expected sometime in the future.</source>
          <target state="translated">드라이버가 다른 프로세스에 의해 이미로드되었거나 리빙 포트 또는 둘 다에서 사용 중입니다. 귀하의로드가 등록되었으며 나중에 해당 &lt;code&gt;try_unload&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="380ea6d015cef2cddc2581f363be87321f771e9f" translate="yes" xml:space="preserve">
          <source>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</source>
          <target state="translated">드라이버가 즉시 언로드되었습니다. 즉, 다른 드라이버가 드라이버 이름을 자유롭게 사용할 수 있으며 기본 OS에서 허용하는 경우 드라이버 개체 코드가 차지하는 메모리가 다시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3da2e19322e3c6628d119e07b3e56934634eac8" translate="yes" xml:space="preserve">
          <source>The driver was loaded and is immediately usable.</source>
          <target state="translated">드라이버가로드되어 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d864f9d9077463dec755426c28ec5da6f217e91e" translate="yes" xml:space="preserve">
          <source>The driver with the specified name is an Erlang statically linked-in driver, which cannot be manipulated with this API.</source>
          <target state="translated">지정된 이름을 가진 드라이버는 Erlang 정적으로 링크 된 드라이버이며이 API로 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1eb9606d6f4220a244d8c3b7748d550c419a79a" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">드라이버 라이터는 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 모니터를 저장하기위한 메모리를 제공해야합니다 . 데이터 주소는 드라이버 외부에 저장되지 않으므로 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 를 다른 데이터로 사용할 수 있으며 복사, 메모리 이동, 잊어 버림 등을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4025b3383bc4889c1c9cd923cfef69764fc7fb73" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나중에 드라이버 콜백에 대한 호출에서 전달되는 드라이버 정의 핸들입니다. 것을 알 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 이 새 드라이버 인스턴스에 대한 호출되지 않습니다. 드라이버 정의 핸들은 일반적으로 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 를 통해 포트가 작성 될 때 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="394034fd0da749c1d06ef57ce69c6215ae425eb2" translate="yes" xml:space="preserve">
          <source>The driver-entry structure used by Erlang drivers.</source>
          <target state="translated">Erlang 드라이버가 사용하는 드라이버 입력 구조.</target>
        </trans-unit>
        <trans-unit id="e67bdfbeb3c1793f1075c60e9dfc86106434ef3f" translate="yes" xml:space="preserve">
          <source>The dump is truncated.</source>
          <target state="translated">덤프가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="58fd56942c22b98ca6dfc0e41f2fc24c62b5de4a" translate="yes" xml:space="preserve">
          <source>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</source>
          <target state="translated">덤프가 잘립니다. 이 경우 주 창의 상태 표시 줄에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="26da6cb9d5e2b4d506bf3083a6055833ae7a4362" translate="yes" xml:space="preserve">
          <source>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</source>
          <target state="translated">내구성 특성은 트랜잭션에 의해 DBMS에 대한 변경 사항이 영구적임을 보장합니다. 트랜잭션이 커밋되면 데이터베이스에 대한 모든 변경 사항이 지속됩니다. 즉, 디스크에 안전하게 기록되고 손상되지 않으며 사라지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7aa3c54478ccaa5bbddda8a5fe6086c5ab90507" translate="yes" xml:space="preserve">
          <source>The duration time is specified as &lt;code&gt;HHMMSS&lt;/code&gt;, for example, &lt;code&gt;-duration 012030&lt;/code&gt; or &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</source>
          <target state="translated">지속 시간은 &lt;code&gt;HHMMSS&lt;/code&gt; 로 지정됩니다 ( 예 : &lt;code&gt;-duration 012030&lt;/code&gt; 또는 &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b34138fd668a3a91f262b3c8cc94e10c40614310" translate="yes" xml:space="preserve">
          <source>The dynamic engine is not supported in LibreSSL from version 2.2.1</source>
          <target state="translated">버전 2.2.1의 LibreSSL에서 동적 엔진이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46cf93457fc198c7fc4b11e05da4141275628e59" translate="yes" xml:space="preserve">
          <source>The earlier factorial example can act as a counter-example. It is not tail-recursive, since a multiplication is done on the result of the recursive call to &lt;code&gt;fact(N-1)&lt;/code&gt;.</source>
          <target state="translated">이전의 계승 예제는 반례로 작용할 수 있습니다. &lt;code&gt;fact(N-1)&lt;/code&gt; 에 대한 재귀 호출의 결과에 곱셈이 수행되므로 꼬리 재귀가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7471d512bedffa6e5e516b4425ff9cbeaebad94b" translate="yes" xml:space="preserve">
          <source>The easiest path is to mimic the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet_tcp&lt;/code&gt; interfaces, but not much functionality in those modules needs to be implemented. In the example application, only a few of the usual interfaces are implemented, and they are much simplified.</source>
          <target state="translated">가장 쉬운 방법은 &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;inet_tcp&lt;/code&gt; 인터페이스 를 모방하는 것이지만 해당 모듈의 기능을 많이 구현할 필요는 없습니다. 예제 응용 프로그램에서는 일반적인 인터페이스 중 일부만 구현되며 훨씬 단순화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a4e2857f3f8ff97859f4357e2a194c2963da6e0" translate="yes" xml:space="preserve">
          <source>The easiest way of using &lt;code&gt;ET&lt;/code&gt;, is to just use it as a graphical tool for displaying message sequence charts. In order to do that you need to first start a &lt;code&gt;Viewer&lt;/code&gt; (which by default starts a &lt;code&gt;Collector&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;ET&lt;/code&gt; 를 사용하는 가장 쉬운 방법은 메시지 시퀀스 차트를 표시하기위한 그래픽 도구로 사용하는 것입니다. 그러기 위해서는 먼저 &lt;code&gt;Viewer&lt;/code&gt; 를 시작해야합니다 (기본적으로 &lt;code&gt;Collector&lt;/code&gt; 시작 ).</target>
        </trans-unit>
        <trans-unit id="3e2ec62c427c4d0d3ce97e74cc8645fe104a328c" translate="yes" xml:space="preserve">
          <source>The easiest way to start Crashdump Viewer is to use shell script &lt;code&gt;cdv&lt;/code&gt; with the full path to the Erlang crashdump as argument. The script is located in directory &lt;code&gt;priv&lt;/code&gt; of the Observer application. This starts the Crashdump Viewer GUI and loads the specified file. If no filename is specified, a file dialog is opened where the file can be selected.</source>
          <target state="translated">&lt;code&gt;cdv&lt;/code&gt; Viewer를 시작하는 가장 쉬운 방법은 쉘 스크립트 cdv 를 Erlang crashdump의 전체 경로와 함께 인수로 사용하는 것입니다. 스크립트는 Observer 응용 프로그램의 &lt;code&gt;priv&lt;/code&gt; 디렉토리에 있습니다 . Crashdump Viewer GUI가 시작되고 지정된 파일이로드됩니다. 파일 이름을 지정하지 않으면 파일을 선택할 수있는 파일 대화 상자가 열립니다.</target>
        </trans-unit>
        <trans-unit id="55d0d417d785ac1626163667303a6253a1c8a917" translate="yes" xml:space="preserve">
          <source>The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.</source>
          <target state="translated">(* THEN)의 효과는 이제 내부 서브 패턴으로 제한됩니다. C에서 실패한 후에는 일치하는 (* FAIL)로 이동하여 더 이상 시도 할 대안이 없으므로 전체 서브 패턴이 실패합니다. 이 경우 일치는 이제 A로 역 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="f16407eee4518305b005b9dbecb5884bd7cbf3bc" translate="yes" xml:space="preserve">
          <source>The effect of combining &lt;code&gt;set_on_first_link&lt;/code&gt; with &lt;code&gt;set_on_link&lt;/code&gt; is the same as &lt;code&gt;set_on_first_link&lt;/code&gt; alone. Likewise for &lt;code&gt;set_on_spawn&lt;/code&gt; and &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_on_first_link&lt;/code&gt; 와 &lt;code&gt;set_on_link&lt;/code&gt; 를 결합한 효과는 &lt;code&gt;set_on_first_link&lt;/code&gt; 단독 과 동일 합니다. 마찬가지로에 대한 &lt;code&gt;set_on_spawn&lt;/code&gt; 및 &lt;code&gt;set_on_first_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb46e1d7474732484a66c32367c6751904b1bed" translate="yes" xml:space="preserve">
          <source>The effect of option &lt;code&gt;cache&lt;/code&gt; is that when generator &lt;code&gt;QH2'&lt;/code&gt; is run the first time, every answer is stored in an ETS table. When the next answer of &lt;code&gt;QH1&lt;/code&gt; is tried, answers to &lt;code&gt;QH2'&lt;/code&gt; are copied from the ETS table, which is very fast. As for option &lt;code&gt;unique&lt;/code&gt; the cost is a possibly substantial amount of RAM memory.</source>
          <target state="translated">옵션 &lt;code&gt;cache&lt;/code&gt; 의 효과는 생성기 &lt;code&gt;QH2'&lt;/code&gt; 가 처음 실행될 때 모든 응답이 ETS 테이블에 저장 된다는 것입니다. &lt;code&gt;QH1&lt;/code&gt; 의 다음 답변 이 시도 될 때, &lt;code&gt;QH2'&lt;/code&gt; 대한 답변 이 ETS 테이블에서 복사되는데, 이는 매우 빠릅니다. 옵션 &lt;code&gt;unique&lt;/code&gt; 경우 비용은 상당한 양의 RAM 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="46af5dbb6ad32f950d071087d55fd5eedd3a2dcc" translate="yes" xml:space="preserve">
          <source>The election process is modified as described in 5.6.4.</source>
          <target state="translated">선거 절차는 5.6.4에 설명 된대로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd607a9ef230a55bb6d74140b011672a2b70ef4" translate="yes" xml:space="preserve">
          <source>The element in position &lt;code&gt;Pos&lt;/code&gt; in &lt;code&gt;Pattern&lt;/code&gt; must be bound. &lt;code&gt;Pos&lt;/code&gt; is an integer (&lt;code&gt;#record.Field&lt;/code&gt;) or an attribute name.</source>
          <target state="translated">위치에있는 요소 &lt;code&gt;Pos&lt;/code&gt; 의 &lt;code&gt;Pattern&lt;/code&gt; 결합해야합니다. &lt;code&gt;Pos&lt;/code&gt; 는 정수 ( &lt;code&gt;#record.Field&lt;/code&gt; ) 또는 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c52c7c2c532d8015d87a1ff9dad023e4fb851308" translate="yes" xml:space="preserve">
          <source>The element to update is also the key.</source>
          <target state="translated">업데이트 할 요소도 핵심 요소입니다.</target>
        </trans-unit>
        <trans-unit id="133139824edb56fee5c9537204f00d5c8e6d31f2" translate="yes" xml:space="preserve">
          <source>The element to update is not an integer.</source>
          <target state="translated">업데이트 할 요소가 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e2b6d90876d98adc6125d07f13d8d523ed72322" translate="yes" xml:space="preserve">
          <source>The embedded system and all the applications start automatically if the script file shown below is added to directory &lt;code&gt;/etc/rc3.d&lt;/code&gt;. The file must be owned and readable by &lt;code&gt;root&lt;/code&gt;. Its name cannot be arbitrarily assigned; the following name is recommended:</source>
          <target state="translated">아래에 표시된 스크립트 파일이 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 디렉토리에 추가되면 내장 시스템 및 모든 응용 프로그램이 자동으로 시작됩니다 . 파일은 &lt;code&gt;root&lt;/code&gt; 가 소유하고 읽을 수 있어야합니다 . 이름은 임의로 지정할 수 없습니다. 다음 이름이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="bad88f7a085d192e2f6cec49768a38f2903f8ae0" translate="yes" xml:space="preserve">
          <source>The emulator calls the driver in the following situations:</source>
          <target state="translated">에뮬레이터는 다음 상황에서 드라이버를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="218b5d9983c658a4cef0aef4b47157f1b19f1a20" translate="yes" xml:space="preserve">
          <source>The emulator has been started with only one scheduler thread.</source>
          <target state="translated">에뮬레이터는 하나의 스케줄러 스레드로 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="00ecfc5e261b4531e61f24b2c4f3b8605c732361" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있으며 스케줄러 스레드가 차단되지 않았습니다. 즉, 사용 가능한 모든 스케줄러 스레드가 Erlang 프로세스를 예약하고 Erlang 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d1335d1e55e250963f0d3ef76a97d106ea1aeeed" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있지만 하나를 제외한 모든 일반 스케줄러 스레드가 차단됩니다. 더티 스케줄러는 차단되지 않으며 Erlang 프로세스를 예약하고 기본 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e09f5c935221131fa5aa069cd7be0f9d773e6f4" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있지만 하나를 제외한 모든 스케줄러 스레드가 차단됩니다. 즉, 하나의 스케줄러 스레드 만 Erlang 프로세스를 예약하고 Erlang 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9414404aaefeb3f5826ea98674c66ad27f121727" translate="yes" xml:space="preserve">
          <source>The emulator probably uses more memory, and because garbage collections occur less frequently, huge binaries can be kept much longer.</source>
          <target state="translated">에뮬레이터는 더 많은 메모리를 사용하고 가비지 수집이 덜 자주 발생하므로 큰 이진 파일을 훨씬 더 오래 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c90a0c569f6e401278d0c92d5efb3209b403c33" translate="yes" xml:space="preserve">
          <source>The emulator refuses to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, as incompatible type changes for the callbacks &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; were introduced in Erlang/OTP R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator, causing it to read random memory and create huge incorrect result blobs.</source>
          <target state="translated">콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 에 대한 호환되지 않는 유형 변경 이 Erlang / OTP R15B에 도입되었으므로 64 비트 지원 드라이버를 허용하기 위해 확장 드라이버 인터페이스를 사용하지 않는 드라이버로드를 거부합니다 . 이전 유형으로 작성된 드라이버는 경고와 함께 컴파일되어 호출 가비지 크기를 에뮬레이터에 반환하면 임의의 메모리를 읽고 잘못된 잘못된 결과 Blob을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7a03fbfd7f6822486dc5e29a1dba526a017e4427" translate="yes" xml:space="preserve">
          <source>The emulator restart on Windows NT expects that the system is started using the &lt;code&gt;erlsrv&lt;/code&gt; program (as a service). Furthermore, the release handler expects that the service is named &lt;code&gt;NodeName&lt;/code&gt;_&lt;code&gt;Release&lt;/code&gt;, where &lt;code&gt;NodeName&lt;/code&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;code&gt;Release&lt;/code&gt; is the current release version. The release handler furthermore expects that a program like &lt;code&gt;start_erl.exe&lt;/code&gt; is specified as &quot;machine&quot; to &lt;code&gt;erlsrv&lt;/code&gt;. During upgrading with restart, a new service is registered and started. The new service is set to automatic and the old service is removed when the new release is made permanent.</source>
          <target state="translated">Windows NT에서 에뮬레이터를 다시 시작하면 &lt;code&gt;erlsrv&lt;/code&gt; 프로그램을 서비스로 사용하여 시스템이 시작될 것으로 예상 됩니다. 또한 릴리스 핸들러는 서비스 이름이 &lt;code&gt;NodeName&lt;/code&gt; _ &lt;code&gt;Release&lt;/code&gt; 인 것으로 예상합니다. 여기서 &lt;code&gt;NodeName&lt;/code&gt; 은 Erlang 노드 이름의 첫 부분 ( &quot;@&quot;까지 포함)이고 &lt;code&gt;Release&lt;/code&gt; 는 현재 릴리스 버전입니다. 릴리스 핸들러는 또한 같은 프로그램을 것으로 예상 &lt;code&gt;start_erl.exe&lt;/code&gt; 이 가 &quot;기계&quot;로 지정됩니다 &lt;code&gt;erlsrv&lt;/code&gt; . 다시 시작하여 업그레이드하는 동안 새 서비스가 등록되고 시작됩니다. 새 서비스가 자동으로 설정되고 새 서비스가 영구적으로 만들어지면 이전 서비스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e59343153e5b1fe6b3e23daad5cd40c9373e3696" translate="yes" xml:space="preserve">
          <source>The encoder and decoder can also be run from the shell:</source>
          <target state="translated">셸에서 인코더와 디코더를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5524aa1d01a0ef49a1ac5386a1c63b808ac68425" translate="yes" xml:space="preserve">
          <source>The encoder callback interface is defined by the &lt;code&gt;megaco_encoder&lt;/code&gt; behaviour, see &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코더 콜백 인터페이스에 의해 정의된다 &lt;code&gt;megaco_encoder&lt;/code&gt; 의 행동을 참조 &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e115c3caf0848d64461367ca5e16e6bd2197d5d0" translate="yes" xml:space="preserve">
          <source>The encoding fails if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;from_enc&lt;/code&gt; 인코딩에서 유효한 문자열이 아닌 경우 인코딩이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="09633aa618d0dc8af3be96ad739582e309ef108d" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 설명 된 주석으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ac74f2d9e4b6b15103658ee4d9051874ee9e500" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment, as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 설명 된대로 주석으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d77e867cd506d61a5b722d136e431c9f033298c" translate="yes" xml:space="preserve">
          <source>The encoding of each file can be specified using comments as described in the &lt;code&gt;epp(3)&lt;/code&gt; module.</source>
          <target state="translated">각 파일의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 모듈에 설명 된대로 주석을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e2118a8dc4b068a3e8e22ff922dd1be302891f7" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (BER), Packed Encoding Rules (PER) aligned, and PER unaligned. If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">사용될 인코딩 규칙. 지원되는 인코딩 규칙은 BER (Basic Encoding Rules), PER (Packed Encoding Rules) 정렬 및 PER 정렬되지 않음입니다. 인코딩 규칙 옵션을 생략하면 &lt;code&gt;ber&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6f95e0e32837beadf0f93d78df4e27d5991fa179" translate="yes" xml:space="preserve">
          <source>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, must be set explicitly as follows:</source>
          <target state="translated">위에서 언급 한 주석으로 지정된 인코딩은 스크립트 자체에 적용됩니다. 그러나 I / O 서버의 인코딩은 다음과 같이 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c828e598776df003c2646b5bcedb28e057c204" translate="yes" xml:space="preserve">
          <source>The encoding_config of the megaco_erl_dist_encoder module may be one of these:</source>
          <target state="translated">megaco_erl_dist_encoder 모듈의 encoding_config는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f48fa03ddf781f161c43a06b94c0c75681b96550" translate="yes" xml:space="preserve">
          <source>The endianness specification can be either &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, or &lt;code&gt;native&lt;/code&gt;. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is &quot;native&quot; for the CPU that the Erlang machine is run on.</source>
          <target state="translated">엔디안 사양이 될 수 있습니다 &lt;code&gt;big&lt;/code&gt; , &lt;code&gt;little&lt;/code&gt; , 또는 &lt;code&gt;native&lt;/code&gt; . Native-endian은 Erlang 시스템이 실행되는 CPU의 &quot;네이티브&quot;에 따라 엔디안이로드시 빅 엔디안 또는 리틀 엔디안으로 해석됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="60e0f49d56e51cf1a5d46c013c216c0ae5dc1eb9" translate="yes" xml:space="preserve">
          <source>The entire contents of the cache will be deleted.</source>
          <target state="translated">캐시의 전체 내용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a01a496ea7149df2179e8879a105341306c0f911" translate="yes" xml:space="preserve">
          <source>The entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, even when a list of objects is inserted.</source>
          <target state="translated">개체 목록이 삽입 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 경우에도 전체 작업이 원자 적이며 격리 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a75cc762ec33088a0ac070865ceb613941ab44" translate="yes" xml:space="preserve">
          <source>The entire program is motorcycles2html.erl:</source>
          <target state="translated">전체 프로그램은 motorcycles2html.erl입니다.</target>
        </trans-unit>
        <trans-unit id="ac7e661e53cfa83634f92105a4582a374de077bb" translate="yes" xml:space="preserve">
          <source>The entire tar file is compressed, as if it has been run through the &lt;code&gt;gzip&lt;/code&gt; program. To abide to the convention that a compressed tar file is to end in &quot;&lt;code&gt;.tar.gz&lt;/code&gt;&quot; or &quot;&lt;code&gt;.tgz&lt;/code&gt;&quot;, add the appropriate extension.</source>
          <target state="translated">전체 tar 파일은 마치 &lt;code&gt;gzip&lt;/code&gt; 프로그램을 통해 실행 된 것처럼 압축 됩니다. 압축 된 tar 파일이 &quot; &lt;code&gt;.tar.gz&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;.tgz&lt;/code&gt; &quot; 로 끝나는 규칙을 준수하려면 적절한 확장자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e1f58ced4a1c7fafa8f4a838e0a3347b18963414" translate="yes" xml:space="preserve">
          <source>The entities involved in this model are the agent, which terminates the management protocol, and the resources, which is to be managed, that is, the actual application entities. The resources should in general have no knowledge of the management protocol used, and the agent should have no knowledge of the managed resources. This implies that a translation mechanism is needed, to translate the management operations to operations on the resources. This translation mechanism is usually called &lt;strong&gt;instrumentation&lt;/strong&gt; and the function that implements it is called &lt;strong&gt;instrumentation function&lt;/strong&gt;. The instrumentation functions are written for each combination of management protocol and resource to be managed. For example, if an application is to be managed by SNMP and HTTP, two sets of instrumentation functions are defined; one that maps SNMP requests to the resources, and one that, for example, generates an HTML page for some resources.</source>
          <target state="translated">이 모델에 포함 된 엔터티는 관리 프로토콜을 종료하는 에이전트와 관리 할 리소스, 즉 실제 응용 프로그램 엔터티입니다. 일반적으로 자원에는 사용 된 관리 프로토콜에 대한 지식이 없어야하며 에이전트는 관리 자원에 대한 지식이 없어야합니다. 이는 관리 작업을 리소스에 대한 작업으로 변환하기 위해 변환 메커니즘이 필요함을 의미합니다. 이 변환 메커니즘을 일반적으로 &lt;strong&gt;계측&lt;/strong&gt; 이라고하며이를 구현하는 기능을 &lt;strong&gt;계측 기능&lt;/strong&gt; 이라고 &lt;strong&gt;합니다.&lt;/strong&gt;. 인스 트루먼 테이션 기능은 관리 할 각 관리 프로토콜 및 자원 조합에 대해 작성됩니다. 예를 들어, 어플리케이션이 SNMP 및 HTTP로 관리되는 경우 두 가지 계측 기능 세트가 정의됩니다. 하나는 SNMP 요청을 리소스에 매핑하고 다른 하나는 일부 리소스에 대한 HTML 페이지를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc41ee140a0e19b3389932dacfd061ee5abd2931" translate="yes" xml:space="preserve">
          <source>The entry format in all files are Erlang terms, separated by a '&lt;strong&gt;.&lt;/strong&gt;' and a &lt;strong&gt;newline&lt;/strong&gt;. In the following sections, the formats of these terms are described. Comments may be specified as ordinary Erlang comments.</source>
          <target state="translated">모든 파일의 입력 형식은 Erlang 용어이며 '로 구분됩니다 &lt;strong&gt;. &lt;/strong&gt;'와 &lt;strong&gt;줄 바꿈&lt;/strong&gt; . 다음 섹션에서는 이러한 용어의 형식에 대해 설명합니다. 코멘트는 일반적인 Erlang 코멘트로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb54532373ef856c343b0b5dff86075c30ed3fbc" translate="yes" xml:space="preserve">
          <source>The entry point of the process, that is, what function was referenced in the &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt; call that started the process.</source>
          <target state="translated">인 프로세스의 진입 점은, 어떤 기능은에서 참조 된 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;spawn_link&lt;/code&gt; 과정을 시작 호출.</target>
        </trans-unit>
        <trans-unit id="7f963220ca94e530caaeba1df441378f7d481672" translate="yes" xml:space="preserve">
          <source>The enumerated type is similar to an integer type, when defined with a set of predefined values. The difference is that an enumerated type can only have specified values, whereas an integer can have any value.</source>
          <target state="translated">열거 된 유형은 사전 정의 된 값 세트로 정의 될 때 정수 유형과 유사합니다. 차이점은 열거 된 유형은 지정된 값만 가질 수있는 반면 정수는 모든 값을 가질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3be6551e42e26d4ead34f786dcb51c0272efaf5" translate="yes" xml:space="preserve">
          <source>The environment can also affect filename interpretation, if Erlang is started with flag &lt;code&gt;+fna&lt;/code&gt; (which is default from Erlang/OTP 17.0).</source>
          <target state="translated">Erlang이 플래그 &lt;code&gt;+fna&lt;/code&gt; (Erlang / OTP 17.0의 기본값 )로 시작되면 환경은 파일 이름 해석에도 영향을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="913d6ab5c0934539b281e92b0bf02bbbfef5d5f9" translate="yes" xml:space="preserve">
          <source>The environment of an Erlang machine started as a service contains two special variables:</source>
          <target state="translated">서비스로 시작된 Erlang 시스템의 환경에는 두 가지 특수 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="572b1efce0a6ff1c606a8d7cea991c683d1b2312" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must be &lt;code&gt;NULL&lt;/code&gt; only if calling from a created thread.</source>
          <target state="translated">호출 프로세스의 환경. 작성된 스레드에서 호출하는 경우에만 &lt;code&gt;NULL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="08711127236c0db559a0b4dc910c12dabe3750d5" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must not be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스의 환경. &lt;code&gt;NULL&lt;/code&gt; 이 아니 어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdd010a7cf9f07e2e5e5be6548225fb6c23b8fd6" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; 로 할당 된 프로세스 독립적 환경 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3da50f98e6b47c2b008dfdf790cd4b0c2b6bf64d" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 NULL로 할당 된 프로세스 독립적 환경이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2fa8fc26b6ef033d7a364376d908df5f6b781167" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; can be used to indicate which logical cluster a C-node belongs to.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 를 사용하여 C 노드가 속하는 논리 클러스터를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e087dc753b87601d38d03f83c1f1759586e203d5" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; can be used to configure the heart time-outs; it can be set in the operating system shell before Erlang is started or be specified at the command line:</source>
          <target state="translated">환경 변수 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 을 사용하여 하트 타임 아웃을 구성 할 수 있습니다. Erlang을 시작하기 전에 운영 체제 쉘에서 설정하거나 명령 행에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dd0dd179f2f7ae89d1e41f5898aa9a98a1d1adc" translate="yes" xml:space="preserve">
          <source>The environment variables can also be used to detect that we are running as a service and make port programs react correctly to the control events generated on logout (see the next section).</source>
          <target state="translated">또한 환경 변수를 사용하여 서비스로 실행 중임을 감지하고 포트 프로그램이 로그 아웃시 생성 된 제어 이벤트에 올바르게 반응하도록 할 수 있습니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="0155a47d2e3d28b9149121cf101f2c0d304723b6" translate="yes" xml:space="preserve">
          <source>The erl scheme is designed to mimic plain CGI, but without the extra overhead. An URL that calls an Erlang &lt;code&gt;erl&lt;/code&gt; function has the following syntax (regular expression):</source>
          <target state="translated">erl 체계는 일반 CGI를 모방하도록 설계되었지만 추가 오버 헤드는 없습니다. Erlang &lt;code&gt;erl&lt;/code&gt; 함수 를 호출하는 URL의 구문은 다음과 같습니다 (정규 표현식).</target>
        </trans-unit>
        <trans-unit id="9f146c11c8615922912cc793d4380f3827809366" translate="yes" xml:space="preserve">
          <source>The erlang connection process spawned by connect/2, will open a port to a c-process that handles the communication with the database through Microsoft's ODBC API. The erlang port will be kept open for exit signal propagation, if something goes wrong in the c-process and it exits we want know as mush as possible about the reason. The main communication with the c-process is done through sockets. The C-process consists of two threads, the supervisor thread and the database handler thread. The supervisor thread checks for shutdown messages on the supervisor socket and the database handler thread receives requests and sends answers on the database socket. If the database thread seems to hang on some database call, the erlang control process will send a shutdown message on the supervisor socket, in this case the c-process will exit. If the c-process crashes/exits it will bring the erlang-process down too and vice versa i.e. the connection is terminated.</source>
          <target state="translated">connect / 2에 의해 생성 된 erlang 연결 프로세스는 Microsoft의 ODBC API를 통해 데이터베이스와의 통신을 처리하는 c-process에 대한 포트를 엽니 다. c- 프로세스에서 문제가 발생하고 종료되면 erlang 포트는 종료 신호 전파를 위해 열린 상태로 유지됩니다. c-process와의 주요 통신은 소켓을 통해 수행됩니다. C- 프로세스는 감독자 스레드와 데이터베이스 핸들러 스레드의 두 스레드로 구성됩니다. 수퍼바이저 스레드는 수퍼바이저 소켓에서 종료 메시지를 확인하고 데이터베이스 핸들러 스레드는 요청을 수신하고 데이터베이스 소켓에서 응답을 보냅니다. 데이터베이스 스레드가 일부 데이터베이스 호출에서 정지 된 것으로 보이면 erlang 제어 프로세스는 수퍼바이저 소켓에서 종료 메시지를 보내며이 경우 c- 프로세스가 종료됩니다.c- 프로세스가 충돌 / 종료되면 erlang-process도 다운되고 그 반대도 마찬가지입니다. 즉 연결이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="df7997d41de6ac2a1785cee171c352d42d04f93c" translate="yes" xml:space="preserve">
          <source>The error behavior differs, see below.</source>
          <target state="translated">오류 동작이 다릅니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="011b09627444a05b2b15d34028f40a28dfdddfe0" translate="yes" xml:space="preserve">
          <source>The error descriptor defaults to &lt;code&gt;DefaultED&lt;/code&gt;, but can be overridden with an alternate one by returning &lt;code&gt;{reply,ED}&lt;/code&gt; or &lt;code&gt;{no_reply,ED}&lt;/code&gt; instead of &lt;code&gt;reply&lt;/code&gt; and &lt;code&gt;no_reply&lt;/code&gt; respectively.</source>
          <target state="translated">오류 디스크립터의 기본값은 &lt;code&gt;DefaultED&lt;/code&gt; 이지만 &lt;code&gt;{reply,ED}&lt;/code&gt; &lt;code&gt;reply&lt;/code&gt; 및 &lt;code&gt;no_reply&lt;/code&gt; 대신 각각 {reply, ED} 또는 &lt;code&gt;{no_reply,ED}&lt;/code&gt; 를 리턴하여 대체 디스크립터 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="461fac531aaf141393d180babf97f72d93ada5dc" translate="yes" xml:space="preserve">
          <source>The error handling strategy and possible errors sources are described in the Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">오류 처리 전략 및 가능한 오류 소스는 Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d405471c43706742d66ca4dd53edcd35e7ff6cb" translate="yes" xml:space="preserve">
          <source>The error information is handled by Logger, which is part of the Kernel application.</source>
          <target state="translated">오류 정보는 커널 응용 프로그램의 일부인 로거에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb4cd48329bca9a99f8dc4cb317a0559bc9784e" translate="yes" xml:space="preserve">
          <source>The error message will look like this:</source>
          <target state="translated">오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3061a1ab3e6a1d434208df5bfeb44852fc476d18" translate="yes" xml:space="preserve">
          <source>The error report module is configured using the directive &lt;code&gt;error_report_mod&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류 보고서 모듈은 &lt;code&gt;error_report_mod&lt;/code&gt; 지시문을 사용하여 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="36a00c6827ff6af3c91907db56029def4bf079b7" translate="yes" xml:space="preserve">
          <source>The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.</source>
          <target state="translated">오류 및 경고는 양식에서 발생하는 순서대로 나열됩니다. 따라서 한 파일의 오류는 오류 목록에서 다른 항목으로 분할 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3460fc594164d8bbf96577fb24868bb714be37" translate="yes" xml:space="preserve">
          <source>The errors detected include:</source>
          <target state="translated">감지 된 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b62e06cf6a78a94894293a2f2fefb7491e659ccc" translate="yes" xml:space="preserve">
          <source>The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.</source>
          <target state="translated">이스케이프 \ o 뒤에는 중괄호로 묶인 일련의 8 진 숫자가 와야합니다. 그렇지 않은 경우 오류가 발생합니다. 이 탈출은 최근 Perl에 추가 된 것입니다. 문자 코드 포인트를 0777보다 큰 8 진수로 지정하는 방법을 제공하며, 8 진수와 역 참조를 명확하게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09cca6482e14cefd7789aca27e688d2b8fc2ae0" translate="yes" xml:space="preserve">
          <source>The escape sequence \K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</source>
          <target state="translated">이스케이프 시퀀스 \ K를 사용하면 이전에 일치 한 문자가 최종 일치 시퀀스에 포함되지 않습니다. 예를 들어 다음 패턴은 &quot;foobar&quot;와 일치하지만 &quot;bar&quot;와 일치한다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="1fdcd1532b972da832570c4e46f8a01588e3f319" translate="yes" xml:space="preserve">
          <source>The escape sequence \N behaves like a dot, except that it is not affected by option &lt;code&gt;PCRE_DOTALL&lt;/code&gt;. That is, it matches any character except one that signifies the end of a line. Perl also uses \N to match characters by name but PCRE does not support this.</source>
          <target state="translated">이스케이프 시퀀스 \ N은 &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 옵션의 영향을받지 않는 점을 제외하고 점처럼 동작 합니다. 즉, 행의 끝을 나타내는 문자를 제외한 모든 문자와 일치합니다. Perl은 \ N을 사용하여 이름별로 문자를 일치 시키지만 PCRE는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ac8458115fbc9af33358e4aea3bbde3c0be1319" translate="yes" xml:space="preserve">
          <source>The escape sequences allowed are the same as for Erlang strings:</source>
          <target state="translated">허용되는 이스케이프 시퀀스는 Erlang 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="32812c856e631f3ed1dcd90e3601c5c2b3077c8f" translate="yes" xml:space="preserve">
          <source>The eval scheme can seriously threaten the integrity of the Erlang node housing a web server, for example:</source>
          <target state="translated">평가 체계는 웹 서버를 수용하는 Erlang 노드의 무결성을 심각하게 위협 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21baa0e66c42986302a436c2cc18ea33ca352672" translate="yes" xml:space="preserve">
          <source>The eval scheme is straight-forward and does not mimic the behavior of plain CGI. An URL that calls an Erlang &lt;code&gt;eval&lt;/code&gt; function has the following syntax:</source>
          <target state="translated">평가 체계는 간단하며 일반 CGI의 동작을 모방하지 않습니다. Erlang &lt;code&gt;eval&lt;/code&gt; 함수 를 호출하는 URL의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10a18f07017de460e02711d1cf0600325f33b7fb" translate="yes" xml:space="preserve">
          <source>The evaluation of the query fails if the &lt;code&gt;qlc&lt;/code&gt; module cannot carry out the chosen join method. Defaults to &lt;code&gt;any&lt;/code&gt;, which means that some fast join method is used if possible.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 선택된 결합 방법을 수행 할 수없는 경우 쿼리 평가에 실패합니다 . 기본값은 &lt;code&gt;any&lt;/code&gt; 로 , 가능하면 일부 빠른 조인 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa8e9b7cfecc247f7bff705d3a3988485befc88c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed (user) type application expression.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 &lt;code&gt;syntax_error&lt;/code&gt; 형식의 사용자 유형 애플리케이션 표현식을 나타내지 않으면 평가에서 syntax_error가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4921b565820162e2c60edc6bea683451b957b890" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed &lt;code&gt;file&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 &lt;code&gt;file&lt;/code&gt; 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="618ce4cbe8b9ff30f535342ccae4d3cf10b313ea" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed application expression.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 애플리케이션 표현식을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="dc7fabf51da4bb4e7f1257e9d4dede7a0e536748" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed export attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 내보내기 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0f66579024f348d7bb0f390e794429a5be199446" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function definition.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 함수 정의를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5406ed8fb8fc38e89372ce85d6f56374209215a4" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function name.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 함수 이름을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="30e8edf0d9aca5a1873eb5bed65e4d0bd6633e76" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed implicit fun.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 암시 적 재미를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="9cbc54914d2a7b46a8529bdd08a5e3617825c157" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed import attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 가져 오기 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1ce44851dc662379c8d2493f03d24234da3c175f" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed module attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 모듈 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e9d8a2fbebf4113ef3337fce36bf9fbf369a6379" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record declaration attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 레코드 선언 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf9e76769c09ba06d5b9bf9c1944e2acfb2dfc1a" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record field specifier.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 레코드 필드 지정자를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ea05ee075bf7f2350e2fc6059b34cff5cb33b78c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed type name.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 이름을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="363e188710c96a0d0d2f45cbb80bd88dddfe084d" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed wild attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 와일드 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="223a63e0ec00c2810aadc750354eca2f59b6acb8" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not well-formed.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 제대로 구성되지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="527c092490ea3417d05959de64ac4673c4e2242c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; represents a record expression that is not well-formed.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 &lt;code&gt;syntax_error&lt;/code&gt; 이 올바르지 않은 레코드 표현식을 나타내는 경우 평가에서 syntax_error 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="78caee1b9d51c269ecfa277516c192bac800da86" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if an ill-formed Erlang construct is encountered.</source>
          <target state="translated">잘못 구성된 Erlang 구문이 발견되면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e360281a65b675290b77c855abb3396feae48026" translate="yes" xml:space="preserve">
          <source>The event &lt;code&gt;user_unblock&lt;/code&gt; is not triggered when a user is removed from the block list explicitly using the &lt;code&gt;unblock_user&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;unblock_user&lt;/code&gt; 함수를 사용하여 명시 적으로 사용자를 차단 목록에서 제거하면 &lt;code&gt;user_unblock&lt;/code&gt; 이벤트 가 트리거되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e9adf6f3e6bc9d678bcfcbf56c75783efdc79bfe" translate="yes" xml:space="preserve">
          <source>The event handler must be able to handle the events in this module, see section &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러는이 모듈에서 이벤트를 처리 할 수 ​​있어야합니다 ( &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="07fadfa5cd3629d9138971bd824a14ddd43b2990" translate="yes" xml:space="preserve">
          <source>The event handler return values are defined in the description of &lt;code&gt;Module:StateName/3&lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">이벤트 핸들러 리턴 값은 &lt;code&gt;gen_statem&lt;/code&gt; 매뉴얼 페이지 의 &lt;code&gt;Module:StateName/3&lt;/code&gt; 에 대한 설명에 정의되어 있지만 다음은 더 읽기 쉬운 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9b5aab32f54b078cb1c0faaf00cf7eb4a19eec31" translate="yes" xml:space="preserve">
          <source>The event handler terminates abnormally and &lt;code&gt;gen_event&lt;/code&gt; logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">이벤트 핸들러가 비정상적으로 종료되고 &lt;code&gt;gen_event&lt;/code&gt; 가 오류를 기록합니다. 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7f89716df5f45b5490450ec2ac15b0b43b462e0" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler.</source>
          <target state="translated">이벤트는 기본 로거 핸들러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2545cd2dda316056d2647ebcf0c0876379df39a7" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler. The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트는 기본 로거 핸들러에 의해 처리됩니다. 로그 레벨을 error 또는 info로 변경할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="836db6626acc8d2b63d4479e731dd11320410d43" translate="yes" xml:space="preserve">
          <source>The event is handled by:</source>
          <target state="translated">이벤트는 다음에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="670f3a97ec79b1617d1253c86abd242fbfe96cb8" translate="yes" xml:space="preserve">
          <source>The event is made into a message and sent to the event manager. When the event is received, the event manager calls &lt;code&gt;handle_event(Event, State)&lt;/code&gt; for each installed event handler, in the same order as they were added. The function is expected to return a tuple &lt;code&gt;{ok,State1}&lt;/code&gt;, where &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the event handler.</source>
          <target state="translated">이벤트는 메시지로 작성되어 이벤트 관리자에게 전송됩니다. 이벤트가 수신되면, 이벤트 관리자는 설치된 각 이벤트 핸들러에 대해 &lt;code&gt;handle_event(Event, State)&lt;/code&gt; 를 추가 된 순서대로 호출합니다 . 이 함수는 튜플 &lt;code&gt;{ok,State1}&lt;/code&gt; 을 리턴 할 것으로 예상되며 , 여기서 &lt;code&gt;State1&lt;/code&gt; 은 이벤트 핸들러 상태의 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="b73ba2f2d96d9d903429f26f68141cab3925fb1c" translate="yes" xml:space="preserve">
          <source>The event is sent to the &lt;code&gt;gen_statem&lt;/code&gt;. When the event is received, the &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt;, or &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt;. &lt;code&gt;StateName&lt;/code&gt; is the name of the current state and &lt;code&gt;NewStateName&lt;/code&gt; is the name of the next state to go to. &lt;code&gt;NewData&lt;/code&gt; is a new value for the server data of the &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;Actions&lt;/code&gt; is a list of actions to be performed by the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">이벤트는 &lt;code&gt;gen_statem&lt;/code&gt; 으로 전송됩니다 . 이벤트가 수신되면 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt; 호출 하여 튜플 &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt; 또는 &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt; 을 리턴 할 것으로 예상됩니다 . &lt;code&gt;StateName&lt;/code&gt; 은 현재 상태 의 이름 이고 &lt;code&gt;NewStateName&lt;/code&gt; 은 다음에 갈 상태의 이름입니다. &lt;code&gt;NewData&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 서버 데이터에 대한 새로운 값 이며, &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 엔진 이 수행 할 조치 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="482c8d79933fe33bda06c58901ec825b1db485ea" translate="yes" xml:space="preserve">
          <source>The event manager essentially maintains a list of &lt;code&gt;{Module, State}&lt;/code&gt; pairs, where each &lt;code&gt;Module&lt;/code&gt; is an event handler, and &lt;code&gt;State&lt;/code&gt; is the internal state of that event handler.</source>
          <target state="translated">이벤트 관리자는 기본적으로 &lt;code&gt;{Module, State}&lt;/code&gt; 쌍 의 목록을 유지 보수합니다 . 여기서 각 &lt;code&gt;Module&lt;/code&gt; 은 이벤트 핸들러이고 &lt;code&gt;State&lt;/code&gt; 는 해당 이벤트 핸들러의 내부 상태입니다.</target>
        </trans-unit>
        <trans-unit id="76d57c410515c44cc8bc28a8d09b64ef1f2639aa" translate="yes" xml:space="preserve">
          <source>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, it terminates if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent.</source>
          <target state="translated">이벤트 관리자가 감독 트리의 일부인 경우 이벤트 관리자가 종료되며 감독자에 의해 종료되도록 명령됩니다. 감독 트리의 일부 가 &lt;strong&gt;아니더라도&lt;/strong&gt; 상위 트리에서 &lt;code&gt;'EXIT'&lt;/code&gt; 메시지를 받으면 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2ce4c38c0aa823b9e5e74e4d8bcd2d1c4f1111f" translate="yes" xml:space="preserve">
          <source>The event tracer framework is made up of four modules:</source>
          <target state="translated">이벤트 추적 프로그램 프레임 워크는 다음 네 가지 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f7cae16de84ad2c9c39b99cb4c031af931d1d5" translate="yes" xml:space="preserve">
          <source>The event types are described in the next sections.</source>
          <target state="translated">이벤트 유형은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1782c63eb3688ca0c9af0612dd19da36a393122" translate="yes" xml:space="preserve">
          <source>The events are also documented in &lt;code&gt;ct_event.erl&lt;/code&gt;. This module can serve as an example of what an event handler for the &lt;code&gt;Common Test&lt;/code&gt; event manager can look like.</source>
          <target state="translated">이벤트는 &lt;code&gt;ct_event.erl&lt;/code&gt; 에도 문서화되어 있습니다 . 이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 이벤트 관리자에 대한 이벤트 핸들러의 모양에 대한 예를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa54bda16841cabde0c2e6fc00114e179e4c8c7f" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트는 이벤트를 생성 한 프로세스에 의해 정의 된 함수 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt; 호출)로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9d4c6263423994284ba2b9c6d7623abbea04412" translate="yes" xml:space="preserve">
          <source>The example &lt;code&gt;Subject&lt;/code&gt; field has one C, two CN and one O part. It is only the CN (Common Name) that is used by hostname verification. The two other (C and O) is not used here even when they contain a domain name like the O part. The C and O parts are defined elsewhere and meaningful only for other functions.</source>
          <target state="translated">예제 &lt;code&gt;Subject&lt;/code&gt; 필드에는 C 1 개, CN 2 개, O 파트 1 개가 있습니다. 호스트 이름 확인에 사용되는 것은 CN (일반 이름)뿐입니다. 다른 두 부분 (C 및 O)은 O 부분과 같은 도메인 이름을 포함하더라도 여기에서 사용되지 않습니다. C 및 O 부분은 다른 곳에서 정의되며 다른 기능에 대해서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53789d2e92c1fda46d0fae07ec08f87e98bdd01d" translate="yes" xml:space="preserve">
          <source>The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.</source>
          <target state="translated">예제 I / O 서버는 문자를 ETS 테이블에 저장하여 상당히 조잡한 RAM 파일을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="3a18dec0331c54c7d131f7f05a54cda624c44be5" translate="yes" xml:space="preserve">
          <source>The example below sets up trace on the exported functions (default) of module &lt;code&gt;snmp_generic&lt;/code&gt; and all functions of module &lt;code&gt;snmp_generic_mnesia&lt;/code&gt;. With return values (which is default) and timestamps in both cases (which is also default):</source>
          <target state="translated">모듈의 내보내기 기능 (기본값)에 대한 추적 설정 아래의 예를 &lt;code&gt;snmp_generic&lt;/code&gt; 및 모듈의 모든 기능 &lt;code&gt;snmp_generic_mnesia&lt;/code&gt; . 반환 값 (기본값)과 두 경우 모두 타임 스탬프 (기본) :</target>
        </trans-unit>
        <trans-unit id="40ec67cee0f09e7e1f38061d74546bfcd1432fac" translate="yes" xml:space="preserve">
          <source>The example manager, &lt;code&gt;snmp_ex2_manager&lt;/code&gt;, is a simple example of how to implement an snmp manager using the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">&lt;code&gt;snmp_ex2_manager&lt;/code&gt; 예제 관리자 는 SNMP Development Toolkit의 관리자 구성 요소를 사용하여 snmp 관리자를 구현하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="bfa0e44fefc9103dfe63a4cd1030807bc049d616" translate="yes" xml:space="preserve">
          <source>The example servers so far in this chapter print the full internal state in the error log, for example, when killed by an exit signal or because of an internal error. This state contains both the code lock code and which digits that remain to unlock.</source>
          <target state="translated">이 장의 지금까지 예제 서버는 종료 신호에 의해 종료되거나 내부 오류로 인해 오류 로그에 전체 내부 상태를 인쇄합니다. 이 상태에는 코드 잠금 코드와 잠금 해제 상태로 남아있는 숫자가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="266205b844f4f6e3267e956b4430b205e05dad6e" translate="yes" xml:space="preserve">
          <source>The example showed the background work that the shell performs just to interpret the first command line. Most work is done by &lt;code&gt;erl_eval&lt;/code&gt; and &lt;code&gt;orddict&lt;/code&gt;.</source>
          <target state="translated">이 예는 쉘이 첫 번째 명령 행을 해석하기 위해 수행하는 백그라운드 작업을 보여줍니다. 대부분의 작업은 &lt;code&gt;erl_eval&lt;/code&gt; 및 &lt;code&gt;orddict&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f7ad9497d8d5ee7ec068f8bbaf412b434e2689f" translate="yes" xml:space="preserve">
          <source>The example shown can be found in the toolkit distribution.</source>
          <target state="translated">표시된 예제는 툴킷 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="396a52ee352a84ef61ae01c6d40809962c1134e8" translate="yes" xml:space="preserve">
          <source>The example shown, &lt;strong&gt;ex2&lt;/strong&gt;, can be found in the toolkit distribution.</source>
          <target state="translated">&lt;strong&gt;ex2&lt;/strong&gt; 예제 는 툴킷 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7c4a3f89e04c623143e7c4c121106db17b0068" translate="yes" xml:space="preserve">
          <source>The example shows some details of how &lt;code&gt;lists:sort/1&lt;/code&gt; works. It used 6047 function calls in the module &lt;code&gt;lists_sort&lt;/code&gt; to complete the work.</source>
          <target state="translated">이 예는 &lt;code&gt;lists:sort/1&lt;/code&gt; 작동 방식 에 대한 세부 정보를 보여줍니다 . &lt;code&gt;lists_sort&lt;/code&gt; 모듈에서 6047 함수 호출을 사용 하여 작업을 완료했습니다.</target>
        </trans-unit>
        <trans-unit id="361c007ea7390ae514b7d7274e3225478c75cf81" translate="yes" xml:space="preserve">
          <source>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</source>
          <target state="translated">이 예에서는 암호에 대해 두 방향 (client2server 및 server2client)으로 서로 다른 알고리즘을 지정하지만, 양방향으로 mac 및 압축에 대해 동일한 알고리즘을 지정합니다. kex (키 교환)는 암시 적이지만 public_key는 명시 적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c97ac9647ab00e65e37eca74aa7e20c8819a73a3" translate="yes" xml:space="preserve">
          <source>The example specifies that:</source>
          <target state="translated">예제는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="839951ee6733677e5315d3af4eb38dc5514df04f" translate="yes" xml:space="preserve">
          <source>The example specifies the following:</source>
          <target state="translated">예제는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5e9468869847362818e3653dadf86b7f55f088d1" translate="yes" xml:space="preserve">
          <source>The example tells us that &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot; was registered on a Monday (since the return value of the first command is 1), and that the &lt;code&gt;calendar&lt;/code&gt; module needed 9 function calls to calculate that.</source>
          <target state="translated">이 예에서는 월요일에 &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot;가 등록되었고 (첫 번째 명령의 반환 값이 1이므로) &lt;code&gt;calendar&lt;/code&gt; 모듈이이를 계산하기 위해 9 개의 함수 호출이 필요했음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4ffa934118cebf3f90cde4787faaae21bba8d06a" translate="yes" xml:space="preserve">
          <source>The exec-option fun is called with the same number of parameters as the arity of the fun, and the result is returned to the client.</source>
          <target state="translated">exec 옵션 fun은 fun의 arity와 동일한 수의 매개 변수로 호출되며 결과는 클라이언트로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b071e577cae1eeba87f1871188878bd3a2873b58" translate="yes" xml:space="preserve">
          <source>The exec-option has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-4 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">exec 옵션은 오랫동안 존재했지만 이전에 문서화되지 않았습니다. 이전 정의와 동작은 유지되지만 충돌하는 경우 위의 1-4 규칙을 준수하십시오. 구식 및 문서화되지 않은 스타일은 새 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b1895955082bfa77ca24a94c48e11688ebe85d9a" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client.</source>
          <target state="translated">실행 요청이 평가되지 않고 클라이언트에 오류 메시지가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0c24b69b74e8713f113ddc4cb4727d97ca1bd44b" translate="yes" xml:space="preserve">
          <source>The executable name (also known as &lt;code&gt;argv[0]&lt;/code&gt;) is not to be specified in this list. The proper executable name is automatically used as &lt;code&gt;argv[0]&lt;/code&gt;, where applicable.</source>
          <target state="translated">실행 파일 이름 ( &lt;code&gt;argv[0]&lt;/code&gt; 이라고도 함 )은이 목록에 지정되지 않습니다. 해당되는 경우 적절한 실행 파일 이름이 &lt;code&gt;argv[0]&lt;/code&gt; 으로 자동 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7703497b2d1d6d7ae666f5086932193209c602a9" translate="yes" xml:space="preserve">
          <source>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</source>
          <target state="translated">런타임 시스템이 추적 메시지를 보낼지 여부를 결정할 때 일치 표현식의 실행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8e42abde3dd1496d089519cf10c81e1be53df" translate="yes" xml:space="preserve">
          <source>The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 기능 실행 시간은 목록을 정렬하는 데 걸리는 시간에 의해 결정됩니다. 정렬이 필요하지 않은 경우 실행 시간은 최악의 경우 입력 인수의 크기와 반환 된 값의 합계에 비례합니다. &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 과 같은 몇 가지 함수가 일정한 시간에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="420632c27cadb89b2f399b84682c82a68f0a0d31" translate="yes" xml:space="preserve">
          <source>The existing association argument &lt;code&gt;Assoc&lt;/code&gt; can be either a &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; record as returned from, for example, &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, or from a listening socket in active mode. It can also be just the field &lt;code&gt;assoc_id&lt;/code&gt; integer from such a record.</source>
          <target state="translated">기존 연관 인수 &lt;code&gt;Assoc&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 와 같이 또는 활성 모드의 청취 소켓에서 리턴 된 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 레코드 일 수 있습니다 . 또한 그러한 레코드에서 필드 &lt;code&gt;assoc_id&lt;/code&gt; 정수일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78f8f6f791625c1c8fdb334b26d42632cd9d6c18" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt;Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템에서 사용되는 종료 이유 (예 : &lt;code&gt;badarg&lt;/code&gt; )는 &lt;code&gt;Errors and Error Handling&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ae7040a803e376f91e7e700a11833b4ef1676c" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종료 값은 나중에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 다른 스레드에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fde359ee385d3e78714231ab869d10ea4d9e799" translate="yes" xml:space="preserve">
          <source>The exported function &lt;code&gt;f/1&lt;/code&gt; is deprecated. Nothing is said whether &lt;code&gt;f/1&lt;/code&gt; will be removed or not.</source>
          <target state="translated">내 보낸 함수 &lt;code&gt;f/1&lt;/code&gt; 은 더 이상 사용되지 않습니다. &lt;code&gt;f/1&lt;/code&gt; 이 제거 될지 여부는 알려지지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="47e6598c7dcf7a2b613f4f2e9c2f96997e697806" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;Expr&lt;/code&gt; is evaluated and the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result. If a match succeeds and the optional guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;Body&lt;/code&gt; is evaluated.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 표현식 이 평가되고 패턴 &lt;code&gt;Pattern&lt;/code&gt; 이 결과와 순차적으로 일치합니다. 일치하고 가드 시퀀스 &lt;code&gt;GuardSeq&lt;/code&gt; 옵션 이 true이면 해당 &lt;code&gt;Body&lt;/code&gt; 이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb08adeb4f1b661f39b36975cfaf70cfc2a2ac3a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; is the list of all elements in &lt;code&gt;T&lt;/code&gt; that are less than &lt;code&gt;Pivot&lt;/code&gt;.</source>
          <target state="translated">표현 &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;Pivot&lt;/code&gt; 보다 작은 모든 요소의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="a1e90b9cd13dd08f75832cad1c6cf3f69ae835ff" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; is processed by the Erlang preprocessor and returns a list of the record field names. With the record definition &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt;, the expression &lt;code&gt;record_info(fields,foo)&lt;/code&gt; is expanded to the list &lt;code&gt;[x,y,z]&lt;/code&gt;. It is therefore possible for you to provide the attribute names or to use the &lt;code&gt;record_info/2&lt;/code&gt; notation.</source>
          <target state="translated">&lt;code&gt;record_info(fields, record_name)&lt;/code&gt; 표현식 은 Erlang 전처리 기에 의해 처리되며 레코드 필드 이름 목록을 리턴합니다. 레코드 정의 &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt; &lt;code&gt;record_info(fields,foo)&lt;/code&gt; 표현식 이 &lt;code&gt;[x,y,z]&lt;/code&gt; 목록으로 확장되었습니다 . 따라서 속성 이름을 제공하거나 &lt;code&gt;record_info/2&lt;/code&gt; 표기법 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46c25aa4f264a013c217a6e6c0cd1f11966c0297" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">확장 인코딩은 디스크 파일 (기능 &lt;code&gt;file:open/2&lt;/code&gt; ) 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a6444a6ceb013adde9ead96d92efa55f0f4c658" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 에 지정된대로 파일에서 테이블을로드하는 동안 더 강력한 검증을 허용하기 위해 파일 바닥 글에 작성된 확장 정보입니다 . 이 함수 는 파일 바닥 글의 값이 아니라 &lt;strong&gt;어떤&lt;/strong&gt; 정보가 &lt;strong&gt;있는지&lt;/strong&gt; 알려줍니다 . 값은 원자 &lt;code&gt;object_count&lt;/code&gt; 및 &lt;code&gt;md5sum&lt;/code&gt; 중 하나 이상을 포함하는 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="7699dc7022a8a1b6e975d2c9f7052dbc61739221" translate="yes" xml:space="preserve">
          <source>The extensible agent in this toolkit understands the SNMPv1, SNMPv2c and SNMPv3. Recall that SNMP consists of two separate parts, the MIB definition language (SMI), and the protocol. On the protocol level, the agent can be configured to speak v1, v2c, v3 or any combination of them at the same time, i.e. a v1 request gets an v1 reply, a v2c request gets a v2c reply, and a v3 request gets a v3 reply. On the MIB level, the MIB compiler can compile both SMIv1 and SMIv2 MIBs. Once compiled, any of the formats can be loaded into the agent, regardless of which protocol version the agent is configured to use. This means that the agent translates from v2 notifications to v1 traps, and vice versa. For example, v2 MIBs can be loaded into an agent that speaks v1 only. The procedures for the translation between the two protocols are described in RFC 1908 and RFC 2089.</source>
          <target state="translated">이 툴킷의 확장 가능 에이전트는 SNMPv1, SNMPv2c 및 SNMPv3을 이해합니다. SNMP는 MIB 정의 언어 (SMI)와 프로토콜의 두 부분으로 구성됩니다. 프로토콜 수준에서 에이전트는 v1, v2c, v3 또는 이들의 조합을 동시에 말하도록 구성 할 수 있습니다. 즉, v1 요청은 v1 응답을 받고 v2c 요청은 v2c 응답을 받고 v3 요청은 v3 답장. MIB 레벨에서 MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 컴파일 할 수 있습니다. 컴파일 된 후에는 에이전트가 사용하도록 구성된 프로토콜 버전에 관계없이 모든 형식을 에이전트에로드 할 수 있습니다. 이는 에이전트가 v2 알림에서 v1 트랩으로 또는 그 반대로 변환 함을 의미합니다. 예를 들어, v2 MIB는 v1 만 말하는 에이전트에로드 할 수 있습니다.두 프로토콜 간의 변환 절차는 RFC 1908 및 RFC 2089에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57de3f33cd01d18ece5f1f8bac4a92c384bb136f" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process than the Erlang runtime system. In some cases this is not acceptable. Consider, for example, drivers with very hard time requirements. It is therefore possible to write a program in C according to certain principles, and dynamically link it to the Erlang runtime system. This is called a &lt;strong&gt;linked-in driver&lt;/strong&gt;.</source>
          <target state="translated">외부 프로그램은 Erlang 런타임 시스템 이외의 다른 OS 프로세스에 있습니다. 어떤 경우에는 허용되지 않습니다. 예를 들어 매우 힘든 시간이 필요한 드라이버를 고려하십시오. 따라서 특정 원칙에 따라 C로 프로그램을 작성하고이를 Erlang 런타임 시스템에 동적으로 링크 할 수 있습니다. 이것을 &lt;strong&gt;링크드 드라이버&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="483a7ce8598855903aaac7d43e33a8b6a176d6b3" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process. By default, it reads from standard input (file descriptor 0) and writes to standard output (file descriptor 1). The external program is to terminate when the port is closed.</source>
          <target state="translated">외부 프로그램은 다른 OS 프로세스에 있습니다. 기본적으로 표준 입력 (파일 설명자 0)에서 읽고 표준 출력 (파일 설명자 1)에 씁니다. 외부 프로그램은 포트가 닫힐 때 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="222a1e19175406b6aa7a82dcd2394935006c713e" translate="yes" xml:space="preserve">
          <source>The external term format is mainly used in the distribution mechanism of Erlang.</source>
          <target state="translated">외부 용어 형식은 주로 Erlang의 배포 메커니즘에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="474968dd4f560dffd7389aa9ca6143617036ffea" translate="yes" xml:space="preserve">
          <source>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">(* PRUNE : NAME)이 이름을 기억한다는 사실은 이름을 검색 할 수 없으므로 Erlang 프로그래머에게는 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e08d6e43db0948fdcb04ad39ee35684175d7b088" translate="yes" xml:space="preserve">
          <source>The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">(* THEN : NAME)이 이름을 기억한다는 사실은 이름을 검색 할 수 없으므로 Erlang 프로그래머에게는 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a45ac2df0b9d463c5e0e5db641eebadc3836e7a0" translate="yes" xml:space="preserve">
          <source>The factor when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;).</source>
          <target state="translated">새 타이머 시간을 계산할 때의 요인 ( &lt;code&gt;wait_for&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b32182822028d3d94853cdaecf2932942b85c07" translate="yes" xml:space="preserve">
          <source>The fastest selective decode is when the decoded type is a primitive type and not so deep in the structure of the top type. &lt;code&gt;selected_decode_Window2&lt;/code&gt; decodes a high constructed value, which explains why this operation is relatively slow.</source>
          <target state="translated">가장 빠른 선택적 디코딩은 디코딩 된 유형이 기본 유형이고 최상위 유형의 구조에 그다지 깊지 않은 경우입니다. &lt;code&gt;selected_decode_Window2&lt;/code&gt; 는 높은 구성 값을 디코딩하여이 작업이 상대적으로 느린 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e539ae850e97a5a9057ff2bb6d6c8fcc08bab73d" translate="yes" xml:space="preserve">
          <source>The feature was added in Erlang 5.7.5/OTP R13B04.</source>
          <target state="translated">이 기능은 Erlang 5.7.5 / OTP R13B04에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7d9b7c2c0bd1f2fc3f2c7d85835796c435f8f44" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;ModData&lt;/code&gt; is a list. This list is the list returned from the last call to &lt;code&gt;do/1&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;data&lt;/code&gt; 에 &lt;code&gt;ModData&lt;/code&gt; 은 목록입니다. 이 목록은 &lt;code&gt;do/1&lt;/code&gt; 에 대한 마지막 호출에서 리턴 된 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6456be6965c0349e34f864167682f7b31ae172c8" translate="yes" xml:space="preserve">
          <source>The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the &lt;strong&gt;same&lt;/strong&gt; call to &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt;. For example, using &lt;code&gt;T&lt;/code&gt; above:</source>
          <target state="translated">필드 너비는 최대 줄 길이를 지정합니다. 기본값은 80입니다. 정밀도는 항의 초기 들여 쓰기를 지정합니다. &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt; 호출 &lt;strong&gt;과 동일한&lt;/strong&gt; 호출 로이 행에 인쇄 된 문자 수를 기본값으로합니다 . 예를 들어, 위의 &lt;code&gt;T&lt;/code&gt; 를 사용 하면 :</target>
        </trans-unit>
        <trans-unit id="45f234045151c357743a7016e59e80ebbcce1cad" translate="yes" xml:space="preserve">
          <source>The fields can be in any order, not necessarily the same order as in the record definition, and fields can be omitted. Omitted fields get their respective default value instead.</source>
          <target state="translated">필드는 레코드 정의에서와 반드시 같은 순서 일 필요는 없으며 임의의 순서 일 수 있으며 필드는 생략 할 수 있습니다. 생략 된 필드는 대신 각각의 기본값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="08c771e3c02df1bde386f66f03b2e079f068c16e" translate="yes" xml:space="preserve">
          <source>The fields in the structure are as follows:</source>
          <target state="translated">구조의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4eaa6a16da05e6ff18f84c1ebcd0b7aefc5111a7" translate="yes" xml:space="preserve">
          <source>The fields of record &lt;code&gt;mod&lt;/code&gt; have the following meaning:</source>
          <target state="translated">레코드 &lt;code&gt;mod&lt;/code&gt; 의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9f5d2712650575f495813aa5945d3da6ac26a56" translate="yes" xml:space="preserve">
          <source>The fields referred to in the pattern can be given in any order.</source>
          <target state="translated">패턴에서 참조되는 필드는 임의의 순서로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08db3122b6c1da4a657ae8cba808796dd5cb6b86" translate="yes" xml:space="preserve">
          <source>The fifth argument is the magic cookie.</source>
          <target state="translated">다섯 번째 주장은 마술 쿠키입니다.</target>
        </trans-unit>
        <trans-unit id="9f962ab964ce6cd051f2dbc6e617195062eacc4f" translate="yes" xml:space="preserve">
          <source>The figures in this section illustrate the steps involved in the development of an SNMP agent.</source>
          <target state="translated">이 섹션의 그림은 SNMP 에이전트 개발과 관련된 단계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4cbdd4fa4fa7eb06d2c2cd3f4fc02cfd3c4c58d8" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;FileName&lt;/code&gt; is to be a plain text file and can contain comments and command-line arguments. A comment begins with a &lt;code&gt;#&lt;/code&gt; character and continues until the next end of line character. Backslash (\\) is used as quoting character. All command-line arguments accepted by &lt;code&gt;erl&lt;/code&gt; are allowed, also flag &lt;code&gt;-args_file FileName&lt;/code&gt;. Be careful not to cause circular dependencies between files containing flag &lt;code&gt;-args_file&lt;/code&gt;, though.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 파일 은 일반 텍스트 파일이어야하며 주석과 명령 줄 인수를 포함 할 수 있습니다. 주석은 &lt;code&gt;#&lt;/code&gt; 문자로 시작 하고 다음 행 문자 끝까지 계속됩니다. 백 슬래시 (\\)는 인용 문자로 사용됩니다. 수락 모든 명령 줄 인수 &lt;code&gt;erl&lt;/code&gt; 플래그 또한, 허용되는 &lt;code&gt;-args_file FileName&lt;/code&gt; . 플래그 &lt;code&gt;-args_file&lt;/code&gt; 을 포함하는 파일간에 순환 종속성이 발생하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef2a4ab9b2cbfd5981924e055242be9d6523c2f1" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;appl.erl&lt;/code&gt; is transferred from the remote to the local host. When the session is opened, the current directory at the remote host is &lt;code&gt;/home/guest&lt;/code&gt;, and &lt;code&gt;/home/fred&lt;/code&gt; at the local host. Before transferring the file, the current local directory is changed to &lt;code&gt;/home/eproj/examples&lt;/code&gt;, and the remote directory is set to &lt;code&gt;/home/guest/appl/examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;appl.erl&lt;/code&gt; 파일 이 원격에서 로컬 호스트로 전송됩니다. 세션이 열리면 원격 호스트의 현재 디렉토리는 &lt;code&gt;/home/guest&lt;/code&gt; 이고 &lt;code&gt;/home/fred&lt;/code&gt; 는 로컬 호스트입니다. 파일을 전송하기 전에 현재 로컬 디렉토리가 &lt;code&gt;/home/eproj/examples&lt;/code&gt; 로 변경되고 원격 디렉토리가 &lt;code&gt;/home/guest/appl/examples&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="5712e30f3c91d1fa3a6c8c851828ea49909dab0b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;ch_app.appup&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ch_app.appup&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="ed1f252a17bd502cae6f65b494d7abad29887093" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;foo.DCD&lt;/code&gt; has been created. This file will eventually store all data that is written into the &lt;code&gt;foo&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;foo.DCD&lt;/code&gt; 파일 이 생성되었습니다. 이 파일은 결국 &lt;code&gt;foo&lt;/code&gt; 테이블에 기록 된 모든 데이터를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="cef24f2335b5ba7f0dd2cc5fad1d52fb9d3d09b4" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; is a copy of our &lt;code&gt;mysystem.boot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; 파일 은 &lt;code&gt;mysystem.boot&lt;/code&gt; 의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="2b8b8152527aa20a7d4a0566192d86d3094913d9" translate="yes" xml:space="preserve">
          <source>The file cannot be found in any of the directories in &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 의 디렉토리에서 파일을 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fc7fabdf332059e44e2eb17eeef692885d373bdb" translate="yes" xml:space="preserve">
          <source>The file cannot be opened.</source>
          <target state="translated">파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9a0257416ae53879f4ba75c38e4782504676962" translate="yes" xml:space="preserve">
          <source>The file descriptor of the socket associated with the port.</source>
          <target state="translated">포트와 연관된 소켓의 파일 디스크립터.</target>
        </trans-unit>
        <trans-unit id="8273bc28b08e309fc9dd43621c30c7519263c61b" translate="yes" xml:space="preserve">
          <source>The file does not exist.</source>
          <target state="translated">파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56db91f9bccb5529a0d13172d3cd82f3fa8e8d12" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the local host.</source>
          <target state="translated">파일은 로컬 호스트에서 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="116b44d8dffe981177c481cc8f3dc87f0f7f4c3e" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the remote host.</source>
          <target state="translated">파일은 원격 호스트에서 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="51b34af4a175f2b4aa90381774d3f18723da3b3d" translate="yes" xml:space="preserve">
          <source>The file includes both version 1, 2 and version 3 messages.</source>
          <target state="translated">파일에는 버전 1, 2 및 버전 3 메시지가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9625a98d2c47b406a8f7769a6753258132546c" translate="yes" xml:space="preserve">
          <source>The file is a directory and the user is not superuser.</source>
          <target state="translated">파일이 디렉토리이고 사용자가 수퍼 유저가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b21cd2436d24bafe2e40702865abc3fbecc09148" translate="yes" xml:space="preserve">
          <source>The file is in both these cases then best processed using the &lt;code&gt;io&lt;/code&gt; module, as the functions in that module can handle code points beyond the ISO Latin-1 range.</source>
          <target state="translated">이 두 가지 경우 모두 파일은 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 가장 잘 처리 됩니다. 해당 모듈의 함수는 ISO Latin-1 범위를 벗어난 코드 포인트를 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b2eb2fd7e69007e3b27fc3504af5f6bbd478142a" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;LocalFile&lt;/code&gt; on the local host.</source>
          <target state="translated">파일의 이름 은 로컬 호스트에서 &lt;code&gt;LocalFile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1df462cd01acebe1ec004334e0f1a8efe5b7e5b1" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;RemoteFile&lt;/code&gt; on the remote host.</source>
          <target state="translated">파일 이름 은 원격 호스트에서 &lt;code&gt;RemoteFile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03b686e18d29e8b42dc1dbee506d16c2eb2c5609" translate="yes" xml:space="preserve">
          <source>The file is not opened for reading.</source>
          <target state="translated">읽을 파일이 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0285680290f8aeb50ca6b7cbc6c042e3ad3dd657" translate="yes" xml:space="preserve">
          <source>The file is not opened for writing.</source>
          <target state="translated">파일이 쓰기 위해 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4982f438e094effbe19f49bddea5cc4009fdfdb" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. Every write operation to a file opened with &lt;code&gt;append&lt;/code&gt; takes place at the end of the file.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. &lt;code&gt;append&lt;/code&gt; 열린 파일에 대한 모든 쓰기 작업은 파일 끝에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d726a268237e91f14236fd6ff2803260e2e1532" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists and &lt;code&gt;write&lt;/code&gt; is not combined with &lt;code&gt;read&lt;/code&gt;, the file is truncated.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. 파일이 존재하고 &lt;code&gt;write&lt;/code&gt; 가 &lt;code&gt;read&lt;/code&gt; 와 결합되지 않으면 파일이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="a197a2f03b6e053838765608c827205470531e6d" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists, &lt;code&gt;{error, eexist}&lt;/code&gt; is returned.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. 파일이 존재하면 &lt;code&gt;{error, eexist}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1abdf85470ebe2b741440d62063d01b5682aba19" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file and &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">요청 된 모드에서 파일이 열립니다. &lt;code&gt;IoDevice&lt;/code&gt; 는 파일에 대한 참조이며 &lt;code&gt;FullName&lt;/code&gt; 은 파일 의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7acf8ec21fa42c861a4f88f31a1e3b43a849b057" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file.</source>
          <target state="translated">요청 된 모드에서 파일이 열립니다. &lt;code&gt;IoDevice&lt;/code&gt; 는 파일에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="916ee7c748bb5e7a2bf22555efc9c7ba3e8e1d3f" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data in the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 파일이 열리고 파일의 데이터를이 함수가 반환하는 바이트 지향 데이터로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af4cd6106424f7957ea5b09a69738ba162a42d0a" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data on the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 파일이 열리고 파일의 데이터를이 함수가 반환하는 바이트 지향 데이터로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1447089fad09b9920a3125bbbcb71e40fcf03b8" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file and &lt;code&gt;Value&lt;/code&gt; the value of the last expression.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름이며 마지막 식의 값은 &lt;code&gt;Value&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab1ff8d4200f6f26fb7134240fe2228fd2ecd31d" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2975a465dfe23956015ba6c274ed78e16024bfa9" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;Value&lt;/code&gt; is the value of the last expression.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;Value&lt;/code&gt; 은 마지막 표현식의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e333fb72ddfdad9f98da967fd861cc9cecde73c6" translate="yes" xml:space="preserve">
          <source>The file is read by the application controller when an application is loaded/started. It is also used by the functions in &lt;code&gt;systools&lt;/code&gt;, for example when generating start scripts.</source>
          <target state="translated">응용 프로그램이로드 / 시작될 때 응용 프로그램 제어기가 파일을 읽습니다. 또한 시작 스크립트를 생성 할 때 와 같이 &lt;code&gt;systools&lt;/code&gt; 의 함수에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d522dbd681f4cd878e0a0aeb3cbd943d113a8c38" translate="yes" xml:space="preserve">
          <source>The file is successfully read. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">파일을 읽습니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e117edda70b67ee50f9d2f7fce2e7996b73bd637" translate="yes" xml:space="preserve">
          <source>The file must be in &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt;. The file is read when the daemon starts.</source>
          <target state="translated">파일은 &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt; 이어야 합니다 . 데몬이 시작될 때 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="80ee3eac8f806ec9cde470e2d7d3f7c22d220194" translate="yes" xml:space="preserve">
          <source>The file must be named &lt;code&gt;Rel.rel&lt;/code&gt;, where &lt;code&gt;Rel&lt;/code&gt; is a unique name.</source>
          <target state="translated">파일 이름은 &lt;code&gt;Rel.rel&lt;/code&gt; 이어야합니다 . 여기서 &lt;code&gt;Rel&lt;/code&gt; 은 고유 한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7582f5f80d20de2502ad5d3c778be456df031796" translate="yes" xml:space="preserve">
          <source>The file must contain a single Erlang term, which is called an &lt;strong&gt;application specification&lt;/strong&gt;:</source>
          <target state="translated">파일에는 단일 Erlang 용어가 포함되어야하며이를 &lt;strong&gt;애플리케이션 사양&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="d15a1263b243302ad1b99430abd18bc925e32e3e" translate="yes" xml:space="preserve">
          <source>The file must have one or more three-tuples &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; terminated by a dot. The file is read when the daemon starts.</source>
          <target state="translated">파일 에는 점으로 끝나는 하나 이상의 3 개 튜플 &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; 가 있어야합니다 . 데몬이 시작될 때 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="56458bdbcf5690ec8658261e5325164ce2a2a111" translate="yes" xml:space="preserve">
          <source>The file name of the current module.</source>
          <target state="translated">현재 모듈의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a5d1d6d598f59230fdf0a71188330092a7de64cf" translate="yes" xml:space="preserve">
          <source>The file name requirement on the engine dynamic library can differ between SSL versions.</source>
          <target state="translated">엔진 동적 라이브러리의 파일 이름 요구 사항은 SSL 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf117b829fc2877fe7b8ccf793bd866ee82bf7d" translate="yes" xml:space="preserve">
          <source>The file names consist of eight hexadecimal digits followed by &lt;code&gt;.rN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer, e.g. &lt;code&gt;1a2b3c4d.r0&lt;/code&gt;. For the first version of the CRL, &lt;code&gt;N&lt;/code&gt; starts at zero, and for each new version, &lt;code&gt;N&lt;/code&gt; is incremented by one. The OpenSSL utility &lt;code&gt;c_rehash&lt;/code&gt; creates symlinks according to this pattern.</source>
          <target state="translated">파일 이름은 8 개의 16 진 숫자와 &lt;code&gt;.rN&lt;/code&gt; 으로 구성되며 &lt;code&gt;N&lt;/code&gt; 은 정수입니다 (예 : &lt;code&gt;1a2b3c4d.r0&lt;/code&gt; ) . CRL의 첫 번째 버전에서 &lt;code&gt;N&lt;/code&gt; 은 0에서 시작하고 새 버전마다 &lt;code&gt;N&lt;/code&gt; 씩 1 씩 증가합니다. OpenSSL 유틸리티 &lt;code&gt;c_rehash&lt;/code&gt; 는이 패턴에 따라 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d7d30bf4111cf6d645a316a6236bd904ed813968" translate="yes" xml:space="preserve">
          <source>The file offset in the zip archive (used internally)</source>
          <target state="translated">zip 아카이브의 파일 오프셋 (내부적으로 사용)</target>
        </trans-unit>
        <trans-unit id="98c7f36c4669e374fe284c2ff98a9ddaef5cf51f" translate="yes" xml:space="preserve">
          <source>The file permissions as the sum of the following bit values:</source>
          <target state="translated">파일은 다음 비트 값의 합으로 사용 권한입니다.</target>
        </trans-unit>
        <trans-unit id="9515e875a26b329b033fd7640f399fd9edd7196e" translate="yes" xml:space="preserve">
          <source>The file privileges and ownership of the &lt;code&gt;mod_syslog&lt;/code&gt; utility must be modified.</source>
          <target state="translated">&lt;code&gt;mod_syslog&lt;/code&gt; 유틸리티 의 파일 권한 및 소유권을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4f22a3c177173ba882d73ea3867a6b6cb6d9dc7" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;</source>
          <target state="translated">들어오는 URL의 파일 접미사가 &lt;code&gt;MimeType&lt;/code&gt; 에 매핑되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4eba4c3a153db010c6d9b7a15465b2d5b3ce266" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;.</source>
          <target state="translated">들어오는 URL의 파일 접미사가 &lt;code&gt;MimeType&lt;/code&gt; 에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="f294360a334b35b807188de18da95f7579b0fb4d" translate="yes" xml:space="preserve">
          <source>The file system on the other host has a different structure to the the master.</source>
          <target state="translated">다른 호스트의 파일 시스템은 마스터와 다른 구조를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c75ca2cbc895f2093ee4a98814185b1afc3a8e1a" translate="yes" xml:space="preserve">
          <source>The file system path to the directory where the driver object file is located. The filename of the object file (minus extension) must correspond to the driver name (used in parameter &lt;code&gt;Name&lt;/code&gt;) and the driver must identify itself with the same name. &lt;code&gt;Path&lt;/code&gt; can be provided as an &lt;strong&gt;iolist()&lt;/strong&gt;, meaning it can be a list of other &lt;code&gt;iolist()&lt;/code&gt;s, characters (8-bit integers), or binaries, all to be flattened into a sequence of characters.</source>
          <target state="translated">드라이버 오브젝트 파일이있는 디렉토리의 파일 시스템 경로입니다. 오브젝트 파일의 파일 이름 (확장자 빼기)은 드라이버 이름 (매개 변수 &lt;code&gt;Name&lt;/code&gt; 에서 사용 )과 일치해야하며 드라이버 는 동일한 이름으로 자신을 식별해야합니다. &lt;code&gt;Path&lt;/code&gt; 는 &lt;strong&gt;iolist ()&lt;/strong&gt; 로 제공 될 수 있습니다 . 즉, 다른 &lt;code&gt;iolist()&lt;/code&gt; , 문자 (8 비트 정수) 또는 이진의 목록 일 수 있으며 모두 일련의 문자로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="bf2eb9cc34b90180610fbc75837cbfad30b948cc" translate="yes" xml:space="preserve">
          <source>The file trace driver expects a filename or a wrap files specification as parameter. A file is written with a high degree of buffering, why all trace messages are &lt;strong&gt;not&lt;/strong&gt; guaranteed to be saved in the file in case of a system crash. That is the price to pay for low tracing overhead.</source>
          <target state="translated">파일 추적 드라이버는 파일 이름 또는 랩 파일 스펙을 매개 변수로 예상합니다. 파일은 높은 수준의 버퍼링으로 작성 되므로 시스템 충돌시 모든 추적 메시지가 파일에 저장 &lt;strong&gt;되지 않을&lt;/strong&gt; 수 있습니다. 이것이 낮은 추적 오버 헤드에 대한 대가입니다.</target>
        </trans-unit>
        <trans-unit id="083d3049caca9cb4909e07d982cf1c0a253eda8d" translate="yes" xml:space="preserve">
          <source>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCCI mode.</source>
          <target state="translated">파일 전송 유형은 세션이 열릴 때 FTP 서버의 기본값으로 설정됩니다. 일반적으로 ASCCI 모드입니다.</target>
        </trans-unit>
        <trans-unit id="d7d87c17221873fd0d28c7a0cf27f97994b73b47" translate="yes" xml:space="preserve">
          <source>The file used must be opened using the &lt;code&gt;raw&lt;/code&gt; flag, and the process calling &lt;code&gt;sendfile&lt;/code&gt; must be the controlling process of the socket. See &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 된 파일은 &lt;code&gt;raw&lt;/code&gt; 플래그를 사용하여 열어야하며 &lt;code&gt;sendfile&lt;/code&gt; 을 호출하는 프로세스 는 소켓의 제어 프로세스 여야합니다. &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0739dac79b5f4f1aa7ca70031ae5a16c934c399" translate="yes" xml:space="preserve">
          <source>The file was read and evaluated.</source>
          <target state="translated">파일을 읽고 평가했습니다.</target>
        </trans-unit>
        <trans-unit id="4e58a2f1e91ddce67de54ef340e3da2cb9cb63a1" translate="yes" xml:space="preserve">
          <source>The file was successfully read.</source>
          <target state="translated">파일을 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="c72d65e1c03281b49322438db24cb3e3334edd0b" translate="yes" xml:space="preserve">
          <source>The file, which must exist, is opened for reading.</source>
          <target state="translated">존재해야하는 파일을 읽기 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="552bd26b6c475a1374de92e4954676c79da00420" translate="yes" xml:space="preserve">
          <source>The filename</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="26016e882c6ac80280490e30771a8dba2723ae37" translate="yes" xml:space="preserve">
          <source>The filename must be &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The path must be the same as the backup copy.</source>
          <target state="translated">파일 이름은 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 이어야합니다 . 경로는 백업 사본과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="29478f77cee4c57798b46ebd0b4dff9c27a01cc8" translate="yes" xml:space="preserve">
          <source>The filename of the copy must be &lt;code&gt;syslog.conf.ORIG&lt;/code&gt;. The directory location is optional; usually it is &lt;code&gt;/etc&lt;/code&gt;. A simple way to do this is to issue the following command:</source>
          <target state="translated">복사본의 파일 이름은 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 이어야합니다 . 디렉토리 위치는 선택 사항입니다. 일반적으로 &lt;code&gt;/etc&lt;/code&gt; 입니다. 이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5af1d694b8b3cdebbfc3c0f00daedcbcdd080514" translate="yes" xml:space="preserve">
          <source>The filename of the crashdump.</source>
          <target state="translated">크래시 덤프의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f51e4a22a3fd6a63b9b7c7d8ef4afc50be94d9de" translate="yes" xml:space="preserve">
          <source>The filename translation mode can be read with function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, which returns &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) or &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">파일 이름 변환 모드는 함수 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 으로 읽을 수 있으며 &lt;code&gt;latin1&lt;/code&gt; (바이트 별 인코딩) 또는 &lt;code&gt;utf8&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0bbf7541fe0325c793eec29d4cd8ad35ed00aa5e" translate="yes" xml:space="preserve">
          <source>The files are unzipped to memory or to file, depending on the options specified to function &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; when opening the archive.</source>
          <target state="translated">아카이브를 열 때 &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; 기능으로 지정된 옵션에 따라 파일이 메모리 또는 파일로 압축 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8c783c92fcd9bf942dd424f42fc61d302ddafc6" translate="yes" xml:space="preserve">
          <source>The files are:</source>
          <target state="translated">파일은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="c0b32d670fd0928ee57d4da38842a479ce59c02a" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;did not pass&lt;/strong&gt;, and the log event is immediately discarded.</source>
          <target state="translated">필터 &lt;strong&gt;가 전달되지 않아&lt;/strong&gt; 로그 이벤트가 즉시 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2fec5992ce5b4648b9da53b9fca03126f14195c8" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next handler filter, if any, is applied. If no more filters exist for this handler, the log event is forwarded to the handler callback.</source>
          <target state="translated">필터가 &lt;strong&gt;통과했습니다&lt;/strong&gt; . 다음 핸들러 필터 (있는 경우)가 적용됩니다. 이 핸들러에 대한 필터가 더 이상 없으면 로그 이벤트가 핸들러 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c64e728f01227118a6f0a504e74466c80ec0c979" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next primary filter, if any, is applied. If no more primary filters exist, the log event is forwarded to the handler part of Logger, where handler filters are applied.</source>
          <target state="translated">필터가 &lt;strong&gt;통과했습니다&lt;/strong&gt; . 다음 기본 필터 (있는 경우)가 적용됩니다. 기본 필터가 더 이상 없으면 로그 이벤트는 Logger의 핸들러 부분으로 전달되며 여기서 핸들러 필터가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4778fe9a2d1bb2efd40561548fc65defaa0949" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the &lt;code&gt;domain&lt;/code&gt; field in the log event's metadata (&lt;code&gt;Domain&lt;/code&gt;) against &lt;code&gt;MatchDomain&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Compare&lt;/code&gt; is:</source>
          <target state="translated">이 필터는 로그 이벤트 메타 데이터 ( &lt;code&gt;Domain&lt;/code&gt; ) 의 &lt;code&gt;domain&lt;/code&gt; 필드 값을 &lt;code&gt;MatchDomain&lt;/code&gt; 과 비교 합니다. &lt;code&gt;Compare&lt;/code&gt; 값 이 다음 과 같은 경우 필터가 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="fb57b499845a0930b0e37c62f80d02bcd2cb10f3" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the event's log level (&lt;code&gt;Level&lt;/code&gt;) to &lt;code&gt;MatchLevel&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Operator&lt;/code&gt; is:</source>
          <target state="translated">필터는 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt; 을 호출 하여 이벤트 로그 레벨 ( &lt;code&gt;Level&lt;/code&gt; ) 의 값 을 &lt;code&gt;MatchLevel&lt;/code&gt; 과 비교합니다 . &lt;code&gt;Operator&lt;/code&gt; 값 이 다음 과 같은 경우 필터가 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="beafc4357de407d81ed4a70bb524b690f9b684ec" translate="yes" xml:space="preserve">
          <source>The filter fun is called with the log event as the first parameter, and the specified &lt;code&gt;filter_args()&lt;/code&gt; as the second parameter.</source>
          <target state="translated">필터 이벤트는 로그 이벤트를 첫 번째 매개 변수로 지정하고 지정된 &lt;code&gt;filter_args()&lt;/code&gt; 를 두 번째 매개 변수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="109bfa797ec0aa4b76af245de1501f0741f1a95b" translate="yes" xml:space="preserve">
          <source>The filter function can return &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;ignore&lt;/code&gt; or the (possibly modified) log event.</source>
          <target state="translated">필터 함수는 &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;ignore&lt;/code&gt; 또는 (수정 가능) 로그 이벤트를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd11c27d7fbe5210f24b8d1e40d0d071f2e3ec4c" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next handler filter, if any, is applied. If no more filters exist for this handler, the value of the &lt;code&gt;filter_default&lt;/code&gt; configuration parameter for the handler specifies if the log event shall be discarded or forwarded to the handler callback.</source>
          <target state="translated">필터는 로그 이벤트를 알지 못합니다. 다음 핸들러 필터 (있는 경우)가 적용됩니다. 이 핸들러에 더 이상 필터가 없으면 핸들러에 대한 &lt;code&gt;filter_default&lt;/code&gt; 구성 매개 변수 의 값은 로그 이벤트를 버릴 것인지 핸들러 콜백으로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ddc0b8589e411612b38fdd950c86be1e96f3d934" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next primary filter, if any, is applied. If no more primary filters exist, the value of the primary &lt;code&gt;filter_default&lt;/code&gt; configuration parameter specifies if the log event shall be discarded or forwarded to the handler part.</source>
          <target state="translated">필터는 로그 이벤트를 알지 못합니다. 다음 기본 필터 (있는 경우)가 적용됩니다. 기본 필터가 더 이상 없으면 기본 &lt;code&gt;filter_default&lt;/code&gt; 구성 매개 변수 의 값은 로그 이벤트를 버릴 것인지 처리기 파트로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="41d4a36552fad1262f02d4b7fdc2ca2fb3a329a9" translate="yes" xml:space="preserve">
          <source>The filter returns &lt;code&gt;ignore&lt;/code&gt; for all other log events.</source>
          <target state="translated">필터는 다른 모든 로그 이벤트에 대해 &lt;code&gt;ignore&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dfb975166536b9370277fc5b05c55860c6bb1974" translate="yes" xml:space="preserve">
          <source>The final result is automatically compacted (compare &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">최종 결과는 자동으로 압축됩니다 ( &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt; 비교 ).</target>
        </trans-unit>
        <trans-unit id="1526dc18038f8fccad4ff828c37ad6dc7b944d4a" translate="yes" xml:space="preserve">
          <source>The final use of backslash is for certain simple assertions. An assertion specifies a condition that must be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The following are the backslashed assertions:</source>
          <target state="translated">백 슬래시의 최종 사용은 특정 간단한 어설 션입니다. 어설 션은 제목 문자열에서 문자를 소비하지 않고 일치하는 특정 지점에서 충족해야하는 조건을 지정합니다. 보다 복잡한 어설 션에 하위 패턴을 사용하는 방법은 다음과 같습니다. 다음은 백 슬래시 된 어설 션입니다.</target>
        </trans-unit>
        <trans-unit id="e6d536c130f15c0094632e977773d39a9eb1e1bc" translate="yes" xml:space="preserve">
          <source>The finish time can be specified as &lt;code&gt;HHMMSS&lt;/code&gt; and is then interpreted as a time today (or possibly tomorrow), but can also be specified as &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt;, for example, &lt;code&gt;-until 071001120000&lt;/code&gt; or &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt;. This means that the tests are executed and (if time allows) repeated, until 12 o'clock on the 1st of October 2007.</source>
          <target state="translated">완료 시간은 &lt;code&gt;HHMMSS&lt;/code&gt; 로 지정 될 수 있으며 오늘 (또는 내일) 시간으로 해석 될 수 있지만 &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt; 로 지정 될 수도 있습니다 ( 예 : &lt;code&gt;-until 071001120000&lt;/code&gt; 또는 &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt; ) . 이는 2007 년 10 월 1 일 12 시까 지 테스트가 실행되고 (시간이 허용되는 경우) 반복됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6e0ddb058b574885245c8e1eb45a6f332a495743" translate="yes" xml:space="preserve">
          <source>The first 4-bits segment of &lt;code&gt;Dgram&lt;/code&gt; is not equal to 4.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 의 첫 4 비트 세그먼트는 4가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8565b4f54aaccfcff566979872a65ab909534a87" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;[&lt;/code&gt; bracket is read as &quot;build the list&quot;.</source>
          <target state="translated">첫 번째 &lt;code&gt;[&lt;/code&gt; 대괄호는 &quot;목록 작성&quot;으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="97b9da02f0f552217d5f6a05e46d62406ee40ed2" translate="yes" xml:space="preserve">
          <source>The first and longest match is preferred to a shorter, which is illustrated by the following example:</source>
          <target state="translated">첫 번째 및 가장 긴 일치 항목이 짧을수록 선호되며 다음 예에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6694406df610cd0f2b38fa2673a9cd35f9806c5a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;code&gt;{down,Vsn}&lt;/code&gt; if there is a downgrade, or &lt;code&gt;Vsn&lt;/code&gt; if there is a upgrade. The term &lt;code&gt;Vsn&lt;/code&gt; is fetched from the 'original' version of the module, that is, the version you are upgrading from, or downgrading to.</source>
          <target state="translated">다운 그레이드가있는 경우 첫 번째 인수는 &lt;code&gt;{down,Vsn}&lt;/code&gt; 이고, 업그레이드가있는 경우 &lt;code&gt;Vsn&lt;/code&gt; 입니다. &lt;code&gt;Vsn&lt;/code&gt; 이라는 용어 는 모듈의 '원본'버전, 즉 업그레이드하거나 다운 그레이드하는 버전에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ce41fd29eb3e83bdeb71be9c3fb406a35efdd54a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;strong&gt;not&lt;/strong&gt; a problem. It is variable, but it is a variable in all clauses. The problem is the variable in the second argument, &lt;code&gt;Xs&lt;/code&gt;, in the middle clause. Because the variable can match anything, the compiler is not allowed to rearrange the clauses, but must generate code that matches them in the order written.</source>
          <target state="translated">첫 번째 주장은 문제 가 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 변수이지만 모든 절의 변수입니다. 문제는 중간 절에서 두 번째 인수 인 &lt;code&gt;Xs&lt;/code&gt; 의 변수입니다 . 변수는 무엇이든 일치 할 수 있으므로 컴파일러는 절을 재 배열 할 수 없지만 작성된 순서대로 해당 절과 일치하는 코드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="32cd604e114cd5b8cc3d471ee8e9bda4b1cee80b" translate="yes" xml:space="preserve">
          <source>The first argument is the host name.</source>
          <target state="translated">첫 번째 인수는 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d1c68fc721622601f7d260f14b31c96cc4eaab50" translate="yes" xml:space="preserve">
          <source>The first argument is the integer used to construct the node name.</source>
          <target state="translated">첫 번째 인수는 노드 이름을 구성하는 데 사용되는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f32a2498eb521e7ca9e58ea1c17356aedb30f6e1" translate="yes" xml:space="preserve">
          <source>The first argument is the internal state &lt;code&gt;State&lt;/code&gt;, passed from function &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt;, and called by the special process when a system message is received. In &lt;code&gt;ch4&lt;/code&gt;, the internal state is the set of available channels &lt;code&gt;Chs&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수는 내부 상태 &lt;code&gt;State&lt;/code&gt; 이며, 함수 &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt; 에서 전달되고 시스템 메시지가 수신 될 때 특수 프로세스에 의해 호출됩니다. 에서는 &lt;code&gt;ch4&lt;/code&gt; , 내부 상태는 이용 가능한 채널들의 세트이다 &lt;code&gt;Chs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c12ca04f8508bcca65e776d0a609f335e9ddf7b5" translate="yes" xml:space="preserve">
          <source>The first argument is the name of the &lt;code&gt;gen_statem&lt;/code&gt; and must agree with the name used to start it. So, we use the same macro &lt;code&gt;?NAME&lt;/code&gt; as when starting. &lt;code&gt;{button,Digit}&lt;/code&gt; is the event content.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;gen_statem&lt;/code&gt; 의 이름이며 이를 시작하는 데 사용 된 이름과 일치해야합니다. 따라서 시작할 때 와 같은 매크로 &lt;code&gt;?NAME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;{button,Digit}&lt;/code&gt; 는 이벤트 내용입니다.</target>
        </trans-unit>
        <trans-unit id="aefd6aec912ef4431dbd33b887c26f8e830aec81" translate="yes" xml:space="preserve">
          <source>The first argument must be the name of the Erlang module as a C-identifier. It will be stringified by the macro.</source>
          <target state="translated">첫 번째 인수는 C 식별자 인 Erlang 모듈의 이름이어야합니다. 매크로로 문자열 화됩니다.</target>
        </trans-unit>
        <trans-unit id="6d796fe4c495cce6f5931a9ed26cf94f76f97e87" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;ttb:format/1,2&lt;/code&gt; specifies which binary log(s) to format. This is usually the name of a directory that &lt;code&gt;ttb&lt;/code&gt; created during log fetch. Unless option &lt;code&gt;disable_sort&lt;/code&gt; is provided, the logs from different files are always sorted according to time-stamp in traces.</source>
          <target state="translated">&lt;code&gt;ttb:format/1,2&lt;/code&gt; 의 첫 번째 인수는 포맷 할 바이너리 로그를 지정합니다. 이것은 일반적으로 &lt;code&gt;ttb&lt;/code&gt; 가 로그 페치 중에 작성한 디렉토리의 이름입니다 . &lt;code&gt;disable_sort&lt;/code&gt; 옵션을 제공 하지 않으면 다른 파일의 로그는 항상 타임 스탬프에 따라 추적으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="f1fc18bc1a4475d49a5401a7876f067a569b9a43" translate="yes" xml:space="preserve">
          <source>The first argument to these functions is the name of the test case. This value can be used with pattern matching in function clauses or conditional expressions to choose different initialization and cleanup routines for different test cases, or perform the same routine for many, or all, test cases.</source>
          <target state="translated">이 함수들에 대한 첫 번째 주장은 테스트 케이스의 이름입니다. 이 값은 함수 절 또는 조건식의 패턴 일치와 함께 사용하여 다른 테스트 케이스에 대해 다른 초기화 및 정리 루틴을 선택하거나 많은 또는 모든 테스트 케이스에 대해 동일한 루틴을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdfdb297a347255c9331f18e2ac5e6afd881831" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;ch_sup&lt;/code&gt;, is the name of the callback module, that is, the module where the &lt;code&gt;init&lt;/code&gt; callback function is located.</source>
          <target state="translated">첫 번째 인수 인 &lt;code&gt;ch_sup&lt;/code&gt; 은 콜백 모듈의 이름, 즉 &lt;code&gt;init&lt;/code&gt; 콜백 함수가 있는 모듈 입니다.</target>
        </trans-unit>
        <trans-unit id="283cb26772a001cdc7fe1371d58b95c0c89083e7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local, ch3}&lt;/code&gt;, specifies the name. The gen_server is then locally registered as &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;{local, ch3}&lt;/code&gt; 은 이름을 지정합니다. gen_server는 &lt;code&gt;ch3&lt;/code&gt; 으로 로컬에 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9747ca5abb30d92b09649a3fe92d54bbd6136b7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local,?NAME}&lt;/code&gt;, specifies the name. In this case, the &lt;code&gt;gen_statem&lt;/code&gt; is locally registered as &lt;code&gt;code_lock&lt;/code&gt; through the macro &lt;code&gt;?NAME&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;{local,?NAME}&lt;/code&gt; 은 이름을 지정합니다. 이 경우, &lt;code&gt;gen_statem&lt;/code&gt; 는 로컬로 등록 &lt;code&gt;code_lock&lt;/code&gt; 매크로 통해 &lt;code&gt;?NAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81bf6f9dd47061daa5ebed0dbe0e76693e63afed" translate="yes" xml:space="preserve">
          <source>The first call to &lt;code&gt;enif_select&lt;/code&gt; for a specific OS &lt;code&gt;event&lt;/code&gt; will establish a relation between the event object and the containing resource. All subsequent calls for an &lt;code&gt;event&lt;/code&gt; must pass its containing resource as argument &lt;code&gt;obj&lt;/code&gt;. The relation is dissolved when &lt;code&gt;enif_select&lt;/code&gt; has been called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and the corresponding &lt;code&gt;stop&lt;/code&gt; callback has returned. A resource can contain several event objects but one event object can only be contained within one resource. A resource will not be destructed until all its contained relations have been dissolved.</source>
          <target state="translated">특정 OS &lt;code&gt;event&lt;/code&gt; 대한 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 첫 번째 호출 은 이벤트 오브젝트와 포함 자원 사이의 관계를 설정합니다. &lt;code&gt;event&lt;/code&gt; 대한 모든 후속 호출 은 포함하는 자원을 인수 &lt;code&gt;obj&lt;/code&gt; 로 전달해야합니다 . &lt;code&gt;enif_select&lt;/code&gt; 가 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 과 같은 &lt;code&gt;mode&lt;/code&gt; 로 호출 되고 해당 &lt;code&gt;stop&lt;/code&gt; 콜백이 리턴 되면 관계가 해소됩니다 . 하나의 자원은 여러 이벤트 오브젝트를 포함 할 수 있지만 하나의 이벤트 오브젝트는 하나의 자원에만 포함될 수 있습니다. 포함 된 모든 관계가 해소 될 때까지 리소스가 소멸되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bd2696be64fe7162dc1485b1d2c990c6c549132" translate="yes" xml:space="preserve">
          <source>The first call to an interpreted function by this process. (&lt;code&gt;Module:Function/Arity&lt;/code&gt;)</source>
          <target state="translated">이 프로세스에 의해 해석 된 함수에 대한 첫 번째 호출. ( &lt;code&gt;Module:Function/Arity&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f928094b6da781dfbc891a4120343ae4cc293b55" translate="yes" xml:space="preserve">
          <source>The first case is when we have the identity-function (&lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt;).</source>
          <target state="translated">첫 번째 경우는 identity-function ( &lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt; )이있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b0fbbc3247a8beb8eb5ac78e663feb3fa54615a2" translate="yes" xml:space="preserve">
          <source>The first element in the list is isolated and the list is split into two sublists.</source>
          <target state="translated">목록의 첫 번째 요소가 분리되고 목록이 두 개의 하위 목록으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="014ba2d1758d0deccfe95265702308ef94fdf898" translate="yes" xml:space="preserve">
          <source>The first element of &lt;code&gt;Type_List&lt;/code&gt; is the top type of the encoded message. In &lt;code&gt;Element_List&lt;/code&gt;, it is followed by each of the component names that leads to selected type.</source>
          <target state="translated">&lt;code&gt;Type_List&lt;/code&gt; 의 첫 번째 요소 는 인코딩 된 메시지의 최상위 유형입니다. 에서는 &lt;code&gt;Element_List&lt;/code&gt; , 이것은 각 성분 이름 뒤에 그 선택된 유형으로 이끈다.</target>
        </trans-unit>
        <trans-unit id="dc44175b8c8ad2a17dc68dd4333970027d3739a1" translate="yes" xml:space="preserve">
          <source>The first element of a non-empty &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; provides the local IP address if an &lt;code&gt;ip&lt;/code&gt; option is not specified. The local address is either returned from&lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; or passed in a &lt;code&gt;connected&lt;/code&gt; message over the transport interface.</source>
          <target state="translated">&lt;code&gt;ip&lt;/code&gt; 옵션이 지정되지 않은 경우 &lt;code&gt;Svc&lt;/code&gt; 에서 비어 있지 않은 &lt;code&gt;Host-IP-Address&lt;/code&gt; 목록 의 첫 번째 요소 는 로컬 IP 주소를 제공 합니다. 로컬 주소는 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 에서 리턴 되거나 전송 인터페이스를 통해 &lt;code&gt;connected&lt;/code&gt; 메시지로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb0352349ee5a8c0a7eb65cc210b44843f0b004" translate="yes" xml:space="preserve">
          <source>The first element of the tuple that is sent is your own pid. This enables &lt;code&gt;my_server&lt;/code&gt; to reply. For more information about the primitives, see the &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">전송되는 튜플의 첫 번째 요소는 자신의 pid입니다. 그러면 &lt;code&gt;my_server&lt;/code&gt; 가 응답 할 수 있습니다 . 기본 요소에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c3d22f06a7d30ce2b647923cf3347f78831669" translate="yes" xml:space="preserve">
          <source>The first field of a record is the second element of the tuple, which is the representation of the record.</source>
          <target state="translated">레코드의 첫 번째 필드는 레코드의 두 번째 요소 인 튜플의 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2595903ccef1ec77d7c52522a5524a8e9b27b8b6" translate="yes" xml:space="preserve">
          <source>The first filter that the trace data is exposed for is the &lt;code&gt;Collector Filter&lt;/code&gt;. When a trace &lt;code&gt;Event&lt;/code&gt; is reported with &lt;code&gt;et_collector:report/2&lt;/code&gt; (or &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt;) the first thing that happens, is that a message is sent to the &lt;code&gt;Collector&lt;/code&gt; process to fetch a handle that contains some useful stuff, such as the &lt;code&gt;Collector Filter Fun&lt;/code&gt; and an Ets table identifier. Then the &lt;code&gt;Collector Filter Fun&lt;/code&gt; is applied and if it returns &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;{true, NewEvent}&lt;/code&gt;), the &lt;code&gt;Event&lt;/code&gt; will be stored in an Ets table. As an optimization, subsequent calls to &lt;code&gt;et_collector:report&lt;/code&gt;-functions can use the handle directly instead of the &lt;code&gt;Collector Pid&lt;/code&gt;.</source>
          <target state="translated">추적 데이터가 노출되는 첫 번째 필터는 &lt;code&gt;Collector Filter&lt;/code&gt; 입니다. 추적 &lt;code&gt;Event&lt;/code&gt; 가 &lt;code&gt;et_collector:report/2&lt;/code&gt; (또는 &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; ) 로보 고 될 때 가장 먼저 발생하는 것은 메시지가 &lt;code&gt;Collector&lt;/code&gt; 프로세스로 전송되어 다음 과 같은 유용한 항목이 포함 된 핸들을 가져 오는 것입니다. &lt;code&gt;Collector Filter Fun&lt;/code&gt; 와 ETS 테이블 식별자. 그런 다음 &lt;code&gt;Collector Filter Fun&lt;/code&gt; 이 적용되고 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;{true, NewEvent}&lt;/code&gt; )를 반환 하면 &lt;code&gt;Event&lt;/code&gt; 가 Ets 테이블에 저장됩니다. 최적화로서 &lt;code&gt;et_collector:report&lt;/code&gt; 에 대한 후속 호출기능은 &lt;code&gt;Collector Pid&lt;/code&gt; 대신 핸들을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e93729010b78d1e9fdfb6095e599e11dc46611ef" translate="yes" xml:space="preserve">
          <source>The first has the effect of clearing any previous inherits, the second of replacing a previous inherits of &lt;code&gt;Prev&lt;/code&gt; to one of &lt;code&gt;Mod&lt;/code&gt;. This allows the semantics of the input dictionary to be changed without modifying the file itself.</source>
          <target state="translated">첫 번째는 이전 상속을 지우는 효과가 있고, 두 번째는 이전 상속을 &lt;code&gt;Prev&lt;/code&gt; 의 대체 를 &lt;code&gt;Mod&lt;/code&gt; 중 하나로 바꿉니다 . 이를 통해 파일 자체를 수정하지 않고 입력 사전의 의미를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb71912301094043ae2a458700ad5b6cfbe752e" translate="yes" xml:space="preserve">
          <source>The first implementation of DTrace probes for the Erlang virtual machine was presented at the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt;. That work, based on the Erlang/OTP R12 release, was discontinued due to what appears to be miscommunication with the original developers.</source>
          <target state="translated">Erlang 가상 머신에 대한 첫 번째 DTrace 프로브 구현은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt; 에서 발표되었습니다 . Erlang / OTP R12 릴리스를 기반으로하는이 작업은 원래 개발자와의 잘못된 통신으로 인해 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f97c49dffef8a26851ac783d21a876b74a6d528" translate="yes" xml:space="preserve">
          <source>The first instruction, &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; is described in the previous section.</source>
          <target state="translated">첫 번째 명령어 인 &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; 는 이전 섹션에서 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="e790f114bc8cf3a2ce28aebcfae1d5a3836f6a2d" translate="yes" xml:space="preserve">
          <source>The first is the current value.</source>
          <target state="translated">첫 번째는 현재 값입니다.</target>
        </trans-unit>
        <trans-unit id="314cc6cc859765f9b7338047d208d202513bf56d" translate="yes" xml:space="preserve">
          <source>The first level is at the UDP entry / exit point, i.e. immediately after the receipt of the message, before any message processing is done (accept_recv) and immediately before sending the message, after all message processing is done (accept_send).</source>
          <target state="translated">첫 번째 레벨은 모든 메시지 처리가 완료된 후 (accept_send) 메시지 처리가 완료되기 전 (accept_recv) 및 메시지를 보내기 직전의 UDP 시작 / 종료 지점에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16552c0f99d14efe5fd0c93c7ebdd486a4076a9" translate="yes" xml:space="preserve">
          <source>The first level is at the transport entry / exit point, i.e. immediately after the receipt of the message before any message processing is done (accept_recv) and immediately before sending the message after all message processing is done (accept_send).</source>
          <target state="translated">첫 번째 레벨은 전송 시작 ​​/ 종료 지점에 있습니다. 즉, 메시지 처리가 완료되기 전 (accept_recv) 및 모든 메시지 처리가 완료된 후 (accept_send) 메시지를 보내기 직전의 메시지 수신 직후.</target>
        </trans-unit>
        <trans-unit id="bbb474799d3c2ceaecdb69173050f2d2cde6ff68" translate="yes" xml:space="preserve">
          <source>The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, as no-pattern is not present, the subpattern matches nothing. That is, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.</source>
          <target state="translated">첫 번째 부분은 선택적인 여는 괄호와 일치하며 해당 문자가 있으면이를 첫 번째 캡처 된 하위 문자열로 설정합니다. 두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치합니다. 세 번째 부분은 첫 번째 괄호 세트가 일치하는지 테스트하는 조건부 하위 패턴입니다. 만일 그들이 주제를 시작 괄호로 시작하면, 조건은 참이므로 yes-pattern이 실행되고 종결 괄호가 필요합니다. 그렇지 않으면, 비 패턴이 존재하지 않기 때문에 서브 패턴은 아무것도 일치하지 않습니다. 즉,이 패턴은 선택적으로 괄호로 묶인 일련의 비 괄호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f02f68659112d26dce19edf7fe8cbae93aa2769c" translate="yes" xml:space="preserve">
          <source>The first part of the 64 bit template is identical to the 32 bit one, but there are some environment variable differences:</source>
          <target state="translated">64 비트 템플릿의 첫 번째 부분은 32 비트와 동일하지만 환경 변수 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65a1941d5d1778fd847b32c5e58a7ed60e551a2" translate="yes" xml:space="preserve">
          <source>The first part of the crash dump shows the following:</source>
          <target state="translated">크래시 덤프의 첫 번째 부분은 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2cc97c1e58d4679396d3bf61c813a63a062816e6" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a DEFINE group inside which is a another group named &quot;byte&quot; is defined. This matches an individual component of an IPv4 address (a number &amp;lt; 256). When matching takes place, this part of the pattern is skipped, as DEFINE acts like a false condition. The remaining pattern uses references to the named group to match the four dot-separated components of an IPv4 address, insisting on a word boundary at each end.</source>
          <target state="translated">패턴의 첫 번째 부분은 내부에 &quot;byte&quot;라는 다른 그룹 인 DEFINE 그룹입니다. 이는 IPv4 주소의 개별 구성 요소 (숫자 &amp;lt;256)와 일치합니다. 일치가 발생하면 DEFINE이 잘못된 조건처럼 작동하므로 패턴의이 부분을 건너 뜁니다. 나머지 패턴은 명명 된 그룹에 대한 참조를 사용하여 각 끝에서 단어 경계를 지정하여 IPv4 주소의 4 개의 점으로 구분 된 구성 요소를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="7724368c62d5b897d69875d863fc670d000c0a9f" translate="yes" xml:space="preserve">
          <source>The first part of the reference number in ref &lt;code&gt;t&lt;/code&gt;. Use only for compatibility.</source>
          <target state="translated">참조 번호의 첫 번째 부분은 ref &lt;code&gt;t&lt;/code&gt; 입니다. 호환성을 위해서만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232ebbaa469296f40c7a1846dbf2fa546b56c045" translate="yes" xml:space="preserve">
          <source>The first part says that the factorial of 1 is 1.:</source>
          <target state="translated">첫 번째 부분은 1의 계승이 1이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="dac65be594adc3151ec035f4511e37fe28d74a93" translate="yes" xml:space="preserve">
          <source>The first program contains some inadequacies regarding handling of nodes which disappear. These are corrected in a later version of the program.</source>
          <target state="translated">첫 번째 프로그램에는 사라지는 노드 처리와 관련하여 일부 부족한 점이 있습니다. 이 프로그램은 이후 버전의 프로그램에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="90106de27192d6ca833e750e4d48c96656c2317b" translate="yes" xml:space="preserve">
          <source>The first record attribute is the primary key, or key for short.</source>
          <target state="translated">첫 번째 레코드 속성은 기본 키 또는 짧은 키입니다.</target>
        </trans-unit>
        <trans-unit id="3a82a7bb7498f5fc4876294f7dfadf942e9bd19c" translate="yes" xml:space="preserve">
          <source>The first state that is entered will get a state enter call with &lt;code&gt;OldState&lt;/code&gt; equal to the current state.</source>
          <target state="translated">입력 된 첫 번째 상태는 &lt;code&gt;OldState&lt;/code&gt; 가 현재 상태 와 같은 상태 입력 호출을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="6086c2b9bf8be61602b6ebcc9d1ba07de24d3cb9" translate="yes" xml:space="preserve">
          <source>The first sublist contains all elements that are smaller than the first element in the list.</source>
          <target state="translated">첫 번째 하위 목록에는 목록의 첫 번째 요소보다 작은 모든 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7c16a3275bdd107763aa82124e29bdb96e0aa246" translate="yes" xml:space="preserve">
          <source>The first subsection will give a short background of the SSH protocol while later sections describes the implementation and provides some examples</source>
          <target state="translated">첫 번째 하위 섹션에서는 SSH 프로토콜에 대한 간단한 배경 지식을 제공하고 이후 섹션에서는 구현에 대해 설명하고 몇 가지 예를 제공합니다</target>
        </trans-unit>
        <trans-unit id="ea7284e31b879942988ef1c4ac5a9d9ef85d8089" translate="yes" xml:space="preserve">
          <source>The first test to run includes all suites for system &lt;code&gt;t1&lt;/code&gt;. Suites &lt;code&gt;t1B&lt;/code&gt; and &lt;code&gt;t1D&lt;/code&gt; are excluded from the test. Test cases &lt;code&gt;test3&lt;/code&gt; and &lt;code&gt;test4&lt;/code&gt; in &lt;code&gt;t1A&lt;/code&gt; and &lt;code&gt;test1&lt;/code&gt; case in &lt;code&gt;t1C&lt;/code&gt; are also excluded from the test.</source>
          <target state="translated">실행할 첫 번째 테스트에는 시스템 &lt;code&gt;t1&lt;/code&gt; 에 대한 모든 제품군이 포함됩니다 . 스위트 &lt;code&gt;t1B&lt;/code&gt; 및 &lt;code&gt;t1D&lt;/code&gt; 는 테스트에서 제외됩니다. 테스트 케이스의 &lt;code&gt;test3&lt;/code&gt; 및 &lt;code&gt;test4&lt;/code&gt; 에서 &lt;code&gt;t1A&lt;/code&gt; 와 &lt;code&gt;test1&lt;/code&gt; 의 경우 &lt;code&gt;t1C&lt;/code&gt; 또한 테스트에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca5c4abe4913702f7baf25de35a02c261b509bb" translate="yes" xml:space="preserve">
          <source>The first thing &lt;code&gt;blend/2&lt;/code&gt; does is to calculate the resulting alpha channel:</source>
          <target state="translated">&lt;code&gt;blend/2&lt;/code&gt; 가하는 첫 번째 일은 결과 알파 채널을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39ceda5701132f42099520c75ed5fefa2f0ce8cf" translate="yes" xml:space="preserve">
          <source>The first thing you need to do, is to make sure you have an ODBC driver installed for the database that you want to access. Both the client machine where you plan to run your erlang node and the server machine running the database needs the the ODBC driver. (In some cases the client and the server may be the same machine).</source>
          <target state="translated">가장 먼저해야 할 일은 액세스하려는 데이터베이스에 ODBC 드라이버가 설치되어 있는지 확인하는 것입니다. erlang 노드를 실행하려는 클라이언트 시스템과 데이터베이스를 실행하는 서버 시스템에는 모두 ODBC 드라이버가 필요합니다. (경우에 따라 클라이언트와 서버가 동일한 시스템 일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="2aae989cc7522942aff9cad7059abdf3f11420db" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;Fun&lt;/code&gt; is applied, &lt;code&gt;Acc0&lt;/code&gt; is the second argument. The next time &lt;code&gt;Fun&lt;/code&gt; is called, the return value from the previous call is used as the second argument. The term the last call to &lt;code&gt;Fun&lt;/code&gt; returns is the return value of the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 이 처음 적용되면 &lt;code&gt;Acc0&lt;/code&gt; 이 두 번째 인수입니다. 다음에 &lt;code&gt;Fun&lt;/code&gt; 을 호출하면 이전 호출의 반환 값이 두 번째 인수로 사용됩니다. &lt;code&gt;Fun&lt;/code&gt; 이 마지막으로 호출 한 용어는 &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 함수의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="50b73034e77a90f94080fa89965c6eaf0283e9d6" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;bchunk/2&lt;/code&gt; is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided.</source>
          <target state="translated">처음 &lt;code&gt;bchunk/2&lt;/code&gt; 는 초기 연속, 원자, 호출 &lt;code&gt;start&lt;/code&gt; 제공되어야한다.</target>
        </trans-unit>
        <trans-unit id="0c2f550699da636c0cd8e01902373a891091a02a" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; (or &lt;code&gt;bchunk()&lt;/code&gt;) is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided. If a disk log process is running on the current node, terms are read from that log. Otherwise, an individual distributed log on some other node is chosen, if such a log exists.</source>
          <target state="translated">처음 &lt;code&gt;chunk()&lt;/code&gt; (또는 &lt;code&gt;bchunk()&lt;/code&gt; )라고하며, 초기 지속, 원자 &lt;code&gt;start&lt;/code&gt; 제공되어야한다. 디스크 로그 프로세스가 현재 노드에서 실행중인 경우 해당 로그에서 용어를 읽습니다. 그렇지 않으면, 그러한 로그가 존재하는 경우 다른 노드의 개별 분산 로그가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae42b9440fbcdcd3aef0e04e0d47cfcd6b93638" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; is called, an initial continuation returned from &lt;code&gt;open/1&lt;/code&gt; or &lt;code&gt;open/2&lt;/code&gt; must be provided.</source>
          <target state="translated">&lt;code&gt;chunk()&lt;/code&gt; 가 처음 호출 될 때 &lt;code&gt;open/1&lt;/code&gt; 또는 &lt;code&gt;open/2&lt;/code&gt; 에서 리턴 된 초기 연속 이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f24cb290ca20c81eb6b4416fabb904d4e10dd7ea" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;my_binary_to_list/1&lt;/code&gt; is called, a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; is created. The match context points to the first byte of the binary. 1 byte is matched out and the match context is updated to point to the second byte in the binary.</source>
          <target state="translated">&lt;code&gt;my_binary_to_list/1&lt;/code&gt; 을 처음 호출하면 &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; 가 작성됩니다. 일치 컨텍스트는 이진의 첫 번째 바이트를 가리 킵니다. 1 바이트가 일치하고 이진에서 두 번째 바이트를 가리 키도록 일치 컨텍스트가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1823ded8e66bfbd9fc7ce09687bb9aaa31338fbb" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;save_scenario/0&lt;/code&gt; is called a server will be started. This server will save runtime scenarios. All saved scenarios can be removed by calling &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_scenario/0&lt;/code&gt; 을 처음 호출하면 서버가 시작됩니다. 이 서버는 런타임 시나리오를 저장합니다. &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; 을 호출하여 저장된 모든 시나리오를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2da631291d48912dfb7f5e3e966ba2a0afa5f92f" translate="yes" xml:space="preserve">
          <source>The first time this function is called, &lt;code&gt;error_logger&lt;/code&gt; is added as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is started.</source>
          <target state="translated">이 함수를 처음 호출하면 &lt;code&gt;error_logger&lt;/code&gt; 가 로거 핸들러로 추가되고 &lt;code&gt;error_logger&lt;/code&gt; 프로세스가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac2627c749c91f8bf457c1c48d430daa18c89a6" translate="yes" xml:space="preserve">
          <source>The first user &quot;sends&quot; the message in the example above by:</source>
          <target state="translated">첫 번째 사용자는 위의 예에서 다음과 같이 메시지를 &quot;보냅니다&quot;.</target>
        </trans-unit>
        <trans-unit id="03cb12d8f1c72fe9141e80abe570426dd8888741" translate="yes" xml:space="preserve">
          <source>The first value indicates the default &lt;code&gt;priv_dir&lt;/code&gt; behavior, that is, one private directory created per test run. The two latter values tell &lt;code&gt;Common Test&lt;/code&gt; to generate a unique test directory name per test case and execution. If the auto version is used, &lt;strong&gt;all&lt;/strong&gt; private directories are created automatically. This can become very inefficient for test runs with many test cases or repetitions, or both. Therefore, if the manual version is used instead, the test case must tell &lt;code&gt;Common Test&lt;/code&gt; to create &lt;code&gt;priv_dir&lt;/code&gt; when it needs it. It does this by calling the function &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 값은 기본 &lt;code&gt;priv_dir&lt;/code&gt; 동작, 즉 테스트 실행마다 작성된 하나의 개인 디렉토리를 나타냅니다 . 후자의 두 값은 &lt;code&gt;Common Test&lt;/code&gt; 에게 테스트 케이스 및 실행마다 고유 한 테스트 디렉토리 이름을 생성하도록 지시합니다. 자동 버전이 사용되면 &lt;strong&gt;모든&lt;/strong&gt; 개인 디렉토리가 자동으로 작성됩니다. 많은 테스트 사례 또는 반복 또는 둘 다를 사용하여 테스트를 실행하는 경우 매우 비효율적 일 수 있습니다. 따라서 수동 버전을 대신 사용하는 경우 테스트 케이스는 &lt;code&gt;Common Test&lt;/code&gt; 에게 &lt;code&gt;priv_dir&lt;/code&gt; 때 priv_dir 을 작성 하도록 지시 해야합니다. &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt; 함수를 호출하여이를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="5b7f2b74f4ad7fcb69baccbea779f423b38f85de" translate="yes" xml:space="preserve">
          <source>The first value is limited to the values 0, 1, or 2. The second value must be in the range 0..39 when the first value is 0 or 1.</source>
          <target state="translated">첫 번째 값은 0, 1 또는 2 값으로 제한됩니다. 첫 번째 값이 0 또는 1 인 경우 두 번째 값은 0..39 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="76cac286407464f1a3cab30ae6ed03a1a8b426a4" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-extra&lt;/code&gt; is treated in special way. Its scope ends at the end of the file. Arguments following an &lt;code&gt;-extra&lt;/code&gt; flag are moved on the command line into the &lt;code&gt;-extra&lt;/code&gt; section, that is, the end of the command line following after an &lt;code&gt;-extra&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;-extra&lt;/code&gt; 플래그 는 특별한 방식으로 처리됩니다. 범위는 파일 끝에서 끝납니다. &lt;code&gt;-extra&lt;/code&gt; 플래그 다음의 인수 는 명령 행에서 &lt;code&gt;-extra&lt;/code&gt; 섹션으로, 즉 &lt;code&gt;-extra&lt;/code&gt; 플래그 다음에 오는 명령 행의 끝으로 이동 됩니다.</target>
        </trans-unit>
        <trans-unit id="095fd71fa9f6ba7fe4c40943793a2bb698c7bbdc" translate="yes" xml:space="preserve">
          <source>The flag can also be set by the STDLIB application variable &lt;code&gt;shell_strings&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;, which means that lists of integers are printed using the string syntax, when possible. Value &lt;code&gt;false&lt;/code&gt; means that no lists are printed using the string syntax.</source>
          <target state="translated">플래그는 STDLIB 응용 프로그램 변수 &lt;code&gt;shell_strings&lt;/code&gt; 에 의해 설정 될 수도 있습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 이며, 가능하면 문자열 구문을 사용하여 정수 목록이 인쇄됩니다. &lt;code&gt;false&lt;/code&gt; 값 은 문자열 구문을 사용하여 목록이 인쇄되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="16ee325443e908603dacad16b814927c10a42e37" translate="yes" xml:space="preserve">
          <source>The flag field of an atom cache reference has the following format:</source>
          <target state="translated">아톰 캐시 참조의 플래그 필드는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a080305c71ef71f1663e7718a0bc9d58d29dd1e8" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;suite&lt;/code&gt;, and &lt;code&gt;group/case&lt;/code&gt; can be combined. For example, to run &lt;code&gt;x_SUITE&lt;/code&gt; and &lt;code&gt;y_SUITE&lt;/code&gt; in directory &lt;code&gt;testdir&lt;/code&gt;, as follows:</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;suite&lt;/code&gt; 및 &lt;code&gt;group/case&lt;/code&gt; 플래그를 결합 할 수 있습니다. 예를 들어, &lt;code&gt;testdir&lt;/code&gt; 디렉토리에서 &lt;code&gt;x_SUITE&lt;/code&gt; 및 &lt;code&gt;y_SUITE&lt;/code&gt; 를 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b93b96139f6762ecd80290edd696f2ed98f35890" translate="yes" xml:space="preserve">
          <source>The flags specific to the MIB compiler can be specified by using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">MIB 컴파일러 고유의 플래그는 &lt;code&gt;+&lt;/code&gt; 구문 을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428847ac69b6b0b0a5e6c4145d8ec6d570f6c395" translate="yes" xml:space="preserve">
          <source>The flex libraries. Without it, the flex powered codecs cannot be used.</source>
          <target state="translated">플렉스 라이브러리. 그렇지 않으면 플렉스 전원 코덱을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c159710396ee724ac90ec79947b2b5b4c1587632" translate="yes" xml:space="preserve">
          <source>The flex scanner is written using a tool called &lt;strong&gt;flex&lt;/strong&gt;. In order to be able to compile the flex scanner driver, this tool has to be available.</source>
          <target state="translated">플렉스 스캐너라는 도구 사용하여 작성 &lt;strong&gt;플렉스&lt;/strong&gt; . Flex 스캐너 드라이버를 컴파일하려면이 도구를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7c4ca511a9bd4686762da41fca66fa99a0af1b0" translate="yes" xml:space="preserve">
          <source>The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag.</source>
          <target state="translated">이 모듈의 부동 소수점 생성 기능은 정수에서 변환 할 때 가장 낮은 비트를 낭비하므로 이러한 걸림을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c041ae86c5f8c7016b0e10add46c29cac233bc88" translate="yes" xml:space="preserve">
          <source>The floating point value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">의 부동 소수점 값 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e419b2fab0b36bcecd87f0c3d0efca53ec378a69" translate="yes" xml:space="preserve">
          <source>The focus of the Erlang reference manual is on the language itself, not the implementation of it. The language constructs are described in text and with examples rather than formally specified. This is to make the manual more readable. The Erlang reference manual is not intended as a tutorial.</source>
          <target state="translated">Erlang 참조 매뉴얼의 초점은 언어 자체가 아니라 구현에 있습니다. 언어 구성은 공식적으로 지정되지 않고 텍스트와 예제로 설명됩니다. 이것은 매뉴얼을 더 읽기 쉽게하기위한 것입니다. Erlang 참조 매뉴얼은 튜토리얼을위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="14233773185c2d086e35c41f6b44cd3cb166311c" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;#hs_data{}&lt;/code&gt; record fields need to be set unless otherwise stated:</source>
          <target state="translated">달리 명시되지 않는 한 다음 &lt;code&gt;#hs_data{}&lt;/code&gt; 레코드 필드를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="755882894d7fd28bede6b99ec073119565eb9367" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s are available. All states are exclusive, meaning that a thread cannot be in two states at once. So, if you add the numbers of all counters in a thread, you get the total runtime for that thread.</source>
          <target state="translated">다음과 같은 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; 를 사용할 수 있습니다. 모든 상태는 배타적이므로 스레드는 한 번에 두 가지 상태에있을 수 없습니다. 따라서 스레드의 모든 카운터 수를 추가하면 해당 스레드의 총 런타임이 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="9f76f02eae75217eb2a5f3c4fb6a601b97548d9f" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes pretty printing of NETCONF traffic to separate logs for the connections named &lt;code&gt;nc_server1&lt;/code&gt; and &lt;code&gt;nc_server2&lt;/code&gt;. Any other connections are logged to default NETCONF log.</source>
          <target state="translated">다음 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 &lt;code&gt;nc_server1&lt;/code&gt; 및 &lt;code&gt;nc_server2&lt;/code&gt; 연결에 대한 로그를 분리하기 위해 NETCONF 트래픽을 꽤 인쇄 합니다. 다른 모든 연결은 기본 NETCONF 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="60898a22579d212b66c103e94e65e3704c005128" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes printing of Telnet traffic to separate logs for the connections &lt;code&gt;server1&lt;/code&gt; and &lt;code&gt;server2&lt;/code&gt;. Traffic for any other connections is logged in the default Telnet log.</source>
          <target state="translated">다음 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 Telnet 트래픽을 인쇄하여 연결 &lt;code&gt;server1&lt;/code&gt; 및 &lt;code&gt;server2&lt;/code&gt; 에 대한 로그를 분리 합니다. 다른 연결에 대한 트래픽은 기본 Telnet 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="1bc4e72d8d4d5620576eec368f8680635ae64598" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;upgrade&lt;/code&gt; instruction is used for supervisors:</source>
          <target state="translated">다음 &lt;code&gt;upgrade&lt;/code&gt; 지침이 감독자에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7721dfe03e9c154ea4e1c34f92eac19aef611c75" translate="yes" xml:space="preserve">
          <source>The following ASN.1 type is used for real numbers:</source>
          <target state="translated">다음 ASN.1 유형은 실수에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da76d97e2e28f2e89ed233e203305a30d4111d61" translate="yes" xml:space="preserve">
          <source>The following BIFs, which are used to create processes, return values of this data type:</source>
          <target state="translated">프로세스를 작성하는 데 사용되는 다음 BIF는이 데이터 유형의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ca462812b4b616c1a4a1c09a1f4a79f0f85f0e72" translate="yes" xml:space="preserve">
          <source>The following CTH logs information about a test run into a format parseable by &lt;code&gt;file:consult/1&lt;/code&gt; (in Kernel):</source>
          <target state="translated">다음 CTH는 테스트 실행에 대한 정보를 &lt;code&gt;file:consult/1&lt;/code&gt; (커널)로 구문 분석 할 수있는 형식으로 기록 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e71ecc8d7cab4d72922ae4ed2e33319f8122346" translate="yes" xml:space="preserve">
          <source>The following I/O request is optional to implement and a client is to be prepared for an error return:</source>
          <target state="translated">다음 I / O 요청은 선택적으로 구현할 수 있으며 클라이언트는 오류 리턴을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="0827ebd08d8a02057148a27dc548b0eb839f8cf1" translate="yes" xml:space="preserve">
          <source>The following Item's are valid:</source>
          <target state="translated">다음 품목이 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="8931f5659efe1bfa45e91bfba89a696d04a3885e" translate="yes" xml:space="preserve">
          <source>The following Kernel configuration parameters apply to Logger:</source>
          <target state="translated">다음 커널 구성 매개 변수가 로거에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f963b53749dee80b3ebd6d93009cb72dd723e7e" translate="yes" xml:space="preserve">
          <source>The following Logger API functions can trigger this callback:</source>
          <target state="translated">다음과 같은 로거 API 함수가이 콜백을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d2e24198262f39e955cdd7b2bb38352780ad95" translate="yes" xml:space="preserve">
          <source>The following MIBs are built-ins of the Erlang SNMP compiler: SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and RFC1155-SMI. They cannot therefore be compiled separately.</source>
          <target state="translated">Erlang SNMP 컴파일러에 내장 된 MIB는 SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF 및 RFC1155-SMI입니다. 따라서 따로 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52d19d789c25255eed9a979999ac8863363f1228" translate="yes" xml:space="preserve">
          <source>The following MIBs are defined in the OTP system:</source>
          <target state="translated">다음 MIB가 OTP 시스템에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f58c9a6d16d6a288dad320d6e8998be16e44721f" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private DSA key:</source>
          <target state="translated">다음 PEM 파일에는 개인 DSA 키 항목이 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1e06caf4405f8154436d98b0b535f1d1da5766" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private RSA key:</source>
          <target state="translated">다음 PEM 파일에는 개인 RSA 키 항목이 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6e0ebe475e308588ade6bad38f0a1b0d7fad83" translate="yes" xml:space="preserve">
          <source>The following activity access contexts are currently supported:</source>
          <target state="translated">다음 활동 액세스 컨텍스트가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7f3d9893eedee1a260cc5b49377b2f1f743ccc" translate="yes" xml:space="preserve">
          <source>The following algorithms are provided:</source>
          <target state="translated">다음과 같은 알고리즘이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="390e0b5eb1e3b7230aad019d3e06855c658180f0" translate="yes" xml:space="preserve">
          <source>The following allocators are present:</source>
          <target state="translated">다음과 같은 할당자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4821bb8c6c116cef14beeab931818f4969279b8" translate="yes" xml:space="preserve">
          <source>The following are primitives, which do not contain other test sets as arguments:</source>
          <target state="translated">다음은 다른 테스트 세트를 인수로 포함하지 않는 기본 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b988567cb4ebfa83309f7036c88dc38f105b9489" translate="yes" xml:space="preserve">
          <source>The following are reserved words in Erlang:</source>
          <target state="translated">다음은 Erlang의 예약어입니다.</target>
        </trans-unit>
        <trans-unit id="23a58c2300ac41928639f29dbe01e89240b2ddfc" translate="yes" xml:space="preserve">
          <source>The following are some of the most important and attractive capabilities provided by Mnesia:</source>
          <target state="translated">다음은 Mnesia가 제공하는 가장 중요하고 매력적인 기능 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="446aea39bd6d645ca35077d4770c830fb9a617e9" translate="yes" xml:space="preserve">
          <source>The following are the fun clauses parameter lists:</source>
          <target state="translated">다음은 fun clauses 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b9a2d4753855996ec68919109001bdcfdfab1176" translate="yes" xml:space="preserve">
          <source>The following are the horizontal space characters:</source>
          <target state="translated">가로 공백 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e7dca09b462b81dbf316dd39e6aa81ce86d2e59" translate="yes" xml:space="preserve">
          <source>The following are the main features of Trace Tool Builder:</source>
          <target state="translated">다음은 Trace Tool Builder의 주요 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4e925277c492d9e6356d76bfacfb3ab772525403" translate="yes" xml:space="preserve">
          <source>The following are the most widely spread encodings:</source>
          <target state="translated">다음은 가장 널리 사용되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="1d30a8b8e3b663292a1ad0bd4a17fb0b5f2c8ae2" translate="yes" xml:space="preserve">
          <source>The following are the possible runtime errors:</source>
          <target state="translated">가능한 런타임 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11e4ce827beb7d257dafdeafaf65224573e225ee" translate="yes" xml:space="preserve">
          <source>The following are the predefined sets of subpatterns:</source>
          <target state="translated">다음은 사전 정의 된 하위 패턴 세트입니다.</target>
        </trans-unit>
        <trans-unit id="b8aeeeb29a22d61e4651a7f7c64491c002da04f2" translate="yes" xml:space="preserve">
          <source>The following are the supported class names:</source>
          <target state="translated">지원되는 클래스 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ae73677bdb343efa75ef5239df98c3995eb5a45" translate="yes" xml:space="preserve">
          <source>The following are the vertical space characters:</source>
          <target state="translated">다음은 세로 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e13eea1a0552634ec49861dfedef83923f03fb36" translate="yes" xml:space="preserve">
          <source>The following argument is required:</source>
          <target state="translated">다음과 같은 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b3fe3a25174fa0e4b7397791cbe163414c93cae5" translate="yes" xml:space="preserve">
          <source>The following behavior applies if &lt;code&gt;Reason&lt;/code&gt; is any term, except &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;kill&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 이 &lt;code&gt;normal&lt;/code&gt; 또는 &lt;code&gt;kill&lt;/code&gt; 을 제외한 임의의 용어 인 경우 다음 동작이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed43b5794a433578fe75d6227c8f8fec9b973992" translate="yes" xml:space="preserve">
          <source>The following built-in handlers exist:</source>
          <target state="translated">다음과 같은 내장 핸들러가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48df9c121f20b43e9189951e6b161ed4e78306b" translate="yes" xml:space="preserve">
          <source>The following built-in list types also exist, but they are expected to be rarely used. Hence, they have long names:</source>
          <target state="translated">다음과 같은 내장 목록 유형도 있지만 거의 사용되지 않을 것으로 예상됩니다. 따라서 그들은 긴 이름을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="56efeb40efc4a8607cb2cf3d6a1bbfa58461fecd" translate="yes" xml:space="preserve">
          <source>The following call would create a table that is replicated on two nodes, has an extra index on attribute &lt;code&gt;y&lt;/code&gt;, and is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">다음 호출은 두 노드에 복제되고 속성 &lt;code&gt;y&lt;/code&gt; 에 대한 추가 색인이 있고 &lt;code&gt;bag&lt;/code&gt; 유형 인 테이블을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="b93cef34769b4ac84bcc58e1f7579a27e1900915" translate="yes" xml:space="preserve">
          <source>The following calls use the default client profile. Use the proxy &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt;, except from requests to localhost. This applies to all the following requests.</source>
          <target state="translated">다음 호출은 기본 클라이언트 프로파일을 사용합니다. localhost에 대한 요청을 제외하고 &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt; 프록시를 사용하십시오 . 이것은 다음의 모든 요청에 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce6762a2b45b2a9419ebd342a2248363882b1ec" translate="yes" xml:space="preserve">
          <source>The following can be done from the shell:</source>
          <target state="translated">쉘에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f1ccb49a8a37c5657c1e09929d43e77df7e6d3" translate="yes" xml:space="preserve">
          <source>The following can help you estimate the buffer requirements for a term. Notice that this information is implementation-specific, and can change in future versions. If you are unsure, use &lt;code&gt;erl_term_len()&lt;/code&gt;.</source>
          <target state="translated">다음은 용어의 버퍼 요구 사항을 추정하는 데 도움이 될 수 있습니다. 이 정보는 구현에 따라 다르며 향후 버전에서 변경 될 수 있습니다. 확실하지 않으면 &lt;code&gt;erl_term_len()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f875dcb652b105150192f44a7e364beec117361" translate="yes" xml:space="preserve">
          <source>The following capability flags are defined:</source>
          <target state="translated">다음과 같은 기능 플래그가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b153457b0c6c74e16cf68b399d11c4fdbeda5276" translate="yes" xml:space="preserve">
          <source>The following capability identifiers, defined in RFC 4741 NETCONF Configuration Protocol, can be returned:</source>
          <target state="translated">RFC 4741 NETCONF 구성 프로토콜에 정의 된 다음 기능 ID가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729ccfc9617ba57afc9d1a89abcf609beb87615d" translate="yes" xml:space="preserve">
          <source>The following causes an error at compile time:</source>
          <target state="translated">다음은 컴파일시 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="46da2b6d47972d1cbb42e35ed601e935a7066068" translate="yes" xml:space="preserve">
          <source>The following changes are added:</source>
          <target state="translated">다음 변경 사항이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="223954bbc5bf81b4921c410a25f0bd6051babb47" translate="yes" xml:space="preserve">
          <source>The following code adds a parser interface to the grammar:</source>
          <target state="translated">다음 코드는 문법에 파서 인터페이스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="132d723fbc5d22b21ca88cffc9fa6e6381b81134" translate="yes" xml:space="preserve">
          <source>The following code defines a function &lt;code&gt;pconst(X)&lt;/code&gt; in the module &lt;code&gt;funparse&lt;/code&gt;, which returns a fun that parses a list of tokens:</source>
          <target state="translated">다음 코드는 함수 정의 &lt;code&gt;pconst(X)&lt;/code&gt; 모듈에서 &lt;code&gt;funparse&lt;/code&gt; 토큰의 목록을 구문 분석 재미를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="56844778b2176882fb2364c894e6a3f1cbf9d20a" translate="yes" xml:space="preserve">
          <source>The following code exemplifies a search with a non-normalized data model. To find all employees at department &lt;code&gt;Dep&lt;/code&gt; with a salary higher than &lt;code&gt;Salary&lt;/code&gt;, use the following code:</source>
          <target state="translated">다음 코드는 정규화되지 않은 데이터 모델을 사용한 검색을 보여줍니다. 부서의 모든 직원 찾으려면 &lt;code&gt;Dep&lt;/code&gt; 보다 높은 급여와 &lt;code&gt;Salary&lt;/code&gt; , 다음 코드를 사용 :</target>
        </trans-unit>
        <trans-unit id="3cf0020bc55d0fa1c895bb9fac0126cb39735295" translate="yes" xml:space="preserve">
          <source>The following code fragment is a simple example of a client connecting to a server at port 5678, transferring a binary, and closing the connection:</source>
          <target state="translated">다음 코드 조각은 클라이언트가 포트 5678에서 서버에 연결하고 바이너리를 전송 한 후 연결을 닫는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="aa22415381d6bc1bea3d2a6fcf7c7cf3cea03a9e" translate="yes" xml:space="preserve">
          <source>The following code illustrates how a &lt;code&gt;Mnesia&lt;/code&gt; table is converted to be a fragmented table and how more fragments are added later:</source>
          <target state="translated">다음 코드는 &lt;code&gt;Mnesia&lt;/code&gt; 테이블이 조각화 된 테이블로 변환되는 방법과 나중에 더 많은 조각이 추가되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4edc8cb91e65e300012f8cc9f371bfd50b18952b" translate="yes" xml:space="preserve">
          <source>The following code is executed to achieve this:</source>
          <target state="translated">이를 달성하기 위해 다음 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bf087b2d7139054e72c10f87277f4e9105ae6aae" translate="yes" xml:space="preserve">
          <source>The following code is from the sample file &lt;code&gt;next_perm.cc&lt;/code&gt;. The driver entry looks like before, but also contains the callback &lt;code&gt;ready_async&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 샘플 파일 &lt;code&gt;next_perm.cc&lt;/code&gt; 의 코드입니다 . 드라이버 항목은 이전과 같지만 콜백 &lt;code&gt;ready_async&lt;/code&gt; 도 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="fd629e06b526d07e792ece40b307e86e30aa4c96" translate="yes" xml:space="preserve">
          <source>The following code is slightly slower because the shape of the list of arguments is unknown at compile time.</source>
          <target state="translated">다음 코드는 인수 목록의 모양을 컴파일 타임에 알 수 없으므로 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="1c15d7bb6d9f5ccee5265bb8903dc3f1c45a0ae2" translate="yes" xml:space="preserve">
          <source>The following code is the Erlang part of the synchronous postgres driver, &lt;code&gt;pg_sync.erl&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 동기 postgres 드라이버 &lt;code&gt;pg_sync.erl&lt;/code&gt; 의 Erlang 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="dca40145d4c0653ae61a32b900aff83a1d19f042" translate="yes" xml:space="preserve">
          <source>The following code reduces the search space and is more efficient:</source>
          <target state="translated">다음 코드는 검색 공간을 줄이고 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">다음 코드 :</target>
        </trans-unit>
        <trans-unit id="10e52292e9dee4a0e3fd6642d8202ab55d1217aa" translate="yes" xml:space="preserve">
          <source>The following command are directly available for indentation.</source>
          <target state="translated">들여 쓰기에는 다음 명령을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54ee1055259696f0cf635190505ae13de7c7874" translate="yes" xml:space="preserve">
          <source>The following commands and functions are used to initiate the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스 를 시작하는 데 다음 명령 및 기능이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a32fdf2e9df498e6565b300a038b14cb68a1735d" translate="yes" xml:space="preserve">
          <source>The following compilers are supported:</source>
          <target state="translated">다음과 같은 컴파일러가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfc763d98ab927b97e114c3d3db99c10685fbd5" translate="yes" xml:space="preserve">
          <source>The following configuration file causes raw logging of all NETCONF traffic in to one single text file:</source>
          <target state="translated">다음 구성 파일은 모든 NETCONF 트래픽을 하나의 단일 텍스트 파일로 원시 로깅합니다.</target>
        </trans-unit>
        <trans-unit id="f14322549f377ad730735aaebaa29c12d04adf7a" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time interval and threshold:</source>
          <target state="translated">다음 구성 매개 변수를 사용하여 시간 간격 및 임계 값의 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193ce5872a1a6b1151ebfa805bdd3ed1418c9a2b" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time intervals and thresholds:</source>
          <target state="translated">다음 구성 매개 변수를 사용하여 시간 간격 및 임계 값의 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d3f81dcc2fefa92fa2bf61c616cec96c1c09f3" translate="yes" xml:space="preserve">
          <source>The following custom metadata keys have special meaning:</source>
          <target state="translated">다음 사용자 정의 메타 데이터 키에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9245e4a9bd60ce63efee4dfb325d04bbf467167e" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions below:</source>
          <target state="translated">아래 기능에서 사용되는 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48be2dc36e35956a8e3588aca9cfc84f77c588b6" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;public_key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;public_key&lt;/code&gt; 의 함수에는 다음 데이터 유형이 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbde7c9ddb7eaf9bcf77f4db441bfdef5bb61047" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;ssl_session_cache_api&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ssl_session_cache_api&lt;/code&gt; 의 함수에는 다음 데이터 유형이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ae4ee24ac66de733888ad1963744fbfbce6e5f4" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for SSL/TLS/DTLS:</source>
          <target state="translated">SSL / TLS / DTLS의 기능에는 다음 데이터 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f214626dc0835db98c5ea380264f0633bf284ba" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for mod_esi:</source>
          <target state="translated">다음 데이터 유형이 mod_esi의 함수에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79cd8536de4f9b5bd968aa07ab5a04ff86d91140" translate="yes" xml:space="preserve">
          <source>The following data types concern the DNS client:</source>
          <target state="translated">다음 데이터 유형은 DNS 클라이언트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d37752ba97444275d3af617925c81e1b46edf9" translate="yes" xml:space="preserve">
          <source>The following data types concern the resolver:</source>
          <target state="translated">다음 데이터 유형은 리졸버와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb88a84344840ee75edbb731e8eaf81fb9c735" translate="yes" xml:space="preserve">
          <source>The following data-types are used in the functions below:</source>
          <target state="translated">아래 함수에서 사용되는 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1484bd1263f6980852c4824bd6d929836444bb83" translate="yes" xml:space="preserve">
          <source>The following definitions are used in the SNMP User's Guide.</source>
          <target state="translated">다음 정의는 SNMP 사용 설명서에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="39b4ce09657d83e126a92760457f3f4da1a2f574" translate="yes" xml:space="preserve">
          <source>The following dialog within the Erlang shell illustrates the functionality of the Erlang ODBC interface. The table used in the example does not have any relevance to anything that exist in reality, it is just a simple example. The example was created using &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; as database and the ODBC driver for &lt;code&gt;sqlserver&lt;/code&gt; with version &lt;code&gt;2000.80.194.00&lt;/code&gt;.</source>
          <target state="translated">Erlang 셸 내의 다음 대화 상자는 Erlang ODBC 인터페이스의 기능을 보여줍니다. 예제에 사용 된 테이블은 실제로 존재하는 것과 관련이 없으며 단순한 예제 일뿐입니다. 이 예제는 &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; 을 데이터베이스로 sqlserver 7.0 과 버전 &lt;code&gt;2000.80.194.00&lt;/code&gt; 을 가진 &lt;code&gt;sqlserver&lt;/code&gt; 용 ODBC 드라이버를 사용하여 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="99bffcf83f746fcc6153881b4b1631f84352b58c" translate="yes" xml:space="preserve">
          <source>The following directory must exist in the system to run the manager:</source>
          <target state="translated">관리자를 실행하려면 시스템에 다음 디렉토리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4067663f255bf23f8ace734d9a80cb7e8eb13f2" translate="yes" xml:space="preserve">
          <source>The following distinct values are recognised:</source>
          <target state="translated">다음과 같은 고유 한 값이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="5bbdb173d3c169abec87c3f3bd04716fdb1d1176" translate="yes" xml:space="preserve">
          <source>The following elements are always present in the list for both local and external funs:</source>
          <target state="translated">로컬 및 외부 재미를 위해 다음 요소가 항상 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="314e2c48845f15727630c647a2291eeb21cc401b" translate="yes" xml:space="preserve">
          <source>The following elements are only present in the list if &lt;code&gt;Fun&lt;/code&gt; is local:</source>
          <target state="translated">다음 요소는 &lt;code&gt;Fun&lt;/code&gt; 이 로컬 인 경우에만 목록에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f117ec12e436f6ca90db1a4bc190e20fe521a5b3" translate="yes" xml:space="preserve">
          <source>The following encoding modules are provided:</source>
          <target state="translated">다음과 같은 인코딩 모듈이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="77da27c3c246440f97582892c2d759bcdbc2e044" translate="yes" xml:space="preserve">
          <source>The following environment variables are recognized by &lt;code&gt;run_erl&lt;/code&gt; and change the logging behavior. For more information, see the previous section.</source>
          <target state="translated">다음 환경 변수는 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 인식되고 로깅 동작을 변경합니다. 자세한 내용은 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="555e6e3612dc9741d46001a128eafcf81c3f1408" translate="yes" xml:space="preserve">
          <source>The following equalities hold for all sequences:</source>
          <target state="translated">모든 시퀀스에 대해 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="31645542bb6c8a8301b513644f9cd8b30b64cec9" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the basic functionality used to run the Erlang ASN.1 compiler.</source>
          <target state="translated">다음 예는 Erlang ASN.1 컴파일러를 실행하는 데 사용되는 기본 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="80f9ad21016f571b21439d39ef29483bf86436fd" translate="yes" xml:space="preserve">
          <source>The following example generates all permutations of the elements in a list:</source>
          <target state="translated">다음 예제는 목록에서 요소의 모든 순열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c404080201f0735af63fd0d67d38459effaabe41" translate="yes" xml:space="preserve">
          <source>The following example illustrate how code can be divided into a generic and a specific part. Consider the following code (written in plain Erlang) for a simple server, which keeps track of a number of &quot;channels&quot;. Other processes can allocate and free the channels by calling the functions &lt;code&gt;alloc/0&lt;/code&gt; and &lt;code&gt;free/1&lt;/code&gt;, respectively.</source>
          <target state="translated">다음 예제는 코드를 일반 부분과 특정 부분으로 나누는 방법을 보여줍니다. 간단한 서버의 경우 다음과 같은 코드 (일반 Erlang으로 작성)를 고려하여 여러 &quot;채널&quot;을 추적합니다. 다른 프로세스는 각각 &lt;code&gt;alloc/0&lt;/code&gt; 및 &lt;code&gt;free/1&lt;/code&gt; 함수를 호출하여 채널을 할당하고 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49ac7049a1dcc2d7a9ce14f9a85fbfcae1153db4" translate="yes" xml:space="preserve">
          <source>The following example illustrates a simple, functional parser that parses the grammar:</source>
          <target state="translated">다음 예제는 문법을 구문 분석하는 간단한 기능적 구문 분석기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8140848b7fdb3cf3311bc85e2c217120f0d742dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates a situation in which we have an SNMP table that we wish to implement as a Mnesia table. The table stores information about employees at a company. Each employee is indexed with the department number and the name.</source>
          <target state="translated">다음 예는 Mnesia 테이블로 구현하려는 SNMP 테이블이있는 상황을 보여줍니다. 이 테이블에는 회사 직원에 대한 정보가 저장됩니다. 각 직원은 부서 번호와 이름으로 색인됩니다.</target>
        </trans-unit>
        <trans-unit id="e0bf2809ff12bfda2aa29b8a9ba782d668e893f5" translate="yes" xml:space="preserve">
          <source>The following example illustrates how this function and &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; are used:</source>
          <target state="translated">다음 예제는이 함수와 &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; 가 사용되는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="474a94a5e901e0dd50063b0b025da701b6e45408" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between type &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;bag&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 유형 &lt;code&gt;set&lt;/code&gt; 와 &lt;code&gt;bag&lt;/code&gt; 의 차이점을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="39a99dfd22c81e72385e303daaf447a32f1dcfba" translate="yes" xml:space="preserve">
          <source>The following example illustrates this idea:</source>
          <target state="translated">다음 예제는이 아이디어를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0064c1a1c0bd35406debf90dd3f22d06ce617d65" translate="yes" xml:space="preserve">
          <source>The following example illustrates use of option &lt;code&gt;{active,once}&lt;/code&gt; and multiple accepts by implementing a server as a number of worker processes doing accept on a single listening socket. Function &lt;code&gt;start/2&lt;/code&gt; takes the number of worker processes and the port number on which to listen for incoming connections. If &lt;code&gt;LPort&lt;/code&gt; is specified as &lt;code&gt;0&lt;/code&gt;, an ephemeral port number is used, which is why the start function returns the actual port number allocated:</source>
          <target state="translated">다음 예제 는 단일 청취 소켓에서 승인을 수행하는 여러 작업자 프로세스로 서버를 구현하여 옵션 &lt;code&gt;{active,once}&lt;/code&gt; 및 다중 승인의 사용을 보여줍니다 . &lt;code&gt;start/2&lt;/code&gt; 기능 은 작업자 프로세스 수와 들어오는 연결을 수신 대기하는 포트 번호를 사용합니다. 경우 &lt;code&gt;LPort&lt;/code&gt; 가 로 지정된 &lt;code&gt;0&lt;/code&gt; , 임시 포트 번호는 시작 기능이 할당 된 실제 포트 번호를 반환하는 이유입니다, 사용된다 :</target>
        </trans-unit>
        <trans-unit id="86c0c5045f0b4867ff5d5e4af410f343d35c255f" translate="yes" xml:space="preserve">
          <source>The following example is a long dialog with the shell. Commands starting with &lt;code&gt;&amp;gt;&lt;/code&gt; are inputs to the shell. All other lines are output from the shell.</source>
          <target state="translated">다음 예제는 쉘이있는 긴 대화 상자입니다. &lt;code&gt;&amp;gt;&lt;/code&gt; 로 시작하는 명령 은 쉘에 대한 입력입니다. 다른 모든 줄은 셸에서 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="10240151e7e7d2b5c92ad81d3640bc34e05d9082" translate="yes" xml:space="preserve">
          <source>The following example is more complex:</source>
          <target state="translated">다음 예제는 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="2d992e491915820ad2afb49cfea9c8e41cff67a2" translate="yes" xml:space="preserve">
          <source>The following example is useful when new object code is to be loaded on all nodes in the network, and indicates some side effects that RPCs can produce:</source>
          <target state="translated">다음 예제는 새 객체 코드가 네트워크의 모든 노드에로드 될 때 유용하며 RPC가 생성 할 수있는 부작용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1bc5ca4ed5e654ab061544449ba776cebd53a7ec" translate="yes" xml:space="preserve">
          <source>The following example selects UTF-8 as default encoding:</source>
          <target state="translated">다음 예제는 UTF-8을 기본 인코딩으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="51e5b893c5c0823be8635b7d769cf2d225ca2947" translate="yes" xml:space="preserve">
          <source>The following example shows a &quot;manual&quot; implementation of the EX1-MIB in Erlang. In this example, the values of the objects are stored in an Erlang server. The server has a 2-tuple as loop data, where the first element is the value of variable &lt;code&gt;myName&lt;/code&gt;, and the second is a sorted list of rows in the table &lt;code&gt;friendsTable&lt;/code&gt;. Each row is a 4-tuple.</source>
          <target state="translated">다음 예는 Erlang에서 EX1-MIB의 &quot;수동&quot;구현을 보여줍니다. 이 예에서 객체 값은 Erlang 서버에 저장됩니다. 서버에는 루프 데이터로 2 개의 튜플이 있으며, 첫 번째 요소는 변수 &lt;code&gt;myName&lt;/code&gt; 의 값이고 두 번째 요소는 테이블 &lt;code&gt;friendsTable&lt;/code&gt; 의 정렬 된 행 목록입니다 . 각 행은 4 개의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="0dda83918f4c357871181a8e692213f82ec6620d" translate="yes" xml:space="preserve">
          <source>The following example shows a &lt;code&gt;manager.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;manager.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3692690cff3bbc46fbe7542193823a072dbd398f" translate="yes" xml:space="preserve">
          <source>The following example shows a C program communicating with an Erlang program over a plain port with home made encoding:</source>
          <target state="translated">다음 예제는 집에서 만든 인코딩으로 일반 포트를 통해 Erlang 프로그램과 통신하는 C 프로그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4d9615b54f64438d5e8028f7a0519b6178976cdb" translate="yes" xml:space="preserve">
          <source>The following example shows a process performing a certain action, and if this action is not completed within a certain limit, the process is killed:</source>
          <target state="translated">다음 예제는 특정 조치를 수행하는 프로세스를 보여 주며이 조치가 특정 한계 내에서 완료되지 않으면 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1096089eeb70a3303a9760156d2d4be7631f7e69" translate="yes" xml:space="preserve">
          <source>The following example shows a simple pushbutton model for a toggling pushbutton implemented with &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;state_functions&lt;/code&gt;. You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on.</source>
          <target state="translated">다음 예는 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;state_functions&lt;/code&gt; 로 구현 된 토글 푸시 버튼에 대한 간단한 푸시 버튼 모델을 보여줍니다 . 버튼을 누르면 버튼이 켜지거나 꺼 졌을 때 응답하며, 버튼을 눌렀을 때 횟수를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd42ec45016c93db472143966e5ca24703f9ed4" translate="yes" xml:space="preserve">
          <source>The following example shows a simple tool for &quot;debug tracing&quot;, that is, tracing of function calls with return values:</source>
          <target state="translated">다음 예제는 &quot;디버그 추적&quot;을위한 간단한 도구, 즉 반환 값을 가진 함수 호출 추적을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="19d3f1e8b5799f072b4359cce670be47936dfd69" translate="yes" xml:space="preserve">
          <source>The following example shows a slightly different solution:</source>
          <target state="translated">다음 예제는 약간 다른 솔루션을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5d4636c02ccef3bb3a01dfd35e9b59f4a603be21" translate="yes" xml:space="preserve">
          <source>The following example shows a test suite that uses configuration functions to open and close a log file for the test cases (an operation that is unnecessary and irrelevant to perform by each test case):</source>
          <target state="translated">다음 예제는 구성 기능을 사용하여 테스트 케이스에 대한 로그 파일을 열고 닫는 테스트 스위트를 보여줍니다 (각 테스트 케이스에서 수행하지 않아도되는 조작).</target>
        </trans-unit>
        <trans-unit id="e3b94c02f704d04153b1383ced31f3788f464a7b" translate="yes" xml:space="preserve">
          <source>The following example shows a transaction that raises the salary of certain employee numbers:</source>
          <target state="translated">다음 예는 특정 직원 수의 급여를 올리는 거래를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f6d9b06dc36617a94b5e02afafc0ad8dfc4a0dad" translate="yes" xml:space="preserve">
          <source>The following example shows a valid &lt;code&gt;standard.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 유효한 &lt;code&gt;standard.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bace4401d809de6e0147dcd93d7d2ad50c7143ee" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;agent.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;agent.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="847239863685661d182c63f6a400e539c34b547a" translate="yes" xml:space="preserve">
          <source>The following example shows an Erlang program communicating with a C program over a plain port with home made encoding:</source>
          <target state="translated">다음 예는 홈 인코딩으로 일반 포트를 통해 C 프로그램과 통신하는 Erlang 프로그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="53825087d6b7108771ca3d6e0c8ef6217b528b80" translate="yes" xml:space="preserve">
          <source>The following example shows an implementation of a table which is stored in Mnesia, but with some checks performed at set-request operations.</source>
          <target state="translated">다음 예는 Mnesia에 저장되어 있지만 요청이 설정 요청 작업에서 수행되는 테이블의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="595ffdab36e0d6fd3473bedf69696fe4094f27bb" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; can be used to rename a &lt;code&gt;db_node&lt;/code&gt; in a backup file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; 을 사용하여 백업 파일에서 &lt;code&gt;db_node&lt;/code&gt; 의 이름을 바꾸는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9fa86a2eb1c462e43e94db58a5942b848857fdbd" translate="yes" xml:space="preserve">
          <source>The following example shows how a shared subterm can be created:</source>
          <target state="translated">다음 예는 공유 하위 용어를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6776554b0d8b27d6e71dbb65c3430e626c70d4bf" translate="yes" xml:space="preserve">
          <source>The following example shows how it works. Assume the following specification is in file &lt;code&gt;PrimStrings.asn1&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 작동 방식을 보여줍니다. 다음 스펙이 &lt;code&gt;PrimStrings.asn1&lt;/code&gt; 파일에 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d86195a9ba7fbeb4a3a2a88335f091528178a8bf" translate="yes" xml:space="preserve">
          <source>The following example shows how the &lt;code&gt;Erl_Interface&lt;/code&gt; library supports remote procedure calls:</source>
          <target state="translated">다음 예제는 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리가 원격 프로 시저 호출을 지원 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d2278792ed447b1b0474672cdb32370ece1d60bb" translate="yes" xml:space="preserve">
          <source>The following example shows how these tasks are performed:</source>
          <target state="translated">다음 예제는 이러한 작업이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0eb710a17335cffa4195147f0b090692db507fb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to access a record field:</source>
          <target state="translated">다음 예제는 레코드 필드에 액세스하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5dc0d07b42694dec0693419e5a61930ecf09e7b5" translate="yes" xml:space="preserve">
          <source>The following example shows how to calculate alpha blending using maps to reference color and alpha channels. Enter the code in a file named &lt;code&gt;color.erl&lt;/code&gt;):</source>
          <target state="translated">다음 예제는 맵을 사용하여 색상 및 알파 채널을 참조하는 알파 블렌딩을 계산하는 방법을 보여줍니다. &lt;code&gt;color.erl&lt;/code&gt; 파일에 코드를 입력하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c239b66af7053b04b58eb08cb9f4bfdfc1ec12a9" translate="yes" xml:space="preserve">
          <source>The following example shows how to change all letters in &lt;code&gt;L&lt;/code&gt; to upper case and then count them.</source>
          <target state="translated">다음 예는 &lt;code&gt;L&lt;/code&gt; 의 모든 문자를 대문자로 변경 한 다음 세는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a2b77ebb5034759887438d2b947908450b7a2b16" translate="yes" xml:space="preserve">
          <source>The following example shows how to find the length of a list. Enter the following code in a file named &lt;code&gt;tut4.erl&lt;/code&gt;):</source>
          <target state="translated">다음 예제는 목록의 길이를 찾는 방법을 보여줍니다. &lt;code&gt;tut4.erl&lt;/code&gt; 파일에 다음 코드를 입력하십시오 .)</target>
        </trans-unit>
        <trans-unit id="cabff7d830edf1695f519312aec99e8c8a4f83ba" translate="yes" xml:space="preserve">
          <source>The following example shows how to override properties in a scenario with deeply nested groups:</source>
          <target state="translated">다음 예제는 깊이 중첩 된 그룹이있는 시나리오에서 특성을 대체하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c2ed5f4e4ba13285a99659d63cce80153eafd62" translate="yes" xml:space="preserve">
          <source>The following example shows how to print &quot;Hello World!&quot; in 5 seconds:</source>
          <target state="translated">다음 예는 &quot;Hello World!&quot;를 인쇄하는 방법을 보여줍니다. 5 초 안에 :</target>
        </trans-unit>
        <trans-unit id="42718ac464a329f1e12022f8904c812c6a41cbb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to reconstruct Erlang source code from the debug information in a BEAM file &lt;code&gt;Beam&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 BEAM 파일 &lt;code&gt;Beam&lt;/code&gt; 의 디버그 정보에서 Erlang 소스 코드를 재구성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="36d0968402854fd2204e4f8284f220657779d484" translate="yes" xml:space="preserve">
          <source>The following example shows how to set up a trace that is automatically stopped and formatted after 5 seconds:</source>
          <target state="translated">다음 예제는 5 초 후에 자동으로 중지 및 형식화 된 추적을 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="df6f58ee5cbd6c36262b198728ebe89b5c130696" translate="yes" xml:space="preserve">
          <source>The following example shows how to start an event manager and add an event handler to it by using the shell:</source>
          <target state="translated">다음 예제는 쉘을 사용하여 이벤트 관리자를 시작하고 이벤트 핸들러를 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5fc528ca550abf4d7a434c41bd619acd146ef168" translate="yes" xml:space="preserve">
          <source>The following example shows how to update a record:</source>
          <target state="translated">다음 예제는 레코드를 업데이트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cbb352e84c7618cb263e59542ab972df29182936" translate="yes" xml:space="preserve">
          <source>The following example shows that the guard succeeds if &lt;code&gt;P&lt;/code&gt; is record of type &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">다음 예는 &lt;code&gt;P&lt;/code&gt; 가 &lt;code&gt;person&lt;/code&gt; 유형의 레코드 인 경우 가드가 성공 함을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c27427b8d967e296729a0172b87b5c1cb7821f6e" translate="yes" xml:space="preserve">
          <source>The following example shows the basic use of &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell. Default options are used both for starting the tracer and for formatting (the custom fetch directory is however provided). This gives a trace log named &lt;code&gt;Node-ttb&lt;/code&gt; in the newly created directory, where &lt;code&gt;Node&lt;/code&gt; is the node name. The default handler prints the formatted trace messages in the shell:</source>
          <target state="translated">다음 예는 Erlang 쉘에서 &lt;code&gt;ttb&lt;/code&gt; 의 기본 사용법을 보여줍니다 . 기본 옵션은 추적 프로그램 시작 및 형식화에 모두 사용됩니다 (그러나 사용자 정의 페치 디렉토리가 제공됨). 이것은 새로 작성된 디렉토리에 &lt;code&gt;Node-ttb&lt;/code&gt; 라는 추적 로그를 제공합니다 . 여기서 &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본 핸들러는 형식화 된 추적 메시지를 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="33c400b4d7bc90cf1fb4285d622a80e1394cc3a9" translate="yes" xml:space="preserve">
          <source>The following example shows the reports generated when a process crashes. The example process is a &lt;code&gt;permanent&lt;/code&gt; process supervised by the &lt;code&gt;test_sup&lt;/code&gt; supervisor. A division by zero is executed and the error is first reported by the faulty process. A crash report is generated, as the process was started using function &lt;code&gt;proc_lib:spawn/3&lt;/code&gt;. The supervisor generates a supervisor report showing the crashed process. A progress report is generated when the process is finally restarted.</source>
          <target state="translated">다음 예는 프로세스가 충돌 할 때 생성 된 보고서를 보여줍니다. 예제 프로세스는 &lt;code&gt;test_sup&lt;/code&gt; 감독자가 감독 하는 &lt;code&gt;permanent&lt;/code&gt; 프로세스 입니다. 0으로 나누기가 실행되고 오류는 먼저 잘못된 프로세스에 의해보고됩니다. &lt;code&gt;proc_lib:spawn/3&lt;/code&gt; 함수를 사용하여 프로세스가 시작되면 충돌 보고서가 생성됩니다 . 수퍼바이저는 충돌 된 프로세스를 표시하는 수퍼바이저 보고서를 생성합니다. 프로세스가 마지막으로 다시 시작되면 진행률 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="862f8553aec4c38b6ab11aac95b152a39de64479" translate="yes" xml:space="preserve">
          <source>The following example successfully constructs a bitstring of 7 bits, provided that all of X and Y are integers:</source>
          <target state="translated">다음 예제는 X와 Y가 모두 정수인 경우 7 비트의 비트 열을 성공적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b791c8b4e90272c4405c7aeae4b46da3f6bb6c8f" translate="yes" xml:space="preserve">
          <source>The following example test suite shows some tests of a database server:</source>
          <target state="translated">다음 테스트 스위트 예제는 데이터베이스 서버의 일부 테스트를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b6d5422eedcad9f5caa434fa7b207125a77682b5" translate="yes" xml:space="preserve">
          <source>The following example uses an explicit match specification to traverse the table:</source>
          <target state="translated">다음 예제는 명시 적 일치 스펙을 사용하여 테이블을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="03a4faf8451b45afff5a5b66483b40e3d0740248" translate="yes" xml:space="preserve">
          <source>The following example was run on OTP/R8 on Solaris 8, all OTP internals in this example are very version dependent.</source>
          <target state="translated">다음 예는 Solaris 8의 OTP / R8에서 실행되었으며이 예의 모든 OTP 내부는 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="46aa402444b6b984aa7f78159a16377f4c23a61a" translate="yes" xml:space="preserve">
          <source>The following example would match a simple Erlang integer or float and return a token which could be sent to the Erlang parser:</source>
          <target state="translated">다음 예제는 간단한 Erlang 정수 또는 float과 일치하여 Erlang 파서로 보낼 수있는 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0171fcebc0acc5e68cccfc60c0381e6097256" translate="yes" xml:space="preserve">
          <source>The following examples assume that the current directory is the top of an Erlang/OTP installation.</source>
          <target state="translated">다음 예는 현재 디렉토리가 Erlang / OTP 설치의 최상위 디렉토리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9e3429edd1596d9bb7aa13fb024e8021be184516" translate="yes" xml:space="preserve">
          <source>The following examples define simplified versions of a few Erlang data types:</source>
          <target state="translated">다음 예제는 몇 가지 Erlang 데이터 유형의 단순화 된 버전을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f8bd6a0797d263a055952885390142cbff7bc575" translate="yes" xml:space="preserve">
          <source>The following examples illustrate a function that returns an error, and the method to retrieve more detailed error information:</source>
          <target state="translated">다음 예제는 오류를 반환하는 함수와보다 자세한 오류 정보를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="02e03cbd265b56591c07a5d42abac6e2a5b935ba" translate="yes" xml:space="preserve">
          <source>The following examples illustrate how binaries are constructed, or matched, and how elements and tails are specified.</source>
          <target state="translated">다음 예제는 바이너리가 구성되거나 일치되는 방법과 요소 및 꼬리가 지정되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8d07d5eba80d244e874b251ee11faf436794868c" translate="yes" xml:space="preserve">
          <source>The following examples illustrate these rules:</source>
          <target state="translated">다음 예제는 이러한 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f52213112fefdbc53dc8c9767c67e39d0c5dce9" translate="yes" xml:space="preserve">
          <source>The following examples show a dialogue with the Erlang shell. All the higher order functions discussed are exported from the module &lt;code&gt;lists&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 Erlang 쉘과의 대화를 보여줍니다. 논의 된 모든 고차 함수는 모듈 &lt;code&gt;lists&lt;/code&gt; 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="4e3ffd9c68f42312446cc6dbf3d84bd42d447765" translate="yes" xml:space="preserve">
          <source>The following examples show parsers of the following type:</source>
          <target state="translated">다음 예제는 다음 유형의 구문 분석기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18a677a2dd5f46875b6af8f8c34c6eb70fbe49be" translate="yes" xml:space="preserve">
          <source>The following examples show the resulting C programs. First a C node server using short node names:</source>
          <target state="translated">다음 예제는 결과 C 프로그램을 보여줍니다. 먼저 짧은 노드 이름을 사용하는 C 노드 서버 :</target>
        </trans-unit>
        <trans-unit id="379499ad8751de711870d7f29677a3a780a463f0" translate="yes" xml:space="preserve">
          <source>The following examples show the two startup options:</source>
          <target state="translated">다음 예제는 두 가지 시작 옵션을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f2e4438a8f07510d88683d4b04f8f84085bdfc63" translate="yes" xml:space="preserve">
          <source>The following examples use the utility function &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; to start all needed applications (&lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;). All examples are run in an Erlang shell, or in a bash shell, using &lt;strong&gt;openssh&lt;/strong&gt; to illustrate how the &lt;code&gt;ssh&lt;/code&gt; application can be used. The examples are run as the user &lt;code&gt;otptest&lt;/code&gt; on a local network where the user is authorized to log in over &lt;code&gt;ssh&lt;/code&gt; to the host &lt;strong&gt;tarlop&lt;/strong&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; 유틸리티 기능을 사용하여 필요한 모든 애플리케이션 ( &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; ) 을 시작합니다 . 모든 예제는 &lt;code&gt;ssh&lt;/code&gt; 애플리케이션 사용 방법을 설명하기 위해 &lt;strong&gt;openssh&lt;/strong&gt; 를 사용하여 Erlang 쉘 또는 bash 쉘에서 실행 됩니다. 예제는 사용자가 &lt;code&gt;ssh&lt;/code&gt; 를 통해 호스트 &lt;strong&gt;tarlop&lt;/strong&gt; 에 로그인 할 수있는 권한이 부여 된 로컬 네트워크에서 &lt;code&gt;otptest&lt;/code&gt; 사용자로 실행됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cd0b11976b5319f2006d2a53413541627fed4ce" translate="yes" xml:space="preserve">
          <source>The following executes &lt;code&gt;tc12&lt;/code&gt;&lt;strong&gt;only&lt;/strong&gt; in group &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">다음이 실행은 &lt;code&gt;tc12&lt;/code&gt; &lt;strong&gt;에만&lt;/strong&gt; 그룹에서 &lt;code&gt;top1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88857e0adb91607265c1fd3c40132140d6d97f6c" translate="yes" xml:space="preserve">
          <source>The following executes one test for all cases and subgroups under &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;top1&lt;/code&gt; 아래의 모든 케이스 및 하위 그룹에 대해 하나의 테스트를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="25e14a4c0f0dd8657c260321ddf24593cbf2714d" translate="yes" xml:space="preserve">
          <source>The following executes only the test cases for &lt;code&gt;sub22&lt;/code&gt; and in reverse order compared to the group definition:</source>
          <target state="translated">다음은 그룹 정의와 비교하여 &lt;code&gt;sub22&lt;/code&gt; 의 테스트 케이스 만 역순으로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9d59ae5da72969b4283c1cf98a39c82e69b73434" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one for all cases and all subgroups under &lt;code&gt;top1&lt;/code&gt;, and one for all under &lt;code&gt;top2&lt;/code&gt;:</source>
          <target state="translated">다음의 두 가지 테스트가 실행하는 모든 경우에 대해 하나 및 아래에있는 모든 서브 그룹 &lt;code&gt;top1&lt;/code&gt; 및 아래 모두 하나 &lt;code&gt;top2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88efd1d16122c7dfa20482784039de0e7578cec9" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one including all cases and subgroups under &lt;code&gt;sub12&lt;/code&gt;, and one with &lt;strong&gt;only&lt;/strong&gt; the test cases in &lt;code&gt;sub12&lt;/code&gt;:</source>
          <target state="translated">다음의 두 가지 테스트가 실행하는 모든 경우 미만 서브 그룹을 포함하는 하나 &lt;code&gt;sub12&lt;/code&gt; 및 하나 &lt;strong&gt;에서만&lt;/strong&gt; 의 테스트 케이스 &lt;code&gt;sub12&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a7ba64d043b7996c073a0f4af0d073005f423a1" translate="yes" xml:space="preserve">
          <source>The following expression creates a new &lt;code&gt;Name&lt;/code&gt; record where the value of each field &lt;code&gt;FieldI&lt;/code&gt; is the value of evaluating the corresponding expression &lt;code&gt;ExprI&lt;/code&gt;:</source>
          <target state="translated">다음 표현식은 각 필드 &lt;code&gt;FieldI&lt;/code&gt; 의 값이 해당 표현식 &lt;code&gt;ExprI&lt;/code&gt; 를 평가하는 값인 새 &lt;code&gt;Name&lt;/code&gt; 레코드를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ae6de457c01e1fb1a3e00546eff8958609de12b0" translate="yes" xml:space="preserve">
          <source>The following expression returns the position of the specified field in the tuple representation of the record:</source>
          <target state="translated">다음 표현식은 레코드의 튜플 표현에서 지정된 필드의 위치를 ​​리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c58518dfed86937c32c0b6a021322cd7beecbd65" translate="yes" xml:space="preserve">
          <source>The following expression yields &lt;code&gt;true&lt;/code&gt;::</source>
          <target state="translated">다음 식을 얻을 수 &lt;code&gt;true&lt;/code&gt; ::</target>
        </trans-unit>
        <trans-unit id="dd1a2e6659306c0be27370e1c7239f7c64f5c457" translate="yes" xml:space="preserve">
          <source>The following expressions are translated equally:</source>
          <target state="translated">다음 표현식은 동일하게 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="f600fa95580d128a5b55c2d2a3bd52715c966b7f" translate="yes" xml:space="preserve">
          <source>The following expressions yield &lt;code&gt;false&lt;/code&gt;, as variable &lt;code&gt;Broken&lt;/code&gt; contains a compiled match specification that has passed through external representation:</source>
          <target state="translated">다음 변수는 &lt;code&gt;Broken&lt;/code&gt; 변수에 외부 표현을 통과 한 컴파일 된 일치 스펙이 포함 되므로 &lt;code&gt;false&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b9eb1676778caddf159cfe9acf52d248a3850a31" translate="yes" xml:space="preserve">
          <source>The following fapply:</source>
          <target state="translated">다음과 같은 일이 일어납니다 :</target>
        </trans-unit>
        <trans-unit id="f3d7d3c3deb0a0a629d81950bc6b6134511197b1" translate="yes" xml:space="preserve">
          <source>The following fields are not described in the ERTS User's Guide:</source>
          <target state="translated">다음 필드는 ERTS 사용 설명서에 설명되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61d54bcd350d6740f125ef1579264955f1c65547" translate="yes" xml:space="preserve">
          <source>The following fields are used from the record, if they are specified:</source>
          <target state="translated">다음 필드는 지정된 경우 레코드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="579212e906c367c5e65524f9d589806b1a4dfd60" translate="yes" xml:space="preserve">
          <source>The following fields can exist for a process:</source>
          <target state="translated">프로세스에 대해 다음 필드가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cec82fe0d57eb1d23921e0d50a78837999069a1" translate="yes" xml:space="preserve">
          <source>The following fields typically must be specified by the sender:</source>
          <target state="translated">다음 필드는 일반적으로 발신자가 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="08329a98a990baea9fd4cf44d504f845faefdaf6" translate="yes" xml:space="preserve">
          <source>The following figure shows a conceptual overview of Logger. The figure shows two log handlers, but any number of handlers can be installed.</source>
          <target state="translated">다음 그림은 로거의 개념 개요를 보여줍니다. 이 그림은 두 개의 로그 처리기를 보여 주지만 원하는 수의 처리기를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bef9dc10cd953efe4cb861873187dfba852609d" translate="yes" xml:space="preserve">
          <source>The following figure shows the bytes of a &lt;code&gt;Window:status&lt;/code&gt; message. The components &lt;code&gt;buttonList&lt;/code&gt; and &lt;code&gt;actions&lt;/code&gt; are excluded from decode. Only &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt; are decoded when &lt;code&gt;decode__Window_exclusive&lt;/code&gt; is called.</source>
          <target state="translated">다음 그림은 &lt;code&gt;Window:status&lt;/code&gt; 메시지 의 바이트를 보여줍니다 . 구성 요소 &lt;code&gt;buttonList&lt;/code&gt; 및 &lt;code&gt;actions&lt;/code&gt; 은 디코딩에서 제외됩니다. 만 &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;enabled&lt;/code&gt; 되면 디코드 &lt;code&gt;decode__Window_exclusive&lt;/code&gt; 가 호출된다.</target>
        </trans-unit>
        <trans-unit id="5e130f9f78c1692a150e4f0eeb068783cb173914" translate="yes" xml:space="preserve">
          <source>The following figure shows which components are in &lt;code&gt;TypeList&lt;/code&gt;&lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;:</source>
          <target state="translated">다음 그림은 &lt;code&gt;TypeList&lt;/code&gt; &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 에 있는 구성 요소를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b445689ad7fd0436cd7641f643a07c0561a2fe9a" translate="yes" xml:space="preserve">
          <source>The following file includes two certificates:</source>
          <target state="translated">다음 파일에는 두 가지 인증서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db502e7fd49532c31554150f0c64ab687cd78ab" translate="yes" xml:space="preserve">
          <source>The following file types are defined in Erlang/OTP:</source>
          <target state="translated">Erlang / OTP에는 다음과 같은 파일 형식이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="71254e9506c929f7f52ca316b3c356b831887b19" translate="yes" xml:space="preserve">
          <source>The following flags are available:</source>
          <target state="translated">다음과 같은 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719ce2e093c09df2408e42a7406958a700ac71ea" translate="yes" xml:space="preserve">
          <source>The following flags are defined automatically and can be retrieved using this function:</source>
          <target state="translated">다음 플래그는 자동으로 정의되며이 기능을 사용하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe356642f0df6916029c9299326bc02952f156d" translate="yes" xml:space="preserve">
          <source>The following flags are recognised:</source>
          <target state="translated">다음과 같은 플래그가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="2791d823738fc796e3aff5cac56fe1c0dc58c276" translate="yes" xml:space="preserve">
          <source>The following flags are supported:</source>
          <target state="translated">다음과 같은 플래그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9a37b4b5f5db6694294b80fe420424b434a55049" translate="yes" xml:space="preserve">
          <source>The following flags are useful in special situations, such as rebuilding the OTP system:</source>
          <target state="translated">다음 플래그는 OTP 시스템 재 구축과 같은 특수 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e3e7ff31b4722f8ae27b4760d8e2609571bf918c" translate="yes" xml:space="preserve">
          <source>The following flags can also be used with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 과 함께 다음 플래그를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe0b90a260b51ac7fbb2626eba5e49455fbc6475" translate="yes" xml:space="preserve">
          <source>The following four installation procedures require super user privilege:</source>
          <target state="translated">다음 4 가지 설치 절차에는 수퍼 유저 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="857a38dd46b2870a572b2281f80d819712f630b7" translate="yes" xml:space="preserve">
          <source>The following fun expressions are also allowed:</source>
          <target state="translated">다음과 같은 재미있는 표현도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e53e9cb8d584334c556a4497982894d55fd0779" translate="yes" xml:space="preserve">
          <source>The following function extracts a list of female employees from the database:</source>
          <target state="translated">다음 함수는 데이터베이스에서 여성 직원 목록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="504f3189fc42a4b1e4cebcb03cdadcfe20e2ff16" translate="yes" xml:space="preserve">
          <source>The following function extracts the names of the female employees stored in the database:</source>
          <target state="translated">다음 함수는 데이터베이스에 저장된 여성 직원의 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e7ccfae3bc62070f3a6d6f25984d604af2dca20b" translate="yes" xml:space="preserve">
          <source>The following function must be exported from a &lt;code&gt;supervisor&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;supervisor&lt;/code&gt; 콜백 모듈 에서 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="07aad394cfc87e43c34047ccb79c6f62e522e12b" translate="yes" xml:space="preserve">
          <source>The following function takes a list of &lt;code&gt;person&lt;/code&gt; records and searches for the phone number of a person with a particular name:</source>
          <target state="translated">다음 기능은 &lt;code&gt;person&lt;/code&gt; 레코드 목록을 가져와 특정 이름을 가진 사람의 전화 번호를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d42b26451a776d64cc4668a7081444af7e2c2a1e" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;add_one&lt;/code&gt;, adds one to every element in a list:</source>
          <target state="translated">&lt;code&gt;add_one&lt;/code&gt; 함수 는 목록의 모든 요소에 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdcde9b058d15df816f05ecda9bd41f522994a81" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;double&lt;/code&gt;, doubles every element in a list:</source>
          <target state="translated">다음 &lt;code&gt;double&lt;/code&gt; 함수 는 목록의 모든 요소를 ​​두 배로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="4a3f4a02410e47e9c3849742c5727d2c0861cf66" translate="yes" xml:space="preserve">
          <source>The following functionally equivalent code writes 128 bytes per call to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; and so does the same work in 0.08 seconds, which is roughly 30 times faster:</source>
          <target state="translated">다음과 같은 기능적으로 동등한 코드는 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 에 대한 호출 당 128 바이트를 작성 하므로 0.08 초 안에 동일한 작업을 수행하므로 약 30 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4851a85cacd7cea8fbbb07ff6c65612ebb17807b" translate="yes" xml:space="preserve">
          <source>The following functions are exported by the generated scanner.</source>
          <target state="translated">생성 된 스캐너에서 다음 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5f67bcd3deeb0c90fe208811b94f6ecb50fdd70e" translate="yes" xml:space="preserve">
          <source>The following functions are inlined:</source>
          <target state="translated">다음 기능이 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8f6071853dc23038c690be527eb7aed97d99f5" translate="yes" xml:space="preserve">
          <source>The following functions are mandatory:</source>
          <target state="translated">다음 기능은 필수입니다 :</target>
        </trans-unit>
        <trans-unit id="6ab66b86479cb4b8966432e55db73f7b8eac0221" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_event&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_event&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="eaf6f53e0685fd921f6065ec533398767638e814" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_server&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_server&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="baab9084b49f784e0a7049c6d9a71e4b999906d7" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_statem&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_statem&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="f6d8fd0dedca27c09b82ec5cdf80b62654de4c23" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_client_channel&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;ssh_client_channel&lt;/code&gt; 콜백 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b8fd8927d0a9812c875db0dd32e79d269aceb81c" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_server_channel&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;ssh_server_channel&lt;/code&gt; 콜백 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e23fa44c13429a2fd437dba0988c988e7a312614" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a formatter callback module.</source>
          <target state="translated">다음 함수는 포맷터 콜백 모듈에서 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f3a0c7ead32b20d4fc3d927da2c12376abf896b9" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a handler callback module.</source>
          <target state="translated">다음 함수는 핸들러 콜백 모듈에서 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="324102d29dfa0e459c285f94eb4c3c3798cd41d3" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;application&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;application&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="623497a405a43189792a81522e86a8b9226d067f" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;erl_tracer&lt;/code&gt; callback module:</source>
          <target state="translated">다음 함수는 &lt;code&gt;erl_tracer&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="64dc45bde2a752b8cec35e2e33de402f72f6cc40" translate="yes" xml:space="preserve">
          <source>The following functions are used for convenience.</source>
          <target state="translated">편의를 위해 다음 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c872bca07adade7d8cc574c2485887affd6e5d83" translate="yes" xml:space="preserve">
          <source>The following functions are used to back up data, to install a backup as fallback, and for disaster recovery:</source>
          <target state="translated">다음 기능은 데이터를 백업하고 폴백으로 백업을 설치하고 재해 복구에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02628df42092a5c994d8e891c4403f91bfbbbb66" translate="yes" xml:space="preserve">
          <source>The following functions are used when implementing a special process. This is an ordinary process, which does not use a standard behavior, but a process that understands the standard system messages.</source>
          <target state="translated">특수 프로세스를 구현할 때 다음 기능이 사용됩니다. 이는 표준 동작을 사용하지 않고 표준 시스템 메시지를 이해하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="26b92712bb4c99562ee4a3caab022028754f5836" translate="yes" xml:space="preserve">
          <source>The following functions can be used to test upgrade and downgrade of single applications (instead of upgrading/downgrading an entire release). A script corresponding to the instructions in the &lt;code&gt;relup&lt;/code&gt; file is created on-the-fly, based on the &lt;code&gt;.appup&lt;/code&gt; file for the application, and evaluated exactly in the same way as &lt;code&gt;release_handler&lt;/code&gt; does.</source>
          <target state="translated">전체 릴리스를 업그레이드 / 다운 그레이드하는 대신 단일 기능의 업그레이드 및 다운 그레이드를 테스트하는 데 다음 기능을 사용할 수 있습니다. &lt;code&gt;relup&lt;/code&gt; 파일 의 명령어에 해당하는 스크립트 는 응용 프로그램 의 &lt;code&gt;.appup&lt;/code&gt; 파일을 기반으로 즉석에서 작성 되며 &lt;code&gt;release_handler&lt;/code&gt; 와 동일한 방식으로 정확하게 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="24d76d64ddf59c8af9a65858beb15de37d52e968" translate="yes" xml:space="preserve">
          <source>The following functions control the behavior of the internal counters.</source>
          <target state="translated">다음 기능은 내부 카운터의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c8f7d8e59ac7e38340a3c25c101d522f5875e82c" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a CTH.</source>
          <target state="translated">다음 함수는 CTH에 대한 콜백 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02a00b734983835a88dfd4ba08c110451f346e89" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a test suite.</source>
          <target state="translated">다음 함수는 테스트 스위트의 콜백 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="647d81b837420325efd90808d2b34ee3893c58a1" translate="yes" xml:space="preserve">
          <source>The following functions describe the interface to &lt;code&gt;snmpa_local_db&lt;/code&gt;. Each function has a Mnesia equivalent. The argument &lt;code&gt;NameDb&lt;/code&gt; is a tuple &lt;code&gt;{Name, Db}&lt;/code&gt; where &lt;code&gt;Name&lt;/code&gt; is the symbolic name of the managed object (as defined in the MIB), and &lt;code&gt;Db&lt;/code&gt; is either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;persistent&lt;/code&gt;. &lt;code&gt;mnesia&lt;/code&gt; is not possible since all these functions are &lt;code&gt;snmpa_local_db&lt;/code&gt; specific.</source>
          <target state="translated">다음 함수는 &lt;code&gt;snmpa_local_db&lt;/code&gt; 에 대한 인터페이스를 설명합니다 . 각 기능에는 Mnesia 기능이 있습니다. &lt;code&gt;NameDb&lt;/code&gt; 인수 는 튜플 &lt;code&gt;{Name, Db}&lt;/code&gt; 이며 , 여기서 &lt;code&gt;Name&lt;/code&gt; 은 MIB에 정의 된대로 관리 오브젝트의 기호 이름이며 &lt;code&gt;Db&lt;/code&gt; 는 &lt;code&gt;volatile&lt;/code&gt; 이거나 &lt;code&gt;persistent&lt;/code&gt; 입니다. &lt;code&gt;mnesia&lt;/code&gt; 는 이러한 모든 기능이기 때문에 가능하지 않다 &lt;code&gt;snmpa_local_db&lt;/code&gt; 특정.</target>
        </trans-unit>
        <trans-unit id="a1100a11b4b80e1ec32b674331fc67603b3198a3" translate="yes" xml:space="preserve">
          <source>The following functions in this module also exist and provides the same functionality in the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; modules. That is, by only changing the module name for each call, you can try out different set representations.</source>
          <target state="translated">이 모듈에는 다음 기능도 있으며 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 모듈 에서 동일한 기능을 제공합니다 . 즉, 각 호출에 대한 모듈 이름 만 변경하여 다른 세트 표현을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403a88e7d4193643f2441bbe4104eef783bcc30f" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;mib-server&lt;/code&gt; data callback module:</source>
          <target state="translated">&lt;code&gt;mib-server&lt;/code&gt; 데이터 콜백 모듈 에서 다음 함수를 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="211427edb5cce5619a96cf4257a0132f6686ca2a" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;supervisor_bridge&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;supervisor_bridge&lt;/code&gt; 콜백 모듈 에서 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e7c33747a8a7210784ba4d3e34376c30cdfd02d" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_edist_compress&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_edist_compress&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c2eb550d5e0fd353c08fabab97a3148ca0012e2" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_encoder&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_encoder&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="36e94e447d27f2ba2ddd7dbee957d9efa47d84bf" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_transport&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_transport&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="f8ee1e36bf47047325c371be3bfaa01a6b15fc9a" translate="yes" xml:space="preserve">
          <source>The following functions, &lt;code&gt;read_cmd()&lt;/code&gt; and &lt;code&gt;write_cmd()&lt;/code&gt;, from the &lt;code&gt;erl_comm.c&lt;/code&gt; example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; can still be used for reading from and writing to the port:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;erl_comm.c&lt;/code&gt; 예제에서 &lt;code&gt;read_cmd()&lt;/code&gt; 및 &lt;code&gt;write_cmd()&lt;/code&gt; 함수를 사용하여 포트에서 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0cc9a33559cd30dd7c5dee49a32a3678fc0996" translate="yes" xml:space="preserve">
          <source>The following general category property codes are supported:</source>
          <target state="translated">다음과 같은 일반 카테고리 특성 코드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="00b20eb40ed0d659393e7ede6b8509b03c2165e1" translate="yes" xml:space="preserve">
          <source>The following illustration shows how a system can look in runtime.</source>
          <target state="translated">다음 그림은 시스템이 런타임에서 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d0fc102c368e541c6de8ef4f6fd846441148303d" translate="yes" xml:space="preserve">
          <source>The following information is given for each child specification/process:</source>
          <target state="translated">각 하위 사양 / 프로세스에 대해 다음 정보가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0cce2ff92e643403b8a8a43b7b39a2cc520dd904" translate="yes" xml:space="preserve">
          <source>The following information is returned for every application:</source>
          <target state="translated">모든 응용 프로그램에 대해 다음 정보가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b3fbdd770d4e0e0bb91f42f7653cca9a0fa8d845" translate="yes" xml:space="preserve">
          <source>The following information is returned for every library module:</source>
          <target state="translated">모든 라이브러리 모듈에 대해 다음 정보가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b25c49ec2d0414911fc31e80509041b6c00e1677" translate="yes" xml:space="preserve">
          <source>The following information is returned for every release:</source>
          <target state="translated">모든 릴리스에 대해 다음 정보가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e22fc9271f190429a4be85a97f17d1b778ca80" translate="yes" xml:space="preserve">
          <source>The following instructions are for building &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 지침은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt; 을 제작 하기 위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9bb6feade4582730097dc79e92bae679305ea48e" translate="yes" xml:space="preserve">
          <source>The following is a checklist for rewriting a pre ERTS 5.9 driver, most important first:</source>
          <target state="translated">다음은 가장 중요한 첫 번째 ERTS 5.9 드라이버를 다시 작성하기위한 점검 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3b1759541f1940201849307e8f98dd17638ad123" translate="yes" xml:space="preserve">
          <source>The following is a complete &lt;code&gt;Fun&lt;/code&gt; parameter for reading and writing on files using the &lt;code&gt;file&lt;/code&gt; module:</source>
          <target state="translated">다음은 &lt;code&gt;file&lt;/code&gt; 모듈을 사용하여 파일 을 읽고 쓰는 데 사용 되는 완전한 &lt;code&gt;Fun&lt;/code&gt; 매개 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="fc7d7129dd6f6c58173a187543c25f188276eaf0" translate="yes" xml:space="preserve">
          <source>The following is a complete list of event types and where they come from:</source>
          <target state="translated">다음은 이벤트 유형의 전체 목록과 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c8a14f55bfff88da1be28bb766800640bcd62c50" translate="yes" xml:space="preserve">
          <source>The following is a list of the ANSI data types. For details turn to the ANSI standard documentation. Usage of other data types is of course possible, but you should be aware that this makes your application dependent on the database you are using at the moment.</source>
          <target state="translated">다음은 ANSI 데이터 유형의 목록입니다. 자세한 내용은 ANSI 표준 설명서를 참조하십시오. 다른 데이터 유형의 사용은 물론 가능하지만 이로 인해 현재 사용중인 데이터베이스에 따라 응용 프로그램이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="9dffda4d1a563c216467972b2fef4d25fa28c442" translate="yes" xml:space="preserve">
          <source>The following is a rather unnatural example to show another exception:</source>
          <target state="translated">다음은 또 다른 예외를 보여주는 다소 부 자연스러운 예입니다.</target>
        </trans-unit>
        <trans-unit id="fc5496457b8761bac15ca387a14c23e2f06d56e0" translate="yes" xml:space="preserve">
          <source>The following is a shell session when running it:</source>
          <target state="translated">다음은 실행시 쉘 세션입니다.</target>
        </trans-unit>
        <trans-unit id="1c1afe341a3a40e5c215a483f55d3776b92db0f3" translate="yes" xml:space="preserve">
          <source>The following is a short program to show the workings of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;if&lt;/code&gt; 의 작동을 보여주는 간단한 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="92e3b552e54cc6f54aad0df369b0b7192bcf382d" translate="yes" xml:space="preserve">
          <source>The following is a simple example of an FTP session, where the user &lt;code&gt;guest&lt;/code&gt; with password &lt;code&gt;password&lt;/code&gt; logs on to the remote host &lt;code&gt;erlang.org&lt;/code&gt;:</source>
          <target state="translated">다음은 FTP 비밀번호 의 간단한 예입니다. 비밀번호 &lt;code&gt;password&lt;/code&gt; 가있는 사용자 &lt;code&gt;guest&lt;/code&gt; 가 원격 호스트 &lt;code&gt;erlang.org&lt;/code&gt; 에 로그온합니다 .</target>
        </trans-unit>
        <trans-unit id="af00308e7be83b75dde0c794afc64df924d05311" translate="yes" xml:space="preserve">
          <source>The following is a simpler example of a handler which logs to a file through one single process:</source>
          <target state="translated">다음은 하나의 단일 프로세스를 통해 파일에 로그하는 처리기의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="2985e72c56df70fad7f40fc868951b90ac475392" translate="yes" xml:space="preserve">
          <source>The following is a slightly more complicated example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; providing one key for module &lt;code&gt;t&lt;/code&gt; and another key for all other modules:</source>
          <target state="translated">다음은 모듈 &lt;code&gt;t&lt;/code&gt; 에 대한 하나의 키 와 다른 모든 모듈에 대한 다른 키를 제공 하는 &lt;code&gt;.erlang.crypt&lt;/code&gt; 의 약간 더 복잡한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c2e759eba9876095f44fce0efab73cd548a24130" translate="yes" xml:space="preserve">
          <source>The following is a template example of how to create and return a resource object.</source>
          <target state="translated">다음은 자원 객체를 생성하고 반환하는 방법에 대한 템플릿 예입니다.</target>
        </trans-unit>
        <trans-unit id="407235d853511b8f33bb270ef89fc50a0d62af2a" translate="yes" xml:space="preserve">
          <source>The following is an easy way of obtaining a unique value to seed with:</source>
          <target state="translated">다음은 시드 할 고유 한 값을 얻는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="559fe21097f15ddc3169882128ef5ed665f04654" translate="yes" xml:space="preserve">
          <source>The following is an example module to trace on:</source>
          <target state="translated">다음은 추적 할 예제 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="80aa757f4a9a7af17950895f0cec0bc27ec18d99" translate="yes" xml:space="preserve">
          <source>The following is an example of Erlang code that assigns values for the types in the previous list:</source>
          <target state="translated">다음은 이전 목록의 유형에 값을 지정하는 Erlang 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="d01528f16015b5f29f1097c6ec1da0702097e439" translate="yes" xml:space="preserve">
          <source>The following is an example of X509 certificates:</source>
          <target state="translated">다음은 X509 인증서의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b27cba48368a69cfcb442391037a03176a6a6532" translate="yes" xml:space="preserve">
          <source>The following is an example of a callback module for a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor:</source>
          <target state="translated">다음은 &lt;code&gt;simple_one_for_one&lt;/code&gt; 수퍼바이저에 대한 콜백 모듈의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1f30318b19c32d664f2f54026ca7ff0b8355f643" translate="yes" xml:space="preserve">
          <source>The following is an example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; file that returns the same key for all modules:</source>
          <target state="translated">다음은 모든 모듈에 대해 동일한 키를 반환 하는 &lt;code&gt;.erlang.crypt&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="beaf428bf8cc669201276ed3d29a25f483cbffc1" translate="yes" xml:space="preserve">
          <source>The following is an example of how the functions in the previous example can be rewritten if it is necessary to open multiple connections to the FTP server:</source>
          <target state="translated">다음은 FTP 서버에 대한 여러 연결을 열어야하는 경우 이전 예의 기능을 다시 작성할 수있는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7f7272e68f14b299a421c24c15d68c41acc39f20" translate="yes" xml:space="preserve">
          <source>The following is an example of how to assert that the configuration data is available and can be used for an FTP session:</source>
          <target state="translated">다음은 구성 데이터가 사용 가능하고 FTP 세션에 사용될 수 있는지 확인하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="006f54e284f6eaf59f32808c04b6087a85040dff" translate="yes" xml:space="preserve">
          <source>The following is an example of how to return the status from a group:</source>
          <target state="translated">다음은 그룹에서 상태를 반환하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="de8c4707aa64df488804045d788d163861ba1459" translate="yes" xml:space="preserve">
          <source>The following is an example session using it on Linux:</source>
          <target state="translated">다음은 Linux에서이를 사용하는 예제 세션입니다.</target>
        </trans-unit>
        <trans-unit id="22fa03b054cca550539d61bd30740fe445725fe1" translate="yes" xml:space="preserve">
          <source>The following is an ordinary asynchronous request:</source>
          <target state="translated">다음은 일반적인 비동기 요청입니다.</target>
        </trans-unit>
        <trans-unit id="1617114c5fde90021a15fd0405960852bae70f6c" translate="yes" xml:space="preserve">
          <source>The following is an ordinary synchronous request:</source>
          <target state="translated">다음은 일반적인 동기 요청입니다.</target>
        </trans-unit>
        <trans-unit id="25cf5f91df4951ef8502f305f460dc3e467e107b" translate="yes" xml:space="preserve">
          <source>The following is another special sequence that can appear at the start of a pattern:</source>
          <target state="translated">다음은 패턴의 시작 부분에 나타날 수있는 또 다른 특수 순서입니다.</target>
        </trans-unit>
        <trans-unit id="25f3a545690924d83cc64312bc56248e3f69655a" translate="yes" xml:space="preserve">
          <source>The following is called when the application is stopped.</source>
          <target state="translated">응용 프로그램이 중지되면 다음이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bb8990a6d72dd204c6cca6df9719f6eb039d12" translate="yes" xml:space="preserve">
          <source>The following is the complete callback module file &lt;code&gt;pushbutton.erl&lt;/code&gt;:</source>
          <target state="translated">다음은 완전한 콜백 모듈 파일 &lt;code&gt;pushbutton.erl&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="eba1404bcd0f1c2d40b6a68a0e51cd8231cb108f" translate="yes" xml:space="preserve">
          <source>The following is the instruction for adding an application:</source>
          <target state="translated">다음은 응용 프로그램을 추가하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="eef8732ed7e4037c0a3fb4336a9e4dba89b8f906" translate="yes" xml:space="preserve">
          <source>The following is the instruction for removing an application:</source>
          <target state="translated">다음은 응용 프로그램을 제거하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="314b2a42ea1284b836958c707ebdeebfb1e761a9" translate="yes" xml:space="preserve">
          <source>The following is the instruction for restarting an application:</source>
          <target state="translated">다음은 응용 프로그램을 다시 시작하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="04b2d72b40a1cd44a0454da6f08a0b030bd3218c" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start a profile at application startup:</source>
          <target state="translated">다음은 Erlang 노드 애플리케이션 구성 파일에 넣어 애플리케이션 시작시 프로파일을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="062b29997a05c71efe23ac3949d3086ab3d47473" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start an HTTP server at application startup:</source>
          <target state="translated">다음은 Erlang 노드 애플리케이션 구성 파일에 넣어 애플리케이션 시작시 HTTP 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d3155b2a460c30a139bad84db61b5cb13f89e622" translate="yes" xml:space="preserve">
          <source>The following items are returned:</source>
          <target state="translated">다음 품목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd7738cf632ddaa8eb52ecadbb7505cd9d32c89a" translate="yes" xml:space="preserve">
          <source>The following items are valid:</source>
          <target state="translated">다음 항목이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="4561a64f009cfbd6722c632e8eb5a471d1923a59" translate="yes" xml:space="preserve">
          <source>The following list details the application versions that were part of OTP 17.0. If the normal part of an application version number compares as smaller than the corresponding application version in the list, the version number does not adhere to the version scheme introduced in OTP 17.0 and is to be considered as not having an order against versions used as of OTP 17.0.</source>
          <target state="translated">다음 목록은 OTP 17.0의 일부인 응용 프로그램 버전을 자세히 보여줍니다. 응용 프로그램 버전 번호의 일반 부분이 목록의 해당 응용 프로그램 버전보다 작은 경우 버전 번호는 OTP 17.0에 도입 된 버전 체계를 따르지 않으며 현재 사용 된 버전과 순서가없는 것으로 간주됩니다. OTP 17.0.</target>
        </trans-unit>
        <trans-unit id="f6f5aff715179f741e21746f788a0d571fc3772d" translate="yes" xml:space="preserve">
          <source>The following macro directives are supplied:</source>
          <target state="translated">다음과 같은 매크로 지시문이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="361a3fd4702c110455bbcea82ba2c037e63e708b" translate="yes" xml:space="preserve">
          <source>The following macros are defined:</source>
          <target state="translated">다음 매크로가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c28f5023d2a208f7eb90d1c1666a542586bef327" translate="yes" xml:space="preserve">
          <source>The following macros are predefined:</source>
          <target state="translated">다음 매크로가 사전 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee950191de94f676ee96776b15e0ccba25dfb73" translate="yes" xml:space="preserve">
          <source>The following macros can be used for retrieving parts of Erlang terms. None of these do any type checking. Results are undefined if you pass an &lt;code&gt;ETERM*&lt;/code&gt; containing the wrong type. For example, passing a tuple to &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; likely results in garbage.</source>
          <target state="translated">Erlang 용어의 일부를 검색하는 데 다음 매크로를 사용할 수 있습니다. 이들 중 어느 것도 유형 검사를 수행하지 않습니다. 잘못된 유형을 포함 하는 &lt;code&gt;ETERM*&lt;/code&gt; 을 전달하면 결과가 정의되지 않습니다 . 예를 들어, 튜플을 &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; 전달하면 가비지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e5655e09259732c78235fc15eeeb16532c8c59" translate="yes" xml:space="preserve">
          <source>The following macros can make tests more compact and readable:</source>
          <target state="translated">다음 매크로는 테스트를보다 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca8309f3b4453ebe12d39150b4c1a41828a11c5" translate="yes" xml:space="preserve">
          <source>The following matches &lt;code&gt;Expr1&lt;/code&gt;, a pattern, against &lt;code&gt;Expr2&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Expr2&lt;/code&gt; 에 대한 패턴 인 &lt;code&gt;Expr1&lt;/code&gt; 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b69739288091f88fd2e2b7df4c33b95efbcb7de9" translate="yes" xml:space="preserve">
          <source>The following matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;:</source>
          <target state="translated">다음은 &quot;bar&quot;다음에 나오는 &quot;foo&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="484da9e33049d8639a65d77742562fb2909ccd89" translate="yes" xml:space="preserve">
          <source>The following matches exactly eight digits:</source>
          <target state="translated">다음은 정확히 8 자리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a06f765490e0bde0129ff3bc5255ac6d9e037e52" translate="yes" xml:space="preserve">
          <source>The following matchings are performed:</source>
          <target state="translated">다음 일치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="10508667a9f0cb2b801a082330c255eed8059206" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process, provided it is stopped at a breakpoint (for details, see section &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">다음 메뉴 항목은 중단 점에서 중지 된 경우 현재 선택된 프로세스에 적용됩니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="012b9ddb6f5b2f9ff9b23f710bee122c826518c8" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process:</source>
          <target state="translated">다음 메뉴 항목은 현재 선택된 프로세스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="961db581de293dbe681aab0fe7f1fa5413883ae0" translate="yes" xml:space="preserve">
          <source>The following message is sent to fred's client:</source>
          <target state="translated">다음 메시지는 fred의 클라이언트에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="040a3190564c92ea22bf0b64f131001c6c8e6bcc" translate="yes" xml:space="preserve">
          <source>The following message is sent to peter's client:</source>
          <target state="translated">다음 메시지가 peter의 클라이언트에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="46e910fb5b7dc40614e76e8f199ed8c133275031" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior.</source>
          <target state="translated">다음 메시지는 &lt;code&gt;ssh_client_channel&lt;/code&gt; 작동 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="568021cb728093af7ccf7e34bcf43fc6d465a610" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_server_channel&lt;/code&gt; behavior.</source>
          <target state="translated">다음 메시지는 &lt;code&gt;ssh_server_channel&lt;/code&gt; 작동 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="95574b85a29dc16b146c7d05b6e10a7f4673d155" translate="yes" xml:space="preserve">
          <source>The following message is used to report that a response to a request has been received. The only request an agent can send is an Inform-Request.</source>
          <target state="translated">다음 메시지는 요청에 대한 응답이 수신되었음을보고하는 데 사용됩니다. 상담원이 보낼 수있는 유일한 요청은 정보 요청입니다.</target>
        </trans-unit>
        <trans-unit id="0c7528a0e8b223caeddcbcb738daf3c373f6236b" translate="yes" xml:space="preserve">
          <source>The following options are accepted by &lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; 에서는 다음 옵션이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="61183e21017b0486797e22d4c6cd3d34960e2bbe" translate="yes" xml:space="preserve">
          <source>The following options are also available, but their use is not recommended (they are mostly for Dialyzer developers and internal debugging):</source>
          <target state="translated">다음 옵션도 사용할 수 있지만 사용하지 않는 것이 좋습니다 (대부분 Dialyzer 개발자 및 내부 디버깅 용).</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd679e7b65020adaa7caadfb8cc5ecd8137541b1" translate="yes" xml:space="preserve">
          <source>The following options are client-specific or have a slightly different meaning in the client than in the server:</source>
          <target state="translated">다음 옵션은 클라이언트마다 다르거 나 클라이언트와 서버에서 약간 다른 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="43fc95d7126c192227c57609b602277d7d9fc9c6" translate="yes" xml:space="preserve">
          <source>The following options are relevant for execution:</source>
          <target state="translated">다음 옵션은 실행과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08de76658d5ff2a86a979ad65f0c82faad76c53" translate="yes" xml:space="preserve">
          <source>The following options are server-specific or have a slightly different meaning in the server than in the client:</source>
          <target state="translated">다음 옵션은 서버마다 다르거 나 서버에서 클라이언트와 약간 다른 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="05f80f80cb76aee8e2eb49065b6adb6528a602a4" translate="yes" xml:space="preserve">
          <source>The following options are valid for specifying an SSH/SFTP connection (that is, can be used as configuration elements):</source>
          <target state="translated">다음 옵션은 SSH / SFTP 연결을 지정하는 데 유효합니다 (즉, 구성 요소로 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="64236fe6def7f266116ddf3fd4dbff2f206d4ac0" translate="yes" xml:space="preserve">
          <source>The following options can also be specified with the suite information list:</source>
          <target state="translated">제품군 정보 목록으로 다음 옵션을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f19a5edc418a6bcc2f47d78030913af7ccd1058" translate="yes" xml:space="preserve">
          <source>The following options can be used:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c58ec5e85924908f7ac6436290b127a355d50e" translate="yes" xml:space="preserve">
          <source>The following options have the same meaning in the client and the server:</source>
          <target state="translated">다음 옵션은 클라이언트와 서버에서 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cc3e03d64e601199200fd4b43567e38970933b0e" translate="yes" xml:space="preserve">
          <source>The following options modify the defaults for the extraction as follows:</source>
          <target state="translated">다음 옵션은 추출의 기본값을 다음과 같이 수정합니다.</target>
        </trans-unit>
        <trans-unit id="ce8906ae4045d2d535cd313e6ec00213370b53c4" translate="yes" xml:space="preserve">
          <source>The following options must be present:</source>
          <target state="translated">다음과 같은 옵션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a2f1d45ea56db7e397408b134364d0f8afeb1b3" translate="yes" xml:space="preserve">
          <source>The following output is shown:</source>
          <target state="translated">다음과 같은 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e25b43e0cc5f60f33a4f8cad836e1610d7400d5" translate="yes" xml:space="preserve">
          <source>The following pair is returned for halt logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드 에서 열린 정지 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="c33b12b3e0b9d36e7372996a4a7abaf00697933a" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드로 열린 모든 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="7611c3aa913240353c120613c97a195274c20308" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs:</source>
          <target state="translated">모든 로그에 대해 다음 쌍이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="91a838c6cf493f03c500bbdbcdd502edf542e0fe" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for wrap logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드 에서 열린 랩 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="224537c90399cde228dbede4c53cbc30f714374c" translate="yes" xml:space="preserve">
          <source>The following parameters can be specified for each Erlang service:</source>
          <target state="translated">각 Erlang 서비스에 대해 다음 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7561aff36c4e31e9b40cf0d53c766582f8727228" translate="yes" xml:space="preserve">
          <source>The following parameters represents the SNMP configuration files &lt;code&gt;context.conf&lt;/code&gt;, &lt;code&gt;standard.conf&lt;/code&gt;, &lt;code&gt;community.conf&lt;/code&gt;, &lt;code&gt;vacm.conf&lt;/code&gt;, &lt;code&gt;usm.conf&lt;/code&gt;, &lt;code&gt;notify.conf&lt;/code&gt;, &lt;code&gt;target_addr.conf&lt;/code&gt;, and &lt;code&gt;target_params.conf&lt;/code&gt;. Notice that all values in &lt;code&gt;agent.conf&lt;/code&gt; can be modified by the parameters listed above. All these configuration files have default values set by the &lt;code&gt;SNMP&lt;/code&gt; application. These values can be overridden by suppling a list of valid configuration values or a file located in the test suites data directory, which can produce a list of valid configuration values if you apply function &lt;code&gt;file:consult/1&lt;/code&gt; to the file.</source>
          <target state="translated">다음 매개 변수는 SNMP 구성 파일 &lt;code&gt;context.conf&lt;/code&gt; , &lt;code&gt;standard.conf&lt;/code&gt; , &lt;code&gt;community.conf&lt;/code&gt; , &lt;code&gt;vacm.conf&lt;/code&gt; , &lt;code&gt;usm.conf&lt;/code&gt; , &lt;code&gt;notify.conf&lt;/code&gt; , &lt;code&gt;target_addr.conf&lt;/code&gt; 및 &lt;code&gt;target_params.conf&lt;/code&gt; 를 나타 냅니다. &lt;code&gt;agent.conf&lt;/code&gt; 의 모든 값은 위에 나열된 매개 변수로 수정할 수 있습니다. 이러한 모든 구성 파일에는 &lt;code&gt;SNMP&lt;/code&gt; 응용 프로그램에서 설정 한 기본값이 있습니다 . 이 값은 유효한 구성 값 목록 또는 테스트 스위트 데이터 디렉토리에있는 파일을 제공하여 대체 할 수 있습니다. 함수 &lt;code&gt;file:consult/1&lt;/code&gt; 을 적용하면 유효한 구성 값 목록이 생성 될 수 있습니다 . 파일에.</target>
        </trans-unit>
        <trans-unit id="cf9b8bf83a4a013f2ea8d7a63a8c6eceb1e8ce5f" translate="yes" xml:space="preserve">
          <source>The following pattern matches &quot;foo&quot; preceded by three digits and any three characters that are not &quot;999&quot;:</source>
          <target state="translated">다음 패턴은 &quot;foo&quot;앞에 세 자리 숫자와 &quot;999&quot;가 아닌 세 문자가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b6c387fc7cb1c2a0aaf335c75b4b32deefd1c2b6" translate="yes" xml:space="preserve">
          <source>The following picture gives an overview of the mechanism to select an MIB view:</source>
          <target state="translated">다음 그림은 MIB보기를 선택하는 메커니즘에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="343b7de69e7382fea1083cf8cb82178662515737" translate="yes" xml:space="preserve">
          <source>The following picture illustrates the idea:</source>
          <target state="translated">다음 그림은 아이디어를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4b30adf5dd015c5f072d818ec045884b44dff621" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; User's Guide:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 사용자 안내서 의 자료를 이해하려면 다음 전제 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f494d18baeb5626e63a43266d42eed96b8ed12a2" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Megaco User's Guide:</source>
          <target state="translated">Megaco 사용 설명서의 내용을 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1cbd57540b48d0efa55b14338c8830cec00d8547" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Reltool User's Guide:</source>
          <target state="translated">Reltool 사용자 안내서의 자료를 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7e4d733e362ec6903442fab3ca35dcd536f3cdbe" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the SNMP User's Guide:</source>
          <target state="translated">SNMP 사용 설명서의 내용을 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fab1a3516c76bbdd3d05df3eae1d2f555b42050e" translate="yes" xml:space="preserve">
          <source>The following procedure does not require root privilege:</source>
          <target state="translated">다음 절차에는 루트 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8602668ad76f501ac94f891d7bfbf36be343c4f" translate="yes" xml:space="preserve">
          <source>The following program illustrates the different ways of creating funs:</source>
          <target state="translated">다음 프로그램은 재미를 만드는 여러 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dbcee6e28420ee50b59b118c6bd9505eaeb1f3e3" translate="yes" xml:space="preserve">
          <source>The following program module creates and populates previously defined tables:</source>
          <target state="translated">다음 프로그램 모듈은 이전에 정의 된 테이블을 작성하고 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="872226e20506f4791f4924b86b65d0e2ff5aeff1" translate="yes" xml:space="preserve">
          <source>The following queries are accepted from remote nodes:</source>
          <target state="translated">원격 노드에서 다음 쿼리가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="34fcb8ab715f637bf664ee99fb64aae24ae2711f" translate="yes" xml:space="preserve">
          <source>The following record definitions can be created:</source>
          <target state="translated">다음과 같은 레코드 정의를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aba38102e6596c004eb1b74efe69102547563ee" translate="yes" xml:space="preserve">
          <source>The following records are generated because of type &lt;code&gt;Emb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Emb&lt;/code&gt; 유형으로 인해 다음 레코드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b8b7242e195bbd29d16d5919c21b7b689163ef" translate="yes" xml:space="preserve">
          <source>The following records used by xmerl to save the parsed data are defined in &lt;code&gt;xmerl.hrl&lt;/code&gt;</source>
          <target state="translated">분석 된 데이터를 저장하기 위해 xmerl이 사용하는 다음 레코드는 xmerl.hrl에 정의되어 &lt;code&gt;xmerl.hrl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a7943f947fe72299ad61ae324cdc2eb219124" translate="yes" xml:space="preserve">
          <source>The following representations control how and where tests are executed:</source>
          <target state="translated">다음 표현은 테스트 실행 방법 및 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="86bacadf1ea90a3c97d82c63773f210e42c2a214" translate="yes" xml:space="preserve">
          <source>The following representations specify fixture handling for test sets:</source>
          <target state="translated">다음 표현은 테스트 세트에 대한 조명기 처리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="010a5b84d478f42d2d6af978a84f08199f613d86" translate="yes" xml:space="preserve">
          <source>The following requirements apply to the &lt;code&gt;.app&lt;/code&gt; file for an included application:</source>
          <target state="translated">포함 된 응용 프로그램 의 &lt;code&gt;.app&lt;/code&gt; 파일 에는 다음 요구 사항이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47012e55fe1825d2922f7d5fb219850e8c4ce7ee" translate="yes" xml:space="preserve">
          <source>The following runs a test executing &lt;code&gt;tc12&lt;/code&gt; in &lt;code&gt;top1&lt;/code&gt; and any subgroup under &lt;code&gt;top1&lt;/code&gt; where it can be found (&lt;code&gt;sub11&lt;/code&gt; and &lt;code&gt;sub121&lt;/code&gt;):</source>
          <target state="translated">다음은 실행 테스트 실행 &lt;code&gt;tc12&lt;/code&gt; 에서 &lt;code&gt;top1&lt;/code&gt; 와 아래의 모든 하위 그룹 &lt;code&gt;top1&lt;/code&gt; 이 찾을 수 있습니다 ( &lt;code&gt;sub11&lt;/code&gt; 및 &lt;code&gt;sub121&lt;/code&gt; 을 ) :</target>
        </trans-unit>
        <trans-unit id="0e90b96a7f25790f2708f620c0e643b1c7f52c18" translate="yes" xml:space="preserve">
          <source>The following script illustrates a modification where the node is given the name &lt;code&gt;cp1&lt;/code&gt;, and where the environment variables &lt;code&gt;HEART_COMMAND&lt;/code&gt; and &lt;code&gt;TERM&lt;/code&gt; have been added to the previous script:</source>
          <target state="translated">다음 스크립트는 노드에 이름이 &lt;code&gt;cp1&lt;/code&gt; 이고 환경 변수 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 및 &lt;code&gt;TERM&lt;/code&gt; 이 이전 스크립트에 추가 된 수정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5db13a72ee33e776ce2ddcad2d3b2330d02936db" translate="yes" xml:space="preserve">
          <source>The following script illustrates the behaviour of the program:</source>
          <target state="translated">다음 스크립트는 프로그램의 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4cb6bb01c4a2fc6f1d31fffabe3ea35bf47bbd99" translate="yes" xml:space="preserve">
          <source>The following script illustrates the default behaviour of the program:</source>
          <target state="translated">다음 스크립트는 프로그램의 기본 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1730c3be7b670e5f6ed8dc96c7503a465a16bfb5" translate="yes" xml:space="preserve">
          <source>The following searches &lt;code&gt;top1&lt;/code&gt; and all its subgroups for &lt;code&gt;tc16&lt;/code&gt; resulting in that this test case executes in group &lt;code&gt;sub121&lt;/code&gt;:</source>
          <target state="translated">다음 검색 &lt;code&gt;top1&lt;/code&gt; 및 모든 하위 그룹 &lt;code&gt;tc16&lt;/code&gt; 결과 그룹이 테스트 케이스 실행하는 &lt;code&gt;sub121&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="526a47fb0328941b790c466199e779b1931bd0e8" translate="yes" xml:space="preserve">
          <source>The following section describes the mandatory and optional test suite functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">다음 섹션에서는 테스트 실행 중에 &lt;code&gt;Common Test&lt;/code&gt; 가 호출 하는 필수 및 선택적 테스트 스위트 기능에 대해 설명합니다 . 자세한 내용 은 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c1a7ce03d50e78be89c8cc10dbc16d75c4a19c" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material for the regular expressions used by this module. The information is based on the PCRE documentation, with changes where this module behaves differently to the PCRE library.</source>
          <target state="translated">다음 섹션에는이 모듈에서 사용되는 정규식에 대한 참조 자료가 포함되어 있습니다. 이 정보는 PCRE 문서를 기반으로하며이 모듈이 PCRE 라이브러리와 다르게 작동하는 위치를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="83810d4821d49c1738acda1b065dd05f79bc8cd1" translate="yes" xml:space="preserve">
          <source>The following sections deal with target systems with different requirements of functionality:</source>
          <target state="translated">다음 섹션에서는 기능 요구 사항이 다른 대상 시스템을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="38eecd6e67f72292d41c686c8caab1a223f8a8a9" translate="yes" xml:space="preserve">
          <source>The following sections describe how the instrumentation functions should be defined in Erlang for the different operations. In the following, &lt;code&gt;RowIndex&lt;/code&gt; is a list of key values for the table, and &lt;code&gt;Column&lt;/code&gt; is a column number.</source>
          <target state="translated">다음 섹션에서는 다양한 작업을 위해 Erlang에서 계측 기능을 정의하는 방법에 대해 설명합니다. 다음에서 &lt;code&gt;RowIndex&lt;/code&gt; 는 테이블의 키 값 목록이고 &lt;code&gt;Column&lt;/code&gt; 은 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="93b41da5ab42cf67eae696be1649b8c0efaf1bfc" translate="yes" xml:space="preserve">
          <source>The following sections describe how to use CTHs, when they are run, and how to manipulate the test results in a CTH.</source>
          <target state="translated">다음 섹션에서는 CTH 사용 방법, 실행시기 및 CTH에서 테스트 결과를 조작하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="31ea898329f4b3682826cd0bafcd93ad163d085b" translate="yes" xml:space="preserve">
          <source>The following sections describe sequential tracing and its most fundamental concepts.</source>
          <target state="translated">다음 섹션에서는 순차적 추적 및 가장 기본적인 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9600ad9c1d4332036b9e8528fa9289370114665e" translate="yes" xml:space="preserve">
          <source>The following sections describe some of the fields in the information tabs. These are fields that do not exist in the raw crashdump, or in some way differ from the fields in the raw crashdump. For details about other fields, see the &lt;code&gt;ERTS User's Guide&lt;/code&gt;, section &quot;How to interpret the Erlang crash dumps&quot;. That section can also be opened from the &lt;strong&gt;Help&lt;/strong&gt; menu in the main window. There are also links from the following sections to related information in &quot;How to interpret the Erlang crash dumps&quot;.</source>
          <target state="translated">다음 섹션에서는 정보 탭의 일부 필드에 대해 설명합니다. 이는 원시 크래시 덤프에 존재하지 않거나 어떤 방식 으로든 원시 크래시 덤프의 필드와 다른 필드입니다. 다른 필드에 대한 자세한 내용은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; &quot;Erlang 크래시 덤프 해석 방법&quot;섹션을 참조하십시오 . 기본 창의 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴에서 해당 섹션을 열 수도 있습니다 . 다음 섹션의 &quot;Erlang 크래시 덤프 해석 방법&quot;에있는 관련 정보로 연결되는 링크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e038c99195f68fa297f2e5f9e78c69595a14730e" translate="yes" xml:space="preserve">
          <source>The following sections describe the mandatory and optional CTH functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">다음 섹션에서는 테스트 실행 중 &lt;code&gt;Common Test&lt;/code&gt; 호출 하는 필수 및 선택적 CTH 기능에 대해 설명합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ca82394dc00f1e6d08913e914b59a46cf6c2484" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each metacharacter.</source>
          <target state="translated">다음 섹션에서는 각 메타 문자 사용에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57bd03425adcf43ca596408a2b02f2936cfeb5dd" translate="yes" xml:space="preserve">
          <source>The following sections describe these steps.</source>
          <target state="translated">다음 섹션에서는 이러한 단계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ef3caea09c20221894e510d93d0376e9f32ba13c" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of how to profile with Fprof. See also the reference manual &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 섹션에서는 Fprof로 프로파일 링하는 방법에 대한 몇 가지 예를 보여줍니다. 참조 설명서 &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98275a3598f57cab63cd60d26cf4b95397a5db2f" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of profiling with &lt;code&gt;cprof&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 섹션에서는 &lt;code&gt;cprof&lt;/code&gt; 로 프로파일 링하는 몇 가지 예를 보여줍니다 . &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3346c4bffa9bbaca48b8099eae111ab7c83c1879" translate="yes" xml:space="preserve">
          <source>The following sections show some features of Xref, beginning with a module check and a predefined analysis. Then follow examples that can be skipped on the first reading; not all of the concepts used are explained, and it is assumed that the &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; has been at least skimmed.</source>
          <target state="translated">다음 섹션에서는 모듈 확인 및 사전 정의 된 분석으로 시작하는 외부 참조의 일부 기능을 보여줍니다. 그런 다음 첫 번째 판독에서 건너 뛸 수있는 예를 따르십시오. 사용 된 모든 개념이 설명되는 것은 아니며, &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 이 최소한 스키밍 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="4f224d7ff4347a5d76be2a01609f9bb95ab48bc8" translate="yes" xml:space="preserve">
          <source>The following sequence of calls fails:</source>
          <target state="translated">다음과 같은 호출 순서는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6f684598ccd6c3370add4d7675b782860903e544" translate="yes" xml:space="preserve">
          <source>The following sequence works, as the call to &lt;code&gt;repair_continuation/2&lt;/code&gt; reestablishes the (deliberately) invalidated continuation &lt;code&gt;Broken&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repair_continuation/2&lt;/code&gt; 에 대한 호출 이 (고의적으로) 무효화 된 연속 &lt;code&gt;Broken&lt;/code&gt; 재설정 함에 따라 다음 순서가 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d34878ccc7af10841358fe32d20c8e85617519" translate="yes" xml:space="preserve">
          <source>The following session with the Erlang shell shows how to load the &lt;code&gt;FRUITS&lt;/code&gt; database:</source>
          <target state="translated">Erlang 쉘을 사용한 다음 세션에서는 &lt;code&gt;FRUITS&lt;/code&gt; 데이터베이스 를로드하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1ca2b9cadd413c828114f5fdadb155510f45b89f" translate="yes" xml:space="preserve">
          <source>The following shell interaction starts &lt;code&gt;Mnesia&lt;/code&gt; and initializes the schema for the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">다음 셸 상호 작용은 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작 하고 &lt;code&gt;Company&lt;/code&gt; 데이터베이스 의 스키마를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="3e56ec35aa2570200adfb4251b42d9a7a4dbc048" translate="yes" xml:space="preserve">
          <source>The following shows an example &lt;code&gt;.rel&lt;/code&gt; file with TLS added:</source>
          <target state="translated">다음은 TLS가 추가 된 &lt;code&gt;.rel&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e94749126c9966bcf63f22766109b91add03d6be" translate="yes" xml:space="preserve">
          <source>The following shows examples of how UTF-8 encoded binaries can be created and manipulated:</source>
          <target state="translated">다음은 UTF-8로 인코딩 된 바이너리를 만들고 조작하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="53b230af1628e298070b4609c7e79b754d5b0d07" translate="yes" xml:space="preserve">
          <source>The following shows how the compiler can be called from the Erlang shell:</source>
          <target state="translated">다음은 Erlang 쉘에서 컴파일러를 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="729768340129de2ea35b78f26817f116e7bf52b6" translate="yes" xml:space="preserve">
          <source>The following simple code illustrates the relationship between the simplified access functions used in most of the examples and their more flexible counterparts:</source>
          <target state="translated">다음의 간단한 코드는 대부분의 예제에서 사용 된 단순화 된 액세스 기능과보다 유연한 대응 기능 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b84b8caa8b26cb602514d1eab6fc03a38ae48762" translate="yes" xml:space="preserve">
          <source>The following small module is used in the subsequent example:</source>
          <target state="translated">다음 예제에서는 다음과 같은 작은 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1dfc37e671a01a444893fce16128adaeffd6fa" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get a running agent:</source>
          <target state="translated">실행중인 에이전트를 가져 오려면 다음 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc08bddc5161d849d8adaf8a442d077969754d3f" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get the manager running:</source>
          <target state="translated">관리자를 실행하려면 다음 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fa6e913607cc215db5650f46601c1682dec9a4c4" translate="yes" xml:space="preserve">
          <source>The following tags appears in the list:</source>
          <target state="translated">다음 태그가 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="59f95e04d57dcd84839504590aa3ea9df899aa69" translate="yes" xml:space="preserve">
          <source>The following tags have special meaning:</source>
          <target state="translated">다음 태그는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e75dc33e0130efecbbf3b0c117aa1a4317b0d14" translate="yes" xml:space="preserve">
          <source>The following terms are allowed in a cover specification file:</source>
          <target state="translated">표지 사양 파일에는 다음 용어가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="082dcb2df904c716cc9a3e85c660d6af2e65ff42" translate="yes" xml:space="preserve">
          <source>The following top level &lt;code&gt;options&lt;/code&gt; are supported:</source>
          <target state="translated">다음과 같은 최상위 &lt;code&gt;options&lt;/code&gt; 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="49a42c98aae1a012fca04ff4fc1c26473f67efa7" translate="yes" xml:space="preserve">
          <source>The following topics are included:</source>
          <target state="translated">다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="05245f82bf6574a4a5eff794c54d89c9d6171eb9" translate="yes" xml:space="preserve">
          <source>The following topics are not treated in this section:</source>
          <target state="translated">이 항목에서는 다음 주제를 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab7564645416f18d8a1c44a537bed7227fcf3ddd" translate="yes" xml:space="preserve">
          <source>The following trace output is received during test:</source>
          <target state="translated">테스트 중에 다음과 같은 추적 출력이 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="b466650d4111c63d9300f7fbae0b73cc83cacf0c" translate="yes" xml:space="preserve">
          <source>The following two Kernel configuration parameters affect the behavior of all sockets opened on an Erlang node:</source>
          <target state="translated">다음 두 커널 구성 매개 변수는 Erlang 노드에서 열린 모든 소켓의 작동에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4a11518ecf3b3d71056ddbfd18678d2117872201" translate="yes" xml:space="preserve">
          <source>The following two calls give the same result (but certainly not the same execution time):</source>
          <target state="translated">다음 두 호출은 동일한 결과를 제공하지만 반드시 동일한 실행 시간은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5507869e7948c09fc8040111e6b2cadd35e4aff0" translate="yes" xml:space="preserve">
          <source>The following two directories must exist in the system to run the agent:</source>
          <target state="translated">에이전트를 실행하려면 시스템에 다음 두 디렉토리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="113cb904554a59290d2e213118f8d8428037b8fb" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to retrieve system information. For details, see the Reference Manual.</source>
          <target state="translated">다음 두 가지 기능을 사용하여 시스템 정보를 검색 할 수 있습니다. 자세한 내용은 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71cd872babc8d6113efd7cead6cf75e880db8ea3" translate="yes" xml:space="preserve">
          <source>The following two functions manipulate indexes on existing tables:</source>
          <target state="translated">다음 두 함수는 기존 테이블의 인덱스를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="706b90dd5c946a37fcc3ef255278e31f7c9293de" translate="yes" xml:space="preserve">
          <source>The following two notations are available for representation of &lt;code&gt;BIT STRING&lt;/code&gt; values in Erlang and as input to the encode functions:</source>
          <target state="translated">Erlang에서 &lt;code&gt;BIT STRING&lt;/code&gt; 값 을 표시 하고 인코딩 함수에 대한 입력으로 다음 두 가지 표기법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9929e878110d22fef5c962cd4c16eef48be74d8c" translate="yes" xml:space="preserve">
          <source>The following two pairs of functions support this scenario:</source>
          <target state="translated">다음 두 쌍의 기능이이 시나리오를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09ba41aca160585c0b08fc3e3fe758e0deed5098" translate="yes" xml:space="preserve">
          <source>The following type definitions are used by more than one function in the FTP client API:</source>
          <target state="translated">다음 유형 정의는 FTP 클라이언트 API에서 둘 이상의 함수에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9226ce7513015120a190ef4af2c57e38cf1718d8" translate="yes" xml:space="preserve">
          <source>The following values are allowed for &lt;code&gt;Key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 에는 다음 값이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c84aa8502d90e7ba6f618344ec9f0990938b08f" translate="yes" xml:space="preserve">
          <source>The following verb causes a matching failure, forcing backtracking to occur. It is equivalent to (?!) but easier to read.</source>
          <target state="translated">다음 동사는 일치하는 실패를 일으켜 역 추적을 강제합니다. (?!)와 동일하지만 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c74b31c10443669b849931e80db4cb844acc7e6d" translate="yes" xml:space="preserve">
          <source>The following verb causes a skip to the next innermost alternative when backtracking reaches it. That is, it cancels any further backtracking within the current alternative.</source>
          <target state="translated">다음 동사는 역 추적에 도달하면 다음으로 가장 안쪽에있는 대안으로 건너 뜁니다. 즉, 현재 대안 내에서 추가 역 추적을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3626ed56739d6ce7e205e1a6154059baf311b051" translate="yes" xml:space="preserve">
          <source>The following verb causes the match to fail at the current starting position in the subject if there is a later matching failure that causes backtracking to reach it:</source>
          <target state="translated">다음 동사는 역 추적에 도달하는 이후의 일치 실패가있는 경우 주제의 현재 시작 위치에서 일치를 실패시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e32c99b23fb1cb8aa4ff4619bdeb76fe057cfe" translate="yes" xml:space="preserve">
          <source>The following verb, when specified without a name, is like (*PRUNE), except that if the pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next character, but to the position in the subject where (*SKIP) was encountered.</source>
          <target state="translated">이름없이 지정 될 때 다음 동사는 패턴이 고정되지 않은 경우 &quot;bumpalong&quot;진행이 다음 문자가 아니라 (* SKIP) 인 주제의 위치에 있다는 점을 제외하고는 (* PRUNE)과 같습니다. 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="56e82a4845f59e054a6c2a8f1874cfef875f8736" translate="yes" xml:space="preserve">
          <source>The following verb, which must not be followed by a name, causes the whole match to fail outright if there is a later matching failure that causes backtracking to reach it. Even if the pattern is unanchored, no further attempts to find a match by advancing the starting point take place.</source>
          <target state="translated">뒤에 나오는 이름이 없어야하는 다음 동사는 역 추적에 도달하는 나중에 일치하는 실패가있는 경우 전체 일치를 완전히 실패하게합니다. 패턴이 고정되어 있지 않더라도 시작점을 진행하여 더 이상 매치를 찾으려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d2ee15663a5b3e2b4b9ab4b42fcb763860ca710" translate="yes" xml:space="preserve">
          <source>The following verbs act as soon as they are encountered. They must not be followed by a name.</source>
          <target state="translated">다음 동사는 마주 치면 바로 작동합니다. 이름 뒤에는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc631f8808db5a059db58a11cb23a25b194b9bc" translate="yes" xml:space="preserve">
          <source>The following verbs do nothing when they are encountered. Matching continues with what follows, but if there is no subsequent match, causing a backtrack to the verb, a failure is forced. That is, backtracking cannot pass to the left of the verb. However, when one of these verbs appears inside an atomic group or an assertion that is true, its effect is confined to that group, as once the group has been matched, there is never any backtracking into it. In this situation, backtracking can &quot;jump back&quot; to the left of the entire atomic group or assertion. (Remember also, as stated above, that this localization also applies in subroutine calls.)</source>
          <target state="translated">다음 동사는 마주 칠 때 아무 것도하지 않습니다. 일치하는 내용은 다음과 계속되지만 후속 일치 항목이 없으면 동사에 대한 역 추적을 유발하면 실패가 발생합니다. 즉, 역 추적은 동사의 왼쪽으로 전달할 수 없습니다. 그러나 이러한 동사 중 하나가 원자 그룹 또는 어설 션 내에 표시되면 그룹이 일치하면 그 역효과가 해당 그룹에 국한되지 않습니다. 이 상황에서 역 추적은 전체 원자 그룹 또는 어설 션의 왼쪽으로 &quot;점프 백&quot;할 수 있습니다. (위에서 언급했듯이이 현지화는 서브 루틴 호출에도 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="e618ac47f63af62ceb8671ae5e22050d8ff5aec4" translate="yes" xml:space="preserve">
          <source>The following warnings and restrictions apply to the funs used in with &lt;code&gt;ets:fun2ms/1&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">다음 경고 및 제한 사항은 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 과 함께 사용되는 기능에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="58ed2789e1ec56e8739ba6ba58818f4844d3585c" translate="yes" xml:space="preserve">
          <source>The following will appear at the console on the node that started the trace client:</source>
          <target state="translated">추적 클라이언트를 시작한 노드의 콘솔에 다음이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4f6cfe143c1844487af6c9d7af979551cc8a56ef" translate="yes" xml:space="preserve">
          <source>The foreign key</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="d5bbce337b986ce05bfb1074200a1cd8e6ba791d" translate="yes" xml:space="preserve">
          <source>The format and value of &lt;code&gt;FixationTime&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FixationTime&lt;/code&gt; 의 형식과 값은 &lt;code&gt;Item&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="403056f7b6145ea80b76c6096562c79850393812" translate="yes" xml:space="preserve">
          <source>The format function is also optional. It is called by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; to give feedback at runtime of how the query is to be evaluated. Try to give as good feedback as possible without showing too much details. In the example, at most seven objects of the table are shown. The format function handles two cases: &lt;code&gt;all&lt;/code&gt; means that all objects of the table are traversed; &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; means that the lookup function is used for looking up key values.</source>
          <target state="translated">포맷 기능도 옵션입니다. &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 호출되어 런타임에 쿼리 평가 방법에 대한 피드백을 제공합니다. 너무 많은 세부 사항을 표시하지 않고 가능한 한 좋은 피드백을 제공하십시오. 이 예에서는 최대 7 개의 테이블 개체가 표시됩니다. format 함수는 두 가지 경우를 처리합니다. &lt;code&gt;all&lt;/code&gt; 은 테이블의 모든 오브젝트가 순회 함을 의미합니다. &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; 는 조회 기능이 키 값을 찾는 데 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a28925d546a087448d542d4ec3fe58c4d1daac9b" translate="yes" xml:space="preserve">
          <source>The format is parsable with the standard Erlang parsing tools &lt;code&gt;erl_scan&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt;, &lt;code&gt;file:consult/1&lt;/code&gt; or &lt;code&gt;io:read/2&lt;/code&gt;. The parse format is not explained here - it should be easy for the interested to try it out. Note that some flags to &lt;code&gt;analyse/1&lt;/code&gt; will affect the format.</source>
          <target state="translated">형식은 표준 Erlang 구문 분석 도구 &lt;code&gt;erl_scan&lt;/code&gt; 및 &lt;code&gt;erl_parse&lt;/code&gt; , &lt;code&gt;file:consult/1&lt;/code&gt; 또는 &lt;code&gt;io:read/2&lt;/code&gt; 로 구문 분석 할 수 있습니다 . 구문 분석 형식은 여기에 설명되어 있지 않습니다. 관심있는 사용자가 쉽게 시도해 볼 수 있습니다. &lt;code&gt;analyse/1&lt;/code&gt; 에 대한 일부 플래그 는 형식에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="dd5e5f8070fec3acf0e1ec232310a61ff03f8b85" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Drive&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;Drive&lt;/code&gt; 형식 이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf4dd1e5a91b60292984d5a8e1ea127c178da5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; depends on the operating system. On UNIX, it is typically produced from the output of the &lt;code&gt;ls -l&lt;/code&gt; shell command.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 의 형식은 운영 체제에 따라 다릅니다. UNIX에서는 일반적으로 &lt;code&gt;ls -l&lt;/code&gt; shell 명령 의 출력에서 ​​생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a8dac735cad80fa64163e77b01f6b5b6e6b931f" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; is a stream of filenames where each filename is separated by &amp;lt;CRLF&amp;gt; or &amp;lt;NL&amp;gt;. Contrary to function &lt;code&gt;ls&lt;/code&gt;, the purpose of &lt;code&gt;nlist&lt;/code&gt; is to enable a program to process filename information automatically.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 의 형식은 각 파일 이름이 &amp;lt;CRLF&amp;gt; 또는 &amp;lt;NL&amp;gt;으로 구분되는 파일 이름 스트림입니다. 함수 &lt;code&gt;ls&lt;/code&gt; 와는 반대로 &lt;code&gt;nlist&lt;/code&gt; 의 목적은 프로그램이 파일 이름 정보를 자동으로 처리 할 수 ​​있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca6bda514e36415bd8dfddbfd465c752506ba14c" translate="yes" xml:space="preserve">
          <source>The format of an audit trail log text item is as follows:</source>
          <target state="translated">감사 추적 로그 텍스트 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44015ed1506dab2702bf874c622404e1cdd4a16b" translate="yes" xml:space="preserve">
          <source>The format of decoded messages and grouped AVPs in the &lt;code&gt;msg&lt;/code&gt; field of diameter_packet records and &lt;code&gt;value&lt;/code&gt; field of diameter_avp records respectively. If &lt;code&gt;record&lt;/code&gt; then a record whose definition is generated from the dictionary file in question. If &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; then a &lt;code&gt;[Name | Avps]&lt;/code&gt; pair where &lt;code&gt;Avps&lt;/code&gt; is a list of AVP name/values pairs or a map keyed on AVP names respectively. If &lt;code&gt;none&lt;/code&gt; then the atom-value message name, or &lt;code&gt;undefined&lt;/code&gt; for a Grouped AVP. See also &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">diameter_packet 레코드 의 &lt;code&gt;msg&lt;/code&gt; 필드와 diameter_avp 레코드의 &lt;code&gt;value&lt;/code&gt; 필드에 각각 디코딩 된 메시지 및 그룹화 된 AVP의 형식입니다 . 만약 &lt;code&gt;record&lt;/code&gt; 후 그 정의 문제의 사전 파일에서 생성되는 기록을. 만약 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;map&lt;/code&gt; 다음 &lt;code&gt;[Name | Avps]&lt;/code&gt; pair 여기서 &lt;code&gt;Avps&lt;/code&gt; 는 각각 AVP 이름 / 값 쌍 또는 AVP 이름을 입력 한 맵 목록입니다. 않으면 &lt;code&gt;none&lt;/code&gt; 그 원자 값 메시지 이름 또는 &lt;code&gt;undefined&lt;/code&gt; 그룹화 된 AVP에 대한. &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="317788b6344114efeaf6f36e9948bb10fc231c82" translate="yes" xml:space="preserve">
          <source>The format of file &lt;code&gt;.hosts.erlang&lt;/code&gt; must be one host name per line. The host names must be within quotes.</source>
          <target state="translated">파일 &lt;code&gt;.hosts.erlang&lt;/code&gt; 의 형식은 한 줄에 하나의 호스트 이름이어야합니다. 호스트 이름은 따옴표 안에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2487f5cf9c75d813920c0dba73a01025e41c80a7" translate="yes" xml:space="preserve">
          <source>The format of received events is not defined.</source>
          <target state="translated">수신 된 이벤트의 형식이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9bfd68e235d56611f777394a5db1608f345a2ba3" translate="yes" xml:space="preserve">
          <source>The format of the &lt;code&gt;otp_versions.table&lt;/code&gt; might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;otp_versions.table&lt;/code&gt; 의 형식은 OTP 17 릴리스 중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689c1f8b385b83aa3589eb65a1746eb08236ca62" translate="yes" xml:space="preserve">
          <source>The format of the configuration file is found in the &lt;code&gt;syslog.conf(5)&lt;/code&gt; manual page, by issuing the command &lt;code&gt;man syslog.conf&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 형식은 &lt;code&gt;man syslog.conf&lt;/code&gt; 명령을 실행하여 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 매뉴얼 페이지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f90e37b89af3e970911fe6712a87407f263ba3" translate="yes" xml:space="preserve">
          <source>The format of the crash dump evolves between OTP releases. Some information described here may not apply to your version. A description like this will never be complete; it is meant as an explanation of the crash dump in general and as a help when trying to find application errors, not as a complete specification.</source>
          <target state="translated">크래시 덤프의 형식은 OTP 릴리스간에 발전합니다. 여기에 설명 된 일부 정보는 사용중인 버전에 적용되지 않을 수 있습니다. 이와 같은 설명은 절대 완료되지 않습니다. 일반적으로 크래시 덤프에 대한 설명과 완전한 사양이 아니라 응용 프로그램 오류를 찾을 때 도움을주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb9b12cb8d3ac8423ae8bea95db89eaec323992a" translate="yes" xml:space="preserve">
          <source>The format of the messages is one of the following, depending on if flag &lt;code&gt;timestamp&lt;/code&gt; of the trace token is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">추적 토큰의 플래그 &lt;code&gt;timestamp&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있는지 여부에 따라 메시지 형식은 다음 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="168262e7bb4ad03b8f9aa164f315f9eabe54fc52" translate="yes" xml:space="preserve">
          <source>The format of the node name is an atom &lt;code&gt;name@host&lt;/code&gt;. &lt;code&gt;name&lt;/code&gt; is the name given by the user. &lt;code&gt;host&lt;/code&gt; is the full host name if long names are used, or the first part of the host name if short names are used. &lt;code&gt;node()&lt;/code&gt; returns the name of the node.</source>
          <target state="translated">노드 이름의 형식은 atom &lt;code&gt;name@host&lt;/code&gt; 입니다. &lt;code&gt;name&lt;/code&gt; 은 사용자가 제공 한 이름 입니다. &lt;code&gt;host&lt;/code&gt; 는 긴 이름을 사용하는 경우 전체 호스트 이름이거나 짧은 이름을 사용하는 경우 호스트 이름의 첫 부분입니다. &lt;code&gt;node()&lt;/code&gt; 는 노드 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e18dae497a998ac661c28b510144fccadd65f4ce" translate="yes" xml:space="preserve">
          <source>The format of the node status change messages depends on &lt;code&gt;Options&lt;/code&gt;. If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, which is the default, the format is as follows:</source>
          <target state="translated">노드 상태 변경 메시지의 형식은 &lt;code&gt;Options&lt;/code&gt; 따라 다릅니다 . 경우 &lt;code&gt;Options&lt;/code&gt; 인 &lt;code&gt;[]&lt;/code&gt; , 기본값 인을, 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="765472921ad5d1b4e5d1dc40a24f50b66dda836a" translate="yes" xml:space="preserve">
          <source>The format of the status message is as follows:</source>
          <target state="translated">상태 메시지의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f119a1fe58fd91d2d32fa64f2417a092c14ccb82" translate="yes" xml:space="preserve">
          <source>The format of the text file is as follows:</source>
          <target state="translated">텍스트 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4333a537987dd2c37f631936cd505a940685024b" translate="yes" xml:space="preserve">
          <source>The format stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. To retrieve particular code representation from the backend, &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; must be invoked. &lt;code&gt;Format&lt;/code&gt; is an atom, such as &lt;code&gt;erlang_v1&lt;/code&gt; for the Erlang Abstract Format or &lt;code&gt;core_v1&lt;/code&gt; for Core Erlang. &lt;code&gt;Module&lt;/code&gt; is the module represented by the beam file and &lt;code&gt;Data&lt;/code&gt; is the value stored in the debug info chunk. &lt;code&gt;Opts&lt;/code&gt; is any list of values supported by the &lt;code&gt;Backend&lt;/code&gt;. &lt;code&gt;Backend:debug_info/4&lt;/code&gt; must return &lt;code&gt;{ok, Code}&lt;/code&gt; or &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 청크에 저장된 형식 입니다. 백엔드에서 특정 코드 표현을 검색하려면 &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; 를 호출해야합니다. &lt;code&gt;Format&lt;/code&gt; 과 같은 원자이다 &lt;code&gt;erlang_v1&lt;/code&gt; 얼랑 추상적 포맷 용 또는 &lt;code&gt;core_v1&lt;/code&gt; 코어 얼랑 대. &lt;code&gt;Module&lt;/code&gt; 은 빔 파일로 표시되는 모듈이고 &lt;code&gt;Data&lt;/code&gt; 는 디버그 정보 청크에 저장된 값입니다. &lt;code&gt;Opts&lt;/code&gt; 는 &lt;code&gt;Backend&lt;/code&gt; 에서 지원하는 모든 값 목록입니다 . &lt;code&gt;Backend:debug_info/4&lt;/code&gt; 는 &lt;code&gt;{ok, Code}&lt;/code&gt; 또는 &lt;code&gt;{error, Term}&lt;/code&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8e6ead11c3e1eac26901161b759833474cba3a4" translate="yes" xml:space="preserve">
          <source>The formatter information consist of a formatter module, &lt;code&gt;FModule&lt;/code&gt; and its configuration, &lt;code&gt;FConfig&lt;/code&gt;. &lt;code&gt;FModule&lt;/code&gt; must export the following function, which can be called by the handler:</source>
          <target state="translated">포맷터 정보는 포맷터 모듈 &lt;code&gt;FModule&lt;/code&gt; 및 해당 구성 &lt;code&gt;FConfig&lt;/code&gt; 로 구성 됩니다 . &lt;code&gt;FModule&lt;/code&gt; 은 핸들러에서 호출 할 수있는 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="d115f8a8e36f58c079d74b58f98933595ecc3ef9" translate="yes" xml:space="preserve">
          <source>The formatter information for a handler is set as a part of its configuration when the handler is added. It can also be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt;, which overwrites the current formatter information, or with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, which only modifies the formatter configuration.</source>
          <target state="translated">핸들러의 포맷터 정보는 핸들러가 추가 될 때 구성의 일부로 설정됩니다. 런타임 중에 현재 포맷터 정보를 겹쳐 쓰는 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt; 또는 포맷터 구성 만 수정하는 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31df239ad5b8271efa81cda13e999773cde8976a" translate="yes" xml:space="preserve">
          <source>The formatter information is specified when adding the handler. The formatter configuration can be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, or the complete formatter information can be overwritten with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러를 추가 할 때 포맷터 정보가 지정됩니다. 포맷터 구성은 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 변경하거나 전체 포맷터 정보를 예를 들어 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt; 로 겹쳐 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8f30a9a1bf44181155aa2e71449137d3512f394" translate="yes" xml:space="preserve">
          <source>The formatting succeeded.</source>
          <target state="translated">포맷이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="10bd3287c5d5cb11c97ef91fb582e7bddc5c508a" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;code&gt;NULL&lt;/code&gt; is ignored. It was earlier used for the deprecated &lt;code&gt;reload&lt;/code&gt; callback which is no longer supported since OTP 20.</source>
          <target state="translated">네 번째 인수 &lt;code&gt;NULL&lt;/code&gt; 은 무시됩니다. 더 이상 사용되지 않는 &lt;code&gt;reload&lt;/code&gt; 콜백에 사용 되었으며 OTP 20부터 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd6d48968ca41cf916b0c1706ee59abd18b5be81" translate="yes" xml:space="preserve">
          <source>The fourth argument is a pointer to an &lt;code&gt;in_addr&lt;/code&gt; struct with the IP address of the host.</source>
          <target state="translated">네 번째 인수는 호스트의 IP 주소를 가진 &lt;code&gt;in_addr&lt;/code&gt; 구조체에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="e236ba0b32b561d73bf0d206f0aebabfe0c3ba82" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. For the available options, see &lt;code&gt;gen_statem:start_link/3&lt;/code&gt;.</source>
          <target state="translated">네 번째 인수 인 &lt;code&gt;[]&lt;/code&gt; 는 옵션 목록입니다. 사용 가능한 옵션은 &lt;code&gt;gen_statem:start_link/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ce7182b37b9940508d39bc849560d216ed57126" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. See the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page for available options.</source>
          <target state="translated">네 번째 인수 인 &lt;code&gt;[]&lt;/code&gt; 는 옵션 목록입니다. 사용 가능한 옵션 은 &lt;code&gt;gen_server(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9100d905b13d1377220d70070d7d60982d6749a4" translate="yes" xml:space="preserve">
          <source>The framework consists of:</source>
          <target state="translated">프레임 워크는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8d31fc362ef9b832d0b697fa5e6ecb8f8d5cf1" translate="yes" xml:space="preserve">
          <source>The full log entry is composed according to the &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 로그 항목은 &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt; 에 따라 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="700f5d03995315807276176315f6bb17647929bf" translate="yes" xml:space="preserve">
          <source>The full name for the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 에 대한 Solaris 표준 구성 파일의 전체 이름</target>
        </trans-unit>
        <trans-unit id="0e81e9ea5253fb51f8c99babc5aff5902bbe7489" translate="yes" xml:space="preserve">
          <source>The full name of the binary executable file is derived from the position of application &lt;code&gt;os_mon&lt;/code&gt; in the file system by adding &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt;. The generic full name of the binary executable file is thus:</source>
          <target state="translated">이진 실행 파일의 전체 이름은 &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt; 를 추가하여 파일 시스템에서 &lt;code&gt;os_mon&lt;/code&gt; 응용 프로그램의 위치에서 파생됩니다 . 바이너리 실행 파일의 일반적인 전체 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="563d73d181f3e9108cba87d81726b482ec3d260c" translate="yes" xml:space="preserve">
          <source>The full name of the minor log file (that is, the name of the file including the absolute directory path) can be read during execution of the test case. It comes as value in tuple &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list (which means it can also be read by a pre- or post &lt;code&gt;Common Test Hook&lt;/code&gt; function). Also, at the start of a test case, this data is sent with an event to any installed event handler. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스 실행 중에 부 로그 파일의 전체 이름 (즉, 절대 디렉토리 경로를 포함한 파일 이름)을 읽을 수 있습니다. 그것은 튜플의 값으로 제공 &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; 의 &lt;code&gt;Config&lt;/code&gt; (그것도 사전에 의해 읽거나 게시 할 수 있음을 의미하는 목록 &lt;code&gt;Common Test Hook&lt;/code&gt; 기능). 또한 테스트 사례가 시작될 때이 데이터는 이벤트와 함께 설치된 모든 이벤트 핸들러로 전송됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="add619cb56fecf8eaa2173268a66512e2ca14e79" translate="yes" xml:space="preserve">
          <source>The full path to the &lt;code&gt;erlsrv.exe&lt;/code&gt;, which can be used to manipulate the service. This comes in handy when defining a heart command for your service.</source>
          <target state="translated">서비스를 조작하는 데 사용할 수있는 &lt;code&gt;erlsrv.exe&lt;/code&gt; 의 전체 경로 입니다. 서비스에 대한 핵심 명령을 정의 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="504f71220986791fe2ea8dea00b27516f0e65c24" translate="yes" xml:space="preserve">
          <source>The fun &lt;code&gt;F&lt;/code&gt; can be evaluated with the following syntax:</source>
          <target state="translated">fun &lt;code&gt;F&lt;/code&gt; 는 다음 구문으로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8ca975ecc3e8edf173345a968b651e47f611e5" translate="yes" xml:space="preserve">
          <source>The fun can have many clauses. Assume that we want to do the following:</source>
          <target state="translated">재미는 많은 절을 가질 수 있습니다. 다음을 수행한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc8a3f1e4f51084c68a1c0c777f1a27337cb3c" translate="yes" xml:space="preserve">
          <source>The fun has the following type specification:</source>
          <target state="translated">재미는 다음과 같은 유형 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f32b8a5a9bbfbf624a0644c5247fde5edb3a429" translate="yes" xml:space="preserve">
          <source>The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple. It must use the &lt;code&gt;is_&lt;/code&gt; guard tests. Language constructs that have no representation in a match specification (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt;, and so on) are not allowed.</source>
          <target state="translated">재미는 매우 제한적이며 단일 변수 또는 일치하는 단일 매개 변수 (단일 변수 또는 튜플) 만 사용할 수 있습니다. &lt;code&gt;is_&lt;/code&gt; guard 테스트를 사용해야합니다 . 일치 스펙에 표현이없는 언어 구문 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 등)은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71d9e7bf1fc41cd7eae3c3b2faa71bd3df3e1269" translate="yes" xml:space="preserve">
          <source>The fun must be defined as:</source>
          <target state="translated">재미는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07c9bc55442a1b08276f48311f68a88a3fb5ef18" translate="yes" xml:space="preserve">
          <source>The fun must be literally constructed inside the parameter list to the pseudo functions. The fun cannot be bound to a variable first and then passed to &lt;code&gt;ets:fun2ms/1&lt;/code&gt; or &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;. For example, &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; works, but not &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt;. The latter results in a compile-time error if the header is included, otherwise a runtime error.</source>
          <target state="translated">재미는 말 그대로 매개 변수 목록 내에서 의사 함수로 구성되어야합니다. fun은 변수에 먼저 바인딩 된 다음 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 또는 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 로 전달할 수 없습니다 . 예를 들어, &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; 는 작동하지만 &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt; 는 작동하지 않습니다 . 후자는 헤더가 포함되어 있으면 컴파일 타임 오류가 발생하고 그렇지 않으면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fc65e668d470b6dcc72f27bda164d6dff73c81" translate="yes" xml:space="preserve">
          <source>The fun must handle the following arguments:</source>
          <target state="translated">재미는 다음 인수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="737c0846a588f1657ff7845917aac0579f2be1af" translate="yes" xml:space="preserve">
          <source>The fun returns the root certificate and certificate chain that has signed the CRL.</source>
          <target state="translated">이 재미는 CRL에 서명 한 루트 인증서 및 인증서 체인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efd695af69ad480c89612803c86acd8baa7d18ec" translate="yes" xml:space="preserve">
          <source>The fun should return:</source>
          <target state="translated">재미는 돌아와야한다 :</target>
        </trans-unit>
        <trans-unit id="d737e56a33d9100f6b6abcd80be538364e25ad0c" translate="yes" xml:space="preserve">
          <source>The fun uses the information in the distribution point to access the latest possible version of the CRL. If this fun is not specified, Public Key uses the default implementation:</source>
          <target state="translated">재미는 배포 지점의 정보를 사용하여 가능한 최신 버전의 CRL에 액세스합니다. 이 재미를 지정하지 않으면 공개 키는 기본 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f1a8e313c80aee065197a6cfd60c195f83fb231" translate="yes" xml:space="preserve">
          <source>The funcion &lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; is performed as an atomic operation although it is not protected by a transaction. Therfore no table update is lost if two processes simultaneously execute the function &lt;code&gt;dirty_update_counter/2&lt;/code&gt;.</source>
          <target state="translated">funcion &lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; 는 트랜잭션에 의해 보호되지 않지만 원 자성 작업으로 수행됩니다. 따라서 두 프로세스가 &lt;code&gt;dirty_update_counter/2&lt;/code&gt; 함수를 동시에 실행하면 테이블 업데이트가 손실되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0013b0c35bbaebef0c54217eeb1d56ac822fe5f" translate="yes" xml:space="preserve">
          <source>The function 'undefined' that has called &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; is an unknown function because that call was not recorded in the trace. It was only recorded that the execution returned from &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; to some other function above in the call stack, or that the process exited from there.</source>
          <target state="translated">&lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 를 호출 한 'undefined' 함수는 해당 호출이 추적에 기록되지 않았으므로 알 수없는 함수입니다. 실행이 &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 에서 호출 스택의 위의 다른 함수 로 리턴 되었거나 프로세스가 종료 된 것으로 기록되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae773ba648b2dd3111bf9ff1bd1ae44f3998a92d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter requires to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 는 직경 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 을 Erlang 소스로 컴파일하는 데 사용됩니다 . 결과 소스는 사전의 메시지와 AVP를 인코딩하고 디코딩하는 데 필요한 인터페이스 직경을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b1eeb1350e2bae25f92e23b1d2b563721196dfbc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; returns the tuple &lt;code&gt;{aborted,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is the tuple &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; 튜플 반환 &lt;code&gt;{aborted,Reason}&lt;/code&gt; , &lt;code&gt;Reason&lt;/code&gt; 튜플이다 &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab82066f7afa34b039ac973980ff4ef53ba41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; returns the term &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt;, which is an error description suitable for display.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; 용어 반환 &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt; 디스플레이에 적합한 오류 설명이다.</target>
        </trans-unit>
        <trans-unit id="416085a9cc04b82b99ed7eea9c9814ce71342d35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; can be used to retrieve the result of the latest periodic memory check.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 최신주기 메모리 점검 결과를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d90d9bd2e78e7f66c786fdc154ab3630fd58d990" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; and the constructor functions &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; 함수 와 생성자 함수 &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; 는 구문 트리를 탐색하고 모든 하위 트리를 방문하지만 대부분 또는 모든 경우에 균일 한 방식으로 트리 노드를 처리하려는 경우 큰 도움이 될 수 있습니다. . 이러한 함수를 사용하면 코드가 명시 적으로 처리되지 않은 모든 노드 유형이 기본 사례로 유지 될 수 있으므로 코드가 구문 트리 데이터 유형의 확장에 지나치게 민감하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9d557c07ad7843b1aa33917e03437c2191df84" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; returns one of the following values:</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; 다음 값 중 하나를 반환 :</target>
        </trans-unit>
        <trans-unit id="7829e947c9fda3671f982c368ab35a66949366af" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; returns all keys in a table.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; 테이블의 모든 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29d2bb31f2eb0b09a4594530fbd096f08be20052" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; activates a new checkpoint that covers all &lt;code&gt;Mnesia&lt;/code&gt; tables with maximum degree of redundancy and performs a backup. Maximum redundancy means that each table replica has a checkpoint retainer. Tables with property &lt;code&gt;local_contents&lt;/code&gt; are backed up as they look on the current node.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; 새로운 체크 포인트를 활성화하는 모든 표지 &lt;code&gt;Mnesia&lt;/code&gt; 의 이중화 행하고 백업의 최대치와 테이블. 최대 중복성은 각 테이블 복제본에 체크 포인트 보유자가 있음을 의미합니다. &lt;code&gt;local_contents&lt;/code&gt; 특성이있는 테이블 은 현재 노드를 볼 때 백업됩니다.</target>
        </trans-unit>
        <trans-unit id="36376c0ad23644747aaadff922c6c829e1451912" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. When executing this function, it returns one of the following responses:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 함수는 테이블을 생성합니다. 이 함수를 실행할 때 다음 응답 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6864b3dbbae165f2d507c1a853d0af094ec0c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; creates a brand new fragmented table, by setting table property &lt;code&gt;frag_properties&lt;/code&gt; to some proper values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 함수는 테이블 속성 &lt;code&gt;frag_properties&lt;/code&gt; 를 적절한 값 으로 설정하여 새로운 조각 테이블을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fd24999a16cc29e37c736949b94f5785cba2b786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; deletes a fragmented table including all its fragments. There must however not exist any other fragmented tables that refer to this table in their foreign key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; 함수 는 모든 조각을 포함하여 조각난 테이블을 삭제합니다. 그러나 외래 키에서이 테이블을 참조하는 다른 조각화 된 테이블이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="30691173c7709ef9a4f3af204d9b1fcd4e7de68a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; can be used to dump RAM table replicas to disc.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 RAM 테이블 복제본을 디스크에 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bca628c2f6585264d68c5ff447dbb6e315d490b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to force load the table regardless of which table load mechanism that is activated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 함수 는 활성화 된 테이블로드 메커니즘에 관계없이 테이블을 강제로드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da340c660c7601de0e1ab6532b1b4defd72ac7f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; can now be used to print some system information even before &lt;code&gt;Mnesia&lt;/code&gt; is started. When &lt;code&gt;Mnesia&lt;/code&gt; is started, the function prints more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작 되기 전에도 일부 시스템 정보를 인쇄 할 수 있습니다 . 때 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작되고 기능이 추가 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="60a3e9499c0d1ca23244a4d32bf0a317d6112fb3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; installs a backup as fallback. It uses the backup module &lt;code&gt;Mod&lt;/code&gt;, or the default backup module, to access the backup media. The function returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, Reason}&lt;/code&gt; if there is an error.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; 대체로서 백업을 설치한다. 백업 모듈 &lt;code&gt;Mod&lt;/code&gt; 또는 기본 백업 모듈을 사용하여 백업 미디어에 액세스합니다. 이 함수는 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환 하고 오류가 있으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f2ed7053b64d799ffc3ded34968b7ea59f0d544" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; is intended to support table locks (as mentioned previously) but also for situations when locks need to be acquired regardless of how tables have been replicated:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; 함수 는 테이블 잠금을 지원하기위한 것이며 (앞서 언급 한대로) 테이블 복제 방법에 관계없이 잠금을 획득해야하는 상황에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a04c9c87e126ea98a8324770baffee72b7c15012" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; lacks some important features that &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; have. For example, &lt;code&gt;mnesia:match_object/3&lt;/code&gt; can only return the matching records, and it cannot express constraints other than equality. To find the names of the male employees on the second floor:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 함수에는 mnesia : select / 3의 중요한 기능이 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; . 예를 들어, &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 는 일치하는 레코드 만 반환 할 수 있으며 동등 이외의 제약 조건을 표현할 수 없습니다. 2 층에서 남성 직원의 이름을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0917cc1d0fa48c8f542630d30c1cd7b2345a64a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; sets master nodes for all tables. For each table it determines its replica nodes and starts &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; with those replica nodes that are included in the &lt;code&gt;Nodes&lt;/code&gt; list (that is, &lt;code&gt;TabNodes&lt;/code&gt; is the intersection of &lt;code&gt;Nodes&lt;/code&gt; and the replica nodes of the table). If the intersection is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; 함수 는 모든 테이블에 대한 마스터 노드를 설정합니다. 각 테이블에 대해 복제본 노드를 결정하고 &lt;code&gt;Nodes&lt;/code&gt; 목록에 포함 된 복제본 노드와 함께 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; 를 시작 합니다 (즉, &lt;code&gt;TabNodes&lt;/code&gt; 는 &lt;code&gt;Nodes&lt;/code&gt; 와 테이블의 복제본 노드의 교차점입니다 ). 교차점이 비어 있으면 특정 테이블의 마스터 노드 복구 메커니즘이 재설정되고 다음에 다시 시작할 때 일반로드 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3124976c6cc4afa58829120e681ccee3319f8f32" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 함수 는 두 노드에서 모두 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="362b910adc258b676d8a22204af77b93afeab4c8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; stops &lt;code&gt;Mnesia&lt;/code&gt; on the node where the function is executed. The functions &lt;code&gt;mnesia:start/0&lt;/code&gt; and &lt;code&gt;mnesia:stop/0&lt;/code&gt; work on the &quot;local&quot; &lt;code&gt;Mnesia&lt;/code&gt; system. No functions start or stop a set of nodes.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; 정지 &lt;code&gt;Mnesia&lt;/code&gt; 을 함수가 실행되는 노드. 기능은 &lt;code&gt;mnesia:start/0&lt;/code&gt; 및 &lt;code&gt;mnesia:stop/0&lt;/code&gt; 은 &quot;로컬&quot;작업을 &lt;code&gt;Mnesia&lt;/code&gt; 의 시스템. 노드 세트를 시작하거나 중지하는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5acaf5a283731e99e901e6928e2526a7dcf95f24" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; now understands item &lt;code&gt;frag_properties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; 함수는 이제 &lt;code&gt;frag_properties&lt;/code&gt; 항목을 이해 합니다.</target>
        </trans-unit>
        <trans-unit id="a1334bf42da6253566700391caa3cba76ccf9209" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Callback:read_config/1&lt;/code&gt; is to be exported from the callback module to read configuration data, initially before the tests start, or as a result of data being reloaded during test execution. The input argument is the same as for function &lt;code&gt;check_parameter/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Callback:read_config/1&lt;/code&gt; 함수 는 콜백 모듈에서 익스포트되어 테스트가 시작되기 전에 또는 테스트 실행 중에 데이터가 다시로드 된 결과로 구성 데이터를 읽습니다. 입력 인수는 &lt;code&gt;check_parameter/1&lt;/code&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7fbf758a3229cc65bafd27a8b6bc7ae6dded54d7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">함수 &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; 테스트 세트를 생성하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="41ef4085ec8a8d22de70a87050ca088731db21f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;check_process_code/3&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;check_process_code/3&lt;/code&gt; 함수 는 요청이 전송 된 직후 &lt;code&gt;async&lt;/code&gt; 값을 리턴합니다 . 요청이 처리되면이 함수를 호출 한 프로세스에 &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt; 형식의 메시지가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6002fc8f958da3877d27d37d914957a73927e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;company:init/0&lt;/code&gt; creates the tables. Two tables are of type &lt;code&gt;bag&lt;/code&gt;. This is the &lt;code&gt;manager&lt;/code&gt; relation as well the &lt;code&gt;in_proj&lt;/code&gt; relation. This is interpreted as: an employee can be manager over several departments, and an employee can participate in several projects. However, the &lt;code&gt;at_dep&lt;/code&gt; relation is &lt;code&gt;set&lt;/code&gt;, as an employee can only work in one department. In this data model, there are examples of relations that are 1-to-1 (&lt;code&gt;set&lt;/code&gt;) and 1-to-many (&lt;code&gt;bag&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;company:init/0&lt;/code&gt; 함수 는 테이블을 작성합니다. 두 개의 테이블은 &lt;code&gt;bag&lt;/code&gt; 유형 입니다. 이것은 &lt;code&gt;in_proj&lt;/code&gt; 관계 뿐만 아니라 &lt;code&gt;manager&lt;/code&gt; 관계입니다. 직원은 여러 부서의 관리자 일 수 있으며 직원은 여러 프로젝트에 참여할 수 있습니다. 그러나 직원은 한 부서에서만 작업 할 수 있으므로 &lt;code&gt;at_dep&lt;/code&gt; 관계가 &lt;code&gt;set&lt;/code&gt; 됩니다. 이 데이터 모델에는 일대일 ( &lt;code&gt;set&lt;/code&gt; ) 및 일대 다 ( &lt;code&gt;bag&lt;/code&gt; ) 인 관계의 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b3a72aa7ba46bfc3b05ebd94c234d7bb780fb0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;erl_decode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; converts the binary into an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">함수 &lt;code&gt;erl_decode()&lt;/code&gt; 에서 &lt;code&gt;erl_marshal&lt;/code&gt; 는 로 이진 변환 &lt;code&gt;ETERM&lt;/code&gt; 의 구조체 :</target>
        </trans-unit>
        <trans-unit id="c72f7b6a5b6f347ed0767231df7d01b1b2dde191" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform any necessary clean-up.</source>
          <target state="translated">MIB가 에이전트에서 언로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이렇게하면 필요한 정리 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af08e789dab44b8458cb66f5d674a989015f5322" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform necessary clean-up.</source>
          <target state="translated">MIB가 에이전트에서 언로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 필요한 청소를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b6c8f67651723c9f3e56c22f4f4ab0b1c577a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; is called when a get-request or a get-next request refers to the variable.</source>
          <target state="translated">함수 &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; 는 get-request 또는 get-next 요청이 변수를 참조 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7f44a9f942983582de9a504377c1237da5bfe42a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-request refers to a table.</source>
          <target state="translated">get-request가 테이블을 참조 할 때 함수 &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f9472e8e9d7e877a982c1ad293026a6058a914d6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-next- or a get-bulk-request refers to the table.</source>
          <target state="translated">get-next- 또는 get-bulk-request가 테이블을 참조 할 때 &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dc9c0fe89d1c4041733fa53cdcec2b986419a3b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that the new value can be checked for inconsistencies.</source>
          <target state="translated">함수 &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; 는 설정 요청 처리의 1 단계에서 호출되므로 새 값이 일치하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d16c30ff848f270285384e5cc25e325a037b629" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that new values can be checked for inconsistencies.</source>
          <target state="translated">함수 &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 는 설정 요청 처리의 1 단계에서 호출되므로 새 값이 불일치인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5330b2475c665d4944e0a229f93d0602e0e5fa" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is loaded into the agent. This makes it possible to perform the necessary initialization.</source>
          <target state="translated">MIB가 에이전트에로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이를 통해 필요한 초기화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1ebb83f7fcf0843f0835365552c7f4c0cad7ca" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each variable in the MIB when the MIB is loaded into the agent. This makes it possible to perform necessary initialization.</source>
          <target state="translated">MIB가 에이전트에로드 될 때 MIB의 각 변수에 대해 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이를 통해 필요한 초기화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="133213fffa730c11eb89996e85007a915e9f1756" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function did not exist, or returned &lt;code&gt;{noError, 0}&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 는 세트 요청 처리의 2 단계에서 세트를 수행하기 위해 호출됩니다. 해당 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 존재하지 않거나 &lt;code&gt;{noError, 0}&lt;/code&gt; 리턴 한 경우에만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="beb994d1c8d031347e7906599f79761b788164a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;find_max_and_min&lt;/code&gt; works out the maximum and minimum temperature. A new construct, &lt;code&gt;if&lt;/code&gt;, is introduced here. If works as follows:</source>
          <target state="translated">&lt;code&gt;find_max_and_min&lt;/code&gt; 함수 는 최대 및 최소 온도를 계산합니다. 새로운 구문 인 &lt;code&gt;if&lt;/code&gt; 가 여기에 소개됩니다. 다음과 같이 작동하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e3c365109eb0604df295111a6b478883a0063173" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foreach&lt;/code&gt; expresses this similarity:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 함수 는 다음과 같은 유사성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32b248029fdb79694c3f91257a1b49d6e08c1720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format/2&lt;/code&gt; (that is, &lt;code&gt;format&lt;/code&gt; with two arguments) takes two lists. The first one is nearly always a list written between &quot; &quot;. This list is printed out as it is, except that each ~w is replaced by a term taken in order from the second list. Each ~n is replaced by a new line. The &lt;code&gt;io:format/2&lt;/code&gt; function itself returns the atom &lt;code&gt;ok&lt;/code&gt; if everything goes as planned. Like other functions in Erlang, it crashes if an error occurs. This is not a fault in Erlang, it is a deliberate policy. Erlang has sophisticated mechanisms to handle errors which are shown later. As an exercise, try to make &lt;code&gt;io:format&lt;/code&gt; crash, it should not be difficult. But notice that although &lt;code&gt;io:format&lt;/code&gt; crashes, the Erlang shell itself does not crash.</source>
          <target state="translated">함수 &lt;code&gt;format/2&lt;/code&gt; (즉, 두 개의 인수가있는 &lt;code&gt;format&lt;/code&gt; )는 두 개의 목록을 갖습니다. 첫 번째는 거의 항상 &quot;&quot;사이에 작성된 목록입니다. 이 목록은 각 ~ w가 두 번째 목록에서 순서대로 가져온 용어로 대체된다는 점을 제외하고는 그대로 인쇄됩니다. 각 ~ n은 새 줄로 바뀝니다. &lt;code&gt;io:format/2&lt;/code&gt; 함수 자체는 원자 반환 &lt;code&gt;ok&lt;/code&gt; 계획대로 모든 것이 진행합니다. Erlang의 다른 기능과 마찬가지로 오류가 발생하면 충돌합니다. 이것은 Erlang의 결함이 아니며, 의도적 인 정책입니다. Erlang은 나중에 보여지는 오류를 처리하는 정교한 메커니즘을 가지고 있습니다. 실습으로 &lt;code&gt;io:format&lt;/code&gt; 충돌을 시도해보십시오 . 어렵지 않아야합니다. 그러나 &lt;code&gt;io:format&lt;/code&gt; 이지만 Erlang 쉘 자체가 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3aac06ca8d394b3646df1b427f505d8cf51b76fc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/1&lt;/code&gt; is deprecated and will be removed in next version.</source>
          <target state="translated">&lt;code&gt;g/1&lt;/code&gt; 기능 은 더 이상 사용되지 않으며 다음 버전에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="88abc7d88e609edf90b5266ee54f52aa2a6dcc51" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/2&lt;/code&gt; is deprecated and will be removed in next major release.</source>
          <target state="translated">&lt;code&gt;g/2&lt;/code&gt; 기능 은 더 이상 사용되지 않으며 다음 주요 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="81d897d03e553a2581073072bbd55d8966c2a444" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/3&lt;/code&gt; is deprecated and will eventually be removed.</source>
          <target state="translated">&lt;code&gt;g/3&lt;/code&gt; 함수 는 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dd9a50875733e809d1405bf85bfdecd386ca67c2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;garbage_collect/2&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;garbage_collect/2&lt;/code&gt; 함수 는 요청이 전송 된 직후 &lt;code&gt;async&lt;/code&gt; 값을 반환합니다 . 요청이 처리되면이 함수를 호출 한 프로세스에 &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt; 형식의 메시지가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd04d9687a79d761d32b2c43de1576259fb5f864" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert_emp/3&lt;/code&gt; creates a Functional Object (Fun). &lt;code&gt;Fun&lt;/code&gt; is passed as a single argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt;. This means that &lt;code&gt;Fun&lt;/code&gt; is run as a transaction with the following properties:</source>
          <target state="translated">함수 &lt;code&gt;insert_emp/3&lt;/code&gt; 은 기능적 개체 (재미)를 생성한다. &lt;code&gt;Fun&lt;/code&gt; 은 함수 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt; 단일 인수로 전달됩니다 . 즉, &lt;code&gt;Fun&lt;/code&gt; 은 다음 속성을 가진 트랜잭션으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ea55fdab4365faa7f773834a49baba846da23b95" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; is intended to be used for reconfiguration of fragmented tables. Argument &lt;code&gt;Change&lt;/code&gt; is to have one of the following values:</source>
          <target state="translated">&lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; 함수 는 조각난 테이블의 재구성에 사용됩니다. 인수 &lt;code&gt;Change&lt;/code&gt; 은 다음 값 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b1c90e4ee481c7da73002efc510d14130a3a01a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:dirty_*&lt;/code&gt; always executes with &lt;code&gt;async_dirty&lt;/code&gt; semantics regardless of which activity access contexts that are started. It can even start contexts without any enclosing activity access context.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_*&lt;/code&gt; 함수 는 시작된 활동 액세스 컨텍스트에 관계없이 항상 &lt;code&gt;async_dirty&lt;/code&gt; 시맨틱으로 실행됩니다 . 또한 주변 액티비티 액세스 컨텍스트없이 컨텍스트를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670d344917e31e9f9f7bd59eee0e7cb0d02a6cdf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:lock/2&lt;/code&gt; is intended to support explicit locking on tables, but is also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two kinds of &lt;code&gt;LockKind&lt;/code&gt; are supported:</source>
          <target state="translated">&lt;code&gt;mnesia:lock/2&lt;/code&gt; 함수 는 테이블에 대한 명시 적 잠금을 지원하기위한 것이지만 테이블 복제 방법에 관계없이 잠금을 획득해야하는 상황을위한 것입니다. 현재 두 종류의 &lt;code&gt;LockKind&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d77603a1f02efb7a0e1f99f991914c28109971d3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:match_object/3&lt;/code&gt; automatically uses indexes if these exist. However, no heuristics are performed to select the best index.</source>
          <target state="translated">&lt;code&gt;mnesia:match_object/3&lt;/code&gt; 함수 는 인덱스가 존재하면 자동으로 인덱스를 사용합니다. 그러나 최상의 인덱스를 선택하기위한 휴리스틱은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6edabfd9b5590580f8f9657171a96caa4b74ebe3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;new/4&lt;/code&gt; creates a new map term and lets the keys &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, and &lt;code&gt;alpha&lt;/code&gt; be associated with an initial value. In this case, only float values between and including 0.0 and 1.0 are allowed, as ensured by the &lt;code&gt;?is_channel/1&lt;/code&gt; macro for each argument. Only the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is allowed when creating a new map.</source>
          <target state="translated">&lt;code&gt;new/4&lt;/code&gt; 함수 는 새로운 맵 용어를 작성하고 &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; 및 &lt;code&gt;alpha&lt;/code&gt; 키를 초기 값과 연관시킵니다. 이 경우 각 인수에 대해 &lt;code&gt;?is_channel/1&lt;/code&gt; 매크로에 의해 보장되는 0.0과 1.0 사이의 float 값만 허용됩니다 . 새 맵을 만들 때는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e4f0d7c8457880dafad073945fded626331720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pyth(N)&lt;/code&gt; generates a list of all integers &lt;code&gt;{A,B,C}&lt;/code&gt; such that &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; and where the sum of the sides is equal to, or less than, &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">함수 &lt;code&gt;pyth(N)&lt;/code&gt; 모든 정수의리스트를 생성한다 &lt;code&gt;{A,B,C}&lt;/code&gt; 되도록 &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; 측면의 합, 또는 이하와 같고, &lt;code&gt;N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6137179b93256e30bc3aeec2790f9eeac4bbcd5d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise/2&lt;/code&gt; contains a Fun made up of four code lines. This Fun is called by the statement &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; and returns a value.</source>
          <target state="translated">&lt;code&gt;raise/2&lt;/code&gt; 함수 는 4 개의 코드 라인으로 구성된 Fun을 포함합니다. 이 Fun은 &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; 문에 의해 호출되며 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99cf9b671e2d9b419e9dca0fedf06d36961f6433" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise_females/1&lt;/code&gt; returns the tuple &lt;code&gt;{atomic, Number}&lt;/code&gt;, where &lt;code&gt;Number&lt;/code&gt; is the number of female employees who received a salary increase. If an error occurs, the value &lt;code&gt;{aborted, Reason}&lt;/code&gt; is returned, and &lt;code&gt;Mnesia&lt;/code&gt; guarantees that the salary is not raised for any employee.</source>
          <target state="translated">함수 &lt;code&gt;raise_females/1&lt;/code&gt; 반환 튜플 &lt;code&gt;{atomic, Number}&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 급여 인상을받은 여성 직원의 수입니다. 오류가 발생하면 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 값 이 반환되고 &lt;code&gt;Mnesia&lt;/code&gt; 는 직원에 대해 급여가 인상되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a03f0af918ed9a2c831249c7c193fd4857632c71" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;select&lt;/code&gt; can be used to add more constraints and create output that cannot be done with &lt;code&gt;mnesia:match_object/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 함수 는 더 많은 제한 조건을 추가하고 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 로 수행 할 수없는 출력을 작성하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a509a3ad87b3c1678e41395b1c17d5a940026b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_message/3&lt;/code&gt; will only be called if the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option has been set to the value &lt;code&gt;flag&lt;/code&gt;. The third argument, &lt;code&gt;Resend&lt;/code&gt; then indicates if the message send is a resend or not.</source>
          <target state="translated">&lt;code&gt;send_message/3&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; 구성 옵션이 value &lt;code&gt;flag&lt;/code&gt; 로 설정된 경우에만 호출됩니다 . 세 번째 인수 인 &lt;code&gt;Resend&lt;/code&gt; 는 메시지 전송이 다시 전송되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7470406d16d9455cca5984d08f7d4c3396313445" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_trap&lt;/code&gt; is kept for backwards compatibility and should not be used in new code. Applications that use this function will continue to work. The &lt;code&gt;snmpNotifyName&lt;/code&gt; is used as the community string by the agent when a notification is sent.</source>
          <target state="translated">&lt;code&gt;send_trap&lt;/code&gt; 함수 는 이전 버전과의 호환성을 위해 유지되므로 새 코드에서 사용해서는 안됩니다. 이 기능을 사용하는 응용 프로그램은 계속 작동합니다. &lt;code&gt;snmpNotifyName&lt;/code&gt; 는 통지를 보낼 때 에이전트에 의해 커뮤니티 문자열로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="103c9badd4ad12f4e6468c8e8de6801ce063239b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;start&lt;/code&gt; first creates a process, let us call it &quot;pong&quot;:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 함수는 먼저 프로세스를 생성하고 &quot;퐁&quot;이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="eb32c2f2d1549c3a5030e2171eab2d919298928c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;subsystem/4&lt;/code&gt; and subsequent calls of &lt;code&gt;send/3,4,5&lt;/code&gt; must be executed in the same process.</source>
          <target state="translated">기능 &lt;code&gt;subsystem/4&lt;/code&gt; 및 후속 &lt;code&gt;send/3,4,5&lt;/code&gt; 호출은 동일한 프로세스에서 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="338ff9986a9cbcb124e3833af89e3fbd5600e24b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:create/1&lt;/code&gt; performs the following:</source>
          <target state="translated">&lt;code&gt;target_system:create/1&lt;/code&gt; 함수 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0cd28e869f41fdc007104b6030c49cc7a75a7292" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:install/2&lt;/code&gt; performs the following:</source>
          <target state="translated">&lt;code&gt;target_system:install/2&lt;/code&gt; 기능 은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4199649f879206d3b2fa3c3bd5824df5cda6d3e9" translate="yes" xml:space="preserve">
          <source>The function accepts the following parameters:</source>
          <target state="translated">이 함수는 다음 매개 변수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="094a87c2e8a4a6a2a6be76b4ad60bd189810ef39" translate="yes" xml:space="preserve">
          <source>The function arguments are as follows:</source>
          <target state="translated">함수 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8347209966cf7f71c1646053d74ccb363214ea1" translate="yes" xml:space="preserve">
          <source>The function arguments passed to a NIF appears in an array &lt;code&gt;argv&lt;/code&gt;, with &lt;code&gt;argc&lt;/code&gt; as the length of the array, and thus the arity of the function. The Nth argument of the function can be accessed as &lt;code&gt;argv[N-1]&lt;/code&gt;. NIFs also take an environment argument that serves as an opaque handle that is needed to be passed on to most API functions. The environment contains information about the calling Erlang process:</source>
          <target state="translated">NIF에 전달 된 함수 인수는 배열 의 길이 가 &lt;code&gt;argc&lt;/code&gt; 인 함수 &lt;code&gt;argv&lt;/code&gt; 와 함께 배열 argv에 나타납니다 . 함수의 N 번째 인수는 &lt;code&gt;argv[N-1]&lt;/code&gt; 으로 액세스 할 수 있습니다 . NIF는 또한 대부분의 API 함수에 전달해야하는 불투명 한 핸들 역할을하는 환경 인수를 사용합니다. 환경에는 호출 Erlang 프로세스에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa68aed990974c1565915491205a9e47d95de75c" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; deletes node &lt;code&gt;mynode@host&lt;/code&gt; from the &lt;code&gt;Mnesia&lt;/code&gt; system. The call fails if &lt;code&gt;Mnesia&lt;/code&gt; is running on &lt;code&gt;mynode@host&lt;/code&gt;. The other &lt;code&gt;Mnesia&lt;/code&gt; nodes never try to connect to that node again. Notice that if there is a disc resident schema on node &lt;code&gt;mynode@host&lt;/code&gt;, the entire &lt;code&gt;Mnesia&lt;/code&gt; directory is to be deleted. This is done with the function &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Mnesia&lt;/code&gt; is started again on node &lt;code&gt;mynode@host&lt;/code&gt; and the directory has not been cleared, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; 함수 호출 은 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에서 &lt;code&gt;mynode@host&lt;/code&gt; 노드를 삭제합니다 . &lt;code&gt;Mnesia&lt;/code&gt; 가 &lt;code&gt;mynode@host&lt;/code&gt; 에서 실행 중이 면 호출이 실패합니다 . 다른 &lt;code&gt;Mnesia&lt;/code&gt; 노드는 해당 노드에 다시 연결을 시도하지 않습니다. 노드 &lt;code&gt;mynode@host&lt;/code&gt; 에 디스크 상주 스키마가 있으면 전체 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리가 삭제됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt; 함수로 수행됩니다 . 경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 노드에서 다시 시작됩니다 &lt;code&gt;mynode@host&lt;/code&gt; 및 디렉토리가 삭제되지 않았의 동작 &lt;code&gt;Mnesia&lt;/code&gt; 가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc50b6ebf32dde9a3ad360a39afe42dd265bea37" translate="yes" xml:space="preserve">
          <source>The function can also return &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;ignore&lt;/code&gt; 를 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54500a01f09be1a2bd2f0c1abfeddba6e33a00fa" translate="yes" xml:space="preserve">
          <source>The function can be called by a log handler to convert a log event term to a printable string. The returned value can, for example, be printed as a log entry to the console or a file using &lt;code&gt;io:put_chars/1,2&lt;/code&gt;.</source>
          <target state="translated">로그 핸들러를 사용하여 로그 이벤트 용어를 인쇄 가능한 문자열로 변환 할 수 있습니다. 리턴 된 값은 예를 들어 콘솔에 대한 로그 항목 또는 &lt;code&gt;io:put_chars/1,2&lt;/code&gt; 를 사용하여 파일로 인쇄 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c504308064f08c5f9ea9e812d1f6e5a760e998d0" translate="yes" xml:space="preserve">
          <source>The function can be called, for example, when these files are generated at the target. The function is to be called after &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; has been called.</source>
          <target state="translated">예를 들어, 이러한 파일이 대상에서 생성 될 때 함수를 호출 할 수 있습니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 가 호출 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dfcfdf84d3a74a872f6ce266bc40953da7783b4c" translate="yes" xml:space="preserve">
          <source>The function can be used as follows:</source>
          <target state="translated">이 기능은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f3fe03e8503c073eac107ed5ad24dbaeb411a0" translate="yes" xml:space="preserve">
          <source>The function can be used on a running system, or by copying the entire log directory and calling this function. SNMP must be running in order to provide MIB information.</source>
          <target state="translated">이 기능은 실행중인 시스템에서 사용하거나 전체 로그 디렉토리를 복사하고이 기능을 호출하여 사용할 수 있습니다. MIB 정보를 제공하려면 SNMP가 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8fb21fb19b96fc3f558cb35f3055df39d441e2b" translate="yes" xml:space="preserve">
          <source>The function can be used on files opened in &lt;code&gt;raw&lt;/code&gt; mode. However, it is inefficient to use it on &lt;code&gt;raw&lt;/code&gt; files if the file is not opened with option &lt;code&gt;{read_ahead, Size}&lt;/code&gt; specified. Thus, combining &lt;code&gt;raw&lt;/code&gt; and &lt;code&gt;{read_ahead, Size}&lt;/code&gt; is highly recommended when opening a text file for raw line-oriented reading.</source>
          <target state="translated">이 기능은 &lt;code&gt;raw&lt;/code&gt; 모드로 열린 파일에서 사용할 수 있습니다 . 그러나 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 옵션을 지정 하여 파일을 열지 않으면 &lt;code&gt;raw&lt;/code&gt; 파일에서 파일 을 사용하는 것이 비효율적 입니다. 따라서 원시 행 지향 읽기를 위해 텍스트 파일을 열 때는 &lt;code&gt;raw&lt;/code&gt; 및 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 를 결합하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a30119da22bc70b60e3eb0a2546500296120c22" translate="yes" xml:space="preserve">
          <source>The function can return any term. If the event handler is deleted because of a call to &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt;, the return value of that function becomes the return value of this function. If the event handler is to be replaced with another event handler because of a swap, the return value is passed to the &lt;code&gt;init&lt;/code&gt; function of the new event handler. Otherwise the return value is ignored.</source>
          <target state="translated">이 함수는 모든 용어를 반환 할 수 있습니다. &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt; 호출로 인해 이벤트 핸들러가 삭제 되면 해당 함수의 리턴 값이이 함수의 리턴 값이됩니다. 스왑으로 인해 이벤트 핸들러를 다른 이벤트 핸들러로 바꾸면 리턴 값이 새 이벤트 핸들러 의 &lt;code&gt;init&lt;/code&gt; 함수로 전달됩니다 . 그렇지 않으면 반환 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ed95f32e82d2850058944611e44392a4e4ff3345" translate="yes" xml:space="preserve">
          <source>The function can return numerous errors, some can only be returned given a certain combination of options.</source>
          <target state="translated">이 함수는 수많은 오류를 반환 할 수 있으며 일부 옵션은 특정 조합으로 만 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea57ec1a4ff4fb3ef55b1134a75586251178e601" translate="yes" xml:space="preserve">
          <source>The function can return the following error conditions, all well specified (no opaque values):</source>
          <target state="translated">이 함수는 다음과 같은 오류 조건을 반환 할 수 있습니다. 모두 올바르게 지정되어 있습니다 (불투명 값 없음).</target>
        </trans-unit>
        <trans-unit id="c5c489b2375429e225473997aebd4b0f058730b3" translate="yes" xml:space="preserve">
          <source>The function cannot be found when evaluating a function call.</source>
          <target state="translated">함수 호출을 평가할 때 함수를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="900b2cc1343be73658d225cf863655824f14c352" translate="yes" xml:space="preserve">
          <source>The function check provides an error tuple if Unicode code points &amp;gt; 255 are to be returned if the client requested &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 &lt;code&gt;latin1&lt;/code&gt; 을 요청한 경우 유니 코드 코드 포인트&amp;gt; 255가 리턴되는 경우 함수 점검은 오류 튜플을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f0030f1dc39e1c15798593d550e2c64df3c720" translate="yes" xml:space="preserve">
          <source>The function creates a copy of &lt;code&gt;channel.erl&lt;/code&gt; where it for each executable line is specified how many times that line has been executed. The output file is called &lt;code&gt;channel.COVER.out&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 각 실행 가능 행마다 해당 행이 몇 번 실행되었는지 지정되는 &lt;code&gt;channel.erl&lt;/code&gt; 의 사본을 작성합니다 . 출력 파일은 &lt;code&gt;channel.COVER.out&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4bf61d20b6e51c3f3e2be4195443a2547ef5d88" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang list object, whose length &lt;code&gt;arrsize&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">이 함수는 길이가 &lt;code&gt;arrsize&lt;/code&gt; 이고 &lt;code&gt;array&lt;/code&gt; 의 항에서 요소를 가져 오는 Erlang 목록 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e824f3f61fcb9a0cc2524376c6e7e48b567c62f2" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang tuple, whose arity is &lt;code&gt;size&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;size&lt;/code&gt; 가 ar이고 &lt;code&gt;array&lt;/code&gt; 의 항에서 요소를 가져 오는 Erlang 튜플을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a0c7fe697609b06db41d8d42bbc188f96462c7d5" translate="yes" xml:space="preserve">
          <source>The function descriptions are sorted in alphabetical order. It is recommended to start to read about &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, &lt;code&gt;mnesia:lock/2&lt;/code&gt;, and &lt;code&gt;mnesia:activity/4&lt;/code&gt; before you continue and learn about the rest.</source>
          <target state="translated">기능 설명은 알파벳 순서로 정렬됩니다. 계속 진행하기 전에 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , &lt;code&gt;mnesia:lock/2&lt;/code&gt; 및 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 에 대해 읽어 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a4a4d3bf61b03f1db00124a05a395c3a8430b995" translate="yes" xml:space="preserve">
          <source>The function does not return until the application is started, stopped, or successfully moved to another node. However, in some cases where permission is set to &lt;code&gt;true&lt;/code&gt;, the function returns &lt;code&gt;ok&lt;/code&gt; even though the application is not started. This is true when an application cannot start because of dependencies to other applications that are not yet started. When they are started, &lt;code&gt;Application&lt;/code&gt; is started as well.</source>
          <target state="translated">응용 프로그램이 시작, 중지 또는 다른 노드로 성공적으로 이동 될 때까지 함수는 리턴되지 않습니다. 그러나 권한이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우에는 응용 프로그램이 시작되지 않은 경우에도 함수가 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 아직 시작되지 않은 다른 응용 프로그램에 대한 종속성으로 인해 응용 프로그램을 시작할 수없는 경우에 해당됩니다. 시작되면 &lt;code&gt;Application&lt;/code&gt; 도 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1a469b96b6bc66c5e0081f41213671f5c1c3834d" translate="yes" xml:space="preserve">
          <source>The function evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the specified nodes and collects the answers. It returns &lt;code&gt;{ResL, BadNodes}&lt;/code&gt;, where &lt;code&gt;BadNodes&lt;/code&gt; is a list of the nodes that do not exist, and &lt;code&gt;ResL&lt;/code&gt; is a list of the return values, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; for failing calls. &lt;code&gt;Timeout&lt;/code&gt; is a time (integer) in milliseconds, or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 지정된 노드에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 답을 수집합니다. &lt;code&gt;{ResL, BadNodes}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;BadNodes&lt;/code&gt; 는 존재하지 않는 노드 목록이고 &lt;code&gt;ResL&lt;/code&gt; 은 리턴 값 목록 또는 호출 실패에 대한 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 입니다. &lt;code&gt;Timeout&lt;/code&gt; 은 밀리 초 또는 &lt;code&gt;infinity&lt;/code&gt; 의 시간 (정수)입니다 .</target>
        </trans-unit>
        <trans-unit id="bfd306c3cfcdf7cb094583b8a0337221382f9540" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 시작 함수에 의해 시작되지 않았 거나 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 에 따라 등록 되지 않은 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="0d8167d08507c4718349622be594e2c2117b70ec" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;proc_lib&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;ServerName&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;proc_lib&lt;/code&gt; 시작 함수에 의해 시작되지 않았 거나 &lt;code&gt;ServerName&lt;/code&gt; 에 따라 등록 되지 않은 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="5ed33b0170b87b32a6fff91a9848a8bb7508e2c1" translate="yes" xml:space="preserve">
          <source>The function fails if the mandatory applications Kernel and STDLIB are not included in the &lt;code&gt;.rel&lt;/code&gt; file and have start type &lt;code&gt;permanent&lt;/code&gt; (which is default).</source>
          <target state="translated">필수 응용 프로그램 커널 및 STDLIB가 &lt;code&gt;.rel&lt;/code&gt; 파일에 포함되어 있지 않고 시작 유형이 &lt;code&gt;permanent&lt;/code&gt; (기본값) 인 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="6976675cebc3455eafac8b880bffae5936b6e076" translate="yes" xml:space="preserve">
          <source>The function fails with a &lt;code&gt;badarg&lt;/code&gt; run-time error if &lt;code&gt;Dest&lt;/code&gt; is an atom name, but this name is not registered. This is the only case when &lt;code&gt;send&lt;/code&gt; fails for an unreachable destination &lt;code&gt;Dest&lt;/code&gt; (of correct type).</source>
          <target state="translated">&lt;code&gt;Dest&lt;/code&gt; 가 아톰 이름 인 경우이 이름이 등록되지 않은 경우 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류와 함께 함수가 실패합니다 . 때 유일한 경우입니다 &lt;code&gt;send&lt;/code&gt; 도달 할 수없는 목적지 실패 &lt;code&gt;Dest&lt;/code&gt; (올바른 유형의).</target>
        </trans-unit>
        <trans-unit id="f9fbf6c475826079470707701e2d9650785e7704" translate="yes" xml:space="preserve">
          <source>The function fails with reason &lt;code&gt;badarg&lt;/code&gt; in the following situations:</source>
          <target state="translated">다음 상황에서 reason &lt;code&gt;badarg&lt;/code&gt; 와 함께 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="fe345735a6f8cc2af489da60647a5b2eb92480ca" translate="yes" xml:space="preserve">
          <source>The function is applied to each argument in the list. &lt;code&gt;foreach&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt;. It is only used for its side-effect:</source>
          <target state="translated">이 함수는 목록의 각 인수에 적용됩니다. &lt;code&gt;foreach&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 부작용에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed286726d563576b74209031d0c844b5706bbb8" translate="yes" xml:space="preserve">
          <source>The function is asynchronous in the sense that it does not invoke a disk check, but returns the latest available value.</source>
          <target state="translated">이 기능은 디스크 검사를 호출하지 않지만 사용 가능한 최신 값을 반환한다는 점에서 비동기식입니다.</target>
        </trans-unit>
        <trans-unit id="b851161538f61def55e8def7663e88f86cb96f48" translate="yes" xml:space="preserve">
          <source>The function is called by Logger when the formatter configuration for a handler is set or modified. It returns &lt;code&gt;ok&lt;/code&gt; if the configuration is valid, and &lt;code&gt;{error,term()}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">핸들러의 포맷터 구성이 설정되거나 수정 될 때 로거가 함수를 호출합니다. 구성이 유효하면 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고 결함이 있으면 &lt;code&gt;{error,term()}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="685ab0b87ed3c05c293ea5d73e5639b4e1ff9576" translate="yes" xml:space="preserve">
          <source>The function is called by a Logger when formatter configuration is set or modified. The formatter must validate the given configuration and return &lt;code&gt;ok&lt;/code&gt; if it is correct, and &lt;code&gt;{error,Reason}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">이 기능은 포맷터 구성이 설정되거나 수정 될 때 로거에 의해 호출됩니다. 포맷터는 지정된 구성을 검증하고 올바른 경우 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고 결함이있는 경우 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fcd6de716b12c9ffa6272634f06715a4cc1ce07" translate="yes" xml:space="preserve">
          <source>The function is called for each start phase (as defined for the primary application) for the primary application and all included applications, for which the start phase is defined.</source>
          <target state="translated">기본 응용 프로그램 및 시작 단계가 정의 된 모든 포함 된 응용 프로그램의 각 시작 단계 (기본 응용 프로그램에 정의 된대로)에 대해 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c011a777dda4570cb71bfb1ec0fb55355e1ee1d3" translate="yes" xml:space="preserve">
          <source>The function is called if a user related error occurs at run-time, for example if a user defined instrumentation function returns erroneous.</source>
          <target state="translated">런타임시 사용자 관련 오류가 발생하면 함수가 호출됩니다 (예 : 사용자 정의 계측 기능이 오류를 반환하는 경우).</target>
        </trans-unit>
        <trans-unit id="af4ce4e1efa0b48a530a0c78c675702975921a0a" translate="yes" xml:space="preserve">
          <source>The function is called if an error occurs during the configuration phase, for example if a syntax error is found in a configuration file.</source>
          <target state="translated">구성 단계에서 오류가 발생하면 (예 : 구성 파일에서 구문 오류가 발견 된 경우) 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="66a34ca9f0458ec66fedbe0a7a5d4d658f1bc216" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when a handler is about to be removed. The purpose is to release all resources used by the handler.</source>
          <target state="translated">핸들러가 제거 되려고 할 때 임시 프로세스에서 함수가 호출됩니다. 목적은 핸들러가 사용하는 모든 자원을 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad2afb8b57f9d81965d61a6dce572893b3ec7c89" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when an new handler is about to be added. The purpose is to verify the configuration and initiate all resources needed by the handler.</source>
          <target state="translated">새 핸들러가 추가 될 때 임시 프로세스에서 함수가 호출됩니다. 목적은 구성을 확인하고 핸들러에 필요한 모든 자원을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdbb67b2c606784fb7d08c84801ed6ce232a3ebb" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when the configuration for a handler is about to change. The purpose is to verify and act on the new configuration.</source>
          <target state="translated">핸들러의 구성이 변경 되려고 할 때 함수는 임시 프로세스에서 호출됩니다. 목적은 새 구성을 확인하고 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80c74d3f2c316470e0f2a09c6499b88b08ed5921" translate="yes" xml:space="preserve">
          <source>The function is called when all primary filters and all handler filters for the handler in question have passed for the given log event. It is called on the client process, that is, the process that issued the log event.</source>
          <target state="translated">해당 로그 이벤트에 대해 모든 기본 필터 및 해당 핸들러의 모든 핸들러 필터가 전달 된 경우 함수가 호출됩니다. 클라이언트 프로세스, 즉 로그 이벤트를 발행 한 프로세스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="729c9968acf86cfc5b4d0b16abd57720e8543995" translate="yes" xml:space="preserve">
          <source>The function is called with the current line, up to the cursor, as a reversed string. It is to return a three-tuple: &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt;. The first element gives a beep if &lt;code&gt;no&lt;/code&gt;, otherwise the expansion is silent; the second is a string that will be entered at the cursor position; the third is a list of possible expansions. If this list is not empty, it is printed and the current input line is written once again.</source>
          <target state="translated">이 함수는 현재 줄에서 커서까지의 반전 된 문자열로 호출됩니다. &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt; 의 세 튜플을 반환해야합니다 . 첫 번째 요소는 &lt;code&gt;no&lt;/code&gt; 인 경우 경고음을냅니다 . 그렇지 않으면 확장이 자동입니다. 두 번째는 커서 위치에 입력 될 문자열입니다. 세 번째는 가능한 확장 목록입니다. 이 목록이 비어 있지 않으면 인쇄되고 현재 입력 행이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5bcd5b77b7b4d998e29896caa372504ff0881133" translate="yes" xml:space="preserve">
          <source>The function is called with the data the I/O server finds on its I/O device, returning one of:</source>
          <target state="translated">이 기능은 I / O 서버가 I / O 장치에서 찾은 데이터와 함께 호출되어 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05b6947d52059ff05be463986c224ccf19b497f6" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments. The first argument is the successive elements in the list. The second argument is the accumulator. The function must return a new accumulator, which is used the next time the function is called.</source>
          <target state="translated">이 함수는 두 개의 인수로 호출됩니다. 첫 번째 인수는 목록의 연속 요소입니다. 두 번째 주장은 누산기입니다. 함수는 다음에 함수가 호출 될 때 사용되는 새 누산기를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1d7045b7530f750d5c794463ab3ef61f6f0030e" translate="yes" xml:space="preserve">
          <source>The function is intended to be called in function &lt;code&gt;init_per_suite&lt;/code&gt; in the test suite.</source>
          <target state="translated">이 함수는 테스트 스위트의 &lt;code&gt;init_per_suite&lt;/code&gt; 함수 에서 호출하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="91d0a41107672655c3969ea037e3566edb95fc7c" translate="yes" xml:space="preserve">
          <source>The function is normally asynchronous in the sense that it does not invoke a memory check, but returns the latest available value. The one exception if is the function is called before a first memory check is finished, in which case it does not return a value until the memory check is finished.</source>
          <target state="translated">이 함수는 일반적으로 메모리 검사를 호출하지 않지만 사용 가능한 최신 값을 반환한다는 점에서 비동기식입니다. 첫 번째 메모리 검사가 완료되기 전에 함수가 호출되는 경우 예외는 메모리 검사가 완료 될 때까지 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34af02f93e44d91dfb2270e53d1db1bc513f0b80" translate="yes" xml:space="preserve">
          <source>The function is optional and can be omitted when implementing an application callback module.</source>
          <target state="translated">이 기능은 선택 사항이며 응용 프로그램 콜백 모듈을 구현할 때 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="982df6f9c963401aaf5cd8cce719f4c21d1397c5" translate="yes" xml:space="preserve">
          <source>The function is optional. If it is not defined, the processes are terminated and then &lt;code&gt;Module:stop(State)&lt;/code&gt; is called.</source>
          <target state="translated">이 기능은 선택 사항입니다. 정의되어 있지 않으면 프로세스가 종료 된 다음 &lt;code&gt;Module:stop(State)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c75677662ff31b49062b31fc1d308b57eded17" translate="yes" xml:space="preserve">
          <source>The function is synchronous and all the nodes, and all the system servers, are running when it returns a value.</source>
          <target state="translated">이 함수는 동기식이며 값을 리턴 할 때 모든 노드와 모든 시스템 서버가 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="4bd22d2a35c5c88266eecbb86f7699a4e9f4d949" translate="yes" xml:space="preserve">
          <source>The function is synchronous in the sense that it is known that all servers have received the message when the call returns. It is not possible to know that the servers have processed the message.</source>
          <target state="translated">이 함수는 호출이 리턴 될 때 모든 서버가 메시지를 수신 한 것으로 알려져 있다는 점에서 동기식입니다. 서버가 메시지를 처리했음을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3e80a528bd9ed8d253ab3a636d365b349c0df48" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that change the details of the current state of the event handler. Any term is allowed for &lt;code&gt;Status&lt;/code&gt;. The &lt;code&gt;gen_event&lt;/code&gt; module uses &lt;code&gt;Status&lt;/code&gt; as follows:</source>
          <target state="translated">이 함수는 이벤트 핸들러의 현재 상태에 대한 세부 사항을 변경하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 하는 것입니다. 모든 용어는 &lt;code&gt;Status&lt;/code&gt; 에 허용됩니다 . &lt;code&gt;gen_event&lt;/code&gt; 의 모듈은 사용 &lt;code&gt;Status&lt;/code&gt; 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="f5e6848577b63036dd2df41149bfea0f17b8cf85" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that changes the details of the current state and status of the &lt;code&gt;gen_server&lt;/code&gt; process. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_server&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 현재 상태 및 상태의 세부 사항을 변경하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 하는 것입니다. &lt;code&gt;Status&lt;/code&gt; 는 취할 수 있는 양식에는 제한이 없지만 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 사례 ( &lt;code&gt;Opt&lt;/code&gt; 가 &lt;code&gt;normal&lt;/code&gt; )의 경우 권장되는 &lt;code&gt;Status&lt;/code&gt; 값은 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; , 여기서 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;gen_server&lt;/code&gt; 상태 의 관련 세부 사항을 제공합니다 . 이 권장 사항을 따를 필요는 없지만 콜백 모듈 상태는 나머지 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 반환 값 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="22b229f5a7773458a1b22bbef3b9114da9d0467f" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that contains the appropriate details of the current state and status of the &lt;code&gt;gen_statem&lt;/code&gt;. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_statem&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value.</source>
          <target state="translated">이 함수는 현재 상태 및 &lt;code&gt;gen_statem&lt;/code&gt; 상태에 대한 적절한 세부 사항을 포함하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 합니다 . &lt;code&gt;Status&lt;/code&gt; 는 취할 수 있는 양식에는 제한이 없지만 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 사례 ( &lt;code&gt;Opt&lt;/code&gt; 가 &lt;code&gt;normal&lt;/code&gt; )의 경우 권장되는 &lt;code&gt;Status&lt;/code&gt; 값은 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; , 여기서 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;gen_statem&lt;/code&gt; 상태 의 관련 세부 사항을 제공합니다 . 이 권장 사항을 따를 필요는 없지만 콜백 모듈 상태는 나머지 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 반환 값 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="2e735ad6e373adc70cb8848117759dd2a569193e" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the main process in the subsystem and &lt;code&gt;State&lt;/code&gt; is any term.</source>
          <target state="translated">함수는 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; 를 리턴하는 것입니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 서브 시스템에서 기본 프로세스의 pid이고 &lt;code&gt;State&lt;/code&gt; 는 임의의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="b33f514bbf6653a3186283c4cae20e76aa53b9a4" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid}&lt;/code&gt; or &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the top supervisor and &lt;code&gt;State&lt;/code&gt; is any term. If omitted, &lt;code&gt;State&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;. If the application is stopped later, &lt;code&gt;State&lt;/code&gt; is passed to &lt;code&gt;Module:prep_stop/1&lt;/code&gt;.</source>
          <target state="translated">함수는 &lt;code&gt;{ok,Pid}&lt;/code&gt; 또는 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; 를 리턴하는 것입니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 최고 감독자의 pid이고 &lt;code&gt;State&lt;/code&gt; 는 임의의 용어입니다. 생략하면 &lt;code&gt;State&lt;/code&gt; 의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 애플리케이션이 나중에 중지되면 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;Module:prep_stop/1&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="29043cd3dfeb40d4aadad45c2081e6be85789b31" translate="yes" xml:space="preserve">
          <source>The function is to return the updated internal state.</source>
          <target state="translated">이 기능은 업데이트 된 내부 상태를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0abf3dd01db775a71cf749a86135b99f1e7db1dc" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 현재 응용 프로그램 버전에서 다운 그레이드 스크립트를 찾습니다. 높은 수준의 명령어는 낮은 수준의 명령어로 변환됩니다. 이 명령은 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때와 같은 방식으로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad728199fe8cc2addea2e4edf8ccc9c3d563c12d" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script to the previous version of the application using &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt; 를 사용하여 이전 버전의 응용 프로그램으로 다운 그레이드 스크립트를 찾으려고합니다 . 이 스크립트는 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 와 정확히 동일한 방식으로 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="043e22dee6e39d2801de5bf62c0f13acd1fb7f3e" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 현재 응용 프로그램 버전에서 업그레이드 스크립트를 찾으려고합니다. 높은 수준의 명령어는 낮은 수준의 명령어로 변환됩니다. 이 명령은 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때와 같은 방식으로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c31fe3b9fb91cec2a465fbf77df750e586faa18" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current version of the application using &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 버전의 애플리케이션에서 업그레이드 스크립트를 찾으려고합니다 . 이 스크립트는 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 와 정확히 동일한 방식으로 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="dae77798ddae832b867b1859c814067bb73455e5" translate="yes" xml:space="preserve">
          <source>The function megaco:connect/4 is used to tell the Megaco application about which control process it should supervise, which MID the remote user has, which callback module it should use to send messages etc. When this &quot;virtual&quot; connection is established the user may use megaco:call/3 and megaco:cast/3 in order to send messages to the other side. Then it is up to the MG to send its first Service Change Request message after applying some clever algorithm in order to fight the problem with startup avalanche (as discussed in the RFC).</source>
          <target state="translated">megaco : connect / 4 함수는 Megaco 응용 프로그램이 감독해야하는 제어 프로세스, 원격 사용자가 가지고있는 MID, 메시지를 보내는 데 사용해야하는 콜백 모듈 등을 알려주는 데 사용됩니다.이 &quot;가상&quot;연결이 설정되면 사용자는 상대방에게 메시지를 보내기 위해 megaco : call / 3 및 megaco : cast / 3를 사용할 수 있습니다. 그런 다음 RFC에서 논의한 것처럼 시작 애벌 런치 문제를 해결하기 위해 영리한 알고리즘을 적용한 후 첫 번째 서비스 변경 요청 메시지를 보내는 것은 MG의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="8ccc872bcbfbd97b2f8f68cc4d29e1cdf3b26f8a" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;ok&lt;/code&gt; if the module is to become the new current code for the module and become callable.</source>
          <target state="translated">모듈이 모듈의 새로운 현재 코드가되어 호출 가능 해야하는 경우 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd0b359eea39bf0334c200db138df73b605bda4d" translate="yes" xml:space="preserve">
          <source>The function name is an atom. Each argument is a pattern.</source>
          <target state="translated">함수 이름은 원자입니다. 각 인수는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="9406ba0cad4fe7e53495b5806fdfd8af528e2c11" translate="yes" xml:space="preserve">
          <source>The function names &lt;code&gt;load_driver&lt;/code&gt; and &lt;code&gt;unload_driver&lt;/code&gt; are kept for backward compatibility.</source>
          <target state="translated">함수 이름 &lt;code&gt;load_driver&lt;/code&gt; 및 &lt;code&gt;unload_driver&lt;/code&gt; 는 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="79180ba05daadaf9ff778778be432cdae4488b2e" translate="yes" xml:space="preserve">
          <source>The function notifying the code lock about a button event is implemented using &lt;code&gt;gen_statem:cast/2&lt;/code&gt;:</source>
          <target state="translated">버튼 이벤트에 대해 코드 잠금을 알리는 기능은 &lt;code&gt;gen_statem:cast/2&lt;/code&gt; 를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bcdf8490fa58034ee65eebf4713860825158535" translate="yes" xml:space="preserve">
          <source>The function print_version_info/0 uses the result of function version1/0 as &lt;code&gt;VersionInfo&lt;/code&gt;.</source>
          <target state="translated">print_version_info / 0 함수는 version1 / 0 함수의 결과를 &lt;code&gt;VersionInfo&lt;/code&gt; 로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d4a4124fa895f394038737b2a3c8f1d3ab62f5b7" translate="yes" xml:space="preserve">
          <source>The function produces lines of &lt;code&gt;Key: Value&lt;/code&gt; from key-value lists. Strings are printed with &lt;code&gt;~ts&lt;/code&gt; and other terms with &lt;code&gt;~tp&lt;/code&gt;.</source>
          <target state="translated">이 함수는 키-값 목록에서 키 &lt;code&gt;Key: Value&lt;/code&gt; 행을 생성 합니다. 문자열은 &lt;code&gt;~ts&lt;/code&gt; 로 인쇄 되고 다른 용어는 &lt;code&gt;~tp&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cb60460defa522f2257f4190da9c81a7ebadbf4" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource destructor function.</source>
          <target state="translated">자원 소멸자 함수의 함수 프로토 타입입니다.</target>
        </trans-unit>
        <trans-unit id="251a711b61dad3eb243d0cc657f90de99a8cb62d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource down function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;pid&lt;/code&gt; is the identity of the monitored process that is exiting, and &lt;code&gt;mon&lt;/code&gt; is the identity of the monitor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 대신에 호출되는 자원 중지 기능의 함수 프로토 타입입니다 . &lt;code&gt;obj&lt;/code&gt; 는 자원이고, &lt;code&gt;pid&lt;/code&gt; 는 종료중인 모니터 된 프로세스 의 ID 이고 &lt;code&gt;mon&lt;/code&gt; 은 모니터의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="c45bd32e6496942fbb5d72602a01f8593df7f20d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource stop function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;event&lt;/code&gt; is OS event, &lt;code&gt;is_direct_call&lt;/code&gt; is true if the call is made directly from &lt;code&gt;enif_select&lt;/code&gt; or false if it is a scheduled call (potentially from another thread).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; 대신 호출되는 자원 중지 기능의 함수 프로토 타입입니다 . &lt;code&gt;obj&lt;/code&gt; 는 자원, &lt;code&gt;event&lt;/code&gt; 는 OS 이벤트, &lt;code&gt;is_direct_call&lt;/code&gt; 은 &lt;code&gt;enif_select&lt;/code&gt; 에서 직접 호출하는 경우 true이고 예약 된 호출 인 경우 (다른 스레드에서 발생할 수있는 경우) false입니다.</target>
        </trans-unit>
        <trans-unit id="48037bd5e6edfdffb2f1110aafc54b00f51f984c" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration and kills the other one.</source>
          <target state="translated">이 함수는 등록 할 pid 중 하나를 임의로 선택하고 다른 pid를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="305e01bbc8fe93b497a733f359ad553dd0edafee" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration, and sends the message &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; to the other pid.</source>
          <target state="translated">이 함수는 등록 할 pid 중 하나를 임의로 선택하고 &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; 메시지 를 다른 pid로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8abbebafab7e64fd67ec141e6747533671416e1f" translate="yes" xml:space="preserve">
          <source>The function removes the &lt;code&gt;Key&lt;/code&gt;, if it exists, and its associated value from &lt;code&gt;Map1&lt;/code&gt; and returns a tuple with the removed &lt;code&gt;Value&lt;/code&gt; and the new map &lt;code&gt;Map2&lt;/code&gt; without key &lt;code&gt;Key&lt;/code&gt;. If the key does not exist &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수는 &lt;code&gt;Key&lt;/code&gt; 가있는 경우 &lt;code&gt;Map1&lt;/code&gt; 에서 관련 값을 제거 하고 &lt;code&gt;Key&lt;/code&gt; 가 없는 새로운 Map &lt;code&gt;Map2&lt;/code&gt; 가 제거 된 &lt;code&gt;Value&lt;/code&gt; 와 함께 튜플을 반환합니다 . 키가 없으면 &lt;code&gt;error&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e238717dba0649170fc233d2b4fe4554b94fb51d" translate="yes" xml:space="preserve">
          <source>The function reports &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; for errors, where &lt;code&gt;Reason&lt;/code&gt; is any possible reason returned by &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; when starting a specific dependency.</source>
          <target state="translated">함수는 &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; 대해 {error, {AppName, Reason}} 을보고합니다. 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 특정 종속성을 시작할 때 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴되는 가능한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="76d19e4d2aef11065f3b75825b4b1412100e2c14" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; for &lt;code&gt;latin1&lt;/code&gt; encoding, as there is no BOM for ISO Latin-1.</source>
          <target state="translated">ISO Latin-1에 대한 BOM이 &lt;code&gt;latin1&lt;/code&gt; 함수는 latin1 인코딩에 대해 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cea6a4ed4ab166dce1a5c11aa39053c9e188fc54" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;1&lt;/code&gt; on successful decoding, &lt;code&gt;-1&lt;/code&gt; on error, and &lt;code&gt;0&lt;/code&gt; if the term seems alright, but does not fit in the &lt;code&gt;term&lt;/code&gt; structure. If &lt;code&gt;1&lt;/code&gt; is returned, the &lt;code&gt;index&lt;/code&gt; is incremented, and &lt;code&gt;term&lt;/code&gt; contains the decoded term.</source>
          <target state="translated">함수가 반환 &lt;code&gt;1&lt;/code&gt; 성공적인 디코딩에 &lt;code&gt;-1&lt;/code&gt; 오류에, 그리고 &lt;code&gt;0&lt;/code&gt; 이 용어는 괜찮아 보이지만에 맞지 않을 경우 &lt;code&gt;term&lt;/code&gt; 구조. 경우 &lt;code&gt;1&lt;/code&gt; 이 반환되면, &lt;code&gt;index&lt;/code&gt; 증가하고, &lt;code&gt;term&lt;/code&gt; 디코딩 된 용어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0efff847bddce6b19a713a0f0517e02e510df4" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the event manager terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">이벤트 관리자가 예상 된 이유로 종료되면 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유로 &lt;code&gt;logger(3)&lt;/code&gt; 사용하여 오류 보고서가 발행됩니다 . 기본 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c7b3421431470de3120253d455529b919367ac1" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">서버가 예상 된 이유로 종료되면 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유로 &lt;code&gt;logger(3)&lt;/code&gt; 사용하여 오류 보고서가 발행됩니다 . 기본 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd73f7ab11de774d64402ce75fdbcce6bc66eb53" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; or an error tuple where the second element contains the I/O error that made the writing impossible.</source>
          <target state="translated">이 함수는 &lt;code&gt;ok&lt;/code&gt; 또는 오류 튜플을 반환 하며, 두 번째 요소에는 쓰기 불가능한 I / O 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8bcc68d7d1e1c02534b3299d71875a81aa57c0" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt;, or terminates if an error occurs. For example, the transaction terminates if no &lt;code&gt;person&lt;/code&gt; table exists.</source>
          <target state="translated">이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 오류가 발생하면 종료됩니다. 예를 들어 &lt;code&gt;person&lt;/code&gt; 테이블이 없으면 트랜잭션이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae9ce4bfa4732575d07ad75abe832d18209cf6d5" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;profiling&lt;/code&gt; if tracing could be enabled for all processes in &lt;code&gt;Rootset&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt; otherwise.</source>
          <target state="translated">함수가 반환 &lt;code&gt;profiling&lt;/code&gt; 추적 경우는 모두 프로세스를 가능하게 할 수 &lt;code&gt;Rootset&lt;/code&gt; , 또는 &lt;code&gt;error&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="82b7eb2d16fbf6159cd686bcbf5282210683decd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if all of the following apply:</source>
          <target state="translated">다음 사항이 모두 적용되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ade0bfc225f1f56359228ebdf66a4c04b123ddc2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;yes&lt;/code&gt; if successful, &lt;code&gt;no&lt;/code&gt; if it fails. For example, &lt;code&gt;no&lt;/code&gt; is returned if an attempt is made to register an already registered process or to register a process with a name that is already in use.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;yes&lt;/code&gt; 를 , 실패하면 &lt;code&gt;no&lt;/code&gt; 를 리턴 합니다. 예를 들어, 이미 등록 된 프로세스를 등록하거나 이미 사용중인 이름으로 프로세스를 등록하려고하면 &lt;code&gt;no&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="00e48b1c0bb58c163a4b66da8eb059d14d44d0a7" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{Pos, Length}&lt;/code&gt; for the binary in &lt;code&gt;Pattern&lt;/code&gt;, starting at the lowest position in &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Subject&lt;/code&gt; 의 가장 낮은 위치에서 시작하여 &lt;code&gt;Pattern&lt;/code&gt; 의 이진에 대해 &lt;code&gt;{Pos, Length}&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="51c7380f6ccd2c685f838a5778eff11acc171a3c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{SourceFile, Options}&lt;/code&gt; if it succeeds. &lt;code&gt;SourceFile&lt;/code&gt; is the absolute path to the source file without extension &lt;code&gt;&quot;.erl&quot;&lt;/code&gt;. &lt;code&gt;Options&lt;/code&gt; includes the options that are necessary to recompile the file with &lt;code&gt;compile:file/2&lt;/code&gt;, but excludes options such as &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;verbose&lt;/code&gt;, which do not change the way code is generated. The paths in options &lt;code&gt;{outdir, Path}&lt;/code&gt; and &lt;code&gt;{i, Path}&lt;/code&gt; are guaranteed to be absolute.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;{SourceFile, Options}&lt;/code&gt; 리턴 합니다. &lt;code&gt;SourceFile&lt;/code&gt; 은 확장자가 &lt;code&gt;&quot;.erl&quot;&lt;/code&gt; 없는 소스 파일의 절대 경로 입니다. &lt;code&gt;Options&lt;/code&gt; 에는 &lt;code&gt;compile:file/2&lt;/code&gt; 로 파일을 다시 컴파일하는 데 필요한 옵션이 포함 되지만 코드 생성 방식을 변경하지 않는 &lt;code&gt;report&lt;/code&gt; 및 &lt;code&gt;verbose&lt;/code&gt; 와 같은 옵션은 제외 됩니다. &lt;code&gt;{outdir, Path}&lt;/code&gt; 및 &lt;code&gt;{i, Path}&lt;/code&gt; 옵션의 경로는 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="95f12585f0eeb736eca25c313b53ecf1f8719509" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,Reason}&lt;/code&gt; if the module cannot be interpreted. &lt;code&gt;Reason&lt;/code&gt; can have the following values:</source>
          <target state="translated">모듈을 해석 할 수없는 경우 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;Reason&lt;/code&gt; 는 다음 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327593fcc1fe364e7a22ff37db545a09532407de" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,eacces}&lt;/code&gt; if the directory is not readable or &lt;code&gt;{error,enoent}&lt;/code&gt; if the directory does not exist.</source>
          <target state="translated">디렉토리를 읽을 수 없으면 함수는 &lt;code&gt;{error,eacces}&lt;/code&gt; 를, 디렉토리가 없으면 &lt;code&gt;{error,enoent}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9a6679cb30215fd3bbce3430d53f63d245192cc6" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{ok, Node}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the new node, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; can be one of:</source>
          <target state="translated">이 함수는 &lt;code&gt;{ok, Node}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Node&lt;/code&gt; 는 새 노드의 이름이고, 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; . 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="926a41dded8f50f5bd40efe538f9bd8d662e5429" translate="yes" xml:space="preserve">
          <source>The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings, for example:</source>
          <target state="translated">이 함수는 일치하는 각 객체에 대해 하나의 요소가있는 목록을 반환합니다. 여기서 각 요소는 패턴 변수 바인딩의 순서가 지정된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ef467049df8eebfb47a732dfe257b75164507468" translate="yes" xml:space="preserve">
          <source>The function returns a new list.</source>
          <target state="translated">이 함수는 새로운 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e921d3a34acd22129663174bed5a4222ddb5120" translate="yes" xml:space="preserve">
          <source>The function returns a tuple &lt;code&gt;{Replies,BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of &lt;code&gt;{Node,Reply}&lt;/code&gt; and &lt;code&gt;BadNodes&lt;/code&gt; is a list of node that either did not exist, or where the &lt;code&gt;gen_server&lt;/code&gt;&lt;code&gt;Name&lt;/code&gt; did not exist or did not reply.</source>
          <target state="translated">이 함수는 튜플 &lt;code&gt;{Replies,BadNodes}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Replies&lt;/code&gt; 는 &lt;code&gt;{Node,Reply}&lt;/code&gt; 의 목록 이고 &lt;code&gt;BadNodes&lt;/code&gt; 는 존재하지 않거나 &lt;code&gt;gen_server&lt;/code&gt; &lt;code&gt;Name&lt;/code&gt; 이 없거나 응답하지 않은 노드의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="b1e8d384f3de9f24fc9976775486188b88a64ca7" translate="yes" xml:space="preserve">
          <source>The function returns according to the specification of an instrumentation function.</source>
          <target state="translated">이 기능은 계측 기능의 사양에 따라 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba15e145974c7c4548255818d03130da786830bb" translate="yes" xml:space="preserve">
          <source>The function returns an Erlang term, or &lt;code&gt;NULL&lt;/code&gt; if &lt;code&gt;FormatStr&lt;/code&gt; does not describe a valid Erlang term.</source>
          <target state="translated">이 함수는 얼랑 용어, 또는 반환 &lt;code&gt;NULL&lt;/code&gt; 을 경우 &lt;code&gt;FormatStr&lt;/code&gt; 이 유효한 얼랑 용어를 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84b04ee2da4370d4c96804f7728600a7d4958614" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many functions that matched, in the same way as the processes and ports are presented in the return value of &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 오류 튜플 또는 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 반환합니다 . &lt;code&gt;List&lt;/code&gt; 프로세스와 포트의 반환 값에 표시되는 것과 같은 방식으로, 일치하는 것이 얼마나 많은 기능의 사양으로 구성되어 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dff9f8ac1b740a28f21f75b322ee576a5c1a3db8" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many processes and ports that matched (in the case of a pure pid() exactly 1). The specification of matched processes is &lt;code&gt;{matched, Node, N}&lt;/code&gt;. If the remote processor call,&lt;code&gt;rpc&lt;/code&gt;, to a remote node fails, the &lt;code&gt;rpc&lt;/code&gt; error message is delivered as a fourth argument and the number of matched processes are 0. Note that the result {ok, List} may contain a list where &lt;code&gt;rpc&lt;/code&gt; calls to one, several or even all nodes failed.</source>
          <target state="translated">이 함수는 오류 튜플 또는 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 반환합니다 . &lt;code&gt;List&lt;/code&gt; (순수 PID () 정확히 1의 경우) 일치하는 것이 얼마나 많은 프로세스와 포트의 사양으로 구성되어 있습니다. 일치하는 프로세스의 스펙은 &lt;code&gt;{matched, Node, N}&lt;/code&gt; 입니다. 원격 노드에 대한 원격 프로세서 호출 &lt;code&gt;rpc&lt;/code&gt; 가 실패하면 &lt;code&gt;rpc&lt;/code&gt; 오류 메시지가 네 번째 인수로 전달되고 일치하는 프로세스 수가 0입니다. 결과 {ok, List}에는 &lt;code&gt;rpc&lt;/code&gt; 가 호출 하는 목록이 포함될 수 있습니다. 하나, 여러 개 또는 모든 노드가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="47ce2b2bb012a9e9a4743dfb100ef52ab194f4a8" translate="yes" xml:space="preserve">
          <source>The function returns one of the following statuses upon success:</source>
          <target state="translated">이 함수는 성공하면 다음 상태 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af80ca7f3d62f6cac6e62e9f90f2843e1b33444b" translate="yes" xml:space="preserve">
          <source>The function returns the answer &lt;code&gt;Reply&lt;/code&gt; as produced by the server &lt;code&gt;Name&lt;/code&gt;, or &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">이 함수는 서버 &lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;{error, Reason}&lt;/code&gt; 의해 생성 된 응답 &lt;code&gt;Reply&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6fa69a661585fbc212f6bcd6110e5d9551001a6f" translate="yes" xml:space="preserve">
          <source>The function returns the list of file names of all created modules, including any automatically created stub modules. The file name of the target module is always first in the list.</source>
          <target state="translated">이 함수는 자동으로 작성된 스텁 모듈을 포함하여 작성된 모든 모듈의 파일 이름 목록을 리턴합니다. 대상 모듈의 파일 이름은 항상 목록에서 첫 번째입니다.</target>
        </trans-unit>
        <trans-unit id="67e6d37d8f8ed9b75d952e7999fb2087c89daf86" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects deleted from the table.</source>
          <target state="translated">이 함수는 테이블에서 삭제 된 개체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f97fd237860bed04d4fc7be045423bcf8705b592" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects matched.</source>
          <target state="translated">이 함수는 일치하는 개체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c874ae6f3ce13ecf61704660eadd7378f687f995" translate="yes" xml:space="preserve">
          <source>The function returns the pid() of a handler process, that does the supervision on behalf of the client application. Note that the client application is linked to this handler.</source>
          <target state="translated">이 함수는 클라이언트 응용 프로그램 대신 감독을 수행하는 처리기 프로세스의 pid ()를 반환합니다. 클라이언트 애플리케이션은이 핸들러에 링크되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8826e27f40bae39e6afc8b99ead67cefc85ed51f" translate="yes" xml:space="preserve">
          <source>The function returns the test result, represented by the tuple &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt;, where each element is an integer. If test execution fails, the function returns the tuple &lt;code&gt;{error,Reason}&lt;/code&gt;, where the term &lt;code&gt;Reason&lt;/code&gt; explains the failure.</source>
          <target state="translated">이 함수는 튜플 &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt; 로 표시되는 테스트 결과를 리턴합니다 . 여기서 각 요소는 정수입니다. 테스트 실행이 실패하면이 함수는 튜플 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴하며 , 여기서 &lt;code&gt;Reason&lt;/code&gt; 라는 용어 는 실패를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="66053340efa519d76743820bb26595016a5a05f7" translate="yes" xml:space="preserve">
          <source>The function returns the total number of replaced objects.</source>
          <target state="translated">이 함수는 교체 된 총 객체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13b54d91784d634be011a5d8f40eca029f4c1437" translate="yes" xml:space="preserve">
          <source>The function returns when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled.</source>
          <target state="translated">이 함수는 응답이 도착할 때, 요청 타이머가 결국 시간 초과되거나 미해결 요청이 명시 적으로 취소 될 때 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0e911cfd5f3fbfe1f052ffaa063943cb8b0fe46c" translate="yes" xml:space="preserve">
          <source>The function returns:</source>
          <target state="translated">이 함수는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9be9148ebe8c1af83ecb810b37aa82c15bf5d001" translate="yes" xml:space="preserve">
          <source>The function should now return:</source>
          <target state="translated">함수는 이제 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="89ceb7fdfb37fece3ab74b229b8cea9443cca0bd" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system or if the tag is not supported.</source>
          <target state="translated">드라이버가 시스템에 없거나 태그가 지원되지 않으면 이 함수는 &lt;code&gt;badarg&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="95ce52efa32ec5a1e922545d8dfcff54dd9fa145" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system.</source>
          <target state="translated">시스템에 드라이버가없는 &lt;code&gt;badarg&lt;/code&gt; 함수는 잘못된 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e2803735d718719dbf8ff59057508925d737d41f" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameter is not a &lt;code&gt;reference()&lt;/code&gt;.</source>
          <target state="translated">매개 변수가 &lt;code&gt;reference()&lt;/code&gt; 가 아닌 경우 함수는 &lt;code&gt;badarg&lt;/code&gt; 예외를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="66d20dcf7ad9c489aba044486ad7cfb8ef93a242" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameters are not specified as described here.</source>
          <target state="translated">여기에 설명 된대로 매개 변수를 지정하지 않으면 함수에서 &lt;code&gt;badarg&lt;/code&gt; 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5d9e44a0ad0773f97c4f379d41e06e651c358097" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameter is in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">매개 변수의 형식이 잘못된 경우 함수는 잘못된 인수를 발생시킵니다. 기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda733b256a520d564c901fe8c2c263fe4e56cd1" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameters are in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">매개 변수의 형식이 잘못된 경우 함수에서 잘못된 인수를 표시합니다. 기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c1041afe84cb2dbdbb948e8208c9f84bf59ebd" translate="yes" xml:space="preserve">
          <source>The function unregisters both pids and sends the message &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; to both processes.</source>
          <target state="translated">이 함수는 두 pid를 모두 등록 취소하고 &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; 메시지 를 두 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c3a1f79b06aa96385eb181ed86fb6eae9b5e9415" translate="yes" xml:space="preserve">
          <source>The function waits for user input, and does not return until the remote shell is ended (that is, exit from the shell).</source>
          <target state="translated">이 함수는 사용자 입력을 대기하고 원격 쉘이 종료 될 때까지 (즉, 쉘에서 나갈 때까지) 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8892ca0441d17488cdcc2015a61701f971adb9a" translate="yes" xml:space="preserve">
          <source>The function will also return an error if the node &lt;code&gt;Nodename&lt;/code&gt; is not reachable.</source>
          <target state="translated">노드 &lt;code&gt;Nodename&lt;/code&gt; 에 도달 할 수없는 경우이 함수는 오류를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fe48f3115cf0be1263ce3632f413691699d232ac" translate="yes" xml:space="preserve">
          <source>The function will also return the &lt;code&gt;Name&lt;/code&gt; instead of the table identifier. To get the table identifier of a named table, use &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 또한 테이블 식별자 대신 &lt;code&gt;Name&lt;/code&gt; 을 반환합니다 . 명명 된 테이블의 테이블 식별자를 얻으려면 &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc605a27b48f7b91fedc8d92d1b0ced2f10b5eee" translate="yes" xml:space="preserve">
          <source>The function will return an error, either due to I/O problems (like a non existing or non readable file) or due to file format problems. The errors from a bad format file are in a more or less textual format, which will give a hint to what's causing the problem.</source>
          <target state="translated">함수는 I / O 문제 (기존 파일이 아니거나 읽을 수없는 파일과 같은) 또는 파일 형식 문제로 인해 오류를 반환합니다. 잘못된 형식 파일의 오류는 다소 텍스트 형식으로되어있어 문제의 원인에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1192b2e61e715c06fc73aea33efb68d8d4e10a72" translate="yes" xml:space="preserve">
          <source>The function will throw an exception if the &lt;code&gt;dyntrace&lt;/code&gt; NIF library could not be loaded by the on_load function of this module.</source>
          <target state="translated">이 모듈의 on_load 함수로 &lt;code&gt;dyntrace&lt;/code&gt; NIF 라이브러리를로드 할 수없는 경우 함수에서 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="877225bff459640b7fb2492bce96b16257fca8af" translate="yes" xml:space="preserve">
          <source>The function works as &lt;code&gt;ei_reg_send&lt;/code&gt; with one exception. Instead of taking &lt;code&gt;ei_cnode&lt;/code&gt; as first argument, it takes a second argument, an &lt;code&gt;erlang_pid&lt;/code&gt;, which is to be the process identifier of the sending process (in the Erlang distribution protocol).</source>
          <target state="translated">이 함수는 한 가지 예외를 제외 하고 &lt;code&gt;ei_reg_send&lt;/code&gt; 로 작동합니다 . &lt;code&gt;ei_cnode&lt;/code&gt; 를 첫 번째 인수로 사용 하는 대신 두 번째 인수 인 &lt;code&gt;erlang_pid&lt;/code&gt; 를 사용하여 송신 프로세스의 프로세스 식별자 (Erlang 배포 프로토콜)가됩니다.</target>
        </trans-unit>
        <trans-unit id="96c1202d0cd6c2fd8c2454e3ec64b0d84b6bd072" translate="yes" xml:space="preserve">
          <source>The functionality described in EEP10 was implemented in Erlang/OTP R13A.</source>
          <target state="translated">EEP10에 설명 된 기능은 Erlang / OTP R13A에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4c5930ab45c4ff48e920b1f1f0e771ba10a38ad" translate="yes" xml:space="preserve">
          <source>The functionality of &lt;code&gt;server&lt;/code&gt; can be extended without having to change &lt;code&gt;ch2&lt;/code&gt; or any other callback module.</source>
          <target state="translated">&lt;code&gt;ch2&lt;/code&gt; 또는 다른 콜백 모듈 을 변경하지 않고도 &lt;code&gt;server&lt;/code&gt; 의 기능을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42a7b913d2b289987ee5e2464734af014db9f20b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; may be used to modify and read verbosity levels during test execution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; 함수 는 테스트 실행 중 자세한 레벨을 수정하고 읽는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9c838a14637c7a4c6ed49ae71fd28e08b8189c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt;, in the &lt;code&gt;erl_parse&lt;/code&gt; module can be used for manipulating annotations in abstract code.</source>
          <target state="translated">[함수 &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt; 는에 &lt;code&gt;erl_parse&lt;/code&gt; 의 모듈 추상 코드에 주석을 조작하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4ef5f76ccaeeff0245cc5352fd37788847bc8dd4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;erl_scan&lt;/code&gt; module can be used for inspecting annotations in tokens.</source>
          <target state="translated">기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;erl_scan&lt;/code&gt; 모듈 토큰에 특수 효과를 검사하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="8f1eb93f5b31a056ece4e165a375a5884952e8c6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; can be used to add and delete replicas of the schema table. Adding a node to the list of nodes where the schema is replicated affects the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 스키마 테이블의 복제본을 추가하고 삭제할 수 있습니다. 스키마가 복제되는 노드 목록에 노드를 추가하면 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="1886785ff0b77240f1ec57a522b97c8411209098" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; are used to get a limited number of results, where &lt;code&gt;Continuation&lt;/code&gt; gets the next chunk of results. &lt;code&gt;Mnesia&lt;/code&gt; uses &lt;code&gt;NObjects&lt;/code&gt; as a recommendation only. Thus, more or less results than specified with &lt;code&gt;NObjects&lt;/code&gt; can be returned in the result list, even the empty list can be returned even if there are more results to collect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 함수 는 제한된 수의 결과를 얻는 데 사용되며, 여기서 &lt;code&gt;Continuation&lt;/code&gt; 은 다음 결과 덩어리를 가져옵니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 사용 &lt;code&gt;NObjects&lt;/code&gt; 을 만 추천한다. 따라서 &lt;code&gt;NObjects&lt;/code&gt; 지정된 것보다 많거나 적은 결과가 결과 목록에 리턴 될 수 있으며, 수집 할 결과가 더 있어도 빈 목록이 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902b2335f36e3393b5572f1006845ff1177285c7" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; can be used to obtain information about the potential master nodes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 잠재적 마스터 노드에 대한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7162f97290d0f08d1d6fce536552b6112fd005e" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; can now be expressed in terms of &lt;code&gt;map&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;add_one&lt;/code&gt; 함수 는 이제 다음과 같이 &lt;code&gt;map&lt;/code&gt; 으로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="222156c9e6dd9e3d178176d3e89b557b47249290" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; have a similar structure. This can be used by writing a function &lt;code&gt;map&lt;/code&gt; that expresses this similarity:</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;add_one&lt;/code&gt; 함수 는 유사한 구조를 갖습니다. 이 유사성을 나타내는 함수 &lt;code&gt;map&lt;/code&gt; 을 작성하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="648f7da232361f38f861a299d3f2d536886a367c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;first/[1,2]&lt;/code&gt;, &lt;code&gt;last/[1,2]&lt;/code&gt;, &lt;code&gt;next/[1,2]&lt;/code&gt;, &lt;code&gt;prev[1,2]&lt;/code&gt; and &lt;code&gt;select/[3,4]&lt;/code&gt; assumes there is a result set associated with the connection to work on. Calling the function &lt;code&gt;select_count/[2,3]&lt;/code&gt; associates such a result set with the connection. Calling select_count again will remove the current result set association and create a new one. Calling a function which dose not operate on an associated result sets, such as &lt;code&gt;sql_query/[2,3]&lt;/code&gt;, will remove the current result set association.</source>
          <target state="translated">기능 &lt;code&gt;first/[1,2]&lt;/code&gt; , &lt;code&gt;last/[1,2]&lt;/code&gt; , &lt;code&gt;next/[1,2]&lt;/code&gt; , &lt;code&gt;prev[1,2]&lt;/code&gt; 및 &lt;code&gt;select/[3,4]&lt;/code&gt; 접속과 연관된 결과 세트가 있다고 가정 작업합니다. &lt;code&gt;select_count/[2,3]&lt;/code&gt; 함수를 호출하면 이러한 결과 세트가 연결과 연관됩니다. select_count를 다시 호출하면 현재 결과 세트 연관이 제거되고 새로 작성됩니다. &lt;code&gt;sql_query/[2,3]&lt;/code&gt; 과 같이 연관된 결과 세트에서 작동하지 않는 함수를 호출 하면 현재 결과 세트 연관이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f5fc6fff1054bde43efdc57cd822c6d67516d395" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;get_s&lt;/code&gt; and &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; are utilities that are used to make the code shorter. &lt;code&gt;get_s&lt;/code&gt; duplicates the string and zero-terminates it, as the postgres client library wants that. &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; takes an &lt;code&gt;ei_x_buff&lt;/code&gt; buffer, allocates a binary, and copies the data there. This binary is returned in &lt;code&gt;*rbuf&lt;/code&gt;. (Notice that this binary is freed by the emulator, not by us.)</source>
          <target state="translated">&lt;code&gt;get_s&lt;/code&gt; 및 &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 함수 는 코드를 더 짧게 만드는 데 사용되는 유틸리티입니다. &lt;code&gt;get_s&lt;/code&gt; 는 postgres 클라이언트 라이브러리가 원하는대로 문자열을 복제하고 0으로 종료합니다. &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 는 &lt;code&gt;ei_x_buff&lt;/code&gt; 버퍼를 가져와 이진을 할당 한 다음 여기에 데이터를 복사합니다. 이 바이너리는 &lt;code&gt;*rbuf&lt;/code&gt; 로 반환됩니다 . (이 바이너리는 우리가 아닌 에뮬레이터에 의해 해제됩니다.)</target>
        </trans-unit>
        <trans-unit id="5096e39491b69e094a3f98629aa50fa1108f0a5e" translate="yes" xml:space="preserve">
          <source>The functions above have an optional argument, &lt;code&gt;Options&lt;/code&gt;. It is a list which can contain the following elements:</source>
          <target state="translated">위의 함수에는 옵션 인수 &lt;code&gt;Options&lt;/code&gt; 있습니다. 다음 요소를 포함 할 수있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4cf9cf212abd94252e34e02e2e21ec1dc4af5994" translate="yes" xml:space="preserve">
          <source>The functions allowed in &lt;code&gt;match_spec&lt;/code&gt; work as follows:</source>
          <target state="translated">&lt;code&gt;match_spec&lt;/code&gt; 에서 허용되는 함수 는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b49c5e0b193b751df77e5b417fa995fca0d1e1a2" translate="yes" xml:space="preserve">
          <source>The functions allowed only for tracing work as follows:</source>
          <target state="translated">추적 작업에만 허용되는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c38557bf4878ec1f68819130f6538837da45503c" translate="yes" xml:space="preserve">
          <source>The functions are also used as input and output for parse transforms, see the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">함수는 구문 분석 변환의 입력 및 출력으로도 사용됩니다 &lt;code&gt;compile(3)&lt;/code&gt; 모듈 참조 ) .</target>
        </trans-unit>
        <trans-unit id="b767ef0cfc20ad008772285b7b151d13f3e95f0c" translate="yes" xml:space="preserve">
          <source>The functions are deliberately kept as simple as possible, for readability reasons.</source>
          <target state="translated">가독성을 위해 기능은 가능한 한 단순하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="45f09a589c0917e05c505ec254a5e8229659ac40" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-run&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">기능은 초기화 프로세스에서 순차적으로 실행 된 다음 정상적으로 종료되고 사용자에게 제어를 전달합니다. 이는 리턴하지 않는 &lt;code&gt;-run&lt;/code&gt; 호출이 추가 처리를 차단 함을 의미합니다 . 이런 경우를 피하기 위해 &lt;code&gt;spawn&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="926aaaf3b21fb32d1bbb6e4c88da0fdf9d06509c" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-s&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">기능은 초기화 프로세스에서 순차적으로 실행 된 다음 정상적으로 종료되고 사용자에게 제어를 전달합니다. 이는 리턴하지 않는 &lt;code&gt;-s&lt;/code&gt; 호출이 추가 처리를 차단 함을 의미합니다 . 이런 경우를 피하기 위해 &lt;code&gt;spawn&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="16b3d921f3dab11c8bd9dcd981b467c9ea9eb69b" translate="yes" xml:space="preserve">
          <source>The functions are kept for backward compatibility, but are not recommended. They will be deprecated in a future release.</source>
          <target state="translated">기능은 이전 버전과의 호환성을 위해 유지되지만 권장되지는 않습니다. 향후 릴리스에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e16c3bfea1464fe2701a69fbec438e22d449fa1c" translate="yes" xml:space="preserve">
          <source>The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but not all functions verify that all binaries are encoded correctly.</source>
          <target state="translated">유효하지 않은 입력 문자열에 대해 함수가 충돌 할 수 있습니다. 예를 들어, 함수는 UTF-8 바이너리를 예상하지만 모든 함수가 모든 바이너리가 올바르게 인코딩되었는지 확인하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dd2b5b372777bf5bb017e0da931269beb671e840" translate="yes" xml:space="preserve">
          <source>The functions for receiving and sending data are combined into a function, pointed out by the driver structure. The data sent into the port is given as arguments, and the replied data is sent with the C-function &lt;code&gt;driver_output&lt;/code&gt;.</source>
          <target state="translated">데이터 수신 및 전송 기능은 드라이버 구조에 의해 지적 된 기능으로 결합됩니다. 포트로 전송 된 데이터는 인수로 제공되며 응답 된 데이터는 C 함수 &lt;code&gt;driver_output&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebbfff7f1d8a39c016464e3f5cebc0cf7001e164" translate="yes" xml:space="preserve">
          <source>The functions implemented by this module cover the following use cases:</source>
          <target state="translated">이 모듈로 구현 된 기능은 다음 사용 사례를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c86b667b04bbb8c7ab1bce69786f4f6966eec074" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;systools&lt;/code&gt; require more information. If they are used, the following keys are mandatory:</source>
          <target state="translated">&lt;code&gt;systools&lt;/code&gt; 의 기능 에는 추가 정보가 필요합니다. 이들이 사용되는 경우 다음 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="2c1aa340d685d0c3733736a0ada3b9ea70cc9c9a" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;io&lt;/code&gt; module cannot be used, as they can only talk to an Erlang process. Instead, use functions &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈 의 기능 은 Erlang 프로세스와 만 대화 할 수 있으므로 사용할 수 없습니다. 대신, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25876dba4377f3e108142ac910ecc80fd99f8dd" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;timer&lt;/code&gt; module that do not manage timers (such as &lt;code&gt;timer:tc/3&lt;/code&gt; or &lt;code&gt;timer:sleep/1&lt;/code&gt;), do not call the timer-server process and are therefore harmless.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 관리하지 않는 타이머 모듈 의 기능 (예 : &lt;code&gt;timer:tc/3&lt;/code&gt; 또는 &lt;code&gt;timer:sleep/1&lt;/code&gt; )은 타이머 서버 프로세스를 호출하지 않으므로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="bc5c8ab81c744e8799da4f1bbc208d8534384ca8" translate="yes" xml:space="preserve">
          <source>The functions in the module &lt;code&gt;file&lt;/code&gt; usually treat binaries as raw filenames, that is, they are passed &quot;as is&quot; even when the encoding of the binary does not agree with &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt;. However, this function expects binaries to be encoded according to the value returned by &lt;code&gt;native_name_encoding()&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;file&lt;/code&gt; 의 함수는 일반적으로 바이너리를 원시 파일 이름으로 취급합니다. 즉, 바이너리의 인코딩이 &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt; 과 일치하지 않더라도 &quot;있는 그대로&quot;전달됩니다 . 그러나이 함수는 &lt;code&gt;native_name_encoding()&lt;/code&gt; 반환 한 값에 따라 바이너리가 인코딩 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="59fe37bf337f659a6dcf2745738cdc7eba91db8e" translate="yes" xml:space="preserve">
          <source>The functions in this module are invoked automatically by the Erlang compiler. There is no reason to invoke these functions separately unless you have written your own Erlang compiler.</source>
          <target state="translated">이 모듈의 함수는 Erlang 컴파일러에 의해 자동으로 호출됩니다. Erlang 컴파일러를 직접 작성하지 않은 경우 이러한 함수를 별도로 호출 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="83d017ac05dd2cacc80880c2e28d8a757b9c1403" translate="yes" xml:space="preserve">
          <source>The functions in this module are operating system-specific. Careless use of these functions results in programs that will only run on a specific platform. On the other hand, with careful use, these functions can be of help in enabling a program to run on most platforms.</source>
          <target state="translated">이 모듈의 기능은 운영 체제별로 다릅니다. 이러한 기능을 부주의하게 사용하면 특정 플랫폼에서만 실행되는 프로그램이 생성됩니다. 반면에 이러한 기능은주의해서 사용하면 대부분의 플랫폼에서 프로그램을 실행하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0090b523e8b96e6009643e2f865f32e534e6e35f" translate="yes" xml:space="preserve">
          <source>The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong.</source>
          <target state="translated">이 모듈의 기능은 인쇄에 적합한 추상 형태의 미적으로 매력적인 표현을 생성하는 데 사용됩니다. 모든 함수는 문자 목록을 리턴하고 (양식이 깊은 경우) 양식이 잘못된 경우 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6379807804d510c1358bcad10b50d619a7c10261" translate="yes" xml:space="preserve">
          <source>The functions in this module exits with reason &lt;code&gt;badarg&lt;/code&gt; if any argument has the wrong format, if the table identifier is invalid, or if the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 모듈의 함수는 인수의 형식이 올바르지 않거나 테이블 ID가 유효하지 않거나 테이블 액세스 권한 ( &lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt; )으로 인해 조작이 거부 된 경우 이유 &lt;code&gt;badarg&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="407acf4eb1d452f08e4cd9870e0fbf1bd80ec28b" translate="yes" xml:space="preserve">
          <source>The functions make references to a debug structure. The debug structure is a list of &lt;code&gt;dbg_opt()&lt;/code&gt;, which is an internal data type used by function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt;. No debugging is performed if it is an empty list.</source>
          <target state="translated">함수는 디버그 구조를 참조합니다. 디버그 구조는 &lt;code&gt;dbg_opt()&lt;/code&gt; 의 목록이며 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수가 사용하는 내부 데이터 유형 입니다. 빈 목록이면 디버깅이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95e0480086d8c1cfed57c30b1e75f554c1263ba9" translate="yes" xml:space="preserve">
          <source>The functions of this module exit the process with a &lt;code&gt;badarg&lt;/code&gt;, &lt;code&gt;bad_function&lt;/code&gt;, or &lt;code&gt;type_mismatch&lt;/code&gt; message when given badly formed arguments or sets the types of which are not compatible.</source>
          <target state="translated">이 모듈의 함수는 잘못 구성된 인수가 제공되거나 호환되지 않는 유형을 설정하면 &lt;code&gt;badarg&lt;/code&gt; , &lt;code&gt;bad_function&lt;/code&gt; 또는 &lt;code&gt;type_mismatch&lt;/code&gt; 메시지 와 함께 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="8bcd836e7cff1f3fb60829e13f437e52a77a3d68" translate="yes" xml:space="preserve">
          <source>The functions returns &lt;code&gt;{module,Module}&lt;/code&gt; if the module was interpreted, otherwise &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">모듈이 해석되면 함수는 &lt;code&gt;{module,Module}&lt;/code&gt; 을 리턴 하고 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c5ba17f384a51d8defb699da21623e5d4d6f29" translate="yes" xml:space="preserve">
          <source>The functions with explicit state never use the process dictionary.</source>
          <target state="translated">명시 적 상태의 함수는 프로세스 사전을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dee609877073beca17837c5cc489fd792ebd7be" translate="yes" xml:space="preserve">
          <source>The functions with implicit state use the process dictionary variable &lt;code&gt;rand_seed&lt;/code&gt; to remember the current state.</source>
          <target state="translated">암시 적 상태의 함수는 프로세스 사전 변수 &lt;code&gt;rand_seed&lt;/code&gt; 를 사용하여 현재 상태를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="3598aafeb02f3f06b45b8fa49e0ea66cd9f4c8c2" translate="yes" xml:space="preserve">
          <source>The fundamental difference between this API and &lt;code&gt;connect/*&lt;/code&gt; is that the return value is that of the underlying OS &lt;code&gt;connect(2)&lt;/code&gt; system call. If &lt;code&gt;ok&lt;/code&gt; is returned, the result of the association establishment is received by the calling process as an &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; event. The calling process must be prepared to receive this, or poll for it using &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, depending on the value of the active option.</source>
          <target state="translated">이 API와 &lt;code&gt;connect/*&lt;/code&gt; 의 근본적인 차이점 은 반환 값이 기본 OS &lt;code&gt;connect(2)&lt;/code&gt; 시스템 호출 의 값이라는 것입니다 . 경우에 &lt;code&gt;ok&lt;/code&gt; 리턴 된 관계 성립의 결과로는 호출 프로세스에 의해 수신 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 이벤트. 호출 프로세스는이를 수신하거나 활성 옵션의 값에 따라 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 를 사용하여 폴링하도록 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="988b6a9c1d9ecd81d685b26b761fdee058fdc894" translate="yes" xml:space="preserve">
          <source>The gain is twofold:</source>
          <target state="translated">이득은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="bcf404e4d234a44441e22cb6261963b4fedd0d7d" translate="yes" xml:space="preserve">
          <source>The gain of using selective and exclusive decode instead of a complete decode is greater the bigger the value and the less deep in the structure you have to decode.</source>
          <target state="translated">완전한 디코딩 대신 선택적 및 배타적 디코딩을 사용하면 값이 클수록 디코딩해야하는 구조의 깊이가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fe50c99cca6dabfaacf57c3d4d8ac0b0024f73ef" translate="yes" xml:space="preserve">
          <source>The garbage collector can also shrink the heap if it is much larger than the amount of data stored on it; setting the minimum heap size prevents that.</source>
          <target state="translated">가비지 수집기는 힙에 저장된 데이터 양보다 훨씬 큰 경우 힙을 축소 할 수도 있습니다. 최소 힙 크기를 설정하면이를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977899977ecd5bafb69cd4c8bac5e829e78b713f" translate="yes" xml:space="preserve">
          <source>The general events are as follows:</source>
          <target state="translated">일반적인 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a45457862e4fc4686a75b757e6f11948bde74a0" translate="yes" xml:space="preserve">
          <source>The general form of bit strings is &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are positive integers. It denotes a bit string that is &lt;code&gt;M + (k*N)&lt;/code&gt; bits long (that is, a bit string that starts with &lt;code&gt;M&lt;/code&gt; bits and continues with &lt;code&gt;k&lt;/code&gt; segments of &lt;code&gt;N&lt;/code&gt; bits each, where &lt;code&gt;k&lt;/code&gt; is also a positive integer). The notations &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; are convenient shorthands for the cases that &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt;, or both, are zero.</source>
          <target state="translated">비트 문자열의 일반적인 형식은 &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt; 이며 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 은 양의 정수입니다. 이는 &lt;code&gt;M + (k*N)&lt;/code&gt; 비트 길이 의 비트 열을 나타냅니다 (즉, &lt;code&gt;M&lt;/code&gt; 비트로 시작하고 각각 &lt;code&gt;N&lt;/code&gt; 비트 의 &lt;code&gt;k&lt;/code&gt; 세그먼트로 계속되는 비트 열 ). &lt;code&gt;k&lt;/code&gt; 는 양의 정수입니다. &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 표기법 은 &lt;code&gt;M&lt;/code&gt; 또는 &lt;code&gt;N&lt;/code&gt; 또는 둘 모두가 0 인 경우 편리한 속기입니다 .</target>
        </trans-unit>
        <trans-unit id="15c107121f9e396eb9a5cd9589f0c40d15c3390b" translate="yes" xml:space="preserve">
          <source>The general form of map types is &lt;code&gt;#{AssociationList}&lt;/code&gt;. The key types in &lt;code&gt;AssociationList&lt;/code&gt; are allowed to overlap, and if they do, the leftmost association takes precedence. A map association has a key in &lt;code&gt;AssociationList&lt;/code&gt; if it belongs to this type. &lt;code&gt;AssociationList&lt;/code&gt; can contain both mandatory and optional association types. If an association type is mandatory, an association with that type is to be present. In the case of an optional association type it is not required for the key type to be present.</source>
          <target state="translated">맵 유형의 일반적인 형식은 &lt;code&gt;#{AssociationList}&lt;/code&gt; 입니다. &lt;code&gt;AssociationList&lt;/code&gt; 의 키 유형은 겹칠 수 있으며, 그 경우 가장 왼쪽의 연결이 우선합니다. 맵 연관 이이 유형에 속하는 경우 &lt;code&gt;AssociationList&lt;/code&gt; 에 키가 있습니다. &lt;code&gt;AssociationList&lt;/code&gt; 는 필수 및 선택적 연관 유형을 모두 포함 할 수 있습니다. 연결 유형이 필수 인 경우 해당 유형과의 연결이 있어야합니다. 선택적 연결 유형의 경우 키 유형이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa26e067e726a95a6d2e3dc44ecd0d512cccd537" translate="yes" xml:space="preserve">
          <source>The general format of a control sequence is &lt;code&gt;~F.P.PadModC&lt;/code&gt;.</source>
          <target state="translated">제어 순서의 일반적인 형식은 &lt;code&gt;~F.P.PadModC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48292e72b50e679a5bd265d2003a203029b9008b" translate="yes" xml:space="preserve">
          <source>The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be &amp;lt; 65536, and the first must be less than or equal to the second. For example, the following matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;:</source>
          <target state="translated">일반 반복 수량 화기는 두 개의 숫자를 중괄호 (중괄호)로 묶어 쉼표로 구분하여 허용되는 일치 항목의 최소 및 최대 수를 지정합니다. 숫자는 &amp;lt;65536이어야하고 첫 번째는 두 번째보다 작거나 같아야합니다. 예를 들어, 다음은 &quot;zz&quot;, &quot;zzz&quot;또는 &quot;zzzz&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e8ceed6edc3f642d5944e6d5d983920ce28f447b" translate="yes" xml:space="preserve">
          <source>The general verbosity level is not associated with any particular category. This level sets the threshold for the standard I/O printouts, uncategorized &lt;code&gt;ct:log/print/pal&lt;/code&gt; printouts, and printouts for categories with undefined verbosity level.</source>
          <target state="translated">일반적인 상세 수준은 특정 범주와 관련이 없습니다. 이 레벨은 표준 I / O 출력, 분류되지 않은 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 출력 및 정의되지 않은 상세 레벨이있는 ​​카테고리의 출력에 대한 임계 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="15f1ac9edee948d6f4ef43892cbf77bf286d9bf4" translate="yes" xml:space="preserve">
          <source>The generated .script (and .boot) file uses the environment variable &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; as prefix for the paths to all applications. The &lt;code&gt;-boot_var&lt;/code&gt; option to &lt;code&gt;erl&lt;/code&gt; can be used for specifying the value of this variable, typically &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt;.</source>
          <target state="translated">생성 된 .script (및 .boot) 파일은 환경 변수 &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; 를 모든 애플리케이션에 대한 경로의 접두어로 사용합니다. &lt;code&gt;erl&lt;/code&gt; 에 대한 &lt;code&gt;-boot_var&lt;/code&gt; 옵션 은이 변수의 값을 지정하는 데 사용할 수 있습니다 (일반적으로 &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0c99eee4f85e52f6340a9da42977768f1eebdd2c" translate="yes" xml:space="preserve">
          <source>The generated Erlang files are placed in the current directory or in the directory specified with option &lt;code&gt;{outdir,Dir}&lt;/code&gt;.</source>
          <target state="translated">생성 된 Erlang 파일은 현재 디렉토리 또는 &lt;code&gt;{outdir,Dir}&lt;/code&gt; 옵션으로 지정된 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c577f200898187404181ae175171d50fcb091818" translate="yes" xml:space="preserve">
          <source>The generated Erlang module always gets the same name as the &lt;code&gt;ASN.1&lt;/code&gt; module. Therefore, only one encoding rule per &lt;code&gt;ASN.1&lt;/code&gt; module can be used at runtime.</source>
          <target state="translated">생성 된 Erlang 모듈은 항상 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 과 동일한 이름을 갖습니다 . 따라서 런타임시 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 당 하나의 인코딩 규칙 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc9a629a78265b39c4931fa85c066a035d12976" translate="yes" xml:space="preserve">
          <source>The generated conversion functions are named &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; and &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt;.</source>
          <target state="translated">생성 된 변환 함수의 이름은 &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; 및 &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70590dbda20778e7131e69e54b148688eb50a6db" translate="yes" xml:space="preserve">
          <source>The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval.</source>
          <target state="translated">생성 된 숫자는 N * 2.0 ^ (-53) 형식입니다. 간격이 똑같습니다.</target>
        </trans-unit>
        <trans-unit id="d46f1c06452ab11c5b4b6ecb5baaa5c431f8b627" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">가수의 모든 비트가 무작위이기 때문에이 함수에서 생성 된 숫자는 일반 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자에 대해 더 세분화되었습니다 . 이 속성은 정확히 0이 반환되지 않는다는 사실과 함께 &lt;code&gt;1.0 / X&lt;/code&gt; 또는 &lt;code&gt;math:log(X)&lt;/code&gt; 와 같은 알고리즘에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="73171ef35be5bd8ba621019aa17e69f855a0576a" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">가수의 모든 비트가 무작위이기 때문에이 함수에서 생성 된 숫자는 일반 &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자에 대해 더 세분화되었습니다 . 이 속성은 정확히 0이 반환되지 않는다는 사실과 함께 &lt;code&gt;1.0 / X&lt;/code&gt; 또는 &lt;code&gt;math:log(X)&lt;/code&gt; 와 같은 알고리즘에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="9601b63aa3ab5a33ac60d263c74f85eedd8bb618" translate="yes" xml:space="preserve">
          <source>The generation of default functions for tables works for tables which use the &lt;code&gt;RowStatus&lt;/code&gt; textual convention from SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.</source>
          <target state="translated">테이블의 기본 기능 생성은 STANDARD-MIB 및 SNMPv2-TC에 정의 된 SNMPv2 의 &lt;code&gt;RowStatus&lt;/code&gt; 텍스트 규칙 을 사용하는 테이블에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a98f897827fbccc29809d0ff98a0c6185bd547f8" translate="yes" xml:space="preserve">
          <source>The generator function &lt;code&gt;GenFun&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">생성기 함수 &lt;code&gt;GenFun&lt;/code&gt; 은 테스트 세트를 생성하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1f65b0f29d2eaf723597fb4ded6e5f61662cb2a0" translate="yes" xml:space="preserve">
          <source>The generator now contains unbound variables and the test has been moved into the filter.</source>
          <target state="translated">제너레이터는 이제 언 바운드 변수를 포함하고 테스트는 필터로 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="df67d175f37e161fc283f4c21214ba8ff79c07f4" translate="yes" xml:space="preserve">
          <source>The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment:</source>
          <target state="translated">일반 URI 구문은 체계, 권한, 경로, 쿼리 및 조각이라고하는 계층 적 구성 요소 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="edcc58c1f9412f2d84d5eca2fbc303265ca32bc7" translate="yes" xml:space="preserve">
          <source>The generic encode and decode functions can be called as follows:</source>
          <target state="translated">일반 인코딩 및 디코딩 기능은 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a0f25dc460ac798f2b85a01f268cff421ca237" translate="yes" xml:space="preserve">
          <source>The generic full name of the file is thus:</source>
          <target state="translated">파일의 일반 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="953d4c56983eabeb70f721a6678334568e77d77a" translate="yes" xml:space="preserve">
          <source>The given BEAM file (with or without the &lt;code&gt;.beam&lt;/code&gt; extension) or the file found by calling &lt;code&gt;code:which(Module)&lt;/code&gt; is checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 BEAM 파일 ( &lt;code&gt;.beam&lt;/code&gt; 확장자 가 있거나없는 ) 또는 &lt;code&gt;code:which(Module)&lt;/code&gt; 을 호출하여 찾은 파일 은 &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 , &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 및 사용되지 않은 로컬 함수에 대해 검사됩니다. 코드 경로는 &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e66a4ab696e12e0f12a8dd69e7f5bb33fedf0273" translate="yes" xml:space="preserve">
          <source>The global name server also performs the critical task of continuously monitoring changes in node configuration. If a node that runs a globally registered process goes down, the name is globally unregistered. To this end, the global name server subscribes to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages sent from module &lt;code&gt;net_kernel&lt;/code&gt;. Relevant Kernel application variables in this context are &lt;code&gt;net_setuptime&lt;/code&gt;, &lt;code&gt;net_ticktime&lt;/code&gt;, and &lt;code&gt;dist_auto_connect&lt;/code&gt;. See also &lt;code&gt;kernel(6)&lt;/code&gt;.</source>
          <target state="translated">글로벌 이름 서버는 또한 노드 구성의 변경 사항을 지속적으로 모니터링하는 중요한 작업을 수행합니다. 전역으로 등록 된 프로세스를 실행하는 노드가 작동 중지되면 이름이 전체적으로 등록 취소됩니다. 이를 위해 글로벌 네임 서버가 등록한 정보는 다음의 제품에 &lt;code&gt;nodeup&lt;/code&gt; 및 &lt;code&gt;nodedown&lt;/code&gt; 메시지는 모듈에서 전송 &lt;code&gt;net_kernel&lt;/code&gt; . 이 컨텍스트에서 관련 커널 응용 프로그램 변수는 &lt;code&gt;net_setuptime&lt;/code&gt; , &lt;code&gt;net_ticktime&lt;/code&gt; 및 &lt;code&gt;dist_auto_connect&lt;/code&gt; 입니다. &lt;code&gt;kernel(6)&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f36454620d0c52943c78b70c7b2d67415456c6b" translate="yes" xml:space="preserve">
          <source>The global name server keeps track of all processes sharing the same lock, that is, if two processes set the same lock, both processes must delete the lock.</source>
          <target state="translated">전역 이름 서버는 동일한 잠금을 공유하는 모든 프로세스를 추적합니다. 즉, 두 프로세스가 동일한 잠금을 설정하면 두 프로세스 모두 잠금을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="46c28148b1520b8f7f30b407f534c21425582a89" translate="yes" xml:space="preserve">
          <source>The global state of the scanner, represented by the #xmerl_scanner{} record.</source>
          <target state="translated">#xmerl_scanner {} 레코드로 표시되는 스캐너의 전역 상태입니다.</target>
        </trans-unit>
        <trans-unit id="162600e8983ca6d0de97e2e5c21045cca4665270" translate="yes" xml:space="preserve">
          <source>The global state of the validator. It is representated by the &lt;code&gt;#xsd_state{}&lt;/code&gt; record.</source>
          <target state="translated">유효성 검사기의 전역 상태입니다. 그것은에 의해 representated됩니다 &lt;code&gt;#xsd_state{}&lt;/code&gt; 기록.</target>
        </trans-unit>
        <trans-unit id="1531d8568b38b4970f1055504bbf9c235ba48c8c" translate="yes" xml:space="preserve">
          <source>The grammar starts with an optional &lt;code&gt;header&lt;/code&gt; section. The header is put first in the generated file, before the module declaration. The purpose of the header is to provide a means to make the documentation generated by EDoc look nicer. Each header line should be enclosed in double quotes, and newlines will be inserted between the lines. For example:</source>
          <target state="translated">문법은 선택적인 &lt;code&gt;header&lt;/code&gt; 섹션 으로 시작 합니다. 헤더는 생성 된 파일에서 먼저 모듈 선언 전에 배치됩니다. 헤더의 목적은 EDoc에 의해 생성 된 문서를 더보기 좋게 만드는 수단을 제공하는 것입니다. 각 머리글 줄은 큰 따옴표로 묶어야하며 줄 사이에 줄 바꿈이 삽입됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95e4974bf09526a8ed59c2c706017450837fabc7" translate="yes" xml:space="preserve">
          <source>The granularity of both measurement types can be high. Therefore, ensure that each individual measurement lasts for at least several seconds.</source>
          <target state="translated">두 측정 유형의 입도는 높을 수 있습니다. 따라서 각 개별 측정이 최소한 몇 초 동안 지속되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="db89aebec1f27ef7ea7b0173203949ea669de4bc" translate="yes" xml:space="preserve">
          <source>The graphical library &lt;code&gt;wx&lt;/code&gt; has extensive support for Unicode text.</source>
          <target state="translated">그래픽 라이브러리 &lt;code&gt;wx&lt;/code&gt; 는 유니 코드 텍스트를 광범위하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3809a7766a11eb66968ebebc3b973ccfe307fc2b" translate="yes" xml:space="preserve">
          <source>The group information properties override those set with the suite information function, and can in turn be overridden by test case information properties. For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그룹 정보 특성은 스위트 정보 기능으로 설정된 특성을 대체하며 테스트 케이스 정보 특성으로 대체 될 수 있습니다. 유효한 정보 특성 및보다 일반적인 정보의 목록은 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1851720cf81d08f4729a487b12a49fba130b63d" translate="yes" xml:space="preserve">
          <source>The group leader should be rarely changed in applications with a supervision tree, because OTP assumes the group leader of their processes is their application master.</source>
          <target state="translated">OTP는 프로세스의 그룹 리더가 애플리케이션 마스터라고 가정하기 때문에 감독 트리가있는 애플리케이션에서는 그룹 리더를 거의 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e52640716213a6b8b724c7b3e51f40080bcd9da2" translate="yes" xml:space="preserve">
          <source>The group path specification does not necessarily have to include &lt;strong&gt;all&lt;/strong&gt; groups in the path to the terminating group. &lt;code&gt;Common Test&lt;/code&gt; searches for all matching paths if an incomplete group path is specified.</source>
          <target state="translated">그룹 경로 지정은 반드시 종료 그룹에 대한 경로에 &lt;strong&gt;모든&lt;/strong&gt; 그룹 을 포함 할 필요는 없습니다 . 불완전한 그룹 경로가 지정되면 &lt;code&gt;Common Test&lt;/code&gt; 는 일치하는 모든 경로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6fc0b568a02963a296071a7bbdb0400eec8c4cbb" translate="yes" xml:space="preserve">
          <source>The group specification feature, as presented in this section, can also be used in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; (with some extra features added).</source>
          <target state="translated">이 섹션에 제시된 그룹 사양 기능은 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 에서도 사용할 수 있습니다 (일부 추가 기능이 추가됨).</target>
        </trans-unit>
        <trans-unit id="75d39fc54f161038ac9929455075c4ce189bfbf6" translate="yes" xml:space="preserve">
          <source>The groups are given explicitly in this list. There may be several elements with the same &lt;code&gt;Size&lt;/code&gt;. In such a case, the server will choose one randomly in the negotiated Size.</source>
          <target state="translated">그룹은이 목록에 명시 적으로 제공됩니다. &lt;code&gt;Size&lt;/code&gt; 가 같은 여러 요소가있을 수 있습니다 . 이 경우 서버는 협상 된 크기에서 임의로 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="57c1aab7095657e5f03ad172fdff464c6e0393b1" translate="yes" xml:space="preserve">
          <source>The guard BIFs: &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;, &lt;code&gt;hd&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;tl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">가드 BIF : &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;element&lt;/code&gt; , &lt;code&gt;hd&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; , &lt;code&gt;tl&lt;/code&gt; , &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf11284c55c81df64e31546d61edba51bacfcf93" translate="yes" xml:space="preserve">
          <source>The guard section can contain any guard expression of Erlang. The following is a list of BIFs and expressions:</source>
          <target state="translated">가드 섹션에는 Erlang의 가드 표현이 포함될 수 있습니다. 다음은 BIF 및 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="08f011ebed41a7bf74303ee2b30d0e5329b2ea66" translate="yes" xml:space="preserve">
          <source>The guard sequence, if any, is true.</source>
          <target state="translated">가드 시퀀스 (있는 경우)는 true입니다.</target>
        </trans-unit>
        <trans-unit id="49c4b028972dd181f72352fd5792e1cbd70780a8" translate="yes" xml:space="preserve">
          <source>The handler has an overload protection mechanism that keeps the handler process and the Kernel application alive during high loads of log events. How overload protection works, and how to configure it, is described in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">처리기에는 과부하 로그 메커니즘이있어 처리기 프로세스와 커널 응용 프로그램이 로그 이벤트가 많을 때에도 활성 상태를 유지합니다. 과부하 보호 작동 방식 및 구성 방법은 사용 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de57b137d6629cde5167564ce3d26dcfae749ef" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config1&lt;/code&gt;.</source>
          <target state="translated">핸들러 ID는 &lt;code&gt;Config1&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 키 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eeb6be906051436af44ca3913114022b11b4c8a" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">핸들러 ID는 &lt;code&gt;Config&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 키 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="88387fc69eaf6d2117329bee1a573a3818611863" translate="yes" xml:space="preserve">
          <source>The handler is not overload protected.</source>
          <target state="translated">처리기는 과부하 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7cc7f26c0b9fef31e9d9003214e5eb8f80f6985" translate="yes" xml:space="preserve">
          <source>The handler must log the event.</source>
          <target state="translated">핸들러는 이벤트를 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="91c3bfd8524a78feb62740d6ae1b2a4f89bcfb08" translate="yes" xml:space="preserve">
          <source>The handler process keeps track of the length of its message queue and takes some form of action when the current length exceeds a configurable threshold. The purpose is to keep the handler in, or to as quickly as possible get the handler into, a state where it can keep up with the pace of incoming log events. The memory use of the handler must never grow larger and larger, since that will eventually cause the handler to crash. These three thresholds, with associated actions, exist:</source>
          <target state="translated">핸들러 프로세스는 메시지 큐 길이를 추적하고 현재 길이가 구성 가능한 임계 값을 초과 할 때 어떤 형태의 조치를 취합니다. 처리기는 들어오는 로그 이벤트의 속도에 따라 처리기를 유지하거나 가능한 빨리 처리기를 가져 오는 것입니다. 핸들러의 메모리 사용은 커져서는 안됩니다. 결국 핸들러가 충돌 할 수 있습니다. 연관된 조치와 함께 다음 세 가지 임계 값이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="d669a7746b992304543fe0d69213b6644ee12b90" translate="yes" xml:space="preserve">
          <source>The handlers are called in sequence, and the order is not defined.</source>
          <target state="translated">핸들러는 순서대로 호출되며 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa6b9a858fe6ebad4a9654a225cc08daa061a060" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated, and Perl has changed in recent releases, causing PCRE also to change. Outside a character class, PCRE reads the digit and any following digits as a decimal number. If the number is &amp;lt; 8, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a &lt;strong&gt;back reference&lt;/strong&gt;. A description of how this works is provided later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">백 슬래시 다음에 0 이외의 숫자를 처리하는 것은 복잡하며 Perl은 최근 릴리스에서 변경되어 PCRE도 변경되었습니다. 문자 클래스 외부에서 PCRE는 숫자와 다음 숫자를 10 진수로 읽습니다. 숫자가 &amp;lt;8이거나 표현식에 이전에 캡처 된 왼쪽 괄호가 많으면 전체 시퀀스가 &lt;strong&gt;역 참조로 사용&lt;/strong&gt; 됩니다. 이것의 작동 방식에 대한 설명은 괄호로 묶인 하위 패턴에 대한 설명에 따라 나중에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ce133ffa97494a3447425009d85e45fe4a4884e0" translate="yes" xml:space="preserve">
          <source>The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship is that both involve newlines. Dot has no special meaning in a character class.</source>
          <target state="translated">도트 처리는 곡절 및 달러 처리와 완전히 독립적이며, 유일한 관계는 둘 다 줄 바꿈과 관련이 있다는 것입니다. 도트는 문자 클래스에서 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="75675acc51f4abea249c539fbe54b590467b1b3e" translate="yes" xml:space="preserve">
          <source>The handshake will continue, but &lt;code&gt;A&lt;/code&gt; is informed that &lt;code&gt;B&lt;/code&gt; has another ongoing connection attempt that will be shut down (simultaneous connect where &lt;code&gt;A&lt;/code&gt;'s name is greater than &lt;code&gt;B&lt;/code&gt;'s name, compared literally).</source>
          <target state="translated">핸드 셰이크는 계속되지만 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 에 또 다른 연결 시도가 종료된다는 알림을받습니다 ( &lt;code&gt;A&lt;/code&gt; 의 이름이 &lt;code&gt;B&lt;/code&gt; 의 이름 보다 큰 동시 연결 은 문자 그대로 비교).</target>
        </trans-unit>
        <trans-unit id="aff3a3821cc248a671eac45e5517c958f3438bd4" translate="yes" xml:space="preserve">
          <source>The handshake will continue.</source>
          <target state="translated">핸드 셰이크가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c48205cabd15c9a3f6c801a9934891e2a4ee54fe" translate="yes" xml:space="preserve">
          <source>The handshake will not continue, as &lt;code&gt;B&lt;/code&gt; already has an ongoing handshake, which it itself has initiated (simultaneous connect where &lt;code&gt;B&lt;/code&gt;'s name is greater than &lt;code&gt;A&lt;/code&gt;'s).</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 에는 이미 핸드 셰이크가 진행 중이므로 핸드 셰이크가 계속되지 않습니다 ( &lt;code&gt;B&lt;/code&gt; 의 이름이 &lt;code&gt;A&lt;/code&gt; 보다 큰 동시 연결 ).</target>
        </trans-unit>
        <trans-unit id="4a492d4993cb9390498042b969391a3f2772dbec" translate="yes" xml:space="preserve">
          <source>The hardware watchdog timer, which is controlled by the &lt;code&gt;heart&lt;/code&gt; port program, requires package &lt;code&gt;FORCEvme&lt;/code&gt;, which contains the VME bus driver, to be installed. However, this driver can clash with the Sun &lt;code&gt;mcp&lt;/code&gt; driver and cause the system to refuse to boot. To cure this problem, the following lines are to be added to &lt;code&gt;/etc/system&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;heart&lt;/code&gt; 포트 프로그램으로 제어되는 하드웨어 감시 타이머 에는 VME 버스 드라이버가 포함 된 &lt;code&gt;FORCEvme&lt;/code&gt; 패키지 가 설치되어 있어야합니다. 그러나이 드라이버는 Sun &lt;code&gt;mcp&lt;/code&gt; 드라이버와 충돌 하여 시스템 부팅을 거부 할 수 있습니다. 이 문제를 해결하려면 &lt;code&gt;/etc/system&lt;/code&gt; 에 다음 행을 추가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e6408f5b48151485bdfcfab3159c61f5c8fa341" translate="yes" xml:space="preserve">
          <source>The head element of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">리스트의 헤드 요소 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5798187c9bcc3504a1324e24484f637b68bd2984" translate="yes" xml:space="preserve">
          <source>The head of the &lt;code&gt;modify_algs_list()&lt;/code&gt; modifies &lt;code&gt;A&lt;/code&gt; giving the result &lt;code&gt;A'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modify_algs_list()&lt;/code&gt; 의 헤드 는 &lt;code&gt;A&lt;/code&gt; 에 결과 &lt;code&gt;A'&lt;/code&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4983c0390f19223c1a70e5dfad48870fe4110265" translate="yes" xml:space="preserve">
          <source>The head of the fun is a head matching (or mismatching) &lt;strong&gt;one&lt;/strong&gt; parameter, one object of the table we select from. The object is always a single variable (can be &lt;code&gt;_&lt;/code&gt;) or a tuple, as ETS, Dets, and Mnesia tables include that. The match specification returned by &lt;code&gt;ets:fun2ms/1&lt;/code&gt; can be used with &lt;code&gt;dets:select/2&lt;/code&gt; and &lt;code&gt;mnesia:select/2&lt;/code&gt;, and with &lt;code&gt;ets:select/2&lt;/code&gt;. The use of &lt;code&gt;=&lt;/code&gt; in the head is allowed (and encouraged) at the top-level.</source>
          <target state="translated">재미의 머리는 우리가 선택한 테이블의 한 개체 인 &lt;strong&gt;하나의&lt;/strong&gt; 매개 변수와 일치하는 (또는 일치하지 않는) &lt;strong&gt;것&lt;/strong&gt; 입니다. ETS, Dets 및 Mnesia 테이블에 포함되어 있으므로 오브젝트는 항상 단일 변수 ( &lt;code&gt;_&lt;/code&gt; 가능 ) 또는 튜플입니다. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 에서 리턴 한 일치 스펙 은 &lt;code&gt;dets:select/2&lt;/code&gt; 및 &lt;code&gt;mnesia:select/2&lt;/code&gt; 와 함께 사용할 수 있으며 &lt;code&gt;ets:select/2&lt;/code&gt; 와 함께 사용할 수 있습니다 . 헤드에서 &lt;code&gt;=&lt;/code&gt; 사용은 최상위 레벨에서 허용 (및 권장)됩니다.</target>
        </trans-unit>
        <trans-unit id="91864c391383ab349ccd4d45371e04aafcfcc9ac" translate="yes" xml:space="preserve">
          <source>The header and objects in the file are checksummed using the built-in MD5 functions. The MD5 sum of all objects is written in the file footer, so that verification while reading detects the slightest bitflip in the file data. Using this costs a fair amount of CPU time.</source>
          <target state="translated">파일의 헤더와 객체는 내장 MD5 기능을 사용하여 체크섬됩니다. 모든 개체의 MD5 합계가 파일 바닥 글에 기록되므로 읽는 동안 확인하면 파일 데이터에서 가장 작은 비트 플립이 감지됩니다. 이를 사용하면 상당한 양의 CPU 시간이 소요됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb240ffbba0a0a325acedfed500d5fbbd4064ac" translate="yes" xml:space="preserve">
          <source>The header includes some system information:</source>
          <target state="translated">헤더에는 몇 가지 시스템 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="68595adcb3ea51d515a7e1ae094708cbf3e1144b" translate="yes" xml:space="preserve">
          <source>The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">헤더가 제거 &lt;strong&gt;되지 않았습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="882ae0c9d1778c987cd41c3f90417de21ef032f7" translate="yes" xml:space="preserve">
          <source>The header name will be in lower case and should not be altered.</source>
          <target state="translated">헤더 이름은 소문자이므로 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="af3ed8fba11aa29a77ab51965b8edb72b975c8e9" translate="yes" xml:space="preserve">
          <source>The header of the Erlang script in the example differs from a normal Erlang module. The first line is intended to be the interpreter line, which invokes &lt;code&gt;escript&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 Erlang 스크립트의 헤더는 일반적인 Erlang 모듈과 다릅니다. 첫 번째 줄은 &lt;code&gt;escript&lt;/code&gt; 를 호출하는 인터프리터 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="aef96215b80c7223d8af26cee2243d32f40daa22" translate="yes" xml:space="preserve">
          <source>The heap size of a process is quite hard to predict, especially the amount of memory that is used during the garbage collection. When contemplating using this option, it is recommended to first run it in production with &lt;code&gt;kill&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and inspect the log events to see what the normal peak sizes of the processes in the system is and then tune the value accordingly.</source>
          <target state="translated">프로세스의 힙 크기, 특히 가비지 수집 중에 사용되는 메모리 양을 예측하기는 매우 어렵습니다. 이 옵션을 사용하여 고려할 때는 &lt;code&gt;kill&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 프로덕션 환경에서 먼저 실행 하고 로그 이벤트를 검사하여 시스템에서 프로세스의 최대 피크 크기가 무엇인지 확인한 다음 그에 따라 값을 조정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e2e37a09af7e8f1d009a1717a88fe618ed3d52c" translate="yes" xml:space="preserve">
          <source>The heavyweight commit protocol is also non-blocking, which allows the surviving participants and their coordinator to finish the transaction regardless (even if a node crashes in the middle of the commit protocol). When a node fails at startup, &lt;code&gt;Mnesia&lt;/code&gt; determines the outcome of the transaction and recovers it. Lightweight protocols, heavyweight protocols, and dirty updates, are dependent on other nodes to be operational to make the correct heavyweight transaction recovery decision.</source>
          <target state="translated">헤비급 커밋 프로토콜은 또한 비 블로킹으로, 남아있는 참가자와 코디네이터가 노드가 커밋 프로토콜의 중간에 충돌하더라도 관계없이 트랜잭션을 완료 할 수 있습니다. 시작시 노드가 실패하면 &lt;code&gt;Mnesia&lt;/code&gt; 는 트랜잭션 결과를 판별하고 복구합니다. 간단한 프로토콜, 무거운 프로토콜 및 더티 업데이트는 올바른 무거운 트랜잭션 복구 결정을 내릴 수 있도록 다른 노드에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="cafb3c516580a793b7de731b14722e5eebd23ea8" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;h...&lt;/code&gt;.</source>
          <target state="translated">16 진수 값의 &lt;code&gt;h...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11e5e2ec0fa10fbdd5f8dd78491bb19a12164f59" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;hh&lt;/code&gt;.</source>
          <target state="translated">16 진수 값 &lt;code&gt;hh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74f0a534d2309926a7d494022615e9a9b4923160" translate="yes" xml:space="preserve">
          <source>The highest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="translated">이 노드가 처리 할 수있는 가장 높은 배포 버전입니다. Erlang / OTP R6B 이상의 값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="0a981eec686f456d91d8a6bc03a6775c554a6fb0" translate="yes" xml:space="preserve">
          <source>The home directory:</source>
          <target state="translated">홈 디렉토리 :</target>
        </trans-unit>
        <trans-unit id="2e797c1729cd1e5a1ad1f79c83782a1c6c07da5c" translate="yes" xml:space="preserve">
          <source>The hook function should return either the data to be exported, or a tuple &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt;, or a tuple &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt;, where &lt;code&gt;Content&lt;/code&gt; is a content list (which can be on simple-form; see &lt;code&gt;export_simple/2&lt;/code&gt; for details).</source>
          <target state="translated">후크 함수는 내보낼 데이터 또는 튜플 &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt; 또는 튜플 &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt; 를 반환해야합니다 . 여기서 &lt;code&gt;Content&lt;/code&gt; 는 컨텐츠 목록 (간단한 형식 일 수 있음, 자세한 내용은 &lt;code&gt;export_simple/2&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="4a1cb12a27b6d6707a5d80ba125a5cfb6386b02f" translate="yes" xml:space="preserve">
          <source>The hook options can also be specified in a configuration file with configuration variable &lt;code&gt;ct_conn_log&lt;/code&gt;:</source>
          <target state="translated">구성 변수 &lt;code&gt;ct_conn_log&lt;/code&gt; 를 사용하여 구성 파일에 후크 옵션을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44ea7e5b4f10ff2cea08d024c8bb140192260555" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are allowed access.</source>
          <target state="translated">호스트 &lt;code&gt;123.34.56.11&lt;/code&gt; 및 &lt;code&gt;150.100.23&lt;/code&gt; 서브넷의 모든 시스템에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e966a241193fc6bb63b6fabbd2c9e1a2a953a3a8" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are not allowed access.</source>
          <target state="translated">호스트 &lt;code&gt;123.34.56.11&lt;/code&gt; 및 &lt;code&gt;150.100.23&lt;/code&gt; 서브넷의 모든 시스템에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b0786bc370f61e14470bf6a8ad6a449f7a915d2" translate="yes" xml:space="preserve">
          <source>The host keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호스트 키 디렉토리는 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d878e97eeb73ea425731416807f352daf86ada0a" translate="yes" xml:space="preserve">
          <source>The hrl generated from a dictionary specification defines records for the messages and grouped AVPs defined in &lt;code&gt;@messages&lt;/code&gt; and &lt;code&gt;@grouped&lt;/code&gt; sections. For each message or grouped AVP definition, a record is defined whose name is the message or AVP name, prefixed with any dictionary prefix defined with &lt;code&gt;@prefix&lt;/code&gt;, and whose fields are the names of the AVPs contained in the message or grouped AVP in the order specified in the definition in question. For example, the grouped AVP</source>
          <target state="translated">사전 스펙에서 생성 된 hrl은 &lt;code&gt;@messages&lt;/code&gt; 및 &lt;code&gt;@grouped&lt;/code&gt; 섹션에 정의 된 메시지 및 그룹화 된 AVP에 대한 레코드를 정의 합니다. 각 메시지 또는 그룹화 된 AVP 정의에 대해 이름이 메시지 또는 AVP 이름이고 &lt;code&gt;@prefix&lt;/code&gt; 로 정의 된 사전 접두어가 앞에 붙고 필드가 메시지에 포함 된 AVP 이름 또는 순서대로 그룹화 된 AVP 인 레코드가 정의 됩니다. 해당 정의에 지정되어 있습니다. 예를 들어 그룹화 된 AVP</target>
        </trans-unit>
        <trans-unit id="962862212161f4c21176923512e551b47c09f8ac" translate="yes" xml:space="preserve">
          <source>The id of the child specification cannot be changed.</source>
          <target state="translated">하위 스펙의 ID는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f091d047abb87ec231553541a5fdb6a8b0e0548d" translate="yes" xml:space="preserve">
          <source>The idea is that it either matches a single character, or two identical characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it does not work if the pattern is longer than three characters. Consider the subject string &quot;abcba&quot;.</source>
          <target state="translated">아이디어는 단일 문자 또는 하위 회문을 둘러싼 두 개의 동일한 문자와 일치한다는 것입니다. Perl에서는이 패턴이 작동합니다. PCRE에서는 패턴이 3자를 초과하면 작동하지 않습니다. 제목 문자열 &quot;abcba&quot;를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b5bed6fe9a9f3870ec94f665573cd5c7dd092c" translate="yes" xml:space="preserve">
          <source>The idea is to have a &lt;code&gt;Common Test&lt;/code&gt; test suite calling a property testing tool with special property test suites as defined by that tool. The usual Erlang application directory structure is assumed. The tests are collected in the &lt;code&gt;test&lt;/code&gt; directory of the application. The &lt;code&gt;test&lt;/code&gt; directory has a subdirectory &lt;code&gt;property_test&lt;/code&gt;, where everything needed for the property tests is collected.</source>
          <target state="translated">아이디어는 해당 도구에서 정의한 특수 특성 테스트 스위트를 사용하여 특성 테스트 도구를 호출 하는 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트 를 갖도록하는 것입니다 . 일반적인 Erlang 애플리케이션 디렉토리 구조가 가정됩니다. 테스트는 응용 프로그램 의 &lt;code&gt;test&lt;/code&gt; 디렉토리에 수집됩니다 . &lt;code&gt;test&lt;/code&gt; 디렉토리 하위 디렉토리가 &lt;code&gt;property_test&lt;/code&gt; 속성 테스트에 필요한 모든 것을 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="874f09de1158faee11366ea5b25b0d18155a826f" translate="yes" xml:space="preserve">
          <source>The idea is to write something like:</source>
          <target state="translated">아이디어는 다음과 같이 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35794ac2165e7b77623ae5db4356014c0f1e5071" translate="yes" xml:space="preserve">
          <source>The identifier for the table. If the table is a &lt;code&gt;named_table&lt;/code&gt;, this is the name.</source>
          <target state="translated">테이블의 식별자입니다. 테이블이 &lt;code&gt;named_table&lt;/code&gt; 인 경우 이름입니다.</target>
        </trans-unit>
        <trans-unit id="948f1754e2dc2f5e9da0d93fd230e4e30fc1f680" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller identifier created by the acceptor process. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">억 셉터 프로세스에 의해 작성된 분배 제어기 식별자의 식별자. &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcd66a26de4ddbf0baac1e4c1845007eafbabac4" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller.</source>
          <target state="translated">배포 컨트롤러의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="727ced51237452469691fc0707b1de9d7db70736" translate="yes" xml:space="preserve">
          <source>The identifier, an arbitrary string, should be reused whenever the same application (or node) wants to start the process. &lt;code&gt;nteventlog&lt;/code&gt; is informed about all events that have arrived to the eventlog since the last accepted message for the current identifier. As long as the same identifier is used, the same eventlog record will not be sent to &lt;code&gt;nteventlog&lt;/code&gt; more than once (with the exception of when graved system failures arise, in which case the last records written before the failure may be sent to Erlang again after reboot).</source>
          <target state="translated">동일한 애플리케이션 (또는 노드)이 프로세스를 시작하려고 할 때마다 임의의 문자열 인 식별자를 재사용해야합니다. &lt;code&gt;nteventlog&lt;/code&gt; 는 현재 식별자에 대해 마지막으로 승인 된 메시지 이후에 이벤트 로그에 도착한 모든 이벤트에 대해 알려줍니다. 동일한 식별자가 사용되는 한 동일한 이벤트 로그 레코드는 &lt;code&gt;nteventlog&lt;/code&gt; 에 두 번 이상 전송되지 않습니다 (중대한 시스템 오류가 발생한 경우를 제외하고는 실패 전에 작성된 마지막 레코드가 Erlang에 다시 전송 될 수 있음) 재부팅).</target>
        </trans-unit>
        <trans-unit id="cf2c592a7835be79474c810d342bb74da9b68ee0" translate="yes" xml:space="preserve">
          <source>The identity (handle) of a connection.</source>
          <target state="translated">연결의 ID (핸들)</target>
        </trans-unit>
        <trans-unit id="8db0de3330260ae6e24af59a9d387dbcefe2afa7" translate="yes" xml:space="preserve">
          <source>The identity of a server, specified in a configuration file.</source>
          <target state="translated">구성 파일에 지정된 서버의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="be2c0371fbc7fc4fed32a1fa7d6f534addbd004b" translate="yes" xml:space="preserve">
          <source>The implemenation of the distribution driver is not completely covered here, details about buffering and other things unrelated to driver writing are not explained. Likewise are some peculiarities of the UDS protocol not explained in detail. The chosen protocol is not important.</source>
          <target state="translated">배포 드라이버의 구현은 여기에서 완전히 다루지 않으며, 버퍼링 및 드라이버 작성과 관련이없는 기타 사항에 대해서는 자세히 설명하지 않습니다. 마찬가지로 UDS 프로토콜의 특징은 자세히 설명하지 않습니다. 선택한 프로토콜은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8024f6f807f5eee458a55b3f38fa11d2c9f7c8b5" translate="yes" xml:space="preserve">
          <source>The implementation based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__atomic_*&lt;/code&gt; builtins.</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__atomic_*&lt;/code&gt; 내장을 기반으로 한 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d22b507e359bf39c3398b52ef33d5269e6b83f2b" translate="yes" xml:space="preserve">
          <source>The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks applications that expect a specific output for a specified seed. The output is still deterministic number series, but different compared to releases older than R15. Seed &lt;code&gt;{0,0,0}&lt;/code&gt; does, for example, no longer produce a flawed series of only zeros.</source>
          <target state="translated">Erlang / OTP R15에서 구현이 변경되었습니다. R15로 업그레이드하면 지정된 시드에 대한 특정 출력이 필요한 응용 프로그램이 중단됩니다. 출력은 여전히 ​​결정적인 숫자 시리즈이지만 R15 이전 릴리스와는 다릅니다. 예를 들어, 종자 &lt;code&gt;{0,0,0}&lt;/code&gt; 은 더 이상 결함이있는 일련의 0만을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17794ee5af2140bd9337aefc9afc392b9c6a3f30" translate="yes" xml:space="preserve">
          <source>The implementation of a system tracer process that produces this printout can look like this:</source>
          <target state="translated">이 출력을 생성하는 시스템 추적 프로그램 프로세스의 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b110452523f370779c51e763c1f9fff3540f763c" translate="yes" xml:space="preserve">
          <source>The implementation of a test case. Call the functions to test and check the result. If something fails, ensure the function causes a runtime error or call &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; (which also causes the test case process to terminate).</source>
          <target state="translated">테스트 케이스의 구현 함수를 호출하여 결과를 테스트하고 확인하십시오. 문제가 발생하면 함수가 런타임 오류를 유발하는지 확인하거나 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하십시오 (이 경우 테스트 케이스 프로세스가 종료 됨).</target>
        </trans-unit>
        <trans-unit id="7fde479db40a86f01a45d84f1970e3229f422aaa" translate="yes" xml:space="preserve">
          <source>The implementation of different asynchronous signals in the virtual machine can vary over time, but the behavior always respects this concept of asynchronous signals being passed between entities as described above.</source>
          <target state="translated">가상 머신에서 서로 다른 비동기 신호의 구현은 시간이 지남에 따라 달라질 수 있지만 동작은 위에서 설명한대로 엔티티간에 전달되는 비동기 신호의이 개념을 항상 존중합니다.</target>
        </trans-unit>
        <trans-unit id="78fb563a772c1aec013eb172f1594ea4c2023024" translate="yes" xml:space="preserve">
          <source>The implementation of lookbehind assertions is, for each alternative, to move the current position back temporarily by the fixed length and then try to match. If there are insufficient characters before the current position, the assertion fails.</source>
          <target state="translated">lookbehind 어설 션의 구현은 각 대안에서 현재 위치를 고정 된 길이만큼 일시적으로 뒤로 이동 한 다음 일치 시키려고합니다. 현재 위치 앞에 문자가 충분하지 않으면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="47c1e5901ab1f453c1b563ce5cd6710f3f98aaf0" translate="yes" xml:space="preserve">
          <source>The implementation of the port mechanism depends on the platform. For UNIX, pipes are used and the external program is assumed to read from standard input and write to standard output. The external program can be written in any programming language as long as it can handle the interprocess communication mechanism with which the port is implemented.</source>
          <target state="translated">포트 메커니즘의 구현은 플랫폼에 따라 다릅니다. UNIX의 경우 파이프가 사용되고 외부 프로그램은 표준 입력에서 읽고 표준 출력에 쓰는 것으로 가정합니다. 외부 프로그램은 포트가 구현되는 프로세스 간 통신 메커니즘을 처리 할 수있는 한 모든 프로그래밍 언어로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478af3e7f92746327d6e9ba13837a8097b170322" translate="yes" xml:space="preserve">
          <source>The implementation of the statistic counters is lightweight. I.e. the statistic counters are handled separately by different entities of the application. For instance our two transport module(s) (see &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;) maintain their own counters and the application engine (see &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt;) maintain its own counters.</source>
          <target state="translated">통계 카운터의 구현은 가볍습니다. 즉, 통계 카운터는 애플리케이션의 다른 엔티티에 의해 개별적으로 처리됩니다. 예를 들어, 두 개의 전송 모듈 ( &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; 참조 )은 자체 카운터를 유지하고 애플리케이션 엔진 ( &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt; 참조 )은 자체 카운터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="298d2d2a07f7dd0f09f6657d3ded4573b0d17570" translate="yes" xml:space="preserve">
          <source>The implementation of this function is based on the &lt;code&gt;terminate&lt;/code&gt; system message, and requires that the process handles system messages correctly. For information about system messages, see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; and section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능의 구현은 시스템 &lt;code&gt;terminate&lt;/code&gt; 메시지를 기반으로 하며 프로세스가 시스템 메시지를 올바르게 처리해야합니다. 시스템 메시지에 대한 자세한 내용은 OTP 디자인 원칙의 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;sys and proc_lib&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8382bdd6585df4f1f98e136541a6143a6f059e2f" translate="yes" xml:space="preserve">
          <source>The implementation provided by Erlang/OTP.</source>
          <target state="translated">Erlang / OTP에서 제공하는 구현입니다.</target>
        </trans-unit>
        <trans-unit id="8260c038977748412f519079cece24fe64e2829f" translate="yes" xml:space="preserve">
          <source>The implementation using ets tables introduces a semantic incompatibility with older implementations. In those older implementations, using pure Erlang terms, the index was garbage collected like any other Erlang term and did not have to be deleted when discarded. An ets table is deleted only when the process creating it explicitly deletes it or when the creating process terminates.</source>
          <target state="translated">ets 테이블을 사용한 구현은 이전 구현과 의미 상 호환되지 않습니다. 순수한 Erlang 용어를 사용하는 이전 구현에서 인덱스는 다른 Erlang 용어와 같이 가비지 수집되었으며 삭제 될 때 삭제할 필요가 없었습니다. ets 테이블은 테이블을 작성하는 프로세스가 명시 적으로 삭제하거나 작성 프로세스가 종료 될 때만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d24ced9c8492598a6342e78545fd97461c5c3534" translate="yes" xml:space="preserve">
          <source>The important line is the last line in the function: the &lt;code&gt;do_read&lt;/code&gt; routine is called to handle new input. The remaining function handles input on a listen socket, which means that it is to be possible to do an accept on the socket, which is also recognized as a read event.</source>
          <target state="translated">중요한 행은 함수의 마지막 행입니다 . 새 입력을 처리하기 위해 &lt;code&gt;do_read&lt;/code&gt; 루틴이 호출됩니다. 나머지 함수는 청취 소켓의 입력을 처리하므로 소켓에서 승인을 수행 할 수 있으며 이는 읽기 이벤트로도 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e9c528ecacf2cef07eb906cdbaca615ae9bccf" translate="yes" xml:space="preserve">
          <source>The imported variables are replaced by match specification &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang funs. However, local or global function calls cannot be in the guard or body of the fun. Calls to built-in match specification functions is of course allowed:</source>
          <target state="translated">가져온 변수는 일치 스펙 &lt;code&gt;const&lt;/code&gt; 표현식 으로 대체되며 , 이는 Erlang 재미에 대한 정적 범위와 일치합니다. 그러나 로컬 또는 전역 함수 호출은 재미의 보호 또는 신체에있을 수 없습니다. 내장 된 일치 스펙 함수에 대한 호출은 물론 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="acfda62ec5b11dd2be3e7e609916ea872e30b97c" translate="yes" xml:space="preserve">
          <source>The imported variables will be replaced by match_spec &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang &lt;code&gt;fun()&lt;/code&gt;s. Local or global function calls can not be in the guard or body of the fun however. Calls to builtin match_spec functions of course is allowed:</source>
          <target state="translated">가져온 변수는 match_spec &lt;code&gt;const&lt;/code&gt; 표현식 으로 대체되어 Erlang &lt;code&gt;fun()&lt;/code&gt; 의 정적 범위와 일치합니다 . 그러나 로컬 또는 전역 함수 호출은 재미의 경비 또는 몸에있을 수 없습니다. 물론 내장 match_spec 함수에 대한 호출이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="19bfe86fb1471efac1e72c2d15460bf77e3a9408" translate="yes" xml:space="preserve">
          <source>The improved &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; module is to be used instead of this module.</source>
          <target state="translated">이 모듈 대신 개선 된 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15c1fb9f30dd76e79041f3806d5e4590f2c710b6" translate="yes" xml:space="preserve">
          <source>The included application can be started in two ways. This is described in the next two sections.</source>
          <target state="translated">포함 된 응용 프로그램은 두 가지 방법으로 시작할 수 있습니다. 이에 대해서는 다음 두 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="06e8644e190d6991435ff4de5c47198aaef4670f" translate="yes" xml:space="preserve">
          <source>The incoming message prior to encode or the outgoing message after encode.</source>
          <target state="translated">인코딩 전의 수신 메시지 또는 인코딩 후의 발신 메시지</target>
        </trans-unit>
        <trans-unit id="4f31b1830353b2c8d2b0ce96b3ddc62f7dea448b" translate="yes" xml:space="preserve">
          <source>The incoming/outgoing message. For an incoming message, a term corresponding to the configured &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; if the message can be decoded in a non-relay application, &lt;code&gt;undefined&lt;/code&gt; otherwise. For an outgoing message, setting a &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; list is equivalent to setting the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;avps&lt;/code&gt; fields to the corresponding values.</source>
          <target state="translated">수신 / 발신 메시지 들어오는 메시지의 경우, 메시지가 릴레이 &lt;code&gt;undefined&lt;/code&gt; 않은 응용 프로그램에서 디코딩 될 수있는 경우 구성된 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 해당하는 용어 는 달리 정의되지 않습니다. 발신 메시지의 경우 &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; 목록은 &lt;code&gt;header&lt;/code&gt; 및 &lt;code&gt;avps&lt;/code&gt; 필드를 해당 값 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed6f20fe9042257fdf8f4d534ef82f96072c8261" translate="yes" xml:space="preserve">
          <source>The increment value when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;). Note that this value &lt;strong&gt;can&lt;/strong&gt; be negative and that a timer restart can therefor lead to a &lt;code&gt;wait_for&lt;/code&gt; value of zero! It is up to the user to be aware of the consequences of a &lt;code&gt;wait_for&lt;/code&gt; value of zero.</source>
          <target state="translated">새 타이머 시간을 계산할 때의 증가 값 ( &lt;code&gt;wait_for&lt;/code&gt; ). 이 값 &lt;strong&gt;은&lt;/strong&gt; 음수 일 &lt;strong&gt;수&lt;/strong&gt; 있으며, 타이머 재시작으로 인해 &lt;code&gt;wait_for&lt;/code&gt; 값이 0이 될 수 있습니다! &lt;code&gt;wait_for&lt;/code&gt; 값 0 의 결과를 아는 것은 사용자의 몫 입니다.</target>
        </trans-unit>
        <trans-unit id="b2b8955465cefc3c169ad13d16bfd76b94516280" translate="yes" xml:space="preserve">
          <source>The indentation features can be used to reindent large sections of a file. If some lines use nonstandard indentation they will be reindented.</source>
          <target state="translated">들여 쓰기 기능을 사용하여 파일의 큰 섹션을 다시 들여 쓸 수 있습니다. 일부 라인이 비표준 들여 쓰기를 사용하는 경우 다시 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="3228c669ff974e48e8faf71906a7cfa3fca40c98" translate="yes" xml:space="preserve">
          <source>The indexing capabilities of &lt;code&gt;Mnesia&lt;/code&gt; are used with the following three functions, which retrieve and match records based on index entries in the database:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 색인 기능은 데이터베이스의 색인 항목을 기반으로 레코드를 검색하고 일치시키는 다음 세 가지 기능과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66a67c598f5e1e4fe6dac7c8d61746c5da5f3c1a" translate="yes" xml:space="preserve">
          <source>The indices must be given in descending order.</source>
          <target state="translated">인덱스는 내림차순으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9802ae4d36471d390cc5236f59166f9448cefa" translate="yes" xml:space="preserve">
          <source>The indices must be integer literals, not variables or expressions.</source>
          <target state="translated">인덱스는 변수 또는 표현식이 아닌 정수 리터럴이어야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
