<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f975f613537adf39477a68ad11e1dc4894dd6870" translate="yes" xml:space="preserve">
          <source>Action Mappings</source>
          <target state="translated">액션 매핑</target>
        </trans-unit>
        <trans-unit id="2440fec108b517d1d709ba90c75d4f7a63c7e81f" translate="yes" xml:space="preserve">
          <source>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...}</source>
          <target state="translated">ActionCall :: = {ActionFunction} | {ActionFunction, ActionTerm, ...}</target>
        </trans-unit>
        <trans-unit id="5590c86022b5bc14c1ea74cf910bca92aa274578" translate="yes" xml:space="preserve">
          <source>ActionFunction ::= &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</source>
          <target state="translated">ActionFunction :: = &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51c493fd8bfe5291ac344e060529e5b42558f385" translate="yes" xml:space="preserve">
          <source>ActionTerm ::= ConditionExpression | ActionCall</source>
          <target state="translated">ActionTerm :: = ConditionExpression | 액션 콜</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="89ff6dbfdb936ca69e6587ae4d22e9a120904bf2" translate="yes" xml:space="preserve">
          <source>Actions :: [&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">동작 :: [ &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="61334da16104ac9d91a8736e913a8cbee03e40e6" translate="yes" xml:space="preserve">
          <source>Actions are executed in the containing list order.</source>
          <target state="translated">작업은 포함 목록 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef0f3b4c93f31bddb43b327dd452b51df2f0936" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;event_timeout()&lt;/code&gt; in the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 을 설정하는 작업 은 동일한 유형의 이전 항목보다 우선하므로 포함 목록의 마지막 항목이 우선합니다. 예를 들어, 마지막 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; 은 목록의 이전 &lt;code&gt;event_timeout()&lt;/code&gt; 을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="b1964869d062538b54d1a15f6f4171d706fef3d8" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 을 설정하는 작업 은 동일한 유형의 이전 항목보다 우선하므로 포함 목록의 마지막 항목이 우선합니다. 예를 들어 마지막 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 은 목록의 이전 &lt;code&gt;postpone()&lt;/code&gt; 을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="13b1df2d40bde8a02c4921e1004b0065de68e10c" translate="yes" xml:space="preserve">
          <source>Activates a connection to a remote user. When this is done the connection can be used to send messages (with SendMod:send_message/2). The ControlPid is the identifier of a process that controls the connection. That process will be supervised and if it dies, this will be detected and the UserMod:handle_disconnect/2 callback function will be invoked. See the megaco_user module for more info about the callback arguments. The connection may also explicitly be deactivated by invoking megaco:disconnect/2.</source>
          <target state="translated">원격 사용자에 대한 연결을 활성화합니다. 이 작업이 끝나면 연결을 사용하여 메시지를 보낼 수 있습니다 (SendMod : send_message / 2 사용). ControlPid는 연결을 제어하는 ​​프로세스의 식별자입니다. 해당 프로세스가 감독되고 프로세스가 종료되면이를 감지하고 UserMod : handle_disconnect / 2 콜백 함수가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오. megaco : disconnect / 2를 호출하여 연결을 명시 적으로 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f69ba29b1f84217c9d2ca2dc152317da71e06308" translate="yes" xml:space="preserve">
          <source>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt;. The default value of the backup callback module &lt;code&gt;BackupMod&lt;/code&gt; is obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;.</source>
          <target state="translated">최대 중복 정도로 스키마를 포함한 모든 Mnesia 테이블을 포괄하는 새로운 검사 점을 활성화하고 &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt; 를 사용하여 백업을 수행합니다 . 백업 콜백 모듈 &lt;code&gt;BackupMod&lt;/code&gt; 의 기본값 은 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 의해 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="0574212bd6baf73e32ac9c415b72677146bade9b" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates on all &lt;code&gt;Mnesia&lt;/code&gt; tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">디버그 수준에서 모든 이벤트를 활성화합니다. 이 레벨에서 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러는 모든 &lt;code&gt;Mnesia&lt;/code&gt; 테이블의 업데이트 구독을 시작합니다 . 이 레벨은 많은 큰 이벤트가 생성 될 수 있으므로 작은 장난감 시스템을 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1473502b15ef43d2fc312f7968ec2627f8afe701" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">디버그 수준에서 모든 이벤트를 활성화합니다. 이 레벨에서 Mnesia 이벤트 핸들러는 모든 Mnesia 테이블의 업데이트 구독을 시작합니다. 이 레벨은 많은 큰 이벤트가 생성 될 수 있으므로 작은 장난감 시스템을 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a11fef95fdd152ac782e603cddf000bf9537358d" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus full trace of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">자세한 수준의 모든 이벤트와 모든 디버그 이벤트의 전체 추적을 활성화합니다. 이러한 디버그 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 Mnesia 이벤트 핸들러로 전송됩니다. 이 디버그 레벨에서 Mnesia 이벤트 핸들러는 스키마 테이블의 업데이트 구독을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d10f11346b4f9c94838ab97da164ecb5b326c009" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus traces of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler. On this debug level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">상세 레벨의 모든 이벤트와 모든 디버그 이벤트의 추적을 활성화합니다. 이러한 디버그 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러로 전송됩니다 . 이 디버그 레벨에서 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러는 스키마 테이블의 업데이트 구독을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6ded0de3f180c32378392899db72b086ca5f1741" translate="yes" xml:space="preserve">
          <source>Activates read data buffering. If &lt;code&gt;read/2&lt;/code&gt; calls are for significantly less than &lt;code&gt;Size&lt;/code&gt; bytes, read operations to the operating system are still performed for blocks of &lt;code&gt;Size&lt;/code&gt; bytes. The extra data is buffered and returned in subsequent &lt;code&gt;read/2&lt;/code&gt; calls, giving a performance gain as the number of operating system calls is reduced.</source>
          <target state="translated">읽기 데이터 버퍼링을 활성화합니다. 경우 &lt;code&gt;read/2&lt;/code&gt; 호출이 크게 미만위한 &lt;code&gt;Size&lt;/code&gt; 바이트, 여전히 블록에 대해 수행중인 운영 체제에 읽기 작업 &lt;code&gt;Size&lt;/code&gt; 바이트. 추가 데이터는 버퍼링되어 후속 &lt;code&gt;read/2&lt;/code&gt; 호출 에서 반환 되므로 운영 체제 호출 수가 줄어들면 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="eb6a9b28d658257a2883ec371985ebb9360570ed" translate="yes" xml:space="preserve">
          <source>Activates the fragmentation properties of an existing table. &lt;code&gt;FragProps&lt;/code&gt; is either to contain &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; or be empty.</source>
          <target state="translated">기존 테이블의 조각화 속성을 활성화합니다. &lt;code&gt;FragProps&lt;/code&gt; 는 &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; 를 포함 하거나 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="532f0aa046ec26e3e6682e682916731e989482e8" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler.</source>
          <target state="translated">중요한 디버그 이벤트 추적을 활성화합니다. 이 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 로 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 Mnesia 이벤트 핸들러로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f95d91404d34111854383ce61fa17d9871d976" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler.</source>
          <target state="translated">중요한 디버그 이벤트 추적을 활성화합니다. 이 이벤트는 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 시스템 이벤트를 생성 합니다. 프로세스는 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 이러한 이벤트를 구독 할 수 있습니다 . 이벤트는 항상 &lt;code&gt;Mnesia&lt;/code&gt; 이벤트 핸들러로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f2c331b898e66e4e4d774932df99c6432852c98" translate="yes" xml:space="preserve">
          <source>Activates/deactivates tracing by changing the current trace pattern.</source>
          <target state="translated">현재 추적 패턴을 변경하여 추적을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="29f45195e4be19fb8b96702dcdd15944ea37fdad" translate="yes" xml:space="preserve">
          <source>Active breakpoints are displayed in red and inactive breakpoints in blue.</source>
          <target state="translated">활성 중단 점은 빨간색으로 표시되고 비활성 중단 점은 파란색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a903c4b66a2fb224f4d96a51df759ac9a67bfc6d" translate="yes" xml:space="preserve">
          <source>Activity concept and various access contexts</source>
          <target state="translated">활동 개념 및 다양한 액세스 컨텍스트</target>
        </trans-unit>
        <trans-unit id="713a8072ef62aa0b1fde6095af47e4a910316756" translate="yes" xml:space="preserve">
          <source>Actual protocol version.</source>
          <target state="translated">실제 프로토콜 버전.</target>
        </trans-unit>
        <trans-unit id="134344cda8fb9734c656b66e40554d208ac6e58b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;-ct_hooks&lt;/code&gt; as an argument to &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;. To add multiple CTHs using this method, append them to each other using the keyword &lt;code&gt;and&lt;/code&gt;, that is, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-ct_hooks&lt;/code&gt; 에 인수로 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 추가하십시오 . 이 방법을 사용하여 여러 CTHs를 추가하려면, 키워드를 사용하여 서로를 추가 &lt;code&gt;and&lt;/code&gt; 있다, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8718d4f36d948a3675c6bdc12db7b8c27966873" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;return_trace&lt;/code&gt; message if the function is of arity 3:</source>
          <target state="translated">함수가 arity 3 인 경우 &lt;code&gt;return_trace&lt;/code&gt; 메시지를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcfe51c34611d10c0d112932679c857d2a6476fa" translate="yes" xml:space="preserve">
          <source>Add a filter to the specified handler.</source>
          <target state="translated">지정된 핸들러에 필터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="988a7e297bf981c7e71c06b09b7717bd00d611be" translate="yes" xml:space="preserve">
          <source>Add a handler with the given configuration.</source>
          <target state="translated">주어진 구성으로 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="07e4c199b9f19567f7bbd64299d17b2cc8c094ac" translate="yes" xml:space="preserve">
          <source>Add a primary filter to Logger.</source>
          <target state="translated">로거에 기본 필터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1970f7a8e650aa5473c699a8c07cc9a162ef1004" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the primary nameserver to use for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 에 사용할 기본 네임 서버의 주소 (및 기본 포트가 아닌 경우 포트)를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cfc1bd9fd579f7622617b9af78a944445ba8847" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the secondary nameserver for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 대한 보조 네임 서버의 주소 (및 기본값이 아닌 경우 포트)를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a12963c05fa3aec6cf7012ff1f7fc0a2d99e08" translate="yes" xml:space="preserve">
          <source>Add an entry. The entry must not exist.</source>
          <target state="translated">항목을 추가하십시오. 항목이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1e310729251dbd2e2aab36a457e446b150b20e5e" translate="yes" xml:space="preserve">
          <source>Add host entry to the hosts table.</source>
          <target state="translated">호스트 테이블에 호스트 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="064eb4472489455e1a24510aa444bd6d5e585d65" translate="yes" xml:space="preserve">
          <source>Add javac &lt;strong&gt;LAST&lt;/strong&gt; to your path environment in bash, in my case this means:</source>
          <target state="translated">bash의 경로 환경에 javac &lt;strong&gt;LAST&lt;/strong&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0bb0d661a36f1c95bc663da03400bb07c43351" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">지정된 핸들러에 대한 구성 데이터를 추가하거나 업데이트하십시오. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하면 연관된 값이 &lt;code&gt;Value&lt;/code&gt; 로 변경됩니다 . 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2e23ac8cf9bd396ad94605da91fe04cfdf9b6acd" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">로거의 기본 구성 데이터를 추가하거나 업데이트하십시오. 주어진 &lt;code&gt;Key&lt;/code&gt; 이미 존재하면 연관된 값이 &lt;code&gt;Value&lt;/code&gt; 로 변경됩니다 . 존재하지 않는 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1f218791abec296d536eef9aee8fee9c4907e8" translate="yes" xml:space="preserve">
          <source>Add search domains for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet_res(3)&lt;/code&gt; 대한 검색 도메인을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd1016b584a0c08284e356371e0b67d2c6544a4a" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ct_hooks&lt;/code&gt; 태그 를 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="62bfcf8bed94dcc27f1ebd702bd7df63f5908679" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 호출에 &lt;code&gt;ct_hooks&lt;/code&gt; 태그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb8bd196c7c5b5791600663f12d69529068e2cf5" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;{scanner, flex}&lt;/code&gt; (or similar) directive to an Erlang system config file for the megaco app (see &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; chapter for details).</source>
          <target state="translated">추가 &lt;code&gt;{scanner, flex}&lt;/code&gt; (참조 MEGACO 응용 프로그램에 대한 얼랑 시스템 설정 파일 (또는 유사) 지침을 &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; 자세한 내용은 장).</target>
        </trans-unit>
        <trans-unit id="a2012ba10173073b8d6e03fc90ee362531d7db30" translate="yes" xml:space="preserve">
          <source>Add the applications Crypto, Public Key, and SSL with their current version numbers after the STDLIB application.</source>
          <target state="translated">STDLIB 애플리케이션 다음에 현재 버전 번호와 함께 애플리케이션 Crypto, 공개 키 및 SSL을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cf34fb9a5fda73afda9f1d571b702839ff2f58b3" translate="yes" xml:space="preserve">
          <source>Add the following directive to the module:</source>
          <target state="translated">다음 지시문을 모듈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="497564ebabd956c895ba8a4ea1a4bb25e8ed7093" translate="yes" xml:space="preserve">
          <source>Add transport capability to a service.</source>
          <target state="translated">서비스에 전송 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="22ba7777616ece673914dfbc3af9096a68b87e29" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using &lt;code&gt;add_module&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램을 추가한다는 것은 &lt;code&gt;.app&lt;/code&gt; 파일 에서 &lt;code&gt;modules&lt;/code&gt; 키로 정의 된 모듈 이 &lt;code&gt;add_module&lt;/code&gt; 을 사용하여로드 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="19baa62e86ec3c161512eb728cf268b6e381fb8a" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using a number of &lt;code&gt;add_module&lt;/code&gt; instructions, and then the application is started.</source>
          <target state="translated">응용 프로그램을 추가한다는 것은 &lt;code&gt;.app&lt;/code&gt; 파일 에서 &lt;code&gt;modules&lt;/code&gt; 키로 정의 된 모듈 이 여러 &lt;code&gt;add_module&lt;/code&gt; 명령어를 사용하여로드 된 다음 응용 프로그램이 시작됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4a2fed64edcf79517387cddb884610573fd90ba1" translate="yes" xml:space="preserve">
          <source>Adding patches</source>
          <target state="translated">패치 추가</target>
        </trans-unit>
        <trans-unit id="9aa3df6db85161c52e69b8f34d6e3268949dc0a1" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;fop&lt;/code&gt; script (in &lt;code&gt;$FOP_HOME&lt;/code&gt;) to your &lt;code&gt;$PATH&lt;/code&gt;, either by adding &lt;code&gt;$FOP_HOME&lt;/code&gt; to &lt;code&gt;$PATH&lt;/code&gt;, or by copying the &lt;code&gt;fop&lt;/code&gt; script to a directory already in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">추가 중 &lt;code&gt;fop&lt;/code&gt; 스크립트 (에서 &lt;code&gt;$FOP_HOME&lt;/code&gt; 당신에게) &lt;code&gt;$PATH&lt;/code&gt; , 하나 추가하여 &lt;code&gt;$FOP_HOME&lt;/code&gt; 에 &lt;code&gt;$PATH&lt;/code&gt; 또는 복사하여 &lt;code&gt;fop&lt;/code&gt; 당신의 이미 디렉토리에 스크립트를 &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38751bf8e4b616e26910db8b22c357a8c20a53f2" translate="yes" xml:space="preserve">
          <source>Adding the location of your installation of &lt;code&gt;fop&lt;/code&gt; in &lt;code&gt;$FOP_HOME&lt;/code&gt;.</source>
          <target state="translated">의 설치 위치 추가 &lt;code&gt;fop&lt;/code&gt; 에 &lt;code&gt;$FOP_HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab0b27d891b1318285ee4899ad6b140de6e4ed3b" translate="yes" xml:space="preserve">
          <source>Additional information and links of interest for Erlang programmers can be found on the Erlang Open Source site &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt;.</source>
          <target state="translated">Erlang 프로그래머를위한 추가 정보 및 관심 링크는 Erlang Open Source 사이트 &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6afdeb8447e9059c599becedc9101b844f957850" translate="yes" xml:space="preserve">
          <source>Additionally, values that can be encoded are limited by way of their encoding as four octets as required by RFC 6733 with the required extension from RFC 2030. In particular, only values between &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; and &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (both inclusive) can be encoded.</source>
          <target state="translated">또한 인코딩 할 수있는 값은 RFC 2030의 필수 확장을 사용하여 RFC 6733에 필요한대로 4 옥텟으로 인코딩하여 제한됩니다. 특히 &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; 및 &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (모두 포함)을 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fda4b3ec4ffdc7738f6833bc3191a5b59bbcea" translate="yes" xml:space="preserve">
          <source>Addresses as inputs to functions can be either a string or a tuple. For example, the IP address 150.236.20.73 can be passed to &lt;code&gt;gethostbyaddr/1&lt;/code&gt;, either as string &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; or as tuple &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt;.</source>
          <target state="translated">함수에 대한 입력으로서의 주소는 문자열 또는 튜플 일 수 있습니다. 예를 들어, IP 주소 150.236.20.73은 문자열 &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; 또는 튜플 &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt; 으로 &lt;code&gt;gethostbyaddr/1&lt;/code&gt; 에 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="919ffc168cee16019d09aa5279148893d8d24a34" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">소켓 API 함수에서 반환되는 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 이외의 주소 특히 &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;unspec&lt;/code&gt; 가족은 AF_UNSPEC에 해당하고, 다른 쪽이 더 소켓 주소가없는 경우 발생할 수 있습니다. &lt;code&gt;undefined&lt;/code&gt; 가족은 VM이 인식하지 못하는 주소 가족의 드문 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d78a2b44c9f8c46bb6a05a403783dea60e8b77" translate="yes" xml:space="preserve">
          <source>Addresses to the test plant or other instruments</source>
          <target state="translated">테스트 플랜트 또는 기타 기기에 대한 주소</target>
        </trans-unit>
        <trans-unit id="e2dc16d39802f8e13757680f2285e270d512d4d0" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. If &lt;code&gt;Dir&lt;/code&gt; exists, it is removed from the old position in the code path.</source>
          <target state="translated">코드 경로의 시작 부분에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . &lt;code&gt;Dir&lt;/code&gt; 이 있으면 코드 경로의 이전 위치에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="926f262a813d5bf3968371cfef08e827663b2a16" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the code path. The directory is added as the last directory in the new path. If &lt;code&gt;Dir&lt;/code&gt; already exists in the path, it is not added.</source>
          <target state="translated">코드 경로에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . 디렉토리는 새 경로의 마지막 디렉토리로 추가됩니다. 경우 &lt;code&gt;Dir&lt;/code&gt; 이미 경로에 존재, 그것은 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca41b9b5a14be7cc19bac8bafe3b381efcc40caa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the list of directories to be searched when including a file. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">파일을 포함 할 때 검색 할 디렉토리 목록에 &lt;code&gt;Dir&lt;/code&gt; 을 추가합니다 . &lt;code&gt;-include&lt;/code&gt; 또는 &lt;code&gt;-include_lib&lt;/code&gt; 지시문 이 발생하면 컴파일러는 다음 디렉토리에서 헤더 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5307e57c8c5d61db386c45a450b3023f9b59e82e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;IncludeDir&lt;/code&gt; to the search-path for &lt;code&gt;.asn1db&lt;/code&gt; and &lt;code&gt;ASN.1&lt;/code&gt; source files. The compiler tries to open an &lt;code&gt;.asn1db&lt;/code&gt; file when a module imports definitions from another &lt;code&gt;ASN.1&lt;/code&gt; module. If no &lt;code&gt;.asn1db&lt;/code&gt; file is found, the &lt;code&gt;ASN.1&lt;/code&gt; source file is parsed. Several &lt;code&gt;{i, IncludeDir}&lt;/code&gt; can be given.</source>
          <target state="translated">&lt;code&gt;.asn1db&lt;/code&gt; 및 &lt;code&gt;ASN.1&lt;/code&gt; 소스 파일 의 검색 경로에 &lt;code&gt;IncludeDir&lt;/code&gt; 을 추가합니다 . 모듈이 다른 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 에서 정의를 &lt;code&gt;.asn1db&lt;/code&gt; 때 컴파일러는 .asn1db 파일 을 열려고합니다 . &lt;code&gt;.asn1db&lt;/code&gt; 파일이 없으면 &lt;code&gt;ASN.1&lt;/code&gt; 소스 파일이 구문 분석됩니다. 여러 개의 &lt;code&gt;{i, IncludeDir}&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595c4b05c70f5ee3afd4c0ee71bd2a9507a8d8e9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and store this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 값에 &lt;code&gt;Increment&lt;/code&gt; 을 추가 하고이 값을 저장하십시오. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Increment&lt;/code&gt; 최초 값으로 저장된다.</target>
        </trans-unit>
        <trans-unit id="9cf5a5933a7780d09616786318d8b162063b8502" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and stores this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 값에 &lt;code&gt;Increment&lt;/code&gt; 을 추가 하고이 값을 저장합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Increment&lt;/code&gt; 최초 값으로 저장된다.</target>
        </trans-unit>
        <trans-unit id="608d4ac3b1f40dea43a70f3ee04cd69ef181057c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;Slave&lt;/code&gt; node to the list of allowed slave hosts.</source>
          <target state="translated">허용 된 슬레이브 호스트 목록에 &lt;code&gt;Slave&lt;/code&gt; 노드를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="c8419b1c93b9fd6c91cbede4425bbc8634cca3f1" translate="yes" xml:space="preserve">
          <source>Adds a USM security data (user) to the agent config. Equivalent to one line in the &lt;code&gt;usm.conf&lt;/code&gt; file.</source>
          <target state="translated">USM 보안 데이터 (사용자)를 에이전트 구성에 추가합니다. &lt;code&gt;usm.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="608718b6fe3ec7101404f6c3f283054c442dd2b4" translate="yes" xml:space="preserve">
          <source>Adds a access definition to the agent config. Equivalent to one vacmAccess-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 액세스 정의를 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에있는 하나의 vacmAccess-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="56be82c63eeffefdb9fecc96c8582dde485169c1" translate="yes" xml:space="preserve">
          <source>Adds a comment to the zip archive.</source>
          <target state="translated">Zip 아카이브에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="43e098c039b116cd95896a1756a343c44df7c071" translate="yes" xml:space="preserve">
          <source>Adds a community to the agent config. Equivalent to one line in the &lt;code&gt;community.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 커뮤니티를 추가합니다. &lt;code&gt;community.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="45955c71ab38b246ddf99aa7e08be1cf306c82b3" translate="yes" xml:space="preserve">
          <source>Adds a context to the agent config. Equivalent to one line in the &lt;code&gt;context.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 컨텍스트를 추가합니다. &lt;code&gt;context.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6c32cf7ccbd49be4e1811292b2c307f4eba42f61" translate="yes" xml:space="preserve">
          <source>Adds a driver entry to the list of drivers known by Erlang. The &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; function of parameter &lt;code&gt;de&lt;/code&gt; is called.</source>
          <target state="translated">Erlang에 알려진 드라이버 목록에 드라이버 항목을 추가합니다. 매개 변수 &lt;code&gt;de&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 기능 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d07970fe182b9d81897e40e78d3b14e7a4e7a0d7" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 로 쓰기 위해 열린 tar 파일에 파일을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b2fca474d01b00ce9ba861cfe769df64577ac35b" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;. This function accepts the same options as &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 로 쓰기 위해 열린 tar 파일에 파일을 추가합니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5eccbecba42ae4288806c579ad8b8fbf3b51a728" translate="yes" xml:space="preserve">
          <source>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</source>
          <target state="translated">조각난 테이블에 조각을 추가합니다. 오래된 조각 중 하나의 모든 레코드가 다시 해시되고 그 중 절반이 새로운 (마지막) 조각으로 이동됩니다. 외래 키에서이 테이블을 참조하는 다른 모든 조각화 된 테이블은 자동으로 새 조각을 가져옵니다. 또한 해당 레코드는 기본 테이블과 동일한 방식으로 동적으로 다시 해시됩니다.</target>
        </trans-unit>
        <trans-unit id="d84d2fb93ae834309e6167a0b3e43d9fab2545e1" translate="yes" xml:space="preserve">
          <source>Adds a host key to the set of trusted host keys.</source>
          <target state="translated">신뢰할 수있는 호스트 키 세트에 호스트 키를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2d77c18b4124fe87017036ce4362ca94cf644272" translate="yes" xml:space="preserve">
          <source>Adds a module and its &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The module will not be member of any application. Returns the name of the module.</source>
          <target state="translated">모듈 및 해당 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 모듈은 응용 프로그램의 구성원이 아닙니다. 모듈 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32c8a7869e19433d754f5fcd1913f72de6ee2803" translate="yes" xml:space="preserve">
          <source>Adds a new &lt;code&gt;Key&lt;/code&gt; to the process dictionary, associated with the value &lt;code&gt;Val&lt;/code&gt;, and returns &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;Key&lt;/code&gt; exists, the old value is deleted and replaced by &lt;code&gt;Val&lt;/code&gt;, and the function returns the old value. Example:</source>
          <target state="translated">값 &lt;code&gt;Val&lt;/code&gt; 과 연관된 프로세스 &lt;code&gt;Key&lt;/code&gt; 에 새 키 를 추가하고 &lt;code&gt;undefined&lt;/code&gt; 를 리턴합니다 . 경우 &lt;code&gt;Key&lt;/code&gt; 존재 이전 값은 삭제로 대체 &lt;code&gt;Val&lt;/code&gt; 하고,이 함수는, 이전의 값을 돌려줍니다. 예:</target>
        </trans-unit>
        <trans-unit id="72a77907fe15211efb4ac1705211f4a6082a3750" translate="yes" xml:space="preserve">
          <source>Adds a new event handler in the same way as &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;, but also supervises the connection between the event handler and the calling process.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 새 이벤트 핸들러를 추가 하고 이벤트 핸들러와 호출 프로세스 간의 연결을 감독합니다.</target>
        </trans-unit>
        <trans-unit id="e9446fd51850eeb6666eac3dc67fdb3d82b72082" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to event manager &lt;code&gt;EventMgrRef&lt;/code&gt;. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initiate the event handler and its internal state.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 에 새 이벤트 핸들러를 추가합니다 . 이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 이벤트 핸들러 및 내부 상태를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="be923232cecb872d45d1007a0378c8bbbe25c6cc" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to the error logger. The event handler must be implemented as a &lt;code&gt;gen_event&lt;/code&gt; callback module, see &lt;code&gt;gen_event(3)&lt;/code&gt;.</source>
          <target state="translated">오류 로거에 새 이벤트 핸들러를 추가합니다. 이벤트 핸들러는 &lt;code&gt;gen_event&lt;/code&gt; 콜백 모듈 로 구현되어야합니다 &lt;code&gt;gen_event(3)&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="346f98f933f954790f0ea34b8324039679ac74dd" translate="yes" xml:space="preserve">
          <source>Adds a node to &lt;code&gt;node_pool&lt;/code&gt;. The new node pool affects the list returned from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;node_pool&lt;/code&gt; 에 노드를 추가합니다 . 새 노드 풀은 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 함수에서 리턴 된 목록에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="35b3eb9263608d380a272fe1f7c6c1eafd65bf84" translate="yes" xml:space="preserve">
          <source>Adds a notify definition to the agent config. Equivalent to one line in the &lt;code&gt;notify.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 알림 정의를 추가합니다. &lt;code&gt;notify.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="13890bf5b34b3baf9845e8775db87c295022c6ec" translate="yes" xml:space="preserve">
          <source>Adds a phony target for each dependency.</source>
          <target state="translated">각 종속성에 대한 가짜 대상을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="29b1ac0ca171003684f30d397e314620318042ec" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 에서 확보 한 자원 오브젝트 &lt;code&gt;obj&lt;/code&gt; 에 대한 참조를 추가합니다 . 를 호출 할 때마다 &lt;code&gt;enif_keep_resource&lt;/code&gt; 객체에 대한이의 호출에 의해 균형을 이루어야한다 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 객체가 파괴되기 전에.</target>
        </trans-unit>
        <trans-unit id="ac2aa5a6a26bf2accad0209a44849095d34310fd" translate="yes" xml:space="preserve">
          <source>Adds a release, the applications of the release, the modules of the applications, and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The applications will be members of the release, and the modules will be members of the applications. The default is to use the base name of the directory as release name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the release.</source>
          <target state="translated">릴리스, 릴리스의 응용 프로그램, 응용 프로그램의 모듈 및 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 응용 프로그램은 릴리스의 구성원이되고 모듈은 응용 프로그램의 구성원이됩니다. 기본적으로 디렉토리의 기본 이름을 릴리스 이름으로 사용하지만 &lt;code&gt;name&lt;/code&gt; 옵션으로 이를 대체 할 수 있습니다 . 릴리스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5963e0eadddadc6570ac86b11276f6f4e83b3156" translate="yes" xml:space="preserve">
          <source>Adds a security to group definition to the agent config. Equivalent to one vacmSecurityToGroup-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 그룹 정의에 보안을 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에서 하나의 vacmSecurityToGroup-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f785833568b0e86ada1e532e1405f500e20a42" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; for a more complete description.</source>
          <target state="translated">정의 된 내용과 할당 된 사람에 대한 기본 정보가 포함 된 각 할당 된 블록에 작은 태그를 추가합니다. 더 자세한 설명 은 &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dfd9dbecdeed6491e670fb60727a24505e80431" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the &lt;code&gt;instrument&lt;/code&gt; module to inspect this information.</source>
          <target state="translated">정의 된 내용과 할당 된 사람에 대한 기본 정보가 포함 된 각 할당 된 블록에 작은 태그를 추가합니다. &lt;code&gt;instrument&lt;/code&gt; 모듈을 사용 하여이 정보를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="e4864b206394f8b2d7b76e4230a5c12a58cc9d0e" translate="yes" xml:space="preserve">
          <source>Adds a target address definition to the agent config. Equivalent to one line in the &lt;code&gt;target_addr.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 대상 주소 정의를 추가합니다. &lt;code&gt;target_addr.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="82b2d6b8384860d53fc589e045f4515d51086799" translate="yes" xml:space="preserve">
          <source>Adds a target parameter definition to the agent config. Equivalent to one line in the &lt;code&gt;target_params.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 구성에 대상 매개 변수 정의를 추가합니다. &lt;code&gt;target_params.conf&lt;/code&gt; 파일의 한 줄과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5794b16429f3c188c00edeb3043c4596518ea624" translate="yes" xml:space="preserve">
          <source>Adds a view tree family definition to the agent config. Equivalent to one vacmViewTreeFamily-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">에이전트 트리 구성에 뷰 트리 제품군 정의를 추가합니다. &lt;code&gt;vacm.conf&lt;/code&gt; 파일 에서 하나의 vacmViewTreeFamily-line과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="10d0b1e780ad0788836f31276e65ce6efb15e764" translate="yes" xml:space="preserve">
          <source>Adds an application, the modules of the application and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The modules will be members of the application. The default is to use the base name of the directory with the version removed as application name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the application.</source>
          <target state="translated">응용 프로그램, 응용 프로그램 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 및 모듈의 모듈 데이터 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 모듈은 응용 프로그램의 구성원이됩니다. 기본값은 버전이 응용 프로그램 이름으로 제거 된 디렉토리의 기본 이름을 사용하지만 &lt;code&gt;name&lt;/code&gt; 옵션 으로 대체 할 수 있습니다 . 응용 프로그램의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="110ffd01521ffa85d725f633c684562720f4ba39" translate="yes" xml:space="preserve">
          <source>Adds binding &lt;code&gt;Name=Value&lt;/code&gt; to &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">바인딩 &lt;code&gt;Name=Value&lt;/code&gt; 를 &lt;code&gt;BindingStruct&lt;/code&gt; 에 추가합니다 . 업데이트 된 바인딩 구조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="166b6b5a44b378b7ef528300e6dd1ab66edcbe83" translate="yes" xml:space="preserve">
          <source>Adds nodes to current cover test. Notice that this only works if cover support is active.</source>
          <target state="translated">현재 커버 테스트에 노드를 추가합니다. 이것은 표지 지원이 활성화 된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebbd57f6aab385f9f5cefe84013bbde0f94bd2a8" translate="yes" xml:space="preserve">
          <source>Adds optional capabilities and sends a &lt;code&gt;hello&lt;/code&gt; message to the server and waits for the return.</source>
          <target state="translated">선택적 기능을 추가 하고 서버에 &lt;code&gt;hello&lt;/code&gt; 메시지를 보내고 리턴을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f4e867c0e696fbab1087c9d79da2f2d90aa8bb6f" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. &lt;code&gt;Bindings&lt;/code&gt; specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</source>
          <target state="translated">구문 트리에서 노드의 주석을 추가하거나 업데이트합니다. &lt;code&gt;Bindings&lt;/code&gt; 은 최상위 노드 환경에서 바인딩 된 변수 세트를 지정합니다. 다음 주석이 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="b3ac712b8a650dd6e42451afed1ca538238431c7" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. Equivalent to &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; where the top-level environment &lt;code&gt;Bindings&lt;/code&gt; is taken from the annotation &lt;code&gt;{env, Bindings}&lt;/code&gt; on the root node of &lt;code&gt;Tree&lt;/code&gt;. An exception is thrown if no such annotation should exist.</source>
          <target state="translated">구문 트리에서 노드의 주석을 추가하거나 업데이트합니다. 최상위 환경 &lt;code&gt;Bindings&lt;/code&gt; 이 &lt;code&gt;Tree&lt;/code&gt; 의 루트 노드에있는 주석 &lt;code&gt;{env, Bindings}&lt;/code&gt; 에서 가져온 &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; 와 같습니다 . 그러한 주석이 존재하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bbf9ca1c736db15763a8239f95f4d5c1b66558d" translate="yes" xml:space="preserve">
          <source>Adds the directories in &lt;code&gt;Dirs&lt;/code&gt; to the end of the code path. If a &lt;code&gt;Dir&lt;/code&gt; exists, it is not added.</source>
          <target state="translated">&lt;code&gt;Dirs&lt;/code&gt; 의 디렉토리를 코드 경로의 끝에 추가합니다 . &lt;code&gt;Dir&lt;/code&gt; 이 있으면 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8d419cc2314f6341b04eb8bad24bf2f277d7f87" translate="yes" xml:space="preserve">
          <source>Adds the modules found in the given directory and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The default is not to examine subdirectories, but if the option &lt;code&gt;recurse&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, modules are searched for in subdirectories on all levels as well as in the given directory. Returns a sorted list of the names of the added modules.</source>
          <target state="translated">주어진 디렉토리에서 찾은 모듈과 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; . 기본값은 서브 디렉토리를 검사하는 것이 아니라 옵션 &lt;code&gt;recurse&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 , 주어진 디렉토리뿐만 아니라 모든 레벨의 서브 디렉토리에서 모듈을 검색합니다. 추가 된 모듈 이름의 정렬 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34d712dcc34471fdb6acaa22554dc0975d1f5dc6" translate="yes" xml:space="preserve">
          <source>Adds the registered name of the process. This can be useful when tracing on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">프로세스의 등록 된 이름을 추가합니다. 이 이름을 가진 프로세스가 모든 추적 노드에서 추적되므로 많은 노드에서 추적 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbf14dbe70908fe6ce0549e066a68aa359629b3" translate="yes" xml:space="preserve">
          <source>Adds the selected process and all processes below, right of it, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">선택된 프로세스 및 프로세스 아래의 모든 프로세스를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3fcbc67018c8db0d7d54f40db7c26439211fb94f" translate="yes" xml:space="preserve">
          <source>Adds the selected process identifier to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the process resides on.</source>
          <target state="translated">선택된 프로세스 식별자를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭 과 프로세스가 상주하는 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3aebb82fdca9aa95c0538fef0af13a3b616d5fe2" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt;code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">&lt;code&gt;code:add_pathsa/1&lt;/code&gt; 과 유사하게 지정된 경로를 코드 경로의 시작 부분에 추가합니다 . 주어진 디렉토리의 순서는 결과 경로에서 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1c883186e0d00a77adaf41f013ddc82c811398" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the end of the code path, similar to &lt;code&gt;code:add_pathsz/1&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">code와 유사하게 &lt;code&gt;code:add_pathsz/1&lt;/code&gt; 경로 끝에 지정된 디렉토리를 추가합니다 . add_pathsz / 1 ; &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d2e0e96fcba01247b2f834ed2a0365db181f6d4" translate="yes" xml:space="preserve">
          <source>Adds the specified primary filters.</source>
          <target state="translated">지정된 기본 필터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d613e82163d56d8326249e8169f52e84f75a04cb" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of compress extensions.</source>
          <target state="translated">이러한 확장을 압축 확장 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="25822e567273ecdc04d1dd713da5a9ee0671d675" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of uncompress extensions.</source>
          <target state="translated">이 확장을 압축 해제 확장 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2f502d97e1ab810c3754afd45a8594c92efa30f8" translate="yes" xml:space="preserve">
          <source>Adds to &lt;code&gt;Forms&lt;/code&gt; the code for the standard pre-defined functions (such as &lt;code&gt;module_info/0&lt;/code&gt;) that are to be included in every module.</source>
          <target state="translated">추가로 &lt;code&gt;Forms&lt;/code&gt; (예컨대 표준 사전 정의 된 함수 코드 &lt;code&gt;module_info/0&lt;/code&gt; 모든 모듈을 포함하여야한다).</target>
        </trans-unit>
        <trans-unit id="bb8f1512f2d702beeef48e8c7223a0b1dde1e4a0" translate="yes" xml:space="preserve">
          <source>Adjust the process(&quot;beam&quot;) reference to your beam version and attach the script to a running &quot;beam&quot; instance:</source>
          <target state="translated">빔 버전에 대한 프로세스 ( &quot;beam&quot;) 참조를 조정하고 실행중인 &quot;beam&quot;인스턴스에 스크립트를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="c57f256463601b2a2c62f254f5126bfecb16a4d2" translate="yes" xml:space="preserve">
          <source>Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes.</source>
          <target state="translated">SSH 흐름 제어 창을 조정합니다. 이는 클라이언트 및 서버 측 채널 프로세스 모두에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="980e8823b26ab3a416e4eec330a78a5f567d8a4d" translate="yes" xml:space="preserve">
          <source>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">SSL-3.0 및 TLS-1.0 연결에만 영향을줍니다. 기존 소프트웨어와 상호 운용되도록 BEAST 완화 전략을 변경하는 데 사용됩니다. 기본값은 &lt;code&gt;one_n_minus_one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6004ea02cc23d09682422b618c26d349782aa93" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. If set to &lt;code&gt;false&lt;/code&gt;, it disables the block cipher padding check to be able to interoperate with legacy software.</source>
          <target state="translated">TLS-1.0 연결에만 영향을줍니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 블록 암호 패딩 검사를 비활성화하여 레거시 소프트웨어와 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b6ffc59171bd18b8e61a3e781dab573deabf10a" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt;, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. &lt;strong&gt;On all other platforms, this option is silently discarded.&lt;/strong&gt;</source>
          <target state="translated">Windows의 외부 프로그램에 대한 포트에만 영향을줍니다. 포트 프로그램의 표준 입력 및 표준 출력 핸들은이 옵션이 제공되면 플래그 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 와 함께 열리 므로 포트 프로그램은 표준 핸들에서 겹친 I / O를 수행 할 수 있습니다. 이것은 일반적으로 간단한 포트 프로그램의 경우가 아니라 숙련 된 Windows 프로그래머에게 유용한 옵션입니다. &lt;strong&gt;다른 모든 플랫폼에서는이 옵션이 자동으로 삭제됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf4fb0d4263b60ac21dc80f51c2dec3dcfb5747e" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. &lt;code&gt;stderr_to_stdout&lt;/code&gt; and &lt;code&gt;nouse_stdio&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">외부 프로그램에 대한 포트에 영향을줍니다. 실행 된 프로그램은 표준 오류 파일을 표준 출력 파일로 리디렉션합니다. &lt;code&gt;stderr_to_stdout&lt;/code&gt; 과 &lt;code&gt;nouse_stdio&lt;/code&gt; 는 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="76c066b0f9a1e6496e99cead0881b8f872728f45" translate="yes" xml:space="preserve">
          <source>After LTTng is properly installed on the system Erlang/OTP can be built with LTTng support.</source>
          <target state="translated">시스템에 LTTng을 올바르게 설치 한 후 LTTng를 지원하여 Erlang / OTP를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1facbcf11ae5793aa1bc80ef16d286aebd0fc34d" translate="yes" xml:space="preserve">
          <source>After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">\ 0 이후에 최대 두 개의 8 진수를 더 읽습니다. 두 자리 미만의 숫자가 있으면 존재하는 숫자 만 사용됩니다. 따라서 \ 0 \ x \ 015 시퀀스는 2 개의 이진수 0과 CR 문자 (코드 값 13)를 차례로 지정합니다. 뒤 따르는 패턴 문자가 8 진수 인 경우 초기 0 다음에 2 자리를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d732389ea2448ab3a2fa3d0a36ca3e321f1eb8c8" translate="yes" xml:space="preserve">
          <source>After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:</source>
          <target state="translated">부분 일치 또는 실패한 일치 후 전체 일치 프로세스에서 마지막으로 발생한 이름이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18ee0e3703c2647b03b1406f234f9cc3d123429d" translate="yes" xml:space="preserve">
          <source>After adding more records to the &lt;code&gt;Company&lt;/code&gt; database, the result can be the following records:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스에 더 많은 레코드를 추가 한 후 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22669be288b8402f937e20a5b4c0d8be02ada8ae" translate="yes" xml:space="preserve">
          <source>After an analysis, you can inspect this information. In the &lt;strong&gt;PLT&lt;/strong&gt; menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in &lt;code&gt;EDoc&lt;/code&gt; format.</source>
          <target state="translated">분석 후이 정보를 검사 할 수 있습니다. &lt;strong&gt;PLT&lt;/strong&gt; 메뉴 에서 &lt;strong&gt;PLT&lt;/strong&gt; 를 검색하거나 전체 PLT의 내용을 검사하도록 선택할 수 있습니다. 정보는 &lt;code&gt;EDoc&lt;/code&gt; 형식으로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef9c0c6bbe4e27c696f859b427107c4e849d03c" translate="yes" xml:space="preserve">
          <source>After any post hook has been executed for all installed CTHs, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; is called if the testcase failed or was skipped, respectively. You cannot affect the outcome of the tests any further at this point.</source>
          <target state="translated">설치된 모든 CTH에 대해 포스트 후크가 실행 된 후 테스트 케이스가 실패하거나 건너 뛴 경우 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; 가 각각 호출됩니다. 이 시점에서 더 이상 테스트 결과에 영향을 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f056750b4e33f30fb9d5942f6265a2d4f346b9dc" translate="yes" xml:space="preserve">
          <source>After at least one tab-character, the line added is to contain the full name of the named pipe where &lt;code&gt;syslogd&lt;/code&gt; writes its information. The path must be the same as for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The filename must be &lt;code&gt;syslog.otp&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 탭 문자 다음에 추가되는 행에는 &lt;code&gt;syslogd&lt;/code&gt; 가 정보를 쓰는 이름 지정된 파이프의 전체 이름이 포함 됩니다. 경로는 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 및 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 파일의 경로와 같아야합니다 . 파일 이름은 &lt;code&gt;syslog.otp&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ce4ab81087082fd95156bdaf8c2e0786410e8e3" translate="yes" xml:space="preserve">
          <source>After completing all the normal building steps described above a debug enabled runtime system can be built. To do this you have to change directory to &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and execute:</source>
          <target state="translated">위에서 설명한 모든 일반적인 빌드 단계를 완료 한 후 디버그 가능 런타임 시스템을 빌드 할 수 있습니다. 이렇게하려면 디렉토리를 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 하고 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cd742cd300933dfb65e0a535f4d15de36d37f01" translate="yes" xml:space="preserve">
          <source>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">메시지를 디코딩 한 후, 사용자가 올바르게 행동 할 수 있도록 다양한 사용자 콜백 함수가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc240b1130d5df1612bf5772e5400cd74e1cad80" translate="yes" xml:space="preserve">
          <source>After flag fields for atom cache references, another half byte flag field is located with the following format:</source>
          <target state="translated">아톰 캐시 참조에 대한 플래그 필드 뒤에 다른 하프 바이트 플래그 필드는 다음 형식으로 위치합니다.</target>
        </trans-unit>
        <trans-unit id="8aca18c81b4ecc6e98bd69677c9d22a41d1f8407" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use &lt;code&gt;erl_connect()&lt;/code&gt;. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">초기화 후 Erlang 노드에 대한 연결을 설정합니다. 연결하려는 Erlang 노드를 지정하려면 &lt;code&gt;erl_connect()&lt;/code&gt; 사용 하십시오 . 다음 예제는 연결을 설정하고 유효한 소켓 파일 설명자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="71297d463c83eda2a6c9154b983ee09e837036ff" translate="yes" xml:space="preserve">
          <source>After installation you can access the documentation by</source>
          <target state="translated">설치 후 다음 방법으로 설명서에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6b0c5270a184c48e498da3c725b4712069c50f99" translate="yes" xml:space="preserve">
          <source>After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</source>
          <target state="translated">6 자리 숫자를 모두 일치시킨 다음 &quot;foo&quot;와 일치하지 않으면, 일치하는 사람의 정상적인 동작은 항목 \ d +와 일치하는 5 자리 숫자 만 사용한 다음 다시 4 자리 숫자 만 사용하여 다시 시도하는 것입니다. &quot;원자 그룹화&quot;(Jeffrey Friedl의 책에서 사용 된 용어)는 하위 패턴이 일치하면이를 다시 평가하지 않도록 지정하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ae043d6d909deeb13bd861dc2fdf16fc111c0f4f" translate="yes" xml:space="preserve">
          <source>After reading the &lt;code&gt;erts_alloc(3)&lt;/code&gt; documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. &lt;code&gt;mbcs&lt;/code&gt; and &lt;code&gt;sbcs&lt;/code&gt; denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</source>
          <target state="translated">&lt;code&gt;erts_alloc(3)&lt;/code&gt; 문서를 읽은 후 , 반환 된 정보는 그 자체로 말하지만, 몇 가지를 설명 할 가치가 있습니다. 통화 수는 두 가지 값으로 표시됩니다. 첫 번째 값은 기가 통화이고 두 번째 값은 통화입니다. &lt;code&gt;mbcs&lt;/code&gt; 및 &lt;code&gt;sbcs&lt;/code&gt; 는 각각 다중 블록 반송파 및 단일 블록 반송파를 나타낸다. 크기는 바이트로 표시됩니다. 크기가 표시되지 않으면 크기입니다. 크기와 양은 종종 세 가지 값으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e9095c6393c06f16504fcb2b9e560f38a38a063b" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">이름을 등록한 후 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; 를 사용 하여 들어오는 연결을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d3c38468398c9f7ba65583a0574f32622bbcf3f0" translate="yes" xml:space="preserve">
          <source>After sending the message &lt;code&gt;pong&lt;/code&gt; to the process &quot;ping&quot;, &quot;pong&quot; calls the &lt;code&gt;pong&lt;/code&gt; function again, which causes it to get back to the &lt;code&gt;receive&lt;/code&gt; again and wait for another message.</source>
          <target state="translated">메시지 &lt;code&gt;pong&lt;/code&gt; 을 프로세스 &quot;ping&quot;으로 보낸 후 &quot;pong&quot;은 &lt;code&gt;pong&lt;/code&gt; 기능을 다시 호출 하여 &lt;code&gt;receive&lt;/code&gt; 다시 돌아가서 다른 메시지를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="e36306045d856ed44b3178bdde7ee2e0ace1e9c1" translate="yes" xml:space="preserve">
          <source>After setting the dictionary the inflate operation should be retried without new input.</source>
          <target state="translated">사전을 설정 한 후 새 입력없이 팽창 조작을 재 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="46b2484894cf1b418bcc258ea3f4b87e3bcd685f" translate="yes" xml:space="preserve">
          <source>After testing that the client process exists:</source>
          <target state="translated">클라이언트 프로세스가 존재하는지 테스트 한 후 :</target>
        </trans-unit>
        <trans-unit id="22756028dc88f951673801206c8f0149ec02c1b4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;Flags&lt;/code&gt; field follow the &lt;code&gt;AtomCacheRefs&lt;/code&gt;. The first &lt;code&gt;AtomCacheRef&lt;/code&gt; is the one corresponding to &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Higher indices follow in sequence up to index &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 필드 다음에는 &lt;code&gt;AtomCacheRefs&lt;/code&gt; 를 따릅니다 . 첫 번째 &lt;code&gt;AtomCacheRef&lt;/code&gt; 는 &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0에 해당하는 인덱스입니다. 높은 인덱스는 순서대로 인덱스 &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="dca4e4c96c0a14c7be226e5bd7489709c72d0c43" translate="yes" xml:space="preserve">
          <source>After the application specifications have been updated, the instructions in the script are evaluated and the function returns &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; if successful. &lt;code&gt;OtherVsn&lt;/code&gt; and &lt;code&gt;Descr&lt;/code&gt; are the version (&lt;code&gt;UpFromVsn&lt;/code&gt; or &lt;code&gt;Vsn&lt;/code&gt;) and description (&lt;code&gt;Descr1&lt;/code&gt; or &lt;code&gt;Descr2&lt;/code&gt;) as specified in the script.</source>
          <target state="translated">응용 프로그램 스펙이 갱신 된 후 스크립트의 지시 사항이 평가되고 성공 하면 함수는 &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;OtherVsn&lt;/code&gt; 및 &lt;code&gt;Descr&lt;/code&gt; 은 스크립트에 지정된 버전 ( &lt;code&gt;UpFromVsn&lt;/code&gt; 또는 &lt;code&gt;Vsn&lt;/code&gt; ) 및 설명 ( &lt;code&gt;Descr1&lt;/code&gt; 또는 &lt;code&gt;Descr2&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0d4f7a31773a30c9ab44ee914a380f7ad8d9358d" translate="yes" xml:space="preserve">
          <source>After the change, 5 lines are presented as follows:</source>
          <target state="translated">변경 후 다음과 같이 5 줄이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2c691aee72f4af2559c4df9a131c0a55a89cadf0" translate="yes" xml:space="preserve">
          <source>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter &lt;code&gt;schema_location&lt;/code&gt; is set.</source>
          <target state="translated">데이터베이스가 삭제 된 후에도 Mnesia를 디스크없는 노드로 시작할 수 있습니다. 이는 구성 매개 변수 &lt;code&gt;schema_location&lt;/code&gt; 이 설정 되는 방법에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e4e458fe2735510f2a3f94986ee2e1c2798b1558" translate="yes" xml:space="preserve">
          <source>After the insertion of the employee named &lt;code&gt;klacke&lt;/code&gt;, the database has the following records:</source>
          <target state="translated">이름이 &lt;code&gt;klacke&lt;/code&gt; 인 직원을 삽입 한 후 데이터베이스에는 다음 레코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="014d2e6e6b7efad4c0429a37b959bc880d48f38c" translate="yes" xml:space="preserve">
          <source>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</source>
          <target state="translated">설치 후 애플리케이션 컨트롤러는 실행중인 모든 애플리케이션의 이전 및 새 구성 매개 변수를 비교하고 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8b5bb17b2c511826d46800999f421579e3ca514c" translate="yes" xml:space="preserve">
          <source>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</source>
          <target state="translated">복원 작업 후 레지스트리의 전체 내용이 수정되지 않은 것으로 표시됩니다. 여기에는 복원 전에 수정되었고 복원으로 덮어 쓰지 않은 모든 개체가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c4f3acb2fc60165a466769fee1869d300231ddf6" translate="yes" xml:space="preserve">
          <source>After the rootsymbol declaration comes an optional declaration of the &lt;code&gt;end_of_input&lt;/code&gt; symbol that your scanner is expected to use. For example:</source>
          <target state="translated">rootsymbol 선언 후 스캐너가 사용할 것으로 예상되는 &lt;code&gt;end_of_input&lt;/code&gt; 기호를 선언적으로 선언 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2770f0bd427f63fd51d60a2a398782f6d81807ca" translate="yes" xml:space="preserve">
          <source>After the successful build it's time to patch. The source tree directory, the directory of the installation and the applications to patch are given as arguments to &lt;code&gt;otp_patch_apply&lt;/code&gt;. The dependencies of each application are validated against the applications in the installation and the other applications given as arguments. If a dependency error is detected, the script will be aborted.</source>
          <target state="translated">성공적인 빌드 후 패치 할 시간입니다. 소스 트리 디렉토리, 설치 디렉토리 및 패치 할 응용 프로그램은 &lt;code&gt;otp_patch_apply&lt;/code&gt; 에 대한 인수로 제공 됩니다. 각 응용 프로그램의 종속성은 설치의 응용 프로그램 및 인수로 지정된 다른 응용 프로그램과 비교하여 검증됩니다. 종속성 오류가 감지되면 스크립트가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="59c978cfe3812d62d5db4509ebca4d4c5513e4b6" translate="yes" xml:space="preserve">
          <source>After the system has been cross built you can build and install the documentation the same way as after a native build of the system. See the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; section in the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document for information on how to build the documentation.</source>
          <target state="translated">시스템이 교차 빌드 된 후 시스템의 기본 빌드와 동일한 방식으로 문서를 빌드하고 설치할 수 있습니다. &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; 대한 정보 는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 문서 에서 문서 작성 방법 섹션 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b3f9b5771b4280d0c55a70767959a27ea46eb52" translate="yes" xml:space="preserve">
          <source>After this is compiled and the file &lt;code&gt;tut19.beam&lt;/code&gt; is copied to the necessary directories, the following is seen on (pong@kosken):</source>
          <target state="translated">이것이 컴파일되고 &lt;code&gt;tut19.beam&lt;/code&gt; 파일 이 필요한 디렉토리에 복사 된 후 , (pong @ kosken)에 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0717a39ec07e9aad70e9e475eae5bb9f752c8e1" translate="yes" xml:space="preserve">
          <source>Again, the &lt;code&gt;relup&lt;/code&gt; file is created manually. Either from scratch or by editing a generated version. Load all code for &lt;code&gt;ch_app&lt;/code&gt; first, and also load the application specification, before &lt;code&gt;prim_sup&lt;/code&gt; is updated. When downgrading, &lt;code&gt;prim_sup&lt;/code&gt; is to updated first, before the code for &lt;code&gt;ch_app&lt;/code&gt; and its application specification are unloaded.</source>
          <target state="translated">다시 &lt;code&gt;relup&lt;/code&gt; 파일이 수동으로 작성됩니다. 처음부터 또는 생성 된 버전을 편집하여. 모든 코드로드 &lt;code&gt;ch_app&lt;/code&gt; 을 먼저하고 전에 또한, 응용 프로그램 사양을로드 &lt;code&gt;prim_sup&lt;/code&gt; 가 업데이트됩니다. 다운 그레이드 할 때 &lt;code&gt;ch_app&lt;/code&gt; 및 해당 애플리케이션 스펙 의 코드 가 언로드 되기 전에 &lt;code&gt;prim_sup&lt;/code&gt; 이 먼저 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b5e61e0895721c0ebf450f07d288833226aa589" translate="yes" xml:space="preserve">
          <source>Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:</source>
          <target state="translated">다시, 이것은 Perl에서는 작동하지만 PCRE에서는 작동하지 않으며 같은 이유로 작동합니다. 더 깊은 재귀가 단일 문자와 일치하면 빈 문자열과 일치하도록 다시 입력 할 수 없습니다. 해결책은 두 경우를 분리하고 홀수 및 짝수 사례를 상위 레벨의 대안으로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b2767e308e62a98e4db59a3a9f824fa516512cb" translate="yes" xml:space="preserve">
          <source>Agent configuration:</source>
          <target state="translated">에이전트 구성 :</target>
        </trans-unit>
        <trans-unit id="3ec3b79e0abd28ca38f812dac049f7131b92ea23" translate="yes" xml:space="preserve">
          <source>Agent semantics</source>
          <target state="translated">에이전트 시맨틱</target>
        </trans-unit>
        <trans-unit id="292ef3c4e0286769b6dbb07a9c3a55d1d989a61e" translate="yes" xml:space="preserve">
          <source>Agent specific config options and types:</source>
          <target state="translated">에이전트 별 구성 옵션 및 유형 :</target>
        </trans-unit>
        <trans-unit id="9183ce25ce4e057cce5e3b5d3d28a86f4aa93b15" translate="yes" xml:space="preserve">
          <source>Agents to be accessed by the manager needs to be registered by a user. Once registered, they can be accessed by all registered users.</source>
          <target state="translated">관리자가 액세스 할 에이전트는 사용자가 등록해야합니다. 등록되면 등록 된 모든 사용자가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b321e7cb00697b98b1069def622912b90e34756e" translate="yes" xml:space="preserve">
          <source>Aho &amp;amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</source>
          <target state="translated">Aho &amp;amp; Johnson : 'LR Parsing', ACM 컴퓨팅 설문 조사, vol. 1974 년 6 월 2 일.</target>
        </trans-unit>
        <trans-unit id="8314c1bccd7fbe31d59f08ffd330d112f0923137" translate="yes" xml:space="preserve">
          <source>Aim for finding bugs. Write whatever test that has the highest probability of finding a bug, now or in the future. Concentrate more on the critical parts. Bugs in critical subsystems are much more expensive than others.</source>
          <target state="translated">버그 찾기를 목표로합니다. 현재 또는 미래에 버그를 발견 할 가능성이 가장 높은 테스트를 작성하십시오. 중요한 부분에 더 집중하십시오. 중요한 서브 시스템의 버그는 다른 것보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="2e73e04c930e7b3b6a12e1613006c2d06e333b4f" translate="yes" xml:space="preserve">
          <source>Aim for functionality testing rather than implementation details. Implementation details change quite often, and the test suites are to be long lived. Implementation details often differ on different platforms and versions. If implementation details must be tested, try to factor them out into separate test cases. These test cases can later be rewritten or skipped.</source>
          <target state="translated">구현 세부 사항보다는 기능 테스트를 목표로합니다. 구현 세부 사항은 자주 변경되며 테스트 스위트는 오래 지속됩니다. 구현 세부 사항은 종종 플랫폼과 버전에 따라 다릅니다. 구현 세부 사항을 테스트해야하는 경우 별도의 테스트 케이스로이를 고려하십시오. 이 테스트 사례는 나중에 다시 쓰거나 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5204c24c2356e334c01209b09953d29e8b1c732c" translate="yes" xml:space="preserve">
          <source>Alarm handling</source>
          <target state="translated">경보 처리</target>
        </trans-unit>
        <trans-unit id="07994d0d2fea2b8ccddc2fe4a57609e0e8cf0605" translate="yes" xml:space="preserve">
          <source>Alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">알람, 즉 BEL 문자 (16 진 07)</target>
        </trans-unit>
        <trans-unit id="44b68bd3aa7ebc745c49072e3fc9224605032491" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is either of the alarms specified above.</source>
          <target state="translated">경보는 SASL 경보 핸들러에보고 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 참조 ) . 알람을 설정하기 위해 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; 이 호출됩니다. 여기서 &lt;code&gt;Alarm&lt;/code&gt; 은 위에 지정된 알람 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0f8dd2eebf6d2846565db4f8d38173a2b29d2814" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is the alarm specified above.</source>
          <target state="translated">경보는 SASL 경보 핸들러에보고 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 참조 ) . 알람을 설정하기 위해 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; 이 호출됩니다. 여기서 &lt;code&gt;Alarm&lt;/code&gt; 은 위에서 지정한 알람 입니다.</target>
        </trans-unit>
        <trans-unit id="84ce7c0201c306089cc2d312b83151f452054aab" translate="yes" xml:space="preserve">
          <source>Alas some drivers only support sequential traversal of the result set, e.i. they do not support what in the ODBC world is known as scrollable cursors. This will have the effect that functions such as &lt;code&gt;first/[1,2]&lt;/code&gt;, &lt;code&gt;last/[1,2]&lt;/code&gt;, &lt;code&gt;prev[1,2]&lt;/code&gt;, etc will return &lt;code&gt;{error, driver_does_not_support_function}&lt;/code&gt;</source>
          <target state="translated">아아 일부 드라이버는 결과 집합의 순차 순회 만 지원합니다. 즉, ODBC 세계에서 스크롤 가능한 커서로 알려진 것을 지원하지 않습니다. 이는 &lt;code&gt;first/[1,2]&lt;/code&gt; , &lt;code&gt;last/[1,2]&lt;/code&gt; , &lt;code&gt;prev[1,2]&lt;/code&gt; 등과 같은 함수 가 &lt;code&gt;{error, driver_does_not_support_function}&lt;/code&gt; 리턴하는 효과 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3544e748508a0bbd0fc5c633ca3118ece8b0800" translate="yes" xml:space="preserve">
          <source>Algorithm &lt;code&gt;dss&lt;/code&gt; can only be used together with digest type &lt;code&gt;sha&lt;/code&gt;.</source>
          <target state="translated">알고리즘 &lt;code&gt;dss&lt;/code&gt; 는 다이제스트 유형 &lt;code&gt;sha&lt;/code&gt; 와 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37c4127ccfb7b20befe4cb97e24121c28c2f7f1f" translate="yes" xml:space="preserve">
          <source>Algorithm specific internal state</source>
          <target state="translated">알고리즘 특정 내부 상태</target>
        </trans-unit>
        <trans-unit id="f502ff90b179f9e55f8a7ae7ffe6d44ac52ffa57" translate="yes" xml:space="preserve">
          <source>Algorithm-dependent state that can be printed or saved to file.</source>
          <target state="translated">인쇄 또는 파일로 저장할 수있는 알고리즘 종속 상태.</target>
        </trans-unit>
        <trans-unit id="75ed735ab6b662cd2ed59461e6465ca8ad02da5f" translate="yes" xml:space="preserve">
          <source>Algorithm-dependent state.</source>
          <target state="translated">알고리즘 종속 상태.</target>
        </trans-unit>
        <trans-unit id="d44cc1b551df7badcd7a33c05306605d60158636" translate="yes" xml:space="preserve">
          <source>Algorithms for directed graphs.</source>
          <target state="translated">유 방향 그래프에 대한 알고리즘.</target>
        </trans-unit>
        <trans-unit id="479976d6e7303ea1ee63388a8b2e770b0c6d7167" translate="yes" xml:space="preserve">
          <source>Alivename, &lt;code&gt;alive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alive&lt;/code&gt; 이름, 살아있는</target>
        </trans-unit>
        <trans-unit id="113679e7d7df16876eb31c71a0f678be963054d7" translate="yes" xml:space="preserve">
          <source>All &quot;function calls&quot; must be tuples, even if they take no arguments. The value of &lt;code&gt;self&lt;/code&gt; is the atom() &lt;code&gt;self&lt;/code&gt;, but the value of &lt;code&gt;{self}&lt;/code&gt; is the pid() of the current process.</source>
          <target state="translated">모든 &quot;함수 호출&quot;은 인수가 없어도 튜플이어야합니다. &lt;code&gt;self&lt;/code&gt; 값은 atom () &lt;code&gt;self&lt;/code&gt; 이지만 &lt;code&gt;{self}&lt;/code&gt; 값은 현재 프로세스의 pid ()입니다.</target>
        </trans-unit>
        <trans-unit id="c96f50147ab1ef9d7a93bb31a493f340cbc1ac77" translate="yes" xml:space="preserve">
          <source>All (in)direct calls from functions in &lt;code&gt;toolbar&lt;/code&gt; to functions in &lt;code&gt;debugger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toolbar&lt;/code&gt; 함수에서 &lt;code&gt;debugger&lt;/code&gt; 함수로의 모든 (in) 직접 호출 .</target>
        </trans-unit>
        <trans-unit id="089083e2c94f89536494899703365f0e8ddff6fd" translate="yes" xml:space="preserve">
          <source>All (locally) mounted disks are checked, including the swap disk if it is present.</source>
          <target state="translated">스왑 디스크가있는 경우이를 포함하여 모든 (로컬로) 마운트 된 디스크가 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="f677675819b8b0d1f1b80ed411e21b154b117015" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; are processed in order of appearance.</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 은 모양 순서대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="05aeddfde77656e8d62c4f7d53fc3c8c4d3ed5c3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;LevelEntry&lt;/code&gt;s of a list must contain the same &lt;code&gt;LevelTag&lt;/code&gt;, except on the top level where both &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;processor&lt;/code&gt;&lt;code&gt;LevelTag&lt;/code&gt;s can coexist.    &lt;code&gt;{LevelTag, SubLevel} == {LevelTag, [], SubLevel}&lt;/code&gt;    More &lt;code&gt;LevelTag&lt;/code&gt;s can be introduced in a future release.     The &lt;code&gt;info_list()&lt;/code&gt; can be extended in a future release.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 와 &lt;code&gt;processor&lt;/code&gt; &lt;code&gt;LevelTag&lt;/code&gt; 가 공존 할 수 있는 최상위 레벨을 제외하고 목록의 모든 &lt;code&gt;LevelEntry&lt;/code&gt; 는 동일한 &lt;code&gt;LevelTag&lt;/code&gt; 를 포함해야합니다 . &lt;code&gt;{LevelTag, SubLevel} == {LevelTag, [], SubLevel}&lt;/code&gt; 향후 릴리스에서 더 많은 &lt;code&gt;LevelTag&lt;/code&gt; 가 도입 될 수 있습니다. &lt;code&gt;info_list()&lt;/code&gt; 미래의 릴리스에서 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6724788c6ade526686ec55a7af8484e09d219146" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;cth_conn_log&lt;/code&gt; hook options described can also be specified in a configuration file with configuration variable &lt;code&gt;ct_conn_log&lt;/code&gt;.</source>
          <target state="translated">설명 된 모든 &lt;code&gt;cth_conn_log&lt;/code&gt; 후크 옵션은 구성 변수 &lt;code&gt;ct_conn_log&lt;/code&gt; 가있는 구성 파일에서도 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a4b3de223153d6148caabecc5ca1ade2664a14a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;snmp&lt;/code&gt; counters are set to zero.</source>
          <target state="translated">모든 &lt;code&gt;snmp&lt;/code&gt; 카운터가 0으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1518061c2a50f94ff59e63daeae206bdc35745d1" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;named&lt;/strong&gt; subpatterns in the regular expression, as if a &lt;code&gt;list()&lt;/code&gt; of all the names &lt;strong&gt;in alphabetical order&lt;/strong&gt; was specified. The list of all names can also be retrieved with &lt;code&gt;&lt;a href=&quot;#inspect-2&quot;&gt;inspect/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;알파벳 순서&lt;/strong&gt; 로 모든 이름의 &lt;code&gt;list()&lt;/code&gt; 가 지정된 것처럼 정규식의 모든 &lt;strong&gt;명명 된&lt;/strong&gt; 하위 패턴 &lt;code&gt;&lt;a href=&quot;#inspect-2&quot;&gt;inspect/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 모든 이름 목록을 검색 할 수도 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4916d63a32f5bd45e8c8ebc0b371a252007867f" translate="yes" xml:space="preserve">
          <source>All API functions that update the index return a &lt;code&gt;NewIndex&lt;/code&gt; term. This is for backward compatibility with a previous implementation that used a B+ tree written purely in Erlang for the index. The &lt;code&gt;NewIndex&lt;/code&gt; return value can now be ignored. The return value is now the unchanged table identifier for the ets table.</source>
          <target state="translated">인덱스를 업데이트하는 모든 API 함수는 &lt;code&gt;NewIndex&lt;/code&gt; 용어를 반환합니다 . 이것은 Erlang에서 순전히 색인으로 작성된 B + 트리를 사용한 이전 구현과의 호환성을위한 것입니다. &lt;code&gt;NewIndex&lt;/code&gt; 반환 값은 이제 무시할 수 있습니다. 리턴 값은 이제 ets 테이블의 변경되지 않은 테이블 ID입니다.</target>
        </trans-unit>
        <trans-unit id="508db9dc0ec99907c00ed0f8830bf421e130f560" translate="yes" xml:space="preserve">
          <source>All API-functions are guarded and if you pass an argument of the wrong type a runtime error will occur. All input parameters to internal functions are trusted to be correct. It is a good programming practise to only distrust input from truly external sources. You are not supposed to catch these errors, it will only make the code very messy and much more complex, which introduces more bugs and in the worst case also covers up the actual faults. Put your effort on testing instead, you should trust your own input.</source>
          <target state="translated">모든 API 함수가 보호되며 잘못된 유형의 인수를 전달하면 런타임 오류가 발생합니다. 내부 기능에 대한 모든 입력 매개 변수는 올바른 것으로 신뢰됩니다. 진정한 외부 소스의 입력 만 불신하는 것이 좋은 프로그래밍 방법입니다. 이러한 오류를 잡아서는 안됩니다. 코드가 매우 복잡하고 훨씬 복잡해져 더 많은 버그가 발생하고 최악의 경우 실제 오류도 포함합니다. 테스트에 노력을 기울이고 자신의 의견을 신뢰해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ff4622a14c4c7f7fbaab2bf437fe6ca8d16292" translate="yes" xml:space="preserve">
          <source>All DTLS versions supported by the SSL application. DTLS 1.2 requires sufficient support from the Crypto application.</source>
          <target state="translated">SSL 애플리케이션이 지원하는 모든 DTLS 버전. DTLS 1.2는 Crypto 응용 프로그램의 충분한 지원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="59b704215a27754dabda2c983777a71cd473ecc4" translate="yes" xml:space="preserve">
          <source>All Dets functions return &lt;code&gt;{error, Reason}&lt;/code&gt; if an error occurs (&lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; are exceptions, they exit the process with the error tuple). If badly formed arguments are specified, all functions exit the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">오류가 발생하면 모든 Dets 함수는 &lt;code&gt;{error, Reason}&lt;/code&gt; 리턴 합니다 ( &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 는 예외이며 오류 튜플과 함께 프로세스를 종료합니다). 잘못 구성된 인수를 지정하면 모든 함수가 &lt;code&gt;badarg&lt;/code&gt; 메시지 와 함께 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="6860af1b417f061473f28a251963ae51220b55b4" translate="yes" xml:space="preserve">
          <source>All Erlang processes have a default standard I/O device. This device is used when no &lt;code&gt;IoDevice&lt;/code&gt; argument is specified in the function calls in this module. However, it is sometimes desirable to use an explicit &lt;code&gt;IoDevice&lt;/code&gt; argument that refers to the default I/O device. This is the case with functions that can access either a file or the default I/O device. The atom &lt;code&gt;standard_io&lt;/code&gt; has this special meaning. The following example illustrates this:</source>
          <target state="translated">모든 Erlang 프로세스에는 기본 표준 I / O 장치가 있습니다. 이 장치는 이 모듈의 함수 호출에 &lt;code&gt;IoDevice&lt;/code&gt; 인수가 지정 되지 않은 경우에 사용됩니다 . 그러나 때로는 기본 I / O 장치를 나타내는 명시 적 &lt;code&gt;IoDevice&lt;/code&gt; 인수 를 사용하는 것이 바람직합니다 . 파일 또는 기본 I / O 장치에 액세스 할 수있는 기능의 경우입니다. atom_ &lt;code&gt;standard_io&lt;/code&gt; 은이 특별한 의미를 갖습니다. 다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="97b951c1c805c5f05124e900fd4fa56864d49618" translate="yes" xml:space="preserve">
          <source>All Erlang types are the string equivalent in LTTng.</source>
          <target state="translated">모든 Erlang 유형은 LTTng와 동등한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d9f521ade6fc1dd9350ccff9c5983982a41844ce" translate="yes" xml:space="preserve">
          <source>All Erlang/OTP applications except the &lt;code&gt;wx&lt;/code&gt; application can be cross compiled. The build of the &lt;code&gt;wx&lt;/code&gt; driver will currently be automatically disabled when cross compiling.</source>
          <target state="translated">&lt;code&gt;wx&lt;/code&gt; 어플리케이션을 제외한 모든 Erlang / OTP 어플리케이션은 크로스 컴파일 될 수 있습니다. 크로스 컴파일시 &lt;code&gt;wx&lt;/code&gt; 드라이버 빌드 는 현재 자동으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad88821804527519cf8d8d810f3204aedf5bf2e" translate="yes" xml:space="preserve">
          <source>All I/O from the port is binary data objects as opposed to lists of bytes.</source>
          <target state="translated">포트의 모든 I / O는 바이트 목록이 아닌 이진 데이터 개체입니다.</target>
        </trans-unit>
        <trans-unit id="2dd52ee361652541899aa325d9fd9f53e18c02c1" translate="yes" xml:space="preserve">
          <source>All Mnesia transactions, including all the schema update functions, either return value &lt;code&gt;{atomic, Val}&lt;/code&gt; or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; can be either of the atoms in the following list. The function &lt;code&gt;error_description/1&lt;/code&gt; returns a descriptive string that describes the error.</source>
          <target state="translated">모든 스키마 업데이트 함수를 포함한 모든 Mnesia 트랜잭션은 &lt;code&gt;{atomic, Val}&lt;/code&gt; 값 또는 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 반환합니다 . &lt;code&gt;Reason&lt;/code&gt; 는 다음 목록의 원자 중 하나 일 수 있습니다. &lt;code&gt;error_description/1&lt;/code&gt; 함수 는 오류를 설명하는 설명 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4d3c60202c3777ca90cba552fcd0b5e85782d21a" translate="yes" xml:space="preserve">
          <source>All NIFs of a module must have an Erlang implementation as well.</source>
          <target state="translated">모듈의 모든 NIF에도 Erlang 구현이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a725195324a4bf0385d8cc76f623d576b9073dd8" translate="yes" xml:space="preserve">
          <source>All ProcBin objects in a process are part of a linked list, so that the garbage collector can keep track of them and decrement the reference counters in the binary when a ProcBin disappears.</source>
          <target state="translated">프로세스의 모든 ProcBin 오브젝트는 링크 된 목록의 일부이므로 가비지 콜렉터는이를 추적하고 ProcBin이 사라질 때 바이너리의 참조 카운터를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea090b0550d7e3c8580dc19d0e4eca0afcac1702" translate="yes" xml:space="preserve">
          <source>All SASL reports have a metadata field &lt;code&gt;domain&lt;/code&gt; which is set to &lt;code&gt;[otp,sasl]&lt;/code&gt;. This field can be used by filters to stop or allow the log events.</source>
          <target state="translated">모든 SASL 보고서에는 &lt;code&gt;[otp,sasl]&lt;/code&gt; 로 설정된 메타 데이터 필드 &lt;code&gt;domain&lt;/code&gt; 이 있습니다. 이 필드는 필터가 로그 이벤트를 중지하거나 허용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f15754d3db80f2fdc54c4817ccee09d053bbbf8" translate="yes" xml:space="preserve">
          <source>All SSL and TLS versions prior to TLS 1.2 use a combination of md5 and sha1 hashes in the handshake for various purposes:</source>
          <target state="translated">TLS 1.2 이전의 모든 SSL 및 TLS 버전은 다양한 목적으로 핸드 셰이크에서 md5 및 sha1 해시 조합을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4d20ed1ea888788dca7c3c5db66c577a283406e7" translate="yes" xml:space="preserve">
          <source>All SSL/TLS versions supported by the SSL application. TLS 1.2 requires sufficient support from the Crypto application.</source>
          <target state="translated">SSL 애플리케이션이 지원하는 모든 SSL / TLS 버전. TLS 1.2는 Crypto 응용 프로그램의 충분한 지원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="68fce467cd9e8e0d201b3f589073cfe5fb95d32d" translate="yes" xml:space="preserve">
          <source>All TCP socket options are accepted except &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;deliver&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;packet&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; , &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;deliver&lt;/code&gt; y , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;packet&lt;/code&gt; 을 제외한 모든 TCP 소켓 옵션이 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5b34ac6bc99e27ebc78ae9ef663f69f3aa7a65b" translate="yes" xml:space="preserve">
          <source>All Unicode newline sequences</source>
          <target state="translated">모든 유니 코드 줄 바꾸기 시퀀스</target>
        </trans-unit>
        <trans-unit id="2dbd3097b8923c397d9061270fd4c85d43474de4" translate="yes" xml:space="preserve">
          <source>All access files in the path to a requested asset are read once per request. This means that the load on the server increases when &lt;code&gt;htaccess&lt;/code&gt; is used.</source>
          <target state="translated">요청 된 자산의 경로에있는 모든 액세스 파일은 요청 당 한 번 읽습니다. 이는 &lt;code&gt;htaccess&lt;/code&gt; 가 사용될 때 서버의로드가 증가 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b65f417a9d96a9f2d2511f358eeb52c2d5221959" translate="yes" xml:space="preserve">
          <source>All allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected.</source>
          <target state="translated">&lt;code&gt;alloc_util&lt;/code&gt; 에 기반한 모든 할당 자가 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="487ed78b0938a6d1f8103db69e76299ed79ed19c" translate="yes" xml:space="preserve">
          <source>All application directories found in the additional directories appears before the standard OTP applications, except for the Kernel and STDLIB applications, which are placed before any additional applications. In other words, modules found in any of the additional library directories override modules with the same name in OTP, except for modules in Kernel and STDLIB.</source>
          <target state="translated">추가 디렉토리에있는 모든 응용 프로그램 디렉토리는 표준 OTP 응용 프로그램 앞에 표시됩니다 (커널 및 STDLIB 응용 프로그램은 추가 응용 프로그램 앞에 위치 함). 다시 말해서, 추가 라이브러리 디렉토리에서 찾은 모듈은 커널 및 STDLIB의 모듈을 제외하고 OTP에서 동일한 이름을 가진 모듈을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="aed81dd75a1fe5a5f216237b2556bd6822c73c1d" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;code&gt;halt(Status)&lt;/code&gt;. If command-line flag &lt;code&gt;-heart&lt;/code&gt; was specified, the &lt;code&gt;heart&lt;/code&gt; program is terminated before the Erlang node terminates. For more information, see &lt;code&gt;heart(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;halt(Status)&lt;/code&gt; 호출하여 시스템이 종료되기 전에 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 모든 포트가 닫힙니다 . 명령 행 플래그 &lt;code&gt;-heart&lt;/code&gt; 를 지정 하면 Erlang 노드가 종료되기 전에 &lt;code&gt;heart&lt;/code&gt; 프로그램이 종료됩니다. 자세한 내용은 &lt;code&gt;heart(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d181c1e78cebe0843b022cbfb70d621d01c1feeb" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates. If command-line flag &lt;code&gt;-heart&lt;/code&gt; was specified, the &lt;code&gt;heart&lt;/code&gt; program tries to reboot the system. For more information, see &lt;code&gt;heart(3)&lt;/code&gt;.</source>
          <target state="translated">모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 시스템이 종료되기 전에 모든 포트가 닫힙니다. 명령 행 플래그 &lt;code&gt;-heart&lt;/code&gt; 가 지정된 경우, &lt;code&gt;heart&lt;/code&gt; 프로그램은 시스템 재부팅을 시도합니다. 자세한 내용은 &lt;code&gt;heart(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31bd3e3bf18b14bb65fb12d63888c9cd0d2fd4b0" translate="yes" xml:space="preserve">
          <source>All applications included by this application. When this application is started, all included applications are loaded automatically, but not started, by the application controller. It is assumed that the top-most supervisor of the included application is started by a supervisor of this application.</source>
          <target state="translated">이 응용 프로그램에 포함 된 모든 응용 프로그램. 이 애플리케이션이 시작되면 포함 된 모든 애플리케이션이 애플리케이션 컨트롤러에 의해 자동으로로드되지만 시작되지는 않습니다. 포함 된 애플리케이션의 최상위 관리자는이 애플리케이션의 관리자에 의해 시작된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="240f8d13b43d7ee3cac18e5842f7f15a95cd9de5" translate="yes" xml:space="preserve">
          <source>All applications that must be started before this application is allowed to be started. &lt;code&gt;systools&lt;/code&gt; uses this list to generate correct start scripts. Defaults to the empty list, but notice that all applications have dependencies to (at least) Kernel and STDLIB.</source>
          <target state="translated">이 응용 프로그램을 시작하기 전에 시작해야하는 모든 응용 프로그램을 시작할 수 있습니다. &lt;code&gt;systools&lt;/code&gt; 는이 목록을 사용하여 올바른 시작 스크립트를 생성합니다. 기본값은 빈 목록이지만 모든 응용 프로그램은 최소한 커널과 STDLIB에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2add5c786e4437232e07f68f555e8cec5d10a4" translate="yes" xml:space="preserve">
          <source>All available ports in the Erlang emulator are in use.</source>
          <target state="translated">Erlang 에뮬레이터에서 사용 가능한 모든 포트가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="f84b54afc405de6cbd2ad11831864c463f1ea3fa" translate="yes" xml:space="preserve">
          <source>All available probes can be listed like this:</source>
          <target state="translated">사용 가능한 모든 프로브는 다음과 같이 나열 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d3b3bbd1737cb224eb46fd66ec80e666cf1f66" translate="yes" xml:space="preserve">
          <source>All binary operators are left associative; for instance, &lt;code&gt;A&amp;nbsp;|&amp;nbsp;B &amp;nbsp;||&amp;nbsp;C&lt;/code&gt; is equivalent to &lt;code&gt;(A&amp;nbsp;|&amp;nbsp;B)&amp;nbsp;||&amp;nbsp;C&lt;/code&gt;. The following is a list of all operators, in increasing order of  &lt;strong id=&quot;precedence&quot;&gt;precedence&lt;/strong&gt;:</source>
          <target state="translated">모든 이진 연산자는 연관되어 있습니다. 예를 들어 &lt;code&gt;A&amp;nbsp;|&amp;nbsp;B &amp;nbsp;||&amp;nbsp;C&lt;/code&gt; 는 &lt;code&gt;(A&amp;nbsp;|&amp;nbsp;B)&amp;nbsp;||&amp;nbsp;C&lt;/code&gt; . 다음은 모든 연산자의 목록이며 &lt;strong id=&quot;precedence&quot;&gt;우선 순위&lt;/strong&gt; 가 &lt;strong id=&quot;precedence&quot;&gt;높습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4eba54c164609c10e1724efde1b5a4f8594b594d" translate="yes" xml:space="preserve">
          <source>All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;binary&lt;/code&gt;, not returning subpatterns you are not interested in is a good way to optimize.</source>
          <target state="translated">첫 번째로 일치하는 하위 패턴, 즉 명시 적으로 캡처 된 모든 하위 패턴을 제외하고 주제 문자열에서 완전히 일치하는 부분은 아닙니다. 정규 표현식 전체가 주제의 많은 부분과 일치하지만 관심있는 부분이 명시 적으로 캡처 된 하위 패턴에있는 경우 유용합니다. 리턴 유형이 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;binary&lt;/code&gt; 인 경우 관심없는 서브 패턴을 리턴하지 않는 것이 최적화하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b4ba388e0b6829ee7e6b0f29a6f89a7986b6d983" translate="yes" xml:space="preserve">
          <source>All calls are stored in the history buffer and can be recalled and stored in a configuration file. This makes it easy to set up the same trace environment, for example, if you want to compare two test runs. It also reduces the amount of typing when using &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell.</source>
          <target state="translated">모든 호출은 히스토리 버퍼에 저장되며 구성 파일에 호출 및 저장 될 수 있습니다. 예를 들어 두 개의 테스트 실행을 비교하려는 경우 동일한 추적 환경을 쉽게 설정할 수 있습니다. 또한 Erlang 쉘에서 &lt;code&gt;ttb&lt;/code&gt; 를 사용할 때 입력량 을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b75423c77806558051eb62cb5b02445cef05ff93" translate="yes" xml:space="preserve">
          <source>All calls that have both an external and a local version.</source>
          <target state="translated">외부 버전과 로컬 버전이 모두있는 모든 통화.</target>
        </trans-unit>
        <trans-unit id="d0fd374788e00e86bd43e2341f520f508c4c7e7e" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;ttb&lt;/code&gt; is stored in the history. This function returns the current content of the history. Any entry can be reexecuted with &lt;code&gt;run_history/1&lt;/code&gt; or stored in a configuration file with &lt;code&gt;write_config/2,3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttb&lt;/code&gt; 에 대한 모든 호출은 히스토리 에 저장됩니다. 이 함수는 히스토리의 현재 컨텐츠를 리턴합니다. &lt;code&gt;run_history/1&lt;/code&gt; 로 모든 항목을 다시 실행 하거나 &lt;code&gt;write_config/2,3&lt;/code&gt; 으로 구성 파일에 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bbe19e21b0c2eee883cf8913cd7724d259725e7" translate="yes" xml:space="preserve">
          <source>All calls within the Kernel application.</source>
          <target state="translated">커널 응용 프로그램 내의 모든 호출</target>
        </trans-unit>
        <trans-unit id="d69e89620f8a9f9e87b4eee0b38ab9d9d4411b86" translate="yes" xml:space="preserve">
          <source>All captured subpatterns including the complete matching string. This is the default.</source>
          <target state="translated">완전한 일치 문자열을 포함하여 모든 캡처 된 서브 패턴. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="34abf6827e137ec9ba4d30877ba27c48b7d401ae" translate="yes" xml:space="preserve">
          <source>All characters needs to be valid characters on the specific OS using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters not necessarily will cause &lt;code&gt;&lt;a href=&quot;#cmd-1&quot;&gt;os:cmd/1&lt;/a&gt;&lt;/code&gt; to fail, but may instead produce invalid results.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하여 특정 OS에서 모든 문자는 유효한 문자 여야합니다 . 특히 널 문자 (정수 값 0)는 허용되지 않습니다. 그러나 모든 유효하지 않은 문자가 반드시 &lt;code&gt;&lt;a href=&quot;#cmd-1&quot;&gt;os:cmd/1&lt;/a&gt;&lt;/code&gt; 을 유발 하지는 않지만 대신 잘못된 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ccc47d84718cbe0754906ab548e6f0d0c99ed92" translate="yes" xml:space="preserve">
          <source>All checks with function &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; are performed before the release package is created. Options &lt;code&gt;src_tests&lt;/code&gt; and &lt;code&gt;exref&lt;/code&gt; are also valid here.</source>
          <target state="translated">릴리스 패키지가 작성되기 전에 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 함수를 사용한 모든 검사 가 수행됩니다. &lt;code&gt;src_tests&lt;/code&gt; 및 &lt;code&gt;exref&lt;/code&gt; 옵션 도 여기에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2a363a443c582c3241bf4c750bee059e7cc5f662" translate="yes" xml:space="preserve">
          <source>All communication between Erlang and C must be established by creating the port. The Erlang process that creates a port is said to be &lt;strong&gt;the connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the connected process. If the connected process terminates, the port also terminates (and the external program, if it is written properly).</source>
          <target state="translated">포트를 작성하여 Erlang과 C 간의 모든 통신을 설정해야합니다. 포트를 생성하는 Erlang 프로세스는 포트 &lt;strong&gt;의 연결된 프로세스&lt;/strong&gt; 라고합니다. 포트와의 모든 통신은 연결된 프로세스를 거쳐야합니다. 연결된 프로세스가 종료되면 포트도 종료됩니다 (외부 프로그램이 올바르게 작성된 경우).</target>
        </trans-unit>
        <trans-unit id="eb709283e324b3781c25b7de16d1f666dbdb72e8" translate="yes" xml:space="preserve">
          <source>All configuration data must be included in configuration files that are located in the configuration directory. The name of this directory is given in the &lt;code&gt;config_dir&lt;/code&gt; configuration parameter. These files are read at start-up, and are used to initialize the SNMPv2-MIB or STANDARD-MIB, SNMP-FRAMEWORK-MIB, SNMP-MPD-MIB, SNMP-VIEW-BASED-ACM-MIB, SNMP-COMMUNITY-MIB, SNMP-USER-BASED-SM-MIB, SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB (refer to the &lt;code&gt;&lt;a href=&quot;snmp_agent_funct_descr#management&quot;&gt;Management of the Agent&lt;/a&gt;&lt;/code&gt; for a description of the MIBs).</source>
          <target state="translated">모든 구성 데이터는 구성 디렉토리에있는 구성 파일에 포함되어야합니다. 이 디렉토리의 이름은 &lt;code&gt;config_dir&lt;/code&gt; 구성 매개 변수에 제공됩니다. 이러한 파일은 시작시 읽혀지며 SNMPv2-MIB 또는 STANDARD-MIB, SNMP-FRAMEWORK-MIB, SNMP-MPD-MIB, SNMP-VIEW-BASED-ACM-MIB, SNMP-COMMUNITY-MIB를 초기화하는 데 사용됩니다. , SNMP-USER-BASED-SM-MIB, SNMP-TARGET-MIB 및 SNMP-NOTIFICATION-MIB (MIB 에 대한 설명은 &lt;code&gt;&lt;a href=&quot;snmp_agent_funct_descr#management&quot;&gt;Management of the Agent&lt;/a&gt;&lt;/code&gt; 참조하십시오 ).</target>
        </trans-unit>
        <trans-unit id="8fb98e168e1cdf700c77f9c617ec623e357237e5" translate="yes" xml:space="preserve">
          <source>All configuration parameters can be set at start by adding &lt;code&gt;-OptName Value&lt;/code&gt; to the command line, for example:</source>
          <target state="translated">명령 줄에 &lt;code&gt;-OptName Value&lt;/code&gt; 를 추가하여 시작시 모든 구성 매개 변수를 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e34d05132c3363672c983606c16c8b3f4cd48ded" translate="yes" xml:space="preserve">
          <source>All contained terms of a list/tuple/map must belong to the same environment as the list/tuple/map itself. Terms can be copied between environments with &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록 / 튜플 / 맵에 포함 된 모든 용어는 목록 / 튜플 / 맵 자체와 동일한 환경에 속해야합니다. &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; 를 사용 하여 환경간에 용어를 복사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17c9652ae90aa032b597d6483480d6b35f039ee7" translate="yes" xml:space="preserve">
          <source>All created threads must be joined by the driver before it is unloaded. If the driver fails to join all threads created before it is unloaded, the runtime system most likely crashes when the driver code is unloaded.</source>
          <target state="translated">생성 된 모든 스레드는 언로드되기 전에 드라이버에 의해 결합되어야합니다. 드라이버가 언로드되기 전에 작성된 모든 스레드를 결합하지 못하면 드라이버 코드가 언로드 될 때 런타임 시스템이 충돌 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="b1b81e568bd7b5d5fd8f96a201883e60680fff00" translate="yes" xml:space="preserve">
          <source>All currently existing ports and all that will be created in the future.</source>
          <target state="translated">현재 존재하는 모든 포트 및 향후에 생성 될 모든 포트</target>
        </trans-unit>
        <trans-unit id="bc6ddc7f5e7f3a0bc6a355b03f78b8fb8d4e520a" translate="yes" xml:space="preserve">
          <source>All currently existing ports.</source>
          <target state="translated">현재 존재하는 모든 포트</target>
        </trans-unit>
        <trans-unit id="f5bd9e7d7b44e072c90e6f8dda758c22961a860e" translate="yes" xml:space="preserve">
          <source>All currently existing processes and all that will be created in the future.</source>
          <target state="translated">현재 존재하는 모든 프로세스 및 향후 생성 될 모든 프로세스</target>
        </trans-unit>
        <trans-unit id="2f2c9f694f2fd17dd3c35e9d0f951e41f0de39c2" translate="yes" xml:space="preserve">
          <source>All currently existing processes and ports and all that will be created in the future.</source>
          <target state="translated">현재 존재하는 모든 프로세스 및 포트와 앞으로 생성 될 모든 것.</target>
        </trans-unit>
        <trans-unit id="a4a1660f0cdb5d321af926f22eca810cb75c7869" translate="yes" xml:space="preserve">
          <source>All currently existing processes and ports.</source>
          <target state="translated">현재 존재하는 모든 프로세스 및 포트</target>
        </trans-unit>
        <trans-unit id="f2774916f15014b59bbde049da46ed37bb38a8f7" translate="yes" xml:space="preserve">
          <source>All currently existing processes.</source>
          <target state="translated">현재 존재하는 모든 프로세스</target>
        </trans-unit>
        <trans-unit id="ff87064c3c8ceacf6dda1a78dcbdf032fd899aad" translate="yes" xml:space="preserve">
          <source>All data in messages between Erlang processes is copied, except for &lt;code&gt;&lt;a href=&quot;binaryhandling#refc_binary&quot;&gt;refc binaries&lt;/a&gt;&lt;/code&gt; on the same Erlang node.</source>
          <target state="translated">동일한 Erlang 노드에있는 &lt;code&gt;&lt;a href=&quot;binaryhandling#refc_binary&quot;&gt;refc binaries&lt;/a&gt;&lt;/code&gt; 를 제외하고 Erlang 프로세스 간 메시지의 모든 데이터가 복사 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1a7180beea8d2918397b581bb39b7c3d97266f" translate="yes" xml:space="preserve">
          <source>All dates conform to the Gregorian calendar. This calendar was introduced by Pope Gregory XIII in 1582 and was used in all Catholic countries from this year. Protestant parts of Germany and the Netherlands adopted it in 1698, England followed in 1752, and Russia in 1918 (the October revolution of 1917 took place in November according to the Gregorian calendar).</source>
          <target state="translated">모든 날짜는 그레고리력을 따릅니다. 이 달력은 1582 년 교황 그레고리 13 세에 의해 소개되었으며 올해부터 모든 가톨릭 국가에서 사용되었습니다. 독일과 네덜란드의 개신교 인들은 1698 년에 그것을 채택했고, 영국은 1752 년에, 1918 년에는 러시아를 채택했다 (1917 년 10 월 혁명은 그레고리력에 따르면 11 월에 일어난다).</target>
        </trans-unit>
        <trans-unit id="5a9db788cb6f00701b230b3a0369568000727f48" translate="yes" xml:space="preserve">
          <source>All dictionaries should typically inherit RFC 6733 AVPs from &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt;.</source>
          <target state="translated">모든 사전에서 일반적으로 상속 RFC 6733 AVPs해야 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2f43f5ea4d88b08d32795c7efcb41af6ca7e5e" translate="yes" xml:space="preserve">
          <source>All direct and indirect calls within the Kernel application. Both the calling and the used functions of indirect calls are defined in modules of the kernel application, but it is possible that some functions outside the kernel application are used by indirect calls.</source>
          <target state="translated">커널 애플리케이션 내의 모든 직간접 호출 간접 호출의 호출 및 사용 된 기능은 모두 커널 응용 프로그램의 모듈에 정의되어 있지만 커널 응용 프로그램 외부의 일부 기능은 간접 호출에 의해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f33a648178dc389edc92503195d2baefeb6e84" translate="yes" xml:space="preserve">
          <source>All dirty functions execute a call to &lt;code&gt;exit({aborted, Reason})&lt;/code&gt; on failure. Even if the following functions are executed inside a transaction no locks are acquired. The following functions are available:</source>
          <target state="translated">모든 더티 함수 는 실패시 &lt;code&gt;exit({aborted, Reason})&lt;/code&gt; 호출을 실행합니다 . 트랜잭션 내에서 다음 기능이 실행 되더라도 잠금은 획득되지 않습니다. 사용 가능한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f81b19ae425dcfaf7c61e80cc7669618b08d52e7" translate="yes" xml:space="preserve">
          <source>All elements must be bound. Or match a binary:</source>
          <target state="translated">모든 요소는 바인딩되어야합니다. 또는 바이너리와 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="e35304a8cee7dd66deca414eafb00819e73f44e7" translate="yes" xml:space="preserve">
          <source>All encode functions assume that the &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; parameters point to a buffer large enough for the data. To get the size of an encoded term, without encoding it, pass &lt;code&gt;NULL&lt;/code&gt; instead of a buffer pointer. Parameter &lt;code&gt;index&lt;/code&gt; is incremented, but nothing will be encoded. This is the way in &lt;code&gt;ei&lt;/code&gt; to &quot;preflight&quot; term encoding.</source>
          <target state="translated">모든 인코딩 함수는 &lt;code&gt;buf&lt;/code&gt; 및 &lt;code&gt;index&lt;/code&gt; 매개 변수가 데이터에 충분한 버퍼를 가리키는 것으로 가정합니다 . 인코딩 된 용어의 크기를 인코딩하지 않고 가져 오려면 버퍼 포인터 대신 &lt;code&gt;NULL&lt;/code&gt; 을 전달하십시오 . 매개 변수 &lt;code&gt;index&lt;/code&gt; 은 증가하지만 아무것도 인코딩되지 않습니다. 이것은의 방법입니다 &lt;code&gt;ei&lt;/code&gt; &quot;프리 플라이트&quot;용어 인코딩.</target>
        </trans-unit>
        <trans-unit id="151ad8ec849846d67f11a6c9c136c41384a8ac5e" translate="yes" xml:space="preserve">
          <source>All event handler modules must have &lt;code&gt;gen_event&lt;/code&gt; behavior. These modules must be precompiled and their locations must be added explicitly to the Erlang code server search path (as in the previous example).</source>
          <target state="translated">모든 이벤트 핸들러 모듈에는 &lt;code&gt;gen_event&lt;/code&gt; 동작이 있어야합니다 . 이러한 모듈은 사전 컴파일되어야하며 해당 위치는 Erlang 코드 서버 검색 경로에 명시 적으로 추가해야합니다 (이전 예에서와 같이).</target>
        </trans-unit>
        <trans-unit id="9edf833c0b78d11f089bdd4ddb61ffd9bb5f9435" translate="yes" xml:space="preserve">
          <source>All event handlers added to the error logger must handle the following events. &lt;code&gt;Gleader&lt;/code&gt; is the group leader pid of the process that sent the event, and &lt;code&gt;Pid&lt;/code&gt; is the process that sent the event.</source>
          <target state="translated">오류 로거에 추가 된 모든 이벤트 핸들러는 다음 이벤트를 처리해야합니다. &lt;code&gt;Gleader&lt;/code&gt; 는 이벤트를 보낸 프로세스의 그룹 리더 pid이고 &lt;code&gt;Pid&lt;/code&gt; 는 이벤트를 보낸 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="97354d25fc5709fda87feb85d1e3e6ab6be22375" translate="yes" xml:space="preserve">
          <source>All events are filtered thru the collector filter, which optionally may transform or discard the event. The first call should use the pid of the collector process as report handle, while subsequent calls should use the table handle.</source>
          <target state="translated">모든 이벤트는 수집기 필터를 통해 필터링되며, 선택적으로 이벤트를 변환하거나 삭제할 수 있습니다. 첫 번째 호출은 콜렉터 프로세스의 pid를 보고서 핸들로 사용해야하며 후속 호출은 테이블 핸들을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="edda3d39980ef94b93836b935091c5b117c59583" translate="yes" xml:space="preserve">
          <source>All events stored with &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; are inserted to be processed before previously queued events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 로 저장된 모든 이벤트 는 이전에 대기중인 이벤트 전에 처리되도록 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3491bb0a7d4060188eb065fbc6bc2594ddbd17ff" translate="yes" xml:space="preserve">
          <source>All existing ports are traced.</source>
          <target state="translated">기존의 모든 포트가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="2c72dcc5bba29ea41d56cc0f3108b0b76f9c39f4" translate="yes" xml:space="preserve">
          <source>All existing processes and ports are traced.</source>
          <target state="translated">기존의 모든 프로세스 및 포트가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="5a4d069c79f3590b37639cb25e98cd7c35810632" translate="yes" xml:space="preserve">
          <source>All existing processes are traced.</source>
          <target state="translated">모든 기존 프로세스가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="5747d94a7ab87afa870a4b1a23637cb5fdeb263d" translate="yes" xml:space="preserve">
          <source>All exported functions &lt;code&gt;f/0&lt;/code&gt;, &lt;code&gt;f/1&lt;/code&gt; and so on are deprecated.</source>
          <target state="translated">내 보낸 모든 기능 &lt;code&gt;f/0&lt;/code&gt; , &lt;code&gt;f/1&lt;/code&gt; 등은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebe25266a3aaabe1092ea2284360d4d7880f5b5d" translate="yes" xml:space="preserve">
          <source>All exported functions in the module are deprecated and will eventually be removed.</source>
          <target state="translated">모듈에서 내 보낸 모든 함수는 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7d0101bf6297ebfbf7dbf99d16c4071d8e1de6f5" translate="yes" xml:space="preserve">
          <source>All exported functions in the module are deprecated. Equivalent to &lt;code&gt;-deprecated({'_','_'}).&lt;/code&gt;.</source>
          <target state="translated">모듈에서 내 보낸 모든 기능은 더 이상 사용되지 않습니다. 상당 &lt;code&gt;-deprecated({'_','_'}).&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a830cb4b996f3591a6f1ba33560d9c6eba657de5" translate="yes" xml:space="preserve">
          <source>All exported functions of the &lt;code&gt;digraph&lt;/code&gt; module used (in)directly by some function in &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">의 모든 수출 기능 &lt;code&gt;digraph&lt;/code&gt; 모듈은 직접 일부 기능으로 (에) 사용되는 &lt;code&gt;digraph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ffdac5fcbe59b543d6b023f7bcb7ab4d567156" translate="yes" xml:space="preserve">
          <source>All exported functions of the &lt;code&gt;xref&lt;/code&gt; module. The first operand of the intersection operator &lt;code&gt;*&lt;/code&gt; is implicitly converted to the more special type of the second operand.</source>
          <target state="translated">&lt;code&gt;xref&lt;/code&gt; 모듈 의 내 보낸 모든 기능 . 교차 연산자 &lt;code&gt;*&lt;/code&gt; 의 첫 번째 피연산자 는 내재적으로보다 특수한 유형의 두 번째 피연산자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="942827b9949c1750c953f7ebc266219ebc7cdd42" translate="yes" xml:space="preserve">
          <source>All external calls to local functions.</source>
          <target state="translated">로컬 함수에 대한 모든 외부 호출</target>
        </trans-unit>
        <trans-unit id="ce56e411c31ac7116e9fd3632deb508253a985ba" translate="yes" xml:space="preserve">
          <source>All files are compressed (as long as they pass the &lt;code&gt;uncompress&lt;/code&gt; condition).</source>
          <target state="translated">모든 파일은 압축 &lt;code&gt;uncompress&lt;/code&gt; 조건 을 통과하는 한 압축 됩니다.</target>
        </trans-unit>
        <trans-unit id="0489e9084611f97b451f50f894c7a01abd2cecc5" translate="yes" xml:space="preserve">
          <source>All files are searched for in the current path. It is assumed that the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.beam&lt;/code&gt; files for an application are located in the same directory. The &lt;code&gt;.erl&lt;/code&gt; files are also assumed to be located in this directory, unless it is an &lt;code&gt;ebin&lt;/code&gt; directory in which case they can be located in the corresponding &lt;code&gt;src&lt;/code&gt; directory.</source>
          <target state="translated">모든 파일은 현재 경로에서 검색됩니다. 응용 프로그램 의 &lt;code&gt;.app&lt;/code&gt; 및 &lt;code&gt;.beam&lt;/code&gt; 파일이 동일한 디렉토리에 있다고 가정합니다 . &lt;code&gt;.erl&lt;/code&gt; 그것이되지 않는 파일도이 디렉토리에있는 것으로 가정 &lt;code&gt;ebin&lt;/code&gt; 그들이 대응에 위치 할 수있는 경우 디렉토리 &lt;code&gt;src&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="8252fbc317a2198d72c5445b998e2855db44bf75" translate="yes" xml:space="preserve">
          <source>All filters (registered in a &lt;code&gt;Collector&lt;/code&gt; or in a &lt;code&gt;Viewer&lt;/code&gt;) must be able to handle an &lt;code&gt;Event record&lt;/code&gt; as input. The &lt;code&gt;Collector Filter&lt;/code&gt; (that is the filter named &lt;code&gt;all&lt;/code&gt;) is a little bit special, as its input also may be raw &lt;code&gt;Erlang Trace Data&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Collector&lt;/code&gt; 또는 &lt;code&gt;Viewer&lt;/code&gt; 에 등록 된 모든 필터 는 &lt;code&gt;Event record&lt;/code&gt; 를 입력 으로 처리 할 수 ​​있어야합니다 . &lt;code&gt;Collector Filter&lt;/code&gt; (필터이다라는 &lt;code&gt;all&lt;/code&gt; 입력도 원료로 할 수있다)는 약간 특별 &lt;code&gt;Erlang Trace Data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="422be21988c49192a9f5f28262b52e1e51a8fd90" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; and &lt;code&gt;xref_base&lt;/code&gt; to &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">모든 기능에서 호출 &lt;code&gt;xref&lt;/code&gt; 및 &lt;code&gt;xref_base&lt;/code&gt; 에 &lt;code&gt;lists&lt;/code&gt; 과 &lt;code&gt;digraph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9db576c6625a484a5d2e923a006859fafb0310a1" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; to &lt;code&gt;lists&lt;/code&gt;, and all function calls from &lt;code&gt;xref_base&lt;/code&gt; to &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">의 모든 함수 호출 &lt;code&gt;xref&lt;/code&gt; 에 대한 &lt;code&gt;lists&lt;/code&gt; 및 모든 함수 호출 &lt;code&gt;xref_base&lt;/code&gt; 에 &lt;code&gt;digraph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d129df75799c1b4bd0113f7d6ec3fb57b5027d20" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; to &lt;code&gt;xref_base&lt;/code&gt;.</source>
          <target state="translated">의 모든 함수 호출 &lt;code&gt;xref&lt;/code&gt; 할 &lt;code&gt;xref_base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca2ffb4856752604dde896ca6470b50c7619bd8" translate="yes" xml:space="preserve">
          <source>All functions can have an optional argument, which specifies a hook that is called if an attempt is made to print an unknown form.</source>
          <target state="translated">모든 함수는 옵션 인수를 가질 수 있는데,이 인수는 알 수없는 양식을 인쇄하려고 할 때 호출되는 후크를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="823a79f73d165ac889d6bd172b59abd37f41a632" translate="yes" xml:space="preserve">
          <source>All functions exported from this module can be used as primary or handler filters. See &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; for more information about how filters are added.</source>
          <target state="translated">이 모듈에서 내 보낸 모든 함수는 기본 또는 핸들러 필터로 사용할 수 있습니다. 참조 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 필터를 추가하는 방법에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec741d9917990170ff113c4353ac60a9452852b7" translate="yes" xml:space="preserve">
          <source>All functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if arguments are of wrong type, for example, queue arguments are not queues, indexes are not integers, and list arguments are not lists. Improper lists cause internal crashes. An index out of range for a queue also causes a failure with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">모든 기능은 이유와 함께 실패 &lt;code&gt;badarg&lt;/code&gt; 인수가 잘못된 형식의 경우 인덱스는 정수되지 않으며, 예를 들어, 큐의 인수가 큐하지 않은, 그리고리스트 인수 목록이 아니다. 부적절한 목록은 내부 충돌을 일으 킵니다. 큐의 범위를 벗어난 인덱스도 이유 &lt;code&gt;badarg&lt;/code&gt; 로 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="e43fac8a393e657d49457e2719a0083470b80dc0" translate="yes" xml:space="preserve">
          <source>All functions in all loaded modules.</source>
          <target state="translated">로드 된 모든 모듈의 모든 기능.</target>
        </trans-unit>
        <trans-unit id="ef103221583f1169bd63b6128675c2644466fb99" translate="yes" xml:space="preserve">
          <source>All functions in module &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;Module&lt;/code&gt; 의 모든 기능 .</target>
        </trans-unit>
        <trans-unit id="2466011b635e6de04d4ec84d7f837c33d888a271" translate="yes" xml:space="preserve">
          <source>All functions in module &lt;code&gt;seq_trace&lt;/code&gt;, except &lt;code&gt;set_system_tracer/1&lt;/code&gt;, can be used after the trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; 로 추적 포트를 시작한 후 &lt;code&gt;set_system_tracer/1&lt;/code&gt; 을 제외한 &lt;code&gt;seq_trace&lt;/code&gt; 모듈의 모든 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43c6b1b0a958a8deaa986884119e0ee53ee936a8" translate="yes" xml:space="preserve">
          <source>All functions in the driver takes a handle (returned from &lt;code&gt;start&lt;/code&gt;) that is just passed along by the Erlang process. This must in some way refer to the port driver instance.</source>
          <target state="translated">드라이버의 모든 함수 는 Erlang 프로세스에 의해 전달 된 핸들 ( &lt;code&gt;start&lt;/code&gt; 에서 리턴 됨 )을 사용합니다. 어떤 식 으로든 포트 드라이버 인스턴스를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6a9297c81dbe83f85ddbef20dc3f747dd1bff17" translate="yes" xml:space="preserve">
          <source>All functions in this Reference Manual can be used in any combination with queries using the list comprehension notation. For information about the query notation, see the &lt;code&gt;qlc&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">이 참조 설명서의 모든 기능은 목록 이해 표기법을 사용하는 쿼리와 조합하여 사용할 수 있습니다. 조회 표기법에 대한 정보 는 STDLIB 의 &lt;code&gt;qlc&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83563c273b58224103fb5b60259d697709cba0bd" translate="yes" xml:space="preserve">
          <source>All functions in this behavior must be implemented as NIFs. This limitation can be removed in a future releases. An &lt;code&gt;&lt;a href=&quot;#example&quot;&gt;example tracer module NIF&lt;/a&gt;&lt;/code&gt; implementation is provided at the end of this page.</source>
          <target state="translated">이 동작의 모든 함수는 NIF로 구현되어야합니다. 이 제한은 향후 릴리스에서 제거 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#example&quot;&gt;example tracer module NIF&lt;/a&gt;&lt;/code&gt; 구현이 페이지의 끝에 제공된다.</target>
        </trans-unit>
        <trans-unit id="5ba27ab55837d04a290469850ad1f69dc5566c5f" translate="yes" xml:space="preserve">
          <source>All functions in this module have an optional parameter &lt;code&gt;IoDevice&lt;/code&gt;. If included, it must be the pid of a process that handles the I/O protocols. Normally, it is the &lt;code&gt;IoDevice&lt;/code&gt; returned by &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 모든 기능에는 선택적 매개 변수 &lt;code&gt;IoDevice&lt;/code&gt; 가 있습니다. 포함 된 경우 I / O 프로토콜을 처리하는 프로세스의 pid 여야합니다. 일반적으로 &lt;code&gt;file:open/2&lt;/code&gt; 에서 반환 한 &lt;code&gt;IoDevice&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="726200fe284b64e025780d2f8b454ec9973f6634" translate="yes" xml:space="preserve">
          <source>All functions of any arity named &lt;code&gt;Function&lt;/code&gt; in module &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">모든 인수에 대응라는 이름의 모든 기능 &lt;code&gt;Function&lt;/code&gt; 모듈의 &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45f048113d0373b3ce22b0d7dd55cfb45f73d15" translate="yes" xml:space="preserve">
          <source>All functions of the &lt;code&gt;xref&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;xref&lt;/code&gt; 모듈 의 모든 기능 .</target>
        </trans-unit>
        <trans-unit id="eba6863daa045e951bded6ccc11181d5402b27a1" translate="yes" xml:space="preserve">
          <source>All functions return &lt;code&gt;0&lt;/code&gt; if successful, otherwise &lt;code&gt;-1&lt;/code&gt; (for example, if a term is not of the expected type, or the data to decode is an invalid Erlang term).</source>
          <target state="translated">모든 함수 가 성공하면 &lt;code&gt;0&lt;/code&gt; 을 , 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 (예를 들어, 용어가 예상 유형이 아니거나 디코딩 할 데이터가 유효하지 않은 Erlang 용어 인 경우).</target>
        </trans-unit>
        <trans-unit id="f5bc6aaf22245be7eb164a817018deef6e568078" translate="yes" xml:space="preserve">
          <source>All functions take two parameters:</source>
          <target state="translated">모든 기능에는 두 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="956ed5e678dd45f2252e7ddbe4d7c18199877e4b" translate="yes" xml:space="preserve">
          <source>All functions that a driver needs to do with Erlang are performed through driver API functions. Functions exist for the following functionality:</source>
          <target state="translated">드라이버가 Erlang과 관련된 모든 기능은 드라이버 API 기능을 통해 수행됩니다. 다음 기능에 대한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="060ec634508a875eb366a978194bdb8554c750a9" translate="yes" xml:space="preserve">
          <source>All functions with a &lt;code&gt;FuncCallCount&lt;/code&gt; lower than &lt;code&gt;Limit&lt;/code&gt; are excluded from &lt;code&gt;FuncAnalysisList&lt;/code&gt;. They are still included in &lt;code&gt;ModCallCount&lt;/code&gt;, though. The default value for &lt;code&gt;Limit&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FuncCallCount&lt;/code&gt; 가 &lt;code&gt;Limit&lt;/code&gt; 보다 낮은 모든 함수 는 &lt;code&gt;FuncAnalysisList&lt;/code&gt; 에서 제외됩니다 . 그러나 여전히 &lt;code&gt;ModCallCount&lt;/code&gt; 에 포함되어 있습니다 . &lt;code&gt;Limit&lt;/code&gt; 의 기본값 은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="046534351d00f7cf7cc373a50278b04994192a3a" translate="yes" xml:space="preserve">
          <source>All initialization, including name registration, is done in &lt;code&gt;init&lt;/code&gt;. The new process must also acknowledge that it has been started to the parent:</source>
          <target state="translated">이름 등록을 포함한 모든 초기화는 &lt;code&gt;init&lt;/code&gt; 에서 수행됩니다 . 새로운 프로세스는 부모 프로세스가 시작되었음을 인정해야합니다.</target>
        </trans-unit>
        <trans-unit id="46cda0f29f9968b1b8eac1178e9399bb98ac0756" translate="yes" xml:space="preserve">
          <source>All interaction between NIF code and the Erlang runtime system is performed by calling NIF API functions. Functions exist for the following functionality:</source>
          <target state="translated">NIF 코드와 Erlang 런타임 시스템 간의 모든 상호 작용은 NIF API 함수를 호출하여 수행됩니다. 다음 기능에 대한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8bf9347aac7d69c1a7c4192dd20e3c477cd2eef" translate="yes" xml:space="preserve">
          <source>All involved nodes must agree on the global group definition, otherwise the behavior of the system is undefined.</source>
          <target state="translated">관련된 모든 노드는 글로벌 그룹 정의에 동의해야합니다. 그렇지 않으면 시스템의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ddeb2fa9e303d6ec0189514f0afae8c313983ca" translate="yes" xml:space="preserve">
          <source>All involved nodes must have the same value for &lt;code&gt;distributed&lt;/code&gt; and &lt;code&gt;sync_nodes_timeout&lt;/code&gt;. Otherwise the system behaviour is undefined.</source>
          <target state="translated">모든 관련 노드는 &lt;code&gt;distributed&lt;/code&gt; 및 &lt;code&gt;sync_nodes_timeout&lt;/code&gt; 에 대해 동일한 값을 가져야 합니다. 그렇지 않으면 시스템 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc6547cbb70d26e829dedc7fc557e10f893223e6" translate="yes" xml:space="preserve">
          <source>All items in &lt;code&gt;Options&lt;/code&gt; that are not make options are assumed to be compiler options and are passed as-is to &lt;code&gt;compile:file/2&lt;/code&gt;. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 이 아닌 옵션의 모든 항목은 컴파일러 옵션으로 간주되며 &lt;code&gt;compile:file/2&lt;/code&gt; 로 그대로 전달됩니다 . &lt;code&gt;Options&lt;/code&gt; 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a74854341f74c068c82ad0a8f0663aa4e14988f" translate="yes" xml:space="preserve">
          <source>All jobs that do not use standard I/O run in the normal way.</source>
          <target state="translated">표준 I / O를 사용하지 않는 모든 작업은 정상적인 방식으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1865391b0c3e8e089483ce4975e720c45e5a9c41" translate="yes" xml:space="preserve">
          <source>All keys and values in the map are terms. Any expression is first evaluated and then the resulting terms are used as &lt;strong&gt;key&lt;/strong&gt; and &lt;strong&gt;value&lt;/strong&gt; respectively.</source>
          <target state="translated">지도의 모든 키와 값은 용어입니다. 모든 표현식을 먼저 평가 한 다음 결과 항을 각각 &lt;strong&gt;키&lt;/strong&gt; 와 &lt;strong&gt;값으로&lt;/strong&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b9288c9e5c221796e80a2e7498e046ec5f58a8b5" translate="yes" xml:space="preserve">
          <source>All keys and values must belong to &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">모든 키와 값은 &lt;code&gt;env&lt;/code&gt; 에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3aae0ef6a36eb4138caa9b3ee5995eea319883b4" translate="yes" xml:space="preserve">
          <source>All list expressions are evaluated. If a cursor has been created, evaluation takes place in the cursor process. For list expressions that are QLCs, the list expressions of the generators of the QLCs are evaluated as well. Be careful if list expressions have side effects, as list expressions are evaluated in unspecified order.</source>
          <target state="translated">모든 목록 표현식이 평가됩니다. 커서가 작성된 경우 커서 프로세스에서 평가가 수행됩니다. QLC 인 목록 표현식의 경우 QLC 생성기의 목록 표현식도 평가됩니다. 목록 표현식은 지정되지 않은 순서로 평가되므로 목록 표현식에 부작용이있는 경우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="ea62e05bff6ced6fe4f7db7a70fe5d182215dc60" translate="yes" xml:space="preserve">
          <source>All lists of identifiers must produce the same number of identifiers.</source>
          <target state="translated">모든 식별자 목록은 동일한 수의 식별자를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="831a903ff3acb3a95d91bc2244d77f78dbc1b105" translate="yes" xml:space="preserve">
          <source>All locks are continuously monitored and its statistics updated. Use &lt;code&gt;lcnt:clear/0&lt;/code&gt; to initially clear all counters before running any specific tests. This command will also reset the duration timer internally.</source>
          <target state="translated">모든 잠금이 지속적으로 모니터링되고 통계가 업데이트됩니다. 특정 테스트를 실행하기 전에 처음으로 모든 카운터를 &lt;code&gt;lcnt:clear/0&lt;/code&gt; 을 사용하십시오 . 이 명령은 또한 지속 시간 타이머를 내부적으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9cd647737f1c87ee7c161c5ee26fe910048843cf" translate="yes" xml:space="preserve">
          <source>All logical drives of type &quot;FIXED_DISK&quot; are checked.</source>
          <target state="translated">&quot;FIXED_DISK&quot;유형의 모든 논리 드라이브가 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="d4db0be4b4b4c802ce985caea6e5dff7b25d978f" translate="yes" xml:space="preserve">
          <source>All macro names generated by the compiler are prefixed with &lt;code&gt;Prefix&lt;/code&gt;. This is useful when multiple protocols that contain macros with identical names are included in a single module.</source>
          <target state="translated">컴파일러에 의해 생성 된 모든 매크로 이름은 접두어 &lt;code&gt;Prefix&lt;/code&gt; . 동일한 이름의 매크로를 포함하는 여러 프로토콜이 단일 모듈에 포함 된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="494705700ec0edc0b3e9bd3d1008f1481b1665ee" translate="yes" xml:space="preserve">
          <source>All macros expand to a call to Logger, where &lt;code&gt;Level&lt;/code&gt; is taken from the macro name, and location data is added to the metadata. See the description of the &lt;code&gt;&lt;a href=&quot;#type-metadata&quot;&gt;metadata()&lt;/a&gt;&lt;/code&gt; type for more information about the location data.</source>
          <target state="translated">모든 매크로는 로거 호출로 확장되며, 여기서 매크로 이름에서 &lt;code&gt;Level&lt;/code&gt; 을 가져오고 위치 데이터가 메타 데이터에 추가됩니다. 위치 데이터에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-metadata&quot;&gt;metadata()&lt;/a&gt;&lt;/code&gt; 유형에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0c8d5eebae1c81c9d4cc44fa89d86c186216006" translate="yes" xml:space="preserve">
          <source>All memory sizes are presented as number of &lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">모든 메모리 크기는 &lt;strong&gt;바이트&lt;/strong&gt; 수로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c95b69f492d38b3c97ab065a21ebadda9800ddeb" translate="yes" xml:space="preserve">
          <source>All messages in the message queue will eventually be placed on heap. They can however temporarily be stored off heap. This is how messages always have been stored up until ERTS 8.0.</source>
          <target state="translated">메시지 큐의 모든 메시지는 결국 힙에 배치됩니다. 그러나 일시적으로 힙에서 저장 될 수 있습니다. ERTS 8.0까지 메시지가 항상 저장된 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f77aafd15225e94bc1f5d8df9caf3f4c48675dfa" translate="yes" xml:space="preserve">
          <source>All messages sent over the transport interface are of the form &lt;code&gt;{diameter, term()}&lt;/code&gt;.</source>
          <target state="translated">전송 인터페이스를 통해 전송 된 모든 메시지는 &lt;code&gt;{diameter, term()}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9fadb6f85546bb42570866cced284af7083a859" translate="yes" xml:space="preserve">
          <source>All modules introduced by this application. &lt;code&gt;systools&lt;/code&gt; uses this list when generating start scripts and tar files. A module can only be defined in one application.</source>
          <target state="translated">이 응용 프로그램에서 소개 된 모든 모듈. &lt;code&gt;systools&lt;/code&gt; 는 시작 스크립트 및 tar 파일을 생성 할 때이 목록을 사용합니다. 모듈은 하나의 응용 프로그램에서만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81023ab4e25ef6717f23395a1aedb12fb5ddbc7" translate="yes" xml:space="preserve">
          <source>All modules of the Tools application.</source>
          <target state="translated">도구 애플리케이션의 모든 모듈.</target>
        </trans-unit>
        <trans-unit id="429cfbd4010cf55e09670589087f82f8687b863b" translate="yes" xml:space="preserve">
          <source>All modules with a name beginning with &lt;code&gt;xref_&lt;/code&gt;.</source>
          <target state="translated">이름이로 시작하는 모든 모듈 &lt;code&gt;xref_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8fe3d0304a41f7579b1ba411ab3df7b0920caa7" translate="yes" xml:space="preserve">
          <source>All names of registered processes started in this application. &lt;code&gt;systools&lt;/code&gt; uses this list to detect name clashes between different applications.</source>
          <target state="translated">등록 된 프로세스의 모든 이름이이 응용 프로그램에서 시작되었습니다. &lt;code&gt;systools&lt;/code&gt; 는이 목록을 사용하여 다른 응용 프로그램 사이의 이름 충돌을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="63603405883458e08fdb5a997ded4a3cb73fef22" translate="yes" xml:space="preserve">
          <source>All nitty gritty details of the event.</source>
          <target state="translated">이벤트의 모든 중요한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="8955d624f919ff35c5d686d0dd52b90c5392d816" translate="yes" xml:space="preserve">
          <source>All nodes added with &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; will be affected by this call, and if Module is not &lt;code&gt;'_'&lt;/code&gt; the module will be loaded on all nodes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 로 추가 된 모든 노드 는이 호출의 영향을 받고 모듈이 &lt;code&gt;'_'&lt;/code&gt; 이 아닌 경우 모듈은 모든 노드에로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c596dc51ad6ac7a667444d4ab6da510586b442cc" translate="yes" xml:space="preserve">
          <source>All nodes added with &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; will be affected by this call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 로 추가 된 모든 노드 는이 호출의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="d9448e54ad1639a4fc81a3d2181edf3fa2a36dab" translate="yes" xml:space="preserve">
          <source>All nodes connected to this node.</source>
          <target state="translated">이 노드에 연결된 모든 노드</target>
        </trans-unit>
        <trans-unit id="c16d866482510d3df4a4d9c10e80cfd8693ce976" translate="yes" xml:space="preserve">
          <source>All of these MIBs should be loaded into the Master Agent. Once loaded, these MIBs are always available in all contexts.</source>
          <target state="translated">이러한 모든 MIB는 마스터 에이전트에로드되어야합니다. 일단로드되면이 MIB는 항상 모든 컨텍스트에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5404924b8d62bd94a8e2b48b441dd9ef3bb2c473" translate="yes" xml:space="preserve">
          <source>All of these can be used in guards. Now for some BIFs that cannot be used in guards:</source>
          <target state="translated">이들 모두는 경비원에서 사용될 수 있습니다. 가드에서 사용할 수없는 일부 BIF의 경우 :</target>
        </trans-unit>
        <trans-unit id="50f0e79a9827c7185eb8a799e8536a39c5dbce1a" translate="yes" xml:space="preserve">
          <source>All open tables must be closed before the system is stopped. If an attempt is made to open a table that is not properly closed, Dets automatically tries to repair it.</source>
          <target state="translated">시스템을 중지하기 전에 열려있는 모든 테이블을 닫아야합니다. 제대로 닫히지 않은 테이블을 열려고 시도하면 Dets는 자동으로 테이블 복구를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9366c0e819489e6627469b740a2d8b3479faca40" translate="yes" xml:space="preserve">
          <source>All operations has an amortized O(1) running time, except &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;filter/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#len-1&quot;&gt;len/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#member-2&quot;&gt;member/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-2&quot;&gt;split/2&lt;/a&gt;&lt;/code&gt; that have O(n). To minimize the size of a queue minimizing the amount of garbage built by queue operations, the queues do not contain explicit length information, and that is why &lt;code&gt;len/1&lt;/code&gt; is O(n). If better performance for this particular operation is essential, it is easy for the caller to keep track of the length.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;filter/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#len-1&quot;&gt;len/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#member-2&quot;&gt;member/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#split-2&quot;&gt;split/2&lt;/a&gt;&lt;/code&gt; 을 제외한 모든 연산에는 O (n) 실행 시간 이 있습니다. 큐 조작으로 빌드 된 가비지 양을 최소화하는 큐 크기를 최소화하기 위해 큐에는 명시적인 길이 정보가 포함되지 않으므로 &lt;code&gt;len/1&lt;/code&gt; 이 O (n)입니다. 이 특정 작업에 대한 더 나은 성능이 필요한 경우 발신자가 길이를 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb3faf2c2244b5d385e1264229f20eef126b3f8" translate="yes" xml:space="preserve">
          <source>All operations on applications are coordinated by the application controller. It is interacted through the functions in the module &lt;code&gt;application&lt;/code&gt;, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel. In particular, applications can be loaded, unloaded, started, and stopped.</source>
          <target state="translated">응용 프로그램의 모든 작업은 응용 프로그램 컨트롤러에 의해 조정됩니다. 모듈 &lt;code&gt;application&lt;/code&gt; 의 기능을 통해 상호 작용합니다 . 커널 의 &lt;code&gt;application(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오. 특히 응용 프로그램을로드, 언로드, 시작 및 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a155092927253ab8adb73277ff15a9389de0ffb" translate="yes" xml:space="preserve">
          <source>All operations that can be performed on &lt;code&gt;dets&lt;/code&gt; files can also be performed on the &lt;code&gt;Mnesia&lt;/code&gt; data files. For example, &lt;code&gt;dets&lt;/code&gt; contains the function &lt;code&gt;dets:traverse/2&lt;/code&gt;, which can be used to view the contents of a &lt;code&gt;Mnesia&lt;/code&gt;&lt;code&gt;DAT&lt;/code&gt; file. However, this can only be done when &lt;code&gt;Mnesia&lt;/code&gt; is not running. So, to view the schema file, do as follows;</source>
          <target state="translated">&lt;code&gt;dets&lt;/code&gt; 파일에서 수행 할 수있는 모든 작업 은 &lt;code&gt;Mnesia&lt;/code&gt; 데이터 파일 에서도 수행 할 수 있습니다 . 예를 들어, &lt;code&gt;dets&lt;/code&gt; 에는 &lt;code&gt;dets:traverse/2&lt;/code&gt; 기능이 포함되어 있으며 &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;DAT&lt;/code&gt; 파일 의 내용을 보는 데 사용할 수 있습니다 . 그러나 이것은 &lt;code&gt;Mnesia&lt;/code&gt; 가 실행되고 있지 않을 때만 수행 할 수 있습니다 . 따라서 스키마 파일을 보려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="7944ca23e769d63791bf6d56110b8504cc650e69" translate="yes" xml:space="preserve">
          <source>All options &lt;code&gt;Opt&lt;/code&gt; are set on the socket before the association is attempted. If an option record has undefined field values, the options record is first read from the socket for those values. In effect, &lt;code&gt;Opt&lt;/code&gt; option records only define field values to change before connecting.</source>
          <target state="translated">모든 옵션 &lt;code&gt;Opt&lt;/code&gt; 는 연결을 시도하기 전에 소켓에서 설정됩니다. 옵션 레코드에 정의되지 않은 필드 값이있는 경우 해당 값에 대한 옵션 레코드를 먼저 소켓에서 읽습니다. 실제로 &lt;code&gt;Opt&lt;/code&gt; 옵션 레코드는 연결하기 전에 변경할 필드 값만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="717f82077e05a6bd5c4e1f6ec9f053ccca43eecd" translate="yes" xml:space="preserve">
          <source>All options has default values.</source>
          <target state="translated">모든 옵션에는 기본값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="df6d621c39e158f12320b634e0dfbb13f7f0a03f" translate="yes" xml:space="preserve">
          <source>All options, except the include path (&lt;code&gt;{i,Dir}&lt;/code&gt;), can also be given in the file with attribute &lt;code&gt;-compile([Option,...])&lt;/code&gt;. Attribute &lt;code&gt;-compile()&lt;/code&gt; is allowed after the function definitions.</source>
          <target state="translated">포함 경로 ( &lt;code&gt;{i,Dir}&lt;/code&gt; )를 제외한 모든 옵션 은 속성 &lt;code&gt;-compile([Option,...])&lt;/code&gt; 을 사용하여 파일에 제공 될 수도 있습니다 . &lt;code&gt;-compile()&lt;/code&gt; 속성 은 함수 정의 후에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3262efdb0e0795ddd30e0491c99cd9db2b1217ce" translate="yes" xml:space="preserve">
          <source>All other error codes are to be translated by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. Notice that calls to &lt;code&gt;format_error&lt;/code&gt; are to be performed from the same running instance of the Erlang virtual machine as the error is detected in, because of system-dependent behavior concerning error values.</source>
          <target state="translated">다른 모든 오류 코드는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수로 변환됩니다 . 오류 값과 관련된 시스템 종속 동작으로 인해 &lt;code&gt;format_error&lt;/code&gt; 에 대한 호출 은 오류가 감지 된 것과 동일한 Erlang 가상 머신 인스턴스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5f6a14eeedaaeb7e6254232d3638d6dc2f6e8555" translate="yes" xml:space="preserve">
          <source>All other funs are called &lt;strong&gt;local&lt;/strong&gt;. When a local fun is called, the same version of the code that created the fun is called (even if a newer version of the module has been loaded).</source>
          <target state="translated">다른 모든 재미는 &lt;strong&gt;지역&lt;/strong&gt; 이라고 합니다. 로컬 재미가 호출되면 재미를 만든 동일한 버전의 코드가 호출됩니다 (최신 버전의 모듈이로드 된 경우에도).</target>
        </trans-unit>
        <trans-unit id="8838f7dce02b840a82ef3664122b2c9a0564b86c" translate="yes" xml:space="preserve">
          <source>All other options are directly passed to &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; or ignored if a connection is already provided.</source>
          <target state="translated">다른 모든 옵션은 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; 로 직접 전달 되거나 연결이 이미 제공된 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0fdd5012a3999f248928e35df9097ed59369e26c" translate="yes" xml:space="preserve">
          <source>All other tables that refer to this table in their foreign key</source>
          <target state="translated">외래 키에서이 테이블을 참조하는 다른 모든 테이블</target>
        </trans-unit>
        <trans-unit id="7bef1fa75d2399a77a342855446a7b8e1b60ed9b" translate="yes" xml:space="preserve">
          <source>All paragraphs up to the next process header only concerns function calls within this process.</source>
          <target state="translated">다음 프로세스 헤더까지의 모든 단락은이 프로세스 내의 함수 호출에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="a921a840e963ba360d450906acb47195c661a0fd" translate="yes" xml:space="preserve">
          <source>All parts returned as binaries.</source>
          <target state="translated">모든 부품이 이진으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21e943024f0cf28dbeb8a994a76fa77df65f90d8" translate="yes" xml:space="preserve">
          <source>All parts returned as lists of characters (&quot;strings&quot;).</source>
          <target state="translated">모든 부분은 문자 목록 ( &quot;문자열&quot;)으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eacdc8b4f05f878b8de176b164d8e1333a39ed8a" translate="yes" xml:space="preserve">
          <source>All patterns must be matched in a sequence. A match is not concluded until all patterns are matched. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="translated">모든 패턴은 순서대로 일치해야합니다. 모든 패턴이 일치 할 때까지 일치가 완료되지 않습니다. 이 옵션은 하나 이상의 &lt;code&gt;HaltPatterns&lt;/code&gt; 에 의해 중단 될 수 있습니다 . &lt;code&gt;MatchList&lt;/code&gt; 은 항상의 목록, 즉, 리턴 &lt;code&gt;Match&lt;/code&gt; 대신 하나의 &lt;code&gt;Match&lt;/code&gt; . 또한 &lt;code&gt;HaltReason&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fe1686901bbde4606445ec2f94e1d9d4f885ae9d" translate="yes" xml:space="preserve">
          <source>All ports created after the call is are to be traced.</source>
          <target state="translated">호출 후 생성 된 모든 포트가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="f925b88f64b63747ed903430e90112298afb46f9" translate="yes" xml:space="preserve">
          <source>All ports in the system as well as all ports created hereafter are to be traced.</source>
          <target state="translated">시스템의 모든 포트와 이후에 생성 된 모든 포트가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="17489271f7d94016b64b27eb715c1631842f0ea9" translate="yes" xml:space="preserve">
          <source>All ports that will be created in the future.</source>
          <target state="translated">향후에 생성 될 모든 포트.</target>
        </trans-unit>
        <trans-unit id="76ff66e92ea2da8c3fa29ddd1a6eef5dcf62d533" translate="yes" xml:space="preserve">
          <source>All pre hooks, except &lt;code&gt;pre_end_per_testcase/4&lt;/code&gt;, can skip or fail the test by returning a tuple with &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;fail&lt;/code&gt;, and a reason as the result.</source>
          <target state="translated">&lt;code&gt;pre_end_per_testcase/4&lt;/code&gt; 를 제외한 모든 사전 후크 는 skip 또는 fail과 함께 튜플을 반환하여 테스트를 &lt;code&gt;skip&lt;/code&gt; 거나 &lt;code&gt;fail&lt;/code&gt; 있으며 그 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c675952980c889f0d89ff8e73fd8703b823a9ed6" translate="yes" xml:space="preserve">
          <source>All printable Unicode characters are considered when determining if a list of integers is to be displayed in string syntax. This can give unexpected results if, for example, your font does not cover all Unicode characters.</source>
          <target state="translated">정수 목록을 문자열 구문으로 표시할지 여부를 결정할 때 인쇄 가능한 모든 유니 코드 문자가 고려됩니다. 예를 들어 글꼴이 모든 유니 코드 문자를 포함하지 않는 경우 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b7ed40b3a03fdb7bdd0b017e905acbe12c81905" translate="yes" xml:space="preserve">
          <source>All processes and ports created after the call is are to be traced.</source>
          <target state="translated">호출 후 생성 된 모든 프로세스와 포트는 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9536dced588a5adfc7f095f97a48ee12e811ce" translate="yes" xml:space="preserve">
          <source>All processes and ports in the system as well as all processes and ports created hereafter are to be traced.</source>
          <target state="translated">이후에 생성 된 모든 프로세스와 포트뿐만 아니라 시스템의 모든 프로세스와 포트가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="02ef48a5ab6a5d0ee8466733327d3e4350edfd7d" translate="yes" xml:space="preserve">
          <source>All processes and ports that will be created in the future.</source>
          <target state="translated">향후에 생성 될 모든 프로세스 및 포트.</target>
        </trans-unit>
        <trans-unit id="d9be8009e2c7f6a938c6f743db853b2dfb9ccf36" translate="yes" xml:space="preserve">
          <source>All processes created after the call is are to be traced.</source>
          <target state="translated">호출 후 작성된 모든 프로세스가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="058932c80ec58afa4c752d8e488f1fd07db947f7" translate="yes" xml:space="preserve">
          <source>All processes executing code in interpreted modules are displayed in the Monitor window.</source>
          <target state="translated">해석 된 모듈에서 코드를 실행하는 모든 프로세스가 모니터 창에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="974deb8f031d33a6740c7ebe7532a4266b1e29c9" translate="yes" xml:space="preserve">
          <source>All processes in the system as well as all processes created hereafter are to be traced.</source>
          <target state="translated">시스템의 모든 프로세스와 이후에 생성 된 모든 프로세스가 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="263aac7a2b0fbff02edd125aaea0db769c21d0fa" translate="yes" xml:space="preserve">
          <source>All processes that will be created in the future.</source>
          <target state="translated">향후에 생성 될 모든 프로세스.</target>
        </trans-unit>
        <trans-unit id="b62c900a4023fa86a2240db1615b7f1efe40eb78" translate="yes" xml:space="preserve">
          <source>All programs accessing the database through the transaction system can be written as if they had sole access to the data. This is a desirable property, as all synchronization is taken care of by the transaction handler. If a program reads or writes data, the system ensures that no other program tries to manipulate the same data at the same time.</source>
          <target state="translated">트랜잭션 시스템을 통해 데이터베이스에 액세스하는 모든 프로그램은 마치 데이터에 단독으로 액세스하는 것처럼 쓸 수 있습니다. 모든 동기화가 트랜잭션 핸들러에 의해 처리되므로 이는 바람직한 특성입니다. 프로그램이 데이터를 읽거나 쓰는 경우 시스템은 다른 프로그램이 동일한 데이터를 동시에 조작하려고하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="17a5433d9d8b1ba8d9bee65a3013cbeaf6dd7b31" translate="yes" xml:space="preserve">
          <source>All record names generated by the compiler are prefixed with &lt;code&gt;Prefix&lt;/code&gt;. This is useful when multiple protocols that contain records with identical names are included in a single module.</source>
          <target state="translated">컴파일러에 의해 생성 된 모든 기록 이름은 접두어 &lt;code&gt;Prefix&lt;/code&gt; . 동일한 이름의 레코드를 포함하는 여러 프로토콜이 단일 모듈에 포함 된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="979b4a0590268416125e90127fc8bfa28240add9" translate="yes" xml:space="preserve">
          <source>All records used in this Reference Manual are generated from ASN.1 specifications and are documented in the User's Guide. See &lt;code&gt;&lt;a href=&quot;public_key_records&quot;&gt;Public-key Records&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 참조 매뉴얼에 사용 된 모든 레코드는 ASN.1 사양에서 생성되며 사용 설명서에 문서화되어 있습니다. &lt;code&gt;&lt;a href=&quot;public_key_records&quot;&gt;Public-key Records&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ac9354c0bfca95837d962e8ba1466208a9c37ae" translate="yes" xml:space="preserve">
          <source>All references to this node can then use the node name. For example, a file over FTP is fetched like follows:</source>
          <target state="translated">이 노드에 대한 모든 참조는 노드 이름을 사용할 수 있습니다. 예를 들어 FTP를 통한 파일은 다음과 같이 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9078a5064d8a2d7b1b465df78627e79bf9b494a4" translate="yes" xml:space="preserve">
          <source>All replicas are &lt;code&gt;ram_copies&lt;/code&gt;.</source>
          <target state="translated">모든 복제본은 &lt;code&gt;ram_copies&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02e9fe7f27cf72b855151f6db9301e6668c3912f" translate="yes" xml:space="preserve">
          <source>All reports containing a common pattern can be shown. Suppose a process crashes because it tries to call a non-existing function &lt;code&gt;release_handler:mbj_func/1&lt;/code&gt;. The reports can then be shown as follows:</source>
          <target state="translated">공통 패턴이 포함 된 모든 보고서를 표시 할 수 있습니다. 존재하지 않는 함수 &lt;code&gt;release_handler:mbj_func/1&lt;/code&gt; 을 호출하려고하기 때문에 프로세스가 충돌한다고 가정하십시오 . 그런 다음 보고서를 다음과 같이 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d223dc7b2bab3d6a8406ce4cb25c92a16820e095" translate="yes" xml:space="preserve">
          <source>All reports matching the regular expression &lt;code&gt;RegExp&lt;/code&gt; are displayed. &lt;code&gt;RegExp&lt;/code&gt; can be any of the following:</source>
          <target state="translated">정규식 &lt;code&gt;RegExp&lt;/code&gt; 와 일치하는 모든 보고서 가 표시됩니다. &lt;code&gt;RegExp&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feccd905133ca27d919366e9013d126e914e1433" translate="yes" xml:space="preserve">
          <source>All request made by the client to the connection are synchronous. If the timeout is used and expires the client process will exit with reason timeout. Proably the right thing to do is let the client die and perhaps be restarted by its supervisor. But if the client chooses to catch this timeout, it is a good idea to wait a little while before trying again. If there are too many consecutive timeouts that are caught the connection process will conclude that there is something radically wrong and terminate the connection.</source>
          <target state="translated">연결에 대한 클라이언트의 모든 요청은 동 기적입니다. 시간 초과가 사용되고 만료되면 클라이언트 프로세스는 이유 시간 초과와 함께 종료됩니다. 아마도 옳은 일은 클라이언트가 죽게하고 감독자가 다시 시작하게하는 것입니다. 그러나 클라이언트가이 시간 초과를 잡기로 선택한 경우 잠시 기다렸다가 다시 시도하는 것이 좋습니다. 연속 된 시간 초과가 너무 많으면 연결 프로세스에서 근본적으로 잘못된 것이 있다고 판단하고 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="032cbcc0d828f70779b0c0ed0bc3facdb5203770" translate="yes" xml:space="preserve">
          <source>All resource objects are created as instances of some &lt;strong&gt;resource type&lt;/strong&gt;. This makes resources from different modules to be distinguishable. A resource type is created by calling &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type&quot;&gt;enif_open_resource_type&lt;/a&gt;&lt;/code&gt; when a library is loaded. Objects of that resource type can then later be allocated and &lt;code&gt;enif_get_resource&lt;/code&gt; verifies that the resource is of the expected type. A resource type can have a user-supplied destructor function, which is automatically called when resources of that type are released (by either the garbage collector or &lt;code&gt;enif_release_resource&lt;/code&gt;). Resource types are uniquely identified by a supplied name string and the name of the implementing module.</source>
          <target state="translated">모든 자원 오브젝트는 일부 &lt;strong&gt;자원 유형의&lt;/strong&gt; 인스턴스로 작성됩니다 . 이를 통해 다른 모듈의 리소스를 구별 할 수 있습니다. 라이브러리가로드 될 때 &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type&quot;&gt;enif_open_resource_type&lt;/a&gt;&lt;/code&gt; 을 호출하여 자원 유형이 작성됩니다 . 그런 다음 해당 자원 유형의 객체를 나중에 할당 할 수 있으며 &lt;code&gt;enif_get_resource&lt;/code&gt; 는 자원이 예상 유형 인지 확인합니다. 자원 유형은 사용자 제공 소멸자 함수를 가질 수 있으며, 이는 해당 유형의 자원이 해제 될 때 자동으로 호출됩니다 (가비지 콜렉터 또는 &lt;code&gt;enif_release_resource&lt;/code&gt; 중 하나에 의해 ). 자원 유형은 제공된 이름 문자열과 구현 모듈의 이름으로 고유하게 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="8b7a4f2a8dc320cacf959f8d17456e7115df6332" translate="yes" xml:space="preserve">
          <source>All runtime dependencies specified in OTP applications during the OTP 17 release may not be completely correct. This is actively being worked on. Declared runtime dependencies in OTP applications are expected to be correct in OTP 18.</source>
          <target state="translated">OTP 17 릴리스 중 OTP 애플리케이션에 지정된 모든 런타임 종속성이 완전히 올바르지 않을 수 있습니다. 이것은 활발히 진행되고 있습니다. OTP 응용 프로그램의 선언 된 런타임 종속성은 OTP 18에서 올바른 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8d4e91d8f62a7df11a977cb27005070535f221fd" translate="yes" xml:space="preserve">
          <source>All sections are returned even if they do not exist in the escript. If a particular section happens to have the same value as the default value, the extracted value is set to the atom &lt;code&gt;default&lt;/code&gt;. If a section is missing, the extracted value is set to the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">escript에 존재하지 않더라도 모든 섹션이 리턴됩니다. 특정 섹션이 기본값과 동일한 값을 갖는 경우 추출 된 값은 원자 &lt;code&gt;default&lt;/code&gt; 설정됩니다 . 섹션이 누락되면 추출 된 값이 원자 &lt;code&gt;undefined&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="93c2177455dcce657afa2684588a0241cb58b085" translate="yes" xml:space="preserve">
          <source>All sizes are in words.</source>
          <target state="translated">모든 크기는 단어입니다.</target>
        </trans-unit>
        <trans-unit id="816578661858d321b1e0e5d92462cad1bde0c144" translate="yes" xml:space="preserve">
          <source>All source directories identified by &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; should contain build results of OTP applications.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 로 식별 된 모든 소스 디렉토리 에는 OTP 응용 프로그램의 빌드 결과가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="279a723e274bbdf44bf4e5f4cdb64a6e1d7b0708" translate="yes" xml:space="preserve">
          <source>All strongly connected components of the Inter Call Graph. Each component is a set of exported or unused local functions that call each other (in)directly.</source>
          <target state="translated">인터 콜 그래프의 모든 강력하게 연결된 구성 요소. 각 구성 요소는 서로 직접 호출하는 내보내거나 사용하지 않는 로컬 함수 집합입니다.</target>
        </trans-unit>
        <trans-unit id="ce9911ac68b49180cc63944c113ff7ba4d2e2e06" translate="yes" xml:space="preserve">
          <source>All subexpressions are evaluated before an expression itself is evaluated, unless explicitly stated otherwise. For example, consider the expression:</source>
          <target state="translated">명시 적으로 다르게 명시되지 않는 한 모든 하위 표현식은 표현식 자체가 평가되기 전에 평가됩니다. 예를 들어, 다음 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bc8cf988787046c6e827bee8905f94b4d9c3ab4c" translate="yes" xml:space="preserve">
          <source>All subroutine calls, recursive or not, are always treated as atomic groups. That is, once a subroutine has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. Any capturing parentheses that are set during the subroutine call revert to their previous values afterwards.</source>
          <target state="translated">재귀 적이든 아니든 모든 서브 루틴 호출은 항상 원자 그룹으로 처리됩니다. 즉, 서브 루틴이 주제 문자열의 일부와 일치하면 시도되지 않은 대안이 포함되고 후속 일치 실패가 있어도 다시 입력되지 않습니다. 서브 루틴 호출 중에 설정된 캡처 괄호는 그 후 이전 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1d5c8272d5e19cda4e470b25066c4bee5acf4aba" translate="yes" xml:space="preserve">
          <source>All supported applications are sent in CEA. The user can reject an incoming CER or CEA in a configured callback.</source>
          <target state="translated">지원되는 모든 응용 프로그램은 CEA로 전송됩니다. 사용자는 구성된 콜백에서 수신 CER 또는 CEA를 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275f9905a31aea84897da6140c192789acae8be1" translate="yes" xml:space="preserve">
          <source>All system events are subscribed by the &lt;code&gt;Mnesia&lt;/code&gt;&lt;code&gt;gen_event&lt;/code&gt; handler. The default &lt;code&gt;gen_event&lt;/code&gt; handler is &lt;code&gt;mnesia_event&lt;/code&gt;, but it can be changed by using application parameter &lt;code&gt;event_module&lt;/code&gt;. The value of this parameter must be the name of a module implementing a complete handler, as specified by the &lt;code&gt;gen_event&lt;/code&gt; module in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">모든 시스템 이벤트는 &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;gen_event&lt;/code&gt; 핸들러에 의해 구독됩니다 . 기본 &lt;code&gt;gen_event&lt;/code&gt; 핸들러는 &lt;code&gt;mnesia_event&lt;/code&gt; 이지만 애플리케이션 매개 변수 &lt;code&gt;event_module&lt;/code&gt; 을 사용하여 변경할 수 있습니다 . 에 의해 지정된대로,이 파라미터의 값은, 전체 처리기를 구현하는 모듈의 이름이어야 &lt;code&gt;gen_event&lt;/code&gt; 에서 모듈 &lt;code&gt;STDLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d08314aed5dcca44e10e6d9a69ebf73a80227eb" translate="yes" xml:space="preserve">
          <source>All tables in these MIBs have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">이 MIB의 모든 테이블에는 &lt;code&gt;StorageType&lt;/code&gt; 유형의 열이 있습니다. 이 열의 값은 각 행이 저장되는 방법과 에이전트를 다시 시작할 때 발생하는 상황을 지정합니다. 구현은 &lt;code&gt;volatile&lt;/code&gt; 및 &lt;code&gt;nonVolatile&lt;/code&gt; 값을 지원합니다 . 테이블이 구성 파일의 데이터로 처음 채워질 때 이러한 행은 스토리지 유형 &lt;code&gt;nonVolatile&lt;/code&gt; 을 자동으로 갖 습니다 . 에이전트가 다시 시작되면 모든 &lt;code&gt;nonVolatile&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 행이 다시 시작된 후에도 휘발성 행이 손실됩니다. 기본적으로 구성 파일은 다시 시작할 때 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2be215003503f0345c1ed6d0ccc3e065ee26074f" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of the column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">이 MIB의 모든 테이블에는 &lt;code&gt;StorageType&lt;/code&gt; 유형의 열이 있습니다. 열 값은 각 행이 저장되는 방법과 에이전트를 다시 시작할 때 발생하는 상황을 지정합니다. 구현은 &lt;code&gt;volatile&lt;/code&gt; 및 &lt;code&gt;nonVolatile&lt;/code&gt; 값을 지원합니다 . 테이블이 구성 파일의 데이터로 처음 채워질 때 이러한 행은 스토리지 유형 &lt;code&gt;nonVolatile&lt;/code&gt; 을 자동으로 갖 습니다 . 에이전트가 다시 시작되면 모든 &lt;code&gt;nonVolatile&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 행이 다시 시작된 후에도 휘발성 행이 손실됩니다. 기본적으로 구성 파일은 다시 시작할 때 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6acc62d86c3d4707c0eac98a8d2e6fe30ade03d" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart by default.</source>
          <target state="translated">이 MIB의 모든 테이블에는 &lt;code&gt;StorageType&lt;/code&gt; 유형의 열이 있습니다. 이 열의 값은 각 행이 저장되는 방법과 에이전트를 다시 시작할 때 발생하는 상황을 지정합니다. 구현은 &lt;code&gt;volatile&lt;/code&gt; 및 &lt;code&gt;nonVolatile&lt;/code&gt; 값을 지원합니다 . 테이블이 구성 파일의 데이터로 처음 채워질 때 이러한 행은 스토리지 유형 &lt;code&gt;nonVolatile&lt;/code&gt; 을 자동으로 갖 습니다 . 에이전트가 다시 시작되면 모든 &lt;code&gt;nonVolatile&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 행이 다시 시작된 후에도 휘발성 행이 손실됩니다. 기본적으로 재시작시 구성 파일을 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00646ed20fc05656dbed000a1f7dd63af6936be5" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">이 MIB의 모든 테이블에는 &lt;code&gt;StorageType&lt;/code&gt; 유형의 열이 있습니다. 이 열의 값은 각 행이 저장되는 방법과 에이전트를 다시 시작할 때 발생하는 상황을 지정합니다. 구현은 &lt;code&gt;volatile&lt;/code&gt; 및 &lt;code&gt;nonVolatile&lt;/code&gt; 값을 지원합니다 . 테이블이 구성 파일의 데이터로 처음 채워질 때 이러한 행은 스토리지 유형 &lt;code&gt;nonVolatile&lt;/code&gt; 을 자동으로 갖 습니다 . 에이전트가 다시 시작되면 모든 &lt;code&gt;nonVolatile&lt;/code&gt; &lt;code&gt;volatile&lt;/code&gt; 행이 다시 시작된 후에도 휘발성 행이 손실됩니다. 기본적으로 구성 파일은 다시 시작할 때 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d08c6b8f5332d226fb098f25e3d0026f24d96b0" translate="yes" xml:space="preserve">
          <source>All terminal sessions, forwarded connections, and so on, are channels. Multiple channels are multiplexed into a single connection. All channels are flow-controlled. This means that no data is sent to a channel peer until a message is received to indicate that window space is available. The &lt;strong&gt;initial window size&lt;/strong&gt; specifies how many bytes of channel data that can be sent to the channel peer without adjusting the window. Typically, an SSH client opens a channel, sends data (commands), receives data (control information), and then closes the channel. The &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behaviour handles generic parts of SSH channel management. This makes it easy to write your own SSH client/server processes that use flow-control and thus opens for more focus on the application logic.</source>
          <target state="translated">모든 터미널 세션, 전달 된 연결 등은 채널입니다. 여러 채널이 단일 연결로 다중화됩니다. 모든 채널은 흐름 제어됩니다. 이는 창 공간이 사용 가능하다는 메시지가 수신 될 때까지 채널 피어로 데이터가 전송되지 않음을 의미합니다. &lt;strong&gt;초기 윈도우 사이즈&lt;/strong&gt; 지정 얼마나 많은 윈도우를 조정하지 않고 상기 채널 피어로 전송 될 수 채널 데이터의 바이트 수. 일반적으로 SSH 클라이언트는 채널을 열고 데이터를 전송 (명령)하고 데이터를 수신 (제어 정보) 한 다음 채널을 닫습니다. &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 의 동작은 SSH 채널 관리의 일반적인 부분을 처리합니다. 따라서 흐름 제어를 사용하는 자체 SSH 클라이언트 / 서버 프로세스를 쉽게 작성할 수 있으므로 응용 프로그램 논리에 더 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbaac04b0726304e8bc0e8488270b15fbabc7eec" translate="yes" xml:space="preserve">
          <source>All terms of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; belong to an environment of type &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;. The lifetime of a term is controlled by the lifetime of its environment object. All API functions that read or write terms has the environment that the term belongs to as the first function argument.</source>
          <target state="translated">&lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 유형의 모든 용어는 ErlNifEnv 유형 의 환경에 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; . 용어의 수명은 해당 환경 개체의 수명에 의해 제어됩니다. 용어를 읽거나 쓰는 모든 API 함수에는 용어가 첫 번째 함수 인수로 속하는 환경이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9bcc2ff9eb94545ba2264a6548aeeb2cfbc7213" translate="yes" xml:space="preserve">
          <source>All test specification terms can have a &lt;code&gt;NodeRefs&lt;/code&gt; element. This element specifies which node or nodes a configuration operation or a test is to be executed on. &lt;code&gt;NodeRefs&lt;/code&gt; is defined as follows:</source>
          <target state="translated">모든 테스트 사양 용어에는 &lt;code&gt;NodeRefs&lt;/code&gt; 요소 가있을 수 있습니다 . 이 요소는 구성 조작 또는 테스트를 실행할 노드를 지정합니다. &lt;code&gt;NodeRefs&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="48735adbc1ab5a93b4785b0a0f4fffaf6f1c2e20" translate="yes" xml:space="preserve">
          <source>All the Latin-1 printable characters can be used and are shown without the escape backslash convention.</source>
          <target state="translated">모든 라틴 -1 인쇄 가능 문자를 사용할 수 있으며 이스케이프 백 슬래시 규칙없이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d4b662d48820ea13cd394713d1d0d65d538449" translate="yes" xml:space="preserve">
          <source>All the files are searched for in the code path. It is assumed that the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.appup&lt;/code&gt; files for an application are located in the same directory.</source>
          <target state="translated">모든 파일은 코드 경로에서 검색됩니다. 응용 프로그램 의 &lt;code&gt;.app&lt;/code&gt; 및 &lt;code&gt;.appup&lt;/code&gt; 파일은 동일한 디렉토리에 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="0444fd0cb5c7b225515f5d7a7b6af2522512c8ad" translate="yes" xml:space="preserve">
          <source>All the makefiles in the entire directory tree use the environment variable &lt;code&gt;ERL_TOP&lt;/code&gt; to find the absolute path of the installation. The &lt;code&gt;configure&lt;/code&gt; script will figure this out and set it in the top level Makefile (which, when building, it will pass on). However, when developing it is sometimes convenient to be able to run make in a subdirectory. To do this you must set the &lt;code&gt;ERL_TOP&lt;/code&gt; variable before you run make.</source>
          <target state="translated">전체 디렉토리 트리의 모든 makefile은 환경 변수 &lt;code&gt;ERL_TOP&lt;/code&gt; 을 사용 하여 설치의 절대 경로를 찾습니다. &lt;code&gt;configure&lt;/code&gt; 스크립트는이 밖으로을 파악하고 (구축 할 때하는, 그것은에 전달합니다) 상위 레벨의 Makefile에서 설정됩니다. 그러나 개발시 하위 디렉토리에서 make를 실행할 수있는 것이 편리한 경우가 있습니다. 이렇게하려면 make를 실행하기 전에 &lt;code&gt;ERL_TOP&lt;/code&gt; 변수를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4e454e4a6b739313895f7f1cd6dd60a39deee0fd" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single character value can be used both inside and outside character classes. Also, inside a character class, \b is interpreted as the backspace character (hex 08).</source>
          <target state="translated">단일 문자 값을 정의하는 모든 시퀀스는 내부 및 외부 문자 클래스 모두에서 사용될 수 있습니다. 또한 문자 클래스 내에서 \ b는 백 스페이스 문자 (16 진 08)로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4ee45dea67a291aecd38cc8ca1fc6c4d76ed45cd" translate="yes" xml:space="preserve">
          <source>All the standard &lt;code&gt;erlc&lt;/code&gt; flags are supported, e.g.</source>
          <target state="translated">모든 표준 &lt;code&gt;erlc&lt;/code&gt; 플래그가 지원됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="7f1c4eba20235be2abd7c818764fb7f15db8c9f6" translate="yes" xml:space="preserve">
          <source>All these approaches have different advantages and disadvantages. Mnesia applications can easily be opened to the SNMP protocol. A direct 1-to-1 mapping can be established between Mnesia tables and SNMP tables. This means that a Mnesia table can be configured to be &lt;strong&gt;both&lt;/strong&gt; a Mnesia table and an SNMP table. A number of functions to control this behavior are described in the Reference Manual.</source>
          <target state="translated">이러한 모든 접근 방식은 장단점이 다릅니다. Mnesia 응용 프로그램은 SNMP 프로토콜로 쉽게 열 수 있습니다. Mnesia 테이블과 SNMP 테이블간에 직접 일대일 매핑을 설정할 수 있습니다. 이는 Mnesia 테이블 이 Mnesia 테이블과 SNMP 테이블 &lt;strong&gt;모두&lt;/strong&gt; 로 구성 될 수 있음을 의미 합니다. 이 동작을 제어하는 ​​여러 기능은 참조 설명서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fac601052f4adfe0b1a57d2c3f3d2911074176e" translate="yes" xml:space="preserve">
          <source>All these files are searched for in the current path. If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">이 모든 파일은 현재 경로에서 검색됩니다. &lt;code&gt;{path,[Dir]}&lt;/code&gt; 옵션을 지정하면이 경로가 현재 경로에 추가됩니다. 와일드 카드 &lt;code&gt;*&lt;/code&gt; 는 일치하는 모든 디렉토리로 확장됩니다. 예 : &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7e2356ccbec315a42104120c05856a52f734c98" translate="yes" xml:space="preserve">
          <source>All these specifications are commonly referred to as &quot;SNMPv3&quot;, but it is actually only the Message module, which defines a new message format, and Security module, which takes care of encryption and authentication, that cannot be used with SNMPv1 or SNMPv2c. In this version of the agent toolkit, all the standard MIBs for agent configuration are used. This includes MIBs for definition of management targets for notifications. These MIBs are used regardless of which SNMP version the agent is configured to use.</source>
          <target state="translated">이러한 모든 사양을 일반적으로 &quot;SNMPv3&quot;이라고하지만 실제로는 새 메시지 형식을 정의하는 메시지 모듈과 SNMPv1 또는 SNMPv2c와 함께 사용할 수없는 암호화 및 인증을 처리하는 보안 모듈 만 있습니다. 이 버전의 에이전트 툴킷에서는 에이전트 구성을위한 모든 표준 MIB가 사용됩니다. 여기에는 알림에 대한 관리 대상을 정의하기위한 MIB가 포함됩니다. 이러한 MIB는 에이전트가 사용하도록 구성된 SNMP 버전에 관계없이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3cac96e5ed27b35536f52f9e48ab7dabf6e3dcbc" translate="yes" xml:space="preserve">
          <source>All these terms are tuples or atoms and this property will hold in any future version of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">이 모든 용어는 튜플 또는 원자 &lt;code&gt;gen_statem&lt;/code&gt; 특성은 이후 버전의 gen_statem 에서 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="890112740b2f13fe0da0f81f57e7bfd71e15b913" translate="yes" xml:space="preserve">
          <source>All those processes are suspended using &lt;code&gt;sys:suspend&lt;/code&gt;, the new module version is loaded, and then the processes are resumed using &lt;code&gt;sys:resume&lt;/code&gt;.</source>
          <target state="translated">이러한 모든 프로세스는 &lt;code&gt;sys:suspend&lt;/code&gt; 를 사용하여 일시 중단 되고 새 모듈 버전이로드 된 후 &lt;code&gt;sys:resume&lt;/code&gt; 을 사용하여 프로세스가 재개됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdb00a5ac19881ad68109f99749ac6602091708a" translate="yes" xml:space="preserve">
          <source>All time values in the printout are in milliseconds.</source>
          <target state="translated">출력물의 모든 시간 값은 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="3664934232b9c1e3d5ba66ce6f23f716a86fdf6f" translate="yes" xml:space="preserve">
          <source>All time-out parameters in &lt;code&gt;ct_ssh&lt;/code&gt; functions are values in milliseconds.</source>
          <target state="translated">&lt;code&gt;ct_ssh&lt;/code&gt; 함수의 모든 시간 종료 매개 변수 는 밀리 초 단위의 값입니다.</target>
        </trans-unit>
        <trans-unit id="73ac2e4652c66f37048e2ce303fb4b7c12c7f46b" translate="yes" xml:space="preserve">
          <source>All trace messages are now sent to the trace port driver, which in turn listens for connections on the TCP/IP port 4711. If we want to see the messages on another node, preferably on another host, we do like this:</source>
          <target state="translated">모든 추적 메시지는 이제 추적 포트 드라이버로 전송되며, 추적 포트 드라이버는 TCP / IP 포트 4711에서 연결을 수신합니다. 다른 노드, 바람직하게는 다른 호스트에서 메시지를 보려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="8f71e5171eeb0a212a223f31caa94583b81ed2fb" translate="yes" xml:space="preserve">
          <source>All trace messages described in &lt;code&gt;erlang:trace/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; 에 설명 된 모든 추적 메시지</target>
        </trans-unit>
        <trans-unit id="d3efff8fa8f318980d38111160f5b67cc47267dc" translate="yes" xml:space="preserve">
          <source>All tracepoints are in the domain of &lt;code&gt;org_erlang_dyntrace&lt;/code&gt;</source>
          <target state="translated">모든 추적 점은 &lt;code&gt;org_erlang_dyntrace&lt;/code&gt; 의 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cb4a9b19b2ae441f7387b7938876140dd1d39f" translate="yes" xml:space="preserve">
          <source>All tracepoints are in the domain of &lt;code&gt;org_erlang_otp&lt;/code&gt;</source>
          <target state="translated">모든 추적 점은 &lt;code&gt;org_erlang_otp&lt;/code&gt; 의 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe016daf62582765dc4aa1a03f24a6e0af233e2a" translate="yes" xml:space="preserve">
          <source>All tracepoints via dyntrace are now visibile and can be listed through &lt;code&gt;lttng list -u&lt;/code&gt;.</source>
          <target state="translated">dyntrace를 통한 모든 추적 점은 이제 가시적이며 &lt;code&gt;lttng list -u&lt;/code&gt; 를 통해 나열 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="499f82751e8891c03eee132bbb924f122760fc91" translate="yes" xml:space="preserve">
          <source>All uses of &lt;code&gt;erlang:now/0&lt;/code&gt; are not necessarily time warp unsafe. If you do not use it to get time, it is time warp safe. However, &lt;strong&gt;all uses of &lt;code&gt;erlang:now/0&lt;/code&gt; are suboptimal&lt;/strong&gt; from a performance and scalability perspective. So you really want to replace the use of it with other functionality. For examples of how to replace the use of &lt;code&gt;erlang:now/0&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#Dos_and_Donts&quot;&gt;How to Work with the New API&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 을 모두 사용 한다고해서 반드시 시간 왜곡이 안전하지는 않습니다. 시간을 얻기 위해 사용하지 않으면 시간 왜곡이 안전합니다. 그러나 &lt;strong&gt; &lt;code&gt;erlang:now/0&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 의 모든 사용은&lt;/strong&gt; 성능 및 확장 성 측면에서 &lt;strong&gt;차선책&lt;/strong&gt; 입니다. 따라서 실제로 다른 기능으로 사용하는 것을 대체하고 싶습니다. &lt;code&gt;erlang:now/0&lt;/code&gt; 사용을 대체하는 방법에 대한 예 &lt;code&gt;&lt;a href=&quot;#Dos_and_Donts&quot;&gt;How to Work with the New API&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="211631ba4463502ebe4c8f751cdd7698a665a9d5" translate="yes" xml:space="preserve">
          <source>All valid &lt;code&gt;Modifier&lt;/code&gt;s can be combined. Repeated (valid) &lt;code&gt;Modifier&lt;/code&gt;s in the &lt;code&gt;ModifierList&lt;/code&gt; are ignored.</source>
          <target state="translated">유효한 모든 &lt;code&gt;Modifier&lt;/code&gt; 결합 할 수 있습니다. &lt;code&gt;Modifier&lt;/code&gt; List 의 반복 된 (유효한) &lt;code&gt;ModifierList&lt;/code&gt; 자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b522b5a14ce33ffd78ac8c417a27a7fc89b353" translate="yes" xml:space="preserve">
          <source>All value tuples returned, except user terms, have the node name as first element.</source>
          <target state="translated">사용자 용어를 제외하고 리턴 된 모든 값 튜플의 노드 이름은 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="21e9bece8ea26173685ff9911582acaf9d4050b7" translate="yes" xml:space="preserve">
          <source>All variables are bound in the head of a match specification, so the translator cannot allow multiple bindings. The special case when matching is done on the top-level makes the variable bind to &lt;code&gt;'$_'&lt;/code&gt; in the resulting match specification. It is to allow a more natural access to the whole matched object. Pseudo function &lt;code&gt;object()&lt;/code&gt; can be used instead, see below.</source>
          <target state="translated">모든 변수는 일치 스펙의 헤드에 바인드되므로 변환기는 다중 바인딩을 허용 할 수 없습니다. 일치하는 최상위 수준에서 수행되는 특별한 경우 결과 일치 사양에서 변수가 &lt;code&gt;'$_'&lt;/code&gt; 에 바인딩됩니다 . 일치하는 전체 개체에보다 자연스럽게 액세스 할 수 있도록합니다. 의사 함수 &lt;code&gt;object()&lt;/code&gt; 를 대신 사용할 수 있습니다 ( 아래 참조).</target>
        </trans-unit>
        <trans-unit id="3239372c6832b6066bf1341e4487441749e323f8" translate="yes" xml:space="preserve">
          <source>All variables in this section can also be used when native compiling.</source>
          <target state="translated">이 섹션의 모든 변수는 네이티브 컴파일시에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e461c8c7353cd1b34f013d7ed1f82ff4c3ffca7d" translate="yes" xml:space="preserve">
          <source>All variables that occur in a generator pattern are assumed to be &quot;fresh&quot; variables.</source>
          <target state="translated">생성기 패턴에서 발생하는 모든 변수는 &quot;신선한&quot;변수 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="df218dfee4c4921dcfbc282d5dc989b168d2e1f4" translate="yes" xml:space="preserve">
          <source>All variables that occur in the head of a fun are assumed to be &quot;fresh&quot; variables.</source>
          <target state="translated">재미의 머리에서 발생하는 모든 변수는 &quot;신선한&quot;변수 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9dca8a39352aeb9ee959a27cda59139e72297719" translate="yes" xml:space="preserve">
          <source>All versions of a release, except the first one, must contain a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">첫 번째 버전을 제외한 모든 버전의 릴리스에는 &lt;code&gt;relup&lt;/code&gt; 파일이 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e91b63c830fdded4d39a3a4df9692ba7ad1288f" translate="yes" xml:space="preserve">
          <source>All write operations must be written to persistent storage.</source>
          <target state="translated">모든 쓰기 작업은 영구 저장소에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="156cc2a3256755987835162d54df2b3bc251cdec" translate="yes" xml:space="preserve">
          <source>Allocates a binary of size &lt;code&gt;size&lt;/code&gt; bytes and creates an owning term. The binary data is mutable until the calling NIF returns. This is a quick way to create a new binary without having to use &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt;. The drawbacks are that the binary cannot be kept between NIF calls and it cannot be reallocated.</source>
          <target state="translated">이진 크기 &lt;code&gt;size&lt;/code&gt; 바이트를 할당하고 소유 용어를 만듭니다. 이진 데이터는 호출하는 NIF가 반환 될 때까지 변경 가능합니다. 이것은 &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt; 를 사용하지 않고도 새로운 바이너리를 생성하는 빠른 방법 입니다. 단점은 NIF 호출간에 바이너리를 유지할 수없고 재 할당 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb968cb7c5633735b69c8c6ae48cba56207bf43d" translate="yes" xml:space="preserve">
          <source>Allocates a driver binary with a memory block of at least &lt;code&gt;size&lt;/code&gt; bytes, and returns a pointer to it, or &lt;code&gt;NULL&lt;/code&gt; on failure (out of memory). When a driver binary has been sent to the emulator, it must not be changed. Every allocated binary is to be freed by a corresponding call to &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; (unless otherwise stated).</source>
          <target state="translated">최소 &lt;code&gt;size&lt;/code&gt; 바이트 의 메모리 블록으로 드라이버 바이너리를 할당하고 포인터를 반환하거나 실패시 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 (메모리 부족). 드라이버 바이너리가 에뮬레이터로 전송되면 변경해서는 안됩니다. 할당 된 모든 바이너리는 별도의 언급이없는 한 &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; 에 대한 해당 호출로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="833eb9c3ea4fa101cb31390f1caf6a0a0d2db0c7" translate="yes" xml:space="preserve">
          <source>Allocates a memory block of the size specified in &lt;code&gt;size&lt;/code&gt;, and returns it. This fails only on out of memory, in which case &lt;code&gt;NULL&lt;/code&gt; is returned. (This is most often a wrapper for &lt;code&gt;malloc&lt;/code&gt;).</source>
          <target state="translated">크기의 메모리 블록에 지정된 할당 &lt;code&gt;size&lt;/code&gt; , 반환을. 이것은 메모리 부족에서만 실패하며,이 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. (이것은 대부분 &lt;code&gt;malloc&lt;/code&gt; 래퍼입니다 ).</target>
        </trans-unit>
        <trans-unit id="7113d00f84f8c1774bce3cf42e016073857670b7" translate="yes" xml:space="preserve">
          <source>Allocates a memory-managed resource object of type &lt;code&gt;type&lt;/code&gt; and size &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 및 크기 &lt;code&gt;size&lt;/code&gt; 바이트 의 메모리 관리 자원 객체를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="40cbb022971bb0ea9616862fa9f96313f80c2ace" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;ei_x_buff&lt;/code&gt; buffer. The fields of the structure pointed to by parameter &lt;code&gt;x&lt;/code&gt; is filled in, and a default buffer is allocated. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; also puts an initial version byte, which is used in the binary format (so that &lt;code&gt;ei_x_encode_version()&lt;/code&gt; will not be needed.)</source>
          <target state="translated">새로운 &lt;code&gt;ei_x_buff&lt;/code&gt; 버퍼를 할당합니다 . 매개 변수 &lt;code&gt;x&lt;/code&gt; 가 가리키는 구조의 필드 가 채워지고 기본 버퍼가 할당됩니다. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; 은 또한 이진 형식으로 사용되는 초기 버전 바이트를 &lt;code&gt;ei_x_encode_version()&lt;/code&gt; 은 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="aba86698e833f8743e3f8398d4c7b3c5cba11222" translate="yes" xml:space="preserve">
          <source>Allocates a new binary of size &lt;code&gt;size&lt;/code&gt; bytes. Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; to refer to the allocated binary. The binary must either be released by &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; or ownership transferred to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. An allocated (and owned) &lt;code&gt;ErlNifBinary&lt;/code&gt; can be kept between NIF calls.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 바이트 인 새로운 바이너리를 할당 합니다. 할당 된 바이너리를 참조하기 위해 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 구조를 초기화합니다 . 바이너리는 &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; 에 의해 릴리스 되거나 &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt; 와 함께 Erlang 용어로 소유권이 이전되어야합니다 . 할당 된 (및 소유 된) &lt;code&gt;ErlNifBinary&lt;/code&gt; 는 NIF 호출간에 유지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7773bdff2c5401e19b3fa0521031da780795237d" translate="yes" xml:space="preserve">
          <source>Allocates a new binary with &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; and stores the result of encoding &lt;code&gt;term&lt;/code&gt; according to the Erlang external term format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 를 사용 하여 새 바이너리를 할당 하고 Erlang 외부 용어 형식에 따라 &lt;code&gt;term&lt;/code&gt; 인코딩 결과를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="7d5526a3227cb0d073e447c7c317d1cd47b6a7bb" translate="yes" xml:space="preserve">
          <source>Allocates a new process-independent environment. The environment can be used to hold terms that are not bound to any process. Such terms can later be copied to a process environment with &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; or be sent to a process as a message with &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새로운 프로세스 독립적 환경을 할당합니다. 환경은 프로세스에 구속되지 않는 용어를 보유하는 데 사용될 수 있습니다. 이러한 용어는 이후에 프로세스 환경에 복사 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; 나있는 메시지로 프로세스로 전송 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef1154674774259204ce883b3c8820bd4b8d7df0" translate="yes" xml:space="preserve">
          <source>Allocates an &lt;code&gt;(ETERM)&lt;/code&gt; structure.</source>
          <target state="translated">&lt;code&gt;(ETERM)&lt;/code&gt; 구조를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="24619459ec0a72f9cf9f4e797e9676fdd79c448d" translate="yes" xml:space="preserve">
          <source>Allocates and initializes a thread option structure.</source>
          <target state="translated">스레드 옵션 구조를 할당하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a18ef353480e9b28111af2f5cb94cf322d5db150" translate="yes" xml:space="preserve">
          <source>Allocates memory of &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 바이트의 메모리를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="6d3c5411f35ce9d979ab943b82f49536b0b3d755" translate="yes" xml:space="preserve">
          <source>Allocation strategy. The following strategies are valid:</source>
          <target state="translated">할당 전략. 다음 전략이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="90fca3fd6d65264d4e4e5dc53f3e23f12741c724" translate="yes" xml:space="preserve">
          <source>Allocator used by the &lt;code&gt;HiPE&lt;/code&gt; application for native executable code.</source>
          <target state="translated">네이티브 실행 코드를 위해 &lt;code&gt;HiPE&lt;/code&gt; 응용 프로그램에서 사용되는 할당 자 .</target>
        </trans-unit>
        <trans-unit id="e5156ecc9d7848780f93b6f5ebc71cee114aba96" translate="yes" xml:space="preserve">
          <source>Allocator used for &lt;code&gt;ets&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;ets&lt;/code&gt; 데이터에 사용 된 할당 자 .</target>
        </trans-unit>
        <trans-unit id="efc1c3dea60e348865091b6b8e2060dd569f66c2" translate="yes" xml:space="preserve">
          <source>Allocator used for Erlang binary data.</source>
          <target state="translated">Erlang 이진 데이터에 사용되는 할당 자.</target>
        </trans-unit>
        <trans-unit id="7a3adf2a9bd06e8c3a3e083ec99105ea6ffe70ec" translate="yes" xml:space="preserve">
          <source>Allocator used for Erlang heap data, such as Erlang process heaps.</source>
          <target state="translated">Erlang 프로세스 힙과 같은 Erlang 힙 데이터에 사용되는 할당 자.</target>
        </trans-unit>
        <trans-unit id="8e85fcae342a51464bc8fd23b308ac874d7d0a04" translate="yes" xml:space="preserve">
          <source>Allocator used for constant terms in Erlang code.</source>
          <target state="translated">Erlang 코드에서 상수 용어에 사용되는 할당 자.</target>
        </trans-unit>
        <trans-unit id="e1d6940ddd5a1c15fef14e15f5f4c63526b4e648" translate="yes" xml:space="preserve">
          <source>Allocator used for driver data.</source>
          <target state="translated">드라이버 데이터에 사용되는 할당 자.</target>
        </trans-unit>
        <trans-unit id="3ea76fff61ed65e7a4390d7beabc10d7b1f5293b" translate="yes" xml:space="preserve">
          <source>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</source>
          <target state="translated">Erlang 코드와 같이 오래 지속될 것으로 예상되는 메모리 블록에 사용 된 할당 자.</target>
        </trans-unit>
        <trans-unit id="a3b32174d0cb257a1aff46d5fa0ab778500a96d6" translate="yes" xml:space="preserve">
          <source>Allocator used for memory blocks that are expected to be short-lived.</source>
          <target state="translated">수명이 짧은 것으로 예상되는 메모리 블록에 사용 된 할당 자.</target>
        </trans-unit>
        <trans-unit id="d37461cad7f410e82c9bcd356e966dab124d9b70" translate="yes" xml:space="preserve">
          <source>Allocator used for most memory blocks not allocated through any of the other allocators described above.</source>
          <target state="translated">할당자는 위에서 설명한 다른 할당자를 통해 할당되지 않은 대부분의 메모리 블록에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e693dfe3e7d7c8a81002580ac04e0ce504a69571" translate="yes" xml:space="preserve">
          <source>Allocator used for temporary allocations.</source>
          <target state="translated">임시 할당에 사용 된 할당 자.</target>
        </trans-unit>
        <trans-unit id="10f9e4423c6925e89dc2106becb3f6ab79d98e45" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;sys_alloc&lt;/code&gt; carriers. Defaults to &lt;code&gt;true&lt;/code&gt;. If set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;sys_alloc&lt;/code&gt; carriers are never created by allocators using the &lt;code&gt;alloc_util&lt;/code&gt; framework.</source>
          <target state="translated">&lt;code&gt;sys_alloc&lt;/code&gt; 캐리어를 허용 하십시오 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 로 설정하면 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;sys_alloc&lt;/code&gt; 의 사업자가 사용하는 할당 자에 의해 생성되지 않습니다 &lt;code&gt;alloc_util&lt;/code&gt; 의 프레임 워크를.</target>
        </trans-unit>
        <trans-unit id="eff7134dcdaeb2b5c83d79ef04547c8d9cc7e16d" translate="yes" xml:space="preserve">
          <source>Allow Erlang code to supply annotations.</source>
          <target state="translated">Erlang 코드가 주석을 제공하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="2367e7a84c9f7bf24def174981a401bf837d2c24" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests if &lt;code&gt;RecordTag&lt;/code&gt; is a literal atom and &lt;code&gt;Size&lt;/code&gt; is a literal integer.</source>
          <target state="translated">&lt;code&gt;RecordTag&lt;/code&gt; 가 리터럴 원자이고 &lt;code&gt;Size&lt;/code&gt; 가 리터럴 정수인 경우 가드 테스트에서 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="501b2ae74253f22d1b49c8d28118aa90b6840545" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests, if &lt;code&gt;RecordTag&lt;/code&gt; is a literal atom.</source>
          <target state="translated">&lt;code&gt;RecordTag&lt;/code&gt; 가 리터럴 원자 인 경우 가드 테스트에서 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ba60d3da32240e2b1d7c2743d638c321c3a258" translate="yes" xml:space="preserve">
          <source>Allowed values for &lt;code&gt;Encoding&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Encoding&lt;/code&gt; 허용되는 값 :</target>
        </trans-unit>
        <trans-unit id="99a20c43f2025ca6e009397d28af92a72d22a63a" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycles&lt;/a&gt;&lt;/code&gt; in the digraph (default).</source>
          <target state="translated">Digraph에서 &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycles&lt;/a&gt;&lt;/code&gt; 를 허용합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="9f8f1bb0255618251aa9f45e2eb49f1f0585198d" translate="yes" xml:space="preserve">
          <source>Allows Igor to work as a component of the Erlang compiler. Including the term &lt;code&gt;{parse_transform, igor}&lt;/code&gt; in the compile options when compiling an Erlang module (cf. &lt;code&gt;compile:file/2&lt;/code&gt;), will call upon Igor to process the source code, allowing automatic inclusion of other source files. No files are created or overwritten when this function is used.</source>
          <target state="translated">Igor가 Erlang 컴파일러의 구성 요소로 작동 할 수 있도록합니다. Erlang 모듈을 컴파일 할 때 컴파일 옵션에 &lt;code&gt;{parse_transform, igor}&lt;/code&gt; 용어를 포함하면 (cf &lt;code&gt;compile:file/2&lt;/code&gt; ) Igor가 다른 소스 파일을 자동으로 포함 할 수 있도록 소스 코드를 처리 할 것을 요구합니다. 이 기능을 사용할 때 파일을 만들거나 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d62f1a06265052c97727445916da061a31b46c03" translate="yes" xml:space="preserve">
          <source>Allows an Erlang process to access any currently opened file descriptors used by Erlang. The file descriptor &lt;code&gt;In&lt;/code&gt; can be used for standard input, and the file descriptor &lt;code&gt;Out&lt;/code&gt; for standard output. It is only used for various servers in the Erlang OS (&lt;code&gt;shell&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt;). Hence, its use is limited.</source>
          <target state="translated">Erlang 프로세스가 Erlang이 사용하는 현재 열린 파일 디스크립터에 액세스 할 수 있도록합니다. 파일 디스크립터 &lt;code&gt;In&lt;/code&gt; 은 표준 입력에, 파일 디스크립터 &lt;code&gt;Out&lt;/code&gt; 은 표준 출력에 사용할 수 있습니다. Erlang OS의 다양한 서버 ( &lt;code&gt;shell&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; ) 에만 사용됩니다 . 따라서 사용이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="720d85d8bcd2b0982465cd89217c4403945af062" translate="yes" xml:space="preserve">
          <source>Allows an existing file-descriptor to be used (passed on to the transport protocol).</source>
          <target state="translated">기존 파일 디스크립터를 사용할 수 있도록합니다 (전송 프로토콜로 전달).</target>
        </trans-unit>
        <trans-unit id="5a7d300ab2bf430dd90e7faf7d031bdea72764be" translate="yes" xml:space="preserve">
          <source>Allows compilers built on top of &lt;code&gt;compile&lt;/code&gt; to attach extra compilation metadata to the &lt;code&gt;compile_info&lt;/code&gt; chunk in the generated beam file.</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; 위에 빌드 된 컴파일러 가 생성 된 빔 파일 의 &lt;code&gt;compile_info&lt;/code&gt; 청크에 추가 컴파일 메타 데이터를 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d9ebd39621d33904a794e05cf3bb97eb76cd7e" translate="yes" xml:space="preserve">
          <source>Allows faster access to a file, as no Erlang process is needed to handle the file. However, a file opened in this way has the following limitations:</source>
          <target state="translated">파일을 처리하는 데 Erlang 프로세스가 필요하지 않으므로 파일에 더 빠르게 액세스 할 수 있습니다. 그러나 이런 방식으로 열린 파일에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d38a6520a61a4489f42b5d87122e227d5717f7" translate="yes" xml:space="preserve">
          <source>Allows or disallows local reuse of port numbers. By default, reuse is disallowed.</source>
          <target state="translated">포트 번호의 로컬 재사용을 허용하거나 허용하지 않습니다. 기본적으로 재사용은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffa1d032886c439e4bec827547cfb0410648a8e3" translate="yes" xml:space="preserve">
          <source>Allows specification of the directory to fetch the data to. If the directory already exists, an error is thrown.</source>
          <target state="translated">디렉토리를 지정하여 데이터를 페치 할 수 있습니다. 디렉토리가 이미 존재하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb4fe77b0bd1f96cbd1b0f77fd621a2567c4e7b4" translate="yes" xml:space="preserve">
          <source>Allows to enable overload checking on the nodes under trace. &lt;code&gt;Module:Function(check)&lt;/code&gt; is performed each &lt;code&gt;MSec&lt;/code&gt; millisecond. If the check returns &lt;code&gt;true&lt;/code&gt;, the tracing is disabled on a specified node.</source>
          <target state="translated">추적중인 노드에서 과부하 검사를 활성화 할 수 있습니다. &lt;code&gt;Module:Function(check)&lt;/code&gt; 은 매 &lt;code&gt;MSec&lt;/code&gt; 밀리 초 마다 수행됩니다 . 검사가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 지정된 노드에서 추적이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4d34cd5d35400761bb61a8de2c3b8cac8b75f88f" translate="yes" xml:space="preserve">
          <source>Allows to specify DTD name when it isn't available in the XML document. This option has effect only together with &lt;code&gt;{validation,'dtd'&lt;/code&gt; option.</source>
          <target state="translated">XML 문서에서 DTD 이름을 사용할 수 없을 때이를 지정할 수 있습니다. 이 옵션은 &lt;code&gt;{validation,'dtd'&lt;/code&gt; 옵션 과 함께 만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47912c360e75c64559b07b272500ccc88ac1869a" translate="yes" xml:space="preserve">
          <source>Allows to specify the order of preference for named curves and to restrict their usage when using a cipher suite supporting them.</source>
          <target state="translated">명명 된 곡선의 우선 순위를 지정하고이를 지원하는 암호 제품군을 사용할 때 사용을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f489a56c04187aff8cb1e8fd899369509580cc57" translate="yes" xml:space="preserve">
          <source>Allows user-specific terms in a test specification (described later).</source>
          <target state="translated">테스트 사양에서 사용자 별 용어를 허용합니다 (나중에 설명).</target>
        </trans-unit>
        <trans-unit id="a041c6fe34c8772f10490994f72eedc84ac17b8e" translate="yes" xml:space="preserve">
          <source>Allows you to disable chunked transfer-encoding when sending a response to an HTTP/1.1 client. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">HTTP / 1.1 클라이언트에 응답을 보낼 때 청크 분할 전송 인코딩을 비활성화 할 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f7dfd6f2f9e5a386b1eb293fb8cbfe622a3386d" translate="yes" xml:space="preserve">
          <source>Almost all functionality available in the &lt;code&gt;et_viewer&lt;/code&gt; is also available via shortcuts. Which key that has the same effect as selecting a menu entry is shown enclosed in parentheses. For example pressing the key &lt;code&gt;r&lt;/code&gt; is equivalent to selecting the menu entry &lt;code&gt;Viewer-&amp;gt;Refresh&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;et_viewer&lt;/code&gt; 에서 사용 가능한 거의 모든 기능 은 바로 가기를 통해 사용할 수도 있습니다. 메뉴 항목을 선택하는 것과 동일한 효과를 나타내는 키는 괄호 안에 표시됩니다. 예를 들어, 키 &lt;code&gt;r&lt;/code&gt; 을 누르는 것은 메뉴 항목 &lt;code&gt;Viewer-&amp;gt;Refresh&lt;/code&gt; 를 선택하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ddea236d72017f9bb6251d4cd4ca6ee8c89d93" translate="yes" xml:space="preserve">
          <source>Almost all server functionality has been implemented using an especially crafted server API, which is described in the Erlang Web Server API. This API can be used to enhance the core server functionality, for example with custom logging and authentication.</source>
          <target state="translated">거의 모든 서버 기능은 Erlang Web Server API에 설명 된 특수하게 조작 된 서버 API를 사용하여 구현되었습니다. 이 API는 핵심 서버 기능을 향상시키는 데 사용될 수 있습니다 (예 : 사용자 정의 로깅 및 인증).</target>
        </trans-unit>
        <trans-unit id="e164535afa87d85e1d8e4d869a83d45ecdea2bd2" translate="yes" xml:space="preserve">
          <source>Alpha converts a pattern (renames variables). Similar to tsubst/1, but only renames variables (including globs).</source>
          <target state="translated">알파는 패턴을 바꿉니다 (이름 변경). tsubst / 1과 유사하지만 변수 (글로브 포함) 만 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="94e6d313a320186aef8a05e769cde9d6aee31ec8" translate="yes" xml:space="preserve">
          <source>Also a simulation of a busy server. Inserts a delay before a reply is sent.</source>
          <target state="translated">또한 바쁜 서버의 시뮬레이션. 회신을 보내기 전에 지연을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="c107930bfba767a92d8fada4aaa539db162143a4" translate="yes" xml:space="preserve">
          <source>Also environment variable operations used to accept names and values of environment variables containing null characters (integer value zero). This caused operations to silently produce erroneous results. Environment variable names and values containing null characters inside the name or value are now &lt;strong&gt;rejected&lt;/strong&gt; and will cause environment variable operations to fail.</source>
          <target state="translated">또한 널 문자 (정수 값 0)를 포함하는 환경 변수의 이름과 값을 승인하는 데 사용되는 환경 변수 조작. 이로 인해 조작이 자동으로 잘못된 결과를 생성했습니다. 이름 또는 값 내에 널 문자를 포함하는 환경 변수 이름 및 값이 이제 &lt;strong&gt;거부&lt;/strong&gt; 되어 환경 변수 조작이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d9b60222b2c75f1c86ff987c34e09f8cde41625a" translate="yes" xml:space="preserve">
          <source>Also for convenience, record notation is allowed to be used. Records are shorthands for the corresponding tuples:</source>
          <target state="translated">또한 편의상 레코드 표기법을 사용할 수 있습니다. 해당 튜플의 레코드는 속기입니다.</target>
        </trans-unit>
        <trans-unit id="a3a4b07a56cad329b79384243949038cbc1372cd" translate="yes" xml:space="preserve">
          <source>Also note that Erlang records will be renamed as necessary to avoid non-equivalent definitions using the same record name. This does not work if the source code accesses the name field of such record tuples by &lt;code&gt;element/2&lt;/code&gt; or similar methods. Always use the record syntax to handle record tuples, if possible.</source>
          <target state="translated">또한 동일한 레코드 이름을 사용하는 동등한 정의를 피하기 위해 Erlang 레코드의 이름이 필요에 따라 변경됩니다. 소스 코드가 &lt;code&gt;element/2&lt;/code&gt; 또는 유사한 메소드 로 이러한 레코드 튜플의 이름 필드에 액세스하는 경우에는 작동하지 않습니다 . 가능하면 항상 레코드 구문을 사용하여 레코드 튜플을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="7ac5f975913185a02359637f04ddfbdfbcd994b3" translate="yes" xml:space="preserve">
          <source>Also note that there are some shell features like history list (control-p and control-n), in line editing (Emacs key bindings) and module and function name completion (tab) if the module is loaded.</source>
          <target state="translated">또한 히스토리 목록 (control-p 및 control-n), 라인 편집 (Emacs 키 바인딩) 및 모듈 및 모듈이로드 된 경우 기능 이름 완료 (탭)와 같은 일부 쉘 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a063b92ca8f32cb5670e7484a2f6224c06de2e7" translate="yes" xml:space="preserve">
          <source>Also note when upgrading a &lt;code&gt;gen_statem&lt;/code&gt;, this function and hence the &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; parameter in the &lt;code&gt;appup&lt;/code&gt; file is not only needed to update the internal state or to act on the &lt;code&gt;Extra&lt;/code&gt; argument. It is also needed if an upgrade or downgrade should change &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, or else the callback mode after the code change will not be honoured, most probably causing a server crash.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 을 업그레이드 할 때도이 함수 및 &lt;code&gt;appup&lt;/code&gt; 파일 의 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 매개 변수 는 내부 상태를 업데이트하거나 &lt;code&gt;Extra&lt;/code&gt; 인수 에 작용할 필요가 없습니다 . 또한 업그레이드 또는 다운 그레이드가 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 변경해야 하거나 코드 변경 후 콜백 모드가 적용되지 않으면 서버 충돌이 발생하는 경우에도 필요합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b03a08b970bd32744c558ee650c59b74bf3ec43b" translate="yes" xml:space="preserve">
          <source>Also try the &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;erl_tidy&lt;/a&gt;&lt;/code&gt; module, as follows:</source>
          <target state="translated">다음과 같이 &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;erl_tidy&lt;/a&gt;&lt;/code&gt; 모듈을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c49a065dda16af9230d583d9a156ea20f71a1f7b" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;errno&lt;/code&gt; values from &lt;code&gt;socket&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; and &lt;code&gt;connect&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; system calls can be propagated into &lt;code&gt;erl_errno&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;socket&lt;/code&gt; &lt;strong&gt;(2)&lt;/strong&gt; 및 &lt;code&gt;connect&lt;/code&gt; &lt;strong&gt;(2)&lt;/strong&gt; 시스템 호출의 &lt;code&gt;errno&lt;/code&gt; 값은 &lt;code&gt;erl_errno&lt;/code&gt; 로 전파 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0950deda4048dd3e61bbd230b1ca6f75c0083a70" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;errno&lt;/code&gt; values from &lt;code&gt;socket&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; and &lt;code&gt;connect&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; system calls may be propagated into &lt;code&gt;erl_errno&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;socket&lt;/code&gt; &lt;strong&gt;(2)&lt;/strong&gt; 및 &lt;code&gt;connect&lt;/code&gt; &lt;strong&gt;(2)&lt;/strong&gt; 시스템 호출의 &lt;code&gt;errno&lt;/code&gt; 값이 &lt;code&gt;erl_errno&lt;/code&gt; 로 전파 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89386e204a09fa8d2107f970fae5575cde96ce99" translate="yes" xml:space="preserve">
          <source>Also, a read-only traversal of the source backup can be performed without updating a target backup. If &lt;code&gt;TargetMod==read_only&lt;/code&gt;, no target backup is accessed.</source>
          <target state="translated">또한 대상 백업을 업데이트하지 않고 소스 백업의 읽기 전용 순회를 수행 할 수 있습니다. 경우 &lt;code&gt;TargetMod==read_only&lt;/code&gt; , 어떤 대상 백업에 액세스하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35a2ab2594479e34bf702bdcbfc2a6ff056e0ee5" translate="yes" xml:space="preserve">
          <source>Also, a time-out of five seconds has been introduced in the &lt;code&gt;await_result&lt;/code&gt; function. That is, if the server does not reply within five seconds (5000 ms), the client terminates. This is only needed in the logon sequence before the client and the server are linked.</source>
          <target state="translated">또한 &lt;code&gt;await_result&lt;/code&gt; 함수 에 5 초의 시간 초과가 도입되었습니다 . 즉, 서버가 5 초 (5000ms) 내에 응답하지 않으면 클라이언트가 종료됩니다. 클라이언트와 서버가 연결되기 전에 로그온 순서로만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fbe49c130871a8ea81b48a336d4846f52b1db188" translate="yes" xml:space="preserve">
          <source>Also, aim for testing everything once, no less, no more. It is not effective having every test case fail only because one function in the interface changed.</source>
          <target state="translated">또한 모든 것을 한 번 또는 더 이상 테스트하지 마십시오. 인터페이스에서 하나의 기능이 변경 되었기 때문에 모든 테스트 케이스가 실패하는 것은 효과적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38092a15de7c4da112bf97ddb70a794cc7c246e0" translate="yes" xml:space="preserve">
          <source>Also, because of fragmentation and prereservation of memory areas, the size of the memory segments containing the dynamically allocated memory blocks can be much larger than the total size of the dynamically allocated memory blocks.</source>
          <target state="translated">또한, 메모리 영역의 단편화 및 사전 예약으로 인해, 동적으로 할당 된 메모리 블록을 포함하는 메모리 세그먼트의 크기는 동적으로 할당 된 메모리 블록의 총 크기보다 훨씬 클 수있다.</target>
        </trans-unit>
        <trans-unit id="d5b32fcc26a6a8b9a2395401bc02ead29333f9bb" translate="yes" xml:space="preserve">
          <source>Also, different activity access contexts can be mixed while nesting. However, the dirty ones (&lt;code&gt;async_dirty&lt;/code&gt;, &lt;code&gt;sync_dirty&lt;/code&gt;, and &lt;code&gt;ets&lt;/code&gt;) inherit the transaction semantics if they are called inside a transaction and thus grab locks and use two or three phase commit.</source>
          <target state="translated">또한 중첩하는 동안 다른 활동 액세스 컨텍스트를 혼합 할 수 있습니다. 그러나 더티 항목 ( &lt;code&gt;async_dirty&lt;/code&gt; , &lt;code&gt;sync_dirty&lt;/code&gt; 및 &lt;code&gt;ets&lt;/code&gt; )은 트랜잭션 내부에서 호출되는 트랜잭션 의미를 상속하므로 잠금을 잡고 2 단계 또는 3 단계 커밋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="823028d8a3ebcfad8bc2f54c9ca2e8fbebc07b0d" translate="yes" xml:space="preserve">
          <source>Also, for documentation purposes, argument names can be given:</source>
          <target state="translated">또한 문서화 목적으로 인수 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a32ab36ee173194b5ab198d8e878626de325e7" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read/3&lt;/code&gt; call fails if the data contains characters larger than 255, which is why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">또한, 만약 &lt;code&gt;encoding&lt;/code&gt; 다른 이상 값으로 설정된다 &lt;code&gt;latin1&lt;/code&gt; 상기 &lt;code&gt;read/3&lt;/code&gt; 데이터 (255)보다 자 더 포함하는 경우 호출 모듈 이유 인 실패 &lt;code&gt;io(3)&lt;/code&gt; 와 같은 파일을 읽을 때 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="425722573d70397b1c7d94c9000e50ce9ddd142d" translate="yes" xml:space="preserve">
          <source>Also, the API driver functions &lt;code&gt;driver_output*&lt;/code&gt; and &lt;code&gt;driver_vec_to_buf&lt;/code&gt;, &lt;code&gt;driver_alloc/realloc*&lt;/code&gt;, and the &lt;code&gt;driver_*&lt;/code&gt; queue functions were changed to have larger length arguments and return values. This is a lesser problem, as code that passes smaller types gets them auto-converted in the calls, and as long as the driver does not handle sizes that overflow an &lt;code&gt;int&lt;/code&gt;, all will work as before.</source>
          <target state="translated">또한 API 드라이버 함수 &lt;code&gt;driver_output*&lt;/code&gt; 및 &lt;code&gt;driver_vec_to_buf&lt;/code&gt; , &lt;code&gt;driver_alloc/realloc*&lt;/code&gt; 및 &lt;code&gt;driver_*&lt;/code&gt; 큐 함수가 더 긴 길이의 인수 및 리턴 값을 갖도록 변경되었습니다. 작은 유형을 전달하는 코드가 호출에서 자동으로 변환되고 드라이버가 &lt;code&gt;int&lt;/code&gt; 오버플로 크기를 처리하지 않는 한 모든 것이 이전과 같이 작동하기 때문에 이것은 덜 문제 입니다.</target>
        </trans-unit>
        <trans-unit id="5bf6719ad80d4978b49cbb0963084e0b9ffea279" translate="yes" xml:space="preserve">
          <source>Also, the Erlang implementation requires understanding of concepts that were never an issue for many (Erlang) programmers. To understand and use Unicode characters requires that you study the subject thoroughly, even if you are an experienced programmer.</source>
          <target state="translated">또한 Erlang을 구현하려면 많은 (Erlang) 프로그래머에게 결코 문제가되지 않은 개념을 이해해야합니다. 유니 코드 문자를 이해하고 사용하려면 숙련 된 프로그래머라도 주제를 철저히 연구해야합니다.</target>
        </trans-unit>
        <trans-unit id="97ffcd43fe119d65b1c38d259f0ad035db9d9f66" translate="yes" xml:space="preserve">
          <source>Also, the toolkit does not support dependencies between sub-agents. A sub-agent should by definition be stand alone and it is therefore not good design to create dependencies between them.</source>
          <target state="translated">또한 툴킷은 하위 에이전트 간의 종속성을 지원하지 않습니다. 서브 에이전트는 정의상 독립형이어야하므로 서브 에이전트를 종속시키는 것은 좋은 설계가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="36abf7ef6c434f71bc62120ad73dd9f305fae2ba" translate="yes" xml:space="preserve">
          <source>Also, this code compares lists elements using the &quot;&lt;code&gt;==&lt;/code&gt;&quot; operator, while &quot;&lt;code&gt;--&lt;/code&gt;&quot; uses the &quot;&lt;code&gt;=:=&lt;/code&gt;&quot; operator. If that difference is important, &lt;code&gt;sets&lt;/code&gt; can be used instead of &lt;code&gt;gb_sets&lt;/code&gt;, but &lt;code&gt;sets:from_list/1&lt;/code&gt; is much slower than &lt;code&gt;gb_sets:from_list/1&lt;/code&gt; for long lists.</source>
          <target state="translated">또한이 코드는 &quot; &lt;code&gt;==&lt;/code&gt; &quot;연산자를 사용하여 목록 요소를 비교 하는 반면 &quot; &lt;code&gt;--&lt;/code&gt; &quot;는 &quot; &lt;code&gt;=:=&lt;/code&gt; &quot;연산자를 사용합니다. 그 차이가 중요하면 &lt;code&gt;gb_sets&lt;/code&gt; 대신 &lt;code&gt;sets&lt;/code&gt; 를 사용할 수 있지만 &lt;code&gt;sets:from_list/1&lt;/code&gt; 은 긴 목록의 경우 &lt;code&gt;gb_sets:from_list/1&lt;/code&gt; 보다 훨씬 느립니다 .</target>
        </trans-unit>
        <trans-unit id="6b487a502989be65a999a414931c10e73d9e958d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;OptionList == []&lt;/code&gt;, only visible nodes, that is, nodes that appear in the result of &lt;code&gt;erlang:nodes/0&lt;/code&gt;, are monitored.</source>
          <target state="translated">또한 &lt;code&gt;OptionList == []&lt;/code&gt; 인 경우 보이는 노드, 즉 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 결과에 나타나는 노드 만 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7e2f70e0a7fca68066437851c1d0da8c3f758e" translate="yes" xml:space="preserve">
          <source>Also, when a table is opened this file is read, if it exists.</source>
          <target state="translated">또한 테이블이 열릴 때이 파일이 있으면 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bf226a59dfe6aed5d51c1238c21cc12d02623322" translate="yes" xml:space="preserve">
          <source>Alternation. It matches either &lt;code&gt;r1&lt;/code&gt; or &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">교대. &lt;code&gt;r1&lt;/code&gt; 또는 &lt;code&gt;r2&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="2d3884e669febf89019a2dd3d1f7118c5ae8dd7e" translate="yes" xml:space="preserve">
          <source>Alternation. Matches one of the alternatives.</source>
          <target state="translated">교대. 대안 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b0e0df8a7d7ac3abd4437e1480f042a0637f8891" translate="yes" xml:space="preserve">
          <source>Alternative &lt;code&gt;ab&lt;/code&gt; is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps.</source>
          <target state="translated">대체 &lt;code&gt;ab&lt;/code&gt; 가 발견되었으며 결과는 [{1,2}, {1,2}]입니다. 결과가 결과 목록에 추가되고 검색 문자열의 위치가 두 단계 씩 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="388bde91034a0c2bd5c6b83f406e6d950cb39478" translate="yes" xml:space="preserve">
          <source>Alternative syntax for acquisition of table locks is as follows:</source>
          <target state="translated">테이블 잠금 획득을위한 대체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de359fc26767f6609fd33d4bab9ab9ec84302a3a" translate="yes" xml:space="preserve">
          <source>Alternative way to stop the HTTP client profile:</source>
          <target state="translated">HTTP 클라이언트 프로파일을 중지하는 다른 방법 :</target>
        </trans-unit>
        <trans-unit id="3b8239e68048624328c3887db9856779071451e0" translate="yes" xml:space="preserve">
          <source>Alternative:</source>
          <target state="translated">Alternative:</target>
        </trans-unit>
        <trans-unit id="84eb863ce8c5fe0eaf266247b00e7b639109efa7" translate="yes" xml:space="preserve">
          <source>Alternatively you download MinGW and MSYS. You'll find the latest installer at:</source>
          <target state="translated">또는 MinGW 및 MSYS를 다운로드하십시오. 최신 설치 프로그램은 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9a5b357a1ebe1596911f8227c3f50733821b16" translate="yes" xml:space="preserve">
          <source>Alternatively, application configuration parameters can be added or updated in &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;sys.config&lt;/code&gt; 에서 애플리케이션 구성 매개 변수를 추가하거나 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d257655b31583a29c42cb081673cc370da4eb39" translate="yes" xml:space="preserve">
          <source>Alternatively, for more control, use functions &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">또는 더 많은 제어를 위해 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d20174a3ef0c0e03812655f5a1538626e3ef7e1" translate="yes" xml:space="preserve">
          <source>Alternatively, setting flags to &lt;code&gt;EI_FORCE&lt;/code&gt; causes a full backup to be done, and &lt;code&gt;EI_NOPURGE&lt;/code&gt; causes the deleted objects to be left in the registry afterwards. These can be bitwise OR'ed together if both behaviors are desired. If &lt;code&gt;EI_NOPURGE&lt;/code&gt; was specified, &lt;code&gt;ei_reg_purge()&lt;/code&gt; can be used to explicitly remove the deleted items from the registry later.</source>
          <target state="translated">또는 플래그를 &lt;code&gt;EI_FORCE&lt;/code&gt; 로 설정 하면 전체 백업이 수행되고 &lt;code&gt;EI_NOPURGE&lt;/code&gt; 로 인해 삭제 된 오브젝트가 레지스트리에 남아있게됩니다. 두 동작을 모두 원할 경우 비트 단위로 OR로 연결될 수 있습니다. 경우 &lt;code&gt;EI_NOPURGE&lt;/code&gt; 가 지정, &lt;code&gt;ei_reg_purge()&lt;/code&gt; 명시 적으로 레지스트리 나중에에서 삭제 된 항목을 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda106df891b543c9d37c11d60d93578eda797a2" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;erl_send()&lt;/code&gt; and &lt;code&gt;erl_receive_msg&lt;/code&gt;, which handle the encoding and decoding of messages transparently.</source>
          <target state="translated">또는 메시지의 인코딩 및 디코딩을 투명하게 처리하는 &lt;code&gt;erl_send()&lt;/code&gt; 및 &lt;code&gt;erl_receive_msg&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a36a8fbf04bc6a8060ec964f113d3388e9e6727" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Common Test&lt;/code&gt; was created primarily for black-box testing, nothing prevents it from working perfectly as a white-box testing tool as well. This is especially true when the application to test is written in Erlang. Then the test ports are easily realized with Erlang function calls.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 는 주로 블랙 박스 테스트 용으로 작성 되었지만 화이트 박스 테스트 도구로 완벽하게 작동하는 것을 막는 것은 없습니다. 테스트 할 응용 프로그램이 Erlang으로 작성된 경우 특히 그렇습니다. 그런 다음 Erlang 함수 호출로 테스트 포트를 쉽게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b19755925d10feb1c1eeb84ec413b87f2a2d0e8" translate="yes" xml:space="preserve">
          <source>Although EUnit uses many preprocessor macros, they have been designed to be as nonintrusive as possible, and should not cause conflicts with existing code. Adding EUnit tests to a module should thus not normally require changing existing code. Furthermore, tests that only exercise the exported functions of a module can always be placed in a completely separate module, avoiding any conflicts entirely.</source>
          <target state="translated">EUnit은 많은 전 처리기 매크로를 사용하지만 가능한 한 방해가되지 않도록 설계되었으며 기존 코드와 충돌하지 않아야합니다. 따라서 EUnit 테스트를 모듈에 추가하면 일반적으로 기존 코드를 변경할 필요가 없습니다. 또한 모듈의 내 보낸 기능 만 실행하는 테스트는 항상 완전히 분리 된 모듈에 배치하여 충돌을 완전히 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16e985c50acb7aa3cc2e37887e81edfb84b36580" translate="yes" xml:space="preserve">
          <source>Although Erlang can handle Unicode data in many forms does not automatically mean that the content of any file can be Unicode text. The external entities, such as ports and I/O servers, are not generally Unicode capable.</source>
          <target state="translated">Erlang이 여러 형식으로 유니 코드 데이터를 처리 할 수 ​​있다고하더라도 파일의 내용이 유니 코드 텍스트 일 ​​수 있다는 것을 자동으로 의미하지는 않습니다. 포트 및 I / O 서버와 같은 외부 엔터티는 일반적으로 유니 코드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02df0b028081655673738d27b03c581fc80907e4" translate="yes" xml:space="preserve">
          <source>Although Erlang drivers in general can be beyond the scope of this section, a brief introduction seems to be in place.</source>
          <target state="translated">Erlang 드라이버는 일반적으로이 섹션의 범위를 벗어나지 만 간단한 소개가 필요한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="145c19dfbd3603b0f1f5d0df7751ed8d04c50799" translate="yes" xml:space="preserve">
          <source>Although all the functionality of EUnit is available even without the use of preprocessor macros, the EUnit header file defines a number of such macros in order to make it as easy as possible to write unit tests as compactly as possible and without getting too many details in the way.</source>
          <target state="translated">전 처리기 매크로를 사용하지 않아도 EUnit의 모든 기능을 사용할 수 있지만, EUnit 헤더 파일은 단위 테스트를 가능한 한 간단하게 작성하고 세부 정보를 너무 많이 얻지 않도록하기 위해 이러한 매크로를 정의합니다. 방법.</target>
        </trans-unit>
        <trans-unit id="288b1873eb386778abf8c7efb5abf1c61cbff2fe" translate="yes" xml:space="preserve">
          <source>Although it would be both pointless and counterproductive to use segmentation on a transport that already does this (e.g. TCP), the megaco application does not check this. Instead, it is up to the user to configure this properly.</source>
          <target state="translated">TCP (예 : TCP)를 이미 수행하는 전송에서 분할을 사용하는 것은 의미가없고 비생산적이지만 megaco 응용 프로그램은이를 확인하지 않습니다. 대신,이를 올바르게 구성하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="beb0a28a74c40d09218865dad1a734397c647414" translate="yes" xml:space="preserve">
          <source>Although public key algorithms are supported in FIPS mode they can only be used with secure key sizes. The Security Policy requires the following minimum values:</source>
          <target state="translated">공개 키 알고리즘은 FIPS 모드에서 지원되지만 보안 키 크기에서만 사용할 수 있습니다. 보안 정책에는 다음과 같은 최소값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc4daacf4342e7c4815a182117afe540cdf564a1" translate="yes" xml:space="preserve">
          <source>Although the garbage collector grows the heap, it grows it step-by-step, which is more costly than directly establishing a larger heap when the process is spawned.</source>
          <target state="translated">가비지 수집기는 힙을 늘리지 만 단계별로 커지므로 프로세스가 생성 될 때 더 큰 힙을 직접 설정하는 것보다 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="24878073b1b7f8b78f02e6ee00d8bf88d852b349" translate="yes" xml:space="preserve">
          <source>Although the options are described in a Unix-like format, the case of the options or commands is not relevant, and both character &quot;/&quot; and &quot;-&quot; can be used for options.</source>
          <target state="translated">옵션이 유닉스 계열 형식으로 설명되어 있지만 옵션 또는 명령의 경우에는 관련이 없으며 문자 &quot;/&quot;및 &quot;-&quot;를 모두 옵션으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce09f2137d6fc334364eda633d224f186c26d70" translate="yes" xml:space="preserve">
          <source>Although the program is located together with files specific to the emulator version, it is not expected to be specific to the emulator version. The release handler does &lt;strong&gt;not&lt;/strong&gt; change option &lt;code&gt;-machine&lt;/code&gt; to &lt;code&gt;erlsrv&lt;/code&gt; during emulator restart. Locate the (possibly customized) &lt;code&gt;start_erl&lt;/code&gt; program so that it is not overwritten during upgrade.</source>
          <target state="translated">프로그램은 에뮬레이터 버전에 특정한 파일과 함께 위치하지만 에뮬레이터 버전에 특정한 것은 아닙니다. 릴리스 핸들러는 않습니다 &lt;strong&gt;되지&lt;/strong&gt; 옵션 변경 &lt;code&gt;-machine&lt;/code&gt; 을 에 &lt;code&gt;erlsrv&lt;/code&gt; 에뮬레이터 다시 시작하는 동안. 업그레이드하는 동안 덮어 쓰지 않도록 &lt;code&gt;start_erl&lt;/code&gt; 프로그램을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="3f57a9d4c00bcaabefc52fe8a80642733e554720" translate="yes" xml:space="preserve">
          <source>Although the record syntax is used, it is still hard to read and even harder to write. The first element of the tuple, &lt;code&gt;#emp{empno = '$1', dept = sales, _='_'}&lt;/code&gt;, tells what to match. Elements not matching this are not returned, as in the &lt;code&gt;ets:match/2&lt;/code&gt; example. The second element, the empty list, is a list of guard expressions, which we do not need. The third element is the list of expressions constructing the return value (in ETS this is almost always a list containing one single term). In our case &lt;code&gt;'$1'&lt;/code&gt; is bound to the employee number in the head (first element of the tuple), and hence the employee number is returned. The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;, as in the &lt;code&gt;ets:foldr/3&lt;/code&gt; example, but the result is retrieved much more efficiently in terms of execution speed and memory consumption.</source>
          <target state="translated">레코드 구문이 사용되지만 여전히 읽기가 어렵고 쓰기가 더 어렵습니다. 튜플의 첫 번째 요소 인 &lt;code&gt;#emp{empno = '$1', dept = sales, _='_'}&lt;/code&gt; 은 일치하는 항목을 알려줍니다. &lt;code&gt;ets:match/2&lt;/code&gt; 예제 와 같이 이것과 일치하지 않는 요소는 반환되지 않습니다 . 두 번째 요소 인 빈 목록은 우리가 필요로하지 않는 가드 표현식의 목록입니다. 세 번째 요소는 리턴 값을 구성하는 표현식 목록입니다 (ETS에서는 거의 항상 하나의 단일 용어를 포함하는 목록입니다). 이 경우 &lt;code&gt;'$1'&lt;/code&gt; 은 헤드의 직원 번호 (튜플의 첫 번째 요소)에 바인딩되므로 직원 번호가 반환됩니다. &lt;code&gt;ets:foldr/3&lt;/code&gt; 에서와 같이 결과는 &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt; 입니다. 예를 들어 결과는 실행 속도와 메모리 소비 측면에서 훨씬 더 효율적으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="2efab97f3a7a5d8ce0a89e59cc48828bf99d33d8" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;binary()&lt;/code&gt; when used as return value</source>
          <target state="translated">반환 값으로 사용될 때 항상 &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92fdd4e6d9d913fcd655491ab0c7675897f9b7ef" translate="yes" xml:space="preserve">
          <source>Always a back reference</source>
          <target state="translated">항상 역 참조</target>
        </trans-unit>
        <trans-unit id="34df78fa84d9ab6d470efe918d9b6fe7aa623768" translate="yes" xml:space="preserve">
          <source>Always a tab</source>
          <target state="translated">항상 탭</target>
        </trans-unit>
        <trans-unit id="a4786c7c8c425f21c582ab746681367ee698691a" translate="yes" xml:space="preserve">
          <source>Always derefrence aliases.</source>
          <target state="translated">항상 별칭을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f8137d77147791c2cdd31baefa8bf6fa8cd8ceff" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;ok&lt;/code&gt;, regardless of the validity of each individual &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">각 개별 &lt;code&gt;Dir&lt;/code&gt; 의 유효성에 관계없이 항상 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="27f040498856798609fee3be2f41e6c84980a8f5" translate="yes" xml:space="preserve">
          <source>Always use this function instead of the BIF for processes started using &lt;code&gt;proc_lib&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 함수를 사용하여 시작된 프로세스에는 항상 BIF 대신이 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1816d6498b5f2b91f67cb09f0eef413cb5e709bf" translate="yes" xml:space="preserve">
          <source>An  &lt;strong id=&quot;analyzed_module&quot;&gt;analyzed module&lt;/strong&gt; is a module that has been added to an Xref server together with its module data. A  &lt;strong id=&quot;library_module&quot;&gt;library module&lt;/strong&gt; is a module located in some directory mentioned in the  &lt;strong id=&quot;library_path&quot;&gt;library path&lt;/strong&gt;. A library module is said to be used if some of its exported functions are used by some analyzed module. An  &lt;strong id=&quot;unknown_module&quot;&gt;unknown module&lt;/strong&gt; is a module that is neither an analyzed module nor a library module, but whose exported functions are used by some analyzed module. An  &lt;strong id=&quot;unknown_function&quot;&gt;unknown function&lt;/strong&gt; is a used function that is neither local or exported by any analyzed module nor exported by any library module. An  &lt;strong id=&quot;undefined_function&quot;&gt;undefined function&lt;/strong&gt; is an externally used function that is not exported by any analyzed module or library module. With this notion, a local function can be an undefined function, namely if it is externally used from some module. All unknown functions are also undefined functions; there is a &lt;code&gt;&lt;a href=&quot;xref_chapter#venn2&quot;&gt;figure&lt;/a&gt;&lt;/code&gt; in the User's Guide that illustrates this relationship.</source>
          <target state="translated">&lt;strong id=&quot;analyzed_module&quot;&gt;분석 모듈은&lt;/strong&gt; 그 모듈의 데이터와 함께 외부 참조 서버에 추가 된 모듈이다. &lt;strong id=&quot;library_module&quot;&gt;라이브러리 모듈은&lt;/strong&gt; 에 언급 된 일부 디렉토리에있는 모듈 &lt;strong id=&quot;library_path&quot;&gt;라이브러리 경로&lt;/strong&gt; . 내 보낸 함수 중 일부가 분석 된 일부 모듈에서 사용되는 경우 라이브러리 모듈이 사용됩니다. &lt;strong id=&quot;unknown_module&quot;&gt;알 수없는 모듈은&lt;/strong&gt; 수출 기능 일부 분석 모듈에 의해 사용되는 분석 된 모듈이나 라이브러리 모듈 만도 아닌 모듈입니다. &lt;strong id=&quot;unknown_function&quot;&gt;알 수없는 함수는&lt;/strong&gt; 어느 지역 또는 라이브러리 모듈에 의해 임의의 분석 모듈에 의해 수출하거나 수출하는 사용되는 기능입니다. &lt;strong id=&quot;undefined_function&quot;&gt;정의 함수&lt;/strong&gt;분석 된 모듈 또는 라이브러리 모듈에서 내 보내지 않은 외부에서 사용되는 함수입니다. 이 개념을 통해 로컬 함수는 정의되지 않은 함수가 될 수 있습니다. 즉 일부 모듈에서 외부 적으로 사용되는 경우입니다. 알려지지 않은 모든 함수는 정의되지 않은 함수이기도합니다. 이 &lt;code&gt;&lt;a href=&quot;xref_chapter#venn2&quot;&gt;figure&lt;/a&gt;&lt;/code&gt; 이 관계를 보여 사용자 설명서는.</target>
        </trans-unit>
        <trans-unit id="61d493bfba03f3650f2161ca9afdcc61c11c1f50" translate="yes" xml:space="preserve">
          <source>An &quot;electric&quot; command is a character that in addition to just inserting the character performs some type of action. For example the &quot;;&quot; character is typed in a situation where is ends a function clause a new function header is generated. The electric commands are as follows:</source>
          <target state="translated">&quot;전기&quot;명령은 문자를 삽입하는 것 외에도 몇 가지 유형의 동작을 수행하는 문자입니다. 예를 들어 &quot;;&quot; 문자는 함수 절이 끝나는 상황에서 입력되며 새로운 함수 헤더가 생성됩니다. 전기 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6226e0305af70826bf5fe3ce4b1308a84190ed32" translate="yes" xml:space="preserve">
          <source>An &quot;index.html&quot; page is written for each test run (that is, stored in the &lt;code&gt;ct_run&lt;/code&gt; directory tagged with node name, date, and time). This file provides an overview of all individual tests performed in the same test run. The test names follow the following convention:</source>
          <target state="translated">&quot;index.html&quot;페이지는 각 테스트 실행에 대해 작성됩니다 (즉, 노드 이름, 날짜 및 시간으로 태그가 지정된 &lt;code&gt;ct_run&lt;/code&gt; 디렉토리에 저장 됨 ). 이 파일은 동일한 테스트 실행에서 수행 된 모든 개별 테스트에 대한 개요를 제공합니다. 테스트 이름은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="00e6ea986b63d5c9739d49f4c3238bab97235630" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0395f6f1fbeee27182938ba0839ebfac3dc6b9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#n_ary_relation&quot;&gt;n-ary relation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#n_ary_relation&quot;&gt;n-ary relation&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ad952e4eb8fcd79b39f9d7f3056d23ad1340548" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;ordered set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;ordered set&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f732501fb2f351bec1b39a9b35f38cdddbe7895e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; of unordered sets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; 정렬되지 않은 세트.</target>
        </trans-unit>
        <trans-unit id="abe550712a0e6ae829a57ff7d8dfef218ca5d4e5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0255682239807b3289c234495e03c8b41192e931" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Event&lt;/code&gt; may be an action performed by one single actor (blue text label) or it may involve two actors and is then depicted as an arrow directed from one actor to another (red text label). Details of an &lt;code&gt;Event&lt;/code&gt; can be shown by clicking (press and release the mouse button 1) on the event label text or on the arrow. When doing that a &lt;code&gt;Contents Viewer&lt;/code&gt; window pops up. It may look like this:</source>
          <target state="translated">&lt;code&gt;Event&lt;/code&gt; 하나 명의 연기자 (블루 텍스트 라벨)에 의해 수행되는 작업 일 수도 있고, 두 배우 포함될 수와는 다른 (적 텍스트 라벨) 한 배우에서 화살표로 지시 한 후 도시되어있다. 이벤트 레이블 텍스트 또는 화살표를 클릭 (마우스 단추 1을 눌렀다 놓음)하여 &lt;code&gt;Event&lt;/code&gt; 세부 사항을 표시 할 수 있습니다. 그렇게하면 &lt;code&gt;Contents Viewer&lt;/code&gt; 창이 나타납니다. 다음과 같이 보일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0255b57e28b30c83aed0be71d9a37eb90b3506e9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;FTP&lt;/code&gt; client.</source>
          <target state="translated">&lt;code&gt;FTP&lt;/code&gt; 클라이언트.</target>
        </trans-unit>
        <trans-unit id="3fb173ebbce3795b42d50041e455d5925eea1573" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Instantiator&lt;/code&gt; function receives the same value as the &lt;code&gt;Cleanup&lt;/code&gt; function, i.e., the value returned by the &lt;code&gt;Setup&lt;/code&gt; function. It should then behave much like a generator (see &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt;), and return a test set whose tests have been &lt;strong&gt;instantiated&lt;/strong&gt; with the given value. A special case is the syntax &lt;code&gt;{with, [AbstractTestFun]}&lt;/code&gt; which represents an instantiator function that distributes the value over a list of unary functions; see &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;{with, X, [...]}&lt;/code&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Instantiator&lt;/code&gt; 함수와 같은 값 수신 &lt;code&gt;Cleanup&lt;/code&gt; 즉 함수의 리턴 값으로 &lt;code&gt;Setup&lt;/code&gt; 기능. 그런 다음 생성기와 매우 유사하게 작동하고 ( &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 참조 ) 테스트가 지정된 값 으로 &lt;strong&gt;인스턴스화&lt;/strong&gt; 된 테스트 세트를 리턴 합니다. 특별한 경우는 &lt;code&gt;{with, [AbstractTestFun]}&lt;/code&gt; 구문 이며, 단항 함수 목록에 값을 분배하는 인스턴스화 함수를 나타냅니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;{with, X, [...]}&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="616e10ae1a8e1fb39bdb912ebeef6ab5ca6b40b1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;accept_callback()&lt;/code&gt; will be called and the boolean return value &lt;code&gt;true&lt;/code&gt; will make the client accept the Host Key. A return value of &lt;code&gt;false&lt;/code&gt; will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are:</source>
          <target state="translated">&lt;code&gt;accept_callback()&lt;/code&gt; 호출됩니다 및 부울 반환 값 &lt;code&gt;true&lt;/code&gt; 클라이언트가 호스트 키를 허용 할 것입니다. 반환 값이 &lt;code&gt;false&lt;/code&gt; 이면 클라이언트가 호스트 키를 거부하게되고 결과적으로 연결이 종료됩니다. 재미에 대한 주장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="413cf6d7a307b2b9673ad27e8dbed416e9a8cd0b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;atom&lt;/code&gt;, defaults to &lt;code&gt;megaco_pretty_text_encoder&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atom&lt;/code&gt; , 기본값 &lt;code&gt;megaco_pretty_text_encoder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa860461448cf61fc6c4412f7dfeeae18b2f5502" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;atom&lt;/code&gt;, defaults to &lt;code&gt;megaco_tcp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atom&lt;/code&gt; , 기본값하는 &lt;code&gt;megaco_tcp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51e3e48053897de71e5e9525b4fac400d5d8b48f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;boolean&lt;/code&gt;, default is true.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; , 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="a54f797ba37540946ac0de61f8e73f6a99a9bc1c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;boolean&lt;/code&gt;, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; , 기본값은 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7304f44642298f3032f1c5b607dd7eafc4c3c8ed" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval&lt;/code&gt; term for the node and &lt;code&gt;startup_functions&lt;/code&gt; in the &lt;code&gt;node_start&lt;/code&gt; options list can be specified. In this case, the node is started first, then the &lt;code&gt;startup_functions&lt;/code&gt; are executed, and finally functions specified with &lt;code&gt;eval&lt;/code&gt; are called.</source>
          <target state="translated">&lt;code&gt;node_start&lt;/code&gt; 옵션 목록 에서 node 및 &lt;code&gt;startup_functions&lt;/code&gt; 의 &lt;code&gt;eval&lt;/code&gt; 기간을 지정할 수 있습니다. 이 경우 노드가 먼저 시작된 다음 &lt;code&gt;startup_functions&lt;/code&gt; 가 실행되고 &lt;code&gt;eval&lt;/code&gt; 로 지정된 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf0639c1fa382f7a371e1fb9d74d243f730a9ec" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_cookie&lt;/code&gt; is the cookie expected to be used by another node when communicating with us, so that &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; corresponds with &lt;code&gt;B&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt;. Below the function &lt;code&gt;in_cookie(Node)&lt;/code&gt; returns the current node's &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in_cookie&lt;/code&gt; 는 그래서 우리와 통신 할 때 다른 노드에 의해 사용될 것으로 예상 쿠키이다 의 &lt;code&gt;in_cookie&lt;/code&gt; 대한 &lt;code&gt;B&lt;/code&gt; 의 대응 &lt;code&gt;B&lt;/code&gt; S ' &lt;code&gt;out_cookie&lt;/code&gt; 위한 . 함수 아래 &lt;code&gt;in_cookie(Node)&lt;/code&gt; 현재 노드의 반환 &lt;code&gt;in_cookie&lt;/code&gt; 에 대한 &lt;code&gt;Node&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d7e048e19b245a7755b67de29c724332d234fef" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;install&lt;/code&gt; program that can take multiple file names.</source>
          <target state="translated">여러 파일 이름을 사용할 수 있는 &lt;code&gt;install&lt;/code&gt; 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="dc1cc59f23e31d3f2faabd0e06404fca41020443" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer()&lt;/code&gt; representing a valid ISO Latin-1 character (0-255).</source>
          <target state="translated">&lt;code&gt;integer()&lt;/code&gt; 유효한 ISO 라틴어 1 문자 (255)를 나타내는.</target>
        </trans-unit>
        <trans-unit id="1e0bac35dea3f1f84ddba60032770d90571b70a9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, default is 1.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="873fbda47245c24d2fb8c42c588854a5bbbe1999" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 0.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 0으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0db32e18586f2823cb1832056d1faf59a25ee88d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 10.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , 10 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="be7525ff96efc958521012096b0629c32d985beb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 2048.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , 2048 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="226fe72bb662892694081c7e4669e49ce4dfb607" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ok&lt;/code&gt; return value only means that &lt;code&gt;sanity_check/0&lt;/code&gt; did not find any issues, &lt;strong&gt;not&lt;/strong&gt; that no issues exist.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 반환 값은 그 의미 &lt;code&gt;sanity_check/0&lt;/code&gt; 문제, 찾지 못했습니다 &lt;strong&gt;하지&lt;/strong&gt; 아무 문제가 없는지를.</target>
        </trans-unit>
        <trans-unit id="cb144d37fcad9dec67a783fea0c08715340b0e47" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ordered_set&lt;/code&gt; only guarantees that objects are processed in &lt;strong&gt;key&lt;/strong&gt; order. Results from functions such as &lt;code&gt;ets:select/2&lt;/code&gt; appear in &lt;strong&gt;key&lt;/strong&gt; order even if the key is not included in the result.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; 개체 만이 처리되는 것을 보장 &lt;strong&gt;키&lt;/strong&gt; 위해. 키가 결과에 포함되지 않은 경우에도 &lt;code&gt;ets:select/2&lt;/code&gt; 와 같은 기능의 결과 는 &lt;strong&gt;키&lt;/strong&gt; 순서로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="1ac32ce0e6bfa96623b07134d73e1a74a678a422" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;other_error()&lt;/code&gt;, indicates some other error such as timeout.</source>
          <target state="translated">&lt;code&gt;other_error()&lt;/code&gt; , 같은 시간 제한으로 다른 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c055e209749d7630d0667a2b7111dd1440c4439d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;other_reason()&lt;/code&gt;, indicates some other error such as:</source>
          <target state="translated">&lt;code&gt;other_reason()&lt;/code&gt; , 일부 다른 오류 등을 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="894fd973b7b8b5b01a93ed5aca695081618b3394" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;out_cookie&lt;/code&gt; is the cookie used in outgoing communication to a certain node, so that &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; is to correspond with &lt;code&gt;B&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; and conversely. &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; need &lt;strong&gt;not&lt;/strong&gt; be the same. Below the function &lt;code&gt;out_cookie(Node)&lt;/code&gt; returns the current node's &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out_cookie&lt;/code&gt; 가 되도록, 특정 노드로 발신 통신에 사용되는 쿠키이다 의 &lt;code&gt;out_cookie&lt;/code&gt; 대 &lt;code&gt;B&lt;/code&gt; 가 대응이고 &lt;code&gt;B&lt;/code&gt; 의 ' &lt;code&gt;in_cookie&lt;/code&gt; 위한 반대로. 의 &lt;code&gt;out_cookie&lt;/code&gt; 에 대한 &lt;code&gt;B&lt;/code&gt; 와 의 ' &lt;code&gt;in_cookie&lt;/code&gt; 에 대한 &lt;code&gt;B&lt;/code&gt; 는 필요 &lt;strong&gt;하지&lt;/strong&gt; 동일합니다. 함수 아래 &lt;code&gt;out_cookie(Node)&lt;/code&gt; 현재 노드의 반환 &lt;code&gt;out_cookie&lt;/code&gt; 에 대한 &lt;code&gt;Node&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7eef5074a9774a00c738e43d74f620a383d53d0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ssl_options&lt;/code&gt; list must be specified if and only if the transport in question has set &lt;code&gt;Inband-Security-Id&lt;/code&gt; to 1 (&lt;code&gt;TLS&lt;/code&gt;), as specified to either &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt;, so that the transport process will receive notification of whether or not to commence with a TLS handshake following capabilities exchange. Failing to specify an options list on a TLS-capable transport for which TLS is negotiated will cause TLS handshake to fail. Failing to specify TLS capability when &lt;code&gt;ssl_options&lt;/code&gt; has been specified will cause the transport process to wait for a notification that will not be forthcoming, which will eventually cause the RFC 3539 watchdog to take down the connection.</source>
          <target state="translated">&lt;code&gt;ssl_options&lt;/code&gt; 문제의 전송이 설정 한 경우에만 경우 목록을 지정해야 &lt;code&gt;Inband-Security-Id&lt;/code&gt; 1 (에 &lt;code&gt;TLS&lt;/code&gt; ) 중 하나에 지정된대로 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; , 그래서 전송 프로세스가 받게 될 것이라고 기능 교환 후 TLS 핸드 셰이크 시작 여부 알림 TLS가 협상되는 TLS 가능 전송에서 옵션 목록을 지정하지 않으면 TLS 핸드 셰이크가 실패합니다. &lt;code&gt;ssl_options&lt;/code&gt; 일 때 TLS 기능을 지정하지 못함 가 지정되면 전송 프로세스가 향후 알림을 기다리게되어 결국 RFC 3539 워치 독이 연결을 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="5953af02f70fe1bd6cb42949e24f0078af4d3ff4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;{outstream, Id}&lt;/code&gt; tuple in the &lt;code&gt;transport_data&lt;/code&gt; field of a outgoing diameter_packet record sets the outbound stream on which the message is sent, modulo the negotiated number of outbound streams. Any other value causes successive such sends to cycle though all outbound streams.</source>
          <target state="translated">나가는 diameter_packet 레코드 의 &lt;code&gt;transport_data&lt;/code&gt; 필드에 있는 &lt;code&gt;{outstream, Id}&lt;/code&gt; 튜플 은 메시지가 전송되는 아웃 바운드 스트림을 설정하여 협상 된 아웃 바운드 스트림 수를 조절합니다. 다른 모든 값은 모든 아웃 바운드 스트림을 통해 연속적으로 이러한 전송을 순환시킵니다.</target>
        </trans-unit>
        <trans-unit id="d5fa362d0f65e987c4b8318080cab175e37513ad" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;acyclic_digraph&quot;&gt;acyclic digraph&lt;/strong&gt; is a digraph without cycles.</source>
          <target state="translated">&lt;strong id=&quot;acyclic_digraph&quot;&gt;비순환 소리를 나타내는 두 글자는&lt;/strong&gt; 사이클이없는 소리를 나타내는 두 글자입니다.</target>
        </trans-unit>
        <trans-unit id="c3aa68fd8d0814a5d205c457e0d32e4bc17b0175" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;arborescence&quot;&gt;arborescence&lt;/strong&gt; is an acyclic digraph with a vertex V, the &lt;strong id=&quot;root&quot;&gt;root&lt;/strong&gt;, such that there is a unique path from V to every other vertex of G.</source>
          <target state="translated">&lt;strong id=&quot;arborescence&quot;&gt;arborescence는&lt;/strong&gt; 정점 V의과 비순환 소리를 나타내는 두 글자입니다 &lt;strong id=&quot;root&quot;&gt;루트&lt;/strong&gt; G.의 다른 모든 정점 V의 고유 경로가되도록,</target>
        </trans-unit>
        <trans-unit id="742a6d0f8438c960e1610deecf0bc0fce6d56d78" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;external_set&quot;&gt;external set&lt;/strong&gt; is an element of the range of Sets.</source>
          <target state="translated">&lt;strong id=&quot;external_set&quot;&gt;외부 세트는&lt;/strong&gt; 세트의 범위의 원소이다.</target>
        </trans-unit>
        <trans-unit id="edf6ff8399e6bc41f3e349775438bc0fb18b7111" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;embedded target system&lt;/strong&gt; where there is also support for logging output from the system to file for later inspection, and where the system can be started automatically at boot time.</source>
          <target state="translated">나중에 검사를 위해 시스템에서 파일로 출력을 로깅하는 기능도 지원하며 부팅시 시스템을 자동으로 시작할 수 있는 &lt;strong&gt;내장 대상 시스템&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="380c35ec1379b2732006ec744451c0160e09d7d7" translate="yes" xml:space="preserve">
          <source>An ASN.1 compiler for Erlang, which generates encode and decode functions to be used by Erlang programs sending and receiving ASN.1 specified data.</source>
          <target state="translated">Erlang 용 ASN.1 컴파일러. ASN.1 지정 데이터를 송수신하는 Erlang 프로그램에서 사용할 인코딩 및 디코딩 기능을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2072c4a338574b8129ce6b5952267c903a250059" translate="yes" xml:space="preserve">
          <source>An Alarm Handling Process</source>
          <target state="translated">경보 처리 프로세스</target>
        </trans-unit>
        <trans-unit id="23ba32dda2e50be421eaa9dbe7743df19b802a29" translate="yes" xml:space="preserve">
          <source>An Erlang code preprocessor.</source>
          <target state="translated">Erlang 코드 전 처리기.</target>
        </trans-unit>
        <trans-unit id="163e8de0a613994fca6438b452c975b50aeb03f4" translate="yes" xml:space="preserve">
          <source>An Erlang crash dump is produced with &lt;code&gt;Status&lt;/code&gt; as slogan. Then the runtime system exits with status code &lt;code&gt;1&lt;/code&gt;. The string will be truncated if longer than 200 characters.</source>
          <target state="translated">Erlang 크래시 덤프는 &lt;code&gt;Status&lt;/code&gt; 를 슬로건으로 생성 합니다. 그런 다음 런타임 시스템은 상태 코드 &lt;code&gt;1&lt;/code&gt; 로 종료됩니다 . 200자를 초과하면 문자열이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4512b1e2b9f7565d7aad070a59e6db442ba6e364" translate="yes" xml:space="preserve">
          <source>An Erlang driver is a library containing a set of native driver callback functions that the Erlang Virtual Machine calls when certain events occur. There can be multiple instances of a driver, each instance is associated with an Erlang port.</source>
          <target state="translated">Erlang 드라이버는 특정 이벤트가 발생할 때 Erlang 가상 머신이 호출하는 기본 드라이버 콜백 함수 세트를 포함하는 라이브러리입니다. 드라이버의 인스턴스는 여러 개있을 수 있으며 각 인스턴스는 Erlang 포트와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="46d02d2d1f7bf010b89b68c50051d352cdf1f1c7" translate="yes" xml:space="preserve">
          <source>An Erlang driver is a native code module written in C (or assembler), which serves as an interface for some special operating system service. This is a general mechanism that is used throughout the Erlang emulator for all kinds of I/O. An Erlang driver can be dynamically linked (or loaded) to the Erlang emulator at runtime by using the &lt;code&gt;erl_ddll&lt;/code&gt; Erlang module. Some of the drivers in OTP are however statically linked to the runtime system, but that is more an optimization than a necessity.</source>
          <target state="translated">Erlang 드라이버는 C (또는 어셈블러)로 작성된 고유 코드 모듈이며 일부 특수 운영 체제 서비스의 인터페이스 역할을합니다. 이것은 모든 종류의 I / O에 대해 Erlang 에뮬레이터 전체에서 사용되는 일반적인 메커니즘입니다. Erlang 드라이버는 런타임에 &lt;code&gt;erl_ddll&lt;/code&gt; Erlang 모듈 을 사용하여 Erlang 에뮬레이터에 동적으로 링크 (또는로드) 될 수 있습니다 . 그러나 OTP의 일부 드라이버는 런타임 시스템에 정적으로 링크되어 있지만 이는 필요 이상으로 최적화 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9d5ba03efbb958aec77ffebac7f1f229efa740a" translate="yes" xml:space="preserve">
          <source>An Erlang driver only exports one function: the driver entry function. This is defined with a macro, &lt;code&gt;DRIVER_INIT&lt;/code&gt;, which returns a pointer to a C &lt;code&gt;struct&lt;/code&gt; containing the entry points that are called from the emulator. The &lt;code&gt;struct&lt;/code&gt; defines the entries that the emulator calls to call the driver, with a &lt;code&gt;NULL&lt;/code&gt; pointer for entries that are not defined and used by the driver.</source>
          <target state="translated">Erlang 드라이버는 드라이버 입력 기능이라는 하나의 기능 만 내 보냅니다. 이것은 매크로 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 로 정의되며 에뮬레이터에서 호출 된 진입 점을 포함 하는 C &lt;code&gt;struct&lt;/code&gt; 대한 포인터를 반환합니다 . &lt;code&gt;struct&lt;/code&gt; 에뮬레이터가 함께 드라이버를 호출하는 호출하는 항목을 정의 &lt;code&gt;NULL&lt;/code&gt; 의 정의 및 드라이버에 의해 사용되지 않는 항목에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="bd548a3ef940c79c88bddfa47cccbd8fb1829c8b" translate="yes" xml:space="preserve">
          <source>An Erlang module containing a collection of test cases for a specific functional area.</source>
          <target state="translated">특정 기능 영역에 대한 테스트 사례 모음이 포함 된 Erlang 모듈.</target>
        </trans-unit>
        <trans-unit id="ad9ae30d2c55cc4178422772dd42ca73a04b1365" translate="yes" xml:space="preserve">
          <source>An Erlang node acting as a client to another Erlang node typically sends a request and waits for a reply. Such a request is included in a function call at a remote node and is called a remote procedure call.</source>
          <target state="translated">다른 Erlang 노드에 대한 클라이언트 역할을하는 Erlang 노드는 일반적으로 요청을 보내고 응답을 기다립니다. 이러한 요청은 원격 노드의 함수 호출에 포함되며이를 원격 프로 시저 호출이라고합니다.</target>
        </trans-unit>
        <trans-unit id="56710ac893f31a54d4164ee165dd753222462531" translate="yes" xml:space="preserve">
          <source>An Erlang node is started using command-line flag &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt;:</source>
          <target state="translated">Erlang 노드는 명령 행 플래그 &lt;code&gt;-name&lt;/code&gt; 또는 &lt;code&gt;-sname&lt;/code&gt; 을 사용하여 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="599c98b38dfe8d71da51449f0bdd899eee1b39d4" translate="yes" xml:space="preserve">
          <source>An Erlang node name has the form host@shortname or host@longname. The node name is used as an atom within the system, so the maximum size of 255 holds also for the node name.</source>
          <target state="translated">Erlang 노드 이름은 host @ shortname 또는 host @ longname 형식입니다. 노드 이름은 시스템 내에서 원자로 사용되므로 최대 255 개의 노드 이름도 보유합니다.</target>
        </trans-unit>
        <trans-unit id="1e0759134862f9ad1e90191482caa5537f8967ba" translate="yes" xml:space="preserve">
          <source>An Erlang pattern is a term that can contain unbound variables or &lt;code&gt;&quot;do not care&quot;&lt;/code&gt; symbols. Such a pattern can be matched against a term and, if the match is successful, any unbound variables in the pattern will be bound as a side effect. The content of a bound variable can then be retrieved:</source>
          <target state="translated">Erlang 패턴은 언 바운드 변수 또는 &lt;code&gt;&quot;do not care&quot;&lt;/code&gt; 무정의 &quot; 기호를 포함 할 수있는 용어입니다 . 이러한 패턴은 용어와 일치시킬 수 있으며, 일치하는 경우 패턴의 바인딩되지 않은 변수는 부작용으로 바인딩됩니다. 그런 다음 바인딩 된 변수의 내용을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1200c0da52a399921a5c78fb7e044cea6d860a20" translate="yes" xml:space="preserve">
          <source>An Erlang process (conceptually) runs until it does a &lt;code&gt;receive&lt;/code&gt; and there is no message which it wants to receive in the message queue. &quot;conceptually&quot; is used here because the Erlang system shares the CPU time between the active processes in the system.</source>
          <target state="translated">그것은이 않습니다 때까지 얼랑 프로세스 (개념)를 실행 &lt;code&gt;receive&lt;/code&gt; 하고 메시지 큐에서 수신하고자하는 어떤 메시지가 없습니다. Erlang 시스템이 시스템의 활성 프로세스간에 CPU 시간을 공유하기 때문에 여기서 &quot;개념적으로&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51ffaec9560fba4d779993b121c3d8e77dcf2ff0" translate="yes" xml:space="preserve">
          <source>An Erlang process can set up links to other Erlang processes. If a process calls &lt;code&gt;link(Other_Pid)&lt;/code&gt; it sets up a bidirectional link between itself and the process called &lt;code&gt;Other_Pid&lt;/code&gt;. When a process terminates, it sends something called a &lt;strong&gt;signal&lt;/strong&gt; to all the processes it has links to.</source>
          <target state="translated">Erlang 프로세스는 다른 Erlang 프로세스에 대한 링크를 설정할 수 있습니다. 프로세스가 &lt;code&gt;link(Other_Pid)&lt;/code&gt; 호출하면 자체 프로세스와 &lt;code&gt;Other_Pid&lt;/code&gt; 프로세스 사이에 양방향 링크를 설정합니다 . 프로세스가 종료되면 링크 된 모든 프로세스에 &lt;strong&gt;신호&lt;/strong&gt; 라는 &lt;strong&gt;신호&lt;/strong&gt; 를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="9970a8a7b56df81fb08ac05a8463925914e6cf12" translate="yes" xml:space="preserve">
          <source>An Erlang process is lightweight compared to threads and processes in operating systems.</source>
          <target state="translated">Erlang 프로세스는 운영 체제의 스레드 및 프로세스에 비해 경량입니다.</target>
        </trans-unit>
        <trans-unit id="09a9e4871d3bc24cfef4abf9dd5b18af33c141ab" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system internal memory allocator library.</source>
          <target state="translated">Erlang 런타임 시스템 내부 메모리 할당 자 라이브러리.</target>
        </trans-unit>
        <trans-unit id="e0378125a458b38016849cc67d1615f3807c8d9e" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system is made a distributed Erlang node by giving it a name. A distributed Erlang node can connect to, and monitor, other nodes. It can also spawn processes at other nodes. Message passing and error handling between processes at different nodes are transparent. A number of useful STDLIB modules are available in a distributed Erlang system. For example, &lt;code&gt;global&lt;/code&gt;, which provides global name registration. The distribution mechanism is implemented using TCP/IP sockets.</source>
          <target state="translated">Erlang 런타임 시스템은 이름을 지정하여 분산 Erlang 노드가됩니다. 분산 Erlang 노드는 다른 노드에 연결하고 모니터링 할 수 있습니다. 다른 노드에서 프로세스를 생성 할 수도 있습니다. 서로 다른 노드에서 프로세스 간 메시지 전달 및 오류 처리는 투명합니다. 분산 Erlang 시스템에는 여러 유용한 STDLIB 모듈이 있습니다. 예를 들어 &lt;code&gt;global&lt;/code&gt; 은 글로벌 이름 등록을 제공합니다. 분배 메커니즘은 TCP / IP 소켓을 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="04046988b941940151b9b5fc8a82309ae841ddb6" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system is started with command &lt;code&gt;erl&lt;/code&gt;:</source>
          <target state="translated">Erlang 런타임 시스템은 &lt;code&gt;erl&lt;/code&gt; 명령으로 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="3393487efc373a12bc45e05f1eacb861280e2ede" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system to be monitored by a heart program is to be started with command-line flag &lt;code&gt;-heart&lt;/code&gt; (see also &lt;code&gt;erl(1)&lt;/code&gt;). The &lt;code&gt;heart&lt;/code&gt; process is then started automatically:</source>
          <target state="translated">심장 프로그램으로 모니터링 할 Erlang 런타임 시스템은 명령 행 플래그 &lt;code&gt;-heart&lt;/code&gt; 로 시작해야합니다 ( &lt;code&gt;erl(1)&lt;/code&gt; ). &lt;code&gt;heart&lt;/code&gt; 프로세스는 자동으로 시작됩니다 :</target>
        </trans-unit>
        <trans-unit id="f733ec70702901146b379fda30a66a57a35b70fb" translate="yes" xml:space="preserve">
          <source>An Erlang script file must always contain the &lt;code&gt;main/1&lt;/code&gt; function. When the script is run, the &lt;code&gt;main/1&lt;/code&gt; function is called with a list of strings representing the arguments specified to the script (not changed or interpreted in any way).</source>
          <target state="translated">Erlang 스크립트 파일은 항상 &lt;code&gt;main/1&lt;/code&gt; 함수를 포함해야합니다 . 스크립트가 실행될 때 &lt;code&gt;main/1&lt;/code&gt; 함수는 스크립트에 지정된 인수를 나타내는 문자열 목록과 함께 호출됩니다 (어떤 방식 으로든 변경되거나 해석되지 않음).</target>
        </trans-unit>
        <trans-unit id="73dec7304e5c6b791062b7b3aca15db293d62078" translate="yes" xml:space="preserve">
          <source>An Erlang session must be started and a &lt;code&gt;Mnesia&lt;/code&gt; directory must be specified for the database.</source>
          <target state="translated">Erlang 세션을 시작하고 데이터베이스에 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce5518b8587007e4c494155014d3a550a3741ae1" translate="yes" xml:space="preserve">
          <source>An Erlang term is represented by a C structure of type &lt;code&gt;ETERM&lt;/code&gt;. Applications should not reference any fields in this structure directly, as it can be changed in future releases to provide faster and more compact term storage. Instead, applications should use the macros and functions provided.</source>
          <target state="translated">Erlang 용어는 &lt;code&gt;ETERM&lt;/code&gt; 유형의 C 구조로 표시됩니다 . 애플리케이션은이 구조에서 필드를 직접 참조하면 안됩니다. 향후 릴리스에서 더 빠르고 컴팩트 한 용어 저장소를 제공하기 위해 변경 될 수 있기 때문입니다. 대신 응용 프로그램은 제공된 매크로와 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="164c80b922f57a9bdd50001a74df476a789dbd1f" translate="yes" xml:space="preserve">
          <source>An Erlang/OTP installation.</source>
          <target state="translated">Erlang / OTP 설치.</target>
        </trans-unit>
        <trans-unit id="1054640745b3e48822c3fd2338dfbcd899d7c1b8" translate="yes" xml:space="preserve">
          <source>An Erlang/OTP source tree containing the updated applications that you want to patch into the existing Erlang/OTP installation.</source>
          <target state="translated">기존 Erlang / OTP 설치에 패치하려는 업데이트 된 응용 프로그램이 포함 된 Erlang / OTP 소스 트리.</target>
        </trans-unit>
        <trans-unit id="33e5f51ee47766fa568bcc250e6552444bf87f73" translate="yes" xml:space="preserve">
          <source>An Ets table is a single-key table (either a hash table or a tree ordered by the key) and is to be used as one. In other words, use the key to look up things whenever possible. A lookup by a known key in a &lt;code&gt;set&lt;/code&gt; Ets table is constant and for an &lt;code&gt;ordered_set&lt;/code&gt; Ets table it is O(logN). A key lookup is always preferable to a call where the whole table has to be scanned. In the previous examples, the field &lt;code&gt;idno&lt;/code&gt; is the key of the table and all lookups where only the name is known result in a complete scan of the (possibly large) table for a matching result.</source>
          <target state="translated">Ets 테이블은 단일 키 테이블 (해시 테이블 또는 키로 정렬 된 트리)이며 하나로 사용됩니다. 다시 말해, 가능할 때마다 키를 사용하여 사물을 찾으십시오. &lt;code&gt;set&lt;/code&gt; Ets 테이블 에서 알려진 키에 의한 조회 는 일정하며 &lt;code&gt;ordered_set&lt;/code&gt; Ets 테이블의 경우 O (logN)입니다. 키 조회는 항상 전체 테이블을 스캔해야하는 호출보다 선호됩니다. 이전 예제에서 필드 &lt;code&gt;idno&lt;/code&gt; 는 테이블의 키이며 이름 만 알려진 모든 조회는 일치하는 결과에 대해 (아마도 큰) 테이블을 완전히 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="a7cf253c697b4afabd6dffd4bbe2047b45daa497" translate="yes" xml:space="preserve">
          <source>An Extensible multi-lingual SNMP agent, which understands SNMPv1 (RFC1157), SNMPv2c (RFC1901, 1905, 1906 and 1907), SNMPv3 (RFC2271, 2272, 2273, 2274 and 2275), or any combination of these protocols.</source>
          <target state="translated">SNMPv1 (RFC1157), SNMPv2c (RFC1901, 1905, 1906 및 1907), SNMPv3 (RFC2271, 2272, 2273, 2274 및 2275) 또는 이러한 프로토콜의 조합을 이해하는 확장 가능한 다국어 SNMP 에이전트.</target>
        </trans-unit>
        <trans-unit id="05553bae8eb36ff1c70b542ddf36a56af29990c8" translate="yes" xml:space="preserve">
          <source>An FTP client can be started in two ways. One is using the &lt;code&gt;&lt;a href=&quot;#service_start&quot;&gt;service_start&lt;/a&gt;&lt;/code&gt; function, the other is to start it directly as a standalone process using function &lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP 클라이언트는 두 가지 방법으로 시작할 수 있습니다. 하나는 &lt;code&gt;&lt;a href=&quot;#service_start&quot;&gt;service_start&lt;/a&gt;&lt;/code&gt; 함수를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 독립형 프로세스로 직접 시작하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="142111236af13f256edac0459b9be958dddb9369" translate="yes" xml:space="preserve">
          <source>An HTTP client and server</source>
          <target state="translated">HTTP 클라이언트 및 서버</target>
        </trans-unit>
        <trans-unit id="2afe7b47404b7ad13ca9bd0ff2a980472ed68c85" translate="yes" xml:space="preserve">
          <source>An HTTP client can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application or started dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpc, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpc, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options are as follows:</source>
          <target state="translated">HTTP 클라이언트가 시작할 때 시작되도록 구성 할 수 있습니다 &lt;code&gt;Inets&lt;/code&gt; 의 호출에 의해 응용 프로그램 또는 런타임에 동적으로 시작 &lt;code&gt;Inets&lt;/code&gt; 애플리케이션 API의 &lt;code&gt;inets:start(httpc, ServiceConfig)&lt;/code&gt; 하거나 &lt;code&gt;inets:start(httpc, ServiceConfig, How)&lt;/code&gt; , 볼 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; . 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac94cd7f217b34f41616cfaaff0e53eb269f96bc" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 client</source>
          <target state="translated">HTTP / 1.1 클라이언트</target>
        </trans-unit>
        <trans-unit id="42eecf40b49071e953314f2ad636039400fdbb0d" translate="yes" xml:space="preserve">
          <source>An I/O device, either &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, a registered name, or a pid handling I/O protocols (returned from &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">I / O 장치 ( &lt;code&gt;standard_io&lt;/code&gt; , &lt;code&gt;standard_error&lt;/code&gt; , 등록 된 이름 또는 pid 처리 I / O 프로토콜 ( &lt;code&gt;file:open/2&lt;/code&gt; 에서 반환 ))</target>
        </trans-unit>
        <trans-unit id="ae711fee4d3a7baed5f9d46d07c066788a61f314" translate="yes" xml:space="preserve">
          <source>An I/O server in binary mode affects the data sent to the client, so that it must be able to handle binary data. For convenience, the modes of an I/O server can be set and retrieved using the following I/O requests:</source>
          <target state="translated">이진 모드의 I / O 서버는 클라이언트로 전송 된 데이터에 영향을 미치므로 이진 데이터를 처리 할 수 ​​있어야합니다. 편의를 위해 I / O 서버의 모드는 다음 I / O 요청을 사용하여 설정 및 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b62015dba8d016181c61cc4f29681a2a099c1f41" translate="yes" xml:space="preserve">
          <source>An I/O server is any process capable of handling the I/O protocol. There is no generic I/O server behavior, but could well be. The framework is simple, a process handling incoming requests, usually both I/O-requests and other I/O device-specific requests (positioning, closing, and so on).</source>
          <target state="translated">I / O 서버는 I / O 프로토콜을 처리 할 수있는 모든 프로세스입니다. 일반적인 I / O 서버 동작은 없지만 그럴 수 있습니다. 프레임 워크는 들어오는 요청, 일반적으로 I / O 요청 및 기타 I / O 장치 별 요청 (포지셔닝, 닫기 등)을 처리하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="71aa558a385dde730a823188e9e6c5a3a9ad8c43" translate="yes" xml:space="preserve">
          <source>An I/O vector containing &lt;code&gt;iovcnt&lt;/code&gt;&lt;code&gt;SysIOVec&lt;/code&gt;s pointing to the data. It is used by &lt;code&gt;&lt;a href=&quot;#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enif_ioq_enqv&quot;&gt;enif_ioq_enqv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">데이터를 가리키는 &lt;code&gt;iovcnt&lt;/code&gt; &lt;code&gt;SysIOVec&lt;/code&gt; 을 포함하는 I / O 벡터 . &lt;code&gt;&lt;a href=&quot;#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enif_ioq_enqv&quot;&gt;enif_ioq_enqv&lt;/a&gt;&lt;/code&gt; 에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="41130f0f20d700a7cd9c6bd00e3e478bc7b4d3be" translate="yes" xml:space="preserve">
          <source>An IP datagram header is of variable length. This length is measured in the number of 32-bit words and is given in the segment corresponding to &lt;code&gt;HLen&lt;/code&gt;. The minimum value of &lt;code&gt;HLen&lt;/code&gt; is 5. It is the segment corresponding to &lt;code&gt;Opts&lt;/code&gt; that is variable, so if &lt;code&gt;HLen&lt;/code&gt; is equal to 5, &lt;code&gt;Opts&lt;/code&gt; becomes an empty binary.</source>
          <target state="translated">IP 데이터 그램 헤더의 길이는 가변적입니다. 이 길이는 32 비트 워드 수로 측정되며 &lt;code&gt;HLen&lt;/code&gt; 에 해당하는 세그먼트에 제공됩니다 . &lt;code&gt;HLen&lt;/code&gt; 의 최소값 은 5 입니다. 가변적 인 &lt;code&gt;Opts&lt;/code&gt; 에 해당하는 세그먼트 이므로 &lt;code&gt;HLen&lt;/code&gt; 이 5 인 경우 &lt;code&gt;Opts&lt;/code&gt; 는 빈 이진이됩니다.</target>
        </trans-unit>
        <trans-unit id="8b34d40f0dbe3b588d3da6f27a42d0abb207e154" translate="yes" xml:space="preserve">
          <source>An LALR-1 parser generator for Erlang, similar to &lt;code&gt;yacc&lt;/code&gt;. Takes a BNF grammar definition as input, and produces Erlang code for a parser.</source>
          <target state="translated">Ercc 용 LALR-1 파서 생성기 . &lt;code&gt;yacc&lt;/code&gt; 와 유사합니다 . BNF 문법 정의를 입력으로 받아서 구문 분석기에 대한 Erlang 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f4de0ab059529b74fa404e77bd9bce10ca57adb" translate="yes" xml:space="preserve">
          <source>An MGC must initiate its transport service in order to listen to MG's trying to connect. How the actual transport is initiated is outside the scope of this application. However a send handle (typically a socket id or host and port) must be provided from the transport service in order to enable us to send the message to the correct destination. We do however not assume anything about this, from our point of view, opaque handle. Hopefully it is rather small since it will passed around the system between processes rather frequently.</source>
          <target state="translated">MGC의 연결 시도를 들으려면 MGC가 전송 서비스를 시작해야합니다. 실제 전송이 시작되는 방법은이 응용 프로그램의 범위를 벗어납니다. 그러나 메시지를 올바른 대상으로 보낼 수 있으려면 전송 서비스에서 전송 핸들 (일반적으로 소켓 ID 또는 호스트 및 포트)을 제공해야합니다. 그러나 우리는 불투명 한 핸들이라는 관점에서 이것에 대해 아무 것도 가정하지 않습니다. 바라건대 프로세스간에 시스템을 자주 통과하기 때문에 다소 작습니다.</target>
        </trans-unit>
        <trans-unit id="3f19384fb5f4be8e031ef20ebc7f31d2d84b520a" translate="yes" xml:space="preserve">
          <source>An MIB view is a collection of included and excluded sub-trees. A sub-tree is identified by an OBJECT IDENTIFIER. A mask is associated with each sub-tree.</source>
          <target state="translated">MIB보기는 포함 및 제외 된 하위 트리의 모음입니다. 하위 트리는 객체 식별자로 식별됩니다. 마스크는 각 하위 트리와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a21abf65ff184b2ac5dfa83b3fd2726d82ff5f71" translate="yes" xml:space="preserve">
          <source>An RFC 3539 watchdog state machine has changed state.</source>
          <target state="translated">RFC 3539 워치 독 상태 시스템의 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="3111bfc27ffe841290b619c09a5ae5ead1e40f85" translate="yes" xml:space="preserve">
          <source>An RSA private key encrypted with a password can look as follows:</source>
          <target state="translated">비밀번호로 암호화 된 RSA 개인 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc7347d7de31b66546bd97686f70b5b899b1f5d0" translate="yes" xml:space="preserve">
          <source>An SFTP client (&lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftp&lt;/a&gt;&lt;/code&gt;) and server (&lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftpd&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">SFTP 클라이언트 ( &lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftp&lt;/a&gt;&lt;/code&gt; ) 및 서버 ( &lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftpd&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c30ebe58cf85f0d3449f206c0fc62e2bc8c29633" translate="yes" xml:space="preserve">
          <source>An SNMP &lt;strong&gt;community&lt;/strong&gt; is a relationship between an SNMP agent and a set of SNMP managers that defines authentication, access control and proxy characteristics.</source>
          <target state="translated">SNMP &lt;strong&gt;커뮤니티&lt;/strong&gt; 는 SNMP 에이전트와 인증, 액세스 제어 및 프록시 특성을 정의하는 일련의 SNMP 관리자 간의 관계입니다.</target>
        </trans-unit>
        <trans-unit id="5c02aa7e99ca473f6341708b73eb0f8e28713993" translate="yes" xml:space="preserve">
          <source>An SNMPv3 agent must implement the SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB. These MIBs are loaded by default, if the agent is configured for SNMPv3. These MIBs can be loaded for other versions as well.</source>
          <target state="translated">SNMPv3 에이전트는 SNMP-FRAMEWORK-MIB 및 SNMP-MPD-MIB를 구현해야합니다. 에이전트가 SNMPv3에 대해 구성된 경우 이러한 MIB가 기본적으로로드됩니다. 이 MIB는 다른 버전에도로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6913d726a46e4ef23b14ab9fbfca01ba07d162" translate="yes" xml:space="preserve">
          <source>An abstract character-based &quot;document&quot; representing a number of possible layouts, which can be processed to produce a single concrete layout. A concrete layout can then be rendered as a sequence of characters containing linebreaks, which can be passed to a printer or terminal that uses a fixed-width font.</source>
          <target state="translated">다수의 가능한 레이아웃을 나타내는 추상 문자 기반 &quot;문서&quot;. 단일 콘크리트 레이아웃을 생성하기 위해 처리 될 수 있습니다. 그런 다음 구체적인 레이아웃을 줄 바꿈이 포함 된 일련의 문자로 렌더링하여 고정 너비 글꼴을 사용하는 프린터 나 터미널로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec400c22d9bf133e13c29bd14a5a46147f57249" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree. See the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module for details.</source>
          <target state="translated">추상 구문 트리. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7ca6b5f69a072fd3b2d3d406795b2d4821be23" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree. The &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; &quot;parse tree&quot; representation is a proper subset of the &lt;code&gt;syntaxTree()&lt;/code&gt; representation.</source>
          <target state="translated">추상 구문 트리. &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; &quot;파스 트리&quot;표현의 부분 집합이다 &lt;code&gt;syntaxTree()&lt;/code&gt; 의 표현.</target>
        </trans-unit>
        <trans-unit id="e5d3cde78159d4684ac47feb70581b71c34485ec" translate="yes" xml:space="preserve">
          <source>An additional filter, &lt;code&gt;integer(X)&lt;/code&gt;, can be added to restrict the result to integers:</source>
          <target state="translated">추가 필터 &lt;code&gt;integer(X)&lt;/code&gt; 를 추가하여 결과를 정수로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6cdc456e7459d3c957081ebfa2dcff54001d0a" translate="yes" xml:space="preserve">
          <source>An address list is available to the start function of a &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt;, which can return a new list for use in the subsequent CER or CEA. Host-IP-Address need not be specified if the transport module in question communicates an address list as described in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주소 목록은 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; 의 시작 기능에 사용 가능하며 후속 CER 또는 CEA에서 사용할 새 목록을 리턴 할 수 있습니다. 해당 전송 모듈이 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 설명 된대로 주소 목록을 통신하는 경우 호스트 IP 주소를 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1e1407ae2e41532b81ffc2fdaec5e23d7093e2d" translate="yes" xml:space="preserve">
          <source>An agent can have many MIBs loaded at the same time.</source>
          <target state="translated">에이전트는 동시에 많은 MIB를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f492d7625cc14110ff6afa2865fa5e903887bda9" translate="yes" xml:space="preserve">
          <source>An agent responds to commands from the manager, and sends notification to the manager. There are potentially many agents in a system.</source>
          <target state="translated">에이전트는 관리자의 명령에 응답하고 관리자에게 알림을 보냅니다. 시스템에 잠재적으로 많은 에이전트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca2e691f8fc810a8b8ce022a203ae58e956a286d" translate="yes" xml:space="preserve">
          <source>An algorithm is selected for computing a secret encryption key. Among examples are: the old nowadays week &lt;code&gt;'diffie-hellman-group-exchange-sha1'&lt;/code&gt; and the very strong and modern &lt;code&gt;'ecdh-sha2-nistp512'&lt;/code&gt;.</source>
          <target state="translated">비밀 암호화 키를 계산하기위한 알고리즘이 선택됩니다. 예를 들면 다음과 같습니다 : 옛날 요일 &lt;code&gt;'diffie-hellman-group-exchange-sha1'&lt;/code&gt; 및 매우 강력하고 현대적인 &lt;code&gt;'ecdh-sha2-nistp512'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40a51c62e24096d5cc5decd65a67cd1b36502a80" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;utf8&lt;/code&gt;, as this is the preferred encoding for Unicode characters in binaries.</source>
          <target state="translated">바이너리의 유니 코드 문자에 대해 선호되는 인코딩이므로 &lt;code&gt;utf8&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="e889063dded89fc29b40235f1212d83a1c277549" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;{utf16,big}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{utf16,big}&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="2d83d259ee7d8e8db95f58d4f28b7d2b435fc514" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;{utf32,big}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{utf32,big}&lt;/code&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="77817f9811fa0bbd6bf15b9e08ba9162578eb833" translate="yes" xml:space="preserve">
          <source>An alias for debug.</source>
          <target state="translated">디버그 별명.</target>
        </trans-unit>
        <trans-unit id="44d338f0d6e24a84de02e7eea09361912aac703c" translate="yes" xml:space="preserve">
          <source>An alias for none.</source>
          <target state="translated">없음의 별명.</target>
        </trans-unit>
        <trans-unit id="47cdcc943c5527c2b6d51204fba8e07c3ec38fe4" translate="yes" xml:space="preserve">
          <source>An allocator manages multiple areas, called carriers, in which memory blocks are placed. A carrier is either placed in a separate memory segment (allocated through &lt;code&gt;mseg_alloc&lt;/code&gt;), or in the heap segment (allocated through &lt;code&gt;sys_alloc&lt;/code&gt;).</source>
          <target state="translated">할당자는 메모리 블록이 배치되는 캐리어라고하는 여러 영역을 관리합니다. 캐리어는 별도의 메모리 세그먼트 ( &lt;code&gt;mseg_alloc&lt;/code&gt; 을 통해 할당 됨 ) 또는 힙 세그먼트 ( &lt;code&gt;sys_alloc&lt;/code&gt; 를 통해 할당 됨 )에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="6febbd430369646d426d8b717469d67277d0bee6" translate="yes" xml:space="preserve">
          <source>An alternative &lt;code&gt;RequestURI&lt;/code&gt; has been generated.</source>
          <target state="translated">대체 &lt;code&gt;RequestURI&lt;/code&gt; 가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef675fb1db408db7ca8ad5c68c12c4eb53d35683" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use named parentheses instead. The Perl syntax for this is (?&amp;amp;name). The earlier PCRE syntax (?P&amp;gt;name) is also supported. We can rewrite the above example as follows:</source>
          <target state="translated">다른 방법은 명명 된 괄호를 대신 사용하는 것입니다. 이에 대한 Perl 구문은 (? &amp;amp; name)입니다. 이전 PCRE 구문 (? P&amp;gt; name)도 지원됩니다. 위의 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e8ca0dc7201fb7d51c9dde7758788591e257936" translate="yes" xml:space="preserve">
          <source>An alternative approach using this &quot;branch reset&quot; feature is to use duplicate named subpatterns, as described in the next section.</source>
          <target state="translated">이 &quot;분기 재설정&quot;기능을 사용하는 다른 방법은 다음 섹션에서 설명하는 것처럼 이름이 지정된 중복 하위 패턴을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0a954e9d1a777f3530d50c8cc1016f12452336b" translate="yes" xml:space="preserve">
          <source>An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string.</source>
          <target state="translated">대안 설명은이 유형의 하위 패턴이 주제 문자열의 현재 지점에 앵커 된 경우 동일한 독립형 패턴이 일치하는 문자열과 일치한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ba8c75b43a6385ab4627c92aea25e2d33f00302" translate="yes" xml:space="preserve">
          <source>An alternative to links are &lt;strong&gt;monitors&lt;/strong&gt;. A process &lt;code&gt;Pid1&lt;/code&gt; can create a monitor for &lt;code&gt;Pid2&lt;/code&gt; by calling the BIF &lt;code&gt;erlang:monitor(process, Pid2)&lt;/code&gt;. The function returns a reference &lt;code&gt;Ref&lt;/code&gt;.</source>
          <target state="translated">링크의 대안은 &lt;strong&gt;모니터&lt;/strong&gt; 입니다. 프로세스 &lt;code&gt;Pid1&lt;/code&gt; 은 BIF &lt;code&gt;erlang:monitor(process, Pid2)&lt;/code&gt; 를 호출하여 &lt;code&gt;Pid2&lt;/code&gt; 에 대한 모니터를 작성할 수 있습니다 . 이 함수는 참조 &lt;code&gt;Ref&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8533112274eb7c989f917717ae151564846d5862" translate="yes" xml:space="preserve">
          <source>An alternative to the &lt;code&gt;rsh&lt;/code&gt; program can be specified on the command line to &lt;code&gt;erl(1)&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;rsh&lt;/code&gt; 프로그램에 대한 대안 은 다음과 같이 명령 행에서 &lt;code&gt;erl(1)&lt;/code&gt; 에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a41af40dfe8039be24689b8d9fa5a4dec7a7425d" translate="yes" xml:space="preserve">
          <source>An application &lt;code&gt;myapp&lt;/code&gt; is to run at the node &lt;code&gt;cp1@cave&lt;/code&gt;. If this node goes down, &lt;code&gt;myapp&lt;/code&gt; is to be restarted at &lt;code&gt;cp2@cave&lt;/code&gt; or &lt;code&gt;cp3@cave&lt;/code&gt;. A system configuration file &lt;code&gt;cp1.config&lt;/code&gt; for &lt;code&gt;cp1@cave&lt;/code&gt; can look as follows:</source>
          <target state="translated">&lt;code&gt;myapp&lt;/code&gt; 애플리케이션 은 &lt;code&gt;cp1@cave&lt;/code&gt; 노드에서 실행됩니다 . 이 노드가 다운되면 &lt;code&gt;myapp&lt;/code&gt; 는 &lt;code&gt;cp2@cave&lt;/code&gt; 또는 &lt;code&gt;cp3@cave&lt;/code&gt; 에서 다시 시작됩니다 . 시스템 구성 파일 &lt;code&gt;cp1.config&lt;/code&gt; 에 대한 &lt;code&gt;cp1@cave&lt;/code&gt; 다음과 같이 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="476b23116cd9f8d3580ef27603fba21f5399f9c3" translate="yes" xml:space="preserve">
          <source>An application archive file and a regular application directory can coexist. This can be useful when it is needed to have parts of the application as regular files. A typical case is the &lt;code&gt;priv&lt;/code&gt; directory, which must reside as a regular directory to link in drivers dynamically and start port programs. For other applications that do not need this, directory &lt;code&gt;priv&lt;/code&gt; can reside in the archive and the files under the directory &lt;code&gt;priv&lt;/code&gt; can be read through &lt;code&gt;erl_prim_loader&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 아카이브 파일과 일반 응용 프로그램 디렉토리가 공존 할 수 있습니다. 응용 프로그램의 일부를 일반 파일로 사용해야 할 때 유용 할 수 있습니다. 일반적인 경우는 &lt;code&gt;priv&lt;/code&gt; 디렉토리이며 드라이버에서 동적으로 링크하고 포트 프로그램을 시작하려면 일반 디렉토리로 상주해야합니다. 이를 필요로하지 않는 다른 응용 프로그램의 경우 디렉토리 &lt;code&gt;priv&lt;/code&gt; 는 아카이브에 상주 할 수 있으며 &lt;code&gt;priv&lt;/code&gt; 디렉토리 아래의 파일은 &lt;code&gt;erl_prim_loader&lt;/code&gt; 를 통해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81e9ecb32e44895786dfebfa55679adffcc065bb" translate="yes" xml:space="preserve">
          <source>An application can &lt;strong&gt;include&lt;/strong&gt; other applications. An &lt;strong&gt;included application&lt;/strong&gt; has its own application directory and &lt;code&gt;.app&lt;/code&gt; file, but it is started as part of the supervisor tree of another application.</source>
          <target state="translated">응용 프로그램 &lt;strong&gt;에는&lt;/strong&gt; 다른 응용 프로그램이 &lt;strong&gt;포함될&lt;/strong&gt; 수 &lt;strong&gt;있습니다&lt;/strong&gt; . &lt;strong&gt;포함 된 응용 프로그램은&lt;/strong&gt; 자체 응용 프로그램 디렉토리가 &lt;code&gt;.app&lt;/code&gt; 파일을 있지만 다른 응용 프로그램의 관리자 트리의 일환으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bbba1c85e48e64885f006fdefa341a6cc281a7c7" translate="yes" xml:space="preserve">
          <source>An application can always be stopped explicitly by calling &lt;code&gt;application:stop/1&lt;/code&gt;. Regardless of the mode, no other applications are affected.</source>
          <target state="translated">&lt;code&gt;application:stop/1&lt;/code&gt; 을 호출하여 응용 프로그램을 항상 명시 적으로 중지 할 수 있습니다 . 모드에 관계없이 다른 응용 프로그램은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4237e4a4e71361c449280ec1eb5b5ab2013b9c88" translate="yes" xml:space="preserve">
          <source>An application can be configured using &lt;strong&gt;configuration parameters&lt;/strong&gt;. These are a list of &lt;code&gt;{Par,Val}&lt;/code&gt; tuples specified by a key &lt;code&gt;env&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">&lt;strong&gt;구성 매개 변수를&lt;/strong&gt; 사용하여 응용 프로그램을 구성 할 수 있습니다 . 다음은 &lt;code&gt;.app&lt;/code&gt; 파일 의 키 &lt;code&gt;env&lt;/code&gt; 에 의해 지정된 &lt;code&gt;{Par,Val}&lt;/code&gt; 튜플 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="2e4737552f8acb83cea1b0aaa1c749b9a4b1bebd" translate="yes" xml:space="preserve">
          <source>An application can only be included by one other application.</source>
          <target state="translated">하나의 응용 프로그램 만 응용 프로그램을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b998578ccefe4ab3f65c6754297234509b764f6" translate="yes" xml:space="preserve">
          <source>An application can use the atom &lt;code&gt;asn1_DEFAULT&lt;/code&gt; to indicate that the encoding is to be omitted for that position in the &lt;code&gt;SEQUENCE&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램은 아톰 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 를 사용 하여 &lt;code&gt;SEQUENCE&lt;/code&gt; 의 해당 위치에 대해 인코딩이 생략됨을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="610dd49b9ed69c0fcdd8e4b86353cb6bb81aba12" translate="yes" xml:space="preserve">
          <source>An application directory &lt;code&gt;AppDir&lt;/code&gt; under a library directory is recognized by the existence of an &lt;code&gt;AppDir/ebin&lt;/code&gt; directory. If this does not exist, Reltool will not consider &lt;code&gt;AppDir&lt;/code&gt; at all when looking for applications.</source>
          <target state="translated">라이브러리 디렉토리 아래 의 응용 프로그램 디렉토리 &lt;code&gt;AppDir&lt;/code&gt; 은 &lt;code&gt;AppDir/ebin&lt;/code&gt; 디렉토리 의 존재로 인식됩니다 . 이것이 존재하지 않으면 Reltool은 응용 프로그램을 찾을 때 &lt;code&gt;AppDir&lt;/code&gt; 을 전혀 고려하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="11790a3abc0ee5cdb260b3defc07c38712b24580" translate="yes" xml:space="preserve">
          <source>An application has an invalid &lt;code&gt;.app&lt;/code&gt; file. The second element identifies the application which has the invalid &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">응용 프로그램에 유효하지 않은 &lt;code&gt;.app&lt;/code&gt; 파일이 있습니다. 두 번째 요소는 잘못된 &lt;code&gt;.app&lt;/code&gt; 파일 이있는 응용 프로그램을 식별 합니다.</target>
        </trans-unit>
        <trans-unit id="b872a6c7b25b61b98a67c571917b77e9c18745dd" translate="yes" xml:space="preserve">
          <source>An application has an invalid application version. The second element identifies the application version that is invalid.</source>
          <target state="translated">응용 프로그램에 유효하지 않은 응용 프로그램 버전이 있습니다. 두 번째 요소는 유효하지 않은 애플리케이션 버전을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f6f21f5a29839ae0eb3a520c3267f5725a862871" translate="yes" xml:space="preserve">
          <source>An application is defined by an &lt;strong&gt;application specification&lt;/strong&gt;. The specification is normally located in an &lt;strong&gt;application resource file&lt;/strong&gt; named &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. For details about the application specification, see &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;strong&gt;응용 프로그램 사양에&lt;/strong&gt; 의해 정의됩니다 . 사양은 일반적으로 &lt;code&gt;Application.app&lt;/code&gt; 라는 응용 &lt;strong&gt;프로그램 리소스 파일&lt;/strong&gt; 에 있습니다. 여기서 &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름입니다. 응용 프로그램 사양에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35cc8d34265eba507b77d8ce059b8e74c5366d40" translate="yes" xml:space="preserve">
          <source>An application is missing &lt;code&gt;runtime dependencies&lt;/code&gt;. The second element identifies the application (with version) that has missing dependencies. The third element contains the missing dependencies.</source>
          <target state="translated">응용 프로그램에 &lt;code&gt;runtime dependencies&lt;/code&gt; 이 없습니다 . 두 번째 요소는 종속성이 누락 된 애플리케이션 (버전 포함)을 식별합니다. 세 번째 요소에는 누락 된 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2d6a9e6ff979b71cea277fe00e98011788f397" translate="yes" xml:space="preserve">
          <source>An application is started by calling:</source>
          <target state="translated">다음을 호출하여 응용 프로그램을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2fec5bb7dc2630ef6ad69450c1671267747da522" translate="yes" xml:space="preserve">
          <source>An application is stopped, but not unloaded, by calling:</source>
          <target state="translated">다음을 호출하여 응용 프로그램이 중지되었지만 언로드되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bce15355fd14cfb6694d5cb7ccae2f7417ded65c" translate="yes" xml:space="preserve">
          <source>An application started the function &lt;code&gt;&lt;a href=&quot;mnesia#report_event-1&quot;&gt;mnesia:report_event(Event)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Event&lt;/code&gt; can be any Erlang data structure. When tracing a system of &lt;code&gt;Mnesia&lt;/code&gt; applications, it is useful to be able to interleave own events of &lt;code&gt;Mnesia&lt;/code&gt; with application-related events that give information about the application context. Whenever the application starts with a new and demanding &lt;code&gt;Mnesia&lt;/code&gt; activity, or enters a new and interesting phase in its execution, it can be a good idea to use &lt;code&gt;mnesia:report_event/1&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;&lt;a href=&quot;mnesia#report_event-1&quot;&gt;mnesia:report_event(Event)&lt;/a&gt;&lt;/code&gt; 함수를 시작했습니다 . &lt;code&gt;Event&lt;/code&gt; 는 모든 Erlang 데이터 구조 일 수 있습니다. 의 시스템 추적 할 때 &lt;code&gt;Mnesia&lt;/code&gt; 의 응용 프로그램을,의 자신의 이벤트 인터리브 할 수있을 유용 &lt;code&gt;Mnesia&lt;/code&gt; 애플리케이션 컨텍스트에 대한 정보를 제공 응용 프로그램 관련 이벤트와 함께합니다. 응용 프로그램이 새롭고 까다로운 &lt;code&gt;Mnesia&lt;/code&gt; 활동으로 시작하거나 실행할 때 새롭고 흥미로운 단계에 들어갈 때마다 &lt;code&gt;mnesia:report_event/1&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f14ca986d2f7db147026ee6782679a5a03b84408" translate="yes" xml:space="preserve">
          <source>An application that has been stopped, or has never been started, can be unloaded. The information about the application is erased from the internal database of the application controller.</source>
          <target state="translated">중지되었거나 시작된 적이없는 응용 프로그램을 언로드 할 수 있습니다. 응용 프로그램에 대한 정보는 응용 프로그램 제어기의 내부 데이터베이스에서 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c9401bc6499ac0973c3774424958a83ea895fc37" translate="yes" xml:space="preserve">
          <source>An application that is not included by any other application is called a &lt;strong&gt;primary application&lt;/strong&gt;.</source>
          <target state="translated">다른 응용 프로그램에 포함되지 않은 응용 프로그램을 &lt;strong&gt;기본 응용 프로그램&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="6d9139252544974ea454236628ab9eb7e354e643" translate="yes" xml:space="preserve">
          <source>An application that needs to import this MIB into another MIB is to use the &lt;code&gt;il&lt;/code&gt; option to the SNMP MIB compiler:</source>
          <target state="translated">이 MIB를 다른 MIB로 가져와야하는 응용 프로그램은 &lt;code&gt;il&lt;/code&gt; 옵션을 SNMP MIB 컴파일러에 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aedbc71f0d851c4a267d3a1c0c5aaf62f7d4dba9" translate="yes" xml:space="preserve">
          <source>An application version or an OTP version identifies source code versions. That is, it implies nothing about how the application or OTP has been built.</source>
          <target state="translated">응용 프로그램 버전 또는 OTP 버전은 소스 코드 버전을 식별합니다. 즉, 응용 프로그램이나 OTP가 어떻게 구축되었는지에 대해서는 아무 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f4a2e38a016cb917aa540b614b135781aa21ea6" translate="yes" xml:space="preserve">
          <source>An application with processes is easiest implemented as a supervision tree using the standard behaviours.</source>
          <target state="translated">프로세스가있는 응용 프로그램은 표준 동작을 사용하여 감독 트리로 가장 쉽게 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="66dea70011adf556837c53a3cf0529342b0737a2" translate="yes" xml:space="preserve">
          <source>An arbitrary term of meaning only to the transport process in question, as documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 설명 된대로 해당 전송 프로세스에만 의미가있는 임의의 용어입니다 .</target>
        </trans-unit>
        <trans-unit id="bd2f0e142f69d7ddafd6b4e615512721bf634753" translate="yes" xml:space="preserve">
          <source>An archive file for an application can, for example, be created like this:</source>
          <target state="translated">예를 들어, 애플리케이션의 아카이브 파일은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893f8dfc800bfa1b0e951f0e6684d0ff5c925843" translate="yes" xml:space="preserve">
          <source>An arithmetic expression can be used within a pattern if it meets both of the following two conditions:</source>
          <target state="translated">다음 두 조건을 모두 만족하는 경우 패턴 내에서 산술 연산 식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c099d0285433de3759b9f43727e0ca89ef8d8154" translate="yes" xml:space="preserve">
          <source>An assertion is a test on the characters following or preceding the current matching point that does not consume any characters. The simple assertions coded as \b, \B, \A, \G, \Z, \z, ^, and $ are described in the previous sections.</source>
          <target state="translated">어설 션은 문자를 소비하지 않는 현재 일치점 다음 또는 앞의 문자에 대한 테스트입니다. \ b, \ B, \ A, \ G, \ Z, \ z, ^ 및 $로 코딩 된 간단한 어설 션은 이전 섹션에서 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="978ae9153d3b935114d56f1e2ba916c150175de4" translate="yes" xml:space="preserve">
          <source>An association A is one of the following:</source>
          <target state="translated">연관 A는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fdf937e643d3d794f4dfc3d3b0be30aaa9ddfa6d" translate="yes" xml:space="preserve">
          <source>An atom is a literal, a constant with name. An atom is to be enclosed in single quotes (') if it does not begin with a lower-case letter or if it contains other characters than alphanumeric characters, underscore (_), or @.</source>
          <target state="translated">원자는 리터럴이며 이름이있는 상수입니다. 원자는 소문자로 시작하지 않거나 영숫자, 밑줄 (_) 또는 @ 이외의 다른 문자를 포함하는 경우 작은 따옴표 ( ')로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c8ee9420b38206282974e3cd3d3b4d8640789fe" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 1 byte unsigned length, followed by &lt;code&gt;Len&lt;/code&gt; bytes containing the &lt;code&gt;AtomName&lt;/code&gt; encoded in UTF-8. Longer atoms encoded in UTF-8 can be represented using &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">아톰은 1 바이트의 부호없는 길이로 저장되고 그 뒤에 UTF-8로 인코딩 된 &lt;code&gt;AtomName&lt;/code&gt; 을 포함하는 &lt;code&gt;Len&lt;/code&gt; 바이트 가 저장됩니다 . UTF-8로 인코딩 된 더 긴 원자는 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 를 사용하여 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5b4b168d4917cd1441088fb0d3d767f247862aa" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 1 byte unsigned length, followed by &lt;code&gt;Len&lt;/code&gt; numbers of 8-bit Latin-1 characters that forms the &lt;code&gt;AtomName&lt;/code&gt;.</source>
          <target state="translated">아톰은 1 바이트의 부호없는 길이로 저장되고 그 뒤에 &lt;code&gt;AtomName&lt;/code&gt; 을 형성하는 &lt;code&gt;Len&lt;/code&gt; 숫자가 8 비트 Latin-1 문자로 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="07c34b58920482b4d31c13cdc559df7d2359423e" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 2 byte unsigned length in big-endian order, followed by &lt;code&gt;Len&lt;/code&gt; bytes containing the &lt;code&gt;AtomName&lt;/code&gt; encoded in UTF-8.</source>
          <target state="translated">아톰은 빅 엔디안 순서로 부호없는 2 바이트 길이로 저장 되고 UTF-8로 인코딩 된 &lt;code&gt;AtomName&lt;/code&gt; 을 포함하는 &lt;code&gt;Len&lt;/code&gt; 바이트 가 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="025e110ec6c6fcee1721f7cbcbad132a16cef024" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 2 byte unsigned length in big-endian order, followed by &lt;code&gt;Len&lt;/code&gt; numbers of 8-bit Latin-1 characters that forms the &lt;code&gt;AtomName&lt;/code&gt;. The maximum allowed value for &lt;code&gt;Len&lt;/code&gt; is 255.</source>
          <target state="translated">아톰은 빅 엔디안 순서로 부호없는 2 바이트 길이로 저장되고 &lt;code&gt;AtomName&lt;/code&gt; 을 형성하는 &lt;code&gt;Len&lt;/code&gt; 숫자의 8 비트 Latin-1 문자가 뒤에옵니다 . &lt;code&gt;Len&lt;/code&gt; 에 허용되는 최대 값 은 255입니다.</target>
        </trans-unit>
        <trans-unit id="b431bae2fda8c033fdb39409998689e38c1c1e1e" translate="yes" xml:space="preserve">
          <source>An atom refers into an atom table, which also consumes memory. The atom text is stored once for each unique atom in this table. The atom table is &lt;strong&gt;not&lt;/strong&gt; garbage-collected.</source>
          <target state="translated">원자는 원자 테이블을 나타내며 메모리도 사용합니다. 아톰 텍스트는이 테이블의 각 고유 아톰에 대해 한 번 저장됩니다. 아톰 테이블은 가비지 수집 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0191848aafc2915da6d60330900193c80a5474" translate="yes" xml:space="preserve">
          <source>An atom that is named from the POSIX error codes used in Unix, and in the runtime libraries of most C compilers.</source>
          <target state="translated">유닉스와 대부분의 C 컴파일러의 런타임 라이브러리에서 사용되는 POSIX 오류 코드에서 명명 된 아톰.</target>
        </trans-unit>
        <trans-unit id="96460aed347ebf24b2ed9071452af314293b4756" translate="yes" xml:space="preserve">
          <source>An atom that is named from the POSIX error codes used in Unix, and in the runtime libraries of most C compilers. See section &lt;code&gt;&lt;a href=&quot;#error_codes&quot;&gt;POSIX Error Codes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유닉스와 대부분의 C 컴파일러의 런타임 라이브러리에서 사용되는 POSIX 오류 코드에서 명명 된 아톰. &lt;code&gt;&lt;a href=&quot;#error_codes&quot;&gt;POSIX Error Codes&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e8843a0acaa52daf81257b21ad8836b998c8089" translate="yes" xml:space="preserve">
          <source>An earlier application version to downgrade to. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</source>
          <target state="translated">다운 그레이드 할 이전 애플리케이션 버전입니다. 문자열 인 경우 특정 버전 번호로 해석됩니다. 이진 인 경우 여러 버전 번호와 일치 할 수있는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="63ac8cc2733af5ba4520a25e1a0a5d26e1de0048" translate="yes" xml:space="preserve">
          <source>An earlier application version to upgrade from. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</source>
          <target state="translated">업그레이드 할 이전 애플리케이션 버전. 문자열 인 경우 특정 버전 번호로 해석됩니다. 이진 인 경우 여러 버전 번호와 일치 할 수있는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="86d25cc1b1c119f7c9ce21b1b20f631ca251d2b2" translate="yes" xml:space="preserve">
          <source>An earlier example pointed out that the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;:</source>
          <target state="translated">이전 예는 다음 패턴이 &quot;감각과 감성&quot;및 &quot;응답과 책임&quot;과 일치하지만 &quot;감각과 책임&quot;과 일치하지 않음을 지적했습니다.</target>
        </trans-unit>
        <trans-unit id="c42c79091566f1fa867808f3997379fa20e2ae07" translate="yes" xml:space="preserve">
          <source>An easier way to do this is to use &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-1&quot;&gt;erlang:monotonic_time/1&lt;/a&gt;&lt;/code&gt; with the desired time unit. However, you can then lose accuracy and precision.</source>
          <target state="translated">가장 쉬운 방법은 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-1&quot;&gt;erlang:monotonic_time/1&lt;/a&gt;&lt;/code&gt; 을 원하는 시간 단위와 함께 사용하는 것입니다. 그러나 정확도와 정밀도를 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e6d13ae9ee54a2968464f59c022d1a0a22fec2" translate="yes" xml:space="preserve">
          <source>An edge e = (v, w) is said to &lt;strong id=&quot;emanate&quot;&gt;emanate&lt;/strong&gt; from vertex v and to be &lt;strong id=&quot;incident&quot;&gt;incident&lt;/strong&gt; on vertex w.</source>
          <target state="translated">에지 e = (v, w)는 꼭짓점 v에서 &lt;strong id=&quot;emanate&quot;&gt;나오고&lt;/strong&gt; 꼭짓점 w에 &lt;strong id=&quot;incident&quot;&gt;입사&lt;/strong&gt; 한다고합니다 .</target>
        </trans-unit>
        <trans-unit id="172599b2aba9fdd5cd8e0641d69258937859fbb4" translate="yes" xml:space="preserve">
          <source>An employee works at a department, hence the &lt;code&gt;at_dep&lt;/code&gt; relationship.</source>
          <target state="translated">직원은 부서에서 일하므로 &lt;code&gt;at_dep&lt;/code&gt; 관계입니다.</target>
        </trans-unit>
        <trans-unit id="536601c2cbcd6150b3784edaf6a33c2948983d16" translate="yes" xml:space="preserve">
          <source>An empty list &lt;code&gt;[]&lt;/code&gt;. This is equivalent to passing &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">빈 목록 &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;none&lt;/code&gt; 을 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="da49af945864fc175e1244b31cb186e75a716158" translate="yes" xml:space="preserve">
          <source>An empty map is constructed by not associating any terms with each other:</source>
          <target state="translated">빈 맵은 용어를 서로 연관시키지 않고 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="20bc15d4624ad61f2625ada525d5ff17ad373837" translate="yes" xml:space="preserve">
          <source>An empty match spec deactivates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">빈 일치 스펙은 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 호출 추적을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="f0f2a6b5cf3bee32b54e68dd8605481238a3fa00" translate="yes" xml:space="preserve">
          <source>An empty schema must be initialized on all the participating nodes.</source>
          <target state="translated">모든 참여 노드에서 빈 스키마를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="82d8e46ec9a0b6406017d5e01235b4160883931e" translate="yes" xml:space="preserve">
          <source>An empty string is interpreted as local time. The values &lt;code&gt;&quot;Z&quot;&lt;/code&gt;, &lt;code&gt;&quot;z&quot;&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; are interpreted as Universal Coordinated Time (UTC).</source>
          <target state="translated">빈 문자열은 현지 시간으로 해석됩니다. 값 &lt;code&gt;&quot;Z&quot;&lt;/code&gt; , &lt;code&gt;&quot;z&quot;&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 은 협정 세계시 (UTC)로 해석된다.</target>
        </trans-unit>
        <trans-unit id="67b4376e4a5d5d2b6491c06b36b24207239ad5a6" translate="yes" xml:space="preserve">
          <source>An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails.</source>
          <target state="translated">이 옵션을 지정하면 빈 문자열이 유효한 것으로 간주되지 않습니다. 패턴에 대안이 있으면 시도합니다. 모든 대안이 빈 문자열과 일치하면 전체 일치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ede47d5a8df58bc759c031e79f49d50dd3d6152e" translate="yes" xml:space="preserve">
          <source>An emulation of the &lt;code&gt;get_line&lt;/code&gt; request can be (inefficiently) implemented using the following functions:</source>
          <target state="translated">&lt;code&gt;get_line&lt;/code&gt; 요청 의 에뮬레이션은 다음 함수를 사용하여 (비효율적으로) 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="769ee572886ec7114895ada8db85a98957037066" translate="yes" xml:space="preserve">
          <source>An engine could among other tasks provide a storage for private or public keys. Such a storage could be made safer than the normal file system. Thoose techniques are not described in this User's Guide. Here we concentrate on how to use private or public keys stored in such an engine.</source>
          <target state="translated">엔진은 다른 작업 중에서 개인 또는 공개 키를위한 스토리지를 제공 할 수 있습니다. 이러한 스토리지는 일반 파일 시스템보다 더 안전하게 만들 수 있습니다. 이 기술 안내서에는 기술이 설명되어 있지 않습니다. 여기서 우리는 그러한 엔진에 저장된 개인 또는 공개 키를 사용하는 방법에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="de3c35730fbd4317113e17cb1a8316aa1ba146c4" translate="yes" xml:space="preserve">
          <source>An entry &lt;code&gt;init&lt;/code&gt; is called when the driver is loaded. However, we do not use this, as it is executed only once, and we want to have the possibility of several instances of the driver.</source>
          <target state="translated">드라이버가로드 될 때 항목 &lt;code&gt;init&lt;/code&gt; 가 호출됩니다. 그러나 한 번만 실행되므로 드라이버를 여러 번 사용할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="f8c9e3c9a42748333730203820467c57427c23cd" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpNotifyTable&lt;/code&gt; selects a set of management targets, which should receive notifications, as well as the type (trap or inform) of notification that should be sent to each selected management target. When an application sends a notification using the function &lt;code&gt;send_notification/5&lt;/code&gt; or the function &lt;code&gt;send_trap&lt;/code&gt; the parameter &lt;code&gt;NotifyName&lt;/code&gt;, specified in the call, is used as an index in the table. The notification is sent to the management targets selected by that entry.</source>
          <target state="translated">&lt;code&gt;snmpNotifyTable&lt;/code&gt; 의 항목은 선택된 각 관리 대상으로 보내야하는 알림 유형 (트랩 또는 알림)뿐만 아니라 알림을 수신해야하는 관리 대상 세트를 선택합니다. 애플리케이션이 &lt;code&gt;send_notification/5&lt;/code&gt; 함수 또는 &lt;code&gt;send_trap&lt;/code&gt; 함수를 사용하여 알림을 보내면 호출에 지정된 매개 변수 &lt;code&gt;NotifyName&lt;/code&gt; 이 테이블에서 인덱스로 사용됩니다. 통지는 해당 항목에 의해 선택된 관리 대상으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d30f9a9d06d4cdda3d95205ef3f8e3559b78ed6a" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; defines transport parameters (such as IP address and UDP port) for each management target. Each row in the &lt;code&gt;snmpNotifyTable&lt;/code&gt; refers to potentially many rows in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt;. Each row in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; refers to an entry in the &lt;code&gt;snmpTargetParamsTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 의 항목은 각 관리 대상에 대한 전송 매개 변수 (예 : IP 주소 및 UDP 포트)를 정의합니다. &lt;code&gt;snmpNotifyTable&lt;/code&gt; 의 각 행은 snmpTargetAddrTable의 잠재적으로 많은 행을 나타 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; . &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 의 각 행은 snmpTargetParamsTable 의 항목을 나타 &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c864a3c020fb7453c6c9230310fc8c808b2ea57f" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; defines which SNMP version to use, and which security parameters to use.</source>
          <target state="translated">&lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 의 항목 은 사용할 SNMP 버전과 사용할 보안 매개 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c6d027e6ae888a87324f48f2f95ccca79a8943b4" translate="yes" xml:space="preserve">
          <source>An enum is defined for the different types of ports:</source>
          <target state="translated">열거 형은 다른 유형의 포트에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="112db680b6814a15cbebf4072e243401d2d30dc2" translate="yes" xml:space="preserve">
          <source>An enumeration of the options that can be specified to &lt;code&gt;&lt;a href=&quot;#enif_binary_to_term&quot;&gt;enif_binary_to_term&lt;/a&gt;&lt;/code&gt;. For default behavior, use value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_binary_to_term&quot;&gt;enif_binary_to_term&lt;/a&gt;&lt;/code&gt; 에 지정할 수있는 옵션의 열거입니다 . 기본 동작의 경우 값 &lt;code&gt;0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6252cac5ba4fabe28fb4f86a057202e9f901cf22" translate="yes" xml:space="preserve">
          <source>An enumeration of the properties that can be requested from &lt;code&gt;&lt;a href=&quot;#enif_make_unique_integer&quot;&gt;enif_make_unique_integer&lt;/a&gt;&lt;/code&gt;. For default properties, use value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_make_unique_integer&quot;&gt;enif_make_unique_integer&lt;/a&gt;&lt;/code&gt; 에서 요청할 수있는 특성의 열거입니다 . 기본 특성의 경우 값 &lt;code&gt;0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="65635c741693783b8faf9619014d7e4c157b5504" translate="yes" xml:space="preserve">
          <source>An enumeration of the supported hash types that can be generated using &lt;code&gt;&lt;a href=&quot;#enif_hash&quot;&gt;enif_hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_hash&quot;&gt;enif_hash&lt;/a&gt;&lt;/code&gt; 를 사용하여 생성 할 수있는 지원되는 해시 유형의 열거입니다 .</target>
        </trans-unit>
        <trans-unit id="a0579ec30b9bde18751f5dc44f0719d4615425a5" translate="yes" xml:space="preserve">
          <source>An enumeration of time units supported by the NIF API:</source>
          <target state="translated">NIF API가 지원하는 시간 단위 열거 :</target>
        </trans-unit>
        <trans-unit id="168bb5a8fd94c8cd10d8ed3f141a0191574b88ed" translate="yes" xml:space="preserve">
          <source>An enumeration of time units supported by the driver API:</source>
          <target state="translated">드라이버 API가 지원하는 시간 단위 열거 :</target>
        </trans-unit>
        <trans-unit id="5667406f6f2878a322440a8811e0537af3474b50" translate="yes" xml:space="preserve">
          <source>An erroneous port driver causes the entire Erlang runtime system to leak memory, hang or crash.</source>
          <target state="translated">잘못된 포트 드라이버는 전체 Erlang 런타임 시스템의 메모리 누수, 정지 또는 충돌을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="a25480ae66be12a6963d7a72edaa77057ebfd25a" translate="yes" xml:space="preserve">
          <source>An erroneously implemented driver callback can cause a VM internal state inconsistency, which can cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the driver callback.</source>
          <target state="translated">잘못 구현 된 드라이버 콜백으로 인해 VM 내부 상태 불일치가 발생할 수 있으며, 이로 인해 VM 충돌이 발생하거나 드라이버 콜백을 호출 한 후 언제든지 VM의 기타 오작동이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8892af8dce296a6140e1075e6fda16d2be53087" translate="yes" xml:space="preserve">
          <source>An erroneously implemented native function can cause a VM internal state inconsistency, which can cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the native function.</source>
          <target state="translated">잘못 구현 된 기본 함수는 VM 내부 상태 불일치를 유발할 수 있으며, 이로 인해 기본 기능 호출 후 어느 시점에서든 VM의 충돌 또는 기타 VM의 오작동이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e29ee9045f599d9ba3e88fde145184df3fac58d" translate="yes" xml:space="preserve">
          <source>An error (preferably &lt;code&gt;enotsup&lt;/code&gt;) is to be expected if the option is not supported by the I/O server (like if an &lt;code&gt;echo&lt;/code&gt; option is sent in a &lt;code&gt;setopts&lt;/code&gt; request to a plain file).</source>
          <target state="translated">옵션이 I / O 서버에서 지원되지 않는 경우 (예 : &lt;code&gt;echo&lt;/code&gt; 옵션이 &lt;code&gt;setopts&lt;/code&gt; 요청에서 일반 파일로 전송 되는 경우) 오류 (예 : &lt;code&gt;enotsup&lt;/code&gt; )가 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef53805af65d4aec1042beb62bf786a927bf0949" translate="yes" xml:space="preserve">
          <source>An error in the token, &lt;code&gt;ErrString&lt;/code&gt; is a string describing the error.</source>
          <target state="translated">토큰의 오류 인 &lt;code&gt;ErrString&lt;/code&gt; 은 오류를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9675f812e2ec4204b8069b26c2c16fc3d11e7e72" translate="yes" xml:space="preserve">
          <source>An error is generated if a POSIX character class (see below) or an escape sequence other than one that defines a single character appears at a point where a range ending character is expected. For example, [z-\xff] is valid, but [A-\d] and [A-[:digit:]] are not.</source>
          <target state="translated">POSIX 문자 클래스 (아래 참조) 또는 단일 문자를 정의하는 것 이외의 이스케이프 시퀀스가 ​​범위 끝 문자가 예상되는 지점에 나타나면 오류가 발생합니다. 예를 들어 [z- \ xff]는 유효하지만 [A- \ d] 및 [A-[: digit :]]는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70ffc117acf0983da95ec8d6661c1771f05359ce" translate="yes" xml:space="preserve">
          <source>An error is returned if the file is inaccessible, badly damaged, or not produced with &lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일에 액세스 할 수 없거나 심각하게 손상되었거나 &lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 으로 생성되지 않은 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4fccfc1950a3f6ff91e3d72c1993a335c05397b" translate="yes" xml:space="preserve">
          <source>An error message from Yecc will be shown if the grammar is not of the LALR type (for example too ambiguous). Shift/reduce conflicts are resolved in favor of shifting if there are no operator precedence declarations. Refer to the &lt;code&gt;yacc&lt;/code&gt; documentation on the use of operator precedence.</source>
          <target state="translated">문법이 LALR 유형이 아닌 경우 (예 : 너무 모호한 경우) Yecc의 오류 메시지가 표시됩니다. 연산자 우선 순위 선언이없는 경우 시프트를 줄이기 위해 시프트 / 감소 충돌이 해결됩니다. 운영자 우선 순위 사용에 대해서는 &lt;code&gt;yacc&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c2414153ba301793b3dd12a7fe55e753d09f20" translate="yes" xml:space="preserve">
          <source>An error occurred and parameter &lt;code&gt;What&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">오류가 발생했으며 매개 변수 &lt;code&gt;What&lt;/code&gt; 는 오류에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b554e8c8ed24e5d9bc17d2154801582fa6248c31" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang expressions in the file. To convert the three-element tuple to an English description of the error, use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일에서 Erlang 표현식을 해석 할 때 오류가 발생했습니다. 세 요소 튜플을 오류에 대한 영어 설명으로 변환하려면 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="767d840af8cc500417913c45ac5faa2d43fc36cf" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang expressions in the file. Use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; to convert the three-element tuple to an English description of the error.</source>
          <target state="translated">파일에서 Erlang 표현식을 해석 할 때 오류가 발생했습니다. 3 요소 튜플을 오류에 대한 영어 설명으로 변환 하려면 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="08fb924c8d5034ec7f5547cd83f8fcb4ccca9d79" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang terms in the file. To convert the three-element tuple to an English description of the error, use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일에서 Erlang 용어를 해석 할 때 오류가 발생했습니다. 세 요소 튜플을 오류에 대한 영어 설명으로 변환하려면 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ce206664f8a29d19d98811cc9c199fb73695df" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang terms in the file. Use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; to convert the three-element tuple to an English description of the error.</source>
          <target state="translated">파일에서 Erlang 용어를 해석 할 때 오류가 발생했습니다. 3 요소 튜플을 오류에 대한 영어 설명으로 변환 하려면 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d42f0460cf512a9c365e9827248b96d2dd4f4f2b" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the file or reading it. For a list of typical error codes, see &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 열거 나 읽을 때 오류가 발생했습니다. 일반적인 오류 코드 목록은 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="865e7e88d043baea59e5a9ce2c7bdc0ec2a285ad" translate="yes" xml:space="preserve">
          <source>An error occurred while tokenizing or parsing.</source>
          <target state="translated">토큰 화 또는 구문 분석 중 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4c273a93c70896df1c5d70c89b20ce9bedbd1cc9" translate="yes" xml:space="preserve">
          <source>An error occurred while tokenizing.</source>
          <target state="translated">토큰 화하는 동안 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="bccc6f1f5cca72606032b0c35b12d1e01e8749d0" translate="yes" xml:space="preserve">
          <source>An error occurred.</source>
          <target state="translated">에러 발생됨.</target>
        </trans-unit>
        <trans-unit id="956fbfe776acc43caa6cf6b2b6cd39d20367cfeb" translate="yes" xml:space="preserve">
          <source>An error occurred. &lt;code&gt;ErrorLocation&lt;/code&gt; is the first location after the erroneous token.</source>
          <target state="translated">에러 발생됨. &lt;code&gt;ErrorLocation&lt;/code&gt; 은 잘못된 토큰 다음의 첫 번째 위치입니다.</target>
        </trans-unit>
        <trans-unit id="b5debc76cc659427400c33c7089e9a450f8d6749" translate="yes" xml:space="preserve">
          <source>An error occurred. &lt;code&gt;LeftOverChars&lt;/code&gt; is the remaining characters of the input data, starting from &lt;code&gt;EndLocation&lt;/code&gt;.</source>
          <target state="translated">에러 발생됨. &lt;code&gt;LeftOverChars&lt;/code&gt; 는 &lt;code&gt;EndLocation&lt;/code&gt; 에서 시작하여 입력 데이터의 나머지 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="b04e7309a02162567e2429e9aecf5da14464d91f" translate="yes" xml:space="preserve">
          <source>An error with this reason is caused by the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function either returning an error or an invalid value.</source>
          <target state="translated">이 이유의 오류는 사용자 &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; 콜백 함수가 오류 또는 유효하지 않은 값을 리턴하여 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c4ed44541e86a0e82fda185481726a9fa534460" translate="yes" xml:space="preserve">
          <source>An error with this reason is generated by the megaco application itself.</source>
          <target state="translated">이 이유의 오류는 megaco 응용 프로그램 자체에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="40f386a85299f082984b2271fcfb815a37ab5075" translate="yes" xml:space="preserve">
          <source>An escape such as \d or \pL that matches a single character</source>
          <target state="translated">단일 문자와 일치하는 \ d 또는 \ pL과 같은 이스케이프</target>
        </trans-unit>
        <trans-unit id="3dbab65b35422e9a5f18088ebc06d25e9fad346a" translate="yes" xml:space="preserve">
          <source>An escript without header can be created as follows:</source>
          <target state="translated">헤더가없는 escript는 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa651d62e89a3194457422deac44f5099468104" translate="yes" xml:space="preserve">
          <source>An event handler that logs events to disk.</source>
          <target state="translated">디스크에 이벤트를 기록하는 이벤트 핸들러.</target>
        </trans-unit>
        <trans-unit id="5819d554802a07971f53d1cb6535b01dfcbb09e8" translate="yes" xml:space="preserve">
          <source>An event manager can also be stopped by calling:</source>
          <target state="translated">다음을 호출하여 이벤트 관리자를 중지 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0e3aa08515364f27e3115f4b2dbde9ad919a3bf" translate="yes" xml:space="preserve">
          <source>An event manager implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하여 구현 된 이벤트 관리자에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함되어 있습니다. 또한 OTP 감독 트리에도 적합합니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="886ccc722947fa7b5754f99dcfc5af3986ac55e6" translate="yes" xml:space="preserve">
          <source>An event manager is implemented as a process and each event handler is implemented as a callback module.</source>
          <target state="translated">이벤트 관리자는 프로세스로 구현되며 각 이벤트 핸들러는 콜백 모듈로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f09b12972f030994c4bc8f915a66c78fbd4519e1" translate="yes" xml:space="preserve">
          <source>An event message sent to processes that have subscribed to these using &lt;code&gt;&lt;a href=&quot;#subscribe-1&quot;&gt;subscribe/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#subscribe-1&quot;&gt;subscribe/1&lt;/a&gt;&lt;/code&gt; 을 사용하여이를 구독 한 프로세스로 전송 된 이벤트 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="7912692308fccb18e880ce6533510b32643ba616" translate="yes" xml:space="preserve">
          <source>An event of type &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;internal&lt;/a&gt;&lt;/code&gt; is to be used when you want to reliably distinguish an event inserted this way from any external event.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;internal&lt;/a&gt;&lt;/code&gt; 유형의 이벤트는 이 방법으로 삽입 된 이벤트를 외부 이벤트와 안정적으로 구별하려는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a40597cb2b6a0fd7a5b617f8cfce1e45596c4fc9" translate="yes" xml:space="preserve">
          <source>An event record consists of the following fields:</source>
          <target state="translated">이벤트 레코드는 다음 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c961b5dc628efa399b055d52eefc6a02b7a6cc27" translate="yes" xml:space="preserve">
          <source>An event time-out is cancelled by any other event so you either get some other event or the time-out event. It is therefore not possible nor needed to cancel or restart an event time-out. Whatever event you act on has already cancelled the event time-out...</source>
          <target state="translated">이벤트 시간 초과는 다른 이벤트에 의해 취소되므로 다른 이벤트 나 시간 초과 이벤트를받을 수 있습니다. 따라서 이벤트 시간 종료를 취소하거나 다시 시작할 필요도 없습니다. 어떤 이벤트를 수행하든 이미 이벤트 시간 초과가 취소되었습니다 ...</target>
        </trans-unit>
        <trans-unit id="a3e4ac702417db8112a904d57243c3232ddfe095" translate="yes" xml:space="preserve">
          <source>An event_handler tuple in argument &lt;code&gt;Opts&lt;/code&gt; has the following definition (see &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 인수의 event_handler 튜플 은 다음 정의를 갖습니다 ( &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3a969467552c52e537f903625bc429c6574d2c9a" translate="yes" xml:space="preserve">
          <source>An example command line doing the same as the example in the previous section can now look as follows (line breaks in the command are for readability, and shall not be there when typed):</source>
          <target state="translated">이전 섹션의 예제와 동일한 작업을 수행하는 예제 명령 줄은 이제 다음과 같이 보일 수 있습니다 (명령의 줄 바꿈은 가독성을위한 것이며 입력 할 때는 없어야합니다).</target>
        </trans-unit>
        <trans-unit id="24e3e494ce66660334a3ee83d7103bc438d96d0c" translate="yes" xml:space="preserve">
          <source>An example command line with this option would look like this:</source>
          <target state="translated">이 옵션이 포함 된 예제 명령 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a72f95d3b2dbe62f799c4b641925aa95c266cbd" translate="yes" xml:space="preserve">
          <source>An example implementation of a distribution module can be found in &lt;code&gt;$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl&lt;/code&gt;. It implements the distribution over TCP/IP using the &lt;code&gt;gen_tcp&lt;/code&gt; API with distribution controllers implemented by processes. This instead of using port distribution controllers as the ordinary TCP/IP distribution uses.</source>
          <target state="translated">배포 모듈의 구현 예는 &lt;code&gt;$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl&lt;/code&gt; 에서 찾을 수 있습니다 . 프로세스에 의해 구현 된 분배 제어기와 함께 &lt;code&gt;gen_tcp&lt;/code&gt; API를 사용하여 TCP / IP를 통한 분배를 구현합니다. 이것은 일반적인 TCP / IP 분배에서 사용하는 포트 분배 제어기 대신에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f25cec01bb097ac34ef114606afd83d4604845c7" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;&amp;lt;MibName&amp;gt;&lt;/code&gt; is &lt;code&gt;RFC1213-MIB&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;MibName&amp;gt;&lt;/code&gt; 의 예 는 &lt;code&gt;RFC1213-MIB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd190ce9f4e4adebb4a1e9e43f55af888513aa13" translate="yes" xml:space="preserve">
          <source>An example of a connection string: &lt;code&gt;&quot;DSN=sql-server;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; where DSN is your ODBC Data Source Name, UID is a database user id and PWD is the password for that user. These are usually the attributes required in the connection string, but some drivers have other driver specific attributes, for example &lt;code&gt;&quot;DSN=Oracle8;DBQ=gandalf;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; where DBQ is your TNSNAMES.ORA entry name e.g. some Oracle specific configuration attribute.</source>
          <target state="translated">연결 문자열의 예 : &lt;code&gt;&quot;DSN=sql-server;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; 여기서 DSN은 ODBC 데이터 원본 이름이고 UID는 데이터베이스 사용자 ID이고 PWD는 해당 사용자의 암호입니다. 이들은 일반적으로 연결 문자열에 필요한 속성이지만 일부 드라이버에는 다른 드라이버 별 속성이 있습니다 (예 : &lt;code&gt;&quot;DSN=Oracle8;DBQ=gandalf;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; ). 여기서 DBQ는 TNSNAMES.ORA 항목 이름입니다. Oracle 특정 구성 속성</target>
        </trans-unit>
        <trans-unit id="4c63ca8ea69582d13ba623fe7884e3eaf6dde10a" translate="yes" xml:space="preserve">
          <source>An example of a simple server written in plain Erlang is provided in &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;. The server can be reimplemented using &lt;code&gt;gen_server&lt;/code&gt;, resulting in this callback module:</source>
          <target state="translated">일반 Erlang으로 작성된 간단한 서버의 예는 &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; 제공됩니다 . &lt;code&gt;gen_server&lt;/code&gt; 를 사용하여 서버를 다시 구현할 수 있으며이 콜백 모듈이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="766c8ed5398a618e0ab57071580f3ae767ca73f1" translate="yes" xml:space="preserve">
          <source>An example of a simple test function could be the following:</source>
          <target state="translated">간단한 테스트 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc8a1c6616df7bc9e05cd29f7f66081b9d15ab3e" translate="yes" xml:space="preserve">
          <source>An example of a test case information function follows:</source>
          <target state="translated">테스트 케이스 정보 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="263edddce7f8f5ac177f18b46f0285f0e12e001a" translate="yes" xml:space="preserve">
          <source>An example of a typical ordering function is less than or equal to: &lt;code&gt;=&amp;lt;/2&lt;/code&gt;.</source>
          <target state="translated">일반적인 순서 함수의 예는 &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 보다 작거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e0cfd15cad67827179545aee45fbe9cd3e6e0b77" translate="yes" xml:space="preserve">
          <source>An example of a value that can be encoded as type &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;{12,&quot;hello&quot;}&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T1&lt;/code&gt; 로 인코딩 될 수있는 값의 예 는 &lt;code&gt;{12,&quot;hello&quot;}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="641b3d8cec6c829548d6cff0640c2452dac92d4d" translate="yes" xml:space="preserve">
          <source>An example of an XML configuration file follows:</source>
          <target state="translated">XML 구성 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c953ad1d3b8e0a028a4a0e50272f51e08c62029" translate="yes" xml:space="preserve">
          <source>An example of branched versions: The version &lt;code&gt;6.0.2.1&lt;/code&gt; is a branched version from the base version &lt;code&gt;6.0.2&lt;/code&gt;. Versions on the form &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; can be compared with normal versions smaller than or equal to &lt;code&gt;6.0.2&lt;/code&gt;, and other versions on the form &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt;. The version &lt;code&gt;6.0.2.1&lt;/code&gt; will include all changes in &lt;code&gt;6.0.2&lt;/code&gt;. However, &lt;code&gt;6.0.3&lt;/code&gt; will most likely &lt;strong&gt;not&lt;/strong&gt; include all changes in &lt;code&gt;6.0.2.1&lt;/code&gt; (note that these versions have no order). A second branched version from the base version &lt;code&gt;6.0.2&lt;/code&gt; will be version &lt;code&gt;6.0.2.0.1&lt;/code&gt;, and a third branched version will be &lt;code&gt;6.0.2.0.0.1&lt;/code&gt;.</source>
          <target state="translated">분기 버전의 예 : 버전 &lt;code&gt;6.0.2.1&lt;/code&gt; 은 기본 버전 &lt;code&gt;6.0.2&lt;/code&gt; 의 분기 버전입니다 . 폼 버전 &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; 보다 작거나 같은 통상의 버전과 비교 될 수 &lt;code&gt;6.0.2&lt;/code&gt; 형태에서, 다른 버전 &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; . 버전 &lt;code&gt;6.0.2.1&lt;/code&gt; 에는 &lt;code&gt;6.0.2&lt;/code&gt; 의 모든 변경 사항이 포함됩니다 . 그러나 &lt;code&gt;6.0.3&lt;/code&gt; 은 &lt;code&gt;6.0.2.1&lt;/code&gt; 의 모든 변경 사항을 포함 &lt;strong&gt;하지 않을&lt;/strong&gt; 가능성이 높습니다 (이 버전에는 순서가 없음). 기본 버전 &lt;code&gt;6.0.2&lt;/code&gt; 의 두 번째 분기 버전은 버전 &lt;code&gt;6.0.2.0.1&lt;/code&gt; 이고 세 번째 분기 버전은 &lt;code&gt;6.0.2.0.0.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d2b79780a92a75d625b2977e20ae40bf2d1dc5d" translate="yes" xml:space="preserve">
          <source>An example of how to compile code with debug information from the Erlang shell:</source>
          <target state="translated">Erlang 쉘의 디버그 정보로 코드를 컴파일하는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="283dddecff25e45c32ff2ee6dc6f7deae1f48787" translate="yes" xml:space="preserve">
          <source>An example of how to compile code with debug information using &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 를 사용하여 디버그 정보로 코드를 컴파일하는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="0b041b3192c84c6c42972b6454b8d190b043db34" translate="yes" xml:space="preserve">
          <source>An example of how to replace the standard handler with a disk_log handler at startup is found in the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; manual.</source>
          <target state="translated">시작시 표준 핸들러를 disk_log 핸들러로 바꾸는 방법에 대한 예는 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 매뉴얼에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7a08deebfc0de42e62f5ac0c0a37270a88259d" translate="yes" xml:space="preserve">
          <source>An example of how to use function &lt;code&gt;seq_trigger_ms/0,1&lt;/code&gt; follows:</source>
          <target state="translated">&lt;code&gt;seq_trigger_ms/0,1&lt;/code&gt; 함수를 사용하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52a1c522c256f4824c6c143ccc112c9b3e8d1721" translate="yes" xml:space="preserve">
          <source>An example of process tracing of &lt;code&gt;os_mon&lt;/code&gt; and friends.</source>
          <target state="translated">&lt;code&gt;os_mon&lt;/code&gt; 및 프렌즈 의 프로세스 추적 예제</target>
        </trans-unit>
        <trans-unit id="d183a4063c6f62966aa70116abbdb5e2ed3c3fa0" translate="yes" xml:space="preserve">
          <source>An example of the suite information function follows:</source>
          <target state="translated">스위트 정보 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71b617f2d4fc8a3ed842c6355b6026c8ba8babba" translate="yes" xml:space="preserve">
          <source>An example of this is the SFTP support in &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt;. This function opens a tar file on a remote machine using an SFTP channel.</source>
          <target state="translated">이에 대한 예는 &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt; 의 SFTP 지원입니다 . 이 기능은 SFTP 채널을 사용하여 원격 시스템에서 tar 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="623a8785811ca24208a4398108f7f9357baa4841" translate="yes" xml:space="preserve">
          <source>An example with an implicit match specification:</source>
          <target state="translated">암시 적 일치 스펙이있는 예 :</target>
        </trans-unit>
        <trans-unit id="b77a79055b4c741418b72739ec8b6223e715e638" translate="yes" xml:space="preserve">
          <source>An example with implicit match specification:</source>
          <target state="translated">암시 적 일치 스펙이있는 예 :</target>
        </trans-unit>
        <trans-unit id="8f768fcb2e6876510a24de877e85b8f46f23c3ca" translate="yes" xml:space="preserve">
          <source>An exception (such as &lt;code&gt;badarg&lt;/code&gt;) in the &lt;code&gt;MatchCondition&lt;/code&gt; part, which resembles an Erlang guard, generates immediate failure.</source>
          <target state="translated">Erlang 가드와 유사한 &lt;code&gt;MatchCondition&lt;/code&gt; 부분 의 예외 (예 : &lt;code&gt;badarg&lt;/code&gt; )는 즉시 실패를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c55f6f36b8c26386f173147d732e092f93370b5b" translate="yes" xml:space="preserve">
          <source>An exception consists of its class, an exit reason (see &lt;code&gt;&lt;a href=&quot;#exit_reasons&quot;&gt;Exit Reason&lt;/a&gt;&lt;/code&gt;), and a stack trace (which aids in finding the code location of the exception).</source>
          <target state="translated">예외는 클래스 종료 이유 (참조 구성 &lt;code&gt;&lt;a href=&quot;#exit_reasons&quot;&gt;Exit Reason&lt;/a&gt;&lt;/code&gt; ) 및 (예외의 코드의 위치를 찾는 AIDS) 스택 추적.</target>
        </trans-unit>
        <trans-unit id="786ccd01cb23da0a273209436d12e92170626910" translate="yes" xml:space="preserve">
          <source>An exception in the &lt;code&gt;MatchBody&lt;/code&gt; part, which resembles the body of an Erlang function, is implicitly caught and results in the single atom &lt;code&gt;'EXIT'&lt;/code&gt;.</source>
          <target state="translated">Erlang 함수의 본문과 유사한 &lt;code&gt;MatchBody&lt;/code&gt; 부분 의 예외 는 암시 적으로 포착되어 단일 원자 &lt;code&gt;'EXIT'&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="eea16817ebabde2bb1160184fce27148bc39b259" translate="yes" xml:space="preserve">
          <source>An exception is if the application has the &lt;code&gt;start_phases&lt;/code&gt; key defined (see &lt;code&gt;&lt;a href=&quot;included_applications&quot;&gt;Included Applications&lt;/a&gt;&lt;/code&gt;). The application is then instead started by calling:</source>
          <target state="translated">응용 프로그램에 &lt;code&gt;start_phases&lt;/code&gt; 키가 정의 되어있는 경우는 예외입니다 ( &lt;code&gt;&lt;a href=&quot;included_applications&quot;&gt;Included Applications&lt;/a&gt;&lt;/code&gt; 참조 ). 대신 다음을 호출하여 응용 프로그램을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ccfc7a550c54e8241796ed0b6744cf68e3304ef5" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;fun_expr_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">&lt;code&gt;fun_expr_clauses(Node)&lt;/code&gt; 가 빈 목록을 반환하거나, 해당 목록의 첫 번째 요소 가 &lt;code&gt;clause_patterns(C)&lt;/code&gt; 가 비어 있지 않은 목록 인 type &lt;code&gt;clause&lt;/code&gt; 구문 트리 &lt;code&gt;C&lt;/code&gt; 가 아닌 경우 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b82407baecc4ff5b4d3851e388407e7da330afd7" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;function_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">예외가있는 경우 발생합니다 &lt;code&gt;function_clauses(Node)&lt;/code&gt; 빈리스트를 반환하거나 목록의 첫 번째 요소는 구문 트리가 아닌 경우 &lt;code&gt;C&lt;/code&gt; 형의 &lt;code&gt;clause&lt;/code&gt; 있도록 &lt;code&gt;clause_patterns(C)&lt;/code&gt; 비어 있지 않은 목록이.</target>
        </trans-unit>
        <trans-unit id="f52143a4be751dfd326004be48fd5e21eb1bb7aa" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;named_fun_expr_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">&lt;code&gt;named_fun_expr_clauses(Node)&lt;/code&gt; 가 빈 목록을 반환하거나, 해당 목록의 첫 번째 요소 가 &lt;code&gt;clause_patterns(C)&lt;/code&gt; 가 비어 있지 않은 목록 인 type &lt;code&gt;clause&lt;/code&gt; 구문 트리 &lt;code&gt;C&lt;/code&gt; 가 아닌 경우 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e847ae794f483b76a1568dd706204639135518bf" translate="yes" xml:space="preserve">
          <source>An exception occurring during the evaluation of &lt;code&gt;Body&lt;/code&gt; is not caught.</source>
          <target state="translated">&lt;code&gt;Body&lt;/code&gt; 를 평가하는 동안 발생하는 예외 는 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b5eab4cdd40c5d5e4cc289495dd5e5e68d0fea2" translate="yes" xml:space="preserve">
          <source>An exception of class &lt;code&gt;error&lt;/code&gt; is also known as a run-time error.</source>
          <target state="translated">클래스 &lt;code&gt;error&lt;/code&gt; 의 예외는 런타임 오류라고도합니다.</target>
        </trans-unit>
        <trans-unit id="4450a7ddfc454818593e6096f098ce6aa2d7511c" translate="yes" xml:space="preserve">
          <source>An exception to the above is if the exit reason is &lt;code&gt;kill&lt;/code&gt;, that is if &lt;code&gt;exit(Pid,kill)&lt;/code&gt; has been called. This unconditionally terminates the process, regardless of if it is trapping exit signals.</source>
          <target state="translated">종료 이유가 &lt;code&gt;kill&lt;/code&gt; 인 경우, 즉 &lt;code&gt;exit(Pid,kill)&lt;/code&gt; 이 호출 된 경우 위의 예외 는 없습니다 . 종료 신호를 트래핑하는지 여부에 관계없이 무조건 프로세스를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="d07cbfc2bcd69590e32840931392d6ea6afd078a" translate="yes" xml:space="preserve">
          <source>An exception will be thrown if a preset dictionary is required for further decompression. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">추가 압축 해제를 위해 사전 설정 사전이 필요한 경우 예외가 발생합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c641f1b9af49cd4d1923ca86b8594f8f949e59" translate="yes" xml:space="preserve">
          <source>An exception within the callback will be treated as a validation failure.</source>
          <target state="translated">콜백 내의 예외는 유효성 검사 실패로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f30fc06164cbf07d72025eed006de40eb4481362" translate="yes" xml:space="preserve">
          <source>An executable line contains an Erlang expression such as a matching or a function call. A blank line or a line containing a comment, function head or pattern in a &lt;code&gt;case&lt;/code&gt;- or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">실행 가능한 행에는 일치 또는 함수 호출과 같은 Erlang 표현식이 포함됩니다. 빈 줄 또는 &lt;code&gt;case&lt;/code&gt; 에 주석, 함수 헤드 또는 패턴이 포함 된 줄 또는 &lt;code&gt;receive&lt;/code&gt; 문은 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8606c5f9fe59cd2685a78631470346707ae72155" translate="yes" xml:space="preserve">
          <source>An expected CEA was not received within &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; of connection establishment.</source>
          <target state="translated">연결 설정 후 &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; 내에 예상 CEA가 수신되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="0cfddc07c615cb5d5e6262a7a3331cc836bbb0c2" translate="yes" xml:space="preserve">
          <source>An expected CER was not received within &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; of connection establishment.</source>
          <target state="translated">연결 설정 후 &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; 내에 예상 CER이 수신되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e9be959321b894a2874f0c88caf59a243a800d" translate="yes" xml:space="preserve">
          <source>An explicit match specification is here used to traverse the table:</source>
          <target state="translated">명시 적 일치 스펙은 여기에서 테이블을 탐색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="057acda345b8319968a51559e553710109f3e800" translate="yes" xml:space="preserve">
          <source>An expression E is one of the following:</source>
          <target state="translated">식 E는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="79ec765b52e5254ae35be2bfa0a2b1b7402af860" translate="yes" xml:space="preserve">
          <source>An expression defining the map to be updated, is put in front of the expression defining the keys to be updated and their respective values:</source>
          <target state="translated">업데이트 할 맵을 정의하는 표현식은 업데이트 할 키와 해당 값을 정의하는 표현식 앞에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5709bbd83330fdb0802325f414deebc289f34a" translate="yes" xml:space="preserve">
          <source>An expression that can be evaluated as a function in the following sense.</source>
          <target state="translated">다음과 같은 의미에서 함수로 평가할 수있는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="b3ffd3c48acbdb730fd9ee6452c9c6da8b28f7c0" translate="yes" xml:space="preserve">
          <source>An extendible array can be made fixed-size later:</source>
          <target state="translated">확장 가능한 배열은 나중에 고정 크기로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8053c45d586487397b53559d19e27dd0eec873c5" translate="yes" xml:space="preserve">
          <source>An identity parse transform.</source>
          <target state="translated">아이덴티티 파싱 변환.</target>
        </trans-unit>
        <trans-unit id="ecdfc6b7cd9818342bbf2008fadc35280070bfc8" translate="yes" xml:space="preserve">
          <source>An implementation of an HTTP 1.1 compliant web server, as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Provides web server start options, administrative functions, and an Erlang callback API.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 정의 된 HTTP 1.1 호환 웹 서버 구현 . 웹 서버 시작 옵션, 관리 기능 및 Erlang 콜백 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bccff937aee314a7a7bbe2e29ed38d05e459fc04" translate="yes" xml:space="preserve">
          <source>An important aspect of these functions is that the system can access a table while it is being reconfigured. For example, it is possible to move a table and simultaneously perform write operations to the same table. This feature is essential for applications that require continuous service.</source>
          <target state="translated">이 기능의 중요한 측면은 시스템이 재구성되는 동안 시스템이 테이블에 액세스 할 수 있다는 것입니다. 예를 들어, 테이블을 이동하고 동시에 같은 테이블에 대한 쓰기 작업을 수행 할 수 있습니다. 이 기능은 지속적인 서비스가 필요한 애플리케이션에 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="8103190c74242180849af27697a68cc90031c667" translate="yes" xml:space="preserve">
          <source>An important feature of the Erlang programming language is the ability to change module code in runtime, &lt;strong&gt;code replacement&lt;/strong&gt;, as described in the Erlang Reference Manual.</source>
          <target state="translated">Erlang 프로그래밍 언어의 중요한 기능은 Erlang 참조 매뉴얼에 설명 된대로 런타임에서 &lt;strong&gt;코드를 교체&lt;/strong&gt; 하고 &lt;strong&gt;코드를 교체&lt;/strong&gt; 하는 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="b984515f043cbeceb35298b231ea0fb8cdbe98e2" translate="yes" xml:space="preserve">
          <source>An important notion is that of  &lt;strong id=&quot;conversion&quot;&gt;conversion&lt;/strong&gt; of expressions. The syntax of a cast expression is:</source>
          <target state="translated">중요한 개념은 표현 의 &lt;strong id=&quot;conversion&quot;&gt;변환&lt;/strong&gt; 이라는 개념입니다 . 캐스트 표현식의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7373b7e60caa76da4c06b8f17342dc9bd893d3f" translate="yes" xml:space="preserve">
          <source>An inbound Diameter message.</source>
          <target state="translated">인바운드 직경 메시지</target>
        </trans-unit>
        <trans-unit id="27e2e729d2af483eadb06f0f20ab32c601a79adb" translate="yes" xml:space="preserve">
          <source>An included application can include other applications.</source>
          <target state="translated">포함 된 응용 프로그램에는 다른 응용 프로그램이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fad7fec6bf12045b5bbf5068c4c8a4f43bff8d4" translate="yes" xml:space="preserve">
          <source>An incoming CEA contained errors and has been rejected. &lt;code&gt;Caps&lt;/code&gt; contains only values for the local node. &lt;code&gt;Pkt&lt;/code&gt; contains the CEA in question.</source>
          <target state="translated">수신 CEA에 오류가 포함되어 거부되었습니다. &lt;code&gt;Caps&lt;/code&gt; 에는 로컬 노드의 값만 포함됩니다. &lt;code&gt;Pkt&lt;/code&gt; 는 해당 CEA를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="59cee863f9f3f47fe8ac63e3064c6869185c82bc" translate="yes" xml:space="preserve">
          <source>An incoming CEA has been rejected for the indicated reason. An integer-valued &lt;code&gt;Result&lt;/code&gt; indicates the result code sent by the peer. &lt;code&gt;Caps&lt;/code&gt; contains pairs of values for the local node and remote peer. &lt;code&gt;Pkt&lt;/code&gt; contains the CEA in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</source>
          <target state="translated">표시된 이유로 들어오는 CEA가 거부되었습니다. 정수 값 &lt;code&gt;Result&lt;/code&gt; 는 피어가 보낸 결과 코드를 나타냅니다. &lt;code&gt;Caps&lt;/code&gt; 는 로컬 노드와 원격 피어에 대한 값 쌍을 포함합니다. &lt;code&gt;Pkt&lt;/code&gt; 는 해당 CEA를 포함합니다. 기능 콜백에 의한 거부의 경우, 튜플에는 거부 콜백이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b1def14681d1943bacda3c612720c72d742fb87a" translate="yes" xml:space="preserve">
          <source>An incoming CER contained errors and has been answered with the indicated result code. &lt;code&gt;Caps&lt;/code&gt; contains values for the local node only. &lt;code&gt;Pkt&lt;/code&gt; contains the CER in question.</source>
          <target state="translated">수신 CER에 오류가 있으며 표시된 결과 코드로 응답되었습니다. &lt;code&gt;Caps&lt;/code&gt; 에는 로컬 노드의 값만 포함됩니다. &lt;code&gt;Pkt&lt;/code&gt; 는 해당 CER을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="44f0c3ff8baccd820cf7209b6da707bb1df632ba" translate="yes" xml:space="preserve">
          <source>An incoming CER has been answered with the indicated result code, or discarded. &lt;code&gt;Caps&lt;/code&gt; contains pairs of values, for the local node and remote peer respectively. &lt;code&gt;Pkt&lt;/code&gt; contains the CER in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</source>
          <target state="translated">수신 된 CER이 표시된 결과 코드로 응답되었거나 폐기되었습니다. &lt;code&gt;Caps&lt;/code&gt; 에는 로컬 노드와 원격 피어 각각에 대한 값 쌍이 포함됩니다. &lt;code&gt;Pkt&lt;/code&gt; 는 해당 CER을 포함합니다. 기능 콜백에 의한 거부의 경우, 튜플에는 거부 콜백이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c010a7263cd57740edb22b37dcc807299770bfbd" translate="yes" xml:space="preserve">
          <source>An index number. Each fun within a module has an unique index. &lt;code&gt;Index&lt;/code&gt; is stored in big-endian byte order.</source>
          <target state="translated">인덱스 번호 모듈 내 각 재미는 고유 한 색인을 갖습니다. &lt;code&gt;Index&lt;/code&gt; 는 빅 엔디안 바이트 순서로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e0917d687832d3450bdf1dd4a6ec48cbe0e0d9e3" translate="yes" xml:space="preserve">
          <source>An index table for the table in the previous examples would have to be a bag (as keys would appear more than once) and can have the following contents:</source>
          <target state="translated">이전 예제에서 테이블의 인덱스 테이블은 백이어야하며 (키가 두 번 이상 나타날 수 있음) 다음 내용을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a716603d7f6fd090e2b620d82712d6086ee98c" translate="yes" xml:space="preserve">
          <source>An info report is written when the upgrade is completed. To programmatically determine if the upgrade is complete, call &lt;code&gt;&lt;a href=&quot;release_handler#which_releases-0&quot;&gt;release_handler:which_releases/0,1&lt;/a&gt;&lt;/code&gt; and check if the expected release has status &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">업그레이드가 완료되면 정보 보고서가 작성됩니다. 프로그래밍 방식으로 업그레이드가 완료되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;release_handler#which_releases-0&quot;&gt;release_handler:which_releases/0,1&lt;/a&gt;&lt;/code&gt; 을 호출 하고 예상 릴리스의 상태가 &lt;code&gt;current&lt;/code&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c23fa577741650a0b90f37b9ba01e57e91c10bd" translate="yes" xml:space="preserve">
          <source>An info report is written when the upgrade is completed. To programmatically find out if the upgrade is complete, call &lt;code&gt;release_handler:which_releases(current)&lt;/code&gt; and check if it returns the expected (that is, the new) release.</source>
          <target state="translated">업그레이드가 완료되면 정보 보고서가 작성됩니다. 프로그래밍 방식으로 업그레이드가 완료 되었는지 확인하려면 &lt;code&gt;release_handler:which_releases(current)&lt;/code&gt; 호출 하고 예상 (즉, 새) 릴리스를 반환하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="54c7f8a299a2c3884adcc720f6b4c75f5057c0ab" translate="yes" xml:space="preserve">
          <source>An initial megaco_receive_handle record may be obtained with megaco:user_info(UserMid, receive_handle)</source>
          <target state="translated">megaco : user_info (UserMid, receive_handle)를 사용하여 초기 megaco_receive_handle 레코드를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1540a39cc27f66083ac255242e015830b64ff885" translate="yes" xml:space="preserve">
          <source>An installed, but not permanent, release can be &lt;strong&gt;removed&lt;/strong&gt;. Information about the release is then deleted from &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and the release-specific code, that is, the new application directories and the &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; directory, are removed.</source>
          <target state="translated">영구적이지만 설치되지 않은 릴리스는 &lt;strong&gt;제거&lt;/strong&gt; 할 수 있습니다 . 그런 다음 릴리스에 대한 정보가 &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; 에서 삭제되고 릴리스 특정 코드, 즉 새 응용 프로그램 디렉토리 및 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 디렉토리가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="543b81b3ca97b671430c105dbe9f1ef27cc417d9" translate="yes" xml:space="preserve">
          <source>An instance of the global group server, &lt;code&gt;global_group&lt;/code&gt;, must be running on each node. The processes are automatically started and synchronized when a node is started.</source>
          <target state="translated">글로벌 그룹 서버 인스턴스 &lt;code&gt;global_group&lt;/code&gt; 은 각 노드에서 실행 중이어야합니다. 프로세스는 노드가 시작될 때 자동으로 시작되고 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="37e43d40c9bbabdd039d304ba4e86e08e3ffdef1" translate="yes" xml:space="preserve">
          <source>An instrumentation function is associated with each managed object. This is the function, which actually implements the operations and will be called by the agent when it receives a request from the management station.</source>
          <target state="translated">인스 트루먼 테이션 기능은 각 관리 오브젝트와 연관됩니다. 이것은 실제로 작업을 구현하고 관리 스테이션으로부터 요청을받을 때 에이전트가 호출하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="c415bc220831ee9b6e63013e939f47504d9e06e6" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt; 1.</source>
          <target state="translated">정수&amp;gt; 1</target>
        </trans-unit>
        <trans-unit id="02913d17fb755af0fd3c86a0adae0000c2d01a6b" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt; 16#10FFFF (the maximum Unicode character)</source>
          <target state="translated">정수&amp;gt; 16 # 10FFFF (최대 유니 코드 문자)</target>
        </trans-unit>
        <trans-unit id="ad0ece817502015092c7dcb2a91f78120a1b145a" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt;= 0, defaults to 5000 (= 5 seconds).</source>
          <target state="translated">0보다 큰 정수는 기본적으로 5000 (= 5 초)입니다.</target>
        </trans-unit>
        <trans-unit id="20367003fe74f6da823d6b30bb16e4e87af78658" translate="yes" xml:space="preserve">
          <source>An integer (1-3) that together with the node name identifies a specific instance of the node.</source>
          <target state="translated">노드 이름과 함께 노드의 특정 인스턴스를 식별하는 정수 (1-3)입니다.</target>
        </trans-unit>
        <trans-unit id="2b542080580abe037742a55ddf14a6930d08becf" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Uniq&lt;/code&gt; is the hash value of the parse for the fun.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 를 사용하여 인코딩 된 정수 입니다. &lt;code&gt;Uniq&lt;/code&gt; 는 재미에 대한 구문 분석의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="1e4efa5efcaeac48981fcfd626c607b83f7f9504" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Uniq&lt;/code&gt; is the hash value of the parse tree for the fun.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 를 사용하여 인코딩 된 정수 입니다. &lt;code&gt;Uniq&lt;/code&gt; 는 재미를 위해 구문 분석 트리의 해시 값입니다.</target>
        </trans-unit>
        <trans-unit id="6a456c7d96d3be7599b8cda2609e6963d6b1de33" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. Is typically a small index into the module's fun table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 를 사용하여 인코딩 된 정수 입니다. 일반적으로 모듈의 fun 테이블에 대한 작은 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6847ab27f51bb9e93819111b69d00c639f57f360" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. It is typically a small index into the module's fun table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 를 사용하여 인코딩 된 정수 입니다. 일반적으로 모듈의 fun 테이블에 대한 작은 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="52ca0689079aeaec22ad11a25c6606e5822f73a2" translate="yes" xml:space="preserve">
          <source>An integer in base 2-36 with Erlang-style base prefix (for example, &lt;code&gt;&quot;16#ffff&quot;&lt;/code&gt;) is expected.</source>
          <target state="translated">Erlang 스타일의 기본 접두사 (예 : &lt;code&gt;&quot;16#ffff&quot;&lt;/code&gt; )가 있는 기본 2-36의 정수 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0baa0e36919cfd4cb52692449c99e08703eaa7db" translate="yes" xml:space="preserve">
          <source>An integer in the range 16#D800 to 16#DFFF (invalid range reserved for UTF-16 surrogate pairs)</source>
          <target state="translated">16 # D800-16 # DFFF 범위의 정수 (UTF-16 서로 게이트 쌍에 대해 예약 된 유효하지 않은 범위)</target>
        </trans-unit>
        <trans-unit id="bb1ed6dc3882ba274f91970e7d75def0f49d509c" translate="yes" xml:space="preserve">
          <source>An integer time-out value means that the supervisor tells the child process to terminate by calling &lt;code&gt;exit(Child, shutdown)&lt;/code&gt; and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using &lt;code&gt;exit(Child, kill)&lt;/code&gt;.</source>
          <target state="translated">정수 시간 제한 값은 감독자가 &lt;code&gt;exit(Child, shutdown)&lt;/code&gt; 를 호출하여 자식 프로세스가 종료하도록 지시 한 다음 종료 신호를 다시 기다립니다. 지정된 시간 내에 종료 신호가 수신되지 않으면 &lt;code&gt;exit(Child, kill)&lt;/code&gt; 사용하여 하위 프로세스가 무조건 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="dabb549e21a83ec6de830a51776d90cd83956482" translate="yes" xml:space="preserve">
          <source>An integer value must be at least 6000 as required by RFC 3539. Defaults to 30000.</source>
          <target state="translated">RFC 3539에 필요한 정수 값은 6000 이상이어야합니다. 기본값은 30000입니다.</target>
        </trans-unit>
        <trans-unit id="d78dcbf8380694136f9fe0e5e3000d89748b331e" translate="yes" xml:space="preserve">
          <source>An integer() =&amp;lt; byte_size(Replacement)</source>
          <target state="translated">정수 () = &amp;lt;byte_size (대체)</target>
        </trans-unit>
        <trans-unit id="eae8aee5e13d9ea04bc6a6da3331604fadfde37c" translate="yes" xml:space="preserve">
          <source>An integer, defaults to 10.</source>
          <target state="translated">정수는 기본값 10입니다.</target>
        </trans-unit>
        <trans-unit id="aaa8bce129155fc26fcd48a021b1aba6aab1fe3e" translate="yes" xml:space="preserve">
          <source>An interesting case is if the client terminates before the server links to it. This is taken care of because linking to a non-existent process causes an exit signal, &lt;code&gt;{'EXIT',From,noproc}&lt;/code&gt;, to be automatically generated. This is as if the process terminated immediately after the link operation.</source>
          <target state="translated">흥미로운 경우는 서버에 연결하기 전에 클라이언트가 종료되는 경우입니다. 존재하지 않는 프로세스에 링크하면 종료 신호 &lt;code&gt;{'EXIT',From,noproc}&lt;/code&gt; 가 자동으로 생성되므로주의해야합니다. 이는 링크 작업 직후 프로세스가 종료 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee03f04c6056f21df390b2f5c06e43f9b491765e" translate="yes" xml:space="preserve">
          <source>An interface to the BEAM file format.</source>
          <target state="translated">BEAM 파일 형식에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4ca4ff078056e9ca1ab23144711d3518ee5bc785" translate="yes" xml:space="preserve">
          <source>An interval timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_interval-4&quot;&gt;apply_interval/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_interval-3&quot;&gt;send_interval/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#send_interval-2&quot;&gt;send_interval/2&lt;/a&gt;&lt;/code&gt; is linked to the process to which the timer performs its task.</source>
          <target state="translated">인터벌 타이머, 즉 &lt;code&gt;&lt;a href=&quot;#apply_interval-4&quot;&gt;apply_interval/4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#send_interval-3&quot;&gt;send_interval/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#send_interval-2&quot;&gt;send_interval/2&lt;/a&gt;&lt;/code&gt; 함수를 평가하여 작성된 타이머는 타이머가 태스크를 수행하는 프로세스에 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="627a27fca6a1a1ae0460efe310199a632e472370" translate="yes" xml:space="preserve">
          <source>An introduction to release handling and an example is provided in &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">릴리스 처리에 대한 소개와 예제는 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;OTP Design Principles&lt;/code&gt; 에 제공되어 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="287260ebb6db5e5582d099b0dc6bfe58c59eb75e" translate="yes" xml:space="preserve">
          <source>An invalid filter is equivalent to &lt;code&gt;{any,[]}&lt;/code&gt;, a filter that matches no peer.</source>
          <target state="translated">유효하지 않은 필터는 피어와 일치하지 않는 필터 &lt;code&gt;{any,[]}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9e6dcd0df7d6d68a6b64b4961a4174415586bdf3" translate="yes" xml:space="preserve">
          <source>An invalid option will cause &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; to fail.</source>
          <target state="translated">유효하지 않은 옵션은 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="76b5573333f8a9fca96e5af38089644ca66d3800" translate="yes" xml:space="preserve">
          <source>An iterator representing the key value associations in a map.</source>
          <target state="translated">맵에서 키 값 연관을 나타내는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="14321e1cc5b6395a120d907a4630fb98a62c2d1a" translate="yes" xml:space="preserve">
          <source>An object has a DESCRIPTIONS field. The descriptions-field will not be included in the compiled mib by default. In order to get the description, the mib must be compiled with the option &lt;code&gt;description&lt;/code&gt;.</source>
          <target state="translated">개체에는 DESCRIPTIONS 필드가 있습니다. descriptions 필드는 기본적으로 컴파일 된 mib에 포함되지 않습니다. 설명을 얻으려면 mib를 &lt;code&gt;description&lt;/code&gt; 옵션으로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ee729cb9bca371486670bc70823bacf43371b316" translate="yes" xml:space="preserve">
          <source>An object is an instance of a class. An object set is a set containing objects of a specified class. A definition can look as follows:</source>
          <target state="translated">객체는 클래스의 인스턴스입니다. 객체 세트는 지정된 클래스의 객체를 포함하는 세트입니다. 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2b7535d7ca9a8df2239bf3e1efc196455c377ac" translate="yes" xml:space="preserve">
          <source>An object stored on the process heap, called a &lt;strong&gt;ProcBin&lt;/strong&gt;</source>
          <target state="translated">프로세스 힙에 저장된 개체 ( &lt;strong&gt;ProcBin)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3818f7783f7171a63429c22bb4302a762ba63b49" translate="yes" xml:space="preserve">
          <source>An on-the-fly FIPS mode change would thus have to be performed in a critical section protected from any concurrently running crypto operations. Furthermore in case of failure all crypto calls would have to be disabled from the Erlang or nif code. This would be too much effort put into this not too important feature.</source>
          <target state="translated">따라서 실시간 FIPS 모드 변경은 동시에 실행중인 암호화 작업으로부터 보호되는 중요한 섹션에서 수행해야합니다. 또한 장애가 발생할 경우 모든 암호화 통화를 Erlang 또는 nif 코드에서 비활성화해야합니다. 이 중요한 기능에 너무 많은 노력을 기울일 것입니다.</target>
        </trans-unit>
        <trans-unit id="9371fdc5c24675c1a03db0e4febf59f3f93d39d8" translate="yes" xml:space="preserve">
          <source>An opaque continuation.</source>
          <target state="translated">불투명 연속.</target>
        </trans-unit>
        <trans-unit id="9edd135f1be094e9884cdcb725f6b9ae29fe3900" translate="yes" xml:space="preserve">
          <source>An opaque handle identifing a distribution channel.</source>
          <target state="translated">배포 채널을 식별하는 불투명 한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="8c06de9b53b4d538ad0727d2caa8126ac3202325" translate="yes" xml:space="preserve">
          <source>An opaque term (a tuple) representing a trace token.</source>
          <target state="translated">추적 토큰을 나타내는 불투명 한 용어 (튜플)입니다.</target>
        </trans-unit>
        <trans-unit id="ffe2dac12bf2d4212d4d945b02bbd44d5376742d" translate="yes" xml:space="preserve">
          <source>An opaque term holding prepared code.</source>
          <target state="translated">준비된 코드를 포함하는 불투명 한 용어입니다.</target>
        </trans-unit>
        <trans-unit id="03858ce2c3f12ebaf6e00e9dd03bc97d803626cb" translate="yes" xml:space="preserve">
          <source>An opaque term returned in, for example, &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt;, which identifies an association for an SCTP socket. The term is opaque except for the special value &lt;code&gt;0&lt;/code&gt;, which has a meaning such as &quot;the whole endpoint&quot; or &quot;all future associations&quot;.</source>
          <target state="translated">SCTP 소켓에 대한 연관을 식별하는 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 와 같이 불투명 한 용어가 리턴되었습니다 . &quot;전체 종점&quot;또는 &quot;모든 미래 연관&quot;과 같은 의미를 갖는 특수 값 &lt;code&gt;0&lt;/code&gt; 을 제외하고이 용어는 불투명 합니다.</target>
        </trans-unit>
        <trans-unit id="1e180467754d1704f0a1df2c1b8933d6555d46e3" translate="yes" xml:space="preserve">
          <source>An open disk log that is not a distributed disk log is said to be a &lt;strong&gt;local disk log&lt;/strong&gt;. A local disk log is only accessible from the node where the disk log process runs, whereas a distributed disk log is accessible from all nodes in the Erlang system, except for those nodes where a local disk log with the same name as the distributed disk log exists. All processes on nodes that have access to a local or distributed disk log can log items or otherwise change, inspect, or close the log.</source>
          <target state="translated">분산 디스크 로그가 아닌 열린 디스크 로그는 &lt;strong&gt;로컬 디스크 로그라고&lt;/strong&gt; 합니다. 로컬 디스크 로그는 디스크 로그 프로세스가 실행되는 노드에서만 액세스 할 수있는 반면, 분산 디스크 로그는 분산 디스크 로그와 이름이 같은 로컬 디스크 로그가있는 노드를 제외하고 Erlang 시스템의 모든 노드에서 액세스 할 수 있습니다. 존재합니다. 로컬 또는 분산 디스크 로그에 액세스 할 수있는 노드의 모든 프로세스는 항목을 로그하거나 로그를 변경, 검사 또는 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663c631411ce98e587cb31bbdd92c54b2f404346" translate="yes" xml:space="preserve">
          <source>An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters.</source>
          <target state="translated">수량자가 허용되지 않는 위치 또는 수량 자의 구문과 일치하지 않는 위치에 나타나는 여는 중괄호는 리터럴 문자로 간주됩니다. 예를 들어, {, 6}은 수량자가 아니라 리터럴 4 문자 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6d91a90e980eb6fd08ac0210bb0e415b4c7d6aec" translate="yes" xml:space="preserve">
          <source>An opening square bracket introduces a character class, terminated by a closing square bracket. A closing square bracket on its own is not special by default. However, if option &lt;code&gt;PCRE_JAVASCRIPT_COMPAT&lt;/code&gt; is set, a lone closing square bracket causes a compile-time error. If a closing square bracket is required as a member of the class, it is to be the first data character in the class (after an initial circumflex, if present) or escaped with a backslash.</source>
          <target state="translated">여는 대괄호는 닫는 대괄호로 끝나는 문자 클래스를 소개합니다. 기본적으로 닫는 대괄호는 특별하지 않습니다. 그러나 &lt;code&gt;PCRE_JAVASCRIPT_COMPAT&lt;/code&gt; 옵션 이 설정되면 단독 닫는 대괄호로 인해 컴파일 타임 오류가 발생합니다. 클래스의 멤버로 닫는 대괄호가 필요한 경우 클래스의 첫 번째 데이터 문자 (있는 경우 초기 곡절 후)이거나 백 슬래시로 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="421ee4a2487ab9d284a55e10a7feef99df36fe1c" translate="yes" xml:space="preserve">
          <source>An operator &lt;code&gt;Op/A&lt;/code&gt; is called (this is handled as a call to function &lt;code&gt;erlang:Op/A&lt;/code&gt;).</source>
          <target state="translated">연산자 &lt;code&gt;Op/A&lt;/code&gt; 가 호출됩니다 ( &lt;code&gt;erlang:Op/A&lt;/code&gt; 함수에 대한 호출로 처리됨 ).</target>
        </trans-unit>
        <trans-unit id="e3b3ea6fc52831c5fd41836eff34ba6b00be455a" translate="yes" xml:space="preserve">
          <source>An option change within a subpattern (see section &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt;) affects only that part of the subpattern that follows it. So, the following matches abc and aBc and no other strings (assuming &lt;code&gt;caseless&lt;/code&gt; is not used):</source>
          <target state="translated">서브 패턴 내에서의 옵션 변경 (섹션 참조 &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt; 만 다음에 서브 패턴의 일부 있음에 영향을). 그래서, 경기 abc 방송과 ABC와 다른 문자열 다음 (가정 &lt;code&gt;caseless&lt;/code&gt; 사용되지 않습니다)</target>
        </trans-unit>
        <trans-unit id="551e2c1420f8fdac698ff16d393dbd32e2b136d1" translate="yes" xml:space="preserve">
          <source>An option is to have table columns that are not visible through the SNMP protocol. These columns must be the last columns of the table. In the previous example, the SNMP table could have columns &lt;code&gt;department&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; only. The application could then use column &lt;code&gt;telno&lt;/code&gt; internally, but it would not be visible to the SNMP managers.</source>
          <target state="translated">옵션은 SNMP 프로토콜을 통해 볼 수없는 테이블 열을 갖는 것입니다. 이 열은 테이블의 마지막 열이어야합니다. 이전 예에서 SNMP 테이블은 &lt;code&gt;department&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 열만 가질 수 있습니다 . 그러면 응용 프로그램은 내부적으로 &lt;code&gt;telno&lt;/code&gt; 열을 사용할 수 있지만 SNMP 관리자에게는 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="251d94f1b858e81b3828d5510ef8d65b4159fa2d" translate="yes" xml:space="preserve">
          <source>An optional sign character is expected. A sign character &lt;code&gt;-&lt;/code&gt; gives return value &lt;code&gt;-1&lt;/code&gt;. Sign character &lt;code&gt;+&lt;/code&gt; or none gives &lt;code&gt;1&lt;/code&gt;. The field width parameter is ignored. Leading whitespace characters are not skipped.</source>
          <target state="translated">선택적 부호 문자가 필요합니다. 부호 문자 &lt;code&gt;-&lt;/code&gt; 는 리턴 값 &lt;code&gt;-1&lt;/code&gt; 을 제공합니다 . 부호 문자 &lt;code&gt;+&lt;/code&gt; 또는 none은 &lt;code&gt;1&lt;/code&gt; 을 제공합니다 . 필드 너비 매개 변수는 무시됩니다. 선행 공백 문자는 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bd063d57db649e289c855dd3e2315e3fa45b28a" translate="yes" xml:space="preserve">
          <source>An ordinary send operation has occurred and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">일반 전송 작업이 발생했으며 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 는 수신자의 pid 를 포함합니다. 메시지는 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d95c4d5591cafb0876b899034ba6f76ed65f97" translate="yes" xml:space="preserve">
          <source>An outbound Diameter message.</source>
          <target state="translated">아웃 바운드 직경 메시지</target>
        </trans-unit>
        <trans-unit id="1e88996446c45983e274f354d9264bc09768f004" translate="yes" xml:space="preserve">
          <source>An overview and summary log file for one or more test suites.</source>
          <target state="translated">하나 이상의 테스트 스위트에 대한 개요 및 요약 로그 파일.</target>
        </trans-unit>
        <trans-unit id="07c751adb15fe1a4d90ad6b7ab4efbae14d0517a" translate="yes" xml:space="preserve">
          <source>An positive integer, Current default is 1.</source>
          <target state="translated">양의 정수, 현재 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="787be85125e87b09b59e0cb657acd9746aadc985" translate="yes" xml:space="preserve">
          <source>An small receive buffer may result in a peer having to resend incoming messages: set the &lt;code&gt;inet(3)&lt;/code&gt; option &lt;code&gt;recbuf&lt;/code&gt; to increase the buffer size.</source>
          <target state="translated">수신 버퍼가 작 으면 피어가 수신 메시지를 다시 &lt;code&gt;recbuf&lt;/code&gt; 할 수 있습니다. 버퍼 크기를 늘리려면 &lt;code&gt;inet(3)&lt;/code&gt; 옵션 recbuf 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b84da375fbfec2799e71fb40dea34b2a15da15f8" translate="yes" xml:space="preserve">
          <source>An small send buffer may result in outgoing messages being discarded: set the &lt;code&gt;inet(3)&lt;/code&gt; option &lt;code&gt;sndbuf&lt;/code&gt; to increase the buffer size.</source>
          <target state="translated">송신 버퍼가 작 으면 발신 메시지가 삭제 될 수 있습니다 . 버퍼 크기를 늘리려면 &lt;code&gt;inet(3)&lt;/code&gt; 옵션 &lt;code&gt;sndbuf&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d96da95c5f83e85028d2b14bb4d255a0e3e94e02" translate="yes" xml:space="preserve">
          <source>An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline.</source>
          <target state="translated">일치하는 텍스트가 줄 바꿈을 통해 계속 될 수 있지만 제목 문자열의 첫 번째 줄 바꿈 전이나 줄에서 일치하지 않는 패턴이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4b306841248c236a72e8f0555640ea69d77d6059" translate="yes" xml:space="preserve">
          <source>An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The release handler then evaluates the instructions in &lt;code&gt;relup&lt;/code&gt;, step by step:</source>
          <target state="translated">압축이 풀린 릴리스를 &lt;strong&gt;설치할&lt;/strong&gt; 수 있습니다 . 그런 다음 릴리스 핸들러는 &lt;code&gt;relup&lt;/code&gt; 의 명령을 단계별 로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e2a7a24dafaa1825d952fc1c97adf9898005d178" translate="yes" xml:space="preserve">
          <source>An unsigned integer in base 2-36 is expected. The field width parameter is used to specify base. Leading whitespace characters are not skipped.</source>
          <target state="translated">기수 2-36의 부호없는 정수가 예상됩니다. 필드 너비 매개 변수는 밑을 지정하는 데 사용됩니다. 선행 공백 문자는 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5286dbe6f7d10b81b53f17ba799c7e96413f6797" translate="yes" xml:space="preserve">
          <source>An unsigned integer type to be used as &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 로 사용될 부호없는 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="e3acdebb60e03e4a5883afd990fc02df22667fa4" translate="yes" xml:space="preserve">
          <source>An unsigned number specifies an absolute reference without the ambiguity that is present in the older syntax. It is also useful when literal digits follow the reference. A negative number is a relative reference. Consider the following example:</source>
          <target state="translated">부호없는 숫자는 이전 구문에 모호하지 않은 절대 참조를 지정합니다. 리터럴 숫자가 참조를 따르는 경우에도 유용합니다. 음수는 상대 참조입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a5a2acb9415f75900acb288ec02a5216db6932a2" translate="yes" xml:space="preserve">
          <source>An unsuccessful parse results in an error, which may be a tuple &lt;code&gt;{error,Reason}&lt;/code&gt; or an exit: &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;. According to the XML 1.0 standard there are &lt;code&gt;fatal error&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; situations. The fatal errors &lt;strong&gt;must&lt;/strong&gt; be detected by a conforming parser while an error &lt;strong&gt;may&lt;/strong&gt; be detected. Both categories of errors are reported as fatal errors by this version of xmerl, most often as an exit.</source>
          <target state="translated">구문 분석에 실패하면 오류가 발생하며 튜플 &lt;code&gt;{error,Reason}&lt;/code&gt; 또는 종료일 수 있습니다 : &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; . XML 1.0 표준에 따르면 &lt;code&gt;fatal error&lt;/code&gt; 및 &lt;code&gt;error&lt;/code&gt; 상황이 있습니다. 치명적인 오류 &lt;strong&gt;해야&lt;/strong&gt; 오류가하면서 순응 파서에서 검출 될 &lt;strong&gt;수도&lt;/strong&gt; 검출한다. 이 버전의 xmerl에서는 두 범주의 오류를 모두 치명적인 오류로보고하며 대부분 종료로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7163f714c0d7d3d9c32d044b0d111ec28a619786" translate="yes" xml:space="preserve">
          <source>An unsuccessful parse returns &lt;code&gt;fail&lt;/code&gt;.</source>
          <target state="translated">실패한 구문 분석이 &lt;code&gt;fail&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="02f4b27ab4513330d46be679798a210b6836a2bb" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;file/1&lt;/code&gt;, but takes a list of forms (in the Erlang abstract format representation) as first argument. Option &lt;code&gt;binary&lt;/code&gt; is implicit, that is, no object code file is produced. For options that normally produce a listing file, such as 'E', the internal format for that compiler pass (an Erlang term, usually not a binary) is returned instead of a binary.</source>
          <target state="translated">&lt;code&gt;file/1&lt;/code&gt; 과 유사 하지만 (Erlang 추상 형식 표현의) 양식 목록을 첫 번째 인수로 사용합니다. 옵션 &lt;code&gt;binary&lt;/code&gt; 는 암시 적입니다. 즉, 객체 코드 파일이 생성되지 않습니다. 일반적으로 'E'와 같은 리스팅 파일을 생성하는 옵션의 경우 해당 컴파일러 패스의 내부 형식 (보통 이진이 아닌 Erlang 용어)이 이진 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3cfe04f04027764dce50d28f04c6ecdc62b2192c" translate="yes" xml:space="preserve">
          <source>Analyses raw profile data in the &lt;code&gt;fprof&lt;/code&gt; server. If called while there is no raw profile data available, &lt;code&gt;{error, no_profile}&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 서버 에서 원시 프로파일 데이터를 분석 합니다. 사용 가능한 원시 프로파일 데이터가없는 동안 호출되면 &lt;code&gt;{error, no_profile}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="89317b6eabbaf1e93c0ba769bafe3e74241cb74f" translate="yes" xml:space="preserve">
          <source>Analysing; the raw profile data is sorted and dumped in text format either to file or console.</source>
          <target state="translated">분석하는; 원시 프로파일 데이터는 파일 또는 콘솔에 텍스트 형식으로 정렬 및 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cf6f5074202c6dffeb5df464d0d684dc5098ed" translate="yes" xml:space="preserve">
          <source>Analysing; the raw profile data is sorted, filtered and dumped in text format either to file or console. The text format intended to be both readable for a human reader, as well as parsable with the standard erlang parsing tools.</source>
          <target state="translated">분석하는; 원시 프로파일 데이터는 파일 또는 콘솔에 텍스트 형식으로 정렬, 필터링 및 덤프됩니다. 텍스트 형식은 인간 독자가 읽을 수 있고 표준 얼랭 파싱 도구로 구문 분석 할 수 있도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="4263863a7deae978003d2e013055bda2bff811e8" translate="yes" xml:space="preserve">
          <source>Analysis and Utility Functions for Instrumentation</source>
          <target state="translated">계측을위한 분석 및 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="33f45b6fb7384ec22cc9390f7b457147372d66b4" translate="yes" xml:space="preserve">
          <source>Analysis of type &lt;code&gt;calls&lt;/code&gt; is used to find out how many times something has been called and is represented by an integer &lt;code&gt;Calls&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;calls&lt;/code&gt; 분석은 무언가가 몇 번 호출되었고 정수 &lt;code&gt;Calls&lt;/code&gt; 표시되는지 알아내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="48073b1fc4f77f2b869e441fa62a40b84feeabf7" translate="yes" xml:space="preserve">
          <source>Analysis of type &lt;code&gt;coverage&lt;/code&gt; is used to find out how much of the code has been executed and how much has not been executed. Coverage is represented by a tuple &lt;code&gt;{Cov,NotCov}&lt;/code&gt;, where &lt;code&gt;Cov&lt;/code&gt; is the number of executable lines that have been executed at least once and &lt;code&gt;NotCov&lt;/code&gt; is the number of executable lines that have not been executed.</source>
          <target state="translated">타입 &lt;code&gt;coverage&lt;/code&gt; 분석은 얼마나 많은 코드가 실행되었고 얼마나 실행되지 않았는지를 알아 내기 위해 사용됩니다. 적용 범위는 튜플 &lt;code&gt;{Cov,NotCov}&lt;/code&gt; 로 표시됩니다 . 여기서 &lt;code&gt;Cov&lt;/code&gt; 는 적어도 한 번 실행 된 실행 가능한 행 수 이고 &lt;code&gt;NotCov&lt;/code&gt; 는 실행되지 않은 실행 가능한 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="28ba17ebd62463c58ee41d92b0a1a95c3083533c" translate="yes" xml:space="preserve">
          <source>Analyzed Modules.</source>
          <target state="translated">분석 된 모듈.</target>
        </trans-unit>
        <trans-unit id="460a405a1e58156272bea6a12fd732a955bce079" translate="yes" xml:space="preserve">
          <source>Analyzes a &quot;source code form&quot; node. If &lt;code&gt;Node&lt;/code&gt; is a &quot;form&quot; type (cf. &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt;), the returned value is a tuple &lt;code&gt;{Type, Info}&lt;/code&gt; where &lt;code&gt;Type&lt;/code&gt; is the node type and &lt;code&gt;Info&lt;/code&gt; depends on &lt;code&gt;Type&lt;/code&gt;, as follows:</source>
          <target state="translated">&quot;소스 코드 형식&quot;노드를 분석합니다. 경우 &lt;code&gt;Node&lt;/code&gt; 는 &quot;양식&quot;유형이다 (참조, &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt; ), 반환 값은 튜플 &lt;code&gt;{Type, Info}&lt;/code&gt; &lt;code&gt;Type&lt;/code&gt; 노드 유형과 &lt;code&gt;Info&lt;/code&gt; 에 따라 달라집니다 &lt;code&gt;Type&lt;/code&gt; 등 다음 :</target>
        </trans-unit>
        <trans-unit id="70965802de1cdb6b126e1b8a48df610079f9270c" translate="yes" xml:space="preserve">
          <source>Analyzes a sequence of &quot;program forms&quot;. The given &lt;code&gt;Forms&lt;/code&gt; may be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of &quot;program form&quot; syntax trees. The returned value is a list of pairs &lt;code&gt;{Key, Info}&lt;/code&gt;, where each value of &lt;code&gt;Key&lt;/code&gt; occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</source>
          <target state="translated">일련의 &quot;프로그램 형식&quot;을 분석합니다. 주어진 &lt;code&gt;Forms&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 단일 구문 트리 이거나 &quot;프로그램 양식&quot;구문 트리 목록 일 수 있습니다 . 반환 값 쌍의 목록입니다 &lt;code&gt;{Key, Info}&lt;/code&gt; 의 각 값, &lt;code&gt;Key&lt;/code&gt; 목록에서 일단 대부분에서 발생; 특정 키가 없으면 해당 키에 대해 잘 정의 된 값이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="125ee5a1deaa5b8939564769889b333464e04925" translate="yes" xml:space="preserve">
          <source>Analyzes an attribute node. If &lt;code&gt;Node&lt;/code&gt; represents a preprocessor directive, the atom &lt;code&gt;preprocessor&lt;/code&gt; is returned. Otherwise, if &lt;code&gt;Node&lt;/code&gt; represents a module attribute &quot;&lt;code&gt;-&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;...&lt;/code&gt;&quot;, a tuple &lt;code&gt;{Name, Info}&lt;/code&gt; is returned, where &lt;code&gt;Info&lt;/code&gt; depends on &lt;code&gt;Name&lt;/code&gt;, as follows:</source>
          <target state="translated">속성 노드를 분석합니다. &lt;code&gt;Node&lt;/code&gt; 가 전 처리기 지시문을 나타내는 경우 atom &lt;code&gt;preprocessor&lt;/code&gt; 반환됩니다. 그렇지 않으면, &lt;code&gt;Node&lt;/code&gt; 가 모듈 속성 &quot; &lt;code&gt;-&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;...&lt;/code&gt; &quot;을 나타내는 경우 튜플 &lt;code&gt;{Name, Info}&lt;/code&gt; 가 리턴되며 여기서 &lt;code&gt;Info&lt;/code&gt; 는 다음과 같이 &lt;code&gt;Name&lt;/code&gt; 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="ef0e889da6c5673f0c6c3783750b01ddef2430db" translate="yes" xml:space="preserve">
          <source>Anchoring a regular expression with &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; is not implemented in the current version of Leex and just generates a parse error.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 로 정규식 을 정하는 것은 현재 버전의 Leex에서 구현되지 않으며 구문 분석 오류 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5aace8ed00b60bb7e100a0b020b8edb7ad2f3f46" translate="yes" xml:space="preserve">
          <source>And Erlang can, for example, be started as follows:</source>
          <target state="translated">예를 들어 Erlang은 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f34731c7287aa9d542ce40b48dcd5e89055c21" translate="yes" xml:space="preserve">
          <source>And Fred logs on at c3@gollum:</source>
          <target state="translated">그리고 Fred는 c3 @ gollum에 로그온합니다 :</target>
        </trans-unit>
        <trans-unit id="ad418175758dc89c620d8f9c8bf36148160d3cc4" translate="yes" xml:space="preserve">
          <source>And a callback module &lt;code&gt;ch2.erl&lt;/code&gt;:</source>
          <target state="translated">콜백 모듈 &lt;code&gt;ch2.erl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc42de5f14df63fba8158204084452c3de1e9550" translate="yes" xml:space="preserve">
          <source>And a message is sent to &lt;code&gt;mess_client&lt;/code&gt;:</source>
          <target state="translated">그리고 메시지가 &lt;code&gt;mess_client&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="f85832be1eb32b29f34ce60cf06e70f7454181cc" translate="yes" xml:space="preserve">
          <source>And a registered process &lt;code&gt;call_server&lt;/code&gt; with &lt;code&gt;Pid == &amp;lt;0.31.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">그리고 &lt;code&gt;Pid == &amp;lt;0.31.0&amp;gt;&lt;/code&gt; 으로 등록 된 프로세스 &lt;code&gt;call_server&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="016bfa826d5a0a1dc763d9d701f8d84a2f10cb83" translate="yes" xml:space="preserve">
          <source>And finally a print-out of the entire internal form:</source>
          <target state="translated">마지막으로 전체 내부 양식을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2dce29dbbed23249542b78338df490da31ae18ce" translate="yes" xml:space="preserve">
          <source>And for 32 bit MSYS2:</source>
          <target state="translated">그리고 32 비트 MSYS2의 경우 :</target>
        </trans-unit>
        <trans-unit id="18268da8563e564ff18a86c591d17c9624d33b67" translate="yes" xml:space="preserve">
          <source>And for &lt;code&gt;id_key_purpose()&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;id_key_purpose()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="768d8655abda5968a013c7a5532efc554753aa5e" translate="yes" xml:space="preserve">
          <source>And for a general range, with &lt;code&gt;N = 1&lt;/code&gt; for &lt;code&gt;exrop&lt;/code&gt;, and &lt;code&gt;N = 3&lt;/code&gt; for &lt;code&gt;exs1024s&lt;/code&gt;:</source>
          <target state="translated">그리고 함께 일반적인 범위에 대한 &lt;code&gt;N = 1&lt;/code&gt; 에 대한 &lt;code&gt;exrop&lt;/code&gt; 및 &lt;code&gt;N = 3&lt;/code&gt; 에 대한 &lt;code&gt;exs1024s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61f39e10b59f839d05bcb5b7c68284a73641ca05" translate="yes" xml:space="preserve">
          <source>And for a table:</source>
          <target state="translated">그리고 테이블 :</target>
        </trans-unit>
        <trans-unit id="f32a5379f3901539fad45723e5315643f98fc032" translate="yes" xml:space="preserve">
          <source>And in, for example, a test suite or a &lt;code&gt;Common Test Hook&lt;/code&gt; function:</source>
          <target state="translated">예를 들어 테스트 스위트 또는 &lt;code&gt;Common Test Hook&lt;/code&gt; 기능에서 :</target>
        </trans-unit>
        <trans-unit id="b39e800fe601dd23ff96f3b954343b70886eba71" translate="yes" xml:space="preserve">
          <source>And now calculate the factorial of 4.</source>
          <target state="translated">이제 계승 4를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ff53b326c9030dfc8cca6e6eeea89ed1bca8b120" translate="yes" xml:space="preserve">
          <source>And so on. This is an example of &quot;lazy embedding&quot;.</source>
          <target state="translated">등등. 이것은 &quot;게으른 임베딩&quot;의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3d04ebfadc776eff044e9ab17fb00bbb3672b0de" translate="yes" xml:space="preserve">
          <source>And some more missing time can be explained by the fact that &lt;code&gt;prim_file:open_int/4&lt;/code&gt; both calls &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; directly as well as through &lt;code&gt;prim_file:open_int_setopts/3&lt;/code&gt;, which complicates the picture.</source>
          <target state="translated">그리고 &lt;code&gt;prim_file:open_int/4&lt;/code&gt; 모두 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 를 직접 호출 할뿐만 아니라 &lt;code&gt;prim_file:open_int_setopts/3&lt;/code&gt; 를 통해 직접 호출 하므로 그림이 복잡 하다는 사실로 인해 누락 된 시간이 더 설명 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cf834b4e9e15474add0506b2ca7667f1657b7fc" translate="yes" xml:space="preserve">
          <source>And that the following &lt;code&gt;match_object/2&lt;/code&gt; call:</source>
          <target state="translated">그리고 다음 &lt;code&gt;match_object/2&lt;/code&gt; 호출 :</target>
        </trans-unit>
        <trans-unit id="8f00d04a945f184b6b51fdfb0f37681af77ca055" translate="yes" xml:space="preserve">
          <source>And the &quot;ping&quot; process on kosken is started (from the code above you can see that a parameter of the &lt;code&gt;start_ping&lt;/code&gt; function is the node name of the Erlang system where &quot;pong&quot; is running):</source>
          <target state="translated">kosken에서 &quot;ping&quot;프로세스가 시작됩니다 (위의 코드에서 &lt;code&gt;start_ping&lt;/code&gt; 함수 의 매개 변수가 &quot;pong&quot;이 실행중인 Erlang 시스템의 노드 이름 임을 알 수 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="2693ffaa052313e03eb07995024a1c7e72e3275b" translate="yes" xml:space="preserve">
          <source>And the following is seen on (ping@gollum):</source>
          <target state="translated">그리고 다음은 (ping @ gollum)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebfe1b54ebc30947606f5975c34d6ebe29e39c89" translate="yes" xml:space="preserve">
          <source>And the programmers view of the same message. First a list of ActionRequest records are constructed and then it is sent with one of the send functions in the API:</source>
          <target state="translated">그리고 프로그래머들은 같은 메시지를 봅니다. 먼저 ActionRequest 레코드 목록이 구성되고 API의 send 함수 중 하나와 함께 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="03698758048cbbb8b318d7515b41284328ea7526" translate="yes" xml:space="preserve">
          <source>And the result shows that the Diffie-Hellman Group1 is added at the head of the kex list</source>
          <target state="translated">결과는 Diffie-Hellman Group1이 kex 목록의 헤드에 추가되었음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="677cd0a3c0fb90ee5c86c4248e6d3267ac590429" translate="yes" xml:space="preserve">
          <source>And then start the node like this (line breaks in the command are for readability, and shall not be there when typed):</source>
          <target state="translated">그런 다음 노드를 다음과 같이 시작하십시오 (명령의 줄 바꿈은 가독성을위한 것이며 입력 할 때는 없어야합니다).</target>
        </trans-unit>
        <trans-unit id="fde94e3ac5c46972cb11a3709289f9bf4a90825b" translate="yes" xml:space="preserve">
          <source>And waits for a reply from the server.</source>
          <target state="translated">그리고 서버에서 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f29a859de34d8206276e4fbe86c78577ef463680" translate="yes" xml:space="preserve">
          <source>And:</source>
          <target state="translated">And:</target>
        </trans-unit>
        <trans-unit id="ad0b0ead53d6b8fc85f3fce651e80aab826cba51" translate="yes" xml:space="preserve">
          <source>Anders Lindgren. The Erlang editing mode for Emacs. Ericsson, 1998.</source>
          <target state="translated">앤더스 린드그렌 Emacs의 Erlang 편집 모드. 에릭슨, 1998.</target>
        </trans-unit>
        <trans-unit id="3739bc370f12e87066b88cf2270e55e1c92949ae" translate="yes" xml:space="preserve">
          <source>Annotate as much of the Erlang VM as is practical.</source>
          <target state="translated">가능한 한 많은 Erlang VM에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="42f041d8d82dfcdd94c890b27d2f3e8b347c5ee7" translate="yes" xml:space="preserve">
          <source>Another (and quite common) case is where the regular expression matches all of the subject:</source>
          <target state="translated">또 다른 (그리고 매우 일반적인) 경우는 정규 표현식이 모든 주제와 일치하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e1571b6f7c9e0a03f663d6275fdaf99d08ee31ce" translate="yes" xml:space="preserve">
          <source>Another (probably more) useful value is to calculate total scheduler utilization weighted against maximum amount of available CPU time:</source>
          <target state="translated">또 다른 유용한 값은 사용 가능한 최대 CPU 시간에 대해 총 스케줄러 사용률을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b99bcf832002b6fe6b87b103723c706b4bdbbefb" translate="yes" xml:space="preserve">
          <source>Another case where implicit anchoring is not applied is when the leading .* is inside an atomic group. Once again, a match at the start can fail where a later one succeeds. Consider the following pattern:</source>
          <target state="translated">암시 적 앵커가 적용되지 않는 다른 경우는 선행. *가 원자 그룹 내에있는 경우입니다. 다시 한번, 시작시의 경기는 나중에 경기에서 성공할 수 없습니다. 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6501d70d60a5f422101c69f878f9e7bfb3e72c3" translate="yes" xml:space="preserve">
          <source>Another change in OTP R16 is that the generated function &lt;code&gt;encode/2&lt;/code&gt; always returns a binary. Function &lt;code&gt;encode/2&lt;/code&gt; for the &lt;code&gt;BER&lt;/code&gt; back end used to return an iolist.</source>
          <target state="translated">OTP R16의 또 다른 변경 사항은 생성 된 함수 &lt;code&gt;encode/2&lt;/code&gt; 가 항상 2 진을 리턴한다는 것입니다. iolist를 리턴하는 데 사용되는 &lt;code&gt;BER&lt;/code&gt; 백엔드에 대한 함수 &lt;code&gt;encode/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b70c5cc0d369162e261ca81ea1735ca702bccb0d" translate="yes" xml:space="preserve">
          <source>Another class of warnings is generated by the compiler during optimization and code generation. They warn about patterns that will never match (such as &lt;code&gt;a=b&lt;/code&gt;), guards that always evaluate to false, and expressions that always fail (such as &lt;code&gt;atom+42&lt;/code&gt;).</source>
          <target state="translated">최적화 및 코드 생성 중에 컴파일러에서 다른 경고 클래스를 생성합니다. 일치하지 않는 패턴 (예 : &lt;code&gt;a=b&lt;/code&gt; ), 항상 거짓으로 평가되는 가드 및 항상 실패하는 표현식 (예 : &lt;code&gt;atom+42&lt;/code&gt; ) 에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="59b4ff59fcdc233f63b2cf21983b15abb6faf95d" translate="yes" xml:space="preserve">
          <source>Another epmd module may return port and distribution protocol version as well.</source>
          <target state="translated">다른 epmd 모듈은 포트 및 배포 프로토콜 버전도 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea09d8fd71909463182da1b49dfda6ea71b82be5" translate="yes" xml:space="preserve">
          <source>Another example is provided in the discussion of DEFINE earlier.</source>
          <target state="translated">DEFINE에 대한 논의에서 다른 예가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea9622b1ad7af37a9c244233dff71af29dca1a6" translate="yes" xml:space="preserve">
          <source>Another example is the accented characters, where the same glyph has two different representations. The Swedish letter &quot;&amp;ouml;&quot; is one example. The Unicode standard has a code point for it, but you can also write it as &quot;o&quot; followed by &quot;U+0308&quot; (Combining Diaeresis, with the simplified meaning that the last letter is to have &quot;&amp;uml;&quot; above). They have the same glyph, user perceived character. They are for most purposes the same, but have different representations. For example, MacOS X converts all filenames to use Combining Diaeresis, while most other programs (including Erlang) try to hide that by doing the opposite when, for example, listing directories. However it is done, it is usually important to normalize such characters to avoid confusion.</source>
          <target state="translated">또 다른 예는 동일한 문자 모양이 서로 다른 두 가지 표현을 갖는 악센트 부호가있는 문자입니다. 스웨덴 문자 &quot;&amp;ouml;&quot;가 한 예입니다. 유니 코드 표준에는 코드 포인트가 있지만 &quot;o&quot;로 뒤에 &quot;U + 0308&quot;을 쓸 수 있습니다 (마지막 문자는 위의 &quot;&amp;uml;&quot;를 갖는 단순화 된 의미로 조합). 그들은 동일한 글리프, 사용자 인식 문자를 가지고 있습니다. 그것들은 대부분 같은 목적이지만, 다른 표현을 가지고 있습니다. 예를 들어, MacOS X은 모든 파일 이름을 Combireing Diaeresis를 사용하도록 변환하는 반면, Erlang을 포함한 대부분의 다른 프로그램은 디렉토리를 나열 할 때 반대의 방법으로이를 숨기려고합니다. 그러나 일반적으로 혼동을 피하기 위해 이러한 문자를 정규화하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">또 다른 예:</target>
        </trans-unit>
        <trans-unit id="10e22f420f5fb57de1efd47e3c06ac5d2818764b" translate="yes" xml:space="preserve">
          <source>Another format handler can be used to calculate the time spent by the garbage collector:</source>
          <target state="translated">가비지 수집기에서 소비 한 시간을 계산하는 데 다른 형식 처리기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08d37d65c3f60aefa8f056e068de920de2ce50a" translate="yes" xml:space="preserve">
          <source>Another function, &lt;code&gt;FunctionName&lt;/code&gt;, written in the same module, can be passed as an argument, using the following syntax:</source>
          <target state="translated">동일한 모듈로 작성된 다른 함수 인 &lt;code&gt;FunctionName&lt;/code&gt; 은 다음 구문을 사용하여 인수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="309724e134f98c0df5fbbbce98193626ec467206" translate="yes" xml:space="preserve">
          <source>Another interesting category of test suites is the one checking that fixed bugs do not reoccur. When a bugfix is introduced, a test case that checks for that specific bug is written and submitted to the affected test suites.</source>
          <target state="translated">테스트 스위트의 또 다른 흥미로운 범주는 수정 된 버그가 다시 발생하지 않는지 확인하는 것입니다. 버그 수정이 도입되면 해당 버그를 확인하는 테스트 사례가 작성되어 영향을받는 테스트 스위트에 제출됩니다.</target>
        </trans-unit>
        <trans-unit id="cb92a0549dc41682e51c74824d96791888dae3f5" translate="yes" xml:space="preserve">
          <source>Another list-valued representation allows a message to be specified as a list whose head is a &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and whose tail is an &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt; list. This representation is used by diameter itself when relaying requests as directed by the return value of a &lt;code&gt;handle_request/3&lt;/code&gt; callback. It differs from the other two in that it bypasses the checks for messages that do not agree with their definitions in the dictionary in question: messages are sent exactly as specified.</source>
          <target state="translated">다른리스트 값 표현은 메시지가 head가 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; 이고 tail이 &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt; 리스트 인리스트로 지정 될 수 있도록 합니다. 이 표현은 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백 의 반환 값에 따라 요청을 릴레이 할 때 직경 자체에서 사용됩니다 . 문제가되는 사전에서 정의와 일치하지 않는 메시지에 대한 검사를 무시한다는 점에서 다른 두 가지와 다릅니다. 메시지는 지정된대로 정확하게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3bc710dca2b3bdaba9f012e29980c13b5a971099" translate="yes" xml:space="preserve">
          <source>Another not uncommon scenario is to use the &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; to trigger hibernation after a certain time of inactivity. There is also a server start option &lt;code&gt;{hibernate_after, Timeout}&lt;/code&gt; for &lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">드문 일이 아닌 다른 시나리오는 일정 시간 동안 활동 이 없으면 &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; 를 사용하여 최대 절전 모드를 트리거하는 것입니다. &lt;code&gt;start/3,4&lt;/code&gt; 또는 &lt;code&gt;start_link/3,4&lt;/code&gt; 에 대한 서버 시작 옵션 &lt;code&gt;{hibernate_after, Timeout}&lt;/code&gt; 이 있어 서버를 자동으로 최대 절전 모드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044ae5d76a606877516f83b8c8933abd5c6a7076" translate="yes" xml:space="preserve">
          <source>Another obstacle is that some drivers do not support scrollable cursors which has the effect that the only way to traverse the result set is sequentially, with next, from the first row to the last, and once you pass a row you can not go back. This means that some functions in the interface will not work together with certain drivers. A similar problem is that not all drivers support &quot;row count&quot; for select queries, hence resulting in that the function &lt;code&gt;select_count/[3,4]&lt;/code&gt; will return &lt;code&gt;{ok, undefined}&lt;/code&gt; instead of &lt;code&gt;{ok, NrRows}&lt;/code&gt; where &lt;code&gt;NrRows&lt;/code&gt; is the number of rows in the result set.</source>
          <target state="translated">또 다른 장애물은 일부 드라이버가 스크롤 가능한 커서를 지원하지 않기 때문에 결과 집합을 순회하는 유일한 방법은 다음 행에서 첫 번째 행에서 마지막 행까지 순차적으로 적용되며 행을 통과하면 되돌릴 수 없다는 것입니다. 이는 인터페이스의 일부 기능이 특정 드라이버와 함께 작동하지 않음을 의미합니다. 비슷한 문제는 모든 드라이버가 선택 쿼리에 대해 &quot;행 수&quot;를 지원하지 않으므로 &lt;code&gt;select_count/[3,4]&lt;/code&gt; 함수 가 &lt;code&gt;{ok, NrRows}&lt;/code&gt; 대신 &lt;code&gt;{ok, undefined}&lt;/code&gt; 를 리턴 &lt;code&gt;NrRows&lt;/code&gt; 입니다. 여기서 NrRows 는 결과 집합의 행</target>
        </trans-unit>
        <trans-unit id="03ee6d9c0afb580323a804d3eab4b79501841ee3" translate="yes" xml:space="preserve">
          <source>Another option is to have an entire Erlang archive in the script. In an archive script, the interpretation of the script header is the same as in a script containing source code. This means that you can make an archive file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In an archive script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported. By default the &lt;code&gt;main/1&lt;/code&gt; function in the module with the same name as the basename of the &lt;code&gt;escript&lt;/code&gt; file is invoked. This behavior can be overridden by setting flag &lt;code&gt;-escript main Module&lt;/code&gt; as one of the emulator flags. &lt;code&gt;Module&lt;/code&gt; must be the name of a module that has an exported &lt;code&gt;main/1&lt;/code&gt; function. For more information about archives and code loading, see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">또 다른 옵션은 스크립트에 전체 Erlang 아카이브를 보유하는 것입니다. 아카이브 스크립트에서 스크립트 헤더의 해석은 소스 코드를 포함하는 스크립트에서와 동일합니다. 즉, 파일 앞에 &lt;code&gt;#!&lt;/code&gt; 으로 시작하는 줄을 붙여 파일을 실행 파일로 만들 수 있습니다 . 그리고 &lt;code&gt;%%!&lt;/code&gt; 위에 언급했듯이. 아카이브 스크립트에서 &lt;code&gt;main/1&lt;/code&gt; 기능을 내 보내야합니다. 기본적으로 &lt;code&gt;escript&lt;/code&gt; 파일 의 기본 이름과 이름이 같은 모듈 의 &lt;code&gt;main/1&lt;/code&gt; 함수 가 호출됩니다. 이 동작은 flag &lt;code&gt;-escript main Module&lt;/code&gt; 을 에뮬레이터 플래그 중 하나로 설정하여 무시할 수 있습니다 . &lt;code&gt;Module&lt;/code&gt; 은 내 보낸 &lt;code&gt;main/1&lt;/code&gt; 이있는 모듈의 이름이어야합니다함수. 아카이브 및 코드로드에 대한 자세한 내용은 &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4546ea403c4311f977adb2b766d698fe32f245cc" translate="yes" xml:space="preserve">
          <source>Another option is to try to read the whole file in UTF-8 encoding and see if it fails. Here we need to read the file using function &lt;code&gt;io:get_chars/3&lt;/code&gt;, as we have to read characters with a code point &amp;gt; 255:</source>
          <target state="translated">다른 옵션은 전체 파일을 UTF-8 인코딩으로 읽고 실패하는지 확인하는 것입니다. 여기서 코드 포인트가 255보다 큰 문자를 읽어야하므로 &lt;code&gt;io:get_chars/3&lt;/code&gt; 함수를 사용하여 파일을 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2021d9cc317b0927635ce1f21baa6d5c5c2fd2c7" translate="yes" xml:space="preserve">
          <source>Another reason to filter the state can be that the state is too large to print, as it fills the error log with uninteresting details.</source>
          <target state="translated">상태를 필터링하는 또 다른 이유는 상태가 너무 커서 인쇄 할 수 없기 때문에 오류 로그에 관심없는 세부 사항이 채워지기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7a115c72c46457e1cc897d74c27eca7f1027cedb" translate="yes" xml:space="preserve">
          <source>Another special case is &lt;code&gt;{message, true}&lt;/code&gt;, which sets the default behavior, as if the function had no match specification; trace message is sent with no extra information (if no other calls to &lt;code&gt;message&lt;/code&gt; are placed before &lt;code&gt;{message, true}&lt;/code&gt;, it is in fact a &quot;noop&quot;).</source>
          <target state="translated">또 다른 특수한 경우는 &lt;code&gt;{message, true}&lt;/code&gt; . 이는 함수에 일치 스펙이없는 것처럼 기본 동작을 설정합니다. 추적 메시지는 추가 정보없이 전송됩니다 ( &lt;code&gt;{message, true}&lt;/code&gt; 앞에 다른 &lt;code&gt;message&lt;/code&gt; 호출이없는 경우 실제로 &quot;noop&quot;임).</target>
        </trans-unit>
        <trans-unit id="b328fda19cc7c09a7238c9e06a0a0739b5922118" translate="yes" xml:space="preserve">
          <source>Another thing that has been added to the messenger is a macro. The file &lt;code&gt;mess_config.hrl&lt;/code&gt; contains the definition:</source>
          <target state="translated">메신저에 추가 된 또 다른 것은 매크로입니다. &lt;code&gt;mess_config.hrl&lt;/code&gt; 파일 에는 다음 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d5f93c71127e50ff2df112ec2940a1427d89fd" translate="yes" xml:space="preserve">
          <source>Another top type is &lt;code&gt;Window&lt;/code&gt; whose subcomponent actions in type &lt;code&gt;Status&lt;/code&gt; and the parts of component &lt;code&gt;buttonList&lt;/code&gt; are to be left undecoded. For this type, the function is named &lt;code&gt;decode__Window_exclusive&lt;/code&gt;. The complete &lt;code&gt;Exclusive_Decode_Instruction&lt;/code&gt; configuration is as follows:</source>
          <target state="translated">또 다른 탑의 형태는 &lt;code&gt;Window&lt;/code&gt; 누구의 하위 유형에서 동작 &lt;code&gt;Status&lt;/code&gt; 및 구성 요소의 부품 &lt;code&gt;buttonList&lt;/code&gt; 있습니다 디코드되지 않은 왼쪽한다. 이 유형의 경우 함수 이름은 &lt;code&gt;decode__Window_exclusive&lt;/code&gt; 입니다. &lt;code&gt;Exclusive_Decode_Instruction&lt;/code&gt; 의 전체 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13dcc540145f3717c4e3da385edb41a46331941d" translate="yes" xml:space="preserve">
          <source>Another typical overload situation is when the transaction manager cannot commit transactions at the same pace as the applications perform updates of disc resident tables. When this occurs, the message queue of the transaction manager continues to grow until the memory is exhausted or the load decreases.</source>
          <target state="translated">또 다른 일반적인 과부하 상황은 응용 프로그램이 디스크 상주 테이블의 업데이트를 수행하는 것과 같은 속도로 트랜잭션 관리자가 트랜잭션을 커밋 할 수없는 경우입니다. 이 경우 메모리가 소진되거나로드가 줄어들 때까지 트랜잭션 관리자의 메시지 큐가 계속 커집니다.</target>
        </trans-unit>
        <trans-unit id="98678e4d7ab8dd43533df21422a00a975cfb7ba2" translate="yes" xml:space="preserve">
          <source>Another use of backslash is for specifying generic character types:</source>
          <target state="translated">백 슬래시의 또 다른 용도는 일반 문자 유형을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d11989cebb406290ee365764c7d5bbc4cda6a5df" translate="yes" xml:space="preserve">
          <source>Another use of resource objects is to create binary terms with user-defined memory management. &lt;code&gt;&lt;a href=&quot;#enif_make_resource_binary&quot;&gt;enif_make_resource_binary&lt;/a&gt;&lt;/code&gt; creates a binary term that is connected to a resource object. The destructor of the resource is called when the binary is garbage collected, at which time the binary data can be released. An example of this can be a binary term consisting of data from a &lt;code&gt;mmap&lt;/code&gt;'ed file. The destructor can then do &lt;code&gt;munmap&lt;/code&gt; to release the memory region.</source>
          <target state="translated">리소스 개체의 또 다른 사용은 사용자 정의 메모리 관리를 사용하여 이진 용어를 만드는 것입니다. &lt;code&gt;&lt;a href=&quot;#enif_make_resource_binary&quot;&gt;enif_make_resource_binary&lt;/a&gt;&lt;/code&gt; 는 자원 객체에 연결된 이진 용어를 만듭니다. 바이너리가 가비지 수집 될 때 리소스의 소멸자가 호출되며이 시간에 바이너리 데이터가 해제 될 수 있습니다. 이것의 예는 &lt;code&gt;mmap&lt;/code&gt; 파일 의 데이터로 구성된 이진 용어 일 수 있습니다 . 그러면 소멸자는 &lt;code&gt;munmap&lt;/code&gt; 을 수행 하여 메모리 영역을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89a360b85a80ca71d493e71ccdbdd60966421147" translate="yes" xml:space="preserve">
          <source>Another usefull way to debug the agent is to pretty-print the content of all the tables and/or variables handled directly by the agent. This can be done by simply calling:</source>
          <target state="translated">에이전트를 디버깅하는 또 다른 유용한 방법은 에이전트가 직접 처리하는 모든 테이블 및 / 또는 변수의 내용을 예쁘게 인쇄하는 것입니다. 간단히 다음을 호출하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631c1a6022578e3dee77a77d5a201dbaf7fc890e" translate="yes" xml:space="preserve">
          <source>Another way of creating and giving a variable a value is by using the match operator = . So if you write &lt;code&gt;M = 5&lt;/code&gt;, a variable called &lt;code&gt;M&lt;/code&gt; is created with the value 5. If, in the same scope, you then write &lt;code&gt;M = 6&lt;/code&gt;, an error is returned. Try this out in the shell:</source>
          <target state="translated">변수를 만들고 값을 제공하는 또 다른 방법은 match operator =를 사용하는 것입니다. 그래서 당신이 쓰는 경우 &lt;code&gt;M = 5&lt;/code&gt; ,라는 변수 &lt;code&gt;M&lt;/code&gt; 은 같은 범위의 값 5. 만약, 작성됩니다, 당신은 그 쓰기 &lt;code&gt;M = 6&lt;/code&gt; , 오류가 리턴됩니다. 쉘에서 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="beaca871bb31a9b7342a385e8665dcccb5f095c3" translate="yes" xml:space="preserve">
          <source>Another way of measuring system load is to divide the number of busy CPU cycles by the total number of CPU cycles. This produces values in the 0-100 range immediately. However, this method hides the fact that a machine can be more or less saturated. CPU utilization is therefore a better name than system load for this measure.</source>
          <target state="translated">시스템로드를 측정하는 또 다른 방법은 사용중인 CPU주기 수를 총 CPU주기 수로 나누는 것입니다. 0-100 범위의 값이 즉시 생성됩니다. 그러나이 방법은 기계가 다소 포화 될 수 있다는 사실을 숨 깁니다. 따라서 CPU 사용량은이 측정에 대한 시스템로드보다 나은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b77873668d8c56ac39491fa5217a49f4134bcf11" translate="yes" xml:space="preserve">
          <source>Another way of tracing from the shell is to explicitly start a &lt;strong&gt;tracer&lt;/strong&gt; and then set the &lt;strong&gt;trace flags&lt;/strong&gt; of your choice on the processes you want to trace, e.g. trace messages and process events:</source>
          <target state="translated">쉘에서 추적하는 다른 방법은 추적 &lt;strong&gt;프로그램&lt;/strong&gt; 을 명시 적으로 시작한 다음 &lt;strong&gt;추적&lt;/strong&gt; 하려는 프로세스 (예 : 추적 메시지 및 프로세스 이벤트)에서 선택한 &lt;strong&gt;추적 플래그&lt;/strong&gt; 를 설정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4b3ea1157a1e3ea0689f0faf146db56bad7d2042" translate="yes" xml:space="preserve">
          <source>Another way of writing an ASCII space</source>
          <target state="translated">ASCII 공간을 쓰는 또 다른 방법</target>
        </trans-unit>
        <trans-unit id="a5bc6479b6ef5274ab93784eff95e33c9f88ddd5" translate="yes" xml:space="preserve">
          <source>Another way to avoid the ambiguity inherent in the use of digits following a backslash is to use the \g escape sequence. This escape must be followed by an unsigned number or a negative number, optionally enclosed in braces. The following examples are identical:</source>
          <target state="translated">백 슬래시 다음에 숫자를 사용할 때의 모호성을 피하는 또 다른 방법은 \ g 이스케이프 시퀀스를 사용하는 것입니다. 이 이스케이프 뒤에는 부호없는 숫자 또는 음수 (선택적으로 중괄호로 묶음)가 와야합니다. 다음 예는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f458a6491b77ecc59537584a0547eeea4ea55395" translate="yes" xml:space="preserve">
          <source>Another way to do it is through a convenience macro &lt;code&gt;?HANDLE_COMMON/0&lt;/code&gt;:</source>
          <target state="translated">또 다른 방법은 편의 매크로 &lt;code&gt;?HANDLE_COMMON/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b35642aab3a9386c91529db83078918912ca068a" translate="yes" xml:space="preserve">
          <source>Another way to handle a late time-out can be to not cancel it, but to ignore it if it arrives in a state where it is known to be late.</source>
          <target state="translated">지연 시간 초과를 처리하는 다른 방법은 취소하지 않고 지연된 것으로 알려진 상태에 도달하면 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eab5fcb4424189a95f4719598653f6d7d5dc728f" translate="yes" xml:space="preserve">
          <source>Another way to shut down the Erlang system is by entering &lt;code&gt;halt()&lt;/code&gt;:</source>
          <target state="translated">Erlang 시스템을 종료하는 또 다른 방법은 &lt;code&gt;halt()&lt;/code&gt; 를 입력하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="92b1a017090fced695e7f6bcf9c838e8a0d3d945" translate="yes" xml:space="preserve">
          <source>Another way to to profile a specific function is to use &lt;code&gt;lcnt:apply/3&lt;/code&gt; or &lt;code&gt;lcnt:apply/1&lt;/code&gt; which does &lt;code&gt;lcnt:clear/0&lt;/code&gt; before the function and &lt;code&gt;lcnt:collect/0&lt;/code&gt; after its invocation. This method should only be used in micro-benchmarks since it sets &lt;code&gt;copy_save&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for the duration of the function call, which may cause the emulator to run out of memory if attempted under load.</source>
          <target state="translated">특정 함수를 프로파일 링하는 또 다른 방법은 &lt;code&gt;lcnt:apply/3&lt;/code&gt; 또는 &lt;code&gt;lcnt:apply/1&lt;/code&gt; 을 사용 하는 &lt;code&gt;lcnt:clear/0&lt;/code&gt; 이 함수는 함수 전에 lcnt : clear / 0 을 수행하고 호출 후 &lt;code&gt;lcnt:collect/0&lt;/code&gt; 을 수행합니다. 이 메소드는 함수 호출 동안 &lt;code&gt;copy_save&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하기 때문에 마이크로 벤치 마크에서만 사용해야합니다 .로드 중에 시도하면 에뮬레이터의 메모리가 부족해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c508f0c9fa83edd30ab43020e59877671989a88" translate="yes" xml:space="preserve">
          <source>Answer message are constructed by the user, except in the case of some protocol errors, in which case the procedures are followed.</source>
          <target state="translated">응답 메시지는 일부 프로토콜 오류의 경우를 제외하고 절차에 따라 사용자가 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f990ff206be9a4e762b0a5b682dfe432e3832419" translate="yes" xml:space="preserve">
          <source>Answers are formulated by the user in most cases. Answers setting the E-bit can be sent by diameter itself in response to a request that cannot be handled by the user.</source>
          <target state="translated">대부분의 경우 사용자가 답변을 정합니다. E 비트 설정에 대한 답변은 사용자가 처리 할 수없는 요청에 대한 응답으로 직경 자체로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169733414ac8e9f0faf1ef2e5d16061544324aa9" translate="yes" xml:space="preserve">
          <source>Answers sent by diameter set the E-bit in the Diameter Header. Since RFC 3588 allows only 3xxx result codes in an &lt;code&gt;answer-message&lt;/code&gt;, &lt;code&gt;answer&lt;/code&gt; has the same semantics as &lt;code&gt;answer_3xxx&lt;/code&gt; when the transport in question has been configured with &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; as its common dictionary. Since RFC 6733 allows both 3xxx and 5xxx result codes in an &lt;code&gt;answer-message&lt;/code&gt;, a transport with &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; as its common dictionary does distinguish between &lt;code&gt;answer_3xxx&lt;/code&gt; and &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">직경으로 전송 된 응답은 직경 헤더에서 E- 비트를 설정합니다. RFC 3588은 오직 3xxx 결과 코드 할 수 있으므로 &lt;code&gt;answer-message&lt;/code&gt; , &lt;code&gt;answer&lt;/code&gt; 동일한 의미를 갖는다 &lt;code&gt;answer_3xxx&lt;/code&gt; 을 당해 반송로가 구성되면 &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; 그 공통 사전있다. RFC 6733은 &lt;code&gt;answer-message&lt;/code&gt; 에 3xxx 및 5xxx 결과 코드를 모두 허용하므로 일반적인 사전 으로 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 을 사용 하는 전송 은 &lt;code&gt;answer_3xxx&lt;/code&gt; 와 &lt;code&gt;answer&lt;/code&gt; 를 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="9583537a8ed59cb672cc8682638edb7ea0041ae4" translate="yes" xml:space="preserve">
          <source>Answers with an unknown Hop-by-Hop Identifier are discarded.</source>
          <target state="translated">알 수없는 Hop-by-Hop 식별자가있는 답변은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3e81377569d145d2611633104ee94d8766283535" translate="yes" xml:space="preserve">
          <source>Any &quot;non-word&quot; character</source>
          <target state="translated">&quot;단어가 아닌&quot;문자</target>
        </trans-unit>
        <trans-unit id="85b67100ee7b90e2d2abf4839ebeec56e0874f69" translate="yes" xml:space="preserve">
          <source>Any &quot;word&quot; character</source>
          <target state="translated">&quot;단어&quot;문자</target>
        </trans-unit>
        <trans-unit id="1da1afe530c2a09d5e4de484a6f1c75175270218" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; returned from this call are handled as if they were appended to the actions returned by the state callback that caused the state entry.</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 들은 상태 항목의 원인이 된 상태 콜백에 의해 반환 조치에 추가 것처럼이 호출에서 반환이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7cf207a939aac0db4a1f7cbab14794dc67dd5e" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;{netmask,_}&lt;/code&gt;, &lt;code&gt;{broadaddr,_}&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; tuples that follow an &lt;code&gt;{addr,_}&lt;/code&gt; tuple concerns that address.</source>
          <target state="translated">&lt;code&gt;{addr,_}&lt;/code&gt; 튜플 다음에 오는 모든 &lt;code&gt;{netmask,_}&lt;/code&gt; , &lt;code&gt;{broadaddr,_}&lt;/code&gt; 또는 &lt;code&gt;{dstaddr,_}&lt;/code&gt; 튜플은 해당 주소와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe20daf09d18f48c6423a6e429a2fc557aba724" translate="yes" xml:space="preserve">
          <source>Any Erlang terms can be passed to a NIF as function arguments and be returned as function return values. The terms are of C-type &lt;code&gt;&lt;a href=&quot;#ERL_NIF_TERM&quot;&gt;ERL_NIF_TERM&lt;/a&gt;&lt;/code&gt; and can only be read or written using API functions. Most functions to read the content of a term are prefixed &lt;code&gt;enif_get_&lt;/code&gt; and usually return &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) if the term is of the expected type (or not). The functions to write terms are all prefixed &lt;code&gt;enif_make_&lt;/code&gt; and usually return the created &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;. There are also some functions to query terms, like &lt;code&gt;enif_is_atom&lt;/code&gt;, &lt;code&gt;enif_is_identical&lt;/code&gt;, and &lt;code&gt;enif_compare&lt;/code&gt;.</source>
          <target state="translated">모든 Erlang 용어는 함수 인수로 NIF에 전달되고 함수 리턴 값으로 리턴 될 수 있습니다. 용어는 C 유형 &lt;code&gt;&lt;a href=&quot;#ERL_NIF_TERM&quot;&gt;ERL_NIF_TERM&lt;/a&gt;&lt;/code&gt; 이며 API 함수를 통해서만 읽거나 쓸 수 있습니다. 용어의 내용을 읽는 대부분의 함수는 접두사 &lt;code&gt;enif_get_&lt;/code&gt; 이며 일반적으로 용어가 예상되는 유형이거나 그렇지 않은 경우 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; )를 반환 합니다 . 용어를 작성하는 함수는 모두 접두사 &lt;code&gt;enif_make_&lt;/code&gt; 이며 일반적으로 작성된 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;enif_is_atom&lt;/code&gt; , &lt;code&gt;enif_is_identical&lt;/code&gt; 및 &lt;code&gt;enif_compare&lt;/code&gt; 와 같은 용어를 쿼리하는 함수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91ee5b553226d8e2804f2a9b1b852b4188f05b90" translate="yes" xml:space="preserve">
          <source>Any Perl &quot;word&quot; character. Matches the same characters as Xan, plus underscore.</source>
          <target state="translated">모든 Perl &quot;단어&quot;문자. Xan과 동일한 문자 및 밑줄을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2a6ee9049397cf4af2bc8f42c671c9f43f3a14a3" translate="yes" xml:space="preserve">
          <source>Any Perl space character. Matches the same as Xps, except that vertical tab is excluded.</source>
          <target state="translated">모든 Perl 공백 문자 세로 탭을 제외하고 Xps와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="226314c00726c9d0643044e7e14db2c1e0125f64" translate="yes" xml:space="preserve">
          <source>Any Posix space character. Matches the characters tab, line feed, vertical tab, form feed, carriage return, and any other character that has the Z (separator) property.</source>
          <target state="translated">모든 Posix 공백 문자. 문자 탭, 줄 바꿈, 세로 탭, 용지 공급, 캐리지 리턴 및 Z (구분 기호) 속성이있는 다른 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="86c83cd82d7f4cc2cb73a7ce452f11a22f90230a" translate="yes" xml:space="preserve">
          <source>Any SNMP agent must implement the &lt;code&gt;system&lt;/code&gt; group and the &lt;code&gt;snmp&lt;/code&gt; group, defined in MIB-II. The definitions of these groups have changed from SNMPv1 to SNMPv2. MIBs and implementations for both of these versions are Provided in the distribution. The MIB file for SNMPv1 is called STANDARD-MIB, and the corresponding for SNMPv2 is called SNMPv2-MIB. If the agent is configured for SNMPv1 only, the STANDARD-MIB is loaded by default; otherwise, the SNMPv2-MIB is loaded by default. It is possible to override this default behavior, by explicitly loading another version of this MIB, for example, you could choose to implement the union of all objects in these two MIBs.</source>
          <target state="translated">모든 SNMP 에이전트는 MIB-II에 정의 된 &lt;code&gt;system&lt;/code&gt; 그룹 및 &lt;code&gt;snmp&lt;/code&gt; 그룹을 구현해야합니다 . 이 그룹의 정의가 SNMPv1에서 SNMPv2로 변경되었습니다. 이 두 버전에 대한 MIB 및 구현은 배포판에서 제공됩니다. SNMPv1의 MIB 파일을 STANDARD-MIB라고하고 SNMPv2의 해당 파일을 SNMPv2-MIB라고합니다. 에이전트가 SNMPv1에 대해서만 구성된 경우 STANDARD-MIB가 기본적으로로드됩니다. 그렇지 않으면 기본적으로 SNMPv2-MIB가로드됩니다. 이 MIB의 다른 버전을 명시 적으로로드하여이 기본 동작을 무시할 수 있습니다. 예를 들어,이 두 MIB에있는 모든 오브젝트의 통합을 구현하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="196d50214eeaa49a69b1974dba346995c28a22e1" translate="yes" xml:space="preserve">
          <source>Any Unicode newline sequence</source>
          <target state="translated">모든 유니 코드 줄 바꾸기 시퀀스</target>
        </trans-unit>
        <trans-unit id="a65ddd3bdd2944c171915eb7fa336f1a4c035808" translate="yes" xml:space="preserve">
          <source>Any alphanumeric character. Matches characters that have either the L (letter) or the N (number) property.</source>
          <target state="translated">영숫자 L (문자) 또는 N (숫자) 속성이있는 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8e4c53abc141aa6a5505d99af2747ead8bf5f3b8" translate="yes" xml:space="preserve">
          <source>Any argument starting with character &lt;code&gt;+&lt;/code&gt; is interpreted as an &lt;code&gt;&lt;a href=&quot;#emu_flags&quot;&gt;emulator flag&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;+&lt;/code&gt; 로 시작하는 모든 인수 는 &lt;code&gt;&lt;a href=&quot;#emu_flags&quot;&gt;emulator flag&lt;/a&gt;&lt;/code&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ec0d985bf2bc312c2013a5109c14aa8377ee3b4" translate="yes" xml:space="preserve">
          <source>Any argument starting with character &lt;code&gt;-&lt;/code&gt; (hyphen) is interpreted as a &lt;code&gt;&lt;a href=&quot;#init_flags&quot;&gt;flag&lt;/a&gt;&lt;/code&gt;, which is to be passed to the Erlang part of the runtime system, more specifically to the &lt;code&gt;init&lt;/code&gt; system process, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자로 시작하는 모든 인자 &lt;code&gt;-&lt;/code&gt; (하이픈)가 해석되는 &lt;code&gt;&lt;a href=&quot;#init_flags&quot;&gt;flag&lt;/a&gt;&lt;/code&gt; 런타임 시스템의 얼랑 부에 전달하는,보다 구체적으로 &lt;code&gt;init&lt;/code&gt; 시스템 프로세스 참조 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38632ef9e937e28c7efee903ba40a94fa4e2fdf" translate="yes" xml:space="preserve">
          <source>Any available SSL/TLS option can be specified in an options file, but note that options that take a &lt;code&gt;fun()&lt;/code&gt; has to use the syntax &lt;code&gt;fun Mod:Func/Arity&lt;/code&gt; since a function body can not be compiled when consulting a file.</source>
          <target state="translated">사용 가능한 SSL / TLS 옵션은 옵션 파일에서 지정할 수 있지만 &lt;code&gt;fun()&lt;/code&gt; 을 사용 하는 옵션 은 파일을 참조 할 때 함수 본문을 컴파일 할 수 없으므로 &lt;code&gt;fun Mod:Func/Arity&lt;/code&gt; 구문을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="01cf19500fd684b4fcd4ae4381bd475d059416c3" translate="yes" xml:space="preserve">
          <source>Any binaries in the input must be encoded with utf8 encoding.</source>
          <target state="translated">입력의 모든 바이너리는 utf8 인코딩으로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4fbd6641fa6af8908c4acddf8ea7d500dda6804" translate="yes" xml:space="preserve">
          <source>Any character that \p{Nd} matches (decimal digit)</source>
          <target state="translated">\ p {Nd}와 일치하는 모든 문자 (10 진수)</target>
        </trans-unit>
        <trans-unit id="ea8d8e8635593d775e42e49ce0087f6c13f6687f" translate="yes" xml:space="preserve">
          <source>Any character that \p{Z} or \h or \v</source>
          <target state="translated">\ p {Z} 또는 \ h 또는 \ v 인 모든 문자</target>
        </trans-unit>
        <trans-unit id="5a07d4df31dba87893c12b1bbe3486e16831b58c" translate="yes" xml:space="preserve">
          <source>Any character that is not a decimal digit</source>
          <target state="translated">10 진수가 아닌 모든 문자</target>
        </trans-unit>
        <trans-unit id="a220eeb7e71547f74bdb672a46dbf62304938ae3" translate="yes" xml:space="preserve">
          <source>Any character that is not a horizontal whitespace character</source>
          <target state="translated">가로 공백 문자가 아닌 문자</target>
        </trans-unit>
        <trans-unit id="38b05e383aff7b661066a32cce33de8ce1d64c59" translate="yes" xml:space="preserve">
          <source>Any character that is not a vertical whitespace character</source>
          <target state="translated">수직 공백 문자가 아닌 문자</target>
        </trans-unit>
        <trans-unit id="637eb6003dd0e91f78519cb1c04ebd5b49030962" translate="yes" xml:space="preserve">
          <source>Any character that is not a whitespace character</source>
          <target state="translated">공백 문자가 아닌 모든 문자</target>
        </trans-unit>
        <trans-unit id="4f01080c6afb4764ff8a2fd9f3cf18325105c6f2" translate="yes" xml:space="preserve">
          <source>Any character that matches \p{L} or \p{N} matches, plus underscore</source>
          <target state="translated">\ p {L} 또는 \ p {N}와 일치하는 모든 문자와 밑줄</target>
        </trans-unit>
        <trans-unit id="9e0fc4e31db4954506ff95018d4e32009cec2276" translate="yes" xml:space="preserve">
          <source>Any child process, static or dynamic, can be stopped in accordance with the shutdown specification:</source>
          <target state="translated">정적 또는 동적의 모든 하위 프로세스는 종료 사양에 따라 중지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61f1827d9b493037b4c65e46ae25e3793bc6166" translate="yes" xml:space="preserve">
          <source>Any decimal digit</source>
          <target state="translated">십진수</target>
        </trans-unit>
        <trans-unit id="319ee56af7d8c4842eef10b32506ec7273db2e2d" translate="yes" xml:space="preserve">
          <source>Any directory structure for development will suffice as long as the released directory structure adhere to the &lt;code&gt;&lt;a href=&quot;#app_dir_released&quot;&gt;description below&lt;/a&gt;&lt;/code&gt;, but it is encouraged that the same directory structure also be used in a development environment. The version number should be omitted from the application directory name since this is an artifact of the release step.</source>
          <target state="translated">릴리스 된 디렉토리 구조가 &lt;code&gt;&lt;a href=&quot;#app_dir_released&quot;&gt;description below&lt;/a&gt;&lt;/code&gt; 준수하는 한 개발 용 디렉토리 구조로 충분 하지만 개발 환경에서 동일한 디렉토리 구조를 사용하는 것이 좋습니다. 릴리스 번호의 아티팩트이므로 버전 번호는 애플리케이션 디렉토리 이름에서 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f8a0eebe69f32841c1055bf42eb38c869fc05ac" translate="yes" xml:space="preserve">
          <source>Any error responded from ssl:connect/3</source>
          <target state="translated">ssl : connect / 3에서 응답 한 오류</target>
        </trans-unit>
        <trans-unit id="dec33b5efd25869658a9a136d55b25ab0eb75ddb" translate="yes" xml:space="preserve">
          <source>Any event cancels an &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; so a zero time event time-out is only generated if the event queue is empty.</source>
          <target state="translated">모든 이벤트는 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; 취소 하므로 이벤트 큐가 비어있는 경우에만 제로 타임 이벤트 시간 초과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f3230758bd2f1f41e208786128600a644fbcfaad" translate="yes" xml:space="preserve">
          <source>Any event that arrives cancels this time-out. Note that a retried or inserted event counts as arrived. So does a state time-out zero event, if it was generated before this time-out is requested.</source>
          <target state="translated">도착하는 모든 이벤트는이 시간 초과를 취소합니다. 재시도 또는 삽입 된 이벤트는 도착한 것으로 계산됩니다. 이 타임 아웃이 요청되기 전에 생성 된 상태 타임 아웃 제로 이벤트도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8b1366eda009f3cb3ff94bd016d0c7d4a6262e2b" translate="yes" xml:space="preserve">
          <source>Any existing file &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created when &lt;code&gt;write_config/2&lt;/code&gt; is called. Option &lt;code&gt;append&lt;/code&gt; can be used to add something at the end of an existing configuration file, for example, &lt;code&gt;ttb:write_config(ConfigFile,What,[append])&lt;/code&gt;.</source>
          <target state="translated">기존 파일 &lt;code&gt;ConfigFile&lt;/code&gt; 이 삭제되고 &lt;code&gt;write_config/2&lt;/code&gt; 가 호출 될 때 새 파일이 작성됩니다 . 옵션 &lt;code&gt;append&lt;/code&gt; 예를 들어, 기존 구성 파일의 마지막에 무언가를 추가 할 수 있습니다 &lt;code&gt;ttb:write_config(ConfigFile,What,[append])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566ef8318f6e8dea307d9a0b22e6f9fb3da4fcf5" translate="yes" xml:space="preserve">
          <source>Any field from the default object that is updated is not an integer.</source>
          <target state="translated">업데이트 된 기본 개체의 모든 필드는 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="633c884f979bcb23bdcf6332835bc8f4a916554f" translate="yes" xml:space="preserve">
          <source>Any file in the archive can be compressed, but to speed up the access of frequently read files, it can be a good idea to store &lt;code&gt;beam&lt;/code&gt; and &lt;code&gt;app&lt;/code&gt; files uncompressed in the archive.</source>
          <target state="translated">아카이브의 모든 파일을 압축 할 수 있지만 자주 읽는 파일의 액세스 속도를 높이려면 &lt;code&gt;beam&lt;/code&gt; 과 &lt;code&gt;app&lt;/code&gt; 파일을 압축되지 않은 상태로 아카이브 에 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c9e92376776fce4af3e899f17a6815d5de8767ca" translate="yes" xml:space="preserve">
          <source>Any further messages sent to the servers, after this function has returned, are received by all servers after this message.</source>
          <target state="translated">이 기능이 리턴 된 후 서버로 전송 된 추가 메시지는이 메시지 다음에 모든 서버에서 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="05a7cdc632d004fced39b4b64081edd1072ad277" translate="yes" xml:space="preserve">
          <source>Any help module (that is, regular Erlang module with name not ending with &quot;_SUITE&quot;) that resides in the same test object directory as a suite, which is part of the test, is also automatically compiled. A help module is not mistaken for a test suite (unless it has a &quot;_SUITE&quot; name). All help modules in a particular test object directory are compiled, no matter if all or only particular suites in the directory are part of the test.</source>
          <target state="translated">테스트의 일부인 스위트와 동일한 테스트 오브젝트 디렉토리에있는 도움말 모듈 (즉, 이름이 &quot;_SUITE&quot;로 끝나지 않는 일반 Erlang 모듈)도 자동으로 컴파일됩니다. 도움말 모듈은 &quot;_SUITE&quot;이름이없는 한 테스트 스위트로 오인되지 않습니다. 디렉토리의 특정 스위트가 전부 또는 일부만 테스트의 일부인지 여부에 관계없이 특정 테스트 오브젝트 디렉토리의 모든 도움말 모듈이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="3a6931e3ecbbcf6123711ba9b45a1b2a389671aa" translate="yes" xml:space="preserve">
          <source>Any horizontal whitespace character</source>
          <target state="translated">수평 공백 문자</target>
        </trans-unit>
        <trans-unit id="59054d406899b9265407eef94618b3745ddccb9c" translate="yes" xml:space="preserve">
          <source>Any kind of set (also included are the atomic sets).</source>
          <target state="translated">모든 종류의 세트 (원자 세트도 포함).</target>
        </trans-unit>
        <trans-unit id="3059e6bd637c2c7edbf7392d90b2b06549a0c4a4" translate="yes" xml:space="preserve">
          <source>Any message from an agent that is not registered is delivered to the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">등록되지 않은 에이전트의 모든 메시지는 &lt;strong&gt;기본 사용자&lt;/strong&gt; 에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e3cde1fa4436f7ff04b9991cb3b2f50c010632c" translate="yes" xml:space="preserve">
          <source>Any module attribute can be specified. The attributes are stored in the compiled code and can be retrieved by calling &lt;code&gt;Module:module_info(attributes)&lt;/code&gt;, or by using the module &lt;code&gt;beam_lib(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">모든 모듈 속성을 지정할 수 있습니다. 속성은 컴파일 된 코드에 저장되며 &lt;code&gt;Module:module_info(attributes)&lt;/code&gt; 를 호출 하거나 &lt;code&gt;beam_lib(3)&lt;/code&gt; 모듈을 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29b8882fa4dee978fed00f1684dc7ee4e8066671" translate="yes" xml:space="preserve">
          <source>Any more option that is applied is passed to the final step when the generated &lt;code&gt;.erl&lt;/code&gt; file is compiled.</source>
          <target state="translated">생성 된 &lt;code&gt;.erl&lt;/code&gt; 파일이 컴파일 될 때 적용되는 추가 옵션이 최종 단계로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b639a0e3ab8cf373688218aa41c8bf04708e870b" translate="yes" xml:space="preserve">
          <source>Any node in &lt;code&gt;Tree&lt;/code&gt; whose node type is &lt;code&gt;variable&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;), and whose list of annotations (see &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt;) contains the atom &lt;code&gt;meta_var&lt;/code&gt;, will remain unchanged in the resulting tree, except that exactly one occurrence of &lt;code&gt;meta_var&lt;/code&gt; is removed from its annotation list.</source>
          <target state="translated">노드 유형이 &lt;code&gt;variable&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 참조 ) 주석 목록 ( &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt; 참조 )에 원자 &lt;code&gt;meta_var&lt;/code&gt; 가 포함 된 &lt;code&gt;Tree&lt;/code&gt; 의 모든 노드는 meta_var 가 정확히 한 &lt;code&gt;meta_var&lt;/code&gt; 제거되는 것을 제외하고 결과 트리에서 변경되지 않은 상태로 유지 됩니다. 주석 목록.</target>
        </trans-unit>
        <trans-unit id="12506e60046e3f66a27e9d0f21bb59c5951fbf0d" translate="yes" xml:space="preserve">
          <source>Any nodes created outside of this module must have type tags distinct from those currently defined by this module; see &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; for a complete list.</source>
          <target state="translated">이 모듈 외부에서 작성된 모든 노드에는이 모듈에서 현재 정의 된 유형 태그와 다른 유형 태그가 있어야합니다. 전체 목록 은 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dd390a9f5c9070fbf0caa7f7decb4d0243c2039" translate="yes" xml:space="preserve">
          <source>Any number of alternatives can appear, and an empty alternative is permitted (matching the empty string). The matching process tries each alternative in turn, from left to right, and the first that succeeds is used. If the alternatives are within a subpattern (defined in section &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt;), &quot;succeeds&quot; means matching the remaining main pattern and the alternative in the subpattern.</source>
          <target state="translated">여러 대안이 나타날 수 있으며 빈 문자열과 일치하는 빈 대안이 허용됩니다. 일치 프로세스는 각 대안을 왼쪽에서 오른쪽으로 차례로 시도하며 성공한 첫 번째 방법이 사용됩니다. 대안이 서브 패턴 내에있는 경우 (서브 패턴 섹션에 정의 &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt; ) &quot;성공&quot;은 나머지 메인 패턴과 서브 패턴의 대안을 일치시키는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3b219ac3ab7183b58c39d339b6c5af13a6e6e890" translate="yes" xml:space="preserve">
          <source>Any number of test terms can be declared in sequence. &lt;code&gt;Common Test&lt;/code&gt; compiles by default the terms into one or more tests to be performed in one resulting test run. A term that specifies a set of test cases &quot;swallows&quot; one that only specifies a subset of these cases. For example, the result of merging one term specifying that all cases in suite S are to be executed, with another term specifying only test case X and Y in S, is a test of all cases in S. However, if a term specifying test case X and Y in S is merged with a term specifying case Z in S, the result is a test of X, Y, and Z in S. To disable this behavior, that is, to instead perform each test sequentially in a &quot;script-like&quot; manner, set term &lt;code&gt;merge_tests&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the test specification.</source>
          <target state="translated">여러 테스트 용어를 순서대로 선언 할 수 있습니다. &lt;code&gt;Common Test&lt;/code&gt; 는 기본적으로 하나의 결과 테스트 실행에서 수행 될 하나 이상의 테스트로 용어를 컴파일합니다. 일련의 테스트 사례를 지정하는 용어는 이러한 사례의 하위 집합 만 지정하는 &quot;제비&quot;를 지정합니다. 예를 들어, 스위트 S의 모든 케이스가 실행되도록 지정하고 하나의 용어를 테스트 케이스 X와 Y 만 S로 지정하는 것으로 지정된 한 용어를 병합 한 결과는 S의 모든 케이스의 테스트입니다. S의 경우 X와 Y는 S의 경우 Z를 지정하는 용어와 병합되고 결과는 S의 X, Y 및 Z의 테스트입니다.이 동작을 비활성화하려면 즉, &quot;스크립트에서 각 테스트를 순차적으로 수행하십시오. -like &quot;방식으로 테스트 스펙에서 &lt;code&gt;merge_tests&lt;/code&gt; 용어 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7f1d0eacfac7695ff6458e838ae9c63e075002a8" translate="yes" xml:space="preserve">
          <source>Any of &lt;code&gt;Pos&lt;/code&gt;, &lt;code&gt;Incr&lt;/code&gt;, &lt;code&gt;Threshold&lt;/code&gt;, or &lt;code&gt;SetValue&lt;/code&gt; is not an integer.</source>
          <target state="translated">의 모든 &lt;code&gt;Pos&lt;/code&gt; , &lt;code&gt;Incr&lt;/code&gt; , &lt;code&gt;Threshold&lt;/code&gt; , 또는 &lt;code&gt;SetValue&lt;/code&gt; 는이 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a07471bf046332e50c16cdbf9fa2f0e4219c9dce" translate="yes" xml:space="preserve">
          <source>Any of the Boolean options can be set to &lt;code&gt;true&lt;/code&gt; by stating the name of the option. For example, &lt;code&gt;verbose&lt;/code&gt; is equivalent to &lt;code&gt;{verbose, true}&lt;/code&gt;.</source>
          <target state="translated">옵션 이름을 지정 하여 부울 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 예를 들어 &lt;code&gt;verbose&lt;/code&gt; 는 &lt;code&gt;{verbose, true}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0d0154918457ea334a0a14f2ca39bfe72abe9e56" translate="yes" xml:space="preserve">
          <source>Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</source>
          <target state="translated">위의 개행 시퀀스 및 유니 코드 시퀀스 VT (수직 탭, U + 000B), FF (폼 피드, U + 000C), NEL (다음 라인, U + 0085), LS (라인 구분 기호, U + 2028) 및 PS (단락 분리기, U + 2029).</target>
        </trans-unit>
        <trans-unit id="4e36b2886b60e8d8125482994d6c845a19875794" translate="yes" xml:space="preserve">
          <source>Any of the three above</source>
          <target state="translated">위의 세 가지 중 하나</target>
        </trans-unit>
        <trans-unit id="86ba96738491ceb49b98c521a1260c55ed5485fb" translate="yes" xml:space="preserve">
          <source>Any of the three preceding sequences is be recognized.</source>
          <target state="translated">앞의 세 가지 시퀀스 중 하나가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="81ac719a424443fef6b057e36ab2fb49dfe28608" translate="yes" xml:space="preserve">
          <source>Any of the three preceding sequences is to be recognized.</source>
          <target state="translated">앞의 세 가지 순서 중 하나를 인식해야합니다.</target>
        </trans-unit>
        <trans-unit id="58b743365bb43cbc12421219d500fe35e8ea844d" translate="yes" xml:space="preserve">
          <source>Any option can be added to the Erlang compiler when compiling the generated Erlang files. Any option unrecognized by the ASN.1 compiler is passed to the Erlang compiler.</source>
          <target state="translated">생성 된 Erlang 파일을 컴파일 할 때 Erlang 컴파일러에 옵션을 추가 할 수 있습니다. ASN.1 컴파일러가 인식 할 수없는 모든 옵션은 Erlang 컴파일러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d80bad487ffa73c04585c5699f22527d1888dc5c" translate="yes" xml:space="preserve">
          <source>Any other character literally, for example &lt;code&gt;\\&lt;/code&gt; for backslash, &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">다른 문자 그대로, 예를 들어 &lt;code&gt;\\&lt;/code&gt; , 백 슬래시 &lt;code&gt;\&quot;&lt;/code&gt; 에 대한 &lt;code&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2982c9337e5698148dd46ac21f02f3137461b4a8" translate="yes" xml:space="preserve">
          <source>Any other return values (including exit signals or throw) and the &lt;code&gt;DefaultED&lt;/code&gt; will be used.</source>
          <target state="translated">다른 반환 값 (종료 신호 또는 던지기 포함)과 &lt;code&gt;DefaultED&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="249dc2b99b732aa6241eec01386b07432c7788b4" translate="yes" xml:space="preserve">
          <source>Any other return values (including exit signals or throw) will result in an error descriptor with code 500 (internal gateway error) and the module name (of the callback module) as reason.</source>
          <target state="translated">다른 반환 값 (종료 신호 또는 throw 포함)은 코드 500 (내부 게이트웨이 오류) 및 모듈 이름 (콜백 모듈의)을 이유로 오류 설명자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a942dcaa5bd45f30971473c45442d68ed922cbd5" translate="yes" xml:space="preserve">
          <source>Any other value &lt;code&gt;OtherValue&lt;/code&gt; returned by &lt;code&gt;Fun&lt;/code&gt; terminates the traversal and is returned immediately.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 이 반환 한 다른 값 &lt;code&gt;OtherValue&lt;/code&gt; 는 순회를 종료하고 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f4d82480914c3ee14ba49d105622133bf704f763" translate="yes" xml:space="preserve">
          <source>Any other value is immediately returned as value of the current call to &lt;code&gt;sort&lt;/code&gt; or &lt;code&gt;keysort&lt;/code&gt;. Each input function is called exactly once. If an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">다른 값은 &lt;code&gt;sort&lt;/code&gt; 또는 &lt;code&gt;keysort&lt;/code&gt; 에 대한 현재 호출 값으로 즉시 리턴됩니다 . 각 입력 함수는 정확히 한 번 호출됩니다. 오류가 발생하면 마지막 함수가 인수 &lt;code&gt;close&lt;/code&gt; 로 호출되며 응답은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f850a68f9f85d9da673e19d77155ac0b55fea37c" translate="yes" xml:space="preserve">
          <source>Any other variable needed by the test</source>
          <target state="translated">테스트에 필요한 다른 변수</target>
        </trans-unit>
        <trans-unit id="9d0e66f20ad63939bfb7baf4ceddb82fb6504347" translate="yes" xml:space="preserve">
          <source>Any parameters are of the wrong type.</source>
          <target state="translated">모든 매개 변수의 유형이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="933ef808931a1467e93c9ed25ccfb4780e6ed6ed" translate="yes" xml:space="preserve">
          <source>Any process can probe a blocked log with &lt;code&gt;info/1&lt;/code&gt; or close it with &lt;code&gt;close/1&lt;/code&gt;. The blocking process can also use functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, &lt;code&gt;chunk_step/3&lt;/code&gt;, and &lt;code&gt;unblock/1&lt;/code&gt; without being affected by the block. Any other attempt than those mentioned so far to update or read a blocked log suspends the calling process until the log is unblocked or returns error message &lt;code&gt;{blocked_log, Log}&lt;/code&gt;, depending on whether the value of &lt;code&gt;QueueLogRecords&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;QueueLogRecords&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;, which is used by &lt;code&gt;block/1&lt;/code&gt;.</source>
          <target state="translated">모든 프로세스는 차단과 로그를 조사 할 수 있습니다 &lt;code&gt;info/1&lt;/code&gt; 또는 가까운 그것은 &lt;code&gt;close/1&lt;/code&gt; . 차단 프로세스는 또한 블록의 영향을받지 않고 &lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; , &lt;code&gt;chunk_step/3&lt;/code&gt; 및 &lt;code&gt;unblock/1&lt;/code&gt; 함수를 사용할 수 있습니다 . 로그가 차단 해제 또는 반환 오류 메시지가 될 때까지 갱신에 지금까지 언급 한 또는 차단 된 로그를 읽는 것보다 다른 시도가 호출 프로세스를 일시 중단 &lt;code&gt;{blocked_log, Log}&lt;/code&gt; 의 값인지에 따라 &lt;code&gt;QueueLogRecords&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;QueueLogRecords&lt;/code&gt; 의 기본값은 &lt;code&gt;true&lt;/code&gt; 이며 &lt;code&gt;block/1&lt;/code&gt; 에서 사용됩니다..</target>
        </trans-unit>
        <trans-unit id="08eca955417b5ab22bebcc976cc21d89efe94422" translate="yes" xml:space="preserve">
          <source>Any process can read or write to the table.</source>
          <target state="translated">모든 프로세스는 테이블을 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="782da514823c3f76e59a01f8bc9028c411c82cda" translate="yes" xml:space="preserve">
          <source>Any process, in any application, with &lt;code&gt;Module&lt;/code&gt; as residence module, is killed when the instruction is evaluated. The user must therefore ensure that all such processes are terminated before deleting the module, to avoid a situation with failing supervisor restarts.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 을 거주 모듈로 사용 하는 응용 프로그램의 모든 프로세스 는 명령이 평가 될 때 종료됩니다. 따라서 사용자는 감독자 재시작 실패 상황을 피하기 위해 모듈을 삭제하기 전에 이러한 모든 프로세스가 종료되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="89c73d072c780c8bd405077821b4399412adb61c" translate="yes" xml:space="preserve">
          <source>Any record, containing type information or not, once defined, can be used as a type using the following syntax:</source>
          <target state="translated">유형 정보를 포함하거나 한 번 정의되지 않은 모든 레코드는 다음 구문을 사용하여 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9ac647f7a1c06663cb2845807c8bed2b8a0381" translate="yes" xml:space="preserve">
          <source>Any relative paths, specified in the test specification, are relative to the directory containing the test specification file if &lt;code&gt;ct_run -spec TestSpecFile ...&lt;/code&gt; or &lt;code&gt;ct:run:test([{spec,TestSpecFile},...])&lt;/code&gt; executes the test.</source>
          <target state="translated">테스트 스펙에 지정된 상대 경로는 &lt;code&gt;ct_run -spec TestSpecFile ...&lt;/code&gt; 또는 &lt;code&gt;ct:run:test([{spec,TestSpecFile},...])&lt;/code&gt; 이 테스트를 실행하는 경우 테스트 스펙 파일을 포함하는 디렉토리를 기준으로합니다 . .</target>
        </trans-unit>
        <trans-unit id="b95b8d2f2c5d4e842e94679e4847a285aed6e939" translate="yes" xml:space="preserve">
          <source>Any required padding is added by diameter when encoding outgoing messages.</source>
          <target state="translated">발신 메시지를 인코딩 할 때 필요한 패딩이 직경별로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9a8124f1b80519c1f040df8df911b83b4c84b7" translate="yes" xml:space="preserve">
          <source>Any start flags to the Erlang runtime system (application ERTS) can also be passed as parameters to &lt;code&gt;ct_run&lt;/code&gt;. It is, for example, useful to be able to pass directories to be added to the Erlang code server search path with flag &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt;. If you have common help- or library modules for test suites (separately compiled), stored in other directories than the test suite directories, these &lt;code&gt;help/lib&lt;/code&gt; directories are preferably added to the code path this way.</source>
          <target state="translated">Erlang 런타임 시스템 (애플리케이션 ERTS)에 대한 모든 시작 플래그는 &lt;code&gt;ct_run&lt;/code&gt; 에 매개 변수로 전달 될 수도 있습니다 . 예를 들어, &lt;code&gt;-pa&lt;/code&gt; 또는 &lt;code&gt;-pz&lt;/code&gt; 플래그를 사용하여 Erlang 코드 서버 검색 경로에 추가 할 디렉토리를 전달할 수 있으면 유용합니다 . 테스트 스위트 디렉토리 이외의 다른 디렉토리에 저장된 테스트 스위트 (별도 컴파일)에 대한 공통 도움말 또는 라이브러리 모듈이있는 경우 이러한 &lt;code&gt;help/lib&lt;/code&gt; 디렉토리는이 방법으로 코드 경로에 추가되는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f182f567f67c83a2ce8839de78f5dd9c2331c337" translate="yes" xml:space="preserve">
          <source>Any term, defaults to the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">모든 용어는 기본적으로 원자 &lt;code&gt;undefined&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="05f2f648b8aa07f43583597f53b95459b0d86b71" translate="yes" xml:space="preserve">
          <source>Any test or test set &lt;code&gt;T&lt;/code&gt; can be annotated with a title, by wrapping it in a pair &lt;code&gt;{Title, T}&lt;/code&gt;, where &lt;code&gt;Title&lt;/code&gt; is a string. For convenience, any test which is normally represented using a tuple can simply be given a title string as the first element, i.e., writing &lt;code&gt;{&quot;The Title&quot;, ...}&lt;/code&gt; instead of adding an extra tuple wrapper as in &lt;code&gt;{&quot;The Title&quot;, {...}}&lt;/code&gt;.</source>
          <target state="translated">상관 테스트 또는 테스트 세트 &lt;code&gt;T&lt;/code&gt; 는 한 쌍으로 배치함으로써, 표제로 주석 될 수있다 &lt;code&gt;{Title, T}&lt;/code&gt; , &lt;code&gt;Title&lt;/code&gt; 문자열이다. 편의를 위해, 일반적으로 튜플을 사용하여 표현되는 모든 테스트는 단순히 첫 번째 요소, 즉, 쓰기 등의 제목 문자열을 제공 할 수있다 &lt;code&gt;{&quot;The Title&quot;, ...}&lt;/code&gt; 대신에 같이 별도의 튜플 래퍼를 추가 &lt;code&gt;{&quot;The Title&quot;, {...}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdfd965642f53e0b7729140f8c9073111a331ea3" translate="yes" xml:space="preserve">
          <source>Any transport option except &lt;code&gt;applications&lt;/code&gt; or &lt;code&gt;capabilities&lt;/code&gt;. Used as defaults for transport configuration, values passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; overriding values configured on the service.</source>
          <target state="translated">&lt;code&gt;applications&lt;/code&gt; 또는 &lt;code&gt;capabilities&lt;/code&gt; 제외한 모든 전송 옵션 . 전송 구성의 기본값으로 사용되는 값은 서비스에 구성된 값을 재정의 하는 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="36287aab00e4133075843c606c024c1da69b5da0" translate="yes" xml:space="preserve">
          <source>Any undocumented functions in &lt;code&gt;string&lt;/code&gt; are not to be used.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 로 문서화되지 않은 함수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4472d33a875806b4fa8c5622d64ebe7f23ffe886" translate="yes" xml:space="preserve">
          <source>Any unspecified fields are assumed to have the type in the original record declaration.</source>
          <target state="translated">지정되지 않은 필드는 원래 레코드 선언에 유형이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8b06f554103b0e00f9de05aa58d618718ce1b34" translate="yes" xml:space="preserve">
          <source>Any variables that are defined before the list comprehension, and that are used in filters, have the values they had before the list comprehension.</source>
          <target state="translated">목록 이해 이전에 정의되고 필터에 사용되는 모든 변수는 목록 이해 이전의 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f184dfb123fe5531382db694e54de8fc62711d8d" translate="yes" xml:space="preserve">
          <source>Any vertical whitespace character</source>
          <target state="translated">수직 공백 문자</target>
        </trans-unit>
        <trans-unit id="dc95992a9a8880a458bf0ac420ad7827afd47252" translate="yes" xml:space="preserve">
          <source>Any whitespace character</source>
          <target state="translated">공백 문자</target>
        </trans-unit>
        <trans-unit id="7d41ee854a3d2e6ed49f2b637df36ad7f9e23190" translate="yes" xml:space="preserve">
          <source>Apart from the ordinary allocators described above, some pre-allocators are used for some specific data types. These pre-allocators pre-allocate a fixed amount of memory for certain data types when the runtime system starts. As long as pre-allocated memory is available, it is used. When no pre-allocated memory is available, memory is allocated in ordinary allocators. These pre-allocators are typically much faster than the ordinary allocators, but can only satisfy a limited number of requests.</source>
          <target state="translated">위에서 설명한 일반적인 할당 자 외에도 일부 사전 할당자는 일부 특정 데이터 유형에 사용됩니다. 이러한 사전 할당자는 런타임 시스템이 시작될 때 특정 데이터 유형에 대해 고정 된 양의 메모리를 사전 할당합니다. 사전 할당 된 메모리가 사용 가능한 한 사용됩니다. 사전 할당 된 메모리가 없으면 메모리는 일반 할당 자에 할당됩니다. 이러한 사전 할당자는 일반적으로 일반 할당 자보다 훨씬 빠르지 만 제한된 수의 요청 만 만족시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6fbecd567654b9cb7f086f33e2e4b65e3a20dbc" translate="yes" xml:space="preserve">
          <source>Appart from the reply message, the &lt;code&gt;{asynchronous, ReplyTag}&lt;/code&gt; option behaves exactly the same as the &lt;code&gt;asynchronous&lt;/code&gt; option without reply tag.</source>
          <target state="translated">응답 메시지의 &lt;code&gt;{asynchronous, ReplyTag}&lt;/code&gt; 옵션은 응답 태그가없는 &lt;code&gt;asynchronous&lt;/code&gt; 옵션 과 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e791b60ddfbf72d731c8a8fbb0e6ea943e25bd" translate="yes" xml:space="preserve">
          <source>Appears when option &lt;code&gt;reload&lt;/code&gt; is specified. The driver &lt;code&gt;Name&lt;/code&gt; is not in the system. Only drivers loaded by this process can be reloaded.</source>
          <target state="translated">옵션 &lt;code&gt;reload&lt;/code&gt; 가 지정 될 때 나타납니다 . 드라이버 &lt;code&gt;Name&lt;/code&gt; 이 시스템에 없습니다. 이 프로세스에서로드 한 드라이버 만 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49cc99a35d08f4016ff481d7d8153734e5631682" translate="yes" xml:space="preserve">
          <source>Appears when option &lt;code&gt;reload&lt;/code&gt; is specified. The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">옵션 &lt;code&gt;reload&lt;/code&gt; 가 지정 될 때 나타납니다 . 드라이버 &lt;code&gt;Name&lt;/code&gt; 이 시스템에 있지만 이 프로세스 에는 해당 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca9605c2bfb20ec231ac66a12bdad85113549dc" translate="yes" xml:space="preserve">
          <source>Append or prepend supported but not enabled algorithm(s) to the list of algorithms. If the wanted algorithms already are in &lt;code&gt;A&lt;/code&gt; they will first be removed and then appended or prepended,</source>
          <target state="translated">지원되지만 활성화되지 않은 알고리즘을 알고리즘 목록에 추가하거나 추가합니다. 원하는 알고리즘이 이미 &lt;code&gt;A&lt;/code&gt; 에 있으면 먼저 제거 된 다음 추가하거나 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0eee5e3eef37b4e12873f20fbe9bf8c113511624" translate="yes" xml:space="preserve">
          <source>Append the agents config to the current manager agents config file.</source>
          <target state="translated">에이전트 구성을 현재 관리자 에이전트 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="670ede32b75903ea1e527f007ab3467a091effc0" translate="yes" xml:space="preserve">
          <source>Append the community config to the current agent community config file.</source>
          <target state="translated">커뮤니티 구성을 현재 에이전트 커뮤니티 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7f98e246919d3685a6470b54ee550be705b1a20d" translate="yes" xml:space="preserve">
          <source>Append the config to the current agent config file.</source>
          <target state="translated">현재 에이전트 구성 파일에 구성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5b99d7bbf0744498145642e57ca0d9bbc5019b3e" translate="yes" xml:space="preserve">
          <source>Append the config to the current manager config file.</source>
          <target state="translated">현재 관리자 구성 파일에 구성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4715714a265ef18003ce3a95c049a6579c5fdc19" translate="yes" xml:space="preserve">
          <source>Append the context config to the current agent context config file.</source>
          <target state="translated">컨텍스트 구성을 현재 에이전트 컨텍스트 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="098b355d60044dcd195c72fb3d8921d6f5c79432" translate="yes" xml:space="preserve">
          <source>Append the notify config to the current agent notify config file.</source>
          <target state="translated">알림 구성을 현재 에이전트 알림 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eacde046205397e77177cf51c65a5911a57b8615" translate="yes" xml:space="preserve">
          <source>Append the standard config to the current agent standard config file.</source>
          <target state="translated">표준 구성을 현재 에이전트 표준 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="10e85fc06cc23b8efed1d3e1c3fb54a94ebffb97" translate="yes" xml:space="preserve">
          <source>Append the target_addr config to the current agent target_addr config file.</source>
          <target state="translated">target_addr 구성을 현재 에이전트 target_addr 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="87b72ce0520ffbff2c18e79fe54c87ebbca4b2fe" translate="yes" xml:space="preserve">
          <source>Append the target_params config to the current agent target_params config file.</source>
          <target state="translated">target_params 구성을 현재 에이전트 target_params 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="95a8435503ae194bc5982a16880db13756b12c3e" translate="yes" xml:space="preserve">
          <source>Append the users config to the current manager users config file.</source>
          <target state="translated">사용자 구성을 현재 관리자 사용자 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="20d781b651b76cd62733934321351ec945be0a2a" translate="yes" xml:space="preserve">
          <source>Append the usm config to the current agent vacm config file.</source>
          <target state="translated">usm 구성을 현재 에이전트 vacm 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="57c21804df817ec8d20c17ff38774329e716571b" translate="yes" xml:space="preserve">
          <source>Append the usm config to the current manager usm config file.</source>
          <target state="translated">usm 구성을 현재 관리자 usm 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5ed7647b353b68ed84afe6fde045a7489b9154cc" translate="yes" xml:space="preserve">
          <source>Append the vacm config to the current agent vacm config file.</source>
          <target state="translated">vacm 구성을 현재 에이전트 vacm 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="85d8a97e8351cb485e2588c8ecfff62c9d854b68" translate="yes" xml:space="preserve">
          <source>Appending to a binary in an efficient way can be done as follows:</source>
          <target state="translated">이진 파일을 효율적으로 추가하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea77b245b41191501f470789eca4aba72934b9e1" translate="yes" xml:space="preserve">
          <source>Appending to a binary or bitstring is specially optimized by the &lt;strong&gt;runtime system&lt;/strong&gt;:</source>
          <target state="translated">바이너리 또는 비트 열에 추가하는 것은 &lt;strong&gt;런타임 시스템에&lt;/strong&gt; 의해 특별히 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6eda043cc568cf13970a30ffbc0034adfa99e03f" translate="yes" xml:space="preserve">
          <source>Appendix A describes the conversion of SNMPv2 to SNMPv1 error messages.</source>
          <target state="translated">부록 A에서는 SNMPv2를 SNMPv1 오류 메시지로 변환하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ee91e579fc45ec4f74f6a038125846de007b671e" translate="yes" xml:space="preserve">
          <source>Appendix B contains the RFC1903 text on &lt;code&gt;RowStatus&lt;/code&gt;.</source>
          <target state="translated">부록 B에는 &lt;code&gt;RowStatus&lt;/code&gt; 에 대한 RFC1903 텍스트가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df0c86c3bdb24e665fb2b6f20747db8d823ab88c" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Comments&lt;/code&gt; to the post-comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 주석에 &lt;code&gt;Comments&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f2d60430814dd0a0d3f29b110da1184762bf96c4" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Comments&lt;/code&gt; to the pre-comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 사전 &lt;code&gt;Comments&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a59eafb92455934508f727a752eaa14a058cbb57" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Directory&lt;/code&gt; to the code path in the invoked Erlang emulator.</source>
          <target state="translated">호출 된 Erlang 에뮬레이터의 코드 경로에 &lt;code&gt;Directory&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="f1ae1ca945105d0b0412c9d33c6ca6cdfd36c3ed" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Directory&lt;/code&gt; to the front of the code path in the invoked Erlang emulator. This can be used to invoke another compiler than the default one.</source>
          <target state="translated">호출 된 Erlang 에뮬레이터에서 코드 경로 앞에 &lt;code&gt;Directory&lt;/code&gt; 를 추가 합니다. 기본 컴파일러가 아닌 다른 컴파일러를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb49cdd164f55f2c7a30cfc667b98571effb1dc9" translate="yes" xml:space="preserve">
          <source>Appends a list of values &lt;code&gt;ValList&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;. An exception is generated if the initial value associated with &lt;code&gt;Key&lt;/code&gt; is not a list of values.</source>
          <target state="translated">값 목록 &lt;code&gt;ValList&lt;/code&gt; 를 &lt;code&gt;Key&lt;/code&gt; 와 연관된 현재 값 목록에 추가합니다 . &lt;code&gt;Key&lt;/code&gt; 와 연관된 초기 값 이 값 목록이 아닌 경우 예외가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="598f89859880c8e0c4b7b657bbbf567d531c94b2" translate="yes" xml:space="preserve">
          <source>Appends a new &lt;code&gt;Value&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 현재 값 목록에 새 &lt;code&gt;Value&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="84026150b614acc7231607e9aad74b0ddcd360b0" translate="yes" xml:space="preserve">
          <source>Appends a new &lt;code&gt;Value&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;. An exception is generated if the initial value associated with &lt;code&gt;Key&lt;/code&gt; is not a list of values.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 연관된 현재 값 목록에 새 &lt;code&gt;Value&lt;/code&gt; 을 추가합니다 . &lt;code&gt;Key&lt;/code&gt; 와 연관된 초기 값 이 값 목록이 아닌 경우 예외가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc8c687a22dd5ccfe5def8e49d349b9718a5a0ba" translate="yes" xml:space="preserve">
          <source>Appends data at the end of buffer &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">버퍼 &lt;code&gt;x&lt;/code&gt; 끝에 데이터를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="394be8930f77fa3eaca7c0be83cce9cd9e021402" translate="yes" xml:space="preserve">
          <source>Appends items to a single file, which size can be limited by the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;disk_log&lt;/code&gt; 모듈로 크기를 제한 할 수있는 단일 파일에 항목을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc7f1a4511966dfd1a8a1b210a23216447ca621" translate="yes" xml:space="preserve">
          <source>Appends the comments of &lt;code&gt;Source&lt;/code&gt; to the current comments of &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 의 주석을 &lt;code&gt;Target&lt;/code&gt; 의 현재 주석에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ea301cbca7c8ac46cf5931d51f42837ef8522c8f" translate="yes" xml:space="preserve">
          <source>Appends the term &lt;code&gt;Annotation&lt;/code&gt; to the list of user annotations of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 라는 사용자 주석 목록에 &lt;code&gt;Annotation&lt;/code&gt; 이라는 용어를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="42124fae91a7c7b871162f34d0590a73350f98e4" translate="yes" xml:space="preserve">
          <source>Application - skeletons for the OTP application behavior</source>
          <target state="translated">응용 프로그램-OTP 응용 프로그램 동작의 골격</target>
        </trans-unit>
        <trans-unit id="b92e83d37579fa02e707537bdedda6f2347cdd94" translate="yes" xml:space="preserve">
          <source>Application ::= Atom</source>
          <target state="translated">응용 프로그램 :: = 원자</target>
        </trans-unit>
        <trans-unit id="3101ceef607cbc0ae4473ea0836a862c09e72c75" translate="yes" xml:space="preserve">
          <source>Application Edges. All application calls.</source>
          <target state="translated">응용 프로그램 에지. 모든 응용 프로그램 호출</target>
        </trans-unit>
        <trans-unit id="3925a6e948fb7872d335532f8d20c939d631d4b3" translate="yes" xml:space="preserve">
          <source>Application Identifiers</source>
          <target state="translated">어플리케이션 식별자</target>
        </trans-unit>
        <trans-unit id="d291c82890b136b5e80c48e67c846c73663b4e1e" translate="yes" xml:space="preserve">
          <source>Application dependencies</source>
          <target state="translated">응용 프로그램 종속성</target>
        </trans-unit>
        <trans-unit id="cf171227ff1428401819ab3800da2acc36ae658c" translate="yes" xml:space="preserve">
          <source>Application name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7c4bdcb550a019467191f10d8c79d46c9076de" translate="yes" xml:space="preserve">
          <source>Application parameter &lt;code&gt;schema_location&lt;/code&gt; controls where &lt;code&gt;Mnesia&lt;/code&gt; searches for its schema. The parameter can be one of the following atoms:</source>
          <target state="translated">응용 프로그램 매개 변수 &lt;code&gt;schema_location&lt;/code&gt; 은 &lt;code&gt;Mnesia&lt;/code&gt; 가 스키마를 검색하는 위치를 제어합니다 . 매개 변수는 다음 원자 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c8d3536642343f82c03359ee86f1e6c6ed51cdc" translate="yes" xml:space="preserve">
          <source>Application programs can access the values of the command-line arguments by calling the function &lt;code&gt;init:get_argument(Key)&lt;/code&gt; or &lt;code&gt;init:get_arguments()&lt;/code&gt;. See the &lt;code&gt;init(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;init:get_argument(Key)&lt;/code&gt; 또는 &lt;code&gt;init:get_arguments()&lt;/code&gt; 함수를 호출하여 명령 행 인수의 값에 액세스 할 수 있습니다 . ERTS 의 &lt;code&gt;init(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a3c99c39895beeb540f03e2907eaa65e2e3d13b" translate="yes" xml:space="preserve">
          <source>Application resource file</source>
          <target state="translated">응용 프로그램 리소스 파일</target>
        </trans-unit>
        <trans-unit id="75ccf582ca3ec68d22db59ba1f474b3c7e769bc8" translate="yes" xml:space="preserve">
          <source>Application resource file.</source>
          <target state="translated">응용 프로그램 리소스 파일</target>
        </trans-unit>
        <trans-unit id="d7df03c04ece2fd1b98a72e8d327f0eca8e79615" translate="yes" xml:space="preserve">
          <source>Application settings</source>
          <target state="translated">어플리케이션 설정</target>
        </trans-unit>
        <trans-unit id="e32c3cf432797b7c1d1e8a63e8761c1703d72948" translate="yes" xml:space="preserve">
          <source>Application specific configuration. An application has a mandatory name and application level options that are described below.</source>
          <target state="translated">응용 프로그램 별 구성. 응용 프로그램에는 아래 설명 된 필수 이름 및 응용 프로그램 수준 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae55983f0b6d7e237d6c21df4a6fc064eb76c1b8" translate="yes" xml:space="preserve">
          <source>Application upgrade file</source>
          <target state="translated">응용 프로그램 업그레이드 파일</target>
        </trans-unit>
        <trans-unit id="781ef14400b810abfadd4a95a97b21db97359040" translate="yes" xml:space="preserve">
          <source>Application-specific error reason that is to be checked by the &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_fun&lt;/code&gt; 로 확인 해야하는 응용 프로그램 특정 오류 이유 .</target>
        </trans-unit>
        <trans-unit id="4507ffa27565890275789b83392e39507e0ef155" translate="yes" xml:space="preserve">
          <source>Application-specific records are defined in the hrl files resulting from dictionary file compilation.</source>
          <target state="translated">응용 프로그램 특정 레코드는 사전 파일 컴파일의 결과 인 hrl 파일에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="5dd7e803139ba20c70acea8fa0e0d5743ed7b495" translate="yes" xml:space="preserve">
          <source>Applications are not required to be located under directory &lt;code&gt;$ROOT/lib&lt;/code&gt;. Several installation directories, which contain different parts of a system, can thus exist. For example, the previous example can be extended as follows:</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;$ROOT/lib&lt;/code&gt; 디렉토리에있을 필요는 없습니다 . 따라서 시스템의 다른 부분을 포함하는 여러 설치 디렉토리가 존재할 수 있습니다. 예를 들어, 이전 예는 다음과 같이 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="362b31da52f21329511e4763851061ec08ac4166" translate="yes" xml:space="preserve">
          <source>Applications that access databases or log files often write a tiny data fragment (for example, one line in a log file) and then call &lt;code&gt;fsync()&lt;/code&gt; immediately to ensure that the written data is physically stored on the hard disk. Unfortunately, &lt;code&gt;fsync()&lt;/code&gt; always initiates two write operations: one for the newly written data and another one to update the modification time stored in the &lt;code&gt;inode&lt;/code&gt;. If the modification time is not a part of the transaction concept, &lt;code&gt;fdatasync()&lt;/code&gt; can be used to avoid unnecessary &lt;code&gt;inode&lt;/code&gt; disk write operations.</source>
          <target state="translated">데이터베이스 또는 로그 파일에 액세스하는 응용 프로그램은 종종 작은 데이터 조각 (예 : 로그 파일의 한 줄 &lt;code&gt;fsync()&lt;/code&gt; 을 쓴 다음 fsync ()를 즉시 호출 하여 기록 된 데이터가 실제로 하드 디스크에 저장되도록합니다. 불행하게도, &lt;code&gt;fsync()&lt;/code&gt; 항상 2 개의 쓰기 작업을 시작합니다. 하나는 새로 쓴 데이터를위한 것이고 다른 하나는 &lt;code&gt;inode&lt;/code&gt; 에 저장된 수정 시간을 업데이트하는 것 입니다. 수정 시간이 트랜잭션 개념의 일부가 아닌 경우, &lt;code&gt;fdatasync()&lt;/code&gt; 를 사용하여 불필요한 &lt;code&gt;inode&lt;/code&gt; 디스크 쓰기 작업 을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36e5e3b3c875b142ebb079646179db76a16ac509" translate="yes" xml:space="preserve">
          <source>Applications that merely need a look-up dictionary that can be stored to disc. Those applications use the standard library module &lt;code&gt;dets&lt;/code&gt;, which is a disc-based version of the module &lt;code&gt;ets&lt;/code&gt;. For information about &lt;code&gt;dets&lt;/code&gt;, see the &lt;code&gt;dets&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">디스크에 저장할 수있는 조회 사전 만 필요한 응용 프로그램. 이러한 응용 프로그램은 표준 라이브러리 모듈 &lt;code&gt;dets&lt;/code&gt; 사용합니다.이 모듈 은 디스크 기반 버전의 모듈 &lt;code&gt;ets&lt;/code&gt; 입니다. &lt;code&gt;dets&lt;/code&gt; 에 대한 정보는 STDLIB 의 &lt;code&gt;dets&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08caa89c85c4c4b67db04b49770e72f7b261a582" translate="yes" xml:space="preserve">
          <source>Applications that need disc logging facilities. Those applications can use the module &lt;code&gt;disk_log&lt;/code&gt; by preference. For information about &lt;code&gt;disk_log&lt;/code&gt;, see the &lt;code&gt;disk_log&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">디스크 로깅 기능이 필요한 응용 프로그램. 해당 응용 프로그램은 환경 설정에 따라 &lt;code&gt;disk_log&lt;/code&gt; 모듈을 사용할 수 있습니다 . &lt;code&gt;disk_log&lt;/code&gt; 에 대한 자세한 내용은 커널 의 &lt;code&gt;disk_log&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d65e8afb7e2d8dc2f453fde746bc143e776e7bfd" translate="yes" xml:space="preserve">
          <source>Applications that need to replicate data.</source>
          <target state="translated">데이터를 복제해야하는 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="0a893d683aa9bd2d820b6ec80f57f8073df0221a" translate="yes" xml:space="preserve">
          <source>Applications that need to use atomic transactions to update several records simultaneously.</source>
          <target state="translated">여러 트랜잭션을 동시에 업데이트하기 위해 원자 트랜잭션을 사용해야하는 애플리케이션</target>
        </trans-unit>
        <trans-unit id="b472e8ea80b9c154d3b89eb9393528fe5e667863" translate="yes" xml:space="preserve">
          <source>Applications that perform complicated searches on data.</source>
          <target state="translated">데이터에서 복잡한 검색을 수행하는 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="218beaf6e33b2c2bfe36be6da2b6bedcdac994cd" translate="yes" xml:space="preserve">
          <source>Applications that use soft real-time characteristics.</source>
          <target state="translated">부드러운 실시간 특성을 사용하는 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="e2d9778da73c053006242c383a365963dcdf2431" translate="yes" xml:space="preserve">
          <source>Applications.</source>
          <target state="translated">Applications.</target>
        </trans-unit>
        <trans-unit id="fa321d507b3a35d5a25a7182b72ba551d90893aa" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;Fun&lt;/code&gt; to each object stored in table &lt;code&gt;Name&lt;/code&gt; in some unspecified order. Different actions are taken depending on the return value of &lt;code&gt;Fun&lt;/code&gt;. The following &lt;code&gt;Fun&lt;/code&gt; return values are allowed:</source>
          <target state="translated">지정되지 않은 순서로 &lt;code&gt;Name&lt;/code&gt; 테이블에 저장된 각 개체에 &lt;code&gt;Fun&lt;/code&gt; 을 적용 합니다 . &lt;code&gt;Fun&lt;/code&gt; 의 반환 값에 따라 다른 조치가 수행됩니다 . 다음과 같은 &lt;code&gt;Fun&lt;/code&gt; 반환 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c175a40ddabcc4446ea6e7c02e64574ef36699b4" translate="yes" xml:space="preserve">
          <source>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node.</source>
          <target state="translated">구문 트리의 각 직계 하위 트리에 함수를 적용합니다. 각 애플리케이션의 결과는 해당하는 원래 노드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a163f49988d544f596168407c81d1f2429198f1c" translate="yes" xml:space="preserve">
          <source>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up.</source>
          <target state="translated">구문 트리의 각 노드에 함수를 적용합니다. 각 애플리케이션의 결과는 해당하는 원래 노드를 대체합니다. 순회 순서는 상향식입니다.</target>
        </trans-unit>
        <trans-unit id="2f3b02962a0c819c60e2a8cb9eea77ed6172b4d6" translate="yes" xml:space="preserve">
          <source>Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by &lt;code&gt;Continuation&lt;/code&gt;, which is returned by a previous call to &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일치 스펙을 테이블에 저장된 일부 오브젝트에 적용하고 비어 있지 않은 결과 목록을 리턴합니다. 일치하는 테이블, 일치 스펙 및 오브젝트 수는 모두 &lt;code&gt;Continuation&lt;/code&gt; 에 의해 정의되며 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c464d5076dfa5b81db106edd89f699c8ab10fb5" translate="yes" xml:space="preserve">
          <source>Applies argument &lt;code&gt;Fun&lt;/code&gt; to all records in the table. &lt;code&gt;Fun&lt;/code&gt; is a function that takes a record of the old type and returns a transformed record of the new type. Argument &lt;code&gt;Fun&lt;/code&gt; can also be the atom &lt;code&gt;ignore&lt;/code&gt;, which indicates that only the metadata about the table is updated. Use of &lt;code&gt;ignore&lt;/code&gt; is not recommended, but included as a possibility for the user do to an own transformation.</source>
          <target state="translated">인수 &lt;code&gt;Fun&lt;/code&gt; 을 테이블의 모든 레코드에 적용 합니다. &lt;code&gt;Fun&lt;/code&gt; 은 이전 유형의 레코드를 가져 와서 새로운 유형의 변환 된 레코드를 리턴하는 함수입니다. Argument &lt;code&gt;Fun&lt;/code&gt; 은 atom &lt;code&gt;ignore&lt;/code&gt; 일 수 있습니다 . 이는 테이블에 대한 메타 데이터 만 업데이트됨을 나타냅니다. &lt;code&gt;ignore&lt;/code&gt; 를 사용 하지 않는 것이 좋지만 사용자가 자체 변환을 수행 할 수있는 가능성이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3f39b03019ec061c371b31fff84840bf62260f" translate="yes" xml:space="preserve">
          <source>Applies file extension specific rules to find the source file for a given object file relative to the object directory. For example, for a file with the extension &lt;code&gt;.beam&lt;/code&gt;, the default rule is to look for a file with a corresponding extension &lt;code&gt;.erl&lt;/code&gt; by replacing the suffix &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; of the object directory path with &lt;code&gt;&quot;src&quot;&lt;/code&gt; or &lt;code&gt;&quot;src/*&quot;&lt;/code&gt;. The file search is done through &lt;code&gt;&lt;a href=&quot;#find_file-3&quot;&gt;find_file/3&lt;/a&gt;&lt;/code&gt;. The directory of the object file is always tried before any other directory specified by the rules.</source>
          <target state="translated">파일 확장자 특정 규칙을 적용하여 오브젝트 디렉토리를 기준으로 지정된 오브젝트 파일의 소스 파일을 찾습니다. 예를 들어, 확장자가 &lt;code&gt;.beam&lt;/code&gt; 인 파일의 경우 기본 규칙은 오브젝트 디렉토리 경로 의 접미 부 &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; 을 &lt;code&gt;&quot;src&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;src/*&quot;&lt;/code&gt; 로 바꾸어 해당 확장자가 &lt;code&gt;.erl&lt;/code&gt; 인 파일을 찾는 것입니다 . 파일 검색은 &lt;code&gt;&lt;a href=&quot;#find_file-3&quot;&gt;find_file/3&lt;/a&gt;&lt;/code&gt; 을 통해 수행됩니다 . 오브젝트 파일의 디렉토리는 항상 규칙에 의해 지정된 다른 디렉토리보다 먼저 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f326da15ffb7ae813d23c15eec50f7c444699f" translate="yes" xml:space="preserve">
          <source>Applying an &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;&lt;code&gt;E&lt;/code&gt; to an argument list &lt;code&gt;A&lt;/code&gt; is meant in the sense of &lt;code&gt;eval([E|A])&lt;/code&gt;.</source>
          <target state="translated">인수 목록 &lt;code&gt;A&lt;/code&gt; 에 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; &lt;code&gt;E&lt;/code&gt; 를 적용하는 것은 &lt;code&gt;eval([E|A])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b14b38298fd4bda910b4630394ad60fbf3511557" translate="yes" xml:space="preserve">
          <source>Applying an exported function (&lt;code&gt;Mod:Name()&lt;/code&gt;, &lt;code&gt;apply(Mod, Name, [])&lt;/code&gt;) is about twice as expensive as calling a fun or about &lt;strong&gt;six times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">내 보낸 함수 ( &lt;code&gt;Mod:Name()&lt;/code&gt; , &lt;code&gt;apply(Mod, Name, [])&lt;/code&gt; )를 적용 하면 fun 호출보다 약 2 &lt;strong&gt;배&lt;/strong&gt; , 로컬 함수 호출 &lt;strong&gt;보다 6 배나&lt;/strong&gt; 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="953254328751bb2f8e674cc873b7ff2bdf1e5334" translate="yes" xml:space="preserve">
          <source>Approach to Extensibility</source>
          <target state="translated">확장성에 대한 접근</target>
        </trans-unit>
        <trans-unit id="0d9fa01dbd526bfbb910c0a4cf194e3ddc6ecb6f" translate="yes" xml:space="preserve">
          <source>Approximate consumed fraction of a full time-slice in percent.</source>
          <target state="translated">전체 시간 조각의 대략적인 소비 비율 (%)입니다.</target>
        </trans-unit>
        <trans-unit id="3c77ccb79f8b6f72613400296314a0c96ee58298" translate="yes" xml:space="preserve">
          <source>Approximation of '$1' | '$2' | '$3' | ...</source>
          <target state="translated">'$ 1'근사치 | '$ 2'| '$ 3'| ...</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="9a1bdf411ab1c83198eecd5f0731a5c27bbb4381" translate="yes" xml:space="preserve">
          <source>Arabic Letter Mark</source>
          <target state="translated">아랍어 문자 마크</target>
        </trans-unit>
        <trans-unit id="594b76f0b7b11a63e0ba97c983e39193011c18c1" translate="yes" xml:space="preserve">
          <source>Arbitrary derived data formats are supported by the dictionary interface.</source>
          <target state="translated">임의의 파생 데이터 형식은 사전 인터페이스에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a286f7c446f5fbd534896a188edddbc7d7a34e76" translate="yes" xml:space="preserve">
          <source>Arbitrary term state</source>
          <target state="translated">임의의 용어 상태</target>
        </trans-unit>
        <trans-unit id="b4ea29fb4d4c1648e6d2e3c64705a89e987e421d" translate="yes" xml:space="preserve">
          <source>Are there other ways to do this that are equivalent and more efficient?</source>
          <target state="translated">동등하고 더 효율적인 다른 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c7427a7532716d8ddc0f775b7a270adc70ce506b" translate="yes" xml:space="preserve">
          <source>Args :: term(),</source>
          <target state="translated">Args :: term (),</target>
        </trans-unit>
        <trans-unit id="0fde5a51f492378b1ac1c7a090a3a9a9c4d7e9b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Args&lt;/code&gt; is a list of &lt;code&gt;{Key, Val}&lt;/code&gt; tuples, where the following values are allowed:</source>
          <target state="translated">인수 &lt;code&gt;Args&lt;/code&gt; 는 다음 값이 허용되는 &lt;code&gt;{Key, Val}&lt;/code&gt; 튜플 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="2a8f4ad3dae9bd362edcdfe9517b3ed392fd27ef" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Args&lt;/code&gt; is used to set &lt;code&gt;erl&lt;/code&gt; command-line arguments. If provided, it is passed to the new node and can be used for a variety of purposes; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Args&lt;/code&gt; 는 &lt;code&gt;erl&lt;/code&gt; 명령 행 인수 를 설정하는 데 사용됩니다 . 제공되는 경우 새 노드로 전달되며 다양한 목적으로 사용될 수 있습니다. &lt;code&gt;erl(1)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="528cc3f851bb138092b3a54cd9007848b26b85a1" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Beam&lt;/code&gt;, which can be a string or an atom, specifies either the module name or the path to the source code, with or without extension &lt;code&gt;&quot;.erl&quot;&lt;/code&gt;. In either case, the module must be known by the code server, that is, &lt;code&gt;code:which(Module)&lt;/code&gt; must succeed.</source>
          <target state="translated">문자열 또는 원자가 될 수있는 Argument &lt;code&gt;Beam&lt;/code&gt; 은 확장명 &lt;code&gt;&quot;.erl&quot;&lt;/code&gt; 이 있거나없는 모듈 이름 또는 소스 코드의 경로를 지정합니다 . 두 경우 모두 코드 서버에서 모듈을 알고 있어야합니다. 즉, &lt;code&gt;code:which(Module)&lt;/code&gt; 이 성공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0c91ae2ecb7961a54a5e641d90a053be1d77b62" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Category&lt;/code&gt; in the previous example can have the value (atom) &lt;code&gt;sys_config&lt;/code&gt; (blue background), &lt;code&gt;sys_state&lt;/code&gt; (yellow background), or &lt;code&gt;error&lt;/code&gt; (white text on red background).</source>
          <target state="translated">이전 예의 인수 &lt;code&gt;Category&lt;/code&gt; 에는 값 (원자) &lt;code&gt;sys_config&lt;/code&gt; (파란색 배경), &lt;code&gt;sys_state&lt;/code&gt; (노란색 배경) 또는 &lt;code&gt;error&lt;/code&gt; (빨간색 배경에 흰색 텍스트)가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf43e2c4fa0b2acf4779f5e6cae85724db020b9a" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ExtraOptions&lt;/code&gt; is added to the options found in the configuration file. If the same options are specified, the values from the configuration file overwrite &lt;code&gt;ExtraOptions&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;ExtraOptions&lt;/code&gt; 가 구성 파일에있는 옵션에 추가되었습니다. 동일한 옵션이 지정되면 구성 파일의 값이 &lt;code&gt;ExtraOptions&lt;/code&gt; 를 겹쳐 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c6e370d885f073ebe4056fc20b4ead3d6c0bc12b" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;FlagList&lt;/code&gt; must be &lt;code&gt;[]&lt;/code&gt; for receive tracing.</source>
          <target state="translated">수신 추적을 하려면 인수 &lt;code&gt;FlagList&lt;/code&gt; 가 &lt;code&gt;[]&lt;/code&gt; 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="63c68c228727c0c08a966c916cd09a8193ea4126" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;FlagList&lt;/code&gt; must be &lt;code&gt;[]&lt;/code&gt; for send tracing.</source>
          <target state="translated">송신 추적의 경우 인수 &lt;code&gt;FlagList&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="5969bfd1f2a4922bae1c797825bd94636e7492ca" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Fun&lt;/code&gt; can also be the atom &lt;code&gt;ignore&lt;/code&gt;, which indicates that only the metadata about the table is updated. Use of &lt;code&gt;ignore&lt;/code&gt; is not recommended (as it creates inconsistencies between the metadata and the actual data) but it is included as a possibility for the user do to an own (offline) transform.</source>
          <target state="translated">Argument &lt;code&gt;Fun&lt;/code&gt; 은 atom &lt;code&gt;ignore&lt;/code&gt; 일 수 있습니다 . 이는 테이블에 대한 메타 데이터 만 업데이트됨을 나타냅니다. 메타 데이터와 실제 데이터간에 불일치가 발생하므로 &lt;code&gt;ignore&lt;/code&gt; 사용 하지 않는 것이 좋지만 사용자가 자체 (오프라인) 변환을 수행 할 수있는 가능성으로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede8746fe6cfaaaacae3ce131c1347e609e2da3f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Importance&lt;/code&gt; specifies a level of importance that, compared to a verbosity level (general and/or set per category), determines if the printout is to be visible. &lt;code&gt;Importance&lt;/code&gt; is any integer in the range 0..99. Predefined constants exist in the &lt;code&gt;ct.hrl&lt;/code&gt; header file. The default importance level, &lt;code&gt;?STD_IMPORTANCE&lt;/code&gt; (used if argument &lt;code&gt;Importance&lt;/code&gt; is not provided), is 50. This is also the importance used for standard I/O, for example, from printouts made with &lt;code&gt;io:format/2&lt;/code&gt;, &lt;code&gt;io:put_chars/1&lt;/code&gt;, and so on.</source>
          <target state="translated">인수 &lt;code&gt;Importance&lt;/code&gt; 는 상세 수준 (일반 및 / 또는 범주별로 설정)과 비교하여 인쇄물을 볼 수 있는지 여부를 결정하는 중요도 수준을 지정합니다. &lt;code&gt;Importance&lt;/code&gt; 는 0..99 범위의 정수입니다. 미리 정의 된 상수는 &lt;code&gt;ct.hrl&lt;/code&gt; 헤더 파일에 있습니다. 기본 중요도 레벨 &lt;code&gt;?STD_IMPORTANCE&lt;/code&gt; ( &lt;code&gt;Importance&lt;/code&gt; 인수 가 제공되지 않은 경우에 사용됨 )는 50입니다. 이는 또한 표준 I / O에 사용되는 중요도입니다 (예 &lt;code&gt;io:format/2&lt;/code&gt; , &lt;code&gt;io:put_chars/1&lt;/code&gt; 로 작성된 출력물). , 등등.</target>
        </trans-unit>
        <trans-unit id="a74c242839b6e17cec6e9fda29e9cd4d39199929" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Length&lt;/code&gt; is meaningful only when the socket is in mode &lt;code&gt;raw&lt;/code&gt; and denotes the number of bytes to read. If &lt;code&gt;Length&lt;/code&gt; = 0, all available bytes are returned. If &lt;code&gt;Length&lt;/code&gt; &amp;gt; 0, exactly &lt;code&gt;Length&lt;/code&gt; bytes are returned, or an error; possibly discarding less than &lt;code&gt;Length&lt;/code&gt; bytes of data when the socket gets closed from the other side.</source>
          <target state="translated">인수 &lt;code&gt;Length&lt;/code&gt; 는 소켓이 &lt;code&gt;raw&lt;/code&gt; 모드 일 때만 의미가 있으며 읽을 바이트 수를 나타냅니다. 경우 &lt;code&gt;Length&lt;/code&gt; 0 = 사용 가능한 모든 바이트가 반환됩니다. 경우 &lt;code&gt;Length&lt;/code&gt; &amp;gt; 0, 정확히 &lt;code&gt;Length&lt;/code&gt; 바이트 반환 또는 오류된다 소켓이 다른 쪽에서 닫힐 때 &lt;code&gt;Length&lt;/code&gt; 바이트 미만 의 데이터를 버릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbac04ffb93617fd9cb7fd3fdb28dcbec27f1793" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Length&lt;/code&gt; is only meaningful when the socket is in &lt;code&gt;raw&lt;/code&gt; mode and denotes the number of bytes to read. If &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, all available bytes are returned. If &lt;code&gt;Length&lt;/code&gt; &amp;gt; &lt;code&gt;0&lt;/code&gt;, exactly &lt;code&gt;Length&lt;/code&gt; bytes are returned, or an error; possibly discarding less than &lt;code&gt;Length&lt;/code&gt; bytes of data when the socket is closed from the other side.</source>
          <target state="translated">인수 &lt;code&gt;Length&lt;/code&gt; 는 소켓이 &lt;code&gt;raw&lt;/code&gt; 모드 일 때만 의미가 있으며 읽을 바이트 수를 나타냅니다. 경우 &lt;code&gt;Length&lt;/code&gt; 입니다 &lt;code&gt;0&lt;/code&gt; , 사용 가능한 모든 바이트가 반환됩니다. 경우 &lt;code&gt;Length&lt;/code&gt; &amp;gt; &lt;code&gt;0&lt;/code&gt; , 정확히 &lt;code&gt;Length&lt;/code&gt; 바이트 반환 또는 오류된다 소켓이 다른 쪽에서 닫힐 때 &lt;code&gt;Length&lt;/code&gt; 바이트 미만 의 데이터를 버릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7df54cbc41d8be6702a7d18339b129a60b117176" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;MFA&lt;/code&gt; is to be a tuple, such as &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;, or the atom &lt;code&gt;on_load&lt;/code&gt; (described below). It can be the module, function, and arity for a function (or a BIF in any module). The atom &lt;code&gt;'_'&lt;/code&gt; can be used as a wildcard in any of the following ways:</source>
          <target state="translated">인수 &lt;code&gt;MFA&lt;/code&gt; 는 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 또는 atom &lt;code&gt;on_load&lt;/code&gt; (아래 설명) 와 같은 튜플이어야합니다 . 함수 (또는 모든 모듈의 BIF)에 대한 모듈, 함수 및 특성 일 수 있습니다. 원자 &lt;code&gt;'_'&lt;/code&gt; 는 다음과 같은 방법으로 와일드 카드로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5ab418823236be2e40f29077d515164f418559" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;MatchSpec&lt;/code&gt; can take the following forms:</source>
          <target state="translated">인수 &lt;code&gt;MatchSpec&lt;/code&gt; 은 다음과 같은 형식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="632db5ffef7ffbf7896b027d5a4845557c315e16" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Misc&lt;/code&gt; can be used to save internal data in a process, for example, its state. It is sent to &lt;code&gt;Module:system_continue/3&lt;/code&gt; or &lt;code&gt;Module:system_terminate/4&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Misc&lt;/code&gt; 를 사용하여 내부 데이터를 프로세스와 같은 프로세스에 저장할 수 있습니다 (예 : 상태). 그것은로 전송 &lt;code&gt;Module:system_continue/3&lt;/code&gt; 또는 &lt;code&gt;Module:system_terminate/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f490daf6a024205229629ca457c94764493e4043" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Modes&lt;/code&gt; is a list of possible modes, see &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, and defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Modes&lt;/code&gt; 는 가능한 모드의 목록입니다. &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 참조 하고 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c41785291fefd33e5c56b0234e5a635c5016d3b1" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;NodesOrDist&lt;/code&gt; can either be a list of nodes or the result from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;NodesOrDist&lt;/code&gt; is assumed to be a sorted list with the best nodes to host new replicas first in the list. The new fragment gets the same number of replicas as the first fragment (see &lt;code&gt;n_ram_copies&lt;/code&gt;, &lt;code&gt;n_disc_copies&lt;/code&gt;, and &lt;code&gt;n_disc_only_copies&lt;/code&gt;). The &lt;code&gt;NodesOrDist&lt;/code&gt; list must at least contain one element for each replica that needs to be allocated.</source>
          <target state="translated">인수 &lt;code&gt;NodesOrDist&lt;/code&gt; 는 노드 목록이거나 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 함수의 결과 일 수 있습니다 . Argument &lt;code&gt;NodesOrDist&lt;/code&gt; 는 목록에서 먼저 새 복제본을 호스팅하기에 가장 적합한 노드가있는 정렬 된 목록 인 것으로 가정합니다. 새 조각은 첫 번째 조각과 동일한 수의 복제본을 가져옵니다 ( &lt;code&gt;n_ram_copies&lt;/code&gt; , &lt;code&gt;n_disc_copies&lt;/code&gt; 및 &lt;code&gt;n_disc_only_copies&lt;/code&gt; 참조 ). &lt;code&gt;NodesOrDist&lt;/code&gt; 의 목록 반드시 적어도 요구를 할당 할 것을 각 복제본 하나 개의 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d85843a85d8a0d52723585742b11afd0899160" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;OptionList&lt;/code&gt; can be used to specify certain behavior regarding ports and triggering monitors under certain conditions:</source>
          <target state="translated">인수 &lt;code&gt;OptionList&lt;/code&gt; 를 사용하여 특정 조건에서 포트 및 트리거링 모니터와 관련된 특정 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de736e1203b55111eca5eccfabbf9c9e91ef73a2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Options&lt;/code&gt; is a list of &lt;code&gt;{Key, Val}&lt;/code&gt; tuples, where the following values are allowed:</source>
          <target state="translated">인수 &lt;code&gt;Options&lt;/code&gt; 은 다음 값이 허용되는 &lt;code&gt;{Key, Val}&lt;/code&gt; 튜플 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="f846b2639fdccdd7fe83e5494fa41e5843c66eb2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;PreArgs&lt;/code&gt; is a list of tagged values. There are two tags, &lt;code&gt;parent_value&lt;/code&gt; and &lt;code&gt;stop_fun&lt;/code&gt;, used by Mnesia for managing transactions.</source>
          <target state="translated">인수 &lt;code&gt;PreArgs&lt;/code&gt; 는 태그가 지정된 값의 목록입니다. Mnesia에서 트랜잭션 관리를 위해 사용하는 &lt;code&gt;parent_value&lt;/code&gt; 및 &lt;code&gt;stop_fun&lt;/code&gt; 태그가 두 개 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f20a5312d5f256e87436cce6c76d1a556dfbb0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Server&lt;/code&gt; in the SFTP functions is only to be used for SFTP sessions that have been started on existing SSH connections (that is, when the original connection type is &lt;code&gt;ssh&lt;/code&gt;). Whenever the connection type is &lt;code&gt;sftp&lt;/code&gt;, use the SSH connection reference only.</source>
          <target state="translated">SFTP 기능의 인수 &lt;code&gt;Server&lt;/code&gt; 는 기존 SSH 연결에서 시작된 (즉, 원래 연결 유형이 &lt;code&gt;ssh&lt;/code&gt; 인 경우 ) SFTP 세션에만 사용됩니다 . 연결 유형이 &lt;code&gt;sftp&lt;/code&gt; 인 경우 SSH 연결 참조 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="127495432a40845ab9ada867dc7fc2fee4865175" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SnmpStruct&lt;/code&gt; is a list of SNMP information. Currently, the only information needed is information about the key types in the table. Multiple keys cannot be handled in Mnesia, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is &lt;code&gt;fix_string&lt;/code&gt;. This means that a string has a fixed size.</source>
          <target state="translated">인수 &lt;code&gt;SnmpStruct&lt;/code&gt; 는 SNMP 정보 목록입니다. 현재 필요한 유일한 정보는 테이블의 키 유형에 대한 정보입니다. Mnesia에서 여러 키를 처리 할 수 ​​없지만 많은 SNMP 테이블에 여러 키가 있습니다. 따라서 다음 규칙이 사용됩니다. 테이블에 여러 키가있는 경우 항상 키 튜플로 저장해야합니다. 주요 유형에 대한 정보는 유형을 설명하는 원자의 튜플로 지정됩니다. 유일하게 중요한 유형은 &lt;code&gt;fix_string&lt;/code&gt; 입니다. 이것은 문자열의 크기가 고정되어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="134ccc578ec25f4a1b41da580e909377b6e00202" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SpawnOpts&lt;/code&gt;, if specified, is passed as the last argument to the &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF.</source>
          <target state="translated">Argument &lt;code&gt;SpawnOpts&lt;/code&gt; 가 지정된 경우 &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF에 마지막 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3cedb4f6297db65a16db517b2fa86b4c83da9c5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;State&lt;/code&gt; is a tuple &lt;code&gt;{ShellState,ExprState}&lt;/code&gt;. The return value &lt;code&gt;NewState&lt;/code&gt; has the same form. This can be used to carry a state between calls to the callback functions. Data saved in &lt;code&gt;ShellState&lt;/code&gt; lives through an entire shell session. Data saved in &lt;code&gt;ExprState&lt;/code&gt; lives only through the evaluation of the current expression.</source>
          <target state="translated">인수 &lt;code&gt;State&lt;/code&gt; 는 튜플 &lt;code&gt;{ShellState,ExprState}&lt;/code&gt; 입니다. 반환 값 &lt;code&gt;NewState&lt;/code&gt; 는 같은 형식입니다. 콜백 함수 호출 사이의 상태를 전달하는 데 사용할 수 있습니다. &lt;code&gt;ShellState&lt;/code&gt; 에 저장된 데이터 는 전체 셸 세션을 통해 유지됩니다. &lt;code&gt;ExprState&lt;/code&gt; 에 저장된 데이터 는 현재 표현식의 평가를 통해서만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="4b4b0aee165785dc7cf379568e4015cc77271225" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented float (the digits are ASCII values). Remaining characters in the string after the float are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;String&lt;/code&gt; 은 float로 표시되는 유효한 텍스트로 시작해야합니다 (숫자는 ASCII 값). float 후 문자열의 나머지 문자는 &lt;code&gt;Rest&lt;/code&gt; 에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="99bddf0ad5e13463903ca5db19b6f229eaaa62d0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented integer (the digits are ASCII values). Remaining characters in the string after the integer are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;String&lt;/code&gt; 은 정수로 표시되는 유효한 텍스트로 시작해야합니다 (숫자는 ASCII 값). 정수 뒤에 문자열의 나머지 문자는 &lt;code&gt;Rest&lt;/code&gt; 에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f022d7270d5362d0771335ef05b9154a045868e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Type&lt;/code&gt; specifies the type of the application. If omitted, it defaults to &lt;code&gt;temporary&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Type&lt;/code&gt; 은 응용 프로그램의 유형을 지정합니다. 생략하면 기본값은 &lt;code&gt;temporary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52529ec5b3dbe90218521bf7062ae0ba51481ae8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; identifies the event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket, pipe or other file descriptor object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use.</source>
          <target state="translated">인수 &lt;code&gt;event&lt;/code&gt; 는 이벤트 객체를 식별합니다. 유닉스 시스템에서는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 기능 이 사용됩니다. 이벤트 오브젝트는 소켓, 파이프 또는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 이 사용할 수있는 다른 파일 디스크립터 오브젝트 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c82d16dce6414cf83d8d93f8e672741f4d9ca8a" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; is not a valid OS event object.</source>
          <target state="translated">인수 &lt;code&gt;event&lt;/code&gt; 가 유효한 OS 이벤트 객체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7980baebdda9326ef971ef864a7e3442b2b16145" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;index&lt;/code&gt; is updated, that is, this function can be viewed as a decode function that decodes a term into a human-readable format.</source>
          <target state="translated">인수 &lt;code&gt;index&lt;/code&gt; 가 업데이트됩니다. 즉,이 함수는 용어를 사람이 읽을 수있는 형식으로 디코딩하는 디코딩 함수로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75ce9ef93d0395faba2903cbdd1f49f30b2929e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;init&lt;/code&gt; is a pointer to an &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; structure that contains the function pointers for destructor, down and stop callbacks for the resource type.</source>
          <target state="translated">인수 &lt;code&gt;init&lt;/code&gt; 은 자원 유형에 대한 소멸자, 다운 및 중지 콜백에 대한 함수 포인터를 포함 하는 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; 구조에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="9dfed7a573331b550431a030fa57b0d3e26d11e8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;mode&lt;/code&gt; describes the type of events to wait for. It can be &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt;, &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; or a bitwise OR combination to wait for both. It can also be &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; which is described further below. When a read or write event is triggered, a notification message like this is sent to the process identified by &lt;code&gt;pid&lt;/code&gt;:</source>
          <target state="translated">인수 &lt;code&gt;mode&lt;/code&gt; 는 대기 할 이벤트 유형을 설명합니다. &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt; , &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; 또는 비트 OR 조합 일 수 있습니다 . 또한 아래에 자세히 설명 된 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 일 수 있습니다 . 읽기 또는 쓰기 이벤트가 트리거되면 다음과 같은 알림 메시지가 &lt;code&gt;pid&lt;/code&gt; 로 식별 된 프로세스로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a90058d12d7cac1628a470a0a7fcf5ea024b094" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is a resource object obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. The purpose of the resource objects is as a container of the event object to manage its state and lifetime. A handle to the resource is received in the notification message as &lt;code&gt;Obj&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;obj&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 에서 얻은 자원 객체 입니다. 자원 객체의 목적은 상태 및 수명을 관리하기위한 이벤트 객체의 컨테이너입니다. 자원에 대한 핸들은 알림 메시지에서 &lt;code&gt;Obj&lt;/code&gt; 로 수신됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
